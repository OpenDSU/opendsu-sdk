pskWebServerRequire=(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({"/home/runner/work/opendsu-sdk/opendsu-sdk/builds/tmp/pskWebServer.js":[function(require,module,exports){
if(typeof $$ === "undefined" || !$$.environmentType) {
    const or = require('overwrite-require');
    or.enableForEnvironment(or.constants.NODEJS_ENVIRONMENT_TYPE);
} else {
    console.log('VirtualMQ running in test environment');
}

require("./pskWebServer_intermediar");
},{"./pskWebServer_intermediar":"/home/runner/work/opendsu-sdk/opendsu-sdk/builds/tmp/pskWebServer_intermediar.js","overwrite-require":"overwrite-require"}],"/home/runner/work/opendsu-sdk/opendsu-sdk/builds/tmp/pskWebServer_intermediar.js":[function(require,module,exports){
(function (global){(function (){
global.pskWebServerLoadModules = function(){ 

	if(typeof $$.__runtimeModules["overwrite-require"] === "undefined"){
		$$.__runtimeModules["overwrite-require"] = require("overwrite-require");
	}

	if(typeof $$.__runtimeModules["pskcrypto"] === "undefined"){
		$$.__runtimeModules["pskcrypto"] = require("pskcrypto");
	}

	if(typeof $$.__runtimeModules["psk-cache"] === "undefined"){
		$$.__runtimeModules["psk-cache"] = require("psk-cache");
	}

	if(typeof $$.__runtimeModules["opendsu"] === "undefined"){
		$$.__runtimeModules["opendsu"] = require("opendsu");
	}

	if(typeof $$.__runtimeModules["acl-magic"] === "undefined"){
		$$.__runtimeModules["acl-magic"] = require("acl-magic");
	}

	if(typeof $$.__runtimeModules["cloud-enclave"] === "undefined"){
		$$.__runtimeModules["cloud-enclave"] = require("cloud-enclave");
	}

	if(typeof $$.__runtimeModules["fast-svd"] === "undefined"){
		$$.__runtimeModules["fast-svd"] = require("fast-svd");
	}

	if(typeof $$.__runtimeModules["bar"] === "undefined"){
		$$.__runtimeModules["bar"] = require("bar");
	}

	if(typeof $$.__runtimeModules["bar-fs-adapter"] === "undefined"){
		$$.__runtimeModules["bar-fs-adapter"] = require("bar-fs-adapter");
	}

	if(typeof $$.__runtimeModules["key-ssi-resolver"] === "undefined"){
		$$.__runtimeModules["key-ssi-resolver"] = require("key-ssi-resolver");
	}

	if(typeof $$.__runtimeModules["apihub"] === "undefined"){
		$$.__runtimeModules["apihub"] = require("apihub");
	}

	if(typeof $$.__runtimeModules["syndicate"] === "undefined"){
		$$.__runtimeModules["syndicate"] = require("syndicate");
	}

	if(typeof $$.__runtimeModules["buffer-crc32"] === "undefined"){
		$$.__runtimeModules["buffer-crc32"] = require("buffer-crc32");
	}

	if(typeof $$.__runtimeModules["node-fd-slicer"] === "undefined"){
		$$.__runtimeModules["node-fd-slicer"] = require("node-fd-slicer");
	}

	if(typeof $$.__runtimeModules["psk-http-client"] === "undefined"){
		$$.__runtimeModules["psk-http-client"] = require("psk-http-client");
	}

	if(typeof $$.__runtimeModules["swarmutils"] === "undefined"){
		$$.__runtimeModules["swarmutils"] = require("swarmutils");
	}

	if(typeof $$.__runtimeModules["queue"] === "undefined"){
		$$.__runtimeModules["queue"] = require("queue");
	}

	if(typeof $$.__runtimeModules["soundpubsub"] === "undefined"){
		$$.__runtimeModules["soundpubsub"] = require("soundpubsub");
	}

	if(typeof $$.__runtimeModules["loki-enclave-facade"] === "undefined"){
		$$.__runtimeModules["loki-enclave-facade"] = require("loki-enclave-facade");
	}
};
if (false) {
	pskWebServerLoadModules();
}
global.pskWebServerRequire = require;
if (typeof $$ !== "undefined") {
	$$.requireBundle("pskWebServer");
}

}).call(this)}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"acl-magic":"acl-magic","apihub":"apihub","bar":"bar","bar-fs-adapter":"bar-fs-adapter","buffer-crc32":"buffer-crc32","cloud-enclave":"cloud-enclave","fast-svd":"fast-svd","key-ssi-resolver":"key-ssi-resolver","loki-enclave-facade":"loki-enclave-facade","node-fd-slicer":"node-fd-slicer","opendsu":"opendsu","overwrite-require":"overwrite-require","psk-cache":"psk-cache","psk-http-client":"psk-http-client","pskcrypto":"pskcrypto","queue":"queue","soundpubsub":"soundpubsub","swarmutils":"swarmutils","syndicate":"syndicate"}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/acl-magic/lib/cache.js":[function(require,module,exports){
/*
    A simple cache implementation that periodically removes everything from cache.
    We purge everything to avoid consuming too much memory in large systems. This should be enough for normal usages.
    For an highly optimised version, ask our commercial offers.
 */

function ExpiringCache(expireTime){
    var storage = {};
    function initilise(space, key){
        if(!storage[space]){
            storage[space] = {};
        }

        if(!storage[space][key]){
            storage[space][key] = {};
        }
    }

    this.insertValue = function(space, key, value){
        initilise(space, key);
        storage[space][key][value] = value;
    }

    this.removeValue = function(space, key, value ){
        initilise(space, key);
        delete storage[space][key][value];
    }


    var err = new Error();
    this.loadAll = function(space, key, callback){
        var arr = [];
        if(!storage[space] || !storage[space][key]){
            callback(err, null);
            return ;
        }

        for(var v in storage[space][key]){
            arr.push(v);
        }
        callback(null, arr);
    }

    function autoClean(){
        storage = {};
        setTimeOut(expireTime,autoClean);
    }

}


module.exports.createCache = function(expireTime){
    return new ExpiringCache(expireTime);
}
},{}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/acl-magic/lib/persistence.js":[function(require,module,exports){

/*
        generic persistence for ACLs. Provide insert, remove and loadSet functions to create a persistence for other databases
*/

function GenericPersistence(cache, insertFunc, removeFunc, loadSet, existsResource) {

    function insertValue(space, key, value, callback) {
        cache.insertValue(space, key, value);
        if (insertFunc) {
            return insertFunc(space, key, value, callback);
        }

        if(callback){
            callback();
        }
    }

    function removeValue(space, key, value, callback) {
        cache.removeValue(space, key, value);
        if (removeFunc) {
            return removeFunc(space, key, value, callback);
        }

        if (callback) {
            callback();
        }
    }

    function loadAll(space, key, callback) {
        cache.loadAll(space, key, function (err, res) {
            if (err) {
                if (loadSet) {
                    loadSet(space, key, callback);
                }
            } else {
                callback(null, res);
            }
        });
    }

    this.addResourceParent = function (resourcesUID, parentUID, callback) {
        insertValue("resources", resourcesUID, parentUID, callback);
    }

    this.addZoneParent = function (zoneId, parentZoneId, callback) {
        insertValue("zones", zoneId, parentZoneId, callback);
    }

    this.delResourceParent = function (resourcesUID, parentUID, callback) {
        removeValue("resources", resourcesUID, parentUID, callback);
    }

    this.delZoneParent = function (zoneId, parentZoneId, callback) {
        removeValue("zones", zoneId, parentZoneId, callback);
    }

    this.loadZoneParents = function (zoneId, callback) {
        var resObj = {};
        var waitingCounter = 0;
        var self = this;

        var mkResArray = function () {
            var res = [zoneId];
            for (var v in resObj) {
                res.push(v);
            }
            return res;
        }

        function loadOneLevel(zoneId) {
            waitingCounter++;
            loadAll("zones", zoneId, function (err, arr) {
                arr.map(function (i) {
                    resObj[i] = i;
                    loadOneLevel(i);
                })
                waitingCounter--;
                if (0 == waitingCounter) {
                    callback(null, mkResArray());
                }
            });
        }

        loadOneLevel(zoneId);

    }

    this.grant = function (concernName, zoneId, resourceId, callback) {
        insertValue(concernName, resourceId, zoneId, callback);
    }

    this.ungrant = function (concernName, zoneId, resourceId, callback) {
        removeValue(concernName, resourceId, zoneId, callback);
    }


    this.loadResourceDirectParents = function (resourceId, callback) {
        loadAll("resources", resourceId, callback);
    }


    this.loadResourceDirectGrants = function (concern, resourceId, callback) {
        loadAll(concern, resourceId, callback);
    }


    this.getProperty = function (propertyName, callback) {
        var props = loadAll.nasync("acl-properties", propertyName);
        (function (props) {
            if (props) {
                var value = props[propertyName];
                callback(null, value);
            } else {
                callback(null, false);
            }
        }).wait(props)
    }

    this.setProperty = function (propertyName, value, callback) {
        insertValue("acl-properties", propertyName, value, callback);
    }

    this.localResourceExists = function (localResourceName, resourceType, callback) {
        if (existsResource) {
            existsResource(localResourceName, resourceType, callback)
        }
        else {
            callback("Implementation not provided for resource existence verification")
        }
    }
}



/*
 Dummy cache with no expiration or other behaviour
 */


function NoExpireCache() {
    var storage = {};
    function initialise(space, key) {
        if (!storage[space]) {
            storage[space] = {};
        }

        if (!storage[space][key]) {
            storage[space][key] = {};
        }
    }

    this.insertValue = function (space, key, value) {
        initialise(space, key);
        storage[space][key][value] = value;
    }

    this.removeValue = function (space, key, value) {
        initialise(space, key);
        delete storage[space][key][value];
    }


    this.loadAll = function (space, key, callback) {
        var arr = [];
        initialise(space, key);
        for (var v in storage[space][key]) {
            arr.push(v);
        }
        callback(null, arr);
    }
}

module.exports.createEnclavePersistence = function (enclave, cache, type) {
    if (!cache) {
        cache = new NoExpireCache();
    }
    function mkKey(space, key) {
        if (type) {
            return "acl_magic_" + type + "_" + space + "_" + key;

        } else {
            return "acl_magic_" + space + "_" + key;
        }
    }

    return new GenericPersistence(cache,
        function (space, key, value, callback) {
            enclave._insertRecord(mkKey(space, key), value, { value: value }, callback)
        },
        function (space, key, value, callback) {
            enclave._deleteRecord(mkKey(space, key), value, callback)
        },
        function (space, key, callback) {
            enclave._getAllRecords(mkKey(space, key), (err, results) => {
                if (err) {
                    return callback(err);
                }
                if (!results) {
                    callback(undefined, [])
                    return;
                }
                if (Object.keys(results).length == 0) {
                    results = []
                }
                callback(null, results.map(result => result.value))
            })
        },
        function (localResourceName, resourceType, callback) {
            enclave._getAllRecords(mkKey("resources", localResourceName), (err, results) => {
                if (err) {
                    return callback(err, null);
                }
                if (results.length == 0 || Object.keys(results).length == 0) {
                    return callback(null, false)
                }
                return callback(null, results.find(parent => parent.pk == resourceType) !== undefined)
            })
        }
    );
}


module.exports.createMemoryPersistence = function () {
    return new GenericPersistence(new NoExpireCache());
}




},{}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/apihub/components/activeComponents/index.js":[function(require,module,exports){
module.exports = function (server){

    function getEndpointRow(endpoint){
        //return endpoint;
        let enabled = true;
        if(["get", "head"].indexOf(endpoint.method) === -1 && server.readOnlyModeActive){
            enabled = false;
        }
        return `<div class="row">
                    <div class="cell">endpoint</div>
                    <div class="cell">${endpoint.method}</div>
                    <div class="cell">${endpoint.url}</div>
                    <div class="cell">${enabled}</div>
                </div>`;
    }

    function getMiddlewareRow(endpoint){
        //return endpoint;
        let enabled = "PUT, POST, DELETE methods are disabled in readOnly";
        return `<div class="row">
                    <div class="cell">middleware</div>
                    <div class="cell">${endpoint.method ? endpoint.method : "ALL"}</div>
                    <div class="cell">${endpoint.url ? endpoint.url : "-"} [${endpoint.fn.name}]</div>
                    <div class="cell">${enabled}</div>
                </div>`;
    }

    function testIfEndpoint(endpoint){
        return !!endpoint.url && !!endpoint.method;
    }

    function testIfMiddleware(endpoint){
        return !testIfEndpoint(endpoint) && !!endpoint.fn.name;
    }

    server.get("/listActiveComponents", async function(req, res){
        let template = require("./template.js");
        let $$HEADER = "";

        let endpoints = server.getRegisteredMiddlewareFunctions();
        let $$ACTIVE_COMPONENTS = '';
        let endpointsCounter = 0;
        let middlewaresCounter = 0;
        for(let endpoint of endpoints){
            if(testIfEndpoint(endpoint)){
                endpointsCounter++;
                $$ACTIVE_COMPONENTS += getEndpointRow(endpoint);
            }
            if(testIfMiddleware(endpoint)){
                middlewaresCounter++;
                $$ACTIVE_COMPONENTS += getMiddlewareRow(endpoint);
            }
        }
        $$HEADER = `
        <div>
        No. middlewares: ${middlewaresCounter}
        <br>
        No. endpoints: ${endpointsCounter}
        </div>
        `;
        template = template.replace("$$HEADER", $$HEADER);
        template = template.replace("$$ACTIVE_COMPONENTS", $$ACTIVE_COMPONENTS);

        res.statusCode = 200;
        res.end(template);
    });
}
},{"./template.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/apihub/components/activeComponents/template.js"}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/apihub/components/activeComponents/template.js":[function(require,module,exports){
module.exports = `
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Active Components</title>
    <style>
        .table {
            display: table;
        }

        .row {
            display: table-row;
        }

        .cell {
            display: table-cell;
            border: 1px solid black;
            padding: 1em;
        }
    </style>
</head>
<body>
$$HEADER
<div class="table">
    <div class="row">
        <div class="cell">TYPE</div>
        <div class="cell">HTTP METHOD</div>
        <div class="cell">PATH [MIDDLEWARE NAME]</div>
        <div class="cell">ACTIVE</div>
    </div>
    $$ACTIVE_COMPONENTS
</div>
</body>
</html>`;
},{}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/apihub/components/admin/index.js":[function(require,module,exports){
const DATABASE_NAME = "adminEnclave";
const DATABASE_PERSISTENCE_TIMEOUT = 100;

const DOMAINS_TABLE = "domains";
const ADMINS_TABLE = "admins";
const VARIABLES_TABLE = "variables";
const TEMPLATES_TABLE = "templates";

const DID_replacement = "";

let internalServerRef;

function getStorageFolder() {
    const config = internalServerRef.config;

    return require("path").join(internalServerRef.rootFolder, config.componentsConfig.admin.storageFolder);
}

function getMainDomainStorageFile() {
    const storageFolder = getStorageFolder();
    return require("path").join(storageFolder, "mainDomain");
}

function getEnclave() {
    const storageFolder = require("path").join(getStorageFolder(), DATABASE_NAME);
    const lokiEnclaveFacadeModule = require("loki-enclave-facade");
    const createLokiEnclaveFacadeInstance = lokiEnclaveFacadeModule.createLokiEnclaveFacadeInstance;
    return createLokiEnclaveFacadeInstance(storageFolder, DATABASE_PERSISTENCE_TIMEOUT, lokiEnclaveFacadeModule.Adaptors.FS);
}

function getMainDomain(callback) {
    const FS = "fs";
    const fs = require(FS);
    fs.readFile(getMainDomainStorageFile(), callback);
}

function saveMainDomain(domain, callback) {
    getMainDomain((err, mainDomain) => {
        if (err || !mainDomain) {
            const FS = "fs";
            const fs = require(FS);
            fs.mkdir(getStorageFolder(), {recursive: true}, (err) => {
                if (err) {
                    return callback(err);
                }
                fs.writeFile(getMainDomainStorageFile(), domain, {}, callback);
            });
        } else {
            return callback(`There is a domain set as mainDomain. Not able to save <${domain}> as main domain.`);
        }
    });
}

function isMainDomain(domain, callback) {
    getMainDomain((err, mainDomain) => {
        if (err || !mainDomain) {
            return saveMainDomain(domain, (err) => {
                if (err) {
                    return callback(err);
                }
                callback(undefined, true);
            });
        }
        return callback(undefined, mainDomain.toString() === domain);
    });
}

function AdminComponentHandler(server) {

    internalServerRef = server;

    let adminService = new AdminService(true);

    async function enforceMainDomainMiddleware(req, res, next) {
        let {mainDomain} = req.params;
        let testIfMainDomain = $$.promisify(isMainDomain);
        try {
            let isMain = await testIfMainDomain(mainDomain);
            if (!isMain) {
                res.statusCode = 403;
                return res.end();
            }
        } catch (err) {
            res.statusCode = 500;
            return res.end();
        }
        next();
    }

    async function addDomain(req, res) {
        let {domainName, timestamp, signature, cloneFromDomain} = req.body;

        if (!cloneFromDomain) {
            res.statusCode = 403;
            res.end();
        }

        try {
            await adminService.addDomainAsync(domainName, cloneFromDomain, timestamp, signature);
        } catch (err) {
            res.statusCode = 500;
            return res.end();
        }

        res.statusCode = 200;
        res.end();
    }

    async function disableDomain(req, res) {
        let {domainName, timestamp, signature} = req.body;
        try {
            await adminService.disableDomainAsync(domainName, timestamp, signature);
        } catch (err) {
            res.statusCode = 500;
            return res.end();
        }

        res.statusCode = 200;
        res.end();
    }

    async function addAdmin(req, res) {
        let {did, timestamp, signature} = req.body;

        try {
            await adminService.registerAdminAsync(did, timestamp, signature);
        } catch (err) {
            res.statusCode = 500;
            return res.end();
        }

        res.statusCode = 200;
        res.end();
    }

    async function addDomainAdmin(req, res) {
        let {domain, did, timestamp, signature} = req.body;

        try {
            await adminService.registerDomainAdminAsync(domain, did, timestamp, signature);
        } catch (err) {
            res.statusCode = 500;
            return res.end();
        }

        res.statusCode = 200;
        res.end();
    }

    async function registerTemplate(req, res) {
        let {path, content, timestamp, signature} = req.body;
        try {
            await adminService.registerTemplateAsync(path, content, timestamp, signature);
        } catch (err) {
            res.statusCode = 500;
            return res.end();
        }

        res.statusCode = 200;
        res.end();
    }

    async function setVariable(req, res) {
        let {dnsDomain, variableName, variableContent, timestamp, signature} = req.body;

        try {
            await adminService.registerVariableAsync(dnsDomain, variableName, variableContent, timestamp, signature);
        } catch (err) {
            res.statusCode = 500;
            return res.end();
        }

        res.statusCode = 200;
        res.end();
    }

    server.use("/admin/:mainDomain/*", enforceMainDomainMiddleware);

    server.use("/admin/*", require("./../../utils/middlewares/index").requestBodyJSONMiddleware);

    server.post("/admin/:mainDomain/addDomain", addDomain);
    server.post("/admin/:mainDomain/disableDomain", disableDomain);
    server.post("/admin/:mainDomain/addAdmin", addAdmin);
    server.post("/admin/:mainDomain/addDomainAdmin", addDomainAdmin);
    server.post("/admin/:mainDomain/storeVariable", setVariable);
    server.post("/admin/:mainDomain/registerTemplate", registerTemplate);
}

function AdminService(exposeAllApis) {
    const enclave = getEnclave();

    this.getDomains = function (callback) {
        enclave.getAllRecords(DID_replacement, DOMAINS_TABLE, callback);
    }

    this.getDomainInfo = function (domainName, callback) {
        enclave.getRecord(DID_replacement, DOMAINS_TABLE, domainName, (err, domainInfo) => {
            //cleanup domain obj before returning it
            return callback(err, domainInfo);
        });
    }

    this.getMainDomain = getMainDomain;

    this.checkForTemplate = function (path, callback) {
        enclave.getRecord(DID_replacement, TEMPLATES_TABLE, path, (err, template) => {
            //cleanup template obj before returning it
            return callback(err, template);
        });
    }

    this.checkIfAdmin = function (did, callback) {
        enclave.getRecord(DID_replacement, ADMINS_TABLE, did, (err, admin) => {
            if (err || !admin) {
                return callback(undefined, false);
            }
            return callback(undefined, true);
        });
    }

    this.checkIfDomainAdmin = function (domainName, did, callback) {
        enclave.getRecord(DID_replacement, DOMAINS_TABLE, domainName, (err, domain) => {
            if (err || !domain || !domain.admins || domain.admins.indexOf(did) === -1) {
                return callback(undefined, false);
            }

            return callback(undefined, true);
        });
    }

    this.getDomainSpecificVariables = function (dnsDomainName, callback) {
        enclave.getRecord(DID_replacement, VARIABLES_TABLE, dnsDomainName, (err, entry) => {
            if (err) {
                return callback(err);
            }

            if (!entry) {
                return callback(`Not able to find domain ${dnsDomainName}.`);
            }

            return callback(undefined, entry.variables || {});
        });
    }

    //from this line down there are only methods that change the state of the enclave.
    if (exposeAllApis) {
        this.addDomain = async function (domainName, cloneFromDomain, timestamp, signature, callback) {
            enclave.insertRecord(DID_replacement, DOMAINS_TABLE, domainName, {
                name: domainName,
                active: true,
                cloneFromDomain
            }, callback);
        }

        this.addDomainAsync = $$.promisify(this.addDomain);

        this.disableDomain = async function (domainName, timestamp, signature, callback) {
            enclave.updateRecord(DID_replacement, DOMAINS_TABLE, domainName, {
                name: domainName,
                active: false
            }, callback);
        }

        this.disableDomainAsync = $$.promisify(this.disableDomain);

        this.registerAdmin = function (did, timestamp, signature, callback) {
            enclave.insertRecord(DID_replacement, ADMINS_TABLE, did, {did, active: true}, callback);
        }

        this.registerAdminAsync = $$.promisify(this.registerAdmin);

        this.registerDomainAdmin = function (domainName, did, timestamp, signature, callback) {
            enclave.getRecord(DID_replacement, DOMAINS_TABLE, domainName, (err, domain) => {
                if (err) {
                    return callback(err);
                }

                if (!domain.admins) {
                    domain.admins = [];
                }
                domain.admins.push(did);

                enclave.updateRecord(DID_replacement, DOMAINS_TABLE, domainName, domain, callback);
            });
        }

        this.registerDomainAdminAsync = $$.promisify(this.registerDomainAdmin);

        this.registerVariable = function (dnsDomain, variableName, variableContent, timestamp, signature, callback) {
            enclave.getRecord(DID_replacement, VARIABLES_TABLE, dnsDomain, (err, entry) => {
                if (err || !entry) {
                    entry = {
                        variables: {}
                    };
                    entry.variables[variableName] = variableContent;
                    enclave.insertRecord(DID_replacement, VARIABLES_TABLE, dnsDomain, entry, callback);
                }

                if (!entry.variables) {
                    entry.variables = {};
                }

                entry.variables[variableName] = variableContent;

                enclave.updateRecord(DID_replacement, VARIABLES_TABLE, dnsDomain, entry, callback);
            });
        }
        this.registerVariableAsync = $$.promisify(this.registerVariable);

        this.registerTemplate = function (path, content, timestamp, signature, callback) {
            enclave.getRecord(DID_replacement, TEMPLATES_TABLE, path, (err, template) => {
                if (err || !template) {
                    return enclave.insertRecord(DID_replacement, TEMPLATES_TABLE, path, {content}, callback);
                }
                enclave.updateRecord(DID_replacement, TEMPLATES_TABLE, path, {content}, callback);
            })
        }

        this.registerTemplateAsync = $$.promisify(this.registerTemplate);
    }

    return this;
}

function getAdminService() {
    if (!internalServerRef) {
        let error = new Error("AdminComponentHandler is not enabled!");
        error.rootCause = "disabled-by-config";
        throw error;
    }

    return new AdminService();
}

module.exports = {
    AdminComponentHandler,
    getAdminService
};
},{"./../../utils/middlewares/index":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/apihub/utils/middlewares/index.js","loki-enclave-facade":"loki-enclave-facade","path":false}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/apihub/components/anchoring/controllers/index.js":[function(require,module,exports){
const {ALIAS_SYNC_ERR_CODE} = require("../utils");
const utils = require("../utils");
const anchoringStrategies = require("../strategies");
const logger = $$.getLogger("apihub", "anchoring");
const getStrategy = async (request) => {
    let receivedDomain;
    let domainConfig;
    if (request.params.anchorId) {
        try {
            receivedDomain = utils.getDomainFromKeySSI(request.params.anchorId);
        } catch (e) {
            throw Error(`[Anchoring] Unable to parse anchor id`);
        }

        if (receivedDomain !== request.params.domain) {
            throw Error(`[Anchoring] Domain mismatch: '${receivedDomain}' != '${request.params.domain}'`);
        }

        domainConfig = await utils.getAnchoringDomainConfig(receivedDomain);
        if (!domainConfig) {
            throw Error(`[Anchoring] Domain '${receivedDomain}' not found`);
        }
    }

    if (request.params.domain) {
        domainConfig = await utils.getAnchoringDomainConfig(request.params.domain);
    }

    if (!domainConfig) {
        throw Error(`[Anchoring] Unable to identify domain. Check configuration or api call required params.`);
    }


    const StrategyClass = anchoringStrategies[domainConfig.type];
    if (!StrategyClass) {
        throw Error(`[Anchoring] Strategy for anchoring domain '${domainConfig.type}' not found`);
    }

    let strategy;
    try {
        strategy = new StrategyClass(request.server, domainConfig, request.params.anchorId, request.params.anchorValue, request.body);
    } catch (e) {
        throw Error(`[Anchoring] Unable to initialize anchoring strategy`);
    }

    return strategy;
}

function getWritingHandler(response) {
    return (err) => {
        if (err) {
            const errorMessage = typeof err === "string" ? err : err.message;
            if (err.code === "EACCES" || err.code === 409) {
                return response.send(409, errorMessage);
            } else if (err.code === ALIAS_SYNC_ERR_CODE || err.statusCode === 428) {
                // see: https://tools.ietf.org/html/rfc6585#section-3
                return response.send(428, errorMessage);
            } else if (err.code === 403) {
                return response.send(403, errorMessage);
            }
            logger.error("Caught an error", JSON.stringify(err));
            return response.send(500, errorMessage);
        }

        response.send(201);
    };
}

async function updateAnchor(action, request, response) {
    let strategy;
    try {
        strategy = await getStrategy(request);
    } catch (e) {
        logger.info(0x01, `Failed to get anchoring strategy`, e);
        return response.send(500, e);
    }
    strategy[action](getWritingHandler(response));
}


function getReadingHandler(response) {
    return (err, result) => {
        if (err) {
            console.error("Could not retrieve anchor", err);
            return response.send(500, "Could not retrieve anchor");
        }

        if (!result) {
            logger.info(0x01, `Anchor not found`);
            return response.send(404);
        }

        if(Array.isArray(result) && result.length === 0){
            logger.info(0x01, `Anchor not found`);
            return response.send(404);
        }

        if (typeof result === "object") {
            response.setHeader("Content-Type", "application/json");
        }

        response.send(200, result);
    }
}

async function readDataForAnchor(action, request, response) {
    let strategy;
    try {
        strategy = await getStrategy(request);
    } catch (e) {
        logger.info(0x01, `Failed to get anchoring strategy`, e);
        return response.send(500, e);
    }
    strategy[action](getReadingHandler(response));
}


function createAnchor(request, response) {
    updateAnchor("createAnchor", request, response);
}

function appendToAnchor(request, response) {
    updateAnchor("appendAnchor", request, response);
}

function createOrUpdateMultipleAnchors(request, response) {
    updateAnchor("createOrUpdateMultipleAnchors", request, response);
}

function getAllVersions(request, response) {
    readDataForAnchor("getAllVersions", request, response);
}

function getLastVersion(request, response) {
    readDataForAnchor("getLastVersion", request, response);
}

function totalNumberOfAnchors(request, response) {
    readDataForAnchor("totalNumberOfAnchors", request, response);
}

function dumpAnchors(request, response) {
    readDataForAnchor("dumpAnchors", request, response);
}


module.exports = {
    createAnchor,
    appendToAnchor,
    createOrUpdateMultipleAnchors,
    getAllVersions,
    getLastVersion,
    totalNumberOfAnchors,
    dumpAnchors
};

},{"../strategies":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/apihub/components/anchoring/strategies/index.js","../utils":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/apihub/components/anchoring/utils/index.js"}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/apihub/components/anchoring/index.js":[function(require,module,exports){
function Anchoring(server) {
    function requestServerMiddleware(request, response, next) {
        request.server = server;
        next();
    }

    const {
        createAnchor,
        appendToAnchor,
        createOrUpdateMultipleAnchors,
        getAllVersions,
        getLastVersion,
        totalNumberOfAnchors
    } = require("./controllers");

    const {responseModifierMiddleware, requestBodyJSONMiddleware} = require("../../utils/middlewares");
    const {getEthereumSyncServiceSingleton} = require("./strategies/oba/ethereumSyncService");

    const ethSyncService = getEthereumSyncServiceSingleton(server);
    ethSyncService.synchronize();

    server.use(`/anchor/:domain/*`, requestServerMiddleware);
    server.use(`/anchor/:domain/*`, responseModifierMiddleware);

    server.put(`/anchor/:domain/create-anchor/:anchorId`, requestBodyJSONMiddleware);
    server.put(`/anchor/:domain/create-anchor/:anchorId/:anchorValue`, createAnchor);

    server.put(`/anchor/:domain/append-to-anchor/:anchorId`, requestBodyJSONMiddleware);
    server.put(`/anchor/:domain/append-to-anchor/:anchorId/:anchorValue`, appendToAnchor);

    server.put(`/anchor/:domain/create-or-update-multiple-anchors`, requestBodyJSONMiddleware);
    server.put(`/anchor/:domain/create-or-update-multiple-anchors`, createOrUpdateMultipleAnchors);

    server.get(`/anchor/:domain/get-all-versions/:anchorId`, getAllVersions);
    server.head(`/anchor/:domain/get-all-versions/:anchorId`, server.getHeadHandler(getAllVersions));

    server.get(`/anchor/:domain/get-last-version/:anchorId`, getLastVersion);
    server.head(`/anchor/:domain/get-last-version/:anchorId`, server.getHeadHandler(getLastVersion));

    server.get(`/anchor/:domain/get-total-numbers-of-anchors`, totalNumberOfAnchors);
    server.head(`/anchor/:domain/get-total-numbers-of-anchors`, server.getHeadHandler(totalNumberOfAnchors));
}

module.exports = Anchoring;

},{"../../utils/middlewares":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/apihub/utils/middlewares/index.js","./controllers":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/apihub/components/anchoring/controllers/index.js","./strategies/oba/ethereumSyncService":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/apihub/components/anchoring/strategies/oba/ethereumSyncService.js"}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/apihub/components/anchoring/strategies/eth/index.js":[function(require,module,exports){
const {ALIAS_SYNC_ERR_CODE} = require("../../utils");

function ETH(server, domainConfig, anchorId, newAnchorValue, jsonData) {
    const openDSU = require("opendsu");
    const http = openDSU.loadAPI("http");
    const logger = $$.getLogger("Eth", "apihub/anchoring");
    const createEndpoint = (action) => {
        let endpoint = domainConfig.option.endpoint;

        if (endpoint.endsWith("/")) {
            endpoint = endpoint.slice(0, endpoint.length - 1);
        }
        endpoint = `${endpoint}/${action}`;
        if (anchorId) {
            endpoint = `${endpoint}/${anchorId}`;
        }

        if (newAnchorValue) {
            endpoint = `${endpoint}/${newAnchorValue}`;
        }

        return endpoint;
    }

    const writeToBlockchain = (action, callback) => {
        let options = {};
        let bodyData = "";
        if (jsonData) {
            bodyData = JSON.stringify(jsonData);
            options = {
                headers: {
                    "Content-Type": "application/json", "Content-Length": bodyData.length
                }
            }
        }

        if (domainConfig && domainConfig.useProxy) {
            options.useProxy = domainConfig.useProxy;
        }

        const endpoint = createEndpoint(action);
        http.doPut(endpoint, bodyData, options, (err, result) => {
            if (err) {
                if (err.statusCode === 428) {
                    const error = Error("Unable to add alias: versions out of sync");
                    error.code = ALIAS_SYNC_ERR_CODE;
                    return callback(error);
                }
                logger.error(err);
                callback(err);
                return;
            }
            callback(null, result);
        });
    }

    const readJSONFromBlockchain = (action, callback)=>{
        const endpoint = createEndpoint(action);
        http.fetch(endpoint, {
            method: 'GET'
        })
            .then(res => res.json())
            .then(data => callback(undefined, data))
            .catch(e => {
                return callback(e);
            });
    }

    const readFromBlockchain = (action, callback) => {
        const endpoint = createEndpoint(action);
        http.fetch(endpoint, {
            method: 'GET'
        })
            .then(res => res.text())
            .then(data => callback(undefined, data))
            .catch(e => {
                return callback(e);
            })
    }

    this.createAnchor = (callback) => {
        writeToBlockchain("createAnchor", callback);
    }

    this.appendAnchor = (callback) => {
        writeToBlockchain("appendAnchor", callback);
    }

    this.createOrUpdateMultipleAnchors = (callback) => {
        writeToBlockchain("createOrUpdateMultipleAnchors", callback);
    }

    this.getAllVersions = (callback) => {
        readJSONFromBlockchain("getAllVersions", callback);
    }

    this.getLastVersion = (callback) => {
        readFromBlockchain("getLastVersion", callback);
    }

    this.totalNumberOfAnchors = (callback) => {
        readFromBlockchain("totalNumberOfAnchors", callback);
    }

    this.dumpAnchors = (callback) => {
        readJSONFromBlockchain("dumpAnchors", callback);
    }
}

module.exports = ETH;
},{"../../utils":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/apihub/components/anchoring/utils/index.js","opendsu":"opendsu"}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/apihub/components/anchoring/strategies/fs/filePersistence.js":[function(require,module,exports){
function FilePersistenceStrategy(rootFolder, configuredPath) {
    const self = this;
    const fileOperations = new FileOperations();
    const FSLock = require("../utils/FSLock");
    const AnchorPathResolver = require("../utils/AnchorPathResolver");
    const anchorPathResolver = new AnchorPathResolver(rootFolder, configuredPath);
    fileOperations.InitializeFolderStructure(rootFolder, configuredPath);

    const fsLocks = {};
    self.prepareAnchoring = (anchorId, callback) => {
        const anchorPath = anchorPathResolver.getAnchorPath(anchorId);
        const fsLock = new FSLock(anchorPath);
        fsLocks[anchorId] = fsLock;
        fsLock.acquireLock(err => {
            if (err) {
                return callback({code: 428, message: "Versions out of sync"})
            }

            callback();
        });
    }

    self.totalNumberOfAnchors = function (callback) {
        fileOperations.totalNumberOfAnchors(callback);
    }

    self.getLastVersion = function (anchorId, callback) {
        fileOperations.isFileNameValid(anchorId, (err) => {
            if (err) {
                return callback(err);
            }
            fileOperations.fileExist(anchorId, (err, exists) => {
                if (err) {
                    return callback(undefined, null);
                }
                if (!exists) {
                    return callback(undefined, null);
                }
                //read the last hashlink for anchorId
                return fileOperations.getlastVersion(anchorId, callback);
            })
        });
    }
    self.getAllVersions = function (anchorId, callback) {
        // read all hashlinks for anchorId
        fileOperations.isFileNameValid(anchorId, (err) => {
            if (err) {
                return callback(err);
            }
            fileOperations.fileExist(anchorId, (err, exists) => {
                if (err) {
                    return callback(err);
                }
                if (!exists) {
                    return callback(undefined, []);
                }
                //read the last hashlink for anchorId
                return fileOperations.getAllVersions(anchorId, callback);
            })
        });
    }
    self.createAnchor = function (anchorId, anchorValueSSI, callback) {
        fileOperations.isFileNameValid(anchorId, (err) => {
            if (err) {
                return callback(err);
            }
            fileOperations.fileExist(anchorId, (err, exists) => {
                if (err) {
                    return callback(err);
                }
                if (!exists) {
                    //file doesnt exist
                    return fileOperations.createAnchor(anchorId, anchorValueSSI, callback);
                }
                //if anchor exist, return error
                return callback(Error(`anchor ${anchorId} already exist`));
            })
        });
    }
    self.appendAnchor = function (anchorId, anchorValueSSI, callback) {
        const anchorPath = anchorPathResolver.getAnchorPath(anchorId);
        const fsLock = fsLocks[anchorId]
        fsLock.isMyLock((err, isMyLock) => {
            if (err) {
                return callback(err);
            }

            if (!isMyLock) {
                return callback(Error(`File ${anchorPath} is locked by another process.`))
            }

            fileOperations.isFileNameValid(anchorId, (err) => {
                if (err) {
                    return callback(err);
                }
                fileOperations.fileExist(anchorId, (err, exists) => {
                    if (err) {
                        return callback(err);
                    }
                    if (!exists) {
                        return callback(new Error(`Anchor ${anchorId} doesn't exist`));
                    }
                    return fileOperations.appendAnchor(anchorId, anchorValueSSI, err => {
                        if (err) {
                            return callback(err);
                        }

                        fsLock.releaseLock(callback);
                    });
                })
            });
        })
    }
}


function FileOperations() {
    const self = this;
    const fs = require('fs');
    const path = require('path');
    let anchoringFolder;
    const endOfLine = require("os").EOL;
    const logger = $$.getLogger("FileOperations", "apihub/anchoring");
    self.InitializeFolderStructure = function (rootFolder, configuredPath) {
        let storageFolder = path.join(rootFolder, configuredPath);
        anchoringFolder = path.resolve(storageFolder);
        try {
            if (!fs.existsSync(anchoringFolder)) {
                fs.mkdirSync(anchoringFolder, {recursive: true});
            }
        } catch (e) {
            logger.error("error creating anchoring folder", e);
            throw new Error(`Failed to create folder ${anchoringFolder}`);
        }
    }

    self.isFileNameValid = function (anchorId, callback) {
        if (!anchorId || typeof anchorId !== "string") {
            return callback(new Error("No fileId specified."));
        }

        let forbiddenCharacters = new RegExp(/[~`!#$%^&*+=\-\[\]\\';,/{}|":<>?]/g);
        if (forbiddenCharacters.test(anchorId)) {
            logger.error(`Found forbidden characters in anchorId ${anchorId}`);
            return callback(new Error(`anchorId ${anchorId} contains forbidden characters`));
        }
        return callback(undefined);
    }

    self.fileExist = function (anchorId, callback) {
        const filePath = path.join(anchoringFolder, anchorId);
        fs.stat(filePath, (err) => {
            if (err) {
                if (err.code === "ENOENT") {
                    return callback(undefined, false);
                }
                return callback(err, false);
            }
            return callback(undefined, true);
        });
    }

    self.totalNumberOfAnchors = function (callback) {
        fs.readdir(anchoringFolder, {withFileTypes: true}, (err, items) => {
            if (err) {
                return callback(err);
            }
            let numberOfFiles = 0;
            items.forEach(item => {
                if (item.isFile()) {
                    numberOfFiles++;
                }
            })
            return callback(undefined, numberOfFiles);
        })
    }

    self.getlastVersion = function (anchorId, callback) {
        self.getAllVersions(anchorId, (err, allVersions) => {
            if (err) {
                return callback(err);
            }
            if (allVersions.length === 0) {
                return callback(undefined, null);
            }
            return callback(undefined, allVersions[allVersions.length - 1]);
        });
    }

    self.getAllVersions = function (anchorId, callback) {
        const filePath = path.join(anchoringFolder, anchorId);
        fs.readFile(filePath, (err, fileHashes) => {
            if (err) {
                return callback(new Error(`Failed to read file <${filePath}>`));
            }
            const fileContent = fileHashes.toString().trimEnd();
            const versions = fileContent ? fileContent.split(endOfLine) : [];
            callback(undefined, versions);
        });
    }

    self.createAnchor = function (anchorId, anchorValueSSI, callback) {
        const fileContent = anchorValueSSI + endOfLine;
        const filePath = path.join(anchoringFolder, anchorId);
        fs.writeFile(filePath, fileContent, callback);
    }

    self.appendAnchor = function (anchorId, anchorValueSSI, callback) {
        const fileContent = anchorValueSSI + endOfLine;
        const filePath = path.join(anchoringFolder, anchorId);
        fs.appendFile(filePath, fileContent, callback);
    }
}


module.exports = {
    FilePersistenceStrategy
}

},{"../utils/AnchorPathResolver":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/apihub/components/anchoring/strategies/utils/AnchorPathResolver.js","../utils/FSLock":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/apihub/components/anchoring/strategies/utils/FSLock.js","fs":false,"os":false,"path":false}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/apihub/components/anchoring/strategies/fs/index.js":[function(require,module,exports){

const openDSU = require("opendsu");

class FS{
    constructor(server, domainConfig, anchorId, anchorValue, jsonData) {
        this.commandData = {};
        this.commandData.option = domainConfig.option;
        this.commandData.anchorId = anchorId;
        this.commandData.anchorValue = anchorValue;
        this.commandData.jsonData = jsonData || {};
        const FilePersistence = require('./filePersistence').FilePersistenceStrategy;
        this.fps = new FilePersistence(server.rootFolder,domainConfig.option.path);
        this.anchoringBehaviour = openDSU.loadApi("anchoring").getAnchoringBehaviour(this.fps);
    }

    createAnchor(callback){
        this.anchoringBehaviour.createAnchor(this.commandData.anchorId, this.commandData.anchorValue, callback);
    }

    appendAnchor(callback){
        this.anchoringBehaviour.appendAnchor(this.commandData.anchorId, this.commandData.anchorValue, callback);
    }

    totalNumberOfAnchors(callback){
        this.fps.totalNumberOfAnchors(callback);
    }

    getAllVersions(callback){
        this.anchoringBehaviour.getAllVersions(this.commandData.anchorId, (err, anchorValues)=>{
            if (err) {
                return callback(err);
            }
            if (anchorValues.length === 0) {
                return callback(undefined, anchorValues);
            }

            callback(undefined, anchorValues.map(el => el.getIdentifier()));
        });
    }

    getLastVersion(callback){
        this.anchoringBehaviour.getLastVersion(this.commandData.anchorId, (err, anchorValue)=>{
            if (err) {
                return callback(err);
            }

            if (anchorValue) {
                return callback(undefined, anchorValue.getIdentifier());
            }

            callback();
        });
    }
}

module.exports = FS;

},{"./filePersistence":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/apihub/components/anchoring/strategies/fs/filePersistence.js","opendsu":"opendsu"}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/apihub/components/anchoring/strategies/index.js":[function(require,module,exports){
module.exports = {
    FS: require("./fs"),
    ETH: require("./eth"),
   /* Contract: require("./contract"),*/
    OBA: require("./oba")
};

},{"./eth":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/apihub/components/anchoring/strategies/eth/index.js","./fs":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/apihub/components/anchoring/strategies/fs/index.js","./oba":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/apihub/components/anchoring/strategies/oba/index.js"}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/apihub/components/anchoring/strategies/oba/ethereumSyncService.js":[function(require,module,exports){
const {ALIAS_SYNC_ERR_CODE, ANCHOR_ALREADY_EXISTS_ERR_CODE} = require("../../utils");
const {getLokiEnclaveFacade} = require("./lokiEnclaveFacadeSingleton");
const {getLogFilePath} = require("./getLogFilePath");
const {getDBFilePath} = require("./getDBFilePath");

function EthereumSyncService(server, config) {
    const defaultConfig = {
        scheduleInterval: 10000,
        sendInterval: 17000,
        burstSize: 100,
        maxNumberOfRetries: 100
    }
    Object.assign(defaultConfig, config);
    config = defaultConfig;

    const DB_STORAGE_FILE = getDBFilePath(server);
    const logger = $$.getLogger("OBA", "EthereumSyncService", getLogFilePath(server));

    const openDSU = require("opendsu");
    const utils = openDSU.loadAPI("utils");
    const TaskCounter = require("swarmutils").TaskCounter;
    let lokiEnclaveFacade = getLokiEnclaveFacade(DB_STORAGE_FILE);
    const ANCHORS_TABLE_NAME = "anchors_table";
    let syncInProgress = false;
    const {ETH} = require("../index");

    const init = () => {
        syncInProgress = false;
        const taskCounter = new TaskCounter(() => {
            this.finishInitialisation();
        })

        lokiEnclaveFacade.filter(undefined, ANCHORS_TABLE_NAME, (err, anchors) => {
            if (err) {
                this.finishInitialisation();
                return;
            }

            if (typeof anchors === "undefined" || anchors.length === 0) {
                return this.finishInitialisation();
            }

            taskCounter.increment(anchors.length);
            anchors.forEach(anchor => {
                anchor.scheduled = null;
                anchor.tc = 1;
                lokiEnclaveFacade.updateRecord(undefined, ANCHORS_TABLE_NAME, anchor.pk, anchor, err => {
                    if (err) {
                        logger.debug(`Failed to update anchor ${anchor.pk} in db: ${err}`);
                    }

                    taskCounter.decrement();
                })
            })
        })
    }

    function sendAnchorToBlockchain(anchor) {
        const ethHandler = new ETH(server, anchor.domainConfig, anchor.anchorId, anchor.anchorValue);
        logger.info(0x101, `Anchoring for anchor ${anchor.anchorId} started.`);
        ethHandler[anchor.anchorUpdateOperation]((err, transactionHash) => {
            if (err) {
                if (err.code === ANCHOR_ALREADY_EXISTS_ERR_CODE || err.code === ALIAS_SYNC_ERR_CODE) {
                    logger.critical(0x101, `Anchoring for ${anchor.anchorId} failed to sync with blockchain`)

                    lokiEnclaveFacade.deleteRecord(undefined, ANCHORS_TABLE_NAME, anchor.pk, err => {
                        if (err) {
                            logger.debug(`Failed to delete anchor ${anchor.anchorId} from db: ${err}`);
                        }
                    });
                    return;
                }
                anchor.scheduled = null;
                anchor.tc++;
                if (anchor.tc === config.maxNumberOfRetries) {
                    logger.warn(0x01, `Anchoring Synchronization for ${anchor.anchorId} retried ${config.maxNumberOfRetries} without success`);
                }
                lokiEnclaveFacade.updateRecord(undefined, ANCHORS_TABLE_NAME, anchor.pk, anchor, err => {
                    if (err) {
                        logger.debug(`Failed to update anchor ${anchor.pk}: ${err}`);
                    }
                });
                return;
            }

            logger.info(0x102, `Anchoring for anchor ${anchor.anchorId} committed in blockchain: ${transactionHash}`);
            lokiEnclaveFacade.deleteRecord(undefined, ANCHORS_TABLE_NAME, anchor.pk, err => {
                if (err) {
                    logger.debug(`Failed to delete anchor ${anchor.anchorId} from db: ${err}`);
                }
            })
        })
    }

    this.storeAnchor = (anchorUpdateOperation, anchorId, anchorValue, domainConfig, callback) => {
        lokiEnclaveFacade.addInQueue(undefined, ANCHORS_TABLE_NAME, {
            anchorId,
            anchorValue,
            anchorUpdateOperation,
            domainConfig,
            scheduled: null,
            tc: 1
        }, callback);
    }

    const scheduleAnchors = () => {
        lokiEnclaveFacade.filter(undefined, ANCHORS_TABLE_NAME, ["scheduled == null"], "asc", (err, anchors) => {
            if (err) {
                if (err.code !== 404) {
                    logger.debug(`Failed to get anchors from db: ${err}`);
                }
                return;
            }
            anchors.forEach(anchor => {
                anchor.scheduled = Date.now() + (anchor.tc > 100 ? 100 : anchor.tc) * config.scheduleInterval;
                lokiEnclaveFacade.updateRecord(undefined, ANCHORS_TABLE_NAME, anchor.pk, anchor, err => {
                    if (err) {
                        logger.debug(`Failed to update anchor ${anchor.pk} in db: ${err}`);
                    }
                })
            })
        })
    }

    const sendAnchorsToBlockchain = () => {
        lokiEnclaveFacade.filter(undefined, ANCHORS_TABLE_NAME, ["scheduled != null", "scheduled != sent", `scheduled < ${Date.now()}`], "asc", config.burstSize, (err, anchors) => {
            if (err) {
                if (err.code !== 404) {
                    logger.debug(`Failed to get anchors from db: ${err}`);
                }
                return;
            }

            anchors.forEach(anchor => {
                anchor.scheduled = "sent";
                lokiEnclaveFacade.updateRecord(undefined, ANCHORS_TABLE_NAME, anchor.pk, anchor, err => {
                    if (err) {
                        logger.debug(`Failed to update anchor ${anchor.pk} in db: ${err}`);
                        return;
                    }

                    sendAnchorToBlockchain(anchor);
                })
            })
        })
    }

    this.synchronize = () => {
        if (!syncInProgress) {
            setInterval(scheduleAnchors, config.scheduleInterval);
            setInterval(sendAnchorsToBlockchain, config.sendInterval);
            syncInProgress = true;
        }
    };

    utils.bindAutoPendingFunctions(this);
    init();
}

const getEthereumSyncServiceSingleton = (server) => {
    if (typeof $$.ethereumSyncService === "undefined") {
        $$.ethereumSyncService = new EthereumSyncService(server);
    }

    return $$.ethereumSyncService;
}
module.exports = {
    getEthereumSyncServiceSingleton
}
},{"../../utils":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/apihub/components/anchoring/utils/index.js","../index":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/apihub/components/anchoring/strategies/index.js","./getDBFilePath":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/apihub/components/anchoring/strategies/oba/getDBFilePath.js","./getLogFilePath":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/apihub/components/anchoring/strategies/oba/getLogFilePath.js","./lokiEnclaveFacadeSingleton":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/apihub/components/anchoring/strategies/oba/lokiEnclaveFacadeSingleton.js","opendsu":"opendsu","swarmutils":"swarmutils"}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/apihub/components/anchoring/strategies/oba/getDBFilePath.js":[function(require,module,exports){
const path = require("path");

const getDBFilePath = (server) => {
    const BASE_FOLDER = path.join(server.rootFolder, "external-volume", "oba");
    const storageFilePath = path.join(BASE_FOLDER, "pendingAnchors");

    return storageFilePath;
}

module.exports = {
    getDBFilePath
}
},{"path":false}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/apihub/components/anchoring/strategies/oba/getLogFilePath.js":[function(require,module,exports){
const path = require("path");

const getLogFilePath = (server) => {
    const BASE_FOLDER = path.join(server.rootFolder, "external-volume", "oba");
    const LOG_FILE = path.join(BASE_FOLDER, "oba.log");

    return LOG_FILE;
}

module.exports = {
    getLogFilePath
}
},{"path":false}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/apihub/components/anchoring/strategies/oba/index.js":[function(require,module,exports){
const {getEthereumSyncServiceSingleton} = require("./ethereumSyncService");
const {getLogFilePath} = require("./getLogFilePath");

function OBA(server, domainConfig, anchorId, anchorValue, ...args) {
    let {FS, ETH} = require("../index");
    const fsHandler = new FS(server, domainConfig, anchorId, anchorValue, ...args);
    const ethHandler = new ETH(server, domainConfig, anchorId, anchorValue, ...args);
    const ethSyncService = getEthereumSyncServiceSingleton(server);
    const logger = $$.getLogger("OBA", "apihub/anchoring", getLogFilePath(server));

    this.createAnchor = function (callback) {
        logger.debug(1, `Anchoring for ${anchorId} started`);
        fsHandler.createAnchor((err, res) => {
            if (err) {
                return callback(err);
            }
            logger.debug(`Optimistic create anchor ended with success.`);

            ethSyncService.storeAnchor("createAnchor", anchorId, anchorValue, domainConfig,(err) => {
                if (err) {
                    logger.error(`Failed to store anchor ${fsHandler.commandData.anchorId} in db.`);
                    return;
                }

                logger.debug(`Anchor ${fsHandler.commandData.anchorId} stored in db successfully.`);
                return callback(undefined, res);
            })
        });
    }

    this.appendAnchor = function (callback) {
        logger.debug(1, `Anchoring for ${anchorId} started`);
        fsHandler.appendAnchor((err, res) => {
            if (err) {
                return callback(err);
            }
            logger.debug(`Optimistic append anchor ended with success.`);
            ethSyncService.storeAnchor("appendAnchor", anchorId, anchorValue, domainConfig, (err) => {
                if (err) {
                    logger.error(`failed to store anchor ${fsHandler.commandData.anchorId} in db.`);
                    return;
                }

                logger.debug(`Anchor ${fsHandler.commandData.anchorId} stored in db successfully.`);
                return callback(undefined, res);

            })
        });
    }

    function readAllVersionsFromBlockchain(callback) {
        logger.debug(`Preparing to read info about anchorId ${fsHandler.commandData.anchorId} from the blockchain...`);
        ethHandler.getAllVersions((err, anchorVersions) => {
            if (err) {
                logger.error(`AnchorId ${fsHandler.commandData.anchorId} syncing blockchain failed. ${err}`);
                return callback(err);
            }

            let history = "";
            for (let i = 0; i < anchorVersions.length; i++) {
                history += anchorVersions[i];
                if (i + 1 < anchorVersions.length) {
                    history += require("os").EOL;
                }
            }

            if (history === "") {
                logger.debug(`AnchorId ${fsHandler.commandData.anchorId} synced but no history found.`);
                //if we don't retrieve info from blockchain we exit
                return callback(undefined, anchorVersions);
            }

            logger.debug(`Found info about anchorId ${fsHandler.commandData.anchorId} in blockchain.`);

            //storing locally the history of the anchorId read from the blockchain
            fsHandler.fps.createAnchor(anchorId, history, (err) => {
                if (err) {
                    logger.error(`Failed to store info about anchorId ${fsHandler.commandData.anchorId} on local because of ${err}`);
                    return callback(err);
                }
                logger.debug(`AnchorId ${fsHandler.commandData.anchorId} fully synced.`);
                //even if we read all the versions of anchorId we return only the last one
                return callback(undefined, anchorVersions);
            });
        });
    }

    this.getAllVersions = function (callback) {
        fsHandler.getAllVersions((error, res) => {
            if (error || !res) {
                return readAllVersionsFromBlockchain((err, allVersions) => {
                    if (err) {
                        //we return the error from FS because we were not able to read any from blockchain.
                        return callback(error);
                    }
                    return callback(undefined, allVersions);
                });
            }
            return callback(undefined, res);
        });
    }

    this.getLastVersion = function (callback) {
        fsHandler.getLastVersion((error, res) => {
            if (error || !res) {
                return readAllVersionsFromBlockchain((err, allVersions) => {
                    if (err) {
                        //we return the error from FS because we were not able to read any from blockchain.
                        return callback(error);
                    }
                    return callback(undefined, allVersions.pop());
                });
            }
            return callback(undefined, res);
        });
    }
}

module.exports = OBA;

},{"../index":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/apihub/components/anchoring/strategies/index.js","./ethereumSyncService":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/apihub/components/anchoring/strategies/oba/ethereumSyncService.js","./getLogFilePath":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/apihub/components/anchoring/strategies/oba/getLogFilePath.js","os":false}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/apihub/components/anchoring/strategies/oba/lokiEnclaveFacadeSingleton.js":[function(require,module,exports){
const fs = require("fs");
const path = require("path");

const getLokiEnclaveFacade = (storageFile) => {
    if(typeof $$.lokiEnclaveFacade === "undefined") {
        try {
            fs.accessSync(path.dirname(storageFile));
        } catch (e) {
            fs.mkdirSync(path.dirname(storageFile), {recursive: true});
        }
        const lokiEnclaveFacadeModule = require("loki-enclave-facade");
        const createLokiEnclaveFacadeInstance = lokiEnclaveFacadeModule.createLokiEnclaveFacadeInstance;
        $$.lokiEnclaveFacade = createLokiEnclaveFacadeInstance(storageFile);
    }

    return $$.lokiEnclaveFacade;
}

module.exports = {
    getLokiEnclaveFacade
}

},{"fs":false,"loki-enclave-facade":"loki-enclave-facade","path":false}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/apihub/components/anchoring/strategies/utils/AnchorPathResolver.js":[function(require,module,exports){
function AnchorPathResolver(rootFolder, configPath) {
    const path = require("path");
    const anchoringFolder = path.resolve(path.join(rootFolder, configPath));

    this.getAnchorPath = (anchorId) => {
        return path.join(anchoringFolder, anchorId);
    }
}

module.exports = AnchorPathResolver;
},{"path":false}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/apihub/components/anchoring/strategies/utils/FSLock.js":[function(require,module,exports){
const fs = require("fs");

function FSLock(filePath, maxTimeMilliSeconds, forcedLockDelay) {
    maxTimeMilliSeconds = maxTimeMilliSeconds || 5000;
    forcedLockDelay = forcedLockDelay || 10000;
    let lockCreationTime;
    const removeDir = require("swarmutils").removeDir;
    this.acquireLock = (callback) => {
        fs.mkdir(getLockPath(), async err => {
            if (err) {
                if (await lockIsExpired()) {
                   return attemptToReacquireExpiredLock(callback);
                }

                return callback(Error(`File ${filePath} is being updated by another process.`));
            }

            lockCreationTime = await getLockCreationTime();
            callback();
        })
    }

    this.releaseLock = (callback) => {
        this.isMyLock((err, isMyLock) => {
            if (err) {
                return callback(err);
            }
            if (isMyLock) {
                return removeDir(getLockPath(), {recursive: true}, callback);
            }

            callback(Error(`The lock is owned by another instance.`));
        })
    }

    this.isMyLock = (callback) => {
        getLockCreationTime().then(creationTime => {
            let isOwnLock = false;
            if (creationTime === lockCreationTime) {
                isOwnLock = true;
            }
            callback(undefined, isOwnLock);
        });
    }

    const lockIsExpired = async () => {
        const lockStartingTime = await getLockCreationTime();
        if (Date.now() - lockStartingTime > maxTimeMilliSeconds) {
            return true;
        }

        return false;
    };


    const releaseExpiredLock = (callback)=>{
        return setTimeout(() => {
            removeDir(getLockPath(), {recursive: true}, (err)=>{
                if (err) {
                    return callback(err);
                }

                callback();
            });
        }, forcedLockDelay);
    }

    const attemptToReacquireExpiredLock = (callback)=>{
        releaseExpiredLock(err=>{
            if (err) {
                return callback(err);
            }

            this.acquireLock(callback);
        })
    }

    const getLockCreationTime = async () => {
        let stats;
        try {
            stats = await $$.promisify(fs.stat)(getLockPath());
        } catch (e) {
            return 0;
        }
        return stats.birthtimeMs;
    }

    const getLockPath = () => {
        return `${filePath}.lock`;
    }
}

module.exports = FSLock;
},{"fs":false,"swarmutils":"swarmutils"}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/apihub/components/anchoring/utils/index.js":[function(require,module,exports){
const { clone } = require("../../../utils");

const getAnchoringDomainConfig = async (domain) => {
    const config = require("../../../config");
    let domainConfiguration = await config.getSafeDomainConfig(domain);

    if (!domainConfiguration) {
        return;
    }

    let domainConfig = domainConfiguration.anchoring;

    if (!domainConfig) {
        // try to get the anchoring strategy based on the anchoring component config
        const anchoringConfig = config.getConfig("componentsConfig", "anchoring");

        if (anchoringConfig) {
            const { anchoringStrategy } = anchoringConfig;
            domainConfig = {
                type: anchoringStrategy,
            };
        } else {
            return;
        }
    }

    domainConfig = clone(domainConfig);
    domainConfig.option = domainConfig.option || {};
    domainConfig.option.path = require("path").join(config.getConfig("externalStorage"), `domains/${domain}/anchors`);

    return domainConfig;
};

const getDomainFromKeySSI = function (ssiString) {
    const openDSU = require("opendsu");
    const keySSISpace = openDSU.loadApi("keyssi");
    const keySSI = keySSISpace.parse(ssiString);
    return keySSI.getDLDomain();
};

const ALIAS_SYNC_ERR_CODE = "sync-error";
const ANCHOR_ALREADY_EXISTS_ERR_CODE = "anchor-already-exists";

module.exports = { getAnchoringDomainConfig, getDomainFromKeySSI, ALIAS_SYNC_ERR_CODE, ANCHOR_ALREADY_EXISTS_ERR_CODE };

},{"../../../config":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/apihub/config/index.js","../../../utils":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/apihub/utils/index.js","opendsu":"opendsu","path":false}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/apihub/components/bdns/index.js":[function(require,module,exports){
function BDNS(server) {
    const logger = $$.getLogger("BDNS", "apihub/bdns");

    const DOMAIN_TEMPLATE = {
        "replicas": [],
        "brickStorages": [
            "$ORIGIN"
        ],
        "anchoringServices": [
            "$ORIGIN"
        ],
        "notifications": [
            "$ORIGIN"
        ]
    };
    const URL_PREFIX = "/bdns";
    const {headersMiddleware} = require('../../utils/middlewares');

    let bdnsCache;
    const config = require("../../config");
    const bdnsConfig = config.getConfig("componentsConfig", "bdns");

    async function getBDNSHostsFromURL(url) {
        const http = require("opendsu").loadAPI("http");
        const bdnsHosts = await http.fetch(url).then(res => res.json());
        return bdnsHosts
    }

    let init_process_runned = false;

    async function initialize() {
        if (init_process_runned) {
            return true;
        }
        init_process_runned = true;
        const fs = require("fs");
        const path = require("path");

        const bdnsHostsPath = path.join(process.env.PSK_CONFIG_LOCATION, "bdns.hosts");

        bdnsCache = fs.readFileSync(bdnsHostsPath).toString();

        if (bdnsConfig && bdnsConfig.url) {
            try {
                const bdnsExtensions = await getBDNSHostsFromURL(bdnsConfig.url);
                let newRegistry = JSON.parse(bdnsCache);
                Object.assign(newRegistry, bdnsExtensions);
                bdnsCache = JSON.stringify(newRegistry);
            } catch (e) {
                logger.error(`Failed to get bdns hosts from url`, e);
            }
        }

        try {
            logger.debug("Testing to see if admin component is active and can be used to expand BDNS configuration.");
            let adminService = require("./../admin").getAdminService();
            let getDomains = $$.promisify(adminService.getDomains);
            let domains = await getDomains();
            if (domains) {
                let bdnsExtensions = {};
                for (let i = 0; i < domains.length; i++) {
                    let domain = domains[i];
                    if (domain.active) {
                        bdnsExtensions[domain.name] = DOMAIN_TEMPLATE;
                    }
                }
                let newRegistry = JSON.parse(bdnsCache);
                Object.assign(newRegistry, bdnsExtensions);
                bdnsCache = JSON.stringify(newRegistry);
            }
            logger.debug("BDNS configuration was updated accordingly to information retrieved from admin service");
        } catch (err) {
            logger.debug("Admin service not available, skipping the process of loading dynamic configured domains. This is not a problem, it's a configuration.");
        }
    }

    async function bdnsHandler(request, response) {
        try {
            await initialize();
        } catch (e) {
            response.statusCode = 500;
            logger.error('Failed to initialize BDNS', e);
            return response.end('Failed to initialize BDNS');
        }

        if (typeof bdnsCache !== "undefined") {
            response.setHeader('content-type', 'application/json');
            response.statusCode = 200;
            response.end(bdnsCache);
        } else {
            logger.debug("Bdns config not available at this moment. A 404 response will be sent.");
            response.statusCode = 404;
            logger.error('BDNS hosts not found');
            return response.end('BDNS hosts not found');
        }
    }

    server.use(`${URL_PREFIX}/*`, headersMiddleware);
    server.get(URL_PREFIX, bdnsHandler);
}

module.exports = BDNS;

},{"../../config":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/apihub/config/index.js","../../utils/middlewares":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/apihub/utils/middlewares/index.js","./../admin":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/apihub/components/admin/index.js","fs":false,"opendsu":"opendsu","path":false}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/apihub/components/bricking/controllers.js":[function(require,module,exports){
const {getBrickWithExternalProvidersFallbackAsync} = require("./utils");
const logger = $$.getLogger("apihub", "bricking");

async function brickExists(request, response) {
    response.setHeader("Cache-control", "No-Cache"); // set brick cache to expire in 1 year

    const {hashLink} = request.params;
    let brickExists;
    try {
        brickExists = await request.fsBrickStorage.brickExists(hashLink);
    } catch (e) {

    }
    if (!brickExists) {
        brickExists = await request.oldFsBrickStorage.brickExists(hashLink);
    }

    if(!brickExists){
        return response.send(404, "Brick not found");
    }
    return response.send(200, brickExists);
}

async function getBrick(request, response) {
    response.setHeader("content-type", "application/octet-stream");
    response.setHeader("Cache-control", "max-age=31536000"); // set brick cache to expire in 1 year

    const {domain, hashLink} = request.params;
    try {
        let brick;
        try {
            brick = await getBrickWithExternalProvidersFallbackAsync(request, domain, hashLink, request.fsBrickStorage);
        } catch (e) {
            logger.debug("Failed to get brick", e);
        }
        if (!brick) {
            brick = await getBrickWithExternalProvidersFallbackAsync(request, domain, hashLink, request.oldFsBrickStorage);
        }
        response.write(brick);
        return response.send(200);
    } catch (error) {
        logger.info(0x02, `Brick <${hashLink}> was not found`);
        return response.send(404, "Brick not found");
    }
}

function putBrick(request, response) {
    const utils = require("./utils");
    utils.convertReadableStreamToBuffer(request, (error, brickData) => {
        if (error) {
            logger.info(0x02, `Fail to convert Stream to Buffer!`, error.message);
            logger.error("Fail to convert Stream to Buffer!", error.message);
            return response.send(500);
        }

        request.fsBrickStorage.addBrick(brickData, (error, brickHash) => {
            if (error) {
                logger.info(0x02, `Fail to manage current brick!`, error.message);
                return response.send(error.code === "EACCES" ? 409 : 500);
            }
            return response.send(201, brickHash);
        });
    });
}

function downloadMultipleBricks(request, response) {
    response.setHeader("content-type", "application/octet-stream");
    response.setHeader("Cache-control", "max-age=31536000"); // set brick cache to expire in 1 year

    const {domain} = request.params;
    let {hashes} = request.query;

    if (!Array.isArray(hashes)) {
        hashes = [hashes];
    }

    const responses = hashes.map((hash) =>
        getBrickWithExternalProvidersFallbackAsync(request, domain, hash, request.fsBrickStorage)
    );
    Promise.all(responses)
        .then((bricks) => {
            const data = bricks.map((brick) => brick.toString());
            return response.send(200, data);
        })
        .catch((error) => {
            logger.info(0x02, `Fail to get multiple bricks`, error.message);
            return response.send(500);
        });
}

module.exports = {
    getBrick,
    putBrick,
    downloadMultipleBricks,
    brickExists
};

},{"./utils":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/apihub/components/bricking/utils.js"}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/apihub/components/bricking/index.js":[function(require,module,exports){
function Bricks(server) {
    function requestServerMiddleware(request, response, next) {
        request.server = server;
        next();
    }

    const { headersMiddleware, responseModifierMiddleware } = require('../../utils/middlewares');

    const { requestFSBrickStorageMiddleware } = require('./middlewares');

    const { getBrick, putBrick, downloadMultipleBricks, brickExists} = require('./controllers');

    server.use(`/bricking/:domain/*`, headersMiddleware);
    server.use(`/bricking/:domain/*`, responseModifierMiddleware);
    server.use(`/bricking/:domain/*`, requestServerMiddleware); // request.server
    server.use(`/bricking/:domain/*`, requestFSBrickStorageMiddleware); // request.fsBrickStorage

    server.put(`/bricking/:domain/put-brick`, putBrick);

    server.get(`/bricking/:domain/get-brick/:hashLink`, getBrick);

    server.get(`/bricking/:domain/brick-exists/:hashLink`, brickExists);

    server.get(`/bricking/:domain/downloadMultipleBricks`, downloadMultipleBricks);
}

module.exports = Bricks;

},{"../../utils/middlewares":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/apihub/utils/middlewares/index.js","./controllers":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/apihub/components/bricking/controllers.js","./middlewares":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/apihub/components/bricking/middlewares.js"}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/apihub/components/bricking/middlewares.js":[function(require,module,exports){
async function requestFSBrickStorageMiddleware(request, response, next) {
    const {domain: domainName} = request.params;
    const logger = $$.getLogger("requestFSBrickStorageMiddleware", "apihub/bricking");

    const domainConfig = await require("./utils").getBricksDomainConfig(domainName);
    if (!domainConfig || !domainConfig.path) {
        const message = `[Bricking] Domain '${domainName}' not found!`;
        logger.error(message);
        return response.send(404, message);
    }

    const createFSBrickStorage = (...props) => {
        return require("./replication/FSBrickStorage").create(...props);
    };

    const FsBrickPathsManager = require("./replication/FSBrickPathsManager");
    request.fsBrickStorage = createFSBrickStorage(
        domainName,
        domainConfig.path,
        request.server.rootFolder,
        new FsBrickPathsManager(2)
    );

    request.oldFsBrickStorage = createFSBrickStorage(
        domainName,
        domainConfig.path,
        request.server.rootFolder,
        new FsBrickPathsManager(5)
    );

    next();
}

module.exports = {
    requestFSBrickStorageMiddleware
};

},{"./replication/FSBrickPathsManager":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/apihub/components/bricking/replication/FSBrickPathsManager.js","./replication/FSBrickStorage":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/apihub/components/bricking/replication/FSBrickStorage.js","./utils":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/apihub/components/bricking/utils.js"}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/apihub/components/bricking/replication/FSBrickPathsManager.js":[function(require,module,exports){
class FSBrickPathsManager {
    constructor(bricksFolderSize = 2) {
        this.brickPaths = {};
        this.bricksFolderSize = bricksFolderSize;
    }

    verifyBrickHash(brickHash) {
        if (!brickHash || typeof brickHash !== 'string') {
            throw Error('[Bricking] No hash specified');
        }

        if (brickHash.length < this.bricksFolderSize) {
            throw Error(`[Bricking] Hash "${brickHash}" is too small`);
        }
    }
    storeDomainPath(domainName, domainFolder, serverRoot) {
        if (!this.brickPaths[domainName]) {
            this.brickPaths[domainName] = require("path").join(serverRoot || "", domainFolder || domainName);
        }
    }

    removeDomainPath(domainName) {
        delete this.brickPaths[domainName];
    }

    resolveBrickPath(domainName, brickHash) {
        return require("path").join(this.resolveBrickDirname(domainName, brickHash), brickHash);
    }

    resolveBrickDirname(domainName, brickHash) {
        this.verifyBrickHash(brickHash);
        return require("path").join(this.brickPaths[domainName], brickHash.substr(0, this.bricksFolderSize));
    }
}

module.exports = FSBrickPathsManager;
},{"path":false}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/apihub/components/bricking/replication/FSBrickStorage.js":[function(require,module,exports){
class FSBrickStorage {
    constructor(domainName, domainFolder, serverRoot, fsBrickPathsManager) {
        this.domain = domainName;
        const FSBrickPathsManager = require("./FSBrickPathsManager");
        this.fsBrickPathsManager = fsBrickPathsManager || new FSBrickPathsManager(2);
        this.fsBrickPathsManager.storeDomainPath(this.domain, domainFolder, serverRoot);
    }

    getBrick(hash, callback) {
        callback = $$.makeSaneCallback(callback);

        this.getBrickAsync(hash)
            .then(result => callback(undefined, result))
            .catch(error => callback(error));
    }

    async getBrickAsync(hash) {
        const fs = require("fs");
        const brickPath = this.fsBrickPathsManager.resolveBrickPath(this.domain, hash);
        await $$.promisify(fs.access)(brickPath);
        return await $$.promisify(fs.readFile)(brickPath);
    }

    async brickExists(hash) {
        const fs = require("fs");
        const brickPath = this.fsBrickPathsManager.resolveBrickPath(this.domain, hash);
        try {
            await $$.promisify(fs.access)(brickPath);
            return true;
        } catch (error) {
        }
        return false
    }
    addBrick(data, callback) {
        callback = $$.makeSaneCallback(callback);

        this.addBrickAsync(data)
            .then(result => callback(undefined, result))
            .catch(error => callback(error));
    }

    async addBrickAsync(data) {
        const fs = require("fs");
        const crypto = require("opendsu").loadAPI("crypto");
        const hash = crypto.sha256(data);
        // TODO: use workers from OpenDSU apiSpace
        // const pool = workers.createPool() or (pool probably should be at FSBrickStorage ctor level)
        // await $$.promisify(pool.runSyncFunction)("crypto", "sha256", data);
        const brickDirPath = this.fsBrickPathsManager.resolveBrickDirname(this.domain, hash);
        await $$.promisify(fs.mkdir)(brickDirPath, { recursive: true });
        //await $$.promisify(fs.access)(brickDirPath);

        const brickPath = this.fsBrickPathsManager.resolveBrickPath(this.domain, hash);
        await $$.promisify(fs.writeFile)(brickPath, data);
        return hash;
    }

    deleteBrick(hash, callback) {
        callback = $$.makeSaneCallback(callback);

        this.deleteBrickAsync(hash)
            .then(result => callback(undefined, result))
            .catch(error => callback(error));
    }

    async deleteBrickAsync(hash) {
        const fs = require("fs");
        const removeDir = require("swarmutils").removeDir;
        const brickPath = this.fsBrickPathsManager.resolveBrickPath(this.domain, hash);
        await $$.promisify(fs.access)(brickPath);
        await $$.promisify(fs.unlink)(brickPath);

        const brickDirPath = this.fsBrickPathsManager.resolveBrickDirname(this.domain, hash);
        await $$.promisify(fs.access)(brickDirPath);
        await $$.promisify(removeDir)(brickDirPath, { recursive: true });
    }
}

function create(...params) {
    return new FSBrickStorage(...params);
}

module.exports = {
    create
};
},{"./FSBrickPathsManager":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/apihub/components/bricking/replication/FSBrickPathsManager.js","fs":false,"opendsu":"opendsu","swarmutils":"swarmutils"}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/apihub/components/bricking/utils.js":[function(require,module,exports){
const { clone } = require("../../utils");
const { getLocalBdnsEntryListExcludingSelfAsync, getHeadersWithExcludedProvidersIncludingSelf } = require("../../utils/request-utils");
const logger = $$.getLogger("bricking", "apihub/bricking")
function convertReadableStreamToBuffer(readStream, callback) {
    let buffers = [];

    readStream.on("data", (chunk) => buffers.push(chunk));

    readStream.on("error", (error) => callback(error));

    readStream.on("end", () => callback(undefined, $$.Buffer.concat(buffers)));
}

async function getBricksDomainConfig(domain) {
    logger.debug("Looking for domain", domain);
    const config = require("../../config");
    let domainConfiguration = await config.getSafeDomainConfig(domain);

    if (!domainConfiguration) {
        return;
    }

    let domainConfig = domainConfiguration.bricking;

    domainConfig = clone(domainConfig || {});
    domainConfig.path = require("path").join(config.getConfig("externalStorage"), `domains/${domain}/brick-storage`);

    return domainConfig;
}

async function getBrickFromExternalProvidersAsync(request, domain, hashLink) {
    let brickingProviders = await getLocalBdnsEntryListExcludingSelfAsync(request, domain, "brickStorages");

    if (!brickingProviders || !brickingProviders.length) {
        throw new Error(`[Bricking] Found no fallback bricking providers!`);
    }

    const http = require("opendsu").loadApi("http");
    for (let i = 0; i < brickingProviders.length; i++) {
        const providerUrl = brickingProviders[i];
        try {
            const brickUrl = `${providerUrl}/bricking/${domain}/get-brick/${hashLink}`;
            let providerResponse = await http.fetch(brickUrl, {
                headers: getHeadersWithExcludedProvidersIncludingSelf(request),
            });
            providerResponse = await providerResponse.text();
            return providerResponse;
        } catch (error) {
            // logger.warn(`[Bricking] Failed to get brick ${hashLink} from ${providerUrl}!`, error);
        }
    }

    throw new Error(`[Bricking] Could not load brick ${hashLink} from external providers`);
}

async function getBrickWithExternalProvidersFallbackAsync(request, domain, hashLink, fsBrickStorage) {
    const code = 0x201;
    try {
        const brick = await fsBrickStorage.getBrickAsync(hashLink);
        if (brick) {
            return brick;
        }
    } catch (error) {
        logger.debug(code, `[Bricking] Brick ${hashLink} not found. Trying to fallback to other providers...`);
    }

    try {
        const externalBrick = await getBrickFromExternalProvidersAsync(request, domain, hashLink);

        // saving the brick in the next cycle in order to not block the get brick request
        setTimeout(async () => {
            try {
                console.info(`[Bricking] Saving external brick ${hashLink} to own storage...`);
                await fsBrickStorage.addBrickAsync(externalBrick);
                console.info(`[Bricking] Saved external brick ${hashLink} to own storage`);
            } catch (error) {
                logger.warn(code, "[Bricking] Fail to manage external brick saving!", error);
            }
        });

        return externalBrick;
    } catch (error) {
        logger.debug(code, `[Bricking] Error while trying to get missing brick from fallback providers!`, error);
        throw error;
    }
}

module.exports = {
    convertReadableStreamToBuffer,
    getBricksDomainConfig,
    getBrickWithExternalProvidersFallbackAsync,
};

},{"../../config":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/apihub/config/index.js","../../utils":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/apihub/utils/index.js","../../utils/request-utils":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/apihub/utils/request-utils.js","opendsu":"opendsu","path":false}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/apihub/components/cloudWallet/controller.js":[function(require,module,exports){
const http = require("http");
const crypto = require("crypto");
const worker_threads = "worker_threads";
const { Worker } = require(worker_threads);
const config = require("../../config");
const { parseCookies, stringifyCookies } = require("../../utils/cookie-utils");
const path = require("swarmutils").path;
const logger = $$.getLogger("CloudWallet", "apihub/cloudWallet");
let dsuBootPath;
const dsuWorkers = {};

let cacheContainerPath;

const SSAPP_TOKEN_COOKIE_NAME = "SSAPP-TOKEN";

const getElapsedTime = (timer) => {
    const elapsed = process.hrtime(timer)[1] / 1000000;
    return `${elapsed.toFixed(3)} ms`;
};

const INVALID_DSU_HTML_RESPONSE = `
    <html>
    <body>
        <p>
            The application has encountered an unexpected error. <br/>
            If you have network issues please use the following to refresh the application.
        </p>
        <button id="refresh">Refresh</button>
        <script>
            document.getElementById("refresh").addEventListener("click", function() {
                window.top.location.reload();
            });
        </script>
    </body>
    </html>
`;

function addDsuWorker(seed, walletAnchorId, cookie) {
    const workerStartTime = process.hrtime();
    const dsuWorker = {
        port: null,
        authorizationKey: null,
        resolver: new Promise((resolve, reject) => {
            crypto.randomBytes(64, (err, randomBuffer) => {
                if (err) {
                    logger.error("Error while generating worker authorizationKey", err);
                    return reject(err);
                }

                const authorizationKey = randomBuffer.toString("hex");
                dsuWorker.authorizationKey = authorizationKey;
                logger.debug(`Starting worker for handling seed ${seed}`);
                const worker = new Worker(dsuBootPath, {
                    workerData: {
                        seed,
                        authorizationKey,
                        cookie,
                        cacheContainerPath,
                        walletAnchorId
                    },
                });

                worker.on("message", (message) => {
                    if (message.error) {
                        dsuWorkers[seed] = null;
                        return reject(message.error);
                    }
                    if (message.port) {
                        logger.debug(
                            `Running worker on PORT ${message.port} for seed ${seed}. Startup took ${getElapsedTime(
                                workerStartTime
                            )}`
                        );
                        dsuWorker.port = message.port;
                        resolve(worker);
                    }
                });
                worker.on("error", (error) => {
                    logger.error("worker error", error);
                });
                worker.on("exit", (code) => {
                    if (code !== 0) {
                        logger.debug(`Worker stopped with exit code ${code}`);
                        // remove the worker from list in order to be recreated when needed
                        delete dsuWorkers[seed];
                    }
                });

                dsuWorker.terminate = function () {
                    worker.terminate();
                };
            });
        }),
    };
    dsuWorkers[seed] = dsuWorker;
    return dsuWorker;
}

function forwardRequestToWorker(dsuWorker, req, res) {
    const method = req.method;
    const { keySSI } = req.params;
    let requestedPath = req.url.substr(req.url.indexOf(keySSI) + keySSI.length);
    if (!requestedPath) {
        requestedPath = "/";
    }
    if (!requestedPath.startsWith("/")) {
        requestedPath = `/${requestedPath}`;
    }

    const options = {
        hostname: "127.0.0.1",
        port: dsuWorker.port,
        path: requestedPath,
        method,
        headers: {
            authorization: dsuWorker.authorizationKey,
        },
    };

    if (req.headers.cookie) {
        options.headers.cookie = req.headers.cookie;
    }

    if (req.headers["content-type"]) {
        options.headers["content-type"] = req.headers["content-type"];
    }

    const workerRequest = http.request(options, (response) => {
        const { statusCode, headers } = response;
        res.statusCode = statusCode;
        const contentType = headers ? headers["content-type"] : null;
        res.setHeader("Content-Type", contentType || "text/html");

        if (statusCode < 200 || statusCode >= 300) {
            return res.end();
        }

        let data = [];
        response.on("data", (chunk) => {
            data.push(chunk);
        });

        response.on("end", () => {
            try {
                const bodyContent = $$.Buffer.concat(data);
                res.statusCode = statusCode;
                res.end(bodyContent);
            } catch (err) {
                logger.error("worker response error", err);
                res.statusCode = 500;
                res.end();
            }
        });
    });
    workerRequest.on("error", (err) => {
        logger.error("worker request error", err);
        res.statusCode = 500;
        res.end();
    });

    if (method === "POST" || method === "PUT") {
        let data = [];
        req.on("data", (chunk) => {
            logger.debug("data.push(chunk);", chunk);
            data.push(chunk);
        });

        req.on("end", () => {
            try {
                const bodyContent = $$.Buffer.concat(data);
                workerRequest.write(bodyContent);
                workerRequest.end();
            } catch (err) {
                logger.error("worker response error", err);
                res.statusCode = 500;
                res.end();
            }
        });
        return;
    }
    workerRequest.end();
}

function init(server) {
    logger.debug(`Registering CloudWallet component`);

    dsuBootPath = config.getConfig("componentsConfig", "cloudWallet", "dsuBootPath");

    if (dsuBootPath.startsWith(".")) {
        dsuBootPath = path.resolve(path.join(process.env.PSK_ROOT_INSTALATION_FOLDER, dsuBootPath));
    }

    logger.debug(`Using boot script for worker: ${dsuBootPath}`);

    cacheContainerPath = require("path").join(server.rootFolder, config.getConfig("externalStorage"), `cache`);

    //if a listening event is fired from this point on...
    //it means that a restart was triggered
    server.on("listening", () => {
        logger.debug(`Restarting process in progress...`);
        logger.debug(`Stopping a number of ${Object.keys(dsuWorkers).length} thread workers`);
        for (let seed in dsuWorkers) {
            let worker = dsuWorkers[seed];
            if (worker && worker.terminate) {
                worker.terminate();
            }
        }
    });
}

function handleCloudWalletRequest(request, response) {
    // use the keySSI set from the token middleware first (if present)
    const keySSI = request.keySSI || request.params.keySSI;

    let dsuWorker = dsuWorkers[keySSI];
    if (!dsuWorker) {
        dsuWorker = addDsuWorker(keySSI, request.walletAnchorId, request.headers.cookie);
    }

    dsuWorker.resolver
        .then(() => {
            forwardRequestToWorker(dsuWorker, request, response);
        })
        .catch((error) => {
            logger.error("worker resolver error", error);
            response.setHeader("Content-Type", "text/html");
            response.statusCode = 400;
            response.end(INVALID_DSU_HTML_RESPONSE);
        });
}

function getSSappTokenCookieValue(request) {
    const cookies = parseCookies(request.headers.cookie);
    let ssappTokenCookieValue = {};
    if (cookies[SSAPP_TOKEN_COOKIE_NAME]) {
        try {
            ssappTokenCookieValue = JSON.parse(cookies[SSAPP_TOKEN_COOKIE_NAME]);
            if (typeof ssappTokenCookieValue !== "object") {
                logger.error(
                    `Detected invalid ${SSAPP_TOKEN_COOKIE_NAME} cookie value (${cookies[SSAPP_TOKEN_COOKIE_NAME]}) parsed content`,
                    ssappTokenCookieValue
                );
                ssappTokenCookieValue = {};
            }
        } catch (error) {
            logger.error(`Failed to parse ${SSAPP_TOKEN_COOKIE_NAME} cookie value (${cookies[SSAPP_TOKEN_COOKIE_NAME]})`, error);
            // reset cookie value since it has an invalid JSON content
            ssappTokenCookieValue = {};
        }
    }
    return ssappTokenCookieValue;
}

function setRequestKeySSIFromSSAppToken(request, response, next) {
    const { keySSI } = request.params;
    const ssappTokenCookieValue = getSSappTokenCookieValue(request);
    if (ssappTokenCookieValue[keySSI]) {
        logger.info(`Found match for walletAnchorId ${keySSI}`);
        request.keySSI = ssappTokenCookieValue[keySSI];
        request.walletAnchorId = keySSI;
    }
    next();
}

function handleSetSSAppTokenRequest(request, response) {
    const { walletAnchorId } = request.params;
    const { sReadSSI } = request.body;

    if (!sReadSSI) {
        logger.error("Required sReadSSI body field not present");
        response.statusCode = 400;
        response.end();
    }

    const ssappTokenCookieValue = getSSappTokenCookieValue(request);
    ssappTokenCookieValue[walletAnchorId] = sReadSSI;

    const updatedTokenCookie = stringifyCookies({
        name: SSAPP_TOKEN_COOKIE_NAME,
        value: JSON.stringify(ssappTokenCookieValue),
        httpOnly: true,
        secure: true,
        path: "/",
        maxAge: 2147483647, // (2038-01-19 04:14:07) maximum value to avoid integer overflow on older browsers
    });
    response.setHeader("Set-Cookie", updatedTokenCookie);
    response.statusCode = 200;
    response.end();
}

module.exports = {
    init,
    handleCloudWalletRequest,
    setRequestKeySSIFromSSAppToken,
    handleSetSSAppTokenRequest,
};

},{"../../config":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/apihub/config/index.js","../../utils/cookie-utils":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/apihub/utils/cookie-utils.js","crypto":false,"http":false,"path":false,"swarmutils":"swarmutils"}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/apihub/components/cloudWallet/index.js":[function(require,module,exports){
function Iframe(server) {
    const {
        init,
        setRequestKeySSIFromSSAppToken,
        handleSetSSAppTokenRequest,
        handleCloudWalletRequest,
    } = require("./controller");
    const { requestBodyJSONMiddleware } = require("../../utils/middlewares");

    init(server);

    server.put(`/cloud-wallet/setSSAPPToken/:walletAnchorId`, requestBodyJSONMiddleware);
    server.put(`/cloud-wallet/setSSAPPToken/:walletAnchorId`, handleSetSSAppTokenRequest);

    server.use(`/cloud-wallet/:keySSI/*`, setRequestKeySSIFromSSAppToken);
    server.use(`/cloud-wallet/:keySSI/*`, handleCloudWalletRequest);
    server.use(`/:walletName/loader/cloud-wallet/:keySSI/*`, setRequestKeySSIFromSSAppToken);
    server.use(`/:walletName/loader/cloud-wallet/:keySSI/*`, handleCloudWalletRequest);

    // keep old URl style
    server.put(`/iframe/setSSAPPToken/:walletAnchorId`, requestBodyJSONMiddleware);
    server.put(`/iframe/setSSAPPToken/:walletAnchorId`, handleSetSSAppTokenRequest);

    server.use(`/iframe/:keySSI/*`, setRequestKeySSIFromSSAppToken);
    server.use(`/iframe/:keySSI/*`, handleCloudWalletRequest);
    server.use(`/:walletName/loader/iframe/:keySSI/*`, setRequestKeySSIFromSSAppToken);
    server.use(`/:walletName/loader/iframe/:keySSI/*`, handleCloudWalletRequest);
}

module.exports = Iframe;

},{"../../utils/middlewares":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/apihub/utils/middlewares/index.js","./controller":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/apihub/components/cloudWallet/controller.js"}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/apihub/components/config/index.js":[function(require,module,exports){
const config = require("../../config");

function Config(server) {
    const { requestBodyJSONMiddleware, responseModifierMiddleware } = require("../../utils/middlewares");

    function getDomainConfig(request, response) {
        const { domain } = request.params;
        const domainConfig = config.getDomainConfig(domain);

        if (!domainConfig) {
            return response.send(404, "Domain not found");
        }
        response.send(200, domainConfig);
    }

    function getDomainKeySSI(request, response) {
        const { domain } = request.params;
        const domainConfig = config.getDomainConfig(domain);
        const domainKeySSI = domainConfig && domainConfig.contracts ? domainConfig.contracts.constitution : null;
        response.send(200, domainKeySSI);
    }

    function validateDomainConfigInput(request, response, next) {
        if (!request.body || typeof request.body !== "object") {
            return response(400, "Invalid domain config specified");
        }
        next();
    }

    function updateDomainConfig(request, response) {
        const { domain } = request.params;
        const domainConfig = request.body;
        config.updateDomainConfig(domain, domainConfig, (error) => {
            if (error) {
                return response.send(500, error);
            }
            response.send(200);
        });
    }

    server.use(`/config/:domain/*`, responseModifierMiddleware);

    server.get(`/config/:domain`, getDomainConfig);
    server.get(`/config/:domain/keyssi`, getDomainKeySSI);

    server.put(`/config/:domain`, requestBodyJSONMiddleware);
    server.put(`/config/:domain`, validateDomainConfigInput);
    server.put(`/config/:domain`, updateDomainConfig);
}

module.exports = Config;

},{"../../config":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/apihub/config/index.js","../../utils/middlewares":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/apihub/utils/middlewares/index.js"}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/apihub/components/debugLogger/controllers.js":[function(require,module,exports){
const url = require('url');
const fs = require('fs');
const path = require('swarmutils').path;
const API_HUB = require('apihub');

let config = API_HUB.getServerConfig();
const rootFolder = path.resolve(config.storage);

const levels = {
  error: 'error',
  warning: 'warning',
  info: 'info',
  debug: 'debug',
};

const logger = $$.getLogger("debugLogger", "apihub/debugLogger");

function createHandlerAppendToLog() {
  return function appendToLog(request, response) {
    if (!request.body || !request.body.message) {
      response.send(400);
      return;
    }
    const message = request.body.message;
    const anchorID = request.params.anchorID;
    const logLevel = levels[request.params.logLevel] || levels['info'];

    let data;

    if (typeof message === 'string') {
      data = { date: new Date().toISOString(), level: logLevel, anchorID: anchorID, message: message };
    } else {
      response.send(400);
      return;
    }

    try {
      const today = new Date().toISOString().split('T')[0];
      const fileName = `${rootFolder}/${today}.json`;

      const exists = fs.existsSync(fileName);

      if (exists) {
        const existingData = fs.readFileSync(fileName);
        const json = JSON.parse(existingData);
        json.push(data);
        fs.writeFile(fileName, JSON.stringify(json), (err) => {
          if (err) {
            response.send(500);
            logger.error(err);
            logger.error(err);

          } else {
            response.send(200, data);

          }
        });
      } else {
        fs.writeFile(fileName, JSON.stringify([data]), (err) => {
          if (err) {
            response.send(500);
            logger.error(err);

          } else {
            response.send(200, data);

          }
        });
      }
    } catch (err) {
      logger.error(err);
      logger.error('Error writing file to disk');
    }
  };
}

function createHandlerReadFromLog() {
  return function readFromLog(request, response) {
    logger.debug('running');
    const today = new Date().toISOString().split('T')[0];
    const anchorID = request.params.anchorID;
    const queryObject = url.parse(request.url, true).query;
    const logLevel = levels[queryObject.logLevel] || levels['info'];

    let fromDate = queryObject.from ? Date.parse(queryObject.from) : Date.parse(today);
    const toDate = queryObject.to ? Date.parse(queryObject.to) : Date.parse(today);
    const oneDay = 1000 * 60 * 60 * 24;

    let promises = [];

    for (fromDate; fromDate <= toDate; fromDate += oneDay) {
      const date = new Date(fromDate).toISOString().split('T')[0];
      const fileName = `${rootFolder}/${date}.json`;
      const exists = fs.existsSync(fileName);

      if (!exists) {
        continue;
      }

      promises.push(
        new Promise((resolve, reject) => {
          fs.readFile(fileName, (err, data) => {
            if (err) {
              reject(err);
              return;
            }
            data = JSON.parse(data);
            data = data.filter((log) => log.anchorID === anchorID);
            data = data.filter((log) =>
              logLevel === levels['debug']
                ? log.level === levels['info'] ||
                  log.level === levels['error'] ||
                  log.level === levels['warning'] ||
                  log.level === levels['debug']
                : logLevel === levels['error']
                ? log.level === levels['info'] || log.level === levels['error'] || log.level === levels['warning']
                : logLevel === levels['warning']
                ? log.level === levels['info'] || log.level === levels['warning']
                : log.level === levels['info']
            );

            resolve(data);
          });
        })
      );
    }

    Promise.all(promises).then((result) => {
      response.send(200, result.flat());
    });
  };
}

module.exports = { createHandlerAppendToLog, createHandlerReadFromLog };

},{"apihub":"apihub","fs":false,"swarmutils":"swarmutils","url":false}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/apihub/components/debugLogger/index.js":[function(require,module,exports){
function DebugLogger(server) {
  const { responseModifierMiddleware, requestBodyJSONMiddleware } = require('../../utils/middlewares');
  const { createHandlerAppendToLog, createHandlerReadFromLog } = require('./controllers');

  const appendToLog = createHandlerAppendToLog();
  const readFromLog = createHandlerReadFromLog();

  server.use(`/log/*`, responseModifierMiddleware);
  server.use(`/log/*`, requestBodyJSONMiddleware);

  server.post(`/log/add/:anchorID/:logLevel`, appendToLog);
  server.get(`/log/get/:anchorID`, readFromLog);
}

module.exports = DebugLogger;

},{"../../utils/middlewares":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/apihub/utils/middlewares/index.js","./controllers":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/apihub/components/debugLogger/controllers.js"}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/apihub/components/installation-details/index.js":[function(require,module,exports){
function InstallationDetails(server){

	function getLog(targetPath, callback){
		const child_process = require("child_process");
		const path = require("path");

		const basicProcOptions = {cwd: path.resolve(targetPath), stdio: [0, "pipe", "pipe"]};
		child_process.exec(" git log -n 1  --pretty=oneline", basicProcOptions, function (err, stdout) {
			if (err) {
				return callback(err);
			}
			let sep = " ";
			let fragments = stdout.split(sep);
			let details = {
				commitNo: fragments.shift(),
				commitMessage: fragments.join(sep)
			};
			return callback(undefined, details);
		});
	}

	function sendSummary(res, summary){
		res.setHeader('Content-Type', 'application/json');
		res.write(JSON.stringify(summary));
		res.end();
	}

	function detailsHandler(req, res){
		const path = require("path");
		//targetPath = the workspace folder
		let targetPath = path.resolve("..");
		let summary = {};
		summary.resourceUsage = getProcessResourceUsage();
		getLog(targetPath, (err, log)=>{
			if(err){
				return sendSummary(res, {err});
			}
			summary[path.basename(targetPath)] = log;

			//targetPath = the privatesky folder
			let tPath = path.resolve(".");
			getLog(tPath, (err, log)=>{
				if(err){
					return sendSummary(res, {err, summary});
				}
				summary[path.basename(tPath)] = log;
				return sendSummary(res, summary);
			});
		});
	}
	
	function getProcessResourceUsage() {
		const resourceUsage = process.resourceUsage();
		resourceUsage.uptime = process.uptime();
		return resourceUsage;
	}

	server.get("/installation-details", detailsHandler);
}

module.exports = InstallationDetails;
},{"child_process":false,"path":false}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/apihub/components/keySsiNotifications/constants.js":[function(require,module,exports){
const URL_PREFIX = '/notifications';

module.exports = { URL_PREFIX };
},{}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/apihub/components/keySsiNotifications/index.js":[function(require,module,exports){
function KeySSINotifications(server) {
	const logger = $$.getLogger("KeySSINotifications", "apihub/keySsiNotifications");
	let notificationManager;
	const utils = require('../../utils');
	const readBody = utils.streams.readStringFromStream;
	const config = require('../../config');
	const { responseModifierMiddleware } = require('./../../utils/middlewares');
	const { URL_PREFIX } = require('./constants');
	const path = require("path");
	const workingDirPath = path.join(server.rootFolder, config.getConfig('componentsConfig', 'notifications', 'workingDirPath'));
    const QUEUED_MESSAGE_LIFETIME = 500; // (ms) Delete undelivered messages after this timeout

	function publish(request, response) {
		let anchorId = request.params.anchorId;

		readBody(request, (err, message) => {
			if (err) {
				return response.send(400);
			}

			notificationManager.createQueue(anchorId, function (err) {
				if (err) {
					if (err.statusCode) {
						if (err.statusCode !== 409) {
							return response.send(err.statusCode);
						}
					} else {
						return response.send(500);
					}
				}

				notificationManager.sendMessage(anchorId, message, QUEUED_MESSAGE_LIFETIME, function (err, counter) {
					if (err) {
						return response.send(500);
					}

					let message;

					if (counter > 0) {
						message = `Message delivered to ${counter} subscribers.`;
					} else {
						message = `Message was added to queue and will be delivered later.`;
					}

					return response.send(200, message);
				});
			});
		});
	}

	function subscribe(request, response) {
		let anchorId = request.params.anchorId;

		notificationManager.createQueue(anchorId, function (err) {
			if (err) {
				if (err.statusCode) {
					if (err.statusCode !== 409) {
						return response.send(err.statusCode);
					}
				} else {
					return response.send(500);
				}
			}

			notificationManager.readMessage(anchorId, function (err, message) {
				try {
					if (err) {
						return response.send(err.statusCode || 500, message);
					}

					response.send(200, message);
				} catch (err) {
					//here we expect to get errors when a connection has reached timeout
					logger.error(err);
					response.send(400, 'opps');
				}
			});
		});
	}

	function unsubscribe(request, response) {
		//to be implemented later
		response.send(503);
	}

	require('./../../libs/Notifications').getManagerInstance(workingDirPath, (err, instance) => {
		if (err) {
			return logger.error(err);
		}

		notificationManager = instance;
		server.use(`${URL_PREFIX}/*`, responseModifierMiddleware)

		server.post(`${URL_PREFIX}/subscribe/:anchorId`, subscribe);
		server.delete(`${URL_PREFIX}/unsubscribe/:anchorId`, unsubscribe);
		server.put(`${URL_PREFIX}/publish/:anchorId`, publish);
	});
}

module.exports = KeySSINotifications;

},{"../../config":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/apihub/config/index.js","../../utils":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/apihub/utils/index.js","./../../libs/Notifications":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/apihub/libs/Notifications.js","./../../utils/middlewares":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/apihub/utils/middlewares/index.js","./constants":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/apihub/components/keySsiNotifications/constants.js","path":false}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/apihub/components/lightDBEnclave/index.js":[function(require,module,exports){
const logger = $$.getLogger("lightDB", "apihub");
const httpWrapper = require("../../libs/http-wrapper/src/httpUtils");
const prefix = "lightDB";
function LightDBEnclave(server) {
    function forwardRequest(path, data, callback){
        const endpoint = process.env.LIGHT_DB_SERVER_ADDRESS || "http://127.0.0.1:8081";
        let protocol = endpoint.indexOf("https://") === 0 ? "https" : "http";
        protocol = require(protocol);

        let request = protocol.request(`${endpoint}${path}`, {method: "PUT"}, (resp) => {
            resp.body = "";

            // A chunk of data has been received.
            resp.on("data", (chunk) => {
                resp.body += chunk;
            });

            // The whole response has been received. Print out the result.
            resp.on("end", () => {
                callback(undefined, resp);
            });
        });

        request.on("error", callback);

        request.write(data);
        request.end();
    }

    server.put(`/${prefix}/executeCommand/:dbName`, httpWrapper.bodyParser);

    server.put(`/${prefix}/executeCommand/:dbName`, function (req, res) {
        const url = `/executeCommand/${req.params.dbName}`;
        forwardRequest(url, req.body, (err, response) => {
            if (err) {
                res.statusCode = 500;
                logger.error(`Error while executing command ${JSON.parse(req.body).commandName}`, err);
                res.write(err.message);
                return res.end();
            }

            res.statusCode = response.statusCode;
            res.write(response.body);
            res.end();
        });
    });

    server.put(`/${prefix}/createDatabase/:dbName`, function (req, res){
        const url = `/createDatabase/${req.params.dbName}`;

        forwardRequest(url, "", (err, response) => {
            if (err) {
                res.statusCode = 500;
                logger.error(`Error while creating database ${req.params.dbName}`, err);
                res.write(err.message);
                return res.end();
            }

            res.statusCode = response.statusCode;
            res.write(response.body);
            res.end();
        });
    });
}

module.exports = LightDBEnclave;
},{"../../libs/http-wrapper/src/httpUtils":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/apihub/libs/http-wrapper/src/httpUtils.js"}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/apihub/components/mainDSU/controller.js":[function(require,module,exports){
const path = require("path");
const fs = require("fs");
const config = require("../../config");
const { parseCookies, stringifyCookies } = require("../../utils/cookie-utils");

const logger = $$.getLogger("controller", "apihub/mainDSU");

const MAIN_DSU_VALUE_COOKIE_NAME = "MAIN-DSU-VALUE";
const MAIN_DSU_VALUE_COOKIE_DEFAULT = "default";

// keep already loaded main DSUs KeySSI
const cachedMainDSUSeedSSIs = {};

let rootFolderPath;
let mainDSUSeedSSIFolderPath;

async function init(server) {
    logger.debug(`[MainDSU] Registering MainDSU component`);
    rootFolderPath = server.rootFolder;
    mainDSUSeedSSIFolderPath = path.join(server.rootFolder, config.getConfig("externalStorage"), "maindsu");
    logger.debug(`[MainDSU] Ensuring MainDSU seedSSI folder (${mainDSUSeedSSIFolderPath}) is created`);
    try {
        await $$.promisify(fs.mkdir)(mainDSUSeedSSIFolderPath, { recursive: true });
    } catch (error) {
        logger.error("[MainDSU] Failed to create MainDSU seedSSI folder", error);
    }
}

function sendMainDSUSeedSSI(mainDSUFileName, response) {
    response.statusCode = 200;
    response.write(cachedMainDSUSeedSSIs[mainDSUFileName].getIdentifier());
    response.end();
}

function getMainDSUFileNameForRequest(request) {
    const cookies = request.headers ? parseCookies(request.headers.cookie) : {};
    const valueCookie = cookies[MAIN_DSU_VALUE_COOKIE_NAME];
    if (valueCookie) {
        const crypto = require("pskcrypto");
        // we need to ensure some filename limit due to some OS filename size restrictions
        const valueCookieHash = crypto.pskHash(valueCookie, "hex");
        return valueCookieHash;
    }
    return MAIN_DSU_VALUE_COOKIE_DEFAULT;
}

async function handleSetSSIForMainDSUCookie(request, response) {
    const { value } = request.body;

    if (value == null) {
        logger.error("Required value body field not present");
        response.statusCode = 400;
        response.end();
    }

    const cookie = stringifyCookies({
        name: MAIN_DSU_VALUE_COOKIE_NAME,
        value: value,
        httpOnly: true,
        path: "/",
        maxAge: 2147483647, // (2038-01-19 04:14:07) maximum value to avoid integer overflow on older browsers
    });
    response.setHeader("Set-Cookie", cookie);
    response.statusCode = 200;
    response.end();
}

async function handleDefaultMainDSURequest(request, response) {
    const mainDSUFileName = getMainDSUFileNameForRequest(request);

    if (cachedMainDSUSeedSSIs[mainDSUFileName]) {
        return sendMainDSUSeedSSI(mainDSUFileName, response);
    }

    const mainDSUSeedSSIFilePath = path.join(mainDSUSeedSSIFolderPath, mainDSUFileName);

    const fs = require("fs");
    const keySSISpace = require("opendsu").loadApi("keyssi");
    const resolver = require("opendsu").loadApi("resolver");
    let mainDSUSeedSSI;
    let mainDSUAnchorId;
    try {
        const fileContent = await $$.promisify(fs.readFile)(mainDSUSeedSSIFilePath, { encoding: "utf-8" });
        mainDSUSeedSSI = keySSISpace.parse(fileContent);
        cachedMainDSUSeedSSIs[mainDSUFileName] = mainDSUSeedSSI;
        mainDSUAnchorId = await $$.promisify(mainDSUSeedSSI.getAnchorId)();
        logger.debug(`[MainDSU] Read existing mainDSU from ${mainDSUSeedSSIFilePath}: ${mainDSUAnchorId}`);
        return sendMainDSUSeedSSI(mainDSUFileName, response);
    } catch (error) {
        logger.error(`[MainDSU] Failed to read/parse keySSI from ${mainDSUSeedSSIFilePath}. Generating new keySSI...`, error);
    }

    try {
        const environmentJsPath = require("path").join(rootFolderPath, "environment.js");
        logger.debug(`[MainDSU] Loading environment.js config file from: ${environmentJsPath}`);

        const environmentConfig = require(environmentJsPath);

        const seedSSI = await $$.promisify(keySSISpace.createSeedSSI)(environmentConfig.vaultDomain);
        const mainDSU = await $$.promisify(resolver.createDSUForExistingSSI)(seedSSI);

        logger.debug(`[MainDSU] Settings config for seed ${await $$.promisify(seedSSI.getAnchorId)()}`, environmentConfig);
        let batchId = await $$.promisify(mainDSU.safeBeginBatch)();
        await $$.promisify(mainDSU.writeFile)("/environment.json", JSON.stringify(environmentConfig));

        mainDSUSeedSSI = seedSSI;
        cachedMainDSUSeedSSIs[mainDSUFileName] = mainDSUSeedSSI;
        mainDSUAnchorId = await $$.promisify(mainDSUSeedSSI.getAnchorId)();
        logger.debug("[MainDSU] Generated mainDSUSeedSSI: ", mainDSUAnchorId, mainDSUSeedSSI);

        logger.debug(`[MainDSU] Writing generated mainDSU to ${mainDSUSeedSSIFilePath}: ${mainDSUAnchorId}`);
        await $$.promisify(fs.writeFile)(mainDSUSeedSSIFilePath, mainDSUSeedSSI.getIdentifier(), "utf-8");
        await $$.promisify(mainDSU.commitBatch(batchId));
        sendMainDSUSeedSSI(mainDSUFileName, response);
    } catch (error) {
        logger.error("[MainDSU] Failed to create seedSSI", error);
        response.statusCode = 500;
        response.setHeader("Content-Type", "text/html");
        response.end("Failed to create seedSSI");
    }
}

module.exports = {
    init,
    handleSetSSIForMainDSUCookie,
    handleDefaultMainDSURequest,
};

},{"../../config":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/apihub/config/index.js","../../utils/cookie-utils":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/apihub/utils/cookie-utils.js","fs":false,"opendsu":"opendsu","path":false,"pskcrypto":"pskcrypto"}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/apihub/components/mainDSU/index.js":[function(require,module,exports){
function MainDSU(server) {
    const { init, handleSetSSIForMainDSUCookie, handleDefaultMainDSURequest } = require("./controller");
    const { requestBodyJSONMiddleware } = require("../../utils/middlewares");

    init(server);

    server.put("/setSSIForMainDSUCookie", requestBodyJSONMiddleware);
    server.put("/setSSIForMainDSUCookie", handleSetSSIForMainDSUCookie);

    // for mobile app, when it includes the expanded DSU content instead of the actual DSU;
    // this will return a static DSU in order to set it as a main context
    server.use("/getSSIForMainDSU", handleDefaultMainDSURequest);
}

module.exports = MainDSU;

},{"../../utils/middlewares":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/apihub/utils/middlewares/index.js","./controller":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/apihub/components/mainDSU/controller.js"}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/apihub/components/mqHub/adapters/MQAdapterMixin.js":[function(require,module,exports){
(function (Buffer){(function (){
function MQAdapterMixin(target, server, prefix, domain, configuration) {
    const logger = $$.getLogger("MQAdapterMixin", "apihub/mqHub");

    const subscribers = {};
    const config = require("../../../config");
    let domainConfig = config.getDomainConfig(domain);
    const utils = require('./../../../utils');
    const readBody = utils.streams.readStringFromStream;

    const settings = {
        mq_messageMaxSize: domainConfig["mq_messageMaxSize"] || 10 * 1024,
        mq_queueLength: domainConfig["mq_queueLength"] || 10000
    };

    Object.assign(settings, configuration);

    function send(res, statusCode, message, headers) {
        res.statusCode = statusCode;

        if (headers) {
            for (let prop in headers) {
                try {
                    res.setHeader(prop, headers[prop]);
                } catch (e) {
                    logger.error(`Failed to set headers after end() was called.`, e);
                    return;
                }
            }
        }

        if (message) {
            res.write(message);
        }
        res.end();
    }

    function checkQueueLoad(queueName, callback) {
        target.loadQueue(queueName, (err, files) => {
            if (err) {
                return callback(err);
            }
            callback(undefined, files.length);
        });
    }

    function _readMessage(queueName, messageId, callback) {
        if (typeof messageId === "function") {
            callback = messageId;
            messageId = undefined;
        }
        target.loadQueue(queueName, (err, messageIds) => {
            if (err) {
                return callback(err);
            }

            if (typeof messageId !== "undefined") {
                if (messageIds.indexOf(messageId) !== -1) {
                    return callback(Error("Message not found."));
                }
            } else {
                messageId = messageIds[0];
            }
            return target.getMessage(queueName, messageId, callback);
        });
    }

    function deliverMessage(subs, message, callback) {
        let counter = 0;
        while (subs.length > 0) {
            let sub = subs.pop();
            try {
                sub(undefined, message);
                counter++;
            } catch (err) {
                //if something happens during message delivery we will catch the error here
            }
        }
        callback(undefined, counter);
    }

    function putMessage(queueName, message, callback) {
        checkQueueLoad(queueName, (err, capacity) => {
            if (err) {
                return callback(err);
            }

            if (typeof subscribers[queueName] === 'undefined') {
                subscribers[queueName] = [];
            }

            const capacityLimit = Number(settings.mq_queueLength);

            if(capacity > capacityLimit){
                const err = new Error("Queue size exceeded!");
                err.sendToUser = true;
                return callback(err);
            }

            if (capacity > 0) {
                return target.storeMessage(queueName, message, callback);
            }

            //if queue is empty we should try to deliver the message to a potential subscriber that waits
            const subs = subscribers[queueName];
            target.storeMessage(queueName, message, (err)=>{
                if (err) {
                    return callback(err);
                }
                return _readMessage(queueName, (err, _message) => {
                    if (err) {
                        return callback(err);
                    }
                    deliverMessage(subs, _message, callback);
                });
            })
        });
    }

    function readMessage(queueName, callback) {
        checkQueueLoad(queueName, (err, capacity) => {
            if (err) {
                return callback(err);
            }

            if (typeof subscribers[queueName] === 'undefined') {
                subscribers[queueName] = [];
            }

            const subs = subscribers[queueName];
            subs.push(callback);

            if (capacity) {
                return _readMessage(queueName, (err, message) => {
                    deliverMessage(subs, message, (err, successCount) => {
                        if (err) {
                            logger.error(err);
                        }

                        logger.debug(`Successfully sent message to a number of ${successCount} subs.`);
                    });
                });
            } else {
                //no message available in queue
            }
        });
    }

    function putMessageHandler(request, response) {
        let queueName = request.params.queueName;
        readBody(request, (err, message) => {
            if (err) {
                logger.error(`Caught an error during body reading from put message request`, err);
                return send(response, 500);
            }

            if (typeof settings.mq_messageMaxSize !== "undefined") {
                const messageMaxSize = Number(settings.mq_messageMaxSize);
                try {
                    let messageAsBuffer = Buffer.from(message);
                    if (messageAsBuffer.length > messageMaxSize) {
                        send(response, 403, "Message size exceeds domain specific limit.");
                        return;
                    }
                } catch (err) {
                    logger.error("Not able to confirm message size. Going on with the flow...");
                }
            }

            putMessage(queueName, message, (err) => {
                if (err) {
                    logger.error(`Caught an error during adding message to queue`, err);
                    return send(response, 500, err.sendToUser ? err.message : undefined);
                }
                send(response, 200);
            });
        });
    }

    function getMessageHandler(request, response) {
        let queueName = request.params.queueName;
        let wasCalled = false;
        const readMessageCallback = (err, message) => {
            if (wasCalled) {
                return;
            }
            wasCalled = true;
            if (err) {
                send(response, 500);
                return;
            }
            send(response, 200, JSON.stringify(message), {'Content-Type': 'application/json'});
        };

        const mqConfig = config.getConfig("componentsConfig", "mq");
        if (mqConfig && mqConfig.connectionTimeout) {
            setTimeout(() => {
                if (!wasCalled) {
                    if (subscribers[queueName]) {
                        const fnRefIndex = subscribers[queueName].findIndex(fn => fn === readMessageCallback);
                        if (fnRefIndex >= 0) {
                            subscribers[queueName].splice(fnRefIndex, 1);
                        }
                    }
                    response.statusCode = 204;
                    response.end();
                }
            }, mqConfig.connectionTimeout);
        }

        readMessage(queueName, readMessageCallback);
    }

    function deleteMessageHandler(request, response) {
        let {queueName, messageId} = request.params;
        target.deleteMessage(queueName, messageId, (err) => {
            if (err) {
                logger.error(`Caught an error during deleting message ${messageId} from queue ${queueName}`, err);
            }
            send(response, err ? 500 : 200);
        });
    }

    function takeMessageHandler(request, response) {
        const queueName = request.params.queueName;
        readMessage(queueName, (err, message) => {
            if (err) {
                logger.error(`Caught an error during message reading from ${queueName}`, err);
                send(response, 500);
                return;
            }
            target.deleteMessage(queueName, message.messageId, (err) => {
                if (err) {
                    logger.error(`Caught an error during message deletion from ${queueName} on the take handler`, err);
                    return send(response, 500);
                }

                return send(response, 200, JSON.stringify(message), {'Content-Type': 'application/json'});
            });
        });
    }

    server.put(`${prefix}/${domain}/put/:queueName`, putMessageHandler); //< message

    server.get(`${prefix}/${domain}/get/:queueName/:signature_of_did`, getMessageHandler); //  > {message}
    server.delete(`${prefix}/${domain}/delete/:queueName/:messageId/:signature_of_did`, deleteMessageHandler);

    server.get(`${prefix}/${domain}/take/:queueName/:signature_of_did`, takeMessageHandler); //  > message
}

module.exports = MQAdapterMixin;
}).call(this)}).call(this,require("buffer").Buffer)

},{"../../../config":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/apihub/config/index.js","./../../../utils":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/apihub/utils/index.js","buffer":false}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/apihub/components/mqHub/adapters/lighDBEnclaveAdapter.js":[function(require,module,exports){
function LightDBEnclaveAdapter(server, prefix, domain, configuration) {
    const logger = $$.getLogger("LokiMQAdapter", "apihub/mqHub");
    const config = require("../../../config");
    let domainConfig = config.getDomainConfig(domain);

    const settings = {
        mq_messageMaxSize: domainConfig["mq_messageMaxSize"] || 10 * 1024,
        mq_queueLength: domainConfig["mq_queueLength"] || 10000
    };

    Object.assign(settings, configuration);

    const MQAdapterMixin = require("./MQAdapterMixin");
    MQAdapterMixin(this, server, prefix, domain, configuration);
    const DB_NAME = "mqDB";
    const lightDBEnclaveClient = require("opendsu").loadAPI("enclave").initialiseLightDBEnclave(DB_NAME);
    const ensureDBIsInitialised = (callback) => {
        lightDBEnclaveClient.createDatabase(DB_NAME,(err) => {
            if (!err) {
                return lightDBEnclaveClient.hasWriteAccess($$.SYSTEM_IDENTIFIER, (err, hasAccess) => {
                    if (err) {
                        return callback(err);
                    }

                    if (hasAccess) {
                        return callback();
                    }

                    lightDBEnclaveClient.grantWriteAccess($$.SYSTEM_IDENTIFIER, callback);
                })
            }

            return callback();
        });
    }

    this.loadQueue = (queueName, callback) => {
        ensureDBIsInitialised((err) => {
            if (err) {
                return callback(err);
            }

            lightDBEnclaveClient.listQueue($$.SYSTEM_IDENTIFIER, queueName, callback);
        });
    }

    this.storeMessage = (queueName, message, callback) => {
        if (typeof message !== "object") {
            message = {message};
        }
        ensureDBIsInitialised((err) => {
            if (err) {
                return callback(err);
            }

            lightDBEnclaveClient.addInQueue($$.SYSTEM_IDENTIFIER, queueName, message, true, callback);
        });
    }

    this.getMessage = (queueName, messageId, callback) => {
        ensureDBIsInitialised((err) => {
            if (err) {
                return callback(err);
            }

            lightDBEnclaveClient.getObjectFromQueue($$.SYSTEM_IDENTIFIER, queueName, messageId, (err, message) => {
                if (err) {
                    return callback(err);
                }
                if (!message) {
                    return callback(Error(`Message ${messageId} not found in queue ${queueName}`));
                }

                message.messageId = messageId;
                return callback(undefined, message);
            });
        });
    }

    this.deleteMessage = (queueName, messageId, callback) => {
        ensureDBIsInitialised((err) => {
            if (err) {
                return callback(err);
            }

            lightDBEnclaveClient.deleteObjectFromQueue($$.SYSTEM_IDENTIFIER, queueName, messageId, callback);
        });
    }

    logger.debug(`Loading Loki MQ Adapter for domain: ${domain}`);
}

module.exports = LightDBEnclaveAdapter;

},{"../../../config":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/apihub/config/index.js","./MQAdapterMixin":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/apihub/components/mqHub/adapters/MQAdapterMixin.js","opendsu":"opendsu"}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/apihub/components/mqHub/adapters/localMQAdapter.js":[function(require,module,exports){
function LocalMQAdapter(server, prefix, domain, configuration) {
	const logger = $$.getLogger("LocalMQAdapter", "apihub/mqHub");
	const config = require("../../../config");
	const swarmUtils = require('swarmutils');
	let path = swarmUtils.path;
	const FILENAME_DELIMITER = "_special_mqs_delimiter_";

	let storage = config.getConfig('componentsConfig', 'mqs', 'storage');
	let domainConfig = config.getDomainConfig(domain);
	if (typeof storage === "undefined") {
		storage = path.join(server.rootFolder, "external-volume", "mqs", domain);
	} else {
		storage = path.join(path.resolve(storage), domain);
	}

	const settings = {
		mq_fsStrategyStorageFolder: storage,
		mq_messageMaxSize: domainConfig["mq_messageMaxSize"] || 10 * 1024,
		mq_queueLength: domainConfig["mq_queueLength"] || 10000
	};

	const MQAdapterMixin = require("./MQAdapterMixin");
	MQAdapterMixin(this, server, prefix, domain, configuration);

	this.loadQueue = (queueName, callback) => {
		require('fs').readdir(getQueueStoragePath(queueName), (err, files) => {
			if (err) {
				if(err.code !== "ENOENT"){
					return callback(err);
				}
				//storage folder for the queue doesn't exist => empty queue
				return callback(undefined, []);
			}
			let messages = files.filter(fileNamesAsTimestamp => {
				fileNamesAsTimestamp = sanitizeFileName(fileNamesAsTimestamp);
				let valid = (new Date(Number(fileNamesAsTimestamp))).getTime() > 0;
				if (!valid) {
					logger.debug(`Found garbage in queue ${queueName} (file: ${fileNamesAsTimestamp}). Ignoring it!`);
				}
				return valid;
			});

			messages.sort(function (a, b) {
				a = sanitizeFileName(a);
				b = sanitizeFileName(b);
				return (new Date(Number(a))).getTime() - (new Date(Number(b))).getTime();
			});
			return callback(undefined, messages);
		});
	}

	function getQueueStoragePath(queueName) {
		const opendsu = require("opendsu");
		const crypto = opendsu.loadAPI('crypto');
		if (queueName.indexOf(':') !== -1) {
			queueName = crypto.encodeBase58(queueName);
		}
		return path.join(settings.mq_fsStrategyStorageFolder, queueName);
	}

	function sanitizeFileName(filename){
		if(filename.indexOf(FILENAME_DELIMITER)!==-1){
			//if we find filename_delimiter in filename then we need to remove the delimiter in order to be able to sort the queue
			filename = filename.split(FILENAME_DELIMITER)[0];
		}
		return filename;
	}

	function constructFileName(proposedFileName, callback) {
		let finalName = proposedFileName;
		let filename = sanitizeFileName(finalName);
		let counter = -1;

		let FS = require('fs');

		if(filename!==finalName){
			counter = Number(finalName.replace(filename+FILENAME_DELIMITER, ""));
		}

		let exists = FS.statSync(finalName, {throwIfNoEntry: false});
		if(!exists){
			try{
				FS.writeFileSync(finalName, "");
			}catch (e){
				//we ignore this e on purpose
			}
            callback(undefined, finalName);
        }else{
			counter++;
			finalName = filename+FILENAME_DELIMITER+counter;
			constructFileName(finalName, callback);
		}
	}

	this.storeMessage = (queueName, message, callback) => {
		const queueDir = getQueueStoragePath(queueName);
		require('fs').mkdir(queueDir, {recursive: true}, (err)=>{
			if (err) {
				return callback(err);
			}

			let fileName = path.join(getQueueStoragePath(queueName), new Date().getTime());
			let FS = require('fs');
			constructFileName(fileName, (err, finalName)=>{
				FS.writeFile(finalName, message, (err) => {
					if (err) {
						return callback(err);
					}
					return callback(undefined, finalName);
				});
			});
		});
	}

	function getMessagePath(queueName, messageId) {
		return path.join(getQueueStoragePath(queueName), messageId);
	}

	this.getMessage = (queueName, messageId, callback) => {
		let fileName = getMessagePath(queueName, messageId);
		require('fs').readFile(fileName, (err, message) => {
			if (err) {
				return callback(err);
			}
			return callback(undefined, {message:message.toString(), messageId});
		});
	}

	this.deleteMessage = (queueName, messageId, callback) => {
		let fileName = getMessagePath(queueName, messageId);
		require('fs').unlink(fileName, callback);
	}

	logger.debug(`Loading Local MQ Adapter for domain: ${domain}`);
}


module.exports = LocalMQAdapter;
},{"../../../config":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/apihub/config/index.js","./MQAdapterMixin":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/apihub/components/mqHub/adapters/MQAdapterMixin.js","fs":false,"opendsu":"opendsu","swarmutils":"swarmutils"}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/apihub/components/mqHub/adapters/lokiMQAdapter.js":[function(require,module,exports){
function LokiMQAdapter(server, prefix, domain, configuration) {
    const logger = $$.getLogger("LokiMQAdapter", "apihub/mqHub");
    const config = require("../../../config");
    let domainConfig = config.getDomainConfig(domain);
    const path = require("path");
    let storage = config.getConfig('componentsConfig', 'mqs', 'storage');
    if (typeof storage === "undefined") {
        storage = path.join(server.rootFolder, "external-volume", "mqs", domain, "messages");
    } else {
        storage = path.join(path.resolve(storage), domain);
    }
    const fs = require("fs");
    try {
        fs.accessSync(storage);
    } catch (err) {
        fs.mkdirSync(path.dirname(storage), {recursive: true});
    }
    const lokiEnclaveFacadeModule = require("loki-enclave-facade");
    const lokiEnclaveFacadeInstance = lokiEnclaveFacadeModule.createLokiEnclaveFacadeInstance(storage);

    const settings = {
        mq_messageMaxSize: domainConfig["mq_messageMaxSize"] || 10 * 1024,
        mq_queueLength: domainConfig["mq_queueLength"] || 10000
    };

    Object.assign(settings, configuration);

    const MQAdapterMixin = require("./MQAdapterMixin");
    MQAdapterMixin(this, server, prefix, domain, configuration);

    this.loadQueue = (queueName, callback) => {
        lokiEnclaveFacadeInstance.listQueue(undefined, queueName, callback);
    }

    this.storeMessage = (queueName, message, callback) => {
        if(typeof message !== "object"){
            message = {message};
        }
        lokiEnclaveFacadeInstance.addInQueue(undefined, queueName, message, true, callback);
    }

    this.getMessage = (queueName, messageId, callback) => {
        lokiEnclaveFacadeInstance.getObjectFromQueue(undefined, queueName, messageId, (err, message) => {
            if (err) {
                return callback(err);
            }
            if (!message) {
                return callback(Error(`Message ${messageId} not found in queue ${queueName}`));
            }

            message.messageId = messageId;
            return callback(undefined, message);
        });
    }

    this.deleteMessage = (queueName, messageId, callback) => {
        lokiEnclaveFacadeInstance.deleteObjectFromQueue(undefined, queueName, messageId, callback);
    }

    logger.debug(`Loading Loki MQ Adapter for domain: ${domain}`);
}

module.exports = LokiMQAdapter;

},{"../../../config":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/apihub/config/index.js","./MQAdapterMixin":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/apihub/components/mqHub/adapters/MQAdapterMixin.js","fs":false,"loki-enclave-facade":"loki-enclave-facade","path":false}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/apihub/components/mqHub/adapters/solaceMQAdapter.js":[function(require,module,exports){
function SolaceMQAdapter(){
	throw new Error("Not Implemented!!!");
}

module.exports = SolaceMQAdapter;
},{}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/apihub/components/mqHub/auth/JWTIssuer.js":[function(require,module,exports){
const DOMAIN_NAME = "MQ_DOMAIN";
const SEEDER_FILE_NAME = "mq_JWT_Auth_Seeder";

const defaultSettings = {
	//todo: implement them later!!!
	mq_nonce_from_smart_contract: false,
	mq_nonce_from_expiring_uuid: true,

	mq_nonce_expiration_time: 10 * 1000//sec
}

function JWTIssuer(workingDir) {
	const logger = $$.getLogger("JWTIssuer", "apihub/mqHub");
	let seeder;
	const config = require("./../../../config");

	function getDomainSpecificConfig(domainName){
		let domainSpecificConfig = JSON.parse(JSON.stringify(defaultSettings));
		Object.assign(domainSpecificConfig, config.getDomainConfig(domainName));
		return domainSpecificConfig;
	}

	function getSeederFilePath(){
		return require("path").join(workingDir, config.getConfig("externalStorage"), SEEDER_FILE_NAME);
	}

	async function init() {
		const fs = require("fs");
		const opendsu = require("opendsu");
		const keyssiApi = opendsu.loadApi("keyssi");
		const code = 601;
		try {
			seeder = await $$.promisify(fs.readFile)(getSeederFilePath());
		} catch (err) {
			if (err.code !== "ENOENT") {
				logger.debug(code, "Not able to read the Issuer persistence file needed by JWT Auth Support layer!", err);
			}
		}

		if (seeder) {
			try {
				seeder = keyssiApi.parse(seeder.toString());
				logger.debug("MQ JWT AUTH Issuer loaded.");
				return;
			} catch (err) {
				logger.info(code, "Failed to load MQ JWT AUTH Issuer info. Creating a new Issuer!",
					"\nPrevious tokens will not be valid anymore!!!");
			}
		}

		//TODO: what happens if it fails to generate and write to file?

		seeder = await $$.promisify(keyssiApi.createSeedSSI)(DOMAIN_NAME);
		await $$.promisify(fs.writeFile)(getSeederFilePath(), seeder.getIdentifier());
		logger.debug("New MQ JWT AUTH Issuer created and saved for later use.");
	}

	this.createToken = function (domain, options, callback) {
		if (typeof options === "function") {
			callback = options;
			options = {};
		}

		function createToken() {
			const opendsu = require("opendsu");
			const crypto = opendsu.loadApi("crypto");
			const keyssiApi = opendsu.loadApi("keyssi");
			const scope = "/mq";
			const credentials = options.credentials || [];

			keyssiApi.createTemplateSeedSSI(domain, (err, subject) => {
				if (err) {
					return callback(err);
				}
				options.subject = subject;
				const cfg = getDomainSpecificConfig(domain);
				//setting the JWT token valid period based on the config
				options.valability = cfg.mq_nonce_expiration_time;

				return crypto.createJWT(seeder, scope, credentials, options, (err, token)=>{
					if(err){
						return callback(err);
					}
					crypto.parseJWTSegments(token, (err, segments)=>{
						if(err){
							return callback(err);
						}
						return callback(undefined, {token, expires: segments.body.exp*1000});
					});
				});
			});
		}

		if (!seeder) {
			init().then(createToken);
			return;
		}

		createToken();
	}

	this.validateToken = function (token, callback) {
		function validateToken() {
			const opendsu = require("opendsu");
			const crypto = opendsu.loadApi("crypto");
			return crypto.verifyJWT(token, null, callback);
		}

		if (!seeder) {
			init().then(validateToken);
			return;
		}

		validateToken();
	}

	this.isOwner = function (token, resource, callback) {
		this.validateToken(token, (err, valid) => {
			if (err || !valid) {
				return callback(err || new Error("Invalid token"));
			}

			const opendsu = require("opendsu");
			const crypto = opendsu.loadApi("crypto");
			return crypto.parseJWTSegments(token, (err, segments) => {
				if (err) {
					return callback(err);
				}
				const valid = segments && segments.body && Array.isArray(segments.body.credentials) && segments.body.credentials.indexOf(resource) !== -1;
				return callback(undefined, valid);
			});
		});
	}
}

module.exports = JWTIssuer;
},{"./../../../config":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/apihub/config/index.js","fs":false,"opendsu":"opendsu","path":false}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/apihub/components/mqHub/index.js":[function(require,module,exports){
const URL_PREFIX = "/mq";
//known implementations for the MQ adapters
const adapterImpls = {
	local: require("./adapters/localMQAdapter.js"),
	solace: require("./adapters/solaceMQAdapter.js"),
	loki: require("./adapters/lokiMQAdapter.js"),
	lightdb: require("./adapters/lighDBEnclaveAdapter.js")
};

const defaultSettings = {
	// normally there are gateways timeouts of 30seconds
	mq_client_timeout: 60 * 1000,//sec
	// not sure about the response.setTimeout(msecs[, callback]) available on nodejs docs

	mq_throttling: 100, //100 per second
	mq_allow_unregistered_did: false
}

async function MQHub(server, signalAsyncLoading, doneLoading) {

	server.registerAccessControlAllowHeaders(["token", "authorization", "x-mq-authorization"]);

	const logger = $$.getLogger("MQHub", "apihub/mqHub");

	signalAsyncLoading();

	const config = require("./../../config/index");

	const JWTIssuer = require("./auth/JWTIssuer");
	const issuer = new JWTIssuer(server.rootFolder);

	let domains = []; //config.getConfiguredDomains();

	function getTokenHandler(request, response) {
		const domain = request.params.domain;
		issuer.createToken(domain, {credentials: request.params.hashDID}, (err, tokenObj) => {
			if (err) {
				logger.info(0x03, "Not able to create a new token.", err);
				response.statusCode = 500;
				return response.end();
			}

			const mqConfig = config.getConfig("componentsConfig", "mq");
			if (mqConfig && mqConfig.connectionTimeout) {
				response.writeHead(200, {
					"connection-timeout": mqConfig.connectionTimeout
				});
			} else {
				response.statusCode = 200;
			}

			response.write(JSON.stringify(tokenObj));
			response.end();
		});
	}

	async function allowUnregisteredDID(domainName){
		const domainConfig = await config.getSafeDomainConfig(domainName);
		let allowUnregisteredDID = defaultSettings.mq_allow_unregistered_did;
		if(domainConfig && typeof domainConfig.mq_allow_unregistered_did !== "undefined"){
			allowUnregisteredDID = !!domainConfig.mq_allow_unregistered_did;
		}
		return allowUnregisteredDID;
	}

	async function putMessageHandler(request, response, next) {
		const domainName = request.params.domain;
		if (domains.indexOf(domainName) === -1) {
			logger.info(0x03, `Caught an request to the MQs for domain ${domainName}. Looks like the domain doesn't have mq component enabled.`);
			response.statusCode = 405;
			response.end();
			return;
		}

		let token = request.headers['x-mq-authorization'];

		if(! await allowUnregisteredDID(domainName) && !token){
			logger.info(0x03, `No token was available on the request and the domain ${domainName} configuration prohibits unregisteredDIDs to use the MQ api.`);
			response.statusCode = 403;
			response.end();
			return;
		}

		issuer.validateToken(token, (err, valid) => {
			let errorMsg = "Not able to validate token: ";
			if (!valid) {
				errorMsg = "Token not valid: ";
			}
			if (err || !valid) {
				logger.info(0x03, `${errorMsg} < ${token} >`, err ? err : "");
				response.statusCode = 403;
				response.end();
				return;
			}

			//all good continue to the domain specific mq handler
			return next();
		});
	}

	async function getMessageHandler(request, response, next) {
		const domainName = request.params.domain;
		if (domains.indexOf(domainName) === -1) {
			logger.info(0x03, `Caught an request to the MQs for domain ${domainName}. Looks like the domain doesn't have mq component enabled.`);
			response.statusCode = 405;
			response.end();
			return;
		}

		let token = request.headers['x-mq-authorization'];

		if(! await allowUnregisteredDID(domainName) && !token){
			logger.info(0x03, `No token was available on the request and the domain ${domainName} configuration prohibits unregisteredDIDs to use the MQ api.`);
			response.statusCode = 403;
			response.end();
			return;
		}

		issuer.isOwner(token, request.params.hashDID, (err, isOwner) => {
			let errorMsg = "Not able to validate authorization token: ";
			if (!isOwner) {
				errorMsg = "Ownership not confirmed based on token: ";
			}
			if (err || !isOwner) {
				logger.info(0x03, `${errorMsg} < ${token} >`, err ? err : "");
				response.statusCode = 403;
				response.end();
				return;
			}

			//all good continue to the domain specific mq handler
			return next();
		});
	}

	function deleteMessageHandler(request, response, next) {
		getMessageHandler(request, response, next);
	}

	function takeMessageHandler(request, response, next) {
		getMessageHandler(request, response, next);
	}

	server.get(`${URL_PREFIX}/:domain/:hashDID/token`, getTokenHandler); //> JWT Token

	server.put(`${URL_PREFIX}/:domain/put/:hashDID`, putMessageHandler); //< message

	server.get(`${URL_PREFIX}/:domain/get/:hashDID/:signature_of_did`, getMessageHandler); //  > {message}
	server.delete(`${URL_PREFIX}/:domain/delete/:hashDID/:messageID/:signature_of_did`, deleteMessageHandler);

	server.get(`${URL_PREFIX}/:domain/take/:hashDID/:signature_of_did`, takeMessageHandler); //  > message

	function testIfMQEnabled(domain, domainToBeUsedByAdapter){
		let domainConfig = config.getDomainConfig(domain);

		if (domainConfig && domainConfig.enable && domainConfig.enable.indexOf("mq") !== -1) {
			const adapterTypeName = domainConfig["mq_type"] || "lightdb";
			const adapter = adapterImpls[adapterTypeName];
			if (!adapter) {
				logger.info(0x03, `Not able to recognize the mq_type < ${adapterTypeName} > from the domain < ${domain} > config.`);
				return;
			}

			try {
				logger.debug(`Preparing to register mq endpoints for domain < ${domain} > ... `);
				adapter(server, URL_PREFIX, domainToBeUsedByAdapter || domain, domainConfig);
			} catch (err) {
				logger.info(0x03, `Caught an error during initialization process of the mq for domain < ${domain} >`, err);
				return;
			}

			return true;
		}
	}

	async function setupDomainSpecificHandlers() {
		let confDomains = typeof config.getConfiguredDomains !== "undefined" ? config.getConfiguredDomains() : ["default"];
		try{
			let adminService = require("./../../components/admin").getAdminService();
			let getDomains = $$.promisify(adminService.getDomains);
			let virtualDomains = await getDomains();
			for(let i=0; i<virtualDomains.length; i++){
				let domainInfo = virtualDomains[i];
				if(domainInfo && domainInfo.active && domainInfo.cloneFromDomain){
					if(testIfMQEnabled(domainInfo.cloneFromDomain, domainInfo.pk)){
						logger.debug(`Successfully register mq endpoints for virtual domain < ${domainInfo.pk} >.`);
						domains.push(domainInfo.pk);
					}
				}
			}
		} catch (err) {
			if(err.rootCause && err.rootCause !== "disabled-by-config"){
				logger.warning('Failed to enable mq handler for virtual domains', err);
			}
		}

		for (let i = 0; i < confDomains.length; i++) {
			let domain = confDomains[i];
			if(testIfMQEnabled(domain)){
				logger.debug(`Successfully register mq endpoints for domain < ${domain} >.`);
				domains.push(domain);
			}
		}
	}

	await setupDomainSpecificHandlers();
	doneLoading();
}

module.exports = {
	MQHub
};

},{"./../../components/admin":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/apihub/components/admin/index.js","./../../config/index":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/apihub/config/index.js","./adapters/lighDBEnclaveAdapter.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/apihub/components/mqHub/adapters/lighDBEnclaveAdapter.js","./adapters/localMQAdapter.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/apihub/components/mqHub/adapters/localMQAdapter.js","./adapters/lokiMQAdapter.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/apihub/components/mqHub/adapters/lokiMQAdapter.js","./adapters/solaceMQAdapter.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/apihub/components/mqHub/adapters/solaceMQAdapter.js","./auth/JWTIssuer":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/apihub/components/mqHub/auth/JWTIssuer.js"}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/apihub/components/requestForwarder/index.js":[function(require,module,exports){
const registeredUrl = "/forwardRequestForAuthenticatedClient";
const logger = $$.getLogger("requestForwarder", "apihub/requestForwarder");
module.exports = function(server){
    server.post(registeredUrl, require("./../../utils/middlewares/index").requestBodyJSONMiddleware);

    server.post(registeredUrl, function(req, res, next){
        let url = req.body.url;

        if(!url){
            res.statusCode = 400;
            return res.end();
        }

        let body = req.body.body || "";
        let options = req.body.options || {method: "POST"};

        let http = require("http");
        if(url.startsWith("https://")){
            http = require("https");
        }

        logger.debug(`Forwarding request ${options.method} to url ${url}`);
        try {

          let request = http.request(url, options, (response) => {
            res.statusCode = response.statusCode;
            if (res.statusCode > 300) {
              res.end();
            }
            response.on("data", res.write);
            response.on('end', res.end);
          });

          request.on("error", (err) => {
            res.statusCode = 500;
            res.end();
          });

          request.write(body);
          request.end();
        } catch (e) {
          logger.error("Error on request: ", e);
          res.statusCode = 500;
          res.end();
        }
    });
}

},{"./../../utils/middlewares/index":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/apihub/utils/middlewares/index.js","http":false,"https":false}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/apihub/components/secrets/SecretsService.js":[function(require,module,exports){
const fs = require("fs");
const path = require("path");
const config = require("../../config");
const {CONTAINERS} = require("./constants");


function SecretsService(serverRootFolder) {
    serverRootFolder = serverRootFolder || config.getConfig("storage");
    const DEFAULT_CONTAINER_NAME = "default";
    const API_KEY_CONTAINER_NAME = "apiKeys";
    const getStorageFolderPath = () => {
        return path.join(serverRootFolder, config.getConfig("externalStorage"), "secrets");
    }

    const lockPath = path.join(getStorageFolderPath(), "secret.lock");
    const lock = require("../../utils/ExpiringFileLock").getLock(lockPath, 10000);
    console.log("Secrets Service initialized");
    const logger = $$.getLogger("secrets", "apihub/secrets");
    const openDSU = require("opendsu");
    const crypto = openDSU.loadAPI("crypto");
    const encryptionKeys = process.env.SSO_SECRETS_ENCRYPTION_KEY ? process.env.SSO_SECRETS_ENCRYPTION_KEY.split(",") : undefined;
    let readonlyMode;

    let writeEncryptionKey = encryptionKeys ? encryptionKeys[0].trim() : undefined;
    if (typeof writeEncryptionKey === "undefined") {
        readonlyMode = true;
        console.warn("No encryption key found. Readonly mode activated");
        return;
    }
    writeEncryptionKey = $$.Buffer.from(writeEncryptionKey, "base64");

    let previousEncryptionKey = encryptionKeys.length === 2 ? encryptionKeys[1].trim() : undefined;
    if (typeof previousEncryptionKey !== "undefined") {
        previousEncryptionKey = $$.Buffer.from(previousEncryptionKey, "base64");
    }
    const containers = {};

    const apiKeyExists = (apiKeysContainer, apiKey) => {
        const apiKeys = Object.values(apiKeysContainer);
        if (apiKeys.length === 0) {
            return false;
        }
        let index = apiKeys.findIndex(el => el === apiKey);
        return index !== -1;
    }

    const loadContainerAsync = async (containerName) => {
        try {
            containers[containerName] = await getDecryptedSecretsAsync(containerName);
            console.info("Secrets container", containerName, "loaded");
        } catch (e) {
            containers[containerName] = {};
            console.info("Initializing secrets container", containerName);
        }

        if (containerName === API_KEY_CONTAINER_NAME) {
            const apiKey = require("opendsu").loadAPI("crypto").sha256JOSE(process.env.SSO_SECRETS_ENCRYPTION_KEY, "base64");
            if (!apiKeyExists(containers[containerName], apiKey)) {
                console.log("API Key not found in container", containerName);
                containers[containerName][apiKey] = apiKey;
                await writeSecretsAsync(containerName);
            }
        }
    }

    this.loadAsync = async () => {
        ensureFolderExists(getStorageFolderPath());
        let secretsContainersNames = fs.readdirSync(getStorageFolderPath());
        if (secretsContainersNames.length) {
            secretsContainersNames = secretsContainersNames.map((containerName) => {
                const extIndex = containerName.lastIndexOf(".");
                return path.basename(containerName).substring(0, extIndex);
            })

            for (let containerName of secretsContainersNames) {
                await loadContainerAsync(containerName);
            }
        } else {
            logger.info("No secrets containers found");
        }
    }

    const createError = (code, message) => {
        const err = Error(message);
        err.code = code

        return err;
    }

    const encryptSecret = (secret) => {
        return crypto.encrypt(secret, writeEncryptionKey);
    }

    const writeSecrets = (secretsContainerName, callback) => {
        if (readonlyMode) {
            return callback(createError(555, `Secrets Service is in readonly mode`));
        }
        let secrets = containers[secretsContainerName];
        secrets = JSON.stringify(secrets);
        const encryptedSecrets = encryptSecret(secrets);
        fs.writeFile(getSecretFilePath(secretsContainerName), encryptedSecrets, callback);
    }

    const writeSecretsAsync = async (secretsContainerName) => {
        return await $$.promisify(writeSecrets)(secretsContainerName);
    }
    const ensureFolderExists = (folderPath) => {
        try {
            fs.accessSync(folderPath);
        } catch (e) {
            fs.mkdirSync(folderPath, {recursive: true});
        }
    }


    const getSecretFilePath = (secretsContainerName) => {
        const folderPath = getStorageFolderPath();
        return path.join(folderPath, `${secretsContainerName}.secret`);
    }

    const decryptAndParseSecrets = (secretsContainerName, encryptedSecret, encryptionKey) => {
        let decryptedSecrets;
        try {
            decryptedSecrets = crypto.decrypt(encryptedSecret, encryptionKey);
            decryptedSecrets = JSON.parse(decryptedSecrets.toString());
            containers[secretsContainerName] = decryptedSecrets;
            return decryptedSecrets;
        } catch (e) {
            logger.error(`Failed to parse secrets`);
            throw createError(555, `Failed to parse secrets`);
        }
    }
    const decryptSecret = async (secretsContainerName, encryptedSecret) => {
        let decryptedSecret;
        try {
            decryptedSecret = decryptAndParseSecrets(secretsContainerName, encryptedSecret, writeEncryptionKey);
            readonlyMode = false;
            return decryptedSecret;
        } catch (e) {
            try {
                decryptedSecret = decryptAndParseSecrets(secretsContainerName, encryptedSecret, previousEncryptionKey);
                logger.info(0x501, "Secrets Encryption Key rotation detected");
                await writeSecretsAsync(secretsContainerName);
                logger.info(0x501, `Re-encrypting Recovery Passphrases on disk completed`);
                readonlyMode = false;
                return decryptedSecret;
            } catch (e) {
                logger.error(`Failed to decrypt secrets`);
                readonlyMode = true;
                console.log("Readonly mode activated")
                throw createError(555, `Failed to decrypt secrets`);
            }
        }
    };

    const getDecryptedSecrets = (secretsContainerName, callback) => {
        const filePath = getSecretFilePath(secretsContainerName);
        fs.readFile(filePath, async (err, secrets) => {
            if (err || !secrets) {
                logger.log(`Failed to read file ${filePath}`);
                return callback(createError(404, `Failed to read file ${filePath}`));
            }

            let decryptedSecrets;
            try {
                decryptedSecrets = await decryptSecret(secretsContainerName, secrets);
            } catch (e) {
                return callback(e);
            }

            callback(undefined, decryptedSecrets);
        });
    }

    const getDecryptedSecretsAsync = async (secretsContainerName) => {
        return await $$.promisify(getDecryptedSecrets, this)(secretsContainerName);
    }

    this.putSecretAsync = async (secretsContainerName, secretName, secret, isAdmin) => {
        await lock.lock();
        let res;
        try {
            await loadContainerAsync(secretsContainerName);
            if (!containers[secretsContainerName]) {
                containers[secretsContainerName] = {};
                console.info("Initializing secrets container", secretsContainerName)
            }
            if (typeof isAdmin !== "undefined") {
                containers[secretsContainerName][secretName] = {};
                containers[secretsContainerName][secretName].secret = secret;
                containers[secretsContainerName][secretName].isAdmin = isAdmin;
            } else {
                containers[secretsContainerName][secretName] = secret;
            }
            res = await writeSecretsAsync(secretsContainerName);
        } catch (e) {
            await lock.unlock();
            throw e;
        }
        await lock.unlock();
        return res;
    }

    this.putSecretInDefaultContainerAsync = async (secretName, secret) => {
        return await this.putSecretAsync(DEFAULT_CONTAINER_NAME, secretName, secret);
    }

    this.getSecretSync = (secretsContainerName, secretName) => {
        if (readonlyMode) {
            throw createError(555, `Secrets Service is in readonly mode`);
        }
        if (!containers[secretsContainerName]) {
            containers[secretsContainerName] = {};
            console.info("Initializing secrets container", secretsContainerName);
        }
        const secret = containers[secretsContainerName][secretName];
        if (!secret) {
            throw createError(404, `Secret ${secretName} not found`);
        }

        return secret;
    }

    this.readSecretSync = this.getSecretSync;

    this.getSecretFromDefaultContainerSync = (secretName) => {
        return this.getSecretSync(DEFAULT_CONTAINER_NAME, secretName);
    }

    this.readSecretFromDefaultContainerSync = this.getSecretFromDefaultContainerSync;

    this.generateAPIKeyAsync = async (keyId, isAdmin) => {
        const apiKey = crypto.generateRandom(32).toString("base64");
        await this.putSecretAsync(API_KEY_CONTAINER_NAME, keyId, apiKey, isAdmin);
        return apiKey;
    }

    this.deleteAPIKeyAsync = async (keyId) => {
        await this.deleteSecretAsync(API_KEY_CONTAINER_NAME, keyId);
    }

    this.containerIsEmpty = (secretsContainerName) => {
        return Object.keys(containers[secretsContainerName] || {}).length === 0;
    }

    this.apiKeysContainerIsEmpty = () => {
        return this.containerIsEmpty(API_KEY_CONTAINER_NAME);
    }

    this.validateAPIKey = async (apiKey) => {
        console.debug("Validating internal call");
        if(apiKey === process.env.SSO_SECRETS_ENCRYPTION_KEY){
            return true;
        }
        await loadContainerAsync(CONTAINERS.API_KEY_CONTAINER_NAME);
        const container = containers[API_KEY_CONTAINER_NAME];
        if (!container) {
            return false;
        }

        return apiKeyExists(container, apiKey);
    }

    this.isAdminAPIKey = (apiKey) => {
        const container = containers[API_KEY_CONTAINER_NAME];
        if (!container) {
            return false;
        }
        const apiKeyObjs = Object.values(container);
        if (apiKeyObjs.length === 0) {
            return false;
        }
        let index = apiKeyObjs.findIndex((obj) => {
            return obj.secret === apiKey && obj.isAdmin;
        });
        return index !== -1;
    }

    this.deleteSecretAsync = async (secretsContainerName, secretName) => {
        await lock.lock();
        try {
            await loadContainerAsync(secretsContainerName);
            if (!containers[secretsContainerName]) {
                containers[secretsContainerName] = {};
                console.info("Initializing secrets container", secretsContainerName)
            }
            if (!containers[secretsContainerName][secretName]) {
                throw createError(404, `Secret ${secretName} not found`);
            }
            delete containers[secretsContainerName][secretName];
            await writeSecretsAsync(secretsContainerName);
        } catch (e) {
            await lock.unlock();
            throw e;
        }
        await lock.unlock();
    }
}

let secretsServiceInstance;
const getSecretsServiceInstanceAsync = async (serverRootFolder) => {
    if (!secretsServiceInstance) {
        secretsServiceInstance = new SecretsService(serverRootFolder);
        await secretsServiceInstance.loadAsync();
    }

    secretsServiceInstance.constants = require("./constants");
    return secretsServiceInstance;
}

const resetInstance = async (serverRootFolder) => {
    secretsServiceInstance = new SecretsService(serverRootFolder);
    await secretsServiceInstance.loadAsync();
    return secretsServiceInstance;
}

module.exports = {
    getSecretsServiceInstanceAsync,
    resetInstance
};

},{"../../config":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/apihub/config/index.js","../../utils/ExpiringFileLock":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/apihub/utils/ExpiringFileLock.js","./constants":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/apihub/components/secrets/constants.js","fs":false,"opendsu":"opendsu","path":false}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/apihub/components/secrets/constants.js":[function(require,module,exports){
module.exports = {
    CONTAINERS: {
        API_KEY_CONTAINER_NAME: "apiKeys",
        DEFAULT_CONTAINER_NAME: "default",
        ADMIN_API_KEY_CONTAINER_NAME: "adminApiKeys",
        USER_API_KEY_CONTAINER_NAME: "userApiKeys",
        DSU_FABRIC: "DSU_Fabric",
        DEMIURGE: "Demiurge"
    },
    SYSADMIN_SECRET: "sysadminSecret"
}
},{}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/apihub/components/secrets/index.js":[function(require,module,exports){
function secrets(server) {
    const openDSU = require("opendsu");
    const crypto = openDSU.loadAPI("crypto");
    const constants = require("./constants");
    const CONTAINERS = constants.CONTAINERS;
    const whitelistedContainers = [CONTAINERS.DSU_FABRIC, CONTAINERS.DEMIURGE];
    const whitelistedSecrets = ["credential"];
    const logger = $$.getLogger("secrets", "apihub/secrets");
    const httpUtils = require("../../libs/http-wrapper/src/httpUtils");
    const SecretsService = require("./SecretsService");
    let secretsService;
    setTimeout(async () => {
        secretsService = await SecretsService.getSecretsServiceInstanceAsync(server.rootFolder);
    })

    const containerIsWhitelisted = (containerName) => {
        return whitelistedContainers.includes(containerName);
    }

    const secretIsWhitelisted = (secretName) => {
        return whitelistedSecrets.includes(secretName);
    }

    const getSSOSecret = (request, response) => {
        let userId = request.headers["user-id"];
        let appName = request.params.appName;
        if (!containerIsWhitelisted(appName) && !secretIsWhitelisted(userId)) {
            response.statusCode = 403;
            response.end("Forbidden");
            return;
        }
        let secret;
        try {
            secret = secretsService.getSecretSync(appName, userId);
        } catch (e) {
            response.statusCode = e.code;
            response.end(e.message);
            return;
        }

        response.statusCode = 200;
        response.end(secret);
    }

    const putSSOSecret = async (request, response) => {
        let userId = request.headers["user-id"];
        let appName = request.params.appName;
        let secret;
        try {
            secret = JSON.parse(request.body).secret;
        } catch (e) {
            logger.error("Failed to parse body", request.body);
            response.statusCode = 500;
            response.end(e);
            return;
        }

        try {
            await secretsService.putSecretAsync(appName, userId, secret);
        } catch (e) {
            response.statusCode = e.code;
            response.end(e.message);
            return;
        }

        response.statusCode = 200;
        response.end();
    };

    const deleteSSOSecret = async (request, response) => {
        let appName = request.params.appName;
        let userId = request.headers["user-id"];

        try {
            await secretsService.deleteSecretAsync(appName, userId);
        } catch (e) {
            response.statusCode = e.code;
            response.end(e.message);
            return;
        }

        response.statusCode = 200;
        response.end();
    }

    const logEncryptionTest = () => {
        const key = "presetEncryptionKeyForInitialLog";
        const text = "TheQuickBrownFoxJumpedOverTheLazyDog";

        logger.info(0x500, "Recovery Passphrase Encryption Check. Plain text: " + text);
        logger.info(0x500, "Preset encryption key: " + key);

        const filePath = require("path").join(server.rootFolder, "initialEncryptionTest");
        const encryptedText = require("opendsu").loadAPI("crypto").encrypt(text, key).toString("hex");

        logger.info(0x500, "Writing encrypted file on disk: " + filePath);
        logger.info(0x500, "Cipher text(file contents): " + encryptedText);

        require("fs").writeFile(filePath, encryptedText, (err) => {
            if (err) {
                logger.info(0x500, "Failed to write file: " + filePath + " Error: " + err);
            }
        });
    }

    async function putDIDSecret(req, res) {
        let {did, name} = req.params;
        let secret = req.body;
        try {
            await secretsService.putSecretAsync(name, did, secret);
        } catch (e) {
            res.statusCode = e.code;
            res.end(e.message);
            return;
        }
        res.statusCode = 200;
        res.end();
    }

    function getDIDSecret(req, res) {
        let {did, name} = req.params;
        if (!containerIsWhitelisted(did) && !secretIsWhitelisted(name)) {
            res.statusCode = 403;
            res.end("Forbidden");
            return;
        }
        let secret;
        try {
            secret = secretsService.getSecretSync(name, did);
            res.statusCode = 200;
        } catch (err) {
            res.statusCode = err.code;
            res.end(err.message);
            return;
        }
        res.end(secret);
    }

    async function deleteDIDSecret(req, res) {
        let {did, name} = req.params;
        try {
            await secretsService.deleteSecretAsync(name, did)
            res.statusCode = 200;
        } catch (err) {
            res.statusCode = err.code;
            res.end(err.message);
            return;
        }

        res.end();
    }

    logEncryptionTest();

    const senderIsAdmin = (req) => {
        const authorizationHeader = req.headers.authorization;
        if (!authorizationHeader) {
            return !!secretsService.apiKeysContainerIsEmpty();
        }

        return secretsService.isAdminAPIKey(authorizationHeader);
    }

    server.post("/apiKey/*", httpUtils.bodyParser);
    server.post("/apiKey/:keyId/:isAdmin", async (req, res) => {
        if (!senderIsAdmin(req)) {
            res.statusCode = 403;
            res.end("Forbidden");
            return;
        }
        let {keyId, isAdmin} = req.params;
        const apiKey = await secretsService.generateAPIKeyAsync(keyId, isAdmin === "true")
        res.statusCode = 200;
        res.end(apiKey);
    });

    server.delete("/apiKey/:keyId", async (req, res) => {
        if (!senderIsAdmin(req)) {
            res.statusCode = 403;
            res.end("Forbidden");
            return;
        }
        let {keyId} = req.params;
        await secretsService.deleteAPIKeyAsync(keyId);
        res.statusCode = 200;
        res.end();
    })

    server.put('/becomeSysAdmin', httpUtils.bodyParser);
    server.put('/becomeSysAdmin', async (req, res) => {
        try {
            let body = req.body;
            try {
                body = JSON.parse(body);
            } catch (e) {
                res.statusCode = 400;
                res.end("Body should be a valid JSON object.");
                return;
            }

            if (!body.secret || !body.apiKey) {
                res.statusCode = 400;
                res.end("Body should contain secret and apiKey fields.");
                return;
            }

            const adminContainerIsEmpty = secretsService.containerIsEmpty(CONTAINERS.ADMIN_API_KEY_CONTAINER_NAME);
            if (adminContainerIsEmpty) {
                await secretsService.putSecretAsync(CONTAINERS.ADMIN_API_KEY_CONTAINER_NAME, req.headers["user-id"], req.body);
                await secretsService.putSecretAsync(CONTAINERS.API_KEY_CONTAINER_NAME, constants.SYSADMIN_SECRET, body.secret);
                res.statusCode = 200;
                res.end('System administrator added successfully.');
                return;
            }

            const sysadminSecret = secretsService.getSecretSync(CONTAINERS.API_KEY_CONTAINER_NAME, constants.SYSADMIN_SECRET);
            if (sysadminSecret === body.secret) {
                await secretsService.putSecretAsync(CONTAINERS.ADMIN_API_KEY_CONTAINER_NAME, req.headers["user-id"], body.apiKey);
                res.statusCode = 200;
                res.end('System administrator added successfully.');
                return;
            }

            res.statusCode = 403;
            res.end("Forbidden");
        } catch (error) {
            res.statusCode = 500;
            res.end(error.message);
        }
    });

    server.put('/makeSysAdmin/:userId', httpUtils.bodyParser);
    server.put('/makeSysAdmin/:userId', async (req, res) => {
        const userId = decodeURIComponent(req.params.userId);
        try {
            // Create a new Admin APIKey and associate it with another user
            let sysadminAPIKey;
            try {
                sysadminAPIKey = secretsService.getSecretSync(constants.CONTAINERS.ADMIN_API_KEY_CONTAINER_NAME, req.headers["user-id"]);
            } catch (e) {
                console.log(e)
                // ignored and handled below
            }

            if (!sysadminAPIKey) {
                res.statusCode = 403;
                res.end("Forbidden");
                return;
            }

            await secretsService.putSecretAsync(constants.CONTAINERS.ADMIN_API_KEY_CONTAINER_NAME, userId, req.body);
            res.statusCode = 200;
            res.end('System administrator added successfully.');
        } catch (error) {
            res.statusCode = 500;
            res.end(error.message);
        }
    });


    server.delete('/deleteAdmin/:userId', async (req, res) => {
        const userId = decodeURIComponent(req.params.userId);
        try {
            let sysadminAPIKey;
            try {
                sysadminAPIKey = secretsService.getSecretSync(constants.CONTAINERS.ADMIN_API_KEY_CONTAINER_NAME, req.headers["user-id"]);
            } catch (e) {
                // ignored and handled below
            }

            if (!sysadminAPIKey) {
                res.statusCode = 403;
                res.end("Forbidden");
                return;
            }

            await secretsService.deleteSecretAsync(constants.CONTAINERS.ADMIN_API_KEY_CONTAINER_NAME, userId);
            res.statusCode = 200;
            res.end('System administrator added successfully.');
        } catch (error) {
            console.log(error);
            res.statusCode = 500;
            res.end(error.message);
        }
    });


    server.put('/associateAPIKey/*', httpUtils.bodyParser);
    server.put('/associateAPIKey/:appName/:name/:userId', async (req, res) => {
        const appName = decodeURIComponent(req.params.appName);
        const name = decodeURIComponent(req.params.name);
        const userId = decodeURIComponent(req.params.userId);
        try {
            const secretName = crypto.sha256JOSE(appName + userId, "base64url");
            let secret;
            try {
                secret = secretsService.getSecretSync(CONTAINERS.USER_API_KEY_CONTAINER_NAME, secretName);
                secret = JSON.parse(secret);
            } catch (e) {
                // ignored and handled below
            }
            if (!secret) {
                secret = {}
                secret[name] = req.body;
            }
            await secretsService.putSecretAsync(CONTAINERS.USER_API_KEY_CONTAINER_NAME, secretName, JSON.stringify(secret));
            res.statusCode = 200;
            res.end('API key associated successfully.');
        } catch (error) {
            res.statusCode = 500;
            res.end(error.message);
        }
    });


    server.delete('/deleteAPIKey/:appName/:name/:userId', async (req, res) => {
        const appName = decodeURIComponent(req.params.appName);
        const name = decodeURIComponent(req.params.name);
        const userId = decodeURIComponent(req.params.userId);
        try {
            const secretName = crypto.sha256JOSE(appName + userId, "base64url");
            let secret;
            try {
                secret = secretsService.getSecretSync(CONTAINERS.USER_API_KEY_CONTAINER_NAME, secretName);
                secret = JSON.parse(secret);
            } catch (e) {
                // ignored and handled below
            }
            if (!secret) {
                res.statusCode = 404;
                res.end('API key not found.');
                return;
            }
            delete secret[name];
            if (Object.keys(secret).length === 0) {
                await secretsService.deleteSecretAsync(CONTAINERS.USER_API_KEY_CONTAINER_NAME, secretName);
                res.statusCode = 200;
                res.end('API key deleted successfully.');
                return;
            }

            await secretsService.putSecretAsync(CONTAINERS.USER_API_KEY_CONTAINER_NAME, secretName, JSON.stringify(secret));
            res.statusCode = 200;
            res.end('API key deleted successfully.');
        } catch (error) {
            res.statusCode = 500;
            res.end(error.message);
        }
    });

    server.get('/getAPIKey/:appName/:name/:userId', async (req, res) => {
        const appName = decodeURIComponent(req.params.appName);
        const name = decodeURIComponent(req.params.name);
        const userId = decodeURIComponent(req.params.userId);
        try {
            const secretName = crypto.sha256JOSE(appName + userId, "base64url");
            let secret;
            try {
                secret = secretsService.getSecretSync(CONTAINERS.USER_API_KEY_CONTAINER_NAME, secretName);
                secret = JSON.parse(secret);
            } catch (e) {
                res.statusCode = 404;
                res.end('API key not found.');
                return;
            }
            if (!secret[name]) {
                res.statusCode = 404;
                res.end('API key not found.');
                return;
            }

            res.statusCode = 200;
            res.end(secret[name]);
        } catch (error) {
            res.statusCode = 500;
            res.end(error.message);
        }
    });

    server.put('/putSSOSecret/*', httpUtils.bodyParser);
    server.get("/getSSOSecret/:appName", getSSOSecret);
    server.put('/putSSOSecret/:appName', putSSOSecret);
    server.delete("/deactivateSSOSecret/:appName/:did", deleteSSOSecret);
    server.delete("/removeSSOSecret/:appName", deleteSSOSecret);

    server.put('/putDIDSecret/*', httpUtils.bodyParser);
    server.put('/putDIDSecret/:did/:name', putDIDSecret);
    server.get('/getDIDSecret/:did/:name', getDIDSecret);
    server.delete('/removeDIDSecret/:did/:name', deleteDIDSecret);
}

module.exports = secrets;

},{"../../libs/http-wrapper/src/httpUtils":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/apihub/libs/http-wrapper/src/httpUtils.js","./SecretsService":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/apihub/components/secrets/SecretsService.js","./constants":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/apihub/components/secrets/constants.js","fs":false,"opendsu":"opendsu","path":false}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/apihub/components/staticServer/index.js":[function(require,module,exports){
function StaticServer(server) {
    const fs = require("fs");
    const path = require('swarmutils').path;
    const utils = require("../../utils");
    const config = require("../../config");
    let componentsConfig = config.getConfig("componentsConfig");
    const logger = $$.getLogger("StaticServer", "apihub/staticServer");
    const excludedFiles = ["apihub.json"];
    let excludedFilesRegex;
    if (componentsConfig && componentsConfig.staticServer && componentsConfig.staticServer.excludedFiles) {
        excludedFilesRegex = componentsConfig.staticServer.excludedFiles.map(str => new RegExp(str));
    }
    function sendFiles(req, res, next) {
        const prefix = "/directory-summary/";
        requestValidation(req, "GET", prefix, function (notOurResponsibility, targetPath) {
            if (notOurResponsibility) {
                return next();
            }
            targetPath = targetPath.replace(prefix, "");
            serverTarget(targetPath);
        });

        function serverTarget(targetPath) {
            logger.debug("Serving summary for dir:", targetPath);
            fs.stat(targetPath, function (err, stats) {
                if (err) {
                    logger.info(0x04, `Path <${targetPath}> was not found`)
                    res.statusCode = 404;
                    res.end();
                    return;
                }
                if (!stats.isDirectory()) {
                    logger.info(0x04, `<${targetPath}> is not a directory`)
                    res.statusCode = 403;
                    res.end();
                    return;
                }

                function send() {
                    res.statusCode = 200;
                    res.setHeader('Content-Type', "application/json");
                    //let's clean some empty objects
                    for (let prop in summary) {
                        if (Object.keys(summary[prop]).length === 0) {
                            delete summary[prop];
                        }
                    }

                    res.write(JSON.stringify(summary));
                    res.end();
                }

                let summary = {};
                let directories = {};

                function extractContent(currentPath) {
                    directories[currentPath] = -1;
                    let summaryId = currentPath.replace(targetPath, "");
                    summaryId = summaryId.split(path.sep).join("/");
                    if (summaryId === "") {
                        summaryId = "/";
                    }
                    //summaryId = path.basename(summaryId);
                    summary[summaryId] = {};

                    fs.readdir(currentPath, function (err, files) {
                        if (err) {
                            return markAsFinish(currentPath);
                        }
                        directories[currentPath] = files.length;
                        //directory empty test
                        if (files.length === 0) {
                            return markAsFinish(currentPath);
                        } else {
                            for (let i = 0; i < files.length; i++) {
                                let file = files[i];
                                const fileName = path.join(currentPath, file);
                                if (fs.statSync(fileName).isDirectory()) {
                                    extractContent(fileName);
                                } else {
                                    let fileContent = fs.readFileSync(fileName);
                                    let fileExtension = fileName.substring(fileName.lastIndexOf(".") + 1);
                                    let mimeType = utils.getMimeTypeFromExtension(fileExtension);
                                    if (mimeType.binary) {
                                        summary[summaryId][file] = Array.from(fileContent);
                                    } else {
                                        summary[summaryId][file] = fileContent.toString();
                                    }

                                }
                                directories[currentPath]--;
                            }
                            return markAsFinish(currentPath);
                        }
                    });
                }

                function markAsFinish(targetPath) {
                    if (directories [targetPath] > 0) {
                        return;
                    }
                    delete directories [targetPath];
                    const dirsLeftToProcess = Object.keys(directories);
                    //if there are no other directories left to process
                    if (dirsLeftToProcess.length === 0) {
                        send();
                    }
                }

                extractContent(targetPath);
            })
        }

    }

    function tryToCreateAtRuntimeFromTemplates(req, callback){

        let adminService;
        try{
            adminService = require("./../admin").getAdminService();
        }catch(err){
            //logger.error("Caught an error durring admin service initialization", err);
            return callback(err);
        }

        adminService.checkForTemplate(req.url, (err, template)=>{
            if(err){
                //logger.error("Not able to find template for", req.url);
                //console.trace(err);
                return callback(err);
            }
            if(template){
                let fileContent = template.content;
                const urlObject = new URL(req.url, `http://${req.headers.host}`);
                let hostname = urlObject.hostname;
                return adminService.getDomainSpecificVariables(hostname, (err, variables)=>{
                    if(err || !variables){
                        return callback(err);
                    }
                    let domainVariables = Object.keys(variables);
                    for(let i=0; i<domainVariables.length; i++){
                        let variableName = domainVariables[i];
                        let variableValue = variables[variableName];

                        const lookupFor = "${"+variableName+"}";
                        fileContent = fileContent.split(lookupFor).join(variableValue);
                    }

                    return callback(undefined, fileContent);
                });
            }else{
                return callback(new Error(`No template found for ${req.url}`));
            }
        });
    }

    function resolveFileAndSend(req, res, file){
        tryToCreateAtRuntimeFromTemplates(req,(err, content)=>{
            if(err){
                //console.trace(err);
                //if any error... we fallback to normal sendFile method
                return sendFile(res, file);
            }
            logger.debug("Responding with template instead of file.");
            res.statusCode = 200;

            setMimeTypeOnResponse(req.url, res);

            res.setHeader('Cache-Control', 'no-store');
            if(req.method === "HEAD"){
                return res.end();
            }
            res.end(content);
        });
    }

    function setMimeTypeOnResponse(file, res){
        let ext = path.extname(file);

        if (ext !== "") {
            ext = ext.replace(".", "");
            res.setHeader('Content-Type', utils.getMimeTypeFromExtension(ext).name);
        } else {
            res.setHeader('Content-Type', "application/octet-stream");
        }
    }

    function sendFile(res, file) {
        if (excludedFiles.includes(require("path").basename(file))) {
            res.statusCode = 403;
            res.end();
            return;
        }
        if (excludedFilesRegex) {
            let index = excludedFilesRegex.findIndex(regExp => file.match(regExp) !== null);
            if (index >= 0) {
                res.statusCode = 403;
                res.end();
                return;
            }
        }
        let stream = fs.createReadStream(file);
        setMimeTypeOnResponse(file, res);


        // instruct to not store response into cache
        res.setHeader('Cache-Control', 'no-store');
        res.statusCode = 200;
        if(res.req.method === "HEAD"){
            return res.end();
        }
        stream.pipe(res);
        stream.on('finish', () => {
            res.end();
        });
    }

    function requestValidation(req, method, urlPrefix, callback) {
        if (typeof urlPrefix === "function") {
            callback = urlPrefix;
            urlPrefix = undefined;
        }

        if (req.method !== method && req.method !== "HEAD") {
            //we resolve only GET and HEAD requests
            return callback(true);
        }

        if (typeof urlPrefix !== "undefined") {
            if (req.url.indexOf(urlPrefix) !== 0) {
                return callback(true);
            }
        }

        const path = require("swarmutils").path;
        let rootFolder = server.rootFolder;
        if(componentsConfig&&componentsConfig.staticServer&&componentsConfig.staticServer.root){
            rootFolder = path.resolve(componentsConfig.staticServer.root);
        }

        let requestedUrl = new URL(req.url, `http://${req.headers.host}`);
        let requestedUrlPathname = requestedUrl.pathname;
        if (urlPrefix) {
            requestedUrlPathname = requestedUrlPathname.replace(urlPrefix, "");
        }
        let targetPath = path.resolve(path.join(rootFolder, requestedUrlPathname));
        //if we detect tricks that tries to make us go above our rootFolder to don't resolve it!!!!

        if (targetPath.indexOf(rootFolder) !== 0) {
            return callback(true);
        }

        callback(false, targetPath);
    }

    function redirect(req, res, next) {
        requestValidation(req, "GET", function (notOurResponsibility, targetPath) {
            if (notOurResponsibility) {
                return next();
            }
            //from now on we mean to resolve the url
            //remove existing query params
            fs.stat(targetPath, function (err, stats) {
                if (err) {
                    return tryToCreateAtRuntimeFromTemplates(req,(err, content)=>{
                        if(err){
                            //if any error... we have to return 404
                            logger.info(0x04, `Failed to create from templates`)
                            res.statusCode = 404;
                            res.end();
                            return;
                        }
                        res.statusCode = 200;
                        res.setHeader('Cache-Control', 'no-store');
                        if(req.method === "HEAD"){
                            return res.end();
                        }
                        res.end(content);
                    });
                }

                if (stats.isDirectory()) {

                    let protocol = req.socket.encrypted ? "https" : "http";
                    let url = new URL(req.url, `${protocol}://${req.headers.host}`);

                    if (url.pathname[url.pathname.length - 1] !== "/") {
                        res.writeHead(302, {
                            'Location': url.pathname + "/" + url.search
                        });
                        res.end();
                        return;
                    }

                    const defaultFileName = "index.html";
                    const defaultPath = path.join(targetPath, defaultFileName);
                    fs.stat(defaultPath, function (err) {
                        if (err) {
                            logger.info(0x04, `Path <${defaultPath}> was not found`)
                            res.statusCode = 403;
                            res.end();
                            return;
                        }

                        return resolveFileAndSend(req, res, defaultPath);
                    });
                } else {
                    return resolveFileAndSend(req, res, targetPath);
                }
            });
        });
    }

    server.use("*", sendFiles);
    server.use("*", redirect);
}

module.exports = StaticServer;

},{"../../config":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/apihub/config/index.js","../../utils":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/apihub/utils/index.js","./../admin":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/apihub/components/admin/index.js","fs":false,"path":false,"swarmutils":"swarmutils"}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/apihub/components/stream/controller.js":[function(require,module,exports){
(function (global){(function (){
const syndicate = require("syndicate");
const logger = $$.getLogger("stream", "apihub/stream");

const dsuWorkers = {};

function getNodeWorkerBootScript() {
    const openDSUScriptPath = global.bundlePaths.openDSU.replace(/\\/g, "\\\\").replace(".js", "");
    return `
        require("${openDSUScriptPath}");
        (${require("./worker-script").toString()})();
    `;
}

async function handleCreateWallet(request, response) {
    try {
        const { domain, userId } = request.params;
        const keySSISpace = require("opendsu").loadApi("keyssi");
        const resolver = require("opendsu").loadApi("resolver");

        const crypto = require("pskcrypto");
        const credential = crypto.randomBytes(64).toString("hex");

        const walletSSI = keySSISpace.createTemplateWalletSSI(domain, credential);
        const seedSSI = await $$.promisify(keySSISpace.createSeedSSI)(domain);

        logger.debug(`[Stream] Creating wallet ${walletSSI.getIdentifier()} for user ${userId}...`);
        const walletDSU = await $$.promisify(resolver.createDSUForExistingSSI)(walletSSI, { dsuTypeSSI: seedSSI });

        const writableDSU = walletDSU.getWritableDSU();

        const enclaveKeySSIObject = await $$.promisify(resolver.createSeedDSU)(domain);
        const enclaveKeySSI = await $$.promisify(enclaveKeySSIObject.getKeySSIAsString)();

        const sharedEnclaveKeySSIObject = await $$.promisify(resolver.createSeedDSU)(domain);
        const sharedEnclaveKeySSI = await $$.promisify(sharedEnclaveKeySSIObject.getKeySSIAsString)();

        const constants = require("opendsu").constants;
        const environmentConfig = {
            vaultDomain: domain,
            didDomain: domain,
            enclaveType: constants.ENCLAVE_TYPES.WALLET_DB_ENCLAVE,
            enclaveKeySSI,
            sharedEnclaveType: constants.ENCLAVE_TYPES.WALLET_DB_ENCLAVE,
            sharedEnclaveKeySSI,
        };

        logger.debug(`[Stream] Settings config for wallet ${await $$.promisify(walletSSI.getAnchorId)()}`, environmentConfig);
        await $$.promisify(writableDSU.writeFile)("/environment.json", JSON.stringify(environmentConfig));

        await $$.promisify(writableDSU.writeFile)("/metadata.json", JSON.stringify({ userId }));

        response.statusCode = 200;
        return response.end(walletSSI.getIdentifier());
    } catch (error) {
        logger.error("[Stream] Error", error);
        response.statusCode = 500;
        return response.end(error);
    }
}

async function handleStreamRequest(request, response) {
    const { keySSI } = request.params;
    let requestedPath = request.url.substr(request.url.indexOf(keySSI) + keySSI.length);
    if (!requestedPath) {
        requestedPath = "/";
    }
    if (!requestedPath.startsWith("/")) {
        requestedPath = `/${requestedPath}`;
    }

    let range = request.headers.range;
    if (!range) {
        response.statusCode = 400;
        return response.end("Requires Range header");
    }

    let dsuWorker = dsuWorkers[keySSI];
    if (!dsuWorker) {
        dsuWorker = syndicate.createWorkerPool({
            bootScript: getNodeWorkerBootScript(),
            maximumNumberOfWorkers: 1,
            workerOptions: {
                eval: true,
                workerData: {
                    keySSI,
                },
            },
        });
        dsuWorkers[keySSI] = dsuWorker;
    }

    const sendTaskToWorker = (task, callback) => {
        dsuWorker.addTask(task, (err, message) => {
            if (err) {
                return callback(err);
            }

            let { error, result } = typeof Event !== "undefined" && message instanceof Event ? message.data : message;

            if (error) {
                return callback(error);
            }

            if (result && result.buffer && result.buffer instanceof Uint8Array) {
                result.buffer = $$.Buffer.from(result.buffer);
            }

            callback(error, result);
        });
    };

    const task = {
        requestedPath,
        range,
    };

    try {
        const taskResult = await $$.promisify(sendTaskToWorker)(task);
        response.writeHead(206, taskResult.headers);
        response.end(taskResult.buffer);
    } catch (error) {
        logger.error("[Stream] error", error);
        response.statusCode = 500;
        return response.end(error);
    }
}

module.exports = {
    handleCreateWallet,
    handleStreamRequest,
};

}).call(this)}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./worker-script":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/apihub/components/stream/worker-script.js","opendsu":"opendsu","pskcrypto":"pskcrypto","syndicate":"syndicate"}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/apihub/components/stream/index.js":[function(require,module,exports){
function Iframe(server) {
    const { handleCreateWallet, handleStreamRequest } = require("./controller");
    server.put(`/stream/:domain/create-wallet/:userId`, handleCreateWallet);
    server.get(`/stream/:keySSI/*`, handleStreamRequest);
}

module.exports = Iframe;

},{"./controller":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/apihub/components/stream/controller.js"}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/apihub/components/stream/worker-script.js":[function(require,module,exports){
(function (Buffer){(function (){
module.exports = async () => {
    const logger = $$.getLogger("worker-script", "apihub/stream");
    //we inject a supplementary tag in order make it more clear the source of the log

    const worker_threads = "worker_threads";
    const { parentPort, workerData } = require(worker_threads);
    logger.debug(`Node worker started for: `, workerData);

    const resolver = require("opendsu").loadApi("resolver");
    const dsu = await $$.promisify(resolver.loadDSU)(workerData.keySSI);

    parentPort.postMessage("ready");

    const CHUNK_SIZE = 1024 * 1024;

    parentPort.on("message", async (task) => {
        logger.debug("Handling task", task);
        const { requestedPath } = task;
        let { range } = task;

        try {
            let start;
            let end;

            if (range.indexOf("=") !== -1) {
                range = range.split("=")[1];
            }
            if (range.indexOf("-") !== -1) {
                parts = range.split("-");
                start = parseInt(parts[0], 10);
                if (parts[1]) {
                    end = parseInt(parts[1], 10);
                } else {
                    end = start + CHUNK_SIZE;
                }
            } else {
                start = parseInt(range, 10);
                end = start + CHUNK_SIZE;
            }
            await $$.promisify(dsu.refresh)();

            const streamRange = { start, end };
            const { totalSize, stream } = await $$.promisify(dsu.createBigFileReadStreamWithRange)(requestedPath, streamRange);
            const actualEnd = Math.min(end, totalSize - 1);
            const contentLength = actualEnd - start + 1;
            const headers = {
                "Content-Range": `bytes ${start}-${actualEnd}/${totalSize}`,
                "Accept-Ranges": "bytes",
                "Content-Length": contentLength,
                "Content-Type": "video/mp4",
            };

            function streamToBuffer(stream) {
                const chunks = [];
                return new Promise((resolve, reject) => {
                    stream.on("data", (chunk) => chunks.push(Buffer.from(chunk)));
                    stream.on("error", (err) => reject(err));
                    stream.on("end", () => resolve(Buffer.concat(chunks)));
                });
            }
            const buffer = await streamToBuffer(stream);

            parentPort.postMessage({ result: { headers, buffer } });
        } catch (error) {
            parentPort.postMessage({ error });
        }
    });

    process.on("uncaughtException", (error) => {
        logger.error("[StreamHandler] uncaughtException inside node worker", error);

        setTimeout(() => process.exit(1), 100);
    });
};

}).call(this)}).call(this,require("buffer").Buffer)

},{"buffer":false,"opendsu":"opendsu"}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/apihub/components/versionlessDSU/controller.js":[function(require,module,exports){
const path = require("path");
const fs = require("fs");
const config = require("../../config");
const openDSU = require("opendsu");
const crypto = openDSU.loadAPI("crypto");
const logger = $$.getLogger("controller", "apihub/versionlessDSU");

let versionlessDSUFolderPath;

const VERSIONLESS_DSU_PATH_PREFIX = "/versionlessdsu/";

async function init(server) {
    logger.debug(`[VersionlessDSU] Registering VersionlessDSU component`);
    versionlessDSUFolderPath = path.join(server.rootFolder, config.getConfig("externalStorage"), "versionlessdsu");
    logger.debug(`[VersionlessDSU] Ensuring VersionlessDSU folder (${versionlessDSUFolderPath}) is created`);
    try {
        await $$.promisify(fs.mkdir)(versionlessDSUFolderPath, { recursive: true });
    } catch (error) {
        logger.error("[VersionlessDSU] Failed to create VersionlessDSU folder", error);
    }
}

function sendVersionlessDSUContent(parsedDSUContent, response) {
    response.statusCode = 200;
    response.write(parsedDSUContent);
    response.end();
}

function getFilePathFromRequest(request) {
    const {url} = request;
    let filePathStartIndex = url.indexOf(VERSIONLESS_DSU_PATH_PREFIX);
    if(filePathStartIndex === -1) {
        return null;
    }

    filePathStartIndex += VERSIONLESS_DSU_PATH_PREFIX.length;
    let filePath = url.substring(filePathStartIndex);

    const filePathHash = crypto.sha256(filePath);
    return path.join(versionlessDSUFolderPath, filePathHash.substring(0, 3), filePathHash);
}

async function handleGetVersionlessDSURequest(request, response) {
    const filePath = getFilePathFromRequest(request);
    if(!filePath) {
        logger.error("[VersionlessDSU] FilePath not specified");
        response.statusCode = 400;
        return response.end();
    }

    const fs = require("fs");
    try {
        let resolvedFilePath = path.resolve(filePath);
        if(resolvedFilePath.indexOf(versionlessDSUFolderPath) === -1){
            throw Error("Trying to read outside of VersionLess storage folder");
        }

        try{
            await $$.promisify(fs.access)(filePath, fs.constants.F_OK);
        }catch(err){
            logger.info(`[VersionlessDSU] Unable to locate storage file ${filePath}`, err);
            response.statusCode = 404;
            response.end();
            return;
        }

        const fileContent = await $$.promisify(fs.readFile)(filePath);
        logger.debug(`[VersionlessDSU] Reading existing versionlessDSU from ${filePath}`);
        response.setHeader('content-type', "application/octet-stream"); // required in order for opendsu http fetch to properly work
        return sendVersionlessDSUContent(fileContent, response);
    } catch (error) {
        logger.error(`[VersionlessDSU] Failed to read/parse versionlessDSU from ${filePath}`, error);
        response.statusCode = 500;
        response.end();
    }
}

async function handlePutVersionlessDSURequest(request, response) {
    const filePath = getFilePathFromRequest(request);
    if(!filePath) {
        logger.error("[VersionlessDSU] FilePath not specified");
        response.statusCode = 400;
        return response.end();
    }

    const dsu = request.body;
    if (!dsu || typeof dsu !== "object") {
        logger.error("[VersionlessDSU] Required DSU content body not present");
        response.statusCode = 400;
        response.end();
    }

    try {
        await $$.promisify(fs.mkdir)(path.dirname(filePath), { recursive: true });
        logger.debug(`[VersionlessDSU] Writing versionlessDSU to ${filePath}`);
        let resolvedFilePath = path.resolve(filePath);
        if(resolvedFilePath.indexOf(versionlessDSUFolderPath) === -1){
            throw Error("Trying to write outside of VersionLess storage folder");
        }
        await $$.promisify(fs.writeFile)(filePath, dsu);
        response.statusCode = 200;
        response.end();
    } catch (error) {
        logger.error(`[VersionlessDSU] Failed to write DSU content to file ${filePath}: (${dsu})`, error);
        response.statusCode = 500;
        response.end();
    }
}

module.exports = {
    init,
    handleGetVersionlessDSURequest,
    handlePutVersionlessDSURequest,
};

},{"../../config":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/apihub/config/index.js","fs":false,"opendsu":"opendsu","path":false}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/apihub/components/versionlessDSU/index.js":[function(require,module,exports){
function VersionlessDSU(server) {
    const logger = $$.getLogger("VersionlessDSU");
    logger.info("Initializing VersionlessDSU");
    const { init, handleGetVersionlessDSURequest, handlePutVersionlessDSURequest } = require("./controller");
    const { bodyReaderMiddleware } = require("../../utils/middlewares");

    init(server);

    server.get("/versionlessdsu/*", handleGetVersionlessDSURequest);

    server.put("/versionlessdsu/*", bodyReaderMiddleware);
    server.put("/versionlessdsu/*", handlePutVersionlessDSURequest);

}

module.exports = VersionlessDSU;

},{"../../utils/middlewares":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/apihub/utils/middlewares/index.js","./controller":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/apihub/components/versionlessDSU/controller.js"}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/apihub/config/config-migrator.js":[function(require,module,exports){
const logger = $$.getLogger("config-migrator", "apihub/config");

function removeConfigComponent(config) {
    if (config.componentsConfig && config.componentsConfig.config) {
        delete config.componentsConfig.config;
    }
}

function traverseObjectProvidedPrimitiveValues(item, onItemTraversal) {
    if (Array.isArray(item)) {
        item.forEach((element) => traversePrimitiveItemValues(element, onItemTraversal));
    } else if (typeof item === "object" && item != null) {
        Object.values(item)
            .filter((key) => item[key])
            .forEach((key) => {
                const value = item[key];
                if (isArray(value) || typeof item === "object") {
                    traverseObjectProvidedPrimitiveValues(value, onItemTraversal);
                } else {
                    onItemTraversal(item, key);
                }
            });
    }
}

function replaceInternalVolumePathsWithExternalVolume(config) {
    traverseObjectProvidedPrimitiveValues(config, (item, key) => {
        let value = item[key];
        if (key === "path" && typeof value === "string" && value.indexOf("internal-volume") !== -1) {
            item[key] = value.replace("internal-volume", "external-volume");
        }
    });
}

function removeBrickingPathConfig(config) {
    if (config.componentsConfig && config.componentsConfig.bricking && config.componentsConfig.bricking.domains) {
        const brickingDomains = config.componentsConfig.bricking.domains;
        Object.keys(brickingDomains).forEach((domain) => {
            delete brickingDomains[domain].path;
        });
    }
}

function removeAnchoringPathConfig(config) {
    if (config.componentsConfig && config.componentsConfig.anchoring && config.componentsConfig.anchoring.domainStrategies) {
        const anchoringDomains = config.componentsConfig.anchoring.domainStrategies;
        Object.keys(anchoringDomains).forEach((domain) => {
            const domainConfig = anchoringDomains[domain];
            if (domainConfig.type === "FS" && domainConfig.option) {
                delete domainConfig.option.path;
            }
        });
    }
}

function extractDomainConfigsAndRemoveThemFromConfig(config) {
    const domainConfigs = {};

    const { componentsConfig } = config;
    if (componentsConfig) {
        const { bricking, anchoring, bricksFabric } = componentsConfig;

        if (bricking) {
            // remove the domains property from bricking since the only used config is "path" which is constructed by convention
            delete bricking.domains;
        }

        if (anchoring && anchoring.domainStrategies) {
            const { domainStrategies } = anchoring;
            Object.keys(domainStrategies).forEach((domain) => {
                if (!domainConfigs[domain]) {
                    domainConfigs[domain] = {};
                }
                const domainConfig = domainConfigs[domain];
                domainConfig.anchoring = {
                    ...domainStrategies[domain],
                };

                if (domainConfig.anchoring.option) {
                    // remove the "path" config which is constructed by convention
                    delete domainConfig.anchoring.option.path;
                }
            });

            delete anchoring.domainStrategies;
        }

        if (bricksFabric && bricksFabric.domainStrategies) {
            const { domainStrategies } = bricksFabric;
            Object.keys(domainStrategies).forEach((domain) => {
                if (!domainConfigs[domain]) {
                    domainConfigs[domain] = {};
                }
                const domainConfig = domainConfigs[domain];
                domainConfig.bricksFabric = {
                    ...domainStrategies[domain],
                };
            });

            delete bricksFabric.domainStrategies;
        }
    }

    return domainConfigs;
}

function migrate(oldConfig, configFolderPath) {
    // create a clone in order to not influence config from outside of the migrator
    oldConfig = JSON.parse(JSON.stringify(oldConfig));

    const { storage, sslFolder, port, host, preventRateLimit, tokenBucket } = oldConfig;
    const { enableInstallationDetails, enableRequestLogger, enableLocalhostAuthorization } = oldConfig;
    const config = {
        storage,
        sslFolder,
        port,
        host,
        preventRateLimit,
        activeComponents: oldConfig.activeEndpoints,
        componentsConfig: oldConfig.endpointsConfig,
        tokenBucket,
        enableInstallationDetails,
        enableRequestLogger,
        enableJWTAuthorisation: oldConfig.enableAuthorisation,
        enableLocalhostAuthorization,
        skipJWTAuthorisation: oldConfig.skipAuthorisation,
    };

    removeConfigComponent(config);
    replaceInternalVolumePathsWithExternalVolume(config);
    removeBrickingPathConfig(config);
    removeAnchoringPathConfig(config);

    const domainConfigs = extractDomainConfigsAndRemoveThemFromConfig(config);

    const path = require("path");
    const fs = require("fs");
    const apihubJsonConfigPath = path.join(configFolderPath, "apihub.json");
    logger.debug(`Generating apihub.json config file at ${apihubJsonConfigPath}...`);

    if (!fs.existsSync(configFolderPath)) {
        fs.mkdirSync(configFolderPath, { recursive: true });
    }
    fs.writeFileSync(apihubJsonConfigPath, JSON.stringify(config, null, 2));

    const domainConfigsFolderPath = path.join(configFolderPath, "domains");
    if (!fs.existsSync(domainConfigsFolderPath)) {
        fs.mkdirSync(domainConfigsFolderPath, { recursive: true });
    }

    Object.keys(domainConfigs).forEach((domain) => {
        const domainConfig = domainConfigs[domain];
        const domainConfigPath = path.join(domainConfigsFolderPath, `${domain}.json`);
        logger.debug(`Generating config file for domain '${domain}' at ${domainConfigPath}...`);
        fs.writeFileSync(domainConfigPath, JSON.stringify(domainConfig, null, 2));
    });

    try {
        const serverJsonConfigPath = path.join(configFolderPath, "server.json");
        fs.unlinkSync(serverJsonConfigPath);
    } catch (error) {
        //We ignore this error because is not relevant.
        //Until now most of the implementations for sure switched from server.json to apihub.json
    }
}

module.exports = {
    migrate,
};

},{"fs":false,"path":false}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/apihub/config/default.js":[function(require,module,exports){

const defaultConfig = {
    "storage":  require("swarmutils").path.join(process.env.PSK_ROOT_INSTALATION_FOLDER, "tmp"),
    "externalStorage": "./external-volume",
    "sslFolder":  require("swarmutils").path.join(process.env.PSK_ROOT_INSTALATION_FOLDER, "conf", "ssl"),
    "port": 8080,
    "host": "0.0.0.0",
    "zeromqForwardAddress": "tcp://127.0.0.1:5001",
    "preventRateLimit": false,
    // staticServer needs to load last
    "activeComponents": ["config", "mq", "secrets", "notifications", "bdns", "bricking", "anchoring", 'debugLogger', "mainDSU", "cloudWallet", "versionlessDSU", "stream", "lightDBEnclave", "staticServer"],
    "componentsConfig": {
        "mq":{
            "module": "./components/mqHub",
            "function": "MQHub",
            "connectionTimeout": 10000
        },
        "secrets":{
            "module": "./components/secrets"
        },
        "notifications": {
            "module": "./components/keySsiNotifications",
            "workingDirPath": "./external-volume/notifications"
        },
        "bdns": {
            "module": "./components/bdns",
        },
        "bricking": {
            "module": "./components/bricking",
        },
        "anchoring": {
            "module": "./components/anchoring",
            "anchoringStrategy": "FS"
        },
        "debugLogger": {
            "module": './components/debugLogger',
            "workingDirPath": './external-volume/debug-logger',
            "storageDirPath": './external-volume/debug-logger/storage',
        },
        "staticServer": {
            "module": "./components/staticServer"
        },
        "contracts": {
            "module": "./components/contracts",
            "domainsPath": "/external-volume/domains"
        },
        "admin": {
            "module": "./components/admin",
            "function": "AdminComponentHandler",
            "storageFolder": './external-volume/config/admin'
        },
        "mainDSU": {
            "module": "./components/mainDSU"
        },
        "cloudWallet": {
            "module": "./components/cloudWallet",
            "dsuBootPath": "./builds/output/nodeBoot.js"
        },
        "stream": {
            "module": "./components/stream"
        },
        "versionlessDSU": {
            "module": "./components/versionlessDSU"
        },
        "requestForwarder":{
            "module": "./components/requestForwarder"
        },
        "lightDBEnclave": {
            "module": "./components/lightDBEnclave",
        },
        "requestLogger":{
            "comment": "this is a standard middleware but its config is here to make it as uniform as possible",
            "statusLogInterval": 3000,
            "longRequests":["/mq/"]
        },
        "activeComponents":{
            "module": "./components/activeComponents",
        }
    },
    "tokenBucket": {
        "cost": {
            "low": 10,
            "medium": 100,
            "high": 500
        },
        "error": {
            "limitExceeded": "error_limit_exceeded",
            "badArgument": "error_bad_argument"
        },
        "startTokens": 6000,
        "tokenValuePerTime": 10,
        "unitOfTime": 100
    },
    "enableInstallationDetails": false,
    "enableRequestLogger": true,
    "enableJWTAuthorisation": false,
    "enableSimpleAuth": false,
    "enableAPIKeyAuth": false,
    "enableClientCredentialsOauth": false,
    "enableLocalhostAuthorization": false,
    "enableErrorCloaking": false,
    "enableReadOnlyMechanism": true,
    "readOnlyFile": "readonly",
    "readOnlyInterval": 60000,
    "skipJWTAuthorisation": [
        "/leaflet-wallet",
        "/config",
        "/anchor",
        "/bricking",
        "/bricksFabric",
        "/create-channel",
        "/send-message",
        "/receive-message",
        "/files",
        "/notifications",
        "/mq",
        "/enclave",
        "/secrets",
        "/logs"
    ]
};

module.exports = Object.freeze(defaultConfig);

},{"swarmutils":"swarmutils"}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/apihub/config/index.js":[function(require,module,exports){
let apihubConfig;
let tokenIssuers;
let domainConfigs = {};
const logger = $$.getLogger("index", "apihub/config");

function checkIfFileExists(filePath) {
    try {
        const fs = require("fs");
        fs.accessSync(filePath);
        return true;
    } catch (error) {
        logger.error(`File ${filePath} doesn't exists or no access is possible!`);
    }
    return false;
}

function loadAllDomainConfigs(configFolderPath) {
    const path = require("swarmutils").path;
    const fs = require("fs");
    const domainsFolderPath = path.join(configFolderPath, 'domains');
    if(checkIfFileExists(domainsFolderPath)) {
        try {
            fs.readdirSync(domainsFolderPath)
                .filter((domainFile) => domainFile.endsWith(".json"))
                .forEach((domainFile) => {
                    const domain = domainFile.substring(0, domainFile.lastIndexOf("."));
                    logger.debug(`Loading config for domain '${domain}'`);

                    try {
                        const domainConfig = fs.readFileSync(path.join(domainsFolderPath, domainFile));
                        domainConfigs[domain] = JSON.parse(domainConfig);
                    } catch (error) {
                        logger.error(`Could not read config for domain '${domain}'`, error);
                    }
                });
        } catch (error) {
            logger.error(`Could not read domain configs at ${domainsFolderPath}`, error);
        }
    } else {
        logger.error(`Domain configs folder not found at ${domainsFolderPath}`);
    }
}

function ensureConfigsAreLoaded() {
    const path = require("swarmutils").path;

    if(!apihubConfig) {
        let apihubJson;
        if (typeof process.env.PSK_CONFIG_LOCATION === "undefined") {
            logger.debug("PSK_CONFIG_LOCATION env variable not set. Not able to load any external config. Using default configuration.")
            apihubJson = {};
        } else {
            const fs = require("fs");
            const configFolderPath = path.resolve(process.env.PSK_CONFIG_LOCATION);
            logger.debug("Trying to read the apihub.json file from the location pointed by PSK_CONFIG_LOCATION env variable.");
            const apihubConfigPath = path.join(configFolderPath, 'apihub.json');

            if(!checkIfFileExists(apihubConfigPath)) {
                logger.debug("Trying to read the server.json file from the location pointed by PSK_CONFIG_LOCATION env variable.");
                const serverJsonConfigPath = path.join(configFolderPath, 'server.json');

                let serverJson;
                if(checkIfFileExists(serverJsonConfigPath)) {
                    serverJson = JSON.parse(fs.readFileSync(serverJsonConfigPath));
                } else {
                    serverJson = {};
                }

                // migrate server.json to apihub.json
                const configMigrator = require("./config-migrator");
                configMigrator.migrate(serverJson, configFolderPath);
            }

            apihubJson = JSON.parse(fs.readFileSync(apihubConfigPath));
            loadAllDomainConfigs(configFolderPath);
        }

        apihubJson = apihubJson || {};
        apihubConfig = new ApihubConfig(apihubJson);
    }
}

function getConfig(...keys) {
    ensureConfigsAreLoaded();

    if (keys.length === 0) {
        return apihubConfig;
    }

    return getSource(keys, apihubConfig);
}

function ApihubConfig(conf) {
    const defaultConf = require('./default');

    function createConfig(config, defaultConfig) {
        if (typeof config === "undefined") {
            return defaultConfig;
        }
    
        //ensure that the config object will contain all the necessary keys for server configuration
        for (let mandatoryKey in defaultConfig) {
            if (typeof config[mandatoryKey] === "undefined") {
                config[mandatoryKey] = defaultConfig[mandatoryKey];
            }
        }
        return __createConfigRecursively(conf, defaultConf);
    
        function __createConfigRecursively(config, defaultConfig) {
            for (let prop in defaultConfig) {
                if (typeof config[prop] === "object" && !Array.isArray(config[prop])) {
                    __createConfigRecursively(config[prop], defaultConfig[prop]);
                } else {
                    if (typeof config[prop] === "undefined") {
                        config[prop] = defaultConfig[prop];
                        __createConfigRecursively(config[prop], defaultConfig[prop]);
                    }
                }
            }
            return config;
        }
    }

    conf = createConfig(conf, defaultConf);
    conf.defaultComponents = defaultConf.activeComponents;
    if(conf.isDefaultComponent){
        logger.debug("\n\nBe aware that there is a method on the config called isDefaultComponent. You need to check and change your config name.\n\n");
    }
    conf.isDefaultComponent = function(componentName) {
        return defaultConf.activeComponents.indexOf(componentName) !== -1 || defaultConf.componentsConfig[componentName];
    }
    return conf;
}

function getSource(arrayKeys, source) {
    if (!arrayKeys.length || source === undefined) {
        return source;
    }

    return getSource(arrayKeys, source[arrayKeys.shift()]);
}

function getTokenIssuers(callback) {
    const fs = require("fs");
    const path = require("swarmutils").path;

    if (tokenIssuers) {
        return callback(null, tokenIssuers);
    }

    if (typeof process.env.PSK_CONFIG_LOCATION === "undefined") {
        tokenIssuers = [];
        return callback(null, tokenIssuers);
    }

    const filePath = path.join(path.resolve(process.env.PSK_CONFIG_LOCATION), "issuers-public-identities");
    logger.debug(
        `Trying to read the token-issuers.txt file from the location pointed by PSK_CONFIG_LOCATION env variable: ${filePath}`
    );

    fs.access(filePath, fs.F_OK, (err) => {
        if (err) {
            logger.debug(`${filePath} doesn't exist so skipping it`);
            tokenIssuers = [];
            callback(null, tokenIssuers);
        }

        fs.readFile(filePath, "utf8", function (err, data) {
            if (err) {
                logger.error(`Cannot load ${filePath}`, err);
                return;
            }

            const openDSU = require("opendsu");
            const crypto = openDSU.loadApi("crypto");

            tokenIssuers = data.split(/\s+/g).filter((issuer) => issuer).map(issuer => crypto.getReadableSSI(issuer));

            callback(null, tokenIssuers);
        });
    });
}

function getDomainConfigFilePath(domain) {
    const path = require("swarmutils").path;
    const domainConfigPath = path.join(path.resolve(process.env.PSK_CONFIG_LOCATION), `domains/${domain}.json`);
    return domainConfigPath;
}

function getConfiguredDomains() {
    ensureConfigsAreLoaded();
    return Object.keys(domainConfigs);
}

async function getSafeDomainConfig(domain, ...configKeys){
    let domainConfig = getDomainConfig(domain);
    if(!domainConfig){
        try{
            let adminService = require("./../components/admin").getAdminService();
            const getDomainInfo = $$.promisify(adminService.getDomainInfo);
            let domainInfo = await getDomainInfo(domain);
            if(domainInfo && domainInfo.active && domainInfo.cloneFromDomain){
                logger.debug(`Config for domain '${domain}' was loaded from admin service.`);
                return getDomainConfig(domainInfo.cloneFromDomain);
            }
        }catch(err){
            //we ignore any errors in this try-catch block because admin component may be disabled
        }
    }
    return getDomainConfig(domain, ...configKeys);
}

function getDomainConfig(domain, ...configKeys) {
    ensureConfigsAreLoaded();
    if(!domain) {
        return {};
    }

    const getConfigResult = (config) => {
        if(!configKeys) {
            configKeys = [];
        }
        let configResult = config ? getSource(configKeys, config) : null;
        return configResult;
    }

    const loadedDomainConfig = domainConfigs[domain];
    if(typeof loadedDomainConfig !== 'undefined') {
        return getConfigResult(loadedDomainConfig);
    }

    if (typeof process.env.PSK_CONFIG_LOCATION === "undefined") {
        logger.debug('PSK_CONFIG_LOCATION env variable not set. Not able to load domain config. Using default configuration.')
        return getConfigResult({});
    }

    const domainConfigPath = getDomainConfigFilePath(domain);
    logger.debug(`Trying to read the config for domain '${domain}' at location: ${domainConfigPath}`);

    try {
        const fsName = "fs";
        const domainConfigContent = require(fsName).readFileSync(domainConfigPath);
        const domainConfig = JSON.parse(domainConfigContent);
        domainConfigs[domain] = domainConfig;
        return getConfigResult(domainConfig);
    } catch (error) {
        logger.error(`Config for domain '${domain}' cannot be loaded from location: ${domainConfigPath}.`);
        domainConfigs[domain] = null;
        return domainConfigs[domain];
    }
}

function updateDomainConfig(domain, config, callback) {
    ensureConfigsAreLoaded();
    const domainConfigPath = getDomainConfigFilePath(domain);
    const fsName = "fs";
    require(fsName).writeFile(domainConfigPath, JSON.stringify(config), (error) => {
        if(error) {
            return callback(error);
        }

        // update the domain config cache
        domainConfigs[domain] = config;
        callback();
    })
}

module.exports = {getConfig, getTokenIssuers, getConfiguredDomains, getDomainConfig, getSafeDomainConfig, updateDomainConfig};

},{"./../components/admin":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/apihub/components/admin/index.js","./config-migrator":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/apihub/config/config-migrator.js","./default":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/apihub/config/default.js","fs":false,"opendsu":"opendsu","swarmutils":"swarmutils"}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/apihub/libs/Notifications.js":[function(require,module,exports){
const stateStorageFileName = 'queues.json';

function NotificationsManager(workingFolderPath, storageFolderPath) {
	const queues = {};
	const subscribers = {};
	const swarmUtils = require('swarmutils');
	const logger = $$.getLogger("NotificationsManager", "apihub/libs");

	this.createQueue = function (queueName, callback) {
		if (typeof queues[queueName] !== "undefined") {
			return callback({ message: 'Queue already exists.', statusCode: 409 });
		}

		createQueue(queueName, (err) => {
			if (err) {
				return callback(err);
			}

			try {
				if (typeof storageFolderPath !== 'undefined') {
					require('fs').mkdirSync(getQueueStoragePath(queueName), { recursive: true });
				}
			} catch (err) {
				return callback(err);
			}

			return callback();
		});
	}

	function createQueue(name, callback) {
		queues[name] = new swarmUtils.Queue();
		if (callback) {
			saveState(callback);
		}
	}

	function getQueueStoragePath(queueName) {
		let path = swarmUtils.path;
		const opendsu = require("opendsu");
		const crypto = opendsu.loadAPI('crypto');
		if (queueName.indexOf(':') !== -1) {
			queueName = crypto.encodeBase58(queueName);
		}
		return path.join(storageFolderPath, queueName);
	}

	function deliverMessage(subs, message, callback) {
		let counter = 0;
		while (subs.length > 0) {
			let sub = subs.pop();
			try {
				sub(undefined, message);
				counter++;
			} catch (err) {
				//if something happens durring message delivery we will catch the error here
			}
		}
		callback(undefined, counter);
	}

	function storeMessage(queueName, message, callback) {
		let path = swarmUtils.path;
		let fileName = path.join(getQueueStoragePath(queueName), new Date().getTime());
		require('fs').writeFile(fileName, message, (err) => {
			if (err) {
				return callback(err);
			}
			return callback(undefined, fileName);
		});
	}

	function buildNotification(message, timestamp, filename, ttl) {
		return {
			filename,
			message,
			timestamp: timestamp ? timestamp : new Date().getTime(),
			ttl
		};
	}

	function addMessageToQueue(queueName, message, messageTTL, callback) {
		if (typeof messageTTL === 'function') {
			callback = messageTTL;
			messageTTL = undefined;
		}
		const notificationObject = buildNotification(message, undefined, undefined, messageTTL);

		if(typeof queues[queueName] === "undefined"){
			return callback(new Error(`There is no queue called ${queueName}`));
		}

		queues[queueName].push(notificationObject);

		if (typeof storageFolderPath !== 'undefined') {
			return storeMessage(queueName, message, (err, fileName) => {
				if (fileName) {
					notificationObject.filename = fileName;
				}
				callback(err);
			});
		}
        callback();
	}

	this.sendMessage = function (queueName, message, messageTTL, callback) {
		if (typeof messageTTL === 'function') {
			callback = messageTTL;
			messageTTL = undefined;
		}

		let subs = subscribers[queueName];
		if (typeof subs !== 'undefined' && subs.length > 0) {
			return deliverMessage(subs, message, (err, counter)=>{
				if(err || counter === 0){
					return addMessageToQueue(queueName, message, messageTTL, callback);
				}
				return callback(err, counter);
			});
		}

		return addMessageToQueue(queueName, message, messageTTL, callback);
	}

	this.readMessage = function (queueName, callback) {
		if (typeof subscribers[queueName] === 'undefined') {
			subscribers[queueName] = [];
		}

		const subs = subscribers[queueName];
		subs.push(callback);
		
		if(typeof queues[queueName] === "undefined"){
			return callback("Not able to find the queue.");
		}
		
		const notificationObject = queues[queueName].pop();

		if (typeof notificationObject !== 'undefined' && notificationObject !== null) {
			deliverMessage(subs, notificationObject.message, (err, counter) => {
				if (counter > 0) {
					//message delivered... let's remove from storage if it was persisted
					if (typeof notificationObject.filename !== 'undefined') {
						try {
							require('fs').unlinkSync(notificationObject.filename);
						} catch (err) {
							logger.error(err);
						}
					}
				}
			});
		}
	}

	function loadState(callback) {
		let state;

		try {
			const path = require("path");
			const fs = require("fs");
			const fileLocation = path.join(workingFolderPath, stateStorageFileName);
			if(!fs.existsSync(fileLocation)){
				throw `${fileLocation} not found. No previous state available.`;
			}
			state = require(fileLocation);
		} catch (err) {
			//if the storage file does not exist or invalid json file we will catch an error here
			return callback();
		}

		if (typeof state !== 'undefined') {
			for (let i = 0; i < state.queues.length; i++) {
				let queueName = state.queues[i];
				createQueue(queueName);
			}
		}

		callback(undefined, state);
	}

	function saveState(callback) {
		let state = {
			queues: Object.keys(queues)
		}

		let fs = require('fs');
		let path = swarmUtils.path;

		fs.writeFile(path.join(workingFolderPath, stateStorageFileName), JSON.stringify(state, null, 4), callback);
	}

	/**
	 * Remove expired queued notifications
	 * Do async cleanup in batches in order to
	 * prevent hogging the event loop
	 */
	function startMQCleanup() {
		const batchCleanup = (startIndex, subBatchSize, msgBatchSize, done) => {
			const keys = Object.keys(queues);
			const now = new Date().getTime();
			if (!keys.length) {
				return done(0);
			}
			let i = startIndex;
			let max = i + subBatchSize;
			for (i; i < max; i++) {
				let key = keys[i];
				if (!key) {
					break;
				}
				const queue = queues[key];
				if (!queue.length) {
					continue;
				}

				let counter = 0;
				for (const msg of queue) {
					if (++counter > msgBatchSize) {
						break;
					}
					if (!msg.ttl) {
						continue;
					}
					const elapsed = now - msg.timestamp;
					// Remove expired message
					if (elapsed >= msg.ttl) {
						queue.remove(msg);
					}
				}
			}

			let resumeIndex = i;
			if (i >= keys.length - 1) {
				resumeIndex = 0;
			}
			done(resumeIndex);
		}


		const runCleanup = (startIndex = 0) => {
			setTimeout(() => {
				batchCleanup(startIndex, 10, 100, (resumeIndex) => {
					runCleanup(resumeIndex);
				})
			}, 250);
		}

		runCleanup();
	}

	this.initialize = function (callback) {
		let fs = require('fs');
		let path = swarmUtils.path;

		//if it's the first time we need to ensure that the working folder exists
		if (!fs.existsSync(workingFolderPath)) {
			fs.mkdirSync(workingFolderPath, { recursive: true });
		}

		startMQCleanup();

		loadState((err, state) => {
			if (typeof storageFolderPath === 'undefined') {
				return callback();
			}

			//if it's the first time we need to ensure that the storage folder exists
			if (!fs.existsSync(storageFolderPath)) {
				fs.mkdirSync(storageFolderPath, { recursive: true });
			}

			//if is our first boot using a specific folder there is no state to be loaded
			if (typeof state === 'undefined') {
				return callback();
			}

			for (let i = 0; i < state.queues.length; i++) {
				let queueName = state.queues[i];
				let queueStoragePath = getQueueStoragePath(queueName);
				fs.readdir(queueStoragePath, (err, messages) => {
					if (err) {
						return callback(err);
					}

					messages.sort(function (a, b) {
						return Number(a) - Number(b);
					});

					for (let i = 0; i < messages.length; i++) {
						let messageTimestamp = messages[i];
						let messageStoragePath = path.join(queueStoragePath, messageTimestamp);
						queues[queueName].push(buildNotification(fs.readFileSync(messageStoragePath), messageTimestamp, messageStoragePath));
					}
				});
			}
			callback();
		});
	}
}

module.exports = {
	getManagerInstance: function (workingFolderPath, storageFolderPath, callback) {
		if (typeof storageFolderPath === 'function') {
			callback = storageFolderPath;
			storageFolderPath = undefined;
		}

		let manager = new NotificationsManager(workingFolderPath, storageFolderPath);
		manager.initialize((err) => {
			callback(err, manager);
		});
	}
};

},{"fs":false,"opendsu":"opendsu","path":false,"swarmutils":"swarmutils"}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/apihub/libs/TokenBucket.js":[function(require,module,exports){
/**
 * An implementation of the Token bucket algorithm
 * @param startTokens - maximum number of tokens possible to obtain and the default starting value
 * @param tokenValuePerTime - number of tokens given back for each "unitOfTime"
 * @param unitOfTime - for each "unitOfTime" (in milliseconds) passed "tokenValuePerTime" amount of tokens will be given back
 * @constructor
 */
const config = require('./../config');

function TokenBucket(startTokens = config.getConfig('tokenBucket', 'startTokens'),
    tokenValuePerTime = config.getConfig('tokenBucket', 'tokenValuePerTime'),
    unitOfTime = config.getConfig('tokenBucket', 'unitOfTime')) {

    if (typeof startTokens !== 'number' || typeof tokenValuePerTime !== 'number' || typeof unitOfTime !== 'number') {
        throw new Error('All parameters must be of type number');
    }

    if (isNaN(startTokens) || isNaN(tokenValuePerTime) || isNaN(unitOfTime)) {
        throw new Error('All parameters must not be NaN');
    }

    if (startTokens <= 0 || tokenValuePerTime <= 0 || unitOfTime <= 0) {
        throw new Error('All parameters must be bigger than 0');
    }

    TokenBucket.prototype.COST_LOW = config.getConfig('tokenBucket', 'cost', 'low');  // equivalent to 10op/s with default values
    TokenBucket.prototype.COST_MEDIUM = config.getConfig('tokenBucket', 'cost', 'medium'); // equivalent to 1op/s with default values
    TokenBucket.prototype.COST_HIGH = config.getConfig('tokenBucket', 'cost', 'high'); // equivalent to 12op/minute with default values

    TokenBucket.ERROR_LIMIT_EXCEEDED = config.getConfig('tokenBucket', 'error', 'limitExceeded');
    TokenBucket.ERROR_BAD_ARGUMENT = config.getConfig('tokenBucket', 'error', 'badArgument');

    const limits = {};

    function takeToken(userKey, cost, callback = () => { }) {
        if (typeof cost !== 'number' || isNaN(cost) || cost <= 0 || cost === Infinity) {
            callback(TokenBucket.ERROR_BAD_ARGUMENT);
            return;
        }

        const userBucket = limits[userKey];

        if (userBucket) {
            userBucket.tokens += calculateReturnTokens(userBucket.timestamp);
            userBucket.tokens -= cost;

            userBucket.timestamp = Date.now();

            if (userBucket.tokens < 0) {
                userBucket.tokens = 0;
                callback(TokenBucket.ERROR_LIMIT_EXCEEDED, 0);
                return;
            }

            return callback(undefined, userBucket.tokens);
        } else {
            limits[userKey] = new Limit(startTokens, Date.now());
            takeToken(userKey, cost, callback);
        }
    }

    function getLimitByCost(cost) {
        if (startTokens === 0 || cost === 0) {
            return 0;
        }

        return Math.floor(startTokens / cost);
    }

    function getRemainingTokenByCost(tokens, cost) {
        if (tokens === 0 || cost === 0) {
            return 0;
        }

        return Math.floor(tokens / cost);
    }

    function Limit(maximumTokens, timestamp) {
        this.tokens = maximumTokens;
        this.timestamp = timestamp;

        const self = this;

        return {
            set tokens(numberOfTokens) {
                if (numberOfTokens < 0) {
                    numberOfTokens = -1;
                }

                if (numberOfTokens > maximumTokens) {
                    numberOfTokens = maximumTokens;
                }

                self.tokens = numberOfTokens;
            },
            get tokens() {
                return self.tokens;
            },
            timestamp
        };
    }


    function calculateReturnTokens(timestamp) {
        const currentTime = Date.now();

        const elapsedTime = Math.floor((currentTime - timestamp) / unitOfTime);

        return elapsedTime * tokenValuePerTime;
    }

    this.takeToken = takeToken;
    this.getLimitByCost = getLimitByCost;
    this.getRemainingTokenByCost = getRemainingTokenByCost;
}

module.exports = TokenBucket;

},{"./../config":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/apihub/config/index.js"}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/apihub/libs/http-wrapper/src/classes/Client.js":[function(require,module,exports){
const http = require('http');
const url = require('url');
const stream = require('stream');

/**
 * Wraps a request and augments it with a "do" method to modify it in a "fluent builder" style
 * @param {string} url
 * @param {*} body
 * @constructor
 */
function Request(url, body) {
    this.request = {
        options: url,
        body
    };

    this.do = function (modifier) {
        modifier(this.request);
        return this;
    };

    this.getHttpRequest = function () {
        return this.request;
    };
}


/**
 * Modifies request.options to contain the url parsed instead of as string
 * @param {Object} request - Object that contains options and body
 */
function urlToOptions(request) {
    const parsedUrl = url.parse(request.options);

    // TODO: movie headers declaration from here
    request.options = {
        host: parsedUrl.hostname,
        port: parsedUrl.port,
        path: parsedUrl.pathname,
        headers: {}
    };
}


/**
 * Transforms the request.body in a type that can be sent through network if it is needed
 * @param {Object} request - Object that contains options and body
 */
function serializeBody(request) {
    if (!request.body) {
        return;
    }

    const handler = {
        get: function (target, name) {
            return name in target ? target[name] : (data) => data;
        }
    };

    const bodySerializationMapping = new Proxy({
        'Object': (data) => JSON.stringify(data),
    }, handler);

    request.body = bodySerializationMapping[request.body.constructor.name](request.body);
}

/**
 *
 * @param {Object} request - Object that contains options and body
 */
function bodyContentLength(request) {
    if (!request.body) {
        return;
    }

    if (request.body.constructor.name in [ 'String', '$$.Buffer', 'ArrayBuffer' ]) {
        request.options.headers['Content-Length'] = $$.Buffer.byteLength(request.body);
    }
}


function Client() {
    /**
     *
     * @param {Request} customRequest
     * @param modifiers - array of functions that modify the request
     * @returns {Object} - with url and body properties
     */
    function request(customRequest, modifiers) {
        for (let i = 0; i < modifiers.length; ++i) {
            customRequest.do(modifiers[i]);
        }

        return customRequest.getHttpRequest();
    }

    function getReq(url, config, callback) {
        const modifiers = [
            urlToOptions,
            (request) => {request.options.headers = config.headers || {};}
        ];

        const packedRequest = request(new Request(url, config.body), modifiers);
        const httpRequest = http.request(packedRequest.options, callback);
        httpRequest.end();

        return httpRequest;
    }

    function postReq(url, config, callback) {
        const modifiers = [
            urlToOptions,
            (request) => {request.options.method = 'POST'; },
            (request) => {request.options.headers = config.headers || {}; },
            serializeBody,
            bodyContentLength
        ];

        const packedRequest = request(new Request(url, config.body), modifiers);
        const httpRequest = http.request(packedRequest.options, callback);

        if (config.body instanceof stream.Readable) {
            config.body.pipe(httpRequest);
        }
        else {
            httpRequest.end(packedRequest.body, config.encoding || 'utf8');
        }
        return httpRequest;
    }

    function deleteReq(url, config, callback) {
        const modifiers = [
            urlToOptions,
            (request) => {request.options.method = 'DELETE';},
            (request) => {request.options.headers = config.headers || {};},
        ];

        const packedRequest = request(new Request(url, config.body), modifiers);
        const httpRequest = http.request(packedRequest.options, callback);
        httpRequest.end();

        return httpRequest;
    }

    this.get = getReq;
    this.post = postReq;
    this.delete = deleteReq;
}

/**
 * Swap third and second parameter if only two are provided and converts arguments to array
 * @param {Object} params
 * @returns {Array} - arguments as array
 */
function parametersPreProcessing(params) {
    const res = [];

    if (typeof params[0] !== 'string') {
        throw new Error('First parameter must be a string (url)');
    }

    const parsedUrl = url.parse(params[0]);

    if (!parsedUrl.hostname) {
        throw new Error('First argument (url) is not valid');
    }

    if (params.length >= 3) {
        if (typeof params[1] !== 'object' || !params[1]) {
            throw new Error('When 3 parameters are provided the second parameter must be a not null object');
        }

        if (typeof params[2] !== 'function') {
            throw new Error('When 3 parameters are provided the third parameter must be a function');
        }
    }

    if (params.length === 2) {
        if (typeof params[1] !== 'function') {
            throw new Error('When 2 parameters are provided the second one must be a function');
        }

        params[2] = params[1];
        params[1] = {};
    }

    const properties = Object.keys(params);
    for(let i = 0, len = properties.length; i < len; ++i) {
        res.push(params[properties[i]]);
    }

    return res;
}

const logger = $$.getLogger("Client", "apihub/http-wrapper");

const handler = {
    get(target, propName) {
        if (!target[propName]) {
            logger.error(propName, "Not implemented!");
        } else {
            return function () {
                const args = parametersPreProcessing(arguments);
                return target[propName].apply(target, args);
            };
        }
    }
};

module.exports = function () {
    return new Proxy(new Client(), handler);
};
},{"http":false,"stream":false,"url":false}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/apihub/libs/http-wrapper/src/classes/MiddlewareRegistry.js":[function(require,module,exports){
const querystring = require('querystring');
const logger = $$.getLogger("http-wrapper", "apihub/libs");

function matchUrl(pattern, url) {
	const result = {
		match: true,
		params: {},
		query: {}
	};

	const queryParametersStartIndex = url.indexOf('?');
	if(queryParametersStartIndex !== -1) {
		const urlQueryString = url.substr(queryParametersStartIndex + 1); // + 1 to ignore the '?'
		result.query = querystring.parse(urlQueryString);
		url = url.substr(0, queryParametersStartIndex);
	}

    const patternTokens = pattern.split('/');
    const urlTokens = url.split('/');

    if(urlTokens[urlTokens.length - 1] === '') {
        urlTokens.pop();
    }

    if (patternTokens.length !== urlTokens.length) {
        result.match = false;
    }

    if(patternTokens[patternTokens.length - 1] === '*') {
        result.match = true;
        patternTokens.pop();
    }

    for (let i = 0; i < patternTokens.length && result.match; ++i) {
        if (patternTokens[i].startsWith(':')) {
            result.params[patternTokens[i].substring(1)] = urlTokens[i];
        } else if (patternTokens[i] !== urlTokens[i]) {
            result.match = false;
        }
    }

    return result;
}

function isTruthy(value) {
    return !!value;

}

function methodMatch(pattern, method) {
    if (!pattern || !method) {
        return true;
    }

    return pattern === method;
}

function MiddlewareRegistry() {
    const registeredMiddlewareFunctions = [];

    function use(method, url, fn) {
        method = method ? method.toLowerCase() : undefined;
        registeredMiddlewareFunctions.push({method, url, fn});
    }

    this.getRegisteredMiddlewareFunctions = function() {
        return registeredMiddlewareFunctions;
    }

    this.use = function (...params) {
    let args = [ undefined, undefined, undefined ];

    switch (params.length) {
        case 0:
            throw Error('Use method needs at least one argument.');

        case 1:
            if (typeof params[0] !== 'function') {
                throw Error('If only one argument is provided it must be a function');
            }

            args[2] = params[0];

            break;
        case 2:
            if (typeof params[0] !== 'string' || typeof params[1] !== 'function') {
                throw Error('If two arguments are provided the first one must be a string (url) and the second a function');
            }

            args[1]=params[0];
            args[2]=params[1];

            break;
        default:
            if (typeof params[0] !== 'string' || typeof params[1] !== 'string' || typeof params[2] !== 'function') {
                throw Error('If three or more arguments are provided the first one must be a string (HTTP verb), the second a string (url) and the third a function');
            }

            if (!([ 'get', 'post', 'put', 'delete', 'patch', 'head', 'connect', 'options', 'trace' ].includes(params[0].toLowerCase()))) {
                throw new Error('If three or more arguments are provided the first one must be a HTTP verb but none could be matched');
            }

            args = params;

            break;
        }

        use.apply(this, args);
    };


    /**
     * Starts execution from the first registered middleware function
     * @param {Object} req
     * @param {Object} res
     */
    this.go = function go(req, res) {
        try {
            execute(0, req.method.toLowerCase(), req.url, req, res);
        } catch (e) {
            logger.error(e);
            res.statusCode = 500;
            res.end("Internal server error");
        }
    };

    /**
     * Executes a middleware if it passes the method and url validation and calls the next one when necessary
     * @param index
     * @param method
     * @param url
     * @param params
     */
    function execute(index, method, url, ...params) {
        if (!registeredMiddlewareFunctions[index]) {
            if(index===0){
                logger.error("No handlers registered yet!");
            }
            return;
        }

        const registeredMethod = registeredMiddlewareFunctions[index].method;
        const registeredUrl = registeredMiddlewareFunctions[index].url;
        const fn = registeredMiddlewareFunctions[index].fn;

        if (!methodMatch(registeredMethod, method)) {
            execute(++index, method, url, ...params);
            return;
        }

        if (isTruthy(registeredUrl)) {
            const urlMatch = matchUrl(registeredUrl, url);

            if (!urlMatch.match) {
                execute(++index, method, url, ...params);
                return;
            }

            if (params[0]) {
                params[0].params = urlMatch.params;
                params[0].query  = urlMatch.query;
            }
        }

        let counter = 0;

        fn(...params, (err) => {
            counter++;
            if (counter > 1) {
                logger.warn('You called next multiple times, only the first one will be executed');
                return;
            }

            if (err) {
                logger.error(err);
                return;
            }

            execute(++index, method, url, ...params);
        });
    }
}

module.exports = MiddlewareRegistry;

},{"querystring":false}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/apihub/libs/http-wrapper/src/classes/Router.js":[function(require,module,exports){
function Router(server) {
    this.use = function use(url, callback) {
        callback(serverWrapper(url, server));
    };
}

function serverWrapper(baseUrl, server) {
    if (baseUrl.endsWith('/')) {
        baseUrl = baseUrl.substring(0, baseUrl.length - 1);
    }

    return {
        use(url, reqResolver) {
            server.use(baseUrl + url, reqResolver);
        },
        get(url, reqResolver) {
            server.get(baseUrl + url, reqResolver);
        },
        post(url, reqResolver) {
            server.post(baseUrl + url, reqResolver);
        },
        put(url, reqResolver) {
            server.put(baseUrl + url, reqResolver);
        },
        delete(url, reqResolver) {
            server.delete(baseUrl + url, reqResolver);
        },
        options(url, reqResolver) {
            server.options(baseUrl + url, reqResolver);
        }
    };
}

module.exports = Router;

},{}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/apihub/libs/http-wrapper/src/classes/Server.js":[function(require,module,exports){
const MiddlewareRegistry = require('./MiddlewareRegistry');
const http = require('http');
const https = require('https');


function Server(sslOptions) {
    const middleware = new MiddlewareRegistry();
    const server = _initServer(sslOptions);


    this.use = function use(url, callback) {
        //TODO: find a better way
        if (arguments.length >= 2) {
            middleware.use(url, callback);
        } else if (arguments.length === 1) {
            callback = url;
            middleware.use(callback);
        }

    };

    this.get = function getReq(reqUrl, reqResolver) {
        middleware.use("GET", reqUrl, reqResolver);
    };

    this.post = function postReq(reqUrl, reqResolver) {
        middleware.use("POST", reqUrl, reqResolver);
    };

    this.put = function putReq(reqUrl, reqResolver) {
        middleware.use("PUT", reqUrl, reqResolver);
    };

    this.delete = function deleteReq(reqUrl, reqResolver) {
        middleware.use("DELETE", reqUrl, reqResolver);
    };

    this.options = function optionsReq(reqUrl, reqResolver) {
        middleware.use("OPTIONS", reqUrl, reqResolver);
    };

    this.head = function getReq(reqUrl, reqResolver) {
        middleware.use("HEAD", reqUrl, reqResolver);
    };

    this.getRegisteredMiddlewareFunctions = middleware.getRegisteredMiddlewareFunctions;

    this.makeLocalRequest = function (method,path, body,headers, callback) {
        if (typeof headers === "function") {
            callback = headers;
            headers = undefined;
        }

        if (typeof body === "function") {
            callback = body;
            headers = undefined;
            body = undefined;
        }

        const protocol =  require(this.protocol);

        const options = {
            hostname : '127.0.0.1',
            port : server.address().port,
            path,
            method,
            headers
        };

        let timer = setTimeout(()=>{
            let error = new Error("Forced timeout for local request");
            error.rootCause = "network";
            let cb = callback;
            callback = ()=>{
                console.warn("Canceled request still got a result");
            };
            cb(error);
        }, 1*60*1000)//after one minute

        const req = protocol.request(options, response => {
            if(timer){
                clearTimeout(timer);
                timer = undefined;
            }

            if (response.statusCode < 200 || response.statusCode >= 300) {
                let err = new Error("Failed to execute command. StatusCode " + response.statusCode);
                err.httpCode = response.statusCode;
                return callback(err);
            }
            let data = [];
            response.on('data', chunk => {
                data.push(chunk);
            });

            response.on('end', () => {
                try {
                    const bodyContent = $$.Buffer.concat(data).toString();
                    //console.log('resolve will be called. bodyContent received : ', bodyContent);
                    return callback(undefined,bodyContent);
                } catch (err) {
                    return callback(err);
                }
            });
        });

        req.on('error', err => {
            return callback(err);
        });

        if(body) {
            req.write(body);
        }
        req.end();
    };

    this.makeLocalRequestAsync = async function(method, path, body, headers) {
        try {
            const makeLocalRequest = $$.promisify(this.makeLocalRequest.bind(this));
            let response = await makeLocalRequest(method, path, body, headers);

            if (response) {
                try {
                    response = JSON.parse(response);
                } catch (error) {
                    // the response isn't a JSON so we keep it as it is
                }
            }

            return response;
        } catch (error) {
            // console.warn(`Failed to call ${method} on '${path}'`, error);
            throw error;
        }
    }

    /* INTERNAL METHODS */

    function _initServer(sslConfig) {
        let server;
        if (sslConfig) {
             server = https.createServer(sslConfig, middleware.go);
             server.protocol = "https";
        } else {
            server = http.createServer(middleware.go);
            server.protocol = "http";
        }

        return server;
    }

    return new Proxy(this, {
       get(target, prop, receiver) {
           if(typeof target[prop] !== "undefined") {
               return target[prop];
           }

           if(typeof server[prop] === "function") {
               return function(...args) {
                   server[prop](...args);
               }
           } else {
               return server[prop];
           }
       },
        set(target, prop, value){
           if(server.hasOwnProperty(prop)){
               server[prop] = value;
               return true;
           }
           target[prop]=value;
           return true;
        }
    });
}

module.exports = Server;
},{"./MiddlewareRegistry":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/apihub/libs/http-wrapper/src/classes/MiddlewareRegistry.js","http":false,"https":false}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/apihub/libs/http-wrapper/src/httpUtils.js":[function(require,module,exports){
const logger = $$.getLogger("http-wrapper", "apihub/libs");

function setDataHandler(request, callback) {
    let bodyContent = '';

    request.on('data', function (dataChunk) {
        bodyContent += dataChunk;
    });

    request.on('end', function () {
        callback(undefined, bodyContent);
    });

    request.on('error', callback);
}

function setDataHandlerMiddleware(request, response, next) {
    if (request.headers['content-type'] !== 'application/octet-stream') {
        setDataHandler(request, function (error, bodyContent) {
            request.body = bodyContent;
            next(error);
        });
    } else {
        return next();
    }
}

function sendErrorResponse(error, response, statusCode) {
    logger.error(error);
    response.statusCode = statusCode;
    response.end();
}

function bodyParser(req, res, next) {
    let bodyContent = '';

    req.on('data', function (dataChunk) {
        bodyContent += dataChunk;
    });

    req.on('end', function () {
        req.body = bodyContent;
        next();
    });

    req.on('error', function (err) {
        next(err);
    });
}

function serveStaticFile(baseFolder, ignorePath) {
    return function (req, res) {
        const fs = require('fs');
        const path = require("swarmutils").path;

        const url = req.url.substring(ignorePath.length);
        const filePath = path.join(baseFolder, url);
        fs.stat(filePath, (err) => {
            if (err) {
                res.statusCode = 404;
                res.end();
                return;
            }

            if (url.endsWith('.html')) {
                res.contentType = 'text/html';
            } else if (url.endsWith('.css')) {
                res.contentType = 'text/css';
            } else if (url.endsWith('.js')) {
                res.contentType = 'text/javascript';
            }

            const fileStream = fs.createReadStream(filePath);
            fileStream.pipe(res);

        });
    };
}

module.exports = {setDataHandler, setDataHandlerMiddleware, sendErrorResponse, bodyParser, serveStaticFile};

},{"fs":false,"swarmutils":"swarmutils"}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/apihub/libs/http-wrapper/src/index.js":[function(require,module,exports){
const Client = require('./classes/Client');
const Server = require('./classes/Server');
const httpUtils = require('./httpUtils');
const Router = require('./classes/Router');

module.exports = {Server, Client, httpUtils, Router};


},{"./classes/Client":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/apihub/libs/http-wrapper/src/classes/Client.js","./classes/Router":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/apihub/libs/http-wrapper/src/classes/Router.js","./classes/Server":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/apihub/libs/http-wrapper/src/classes/Server.js","./httpUtils":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/apihub/libs/http-wrapper/src/httpUtils.js"}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/apihub/middlewares/SimpleLock/index.js":[function(require,module,exports){
const fsname = "fs";
const fs = require(fsname);
const pathname = "path";
const path = require(pathname);
const logger = $$.getLogger("SimpleLock", "apihub/logger");

const STORAGE = "external-volume/locks";

module.exports = function (server) {

    const storage = path.join(server.rootFolder, STORAGE);
    let fileStructureEnsured = false;
    function ensureFolder(callback){
        if(fileStructureEnsured){
            return callback();
        }
        fs.mkdir(storage, {recursive: true}, (err)=>{
            if(!err){
                fileStructureEnsured = true;
                return callback();
            }
            logger.error("Failed to ensure folder structure for locks", err);
            callback(err);
        });
    }

    function getLockFolderPath(id){
        const crypto = require("opendsu").loadApi("crypto");
        let name = crypto.encodeBase58(id).toString();

        return path.join(storage, name);
    }

    function getLockFilePath(id){
        return path.join(getLockFolderPath(id), "lock");
    }

    function getLockData(id, callback){
        ensureFolder((err)=>{
            if(err){
                return callback(err);
            }

            fs.readFile(getLockFilePath(id), (err, lockData)=>{
                if(err){
                    if(err.code === "ENOENT"){
                        return callback(undefined, {});
                    }
                    return callback(err);
                }
                try{
                    lockData = JSON.parse(lockData.toString());
                }catch(err){
                    return callback(undefined, {});
                }
                return callback(undefined, lockData);
            });
        });
    }

    function cleanLockFiles(id, callback){
        fs.rm(getLockFolderPath(id), { recursive: true, force: true }, (err)=>{
            if(err){
                if(err.code === "ENOENT"){
                    return callback(undefined);
                }
                return callback(err);
            }
            return callback(undefined);
        });
    }

    function checkIfLockExists(id, callback){
        getLockData(id, (err, lockData)=>{
            if(err){
                return callback(err);
            }
            logger.debug("lockData.expire", lockData.expire, Date.now(), Number(lockData.expire) < Date.now());
            if(!lockData.expire || Number(lockData.expire) < Date.now()){
                return cleanLockFiles(id, (err)=> {
                    if (err) {
                        return callback(err);
                    }
                    return callback(undefined, false);
                });
            }

            logger.debug("cleaning lock files, time to expire", Number(lockData.expire) < Date.now());
            logger.debug("cleaning lock files", lockData);
            return callback(undefined, true);

        });
    }

    function constructLockData(secret, period){
        return {expire: Date.now()+Number(period), secret};
    }

    function putLock(id, secret, period, callback){
        checkIfLockExists(id, (err, locked)=>{
            if(err){
                return callback(err);
            }
            if(locked){
                return callback(undefined, false);
            }

            fs.mkdir(getLockFolderPath(id), {recursive: true}, (err)=>{
                if(err){
                    logger.error("Failed to write lock", err);
                    return callback(err);
                }
                fs.writeFile(getLockFilePath(id), JSON.stringify(constructLockData(secret, period)), (err)=>{
                    if(err){
                        logger.error("Failed to write lock", err);
                        return callback(err);
                    }
                    callback(undefined, true);
                });
            });
        });
    }

    function removeLock(id, secret, callback){
        getLockData(id, (err, lockData)=>{
            if(err){
                return callback(err);
            }
            if(lockData && lockData.secret === secret){
                return fs.rm(getLockFilePath(id), (err)=>{
                    if(err){
                        logger.error("Failed to delete lock", err);
                        return callback(err);
                    }
                    callback(undefined, true);
                });
            }
            return callback(undefined, false);
        });
    }

    server.get("/lock", (req, res) => {
        let {id, secret, period} = req.query;
        if(!id || !secret || !period){
            res.statusCode = 400;
            res.end();
            return;
        }

        putLock(id, secret, period, (err, success)=>{
            if(err){
                res.statusCode = 500;
                res.end();
                return;
            }
            if(success){
                res.statusCode = 200;
                res.end();
                return;
            }
            res.statusCode = 409;
            res.end();
        });
    });

    server.get("/unlock", (req, res) => {
        let {id, secret} = req.query;
        if(!id || !secret){
            res.statusCode = 400;
            res.end();
            return;
        }
        removeLock(id, secret, (err, result)=>{
            if(err){
                res.statusCode = 500;
                res.end();
                return;
            }
            if(result){
                res.statusCode = 200;
                res.end();
                return;
            }
            res.statusCode = 404;
            res.end();
            return;
        });
    });
}
},{"opendsu":"opendsu"}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/apihub/middlewares/apiKeyAuth/index.js":[function(require,module,exports){
function APIKeyAuth(server) {
    const SecretsService = require("../../components/secrets/SecretsService");
    let secretServiceInstance;
    const utils = require("../../utils/cookie-utils.js")

    const authorizationHeaderContainsAValidAPIKey = async (req) => {
        const apiKey = req.headers["x-api-key"];
        if (!apiKey) {
            return false;
        }

        return await secretServiceInstance.validateAPIKey(apiKey);
    }

    server.use(async (req, res, next) => {
        if (!secretServiceInstance) {
            secretServiceInstance = await SecretsService.getSecretsServiceInstanceAsync(server.rootFolder);
        }

        if (req.skipSSO) {
            delete req.skipSSO;
        }

        if(req.skipClientCredentialsOauth){
            delete req.skipClientCredentialsOauth;
        }

        if (await authorizationHeaderContainsAValidAPIKey(req)) {
            req.skipSSO = true;
            req.skipClientCredentialsOauth = true;
            return next();
        }

        const {apiKey} = utils.parseCookies(req.headers.cookie);

        if(!apiKey){
            return next();
        }

        if(await secretServiceInstance.validateAPIKey(apiKey)){
            req.skipSSO = true;
            req.skipClientCredentialsOauth = true;
            return next();
        }

        res.statusCode = 403;
        res.end("Forbidden");
    });

}

module.exports = APIKeyAuth;
},{"../../components/secrets/SecretsService":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/apihub/components/secrets/SecretsService.js","../../utils/cookie-utils.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/apihub/utils/cookie-utils.js"}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/apihub/middlewares/authorisation/index.js":[function(require,module,exports){
const openDSU = require("opendsu");
const crypto = openDSU.loadApi("crypto");

const {sendUnauthorizedResponse} = require("../../utils/middlewares");

function Authorisation(server) {
  const logger = $$.getLogger("Authorisation", "apihub/authorisation");

  logger.debug(`Registering Authorisation middleware`);

  const config = require("../../config");
  const skipJWTAuthorisation = config.getConfig("skipJWTAuthorisation");

  const urlsToSkip = skipJWTAuthorisation && Array.isArray(skipJWTAuthorisation) ? skipJWTAuthorisation : [];

  server.use(function (req, res, next) {
    let { url } = req;
    let jwt = req.headers['authorization'];

    const canSkipJWTAuthorisation = urlsToSkip.some((urlToSkip) => url.indexOf(urlToSkip) === 0);
    if (url === "/" || canSkipJWTAuthorisation) {
      next();
      return;
    }

    if (!config.getConfig("enableLocalhostAuthorization") && req.headers.host.indexOf("localhost") === 0) {
      next();
      return;
    }

    if (!jwt) {
      return sendUnauthorizedResponse(req, res, "Missing required Authorization header");
    }

    config.getTokenIssuers((err, tokenIssuers) => {
      if (err) {
        return sendUnauthorizedResponse(req, res, "error while getting token issuers", err);
      }

      jwt = jwt.replace("Bearer ", "");
      crypto.verifyAuthToken(jwt, tokenIssuers, (error, isValid) => {
        if (error || !isValid) {
          return sendUnauthorizedResponse(req, res, "JWT could not be verified", error);
        }

        next();
      });
    });
  });
}

module.exports = Authorisation;

},{"../../config":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/apihub/config/index.js","../../utils/middlewares":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/apihub/utils/middlewares/index.js","opendsu":"opendsu"}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/apihub/middlewares/clientCredentialsOauth/index.js":[function(require,module,exports){
function ClientCredentialsOauth(server) {
    const config = require("../../config");
    const jwksEndpoint = config.getConfig("oauthJWKSEndpoint");
    const util = require("../oauth/lib/util");

    server.use(async (req, res, next) => {
        if (req.skipClientCredentialsOauth) {
            return next();
        }

        if (!req.headers.authorization) {
            return next();
        }

        const token = req.headers.authorization.split(" ")[1];
        util.validateAccessToken(jwksEndpoint, token, (err) => {
            if (err) {
                res.statusCode = 401;
                return res.end("Invalid token");
            }

            req.headers["user-id"] = util.getSSODetectedIdFromPayload(util.parseAccessToken(token).payload);
            req.skipSSO = true
            next();
        })
    });
}


module.exports = ClientCredentialsOauth;
},{"../../config":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/apihub/config/index.js","../oauth/lib/util":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/apihub/middlewares/oauth/lib/util.js"}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/apihub/middlewares/fixedUrls/index.js":[function(require,module,exports){
(function (Buffer){(function (){
const TAG_FIXED_URL_REQUEST = "fixedurlrequest";
const INTERVAL_TIME = 1 * 1000; //ms aka 1 sec
const DEFAULT_MAX_AGE = 10; //seconds aka 10 sec
const TASKS_TABLE = "tasks";
const HISTORY_TABLE = "history";
const DATABASE = "FixedUrls.db";

const enclaveAPI = require("opendsu").loadAPI("enclave");
const fsname = "fs";
const fs = require(fsname);
const pathname = "path";
const path = require(pathname);
const logger = $$.getLogger("FixedUrl", "apihub/logger");

module.exports = function (server) {

    const workingDir = path.join(server.rootFolder, "external-volume", "fixed-urls");
    const storage = path.join(workingDir, "storage");
    let lightDBEnclaveClient = enclaveAPI.initialiseLightDBEnclave(DATABASE);

    let watchedUrls = [];
    //we inject a helper function that can be called by different components or middleware to signal that their requests
    // can be watched by us
    server.allowFixedUrl = function (url) {
        if (!url) {
            throw new Error("Expected an Array of strings or single string representing url prefix");
        }
        if (Array.isArray(url)) {
            watchedUrls = watchedUrls.concat(url);
            return;
        }
        watchedUrls.push(url);
    }

    function ensureURLUniformity(req) {
        let base = "https://non.relevant.url.com";
        //we add the base to get a valid url
        let url = typeof req === "object" ? req.url : req;
        let converter = new URL(base + url);
        //we ensure that the searchParams are sorted
        converter.searchParams.sort();
        //we remove our artificial base
        let newString = converter.toString().replaceAll(base, "");
        return newString;
    }

    function respond(res, content, statusCode) {
        if (statusCode) {
            res.statusCode = statusCode;
            logger.audit(0x102, `Responding to url ${res.req.url} with status code ${statusCode}`);
        } else {
            logger.audit(0x101, `Successful serving url ${res.req.url}`);
            res.statusCode = 200;
        }
        const fixedURLExpiry = server.config.fixedURLExpiry || DEFAULT_MAX_AGE;
        res.setHeader("cache-control", `max-age=${fixedURLExpiry}`);
        res.write(content);
        res.end();
    }

    function getIdentifier(fixedUrl) {
        return Buffer.from(fixedUrl).toString("base64url");
    }

    const indexer = {
        getFileName: function (fixedUrl) {
            return path.join(storage, getIdentifier(fixedUrl));
        },
        persist: function (fixedUrl, content, callback) {
            logger.debug("Persisting url", fixedUrl);
            fs.writeFile(indexer.getFileName(fixedUrl), content, callback);
        },
        get: function (fixedUrl, callback) {
            logger.debug("Reading url", fixedUrl);
            fs.readFile(indexer.getFileName(fixedUrl), callback);
        },
        clean: function (fixedUrl, callback) {
            logger.debug("Cleaning url", fixedUrl);
            fs.unlink(indexer.getFileName(fixedUrl), callback);
        },
        getTimestamp: function (fixedUrl, callback) {
            logger.debug("Reading timestamp for", fixedUrl);
            fs.stat(indexer.getFileName(fixedUrl), {bigint: true}, (err, stats) => {
                if (err) {
                    return callback(err);
                }
                return callback(undefined, stats.mtimeMs);
            });
        }
    };

    const taskRegistry = {
        inProgress: {},
        createModel: function (fixedUrl) {
            return {url: fixedUrl, pk: getIdentifier(fixedUrl)};
        },
        register: function (task, callback) {
            let newRecord = taskRegistry.createModel(task);
            newRecord.__fallbackToInsert = true
            return lightDBEnclaveClient.updateRecord($$.SYSTEM_IDENTIFIER, HISTORY_TABLE, newRecord.pk, newRecord,  callback);
        },
        add: function (task, callback) {
            let newRecord = taskRegistry.createModel(task);
            lightDBEnclaveClient.getRecord($$.SYSTEM_IDENTIFIER, TASKS_TABLE, newRecord.pk, function (err, record) {
                if (err || !record) {
                    return lightDBEnclaveClient.insertRecord($$.SYSTEM_IDENTIFIER, TASKS_TABLE, newRecord.pk, newRecord, (insertError)=>{
                        //if we fail... could be that the task is ready register by another request due to concurrency
                        //we do another getRecord and if fails we return the original insert record error
                        if(insertError){
                            //we set the counter to 2 just in case there is a task with a counter value that we don't know,
                            // and we hope to have enough invalidation of the task to don't have garbage
                            newRecord.counter = 2;
                            newRecord.__fallbackToInsert = true;
                            return lightDBEnclaveClient.updateRecord($$.SYSTEM_IDENTIFIER, TASKS_TABLE, newRecord.pk, newRecord, callback);
                        }
                        callback(undefined);
                    });
                }
                if (!record.counter) {
                    record.counter = 0;
                }
                record.counter++;
                record.__fallbackToInsert = true;
                return lightDBEnclaveClient.updateRecord($$.SYSTEM_IDENTIFIER, TASKS_TABLE, record.pk, record, callback);
            });
        },
        remove: function (task, callback) {
            let toBeRemoved = taskRegistry.createModel(task);
            lightDBEnclaveClient.getRecord($$.SYSTEM_IDENTIFIER, TASKS_TABLE, toBeRemoved.pk, function (err, record) {
                if (err || !record) {
                    return callback(undefined);
                }
                if (record.counter && record.counter > 1) {
                    record.counter = 1;
                    record.__fallbackToInsert = true;
                    return lightDBEnclaveClient.updateRecord($$.SYSTEM_IDENTIFIER, TASKS_TABLE, toBeRemoved.pk, record, callback);
                }

                lightDBEnclaveClient.deleteRecord($$.SYSTEM_IDENTIFIER, TASKS_TABLE, toBeRemoved.pk, callback);
            });
        },
        getOneTask: function (callback) {
            lightDBEnclaveClient.filter($$.SYSTEM_IDENTIFIER, TASKS_TABLE, "__timestamp > 0", "asc", 1, function (err, task) {
                if (err) {
                    return callback(err);
                }
                if (task.length === 0) {
                    return callback(undefined);
                }
                task = task[0];
                if (taskRegistry.inProgress[task.url]) {
                    logger.debug(`${task.url} is in progress.`);
                    //we already have this task in progress, we need to wait
                    return callback(undefined);
                }
                taskRegistry.markInProgress(task.url);
                callback(undefined, task);
            });
        },
        isInProgress: function (task) {
            return !!taskRegistry.inProgress[task];
        },
        isScheduled: function (task, callback) {
            let tobeChecked = taskRegistry.createModel(task);
            lightDBEnclaveClient.getRecord($$.SYSTEM_IDENTIFIER, TASKS_TABLE, tobeChecked.pk, function (err, task) {
                if (err || !task) {
                    return callback(undefined, undefined);
                }
                callback(undefined, task);
            });
        },
        markInProgress: function (task) {
            taskRegistry.inProgress[task] = true;
        },
        markAsDone: function (task, callback) {
            logger.debug(`Marking task ${task} as done`);
            taskRegistry.inProgress[task] = undefined;
            delete taskRegistry.inProgress[task];
            taskRegistry.remove(task, callback);
        },
        isKnown: function (task, callback) {
            let target = taskRegistry.createModel(task);
            lightDBEnclaveClient.getRecord($$.SYSTEM_IDENTIFIER, HISTORY_TABLE, target.pk, callback);
        },
        schedule: function (criteria, callback) {
            if(server.readOnlyModeActive){
                return callback(new Error("FixedURL scheduling is not possible when server is in readOnly mode"));
            }
            lightDBEnclaveClient.filter($$.SYSTEM_IDENTIFIER, HISTORY_TABLE, criteria, function (err, records) {
                if (err) {
                    if (err.code === 404) {
                        return callback();
                    }
                    return callback(err);
                }

                function createTask() {
                    if (records.length === 0) {
                        return callback(undefined);
                    }

                    let record = records.pop();
                    taskRegistry.add(record.url, function (err) {
                        if (err) {
                            return callback(err);
                        }
                        createTask();
                    });
                }

                createTask();
            });
        },
        cancel: function (criteria, callback) {
            lightDBEnclaveClient.filter($$.SYSTEM_IDENTIFIER, HISTORY_TABLE, criteria, async function (err, tasks) {
                if (err) {
                    if (err.code === 404) {
                        return callback();
                    }
                    return callback(err);
                }

                try {
                    let markAsDone = $$.promisify(taskRegistry.markAsDone);
                    let clean = $$.promisify(indexer.clean);
                    for (let task of tasks) {
                        let url = task.url;
                        //by marking it as done the task is removed from pending and lightDBEnclaveClient also
                        await markAsDone(url);
                        try {
                            await clean(url);
                        } catch (err) {
                            //we ignore any errors related to file not found...
                            if (err.code !== "ENOENT") {
                                throw err;
                            }
                        }
                    }
                } catch (err) {
                    return callback(err);
                }

                callback(undefined);
            });
        },
        status: function () {
            if(server.readOnlyModeActive){
                //preventing log noise in readOnly mode
                return ;
            }
            let inProgressCounter = Object.keys(taskRegistry.inProgress);
            logger.debug(`Number of tasks that are in progress: ${inProgressCounter.length ? inProgressCounter.length : 0}`);

            lightDBEnclaveClient.getAllRecords($$.SYSTEM_IDENTIFIER, TASKS_TABLE, (err, scheduledTasks) => {
                if (!err) {
                    logger.debug(`Number of scheduled tasks: ${scheduledTasks ? scheduledTasks.length : 0}`);
                }
            });
            lightDBEnclaveClient.getAllRecords($$.SYSTEM_IDENTIFIER, HISTORY_TABLE, (err, tasks) => {
                if (!err) {
                    logger.debug(`Number of fixed urls: ${tasks ? tasks.length : 0}`);
                }
            });
        },
        httpStatus: async function(req, res){
            let inProgressCounter = Object.keys(taskRegistry.inProgress);
            let status = {};
            try{
                status.inProgress = inProgressCounter.length ? inProgressCounter.length : 0;
                let scheduledTasks = await $$.promisify(lightDBEnclaveClient.getAllRecords)($$.SYSTEM_IDENTIFIER, TASKS_TABLE);
                status.scheduled = scheduledTasks ? scheduledTasks.length : 0;
                let tasks = await $$.promisify(lightDBEnclaveClient.getAllRecords)($$.SYSTEM_IDENTIFIER, HISTORY_TABLE);
                status.total = tasks ? tasks.length : 0;
            }catch(err){
                res.statusCode = 500;
                res.end(`Failed to generate status info ${err.message}`);
            }
            res.statusCode = 200;
            res.end(JSON.stringify(status));
        }
    };
    const taskRunner = {
        doItNow: function (task) {
            logger.info("Executing task for url", task.url);
            const fixedUrl = task.url;
            //we need to do the request and save the result into the cache
            let urlBase = `http://127.0.0.1`;
            let url = urlBase;
            if (!fixedUrl.startsWith("/")) {
                url += "/";
            }
            url += fixedUrl;

            //let's create an url object from our string
            let converter = new URL(url);
            //we inject the request identifier
            converter.searchParams.append(TAG_FIXED_URL_REQUEST, "true");
            //this new url will contain our flag that prevents resolving in our middleware
            url = converter.toString().replace(urlBase, "");

            //executing the request

            server.makeLocalRequest("GET", url, "", {}, function (error, result) {
                if (error) {
                    logger.error("caught an error during fetching fixedUrl", error.message, error.code, error);
                    if (error.httpCode && error.httpCode > 300) {
                        //missing data
                        taskRunner.resolvePendingReq(task.url, "", error.httpCode);
                        logger.debug("Cleaning url because of the resolving error", error);
                        indexer.clean(task.url, (err) => {
                            if (err) {
                                if (err.code !== "ENOENT") {
                                    logger.error("Failed to clean url", err);
                                }
                            }
                        });
                        return taskRegistry.markAsDone(task.url, (err) => {
                            if (err) {
                                logger.log("Failed to remove a task that we weren't able to resolve");
                                return;
                            }
                        });
                    }
                    return taskRegistry.markAsDone(task.url, (err) => {
                        if (err) {
                            logger.log("Failed to remove a task that we weren't able to resolve");
                            return;
                        }
                        //if failed we add the task back to the end of the queue...
                        setTimeout(() => {
                            taskRegistry.add(task.url, (err) => {
                                if (err) {
                                    logger.log("Failed to reschedule the task", task.url, err.message, err.code, err);
                                }
                            });
                        }, 100);
                    })
                }
                //got result... we need to store it for future requests, and we need to resolve any pending request waiting for it
                if (result) {
                    //let's resolve as fast as possible any pending request for the current task
                    taskRunner.resolvePendingReq(task.url, result);

                    if (!taskRegistry.isInProgress(task.url)) {
                        logger.info("Looks that somebody canceled the task before we were able to resolve.");
                        //if somebody canceled the task before we finished the request we stop!
                        return;
                    }

                    indexer.persist(task.url, result, function (err) {
                        if (err) {
                            logger.error("Not able to persist fixed url", task, err);
                        }

                        taskRegistry.markAsDone(task.url, (err) => {
                            if (err) {
                                logger.warn("Failed to mark request as done in lightDBEnclaveClient", task);
                            }
                        });

                        //let's test if we have other tasks that need to be executed...
                        taskRunner.execute();
                    });
                } else {
                    taskRegistry.markAsDone(task.url, (err) => {
                        if (err) {
                            logger.warn("Failed to mark request as done in lightDBEnclaveClient", task);
                        }
                        taskRunner.resolvePendingReq(task.url, result, 204);
                    });
                }
            });
        },
        execute: function () {
            taskRegistry.getOneTask(function (err, task) {
                if (err || !task) {
                    return;
                }

                taskRunner.doItNow(task);
            })
        },
        pendingRequests: {},
        registerReq: function (url, req, res) {
            if (!taskRunner.pendingRequests[url]) {
                taskRunner.pendingRequests[url] = [];
            }
            taskRunner.pendingRequests[url].push({req, res});
        },
        resolvePendingReq: function (url, content, statusCode) {
            let pending = taskRunner.pendingRequests[url];
            if (!pending) {
                return;
            }
            while (pending.length > 0) {
                let delayed = pending.shift();
                try {
                    respond(delayed.res, content, statusCode);
                } catch (err) {
                    //we ignore any errors at this stage... timeouts, client aborts etc.
                }
            }
        },
        status: function () {
            if(server.readOnlyModeActive){
                //preventing log noise in readOnly mode
                return ;
            }
            let pendingReq = Object.keys(taskRunner.pendingRequests);
            let counter = 0;
            for (let pendingUrl of pendingReq) {
                if (taskRunner.pendingRequests[pendingUrl]) {
                    counter += taskRunner.pendingRequests[pendingUrl].length;
                }
            }

            logger.debug(`Number of requests that are in pending: ${counter}`);
            taskRegistry.status();
        }
    };

    if(!server.readOnlyModeActive){
        fs.mkdir(storage, {recursive: true}, (err) => {
            if (err) {
                logger.error("Failed to ensure folder structure due to", err);
            }
            lightDBEnclaveClient.createDatabase(DATABASE, (err) => {
                if (err) {
                    logger.debug("Failed to create database", err.message, err.code, err.rootCause);
                }

                lightDBEnclaveClient.hasWriteAccess($$.SYSTEM_IDENTIFIER, (err, hasAccess) => {
                    if (err) {
                        logger.error("Failed to check if we have write access", err.message, err.code, err.rootCause);
                    }

                    if (hasAccess) {
                        setInterval(taskRunner.execute, INTERVAL_TIME);
                        return;
                    }

                    lightDBEnclaveClient.grantWriteAccess($$.SYSTEM_IDENTIFIER, (err) => {
                        if (err) {
                            logger.error("Failed to grant write access to the enclave", err.message, err.code, err.rootCause);
                        }

                        setInterval(taskRunner.execute, INTERVAL_TIME);
                    })
                })
            })
        });
    }

    server.put("/registerFixedURLs", require("./../../utils/middlewares").bodyReaderMiddleware);
    server.put("/registerFixedURLs", function register(req, res, next) {
        if (!lightDBEnclaveClient) {
            return setTimeout(() => {
                register(req, res, next);
            }, 100);
        }
        let body = req.body;
        try {
            body = JSON.parse(body);
        } catch (err) {
            logger.log(err);
        }

        if (!Array.isArray(body)) {
            body = [body];
        }

        function recursiveRegistry() {
            if (body.length === 0) {
                res.statusCode = 200;
                res.end();
                return;
            }
            let fixedUrl = body.pop();
            taskRegistry.register(fixedUrl, function (err) {
                if (err) {
                    res.statusCode = 500;
                    return res.end(`Failed to register url because: ${err.message}`);
                }
                recursiveRegistry();
            });
        }

        recursiveRegistry();
    });

    server.put("/activateFixedURL", require("./../../utils/middlewares").bodyReaderMiddleware);
    server.put("/activateFixedURL", function activate(req, res, next) {
        if (!lightDBEnclaveClient) {
            return setTimeout(() => {
                activate(req, res, next);
            }, 100);
        }
        taskRegistry.schedule(req.body.toString(), function (err) {
            if (err) {
                logger.log(err);
                res.statusCode = 500;
                return res.end(`Failed to schedule task ${err.message}`);
            }
            res.statusCode = 200;
            res.end();
        });
    });

    server.put("/deactivateFixedURL", require("./../../utils/middlewares").bodyReaderMiddleware);
    server.put("/deactivateFixedURL", function deactivate(req, res, next) {
        if (!lightDBEnclaveClient) {
            return setTimeout(() => {
                deactivate(req, res, next);
            }, 100);
        }
        taskRegistry.cancel(req.body.toString(), function (err) {
            if (err) {
                logger.log(err);
                res.statusCode = 500;
                return res.end(`Failed to cancel task ${err.message}`);
            }
            res.statusCode = 200;
            res.end();
        });
    });

    function getTimestampHandler(req, res, next) {
        if (["HEAD", "GET"].indexOf(req.method) === -1) {
            //not our responsibility... for the moment we resolve only GET methods that have query params...
            return next();
        }
        let possibleFixedUrl = false;
        let url = req.url;

        if (req.method === "GET" && !url.startsWith("/mtime")) {
            //not our responsibility...
            return next();
        }

        if (req.method === "GET") {
            url = url.replace("/mtime", "");
        }

        for (let wUrl of watchedUrls) {
            if (url.startsWith(wUrl)) {
                possibleFixedUrl = true;
            }
        }

        if (!possibleFixedUrl) {
            //not our responsibility
            return next();
        }

        let fixedUrl = ensureURLUniformity(url);
        indexer.getTimestamp(fixedUrl, function (err, timestamp) {
            if (err) {
                //for any errors we try to invalidate any cache
                timestamp = Date.now() - 1000;
            }
            res.setHeader("ETag", timestamp);
            if (req.method === "GET") {
                res.write(timestamp.toString());
            }
            res.statusCode = 200;
            res.end();

        });
    }


    //register a middleware to intercept all the requests
    server.use("*", function (req, res, next) {

        if (req.method !== "GET") {
            //not our responsibility... for the moment we resolve only GET methods that have query params...
            return next();
        }

        let possibleFixedUrl = false;
        for (let url of watchedUrls) {
            if (req.url.startsWith(url)) {
                possibleFixedUrl = true;
            }
        }

        if (!possibleFixedUrl) {
            //not our responsibility
            return next();
        }


        if (req.query && req.query[TAG_FIXED_URL_REQUEST]) {
            //this TAG_FIXED_URL_REQUEST query param is set by our runner, and we should let this request to be executed
            return next();
        }

        //if we reached this line of code means that we need to do our "thing"
        let fixedUrl = ensureURLUniformity(req);
        if (taskRegistry.isInProgress(fixedUrl)) {
            //there is a task for it... let's wait
            return taskRunner.registerReq(fixedUrl, req, res);
        }

        function resolveURL() {
            taskRegistry.isScheduled(fixedUrl, (err, task) => {
                if (task) {
                    logger.debug(`There is a scheduled task for this ${fixedUrl}`);
                    taskRunner.registerReq(fixedUrl, req, res);
                    taskRegistry.markInProgress(fixedUrl);
                    taskRunner.doItNow(task);
                    return;
                }

                taskRegistry.isKnown(fixedUrl, (err, known) => {
                    if (known) {
                        //there is no task in progress for this url... let's test even more...
                        return indexer.get(fixedUrl, (err, content) => {
                            if (err) {
                                logger.warn(`Failed to load content for fixedUrl; highly improbable, check your configurations!`);
                                //no current task and no cache... let's move on to resolving the req
                                return next();
                            }
                            //known fixed url let's respond to the client
                            respond(res, content);
                        });
                    }
                    next();
                });
            });
        }

        taskRegistry.isKnown(fixedUrl, (err, known) => {
            //if reached this point it might be a fixed url that is not known yet, and it should get registered and scheduled for resolving...
            //this case could catch params combinations that are not captured...

            if(server.readOnlyModeActive){
                //this case of readOnlyModeActive needs to be handled carefully in order to prevent any writes possible
                if(known){
                    return indexer.get(fixedUrl, (err, content) => {
                        if (err) {
                            logger.warn(`Failed to load content for fixedUrl; This could happen when the task is not yet resolved by full container`);
                            //no current task and no cache... let's move on to resolving the req
                            return next();
                        }
                        //known fixed url let's respond to the client
                        respond(res, content);
                    });
                }else{
                    return next();
                }
            }

            if (!known) {
                return taskRegistry.register(fixedUrl, (err) => {
                    if (err) {
                        //this should not happen... but even if it happens we log and go on with the execution
                        console.error(err);
                    }
                    taskRegistry.add(fixedUrl, (err) => {
                        if (err) {
                            //this should not happen... but even if it happens we log and go on with the execution
                            console.error(err);
                        }
                        resolveURL();
                    });
                });
            }
            resolveURL();
        });
    });
    server.use("*", getTimestampHandler);
    server.get("/mtime/*", getTimestampHandler);
    server.get("/statusFixedURL", taskRegistry.httpStatus);
}
}).call(this)}).call(this,require("buffer").Buffer)

},{"./../../utils/middlewares":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/apihub/utils/middlewares/index.js","buffer":false,"opendsu":"opendsu"}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/apihub/middlewares/genericErrorMiddleware/index.js":[function(require,module,exports){
function setupGenericErrorMiddleware(server) {
    const constants = require("./../../moduleConstants");
    const logger = $$.getLogger("setupGenericErrorMiddleware", "apihub/genericErrorMiddleware");

	server.use(function (req, res, next) {
        const capturedWrites = [];

        const originalResWrite = res.write;
        const originalResEnd = res.end;

        res.write = function(chunk, encoding, callback){
            if(typeof callback === "function" || typeof encoding === "function"){
                logger.debug(`${constants.LOG_IDENTIFIER}`,
                    "Generic Error Middleware is running and has detected that a callback was used for response.write method call.",
                    "Be aware that this middleware can generate undesired behaviour in this case.", new Error());
            }
            capturedWrites.push([chunk, encoding, callback]);
        }

        res.end = function(data, encoding, callback){
            if(res.statusCode < 400){
                for(let i=0; i<capturedWrites.length; i++){
                    originalResWrite.call(res, ...capturedWrites[i]);
                }
                originalResEnd.call(res, data, encoding, callback);
            }else{
                if(req.log){
                    for(let i=0; i<capturedWrites.length; i++){
                        req.log("Generic Error Middleware prevented message to be sent on response.write", ...capturedWrites[i]);
                    }
                    if(data){
                        req.log("Generic Error Middleware prevented message to be sent on response.end", data);
                    }
                }
                originalResWrite.call(res, "Error");
                originalResEnd.call(res, undefined, encoding, callback);
            }
        }

		next();
	});

    logger.debug(`${constants.LOG_IDENTIFIER}`, "generic error middleware was loaded. This middleware will prevent any error to leak when sending a >=400 response to the client.");
}

module.exports = setupGenericErrorMiddleware;

},{"./../../moduleConstants":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/apihub/moduleConstants.js"}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/apihub/middlewares/logger/index.js":[function(require,module,exports){
function Logger(server) {
    const LOG_IDENTIFIER = "Logger";
    const logger = $$.getLogger(LOG_IDENTIFIER, "apihub/logger");
    logger.debug(`Registering Logger middleware`);

    const getRequestDuration = (start) => {
        const diff = process.hrtime(start);
        return (diff[0] * 1e9 + diff[1]) / 1e6;
    };

    let ms = 10000;
    let longRequests = [];
    const config = server.config.componentsConfig;
    if (config.requestLogger) {
        if (config.requestLogger.statusLogInterval) {
            ms = config.requestLogger.statusLogInterval;
            logger.debug(`Requests that will take longer than ${ms} ms will be logged as in progress`);
        }

        if (config.requestLogger.longRequests) {
            if (!Array.isArray(config.requestLogger.longRequests)) {
                logger.error("longRequests config is expected to be an Array of strings! Check config to make it apply!");
            } else {
                longRequests = config.requestLogger.longRequests;
                logger.debug("the following filter will be used to acknowledge longer time resolve urls", JSON.stringify(longRequests));
            }
        }
    }

    server.use(function (req, res, next) {
        const {
            method,
            url
        } = req;

        const start = process.hrtime();

        let timer;
        let quickReq = true;
        for(let longReq of longRequests){
            if(url.indexOf(longReq)!==-1){
                quickReq = false;
            }
        }

        if(quickReq){
            //we don't want to log requests that have a big time to leave like (TLL) in case of http poll requests
            timer = setInterval(() => {
                logger.info(`Request progress ${method}:${url}`);
            }, ms);
        }

        let durationInMilliseconds;

        //let's add a safety net and log
        res.on('error', (error) => {
            if (error) {
                //may be redundant to check the argument but still ...
                logger.info(`Error while sending response for ${method}:${url}`, error.code, error.message);
            }
        });

        req.on("error", (err)=>{
            //clearing the timer
            if (timer) {
                clearInterval(timer);
            }
            logger.info(`Request closed by client`, `${method}:${url}`, err?err.message:"", err);
        });

        res.on('finish', () => {
            //clearing the timer
            if (timer) {
                clearInterval(timer);
            }

            const {statusCode} = res;
            durationInMilliseconds = getRequestDuration(start);
            let log = `${method}:${url} ${statusCode} ${durationInMilliseconds.toLocaleString()}ms`;
            logger.log(log);
            if (req.getLogs) {
                const visualIndex = "\t";
                const requestLogs = req.getLogs();
                if (requestLogs.length > 0) {
                    logger.debug("Request logs:");
                    for (let i = 0; i < requestLogs.length; i++) {
                        if (Array.isArray(requestLogs)) {
                            logger.log(visualIndex, ...requestLogs[i]);
                        } else {
                            logger.log(visualIndex, requestLogs[i]);
                        }
                    }
                    logger.log("\n");
                }
            }
        });

        next();
    });
}

module.exports = Logger;

},{}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/apihub/middlewares/oauth/index.js":[function(require,module,exports){
const config = require("../../config");

const serverAuthentication = config.getConfig("serverAuthentication")
if (serverAuthentication) {
    module.exports = require("./lib/OauthMiddleware");
} else {
    module.exports = require("./lib/AccessTokenValidator");
}


},{"../../config":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/apihub/config/index.js","./lib/AccessTokenValidator":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/apihub/middlewares/oauth/lib/AccessTokenValidator.js","./lib/OauthMiddleware":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/apihub/middlewares/oauth/lib/OauthMiddleware.js"}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/apihub/middlewares/oauth/lib/AccessTokenValidator.js":[function(require,module,exports){
const {sendUnauthorizedResponse} = require("../../../utils/middlewares");
const util = require("./util");
const config = require("../../../config");

function AccessTokenValidator(server) {
    const logger = $$.getLogger("AccessTokenValidator", "apihub/oauth");

    logger.debug(`Registering AccessTokenValidator middleware`);
    const urlsToSkip = util.getUrlsToSkip();

    server.use(function (req, res, next) {
        let {url} = req;
        let cookies = util.parseCookies(req.headers.cookie);
        const authorisation = cookies.authorization;
        const canSkipOAuth = urlsToSkip.some((urlToSkip) => url.indexOf(urlToSkip) === 0);
        if (url === "/" || canSkipOAuth) {
            next();
            return;
        }

        if (!config.getConfig("enableLocalhostAuthorization") && req.headers.host.indexOf("localhost") === 0) {
            next();
            return;
        }

        if (!authorisation) {
            res.writeHead(301, {Location: "/"});
            res.end();
            return;
        }

        const jwksEndpoint = config.getConfig("oauthJWKSEndpoint");
        util.validateAccessToken(jwksEndpoint, authorisation,  (err) => {
            if (err) {
                return sendUnauthorizedResponse(req, res, "Failed to validate token");
            }

            next();
        })
    });
}

module.exports = AccessTokenValidator;
},{"../../../config":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/apihub/config/index.js","../../../utils/middlewares":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/apihub/utils/middlewares/index.js","./util":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/apihub/middlewares/oauth/lib/util.js"}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/apihub/middlewares/oauth/lib/OauthMiddleware.js":[function(require,module,exports){
const util = require("./util");
const urlModule = require("url");
const {httpUtils} = require("../../../libs/http-wrapper");
const {printDebugLog} = require("./util");

function OAuthMiddleware(server) {
    const logger = $$.getLogger("OAuthMiddleware", "apihub/oauth");

    function sendUnauthorizedResponse(req, res, reason, error) {
        logger.error(`[${req.method}] ${req.url} blocked: ${reason}`, error);
        res.statusCode = 403;
        const loginUrl = oauthConfig.client.postLogoutRedirectUrl;
        const returnHtml = "<html>" +
            `<body>We apologize for the inconvenience. The automated login attempt was unsuccessful. 
                    You can either <a href="${loginUrl}">retry the login</a> or if the issue persists, please restart your browser.
                    <script>sessionStorage.setItem('initialURL', window.location.href);</script>
                </body>` +
            "</html>";
        res.end(returnHtml);
    }

    logger.debug(`Registering OAuthMiddleware`);
    const staticContentIdentifiers = ["text/html", "application/xhtml+xml", "application/xml"];
    const config = require("../../../config");
    const oauthConfig = config.getConfig("oauthConfig");
    const path = require("path");
    const ENCRYPTION_KEYS_LOCATION = oauthConfig.encryptionKeysLocation || path.join(server.rootFolder, "external-volume", "encryption-keys");
    let urlsToSkip = util.getUrlsToSkip();
    let skippedUrlsForSessionTimeout = ["/mq/"]

    server.whitelistUrlForSessionTimeout = (url) => {
        if(url.startsWith("/")){
            skippedUrlsForSessionTimeout.push(url);
        } else {
            throw new Error(`Whitelisting invalid URL for session timeout: ${url}. It should start with /`);
        }
    };

    server.whitelistUrl = (url) => {
        if(url.startsWith("/")){
            urlsToSkip.push(url);
        } else {
            throw new Error(`Whitelisting invalid URL: ${url}. It should start with /`);
        }
    };

    const WebClient = require("./WebClient");
    const webClient = new WebClient(oauthConfig);
    const errorMessages = require("./errorMessages");

    const defaultUrlsToSkip = ["/installation-details", "/ready-probe"];
    urlsToSkip = urlsToSkip.concat(defaultUrlsToSkip);
    const defaultActionsToSkip = ["brick-exists", "get-all-versions", "get-last-version", "get-brick", "credential"];

    //we let KeyManager to boot and prepare ...
    util.initializeKeyManager(ENCRYPTION_KEYS_LOCATION, oauthConfig.keyTTL);

    function redirectToLogin(res) {
        res.statusCode = 200;
        res.write(`<html><body><script>sessionStorage.setItem('initialURL', window.location.href); window.location.href = "/login";</script></body></html>`);
        res.end();
    }

    function setSSODetectedId(ssoDetectedId, SSOUserId, accessTokenCookie, res) {
        res.writeHead(200, {'Content-Type': 'text/html'});
        return res.end(`<script>
                localStorage.setItem('SSODetectedId', '${ssoDetectedId}');
                localStorage.setItem('SSOUserId', '${SSOUserId}');
                localStorage.setItem('accessTokenCookie', '${accessTokenCookie}');
                localStorage.setItem('logoutUrl', '${oauthConfig.client.logoutUrl}');
                localStorage.setItem('postLogoutRedirectUrl', '${oauthConfig.client.postLogoutRedirectUrl}');
                window.location.href = '/redirect.html';
                </script>`);
    }

    function startAuthFlow(req, res) {
        util.printDebugLog("Starting authentication flow");
        const loginContext = webClient.getLoginInfo(oauthConfig);
        util.printDebugLog("Login info", JSON.stringify(loginContext));
        util.encryptLoginInfo(loginContext, (err, encryptedContext) => {
            if (err) {
                return sendUnauthorizedResponse(req, res, "Unable to encrypt login info");
            }
            let cookies = [`loginContextCookie=${encryptedContext}; Path=/; HttpOnly; Secure`];
            logger.info("SSO redirect (http 301) triggered for:", req.url);
            res.writeHead(301, {
                Location: loginContext.redirect,
                "Set-Cookie": cookies,
                "Cache-Control": "no-store, no-cache, must-revalidate, post-check=0, pre-check=0"
            });
            res.end();
        })
    }

    function loginCallbackRoute(req, res) {
        util.printDebugLog("Entered login callback");
        let cbUrl = req.url;
        let query = urlModule.parse(cbUrl, true).query;
        const {loginContextCookie} = util.parseCookies(req.headers.cookie);
        if (!loginContextCookie) {
            util.printDebugLog("Logout because loginContextCookie is missing.")
            return logout(req, res);
        }
        util.decryptLoginInfo(loginContextCookie, (err, loginContext) => {
            if (err) {
                return sendUnauthorizedResponse(req, res, "Unable to decrypt login info", err);
            }

            if (Date.now() - loginContext.date > oauthConfig.sessionTimeout) {
                util.printDebugLog("Logout because loginContextCookie is expired.")
                return logout(req, res);
            }

            const queryCode = query['code'];
            const queryState = query['state'];
            const context = {
                clientState: loginContext.state,
                clientFingerprint: loginContext.fingerprint,
                clientCode: loginContext.codeVerifier,
                queryCode,
                queryState,
                origin: req.headers.host,
            };

            util.printDebugLog("Requesting token set");
            util.printDebugLog("context", JSON.stringify(context));
            webClient.loginCallback(context, (err, tokenSet) => {
                if (err) {
                    return sendUnauthorizedResponse(req, res, "Unable to get token set", err);
                }

                util.printDebugLog("Access token", tokenSet.access_token);
                util.printDebugLog("Id token", tokenSet.id_token);
                util.encryptTokenSet(tokenSet, (err, encryptedTokenSet) => {
                    if (err) {
                        return sendUnauthorizedResponse(req, res, "Unable to encrypt access token", err);
                    }
                    util.getSSODetectedIdAndUserId(tokenSet, (err, {SSODetectedId, SSOUserId}) => {
                        if (err) {
                            util.printDebugLog("Unable to get SSODetectedId");
                            return sendUnauthorizedResponse(req, res, "Unable to get token set", err);
                        }

                        util.printDebugLog("SSODetectedId", SSODetectedId);
                        res.writeHead(301, {
                            Location: "/setSSODetectedId",
                            "Set-Cookie": [`logout=false; Path=/; HttpOnly; Secure`, `accessTokenCookie=${encryptedTokenSet.encryptedAccessToken}; HttpOnly; Secure`, "isActiveSession=true; HttpOnly; Secure", `refreshTokenCookie=${encryptedTokenSet.encryptedRefreshToken}; HttpOnly; Secure`, `SSOUserId=${SSOUserId}; HttpOnly; Secure`, `SSODetectedId=${SSODetectedId}; HttpOnly; Secure`, `loginContextCookie=; Max-Age=0; Path=/; HttpOnly; Secure`],
                            "Cache-Control": "no-store, no-cache, must-revalidate, post-check=0, pre-check=0"
                        });
                        res.end();
                    });
                })
            });
        });
    }

    function logout(req, res) {
        const urlModule = require("url");
        const logoutUrl = urlModule.parse(oauthConfig.client.logoutUrl);

        logoutUrl.query = {
            post_logout_redirect_uri: oauthConfig.client.postLogoutRedirectUrl, client_id: oauthConfig.client.clientId,
        };

        let cookies = ["logout=true; Path=/; HttpOnly; Secure",
            "accessTokenCookie=; Path=/; Max-Age=0;",
            "isActiveSession=; Path=/; Max-Age=0;",
            "refreshTokenCookie=; Path=/; Max-Age=0;",
            "loginContextCookie=; Path=/; Max-Age=0;"];
        logger.info("SSO redirect (http 301) triggered for:", req.url);
        if (oauthConfig.usePostForLogout) {
            res.writeHead(301, {
                Location: "/logout-post",
                "Set-Cookie": cookies,
                "Cache-Control": "no-store, no-cache, must-revalidate, post-check=0, pre-check=0"
            });

            return res.end();
        }

        res.writeHead(301, {
            Location: urlModule.format(logoutUrl),
            "Set-Cookie": cookies,
            "Cache-Control": "no-store, no-cache, must-revalidate, post-check=0, pre-check=0"
        });
        res.end();
    }

    const CHECK_IF_SESSION_HAS_EXPIRED = "/checkIfSessionHasExpired";
    const LOGOUT_WAS_TRIGGERED = "/logoutWasTriggered";
    server.use(function (req, res, next) {
        let {url} = req;

        if (url === CHECK_IF_SESSION_HAS_EXPIRED) {
            const {sessionExpiryTime} = util.parseCookies(req.headers.cookie);
            res.statusCode = 200;
            if (sessionExpiryTime && parseInt(sessionExpiryTime) < Date.now()) {
                return res.end("true");
            }
            return res.end("false");
        }

        if (url === LOGOUT_WAS_TRIGGERED) {
            const {logout} = util.parseCookies(req.headers.cookie);
            res.statusCode = 200;
            return res.end(logout);
        }

        function isSetSSODetectedIdPhaseActive() {
            return url === "/setSSODetectedId";
        }

        function isCallbackPhaseActive() {
            const redirectUrlObj = new urlModule.URL(oauthConfig.client.redirectPath);
            const redirectPath = oauthConfig.client.redirectPath.slice(redirectUrlObj.origin.length);
            return !!url.includes(redirectPath) || !!url.includes("code=");
        }

        function isPostLogoutPhaseActive() {
            const postLogoutRedirectUrlObj = new urlModule.URL(oauthConfig.client.postLogoutRedirectUrl);
            const postLogoutRedirectPath = oauthConfig.client.postLogoutRedirectUrl.slice(postLogoutRedirectUrlObj.origin.length);
            return !!url.includes(postLogoutRedirectPath);
        }

        function startLogoutPhase(res) {
            let cookies = ["accessTokenCookie=; Max-Age=0; HttpOnly; Secure", "isActiveSession=; Max-Age=0; HttpOnly; Secure", "refreshTokenCookie=; Max-Age=0; HttpOnly; Secure", "loginContextCookie=; Path=/; Max-Age=0; HttpOnly; Secure"];
            logger.info("SSO redirect (http 301) triggered for:", req.url);
            res.writeHead(301, {
                Location: "/logout",
                "Set-Cookie": cookies,
                "Cache-Control": "no-store, no-cache, must-revalidate, post-check=0, pre-check=0"
            });
            res.end();
        }

        function isLogoutPhaseActive() {
            return url === "/logout";
        }

        function isLoginPhaseActive() {
            return url === "/login";
        }

        function isLogoutPostPhaseActive() {
            return url === "/logout-post";
        }

        if (req.skipSSO) {
            return next();
        }

        const canSkipOAuth = urlsToSkip.some((urlToSkip) => url.indexOf(urlToSkip) === 0);
        if (canSkipOAuth) {
            next();
            return;
        }

        let urlParts = url.split("/");
        let action = "";
        try {
            action = urlParts[3];
        } catch (err) {
            //ignored on purpose
        }

        if (defaultActionsToSkip.indexOf(action) !== -1) {
            next();
            return;
        }

        //this if is meant to help debugging "special" situation of wrong localhost req being checked with sso even if localhostAuthorization is disabled
        if (!config.getConfig("enableLocalhostAuthorization") && req.headers.host.indexOf("localhost") !== -1) {
            printDebugLog("SSO verification activated on 'local' request", "host header", req.headers.host, JSON.stringify(req.headers));
        }

        if (isCallbackPhaseActive()) {
            return loginCallbackRoute(req, res);
        }

        if (isLogoutPhaseActive()) {
            return logout(req, res);
        }

        if (isLoginPhaseActive()) {
            return startAuthFlow(req, res);
        }

        const parsedCookies = util.parseCookies(req.headers.cookie);
        let {accessTokenCookie, refreshTokenCookie, isActiveSession, SSODetectedId, SSOUserId} = parsedCookies;
        if (isSetSSODetectedIdPhaseActive()) {
            return setSSODetectedId(SSODetectedId, SSOUserId, accessTokenCookie, res);
        }
        let logoutCookie = parsedCookies.logout;
        let cookies = [];

        if (isPostLogoutPhaseActive()) {
            return startAuthFlow(req, res);
        }

        if (isLogoutPostPhaseActive()) {
            const returnHtml = "<html>" +
                `<body>
                 <script>
                    const logoutUrl = localStorage.getItem("logoutUrl");
                    const postLogoutRedirectUrl = localStorage.getItem("postLogoutRedirectUrl");
                    
                    fetch(logoutUrl, {method: "POST"}).
                        then(response => {
                            window.location.href = postLogoutRedirectUrl; 
                        })
                 </script>
                </body>` +
                "</html>";

            return res.end(returnHtml);
        }

        if (logoutCookie === "true") {
            res.statusCode = 403;
            const loginUrl = oauthConfig.client.postLogoutRedirectUrl;
            const returnHtml = "<html>" +
                `<body>We apologize for the inconvenience. The automated login attempt was unsuccessful. 
                    You can either <a href="${loginUrl}">retry the login</a> or if the issue persists, please restart your browser.
                    <script>sessionStorage.setItem('initialURL', window.location.href);</script>
                </body>` +
                "</html>";

            return res.end(returnHtml);
        }

        if (!accessTokenCookie) {
            if (!isActiveSession) {
                util.printDebugLog("Redirect to login because accessTokenCookie and isActiveSession are missing.")
                if (req.headers && req.headers.accept) {
                    const acceptHeadersIdentifiers = req.headers.accept.split(",");
                    if (acceptHeadersIdentifiers.some((acceptHeader) => staticContentIdentifiers.includes(acceptHeader))) {
                        return redirectToLogin(res);
                    }
                }
                res.statusCode = 401;
                return res.end("Unauthorized");
            } else {
                util.printDebugLog("Logout because accessTokenCookie is missing and isActiveSession is present.")
                return startLogoutPhase(res);
            }
        }

        const jwksEndpoint = config.getConfig("oauthJWKSEndpoint");
        util.validateEncryptedAccessToken(jwksEndpoint, accessTokenCookie, oauthConfig.sessionTimeout, (err) => {
            if (err) {
                if (err.message === errorMessages.ACCESS_TOKEN_DECRYPTION_FAILED || err.message === errorMessages.SESSION_EXPIRED) {
                    util.printDebugLog("Logout because accessTokenCookie decryption failed or session has expired.")
                    return startLogoutPhase(res);
                }

                return webClient.refreshToken(refreshTokenCookie, (err, tokenSet) => {
                    if (err) {
                        if (err.message === errorMessages.REFRESH_TOKEN_DECRYPTION_FAILED || err.message === errorMessages.SESSION_EXPIRED) {
                            util.printDebugLog("Logout because refreshTokenCookie decryption failed or session has expired.")
                            return startLogoutPhase(res);
                        }
                        return sendUnauthorizedResponse(req, res, "Unable to refresh token");
                    }

                    cookies = cookies.concat([`accessTokenCookie=${tokenSet.encryptedAccessToken}; HttpOnly; Secure`, `refreshTokenCookie=${tokenSet.encryptedRefreshToken}; HttpOnly; Secure`]);
                    logger.info("SSO redirect (http 301) triggered for:", req.url);
                    res.writeHead(301, {Location: "/", "Set-Cookie": cookies});
                    res.end();
                })
            }

            util.getSSODetectedIdFromEncryptedToken(accessTokenCookie, (err, SSODetectedId) => {
                if (err) {
                    util.printDebugLog("Logout because accessTokenCookie decryption failed or session has expired.")
                    return startLogoutPhase(res);
                }

                util.printDebugLog("SSODetectedId", SSODetectedId);
                req.headers["user-id"] = SSODetectedId;
                const canSkipUrlForSessionTimeout = skippedUrlsForSessionTimeout.some((urlToSkip) => url.includes(urlToSkip));
                if (canSkipUrlForSessionTimeout) {
                    return next();
                }
                util.updateAccessTokenExpiration(accessTokenCookie, (err, encryptedAccessToken) => {
                    if (err) {
                        util.printDebugLog("Logout because accessTokenCookie decryption failed.")
                        return startLogoutPhase(res);
                    }

                    const sessionExpiryTime = Date.now() + oauthConfig.sessionTimeout;
                    cookies = cookies.concat([`sessionExpiryTime=${sessionExpiryTime}; Path=/; HttpOnly; Secure`, `accessTokenCookie=${encryptedAccessToken}; Path=/; HttpOnly; Secure`]);
                    res.setHeader("Set-Cookie", cookies);
                    next();
                })
            })
        })
    });

    const GET_USER_ID = "/clientAuthenticationProxy/getUserId";
    server.post(GET_USER_ID, httpUtils.bodyParser);
    server.post(GET_USER_ID, async (req, res) => {
        try {
            req.body = JSON.parse(req.body);
        } catch (e) {
            res.statusCode = 400;
            res.end("Invalid request body");
            return;
        }
        const {clientId, clientSecret, scope, tokenEndpoint} = req.body;

        const params = new URLSearchParams();
        params.append('grant_type', 'client_credentials');
        params.append('client_id', clientId);
        params.append('client_secret', clientSecret);
        params.append('scope', scope);

        let response;
        try {
            response = await fetch(tokenEndpoint, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/x-www-form-urlencoded',
                },
                body: params
            })
        } catch (e) {
            res.statusCode = 500;
            res.end(e.message);
            return;
        }
        if (response.status !== 200) {
            res.statusCode = response.status;
            let errMessage = response.statusText;
            try {
                const data = await response.json();
                if (data.error) {
                    errMessage = data.error;
                    logger.error(data.error);
                }

                if (data.error_description) {
                    logger.error(data.error_description);
                    errMessage = data.error_description;
                }
            } catch (e) {
                logger.error(e);
            }
            res.end(errMessage);
            return;
        }
        let data;
        try {
            data = await response.json();
        } catch (e) {
            res.statusCode = 500;
            res.end(e.message);
            return;
        }
        const {payload} = util.parseAccessToken(data.access_token);
        res.statusCode = 200;
        res.end(payload.sub);
    })
}

module.exports = OAuthMiddleware;

},{"../../../config":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/apihub/config/index.js","../../../libs/http-wrapper":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/apihub/libs/http-wrapper/src/index.js","./WebClient":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/apihub/middlewares/oauth/lib/WebClient.js","./errorMessages":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/apihub/middlewares/oauth/lib/errorMessages.js","./util":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/apihub/middlewares/oauth/lib/util.js","path":false,"url":false}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/apihub/middlewares/oauth/lib/WebClient.js":[function(require,module,exports){
(function (Buffer){(function (){
const url = require('url');
const util = require("./util");
const openDSU = require("opendsu");
const http = openDSU.loadAPI("http");
const crypto = openDSU.loadAPI("crypto");
const errorMessages = require("./errorMessages");

function WebClient(oauthConfig) {
    this.getLoginInfo = () => {
        const fingerprint = crypto.generateRandom(32).toString('hex');//User-agent IP
        const state = crypto.generateRandom(32).toString('hex');
        const pkce = util.pkce();
        const authorizeUrl = url.parse(oauthConfig.issuer.authorizationEndpoint);
        authorizeUrl.query = {
            client_id: oauthConfig.client.clientId,
            redirect_uri: oauthConfig.client.redirectPath,
            response_type: 'code',
            scope: oauthConfig.client.scope,
            code_challenge_method: 'S256',
            code_challenge: pkce.codeChallenge,
            state
        };
        return {
            state,
            fingerprint,
            codeVerifier: pkce.codeVerifier,
            redirect: url.format(authorizeUrl),
            date: Date.now()
        }
    }


    this.loginCallback = (context, callback) => {
        //fingerprint verification
        /* disabled because was triggered by multiple tabs login...
        if (context.clientState !== context.queryState) {
            return callback(new Error('Invalid state'));
        }*/

        let body = {
            'grant_type': 'authorization_code',
            'client_id': oauthConfig.client.clientId,
            'client_secret': oauthConfig.client.clientSecret,
            'redirect_uri': oauthConfig.client.redirectPath,
            'code': context.queryCode,
            'code_verifier': context.clientCode
        }

        const postData = util.urlEncodeForm(body);

        const options = {
            method: "POST",
            headers: {
                'Content-Type': 'application/x-www-form-urlencoded',
                'Content-Length': postData.length
            }
        };

        http.doPost(oauthConfig.issuer.tokenEndpoint, util.urlEncodeForm(body), options, (err, tokenSet) => {
            if (err) {
                return callback(err);
            }

            try {
                tokenSet = JSON.parse(tokenSet);
            } catch (e) {
                return callback(e);
            }

            callback(undefined, tokenSet);
        });
    }

    this.refreshToken = function refreshToken(currentEncryptionKeyPath, previousEncryptionKeyPath, refreshTokenCookie, callback) {
        util.decryptRefreshTokenCookie(currentEncryptionKeyPath, previousEncryptionKeyPath, refreshTokenCookie, (err, refreshToken) => {
            if (err) {
                return callback(err);
            }

            if ( Date.now() - refreshToken.date > oauthConfig.sessionTimeout) {
                return callback(Error(errorMessages.SESSION_EXPIRED))
            }

            const body = {
                'grant_type': 'refresh_token',
                'client_id': oauthConfig.client.clientId,
                'redirect_uri': oauthConfig.client.redirectPath,
                'refresh_token': refreshToken,
                'client_secret': oauthConfig.client.clientSecret
            };
            const postData = util.urlEncodeForm(body);
            const options = {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/x-www-form-urlencoded',
                    'Content-Length': Buffer.byteLength(postData)
                }
            }

            http.doPost(oauthConfig.issuer.tokenEndpoint, postData, options, (err, tokenSet) => {
                if (err) {
                    return callback(err);
                }

                try {
                    tokenSet = JSON.parse(tokenSet);
                } catch (e) {
                    return callback(e);
                }
                util.encryptTokenSet(currentEncryptionKeyPath, tokenSet, callback);
            });
        });
    }

    this.getUserInfo = (accessToken, callback)=>{
        const options = {
            method: 'GET',
            headers: {
                'Authorization': `Bearer ${accessToken}`
            }
        }
        http.doGet(oauthConfig.issuer.userInfoEndpoint, options, (err, userInfo) => {
            if (err) {
                return callback(err);
            }

            util.printDebugLog("Raw user info:", userInfo);
            util.printDebugLog("typeof user info:", typeof userInfo);
            try {
                userInfo = JSON.parse(userInfo);
            } catch (e) {
                return callback(e);
            }

            callback(undefined, userInfo);
        });
    }
}


module.exports = WebClient;
}).call(this)}).call(this,require("buffer").Buffer)

},{"./errorMessages":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/apihub/middlewares/oauth/lib/errorMessages.js","./util":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/apihub/middlewares/oauth/lib/util.js","buffer":false,"opendsu":"opendsu","url":false}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/apihub/middlewares/oauth/lib/errorMessages.js":[function(require,module,exports){
module.exports = {
    ACCESS_TOKEN_DECRYPTION_FAILED: "Failed to decrypt accessTokenCookie",
    REFRESH_TOKEN_DECRYPTION_FAILED: "Failed to decrypt refreshTokenCookie",
    REFRESH_TOKEN_UNDEFINED: "refreshTokenCookie is undefined",
    SESSION_EXPIRED:"Session expired"
}
},{}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/apihub/middlewares/oauth/lib/util.js":[function(require,module,exports){
const openDSU = require("opendsu");
const crypto = openDSU.loadAPI("crypto");
const http = openDSU.loadAPI("http");
const fs = require("fs");
const errorMessages = require("./errorMessages");
const logger = $$.getLogger("OAuthMiddleware", "util.js");

let publicKey;

const PREVIOUS_ENCRYPTION_KEY_FILE = "previousEncryptionKey.secret";
const CURRENT_ENCRYPTION_KEY_FILE = "currentEncryptionKey.secret";

function KeyManager(storage, rotationInterval){
    let current;
    let previous;

    const logger = $$.getLogger("OAuthMiddleware", "oauth/keyManager");

    function getPath(filename){
        const path = require("path");
        return path.join(storage, filename);
    }

    function persist(filename, key, callback){
        logger.debug("Writing", filename);
        fs.writeFile(getPath(filename), key, callback);
    }

    function getAge(lastModificationTime){
        let timestamp = new Date().getTime();
        let converted = new Date(lastModificationTime).getTime();
        let age = timestamp - converted;
        //logger.debug("age seems to be", age);
        return age;
    }

    function checkIfExpired(lastModificationTime){
        let res = getAge(lastModificationTime) > rotationInterval;
        logger.debug("expired", res);
        return res;
    }

    let self = this;
    function tic(){
        fs.stat(getPath(CURRENT_ENCRYPTION_KEY_FILE), (err, stats)=>{
            if(stats && checkIfExpired(stats.mtime)){
                self.rotate();
            }

            if(err || !stats){
                //for any error we try as soon as possible again
                setTimeout(tic, 0);
            }
        });
    }

    function generateKey(){
        logger.debug("generating new key");
        return crypto.generateRandom(32);
    }

    this.init = ()=>{
        let stats;
        try {
            stats = fs.statSync(getPath(CURRENT_ENCRYPTION_KEY_FILE));
            if(stats){
                logger.debug("mtime of current encryption key is", stats.mtime);
                if(checkIfExpired(stats.mtime)){
                    throw new Error("Current key is to old");
                }
                logger.info("Loading encryption keys");
                current = fs.readFileSync(getPath(CURRENT_ENCRYPTION_KEY_FILE));
                try{
                    previous = fs.readFileSync(getPath(PREVIOUS_ENCRYPTION_KEY_FILE));
                }catch(e){
                    logger.debug("Caught an error during previous key loading. This could mean that a restart was performed before any rotation and the previous key file doesn't exit.", e.message, e.code);
                }

                // let's schedule a quick check of key age
                setTimeout(tic, getAge(stats.mtime));
            }else{
                logger.info("Initializing...");
                throw new Error("Initialization required");
            }
        } catch (e) {
            logger.debug(e.message);
            //for any reason we try to ensure folder structure...
            fs.mkdirSync(storage, {recursive: true});

            this.rotate();
        }

        //we split the "big" interval in smaller intervals
        setInterval(tic, Math.round(rotationInterval/12));
    }

    this.getCurrentEncryptionKey = ()=>{
        return current;
    }

    this.getPreviousEncryptionKey = ()=>{
        return previous;
    }

    this.rotate = ()=>{
        if(!current && !previous){
            logger.info("No current or previous key, there we generate current ant persist");
            current = generateKey();
            return persist(CURRENT_ENCRYPTION_KEY_FILE, current, (err)=>{
                if(err){
                    logger.error("Failed to persist key");
                }
            });
        }
        logger.debug("saving current key as previous");
        previous = current;
        current = generateKey();

        function saveState(lastGeneratedKey){
            if(lastGeneratedKey !== current){
                logger.error("Unable to persist keys until a new rotation time achieved");
                //we weren't able to save the state until a new rotation
                return;
            }
            persist(PREVIOUS_ENCRYPTION_KEY_FILE, previous, (err)=>{
                if(err){
                    logger.debug("Caught error during key rotation", err);
                    return saveState(lastGeneratedKey);
                }
                persist(CURRENT_ENCRYPTION_KEY_FILE, current, (err)=>{
                    if(err){
                        logger.debug("Caught error during key rotation", err);
                        saveState(lastGeneratedKey);
                    }
                    logger.info("Successful key rotation");
                });
            });
        }

        saveState(current);
    }

    this.init();
    return this;
}

let keyManager;
function initializeKeyManager(storage, rotationInterval){
    if(!keyManager){
        keyManager =  new KeyManager(storage, rotationInterval);
    }
}

function pkce() {
    const codeVerifier = crypto.generateRandom(32).toString('hex');
    const codeChallenge = pkceChallenge(codeVerifier);
    return {codeVerifier, codeChallenge};
}

function pkceChallenge(codeVerifier) {
    return crypto.sha256JOSE(codeVerifier).toString("base64").replace(/=/g, "")
        .replace(/\+/g, "-")
        .replace(/\//g, "_");
}

function urlEncodeForm(obj) {
    let encodedStr = "";
    for (let prop in obj) {
        encodedStr += `${encodeURIComponent(prop)}=${encodeURIComponent(obj[prop])}&`;
    }
    if (encodedStr[encodedStr.length - 1] === "&") {
        encodedStr = encodedStr.slice(0, -1);
    }

    return encodedStr;
}

function encodeCookie(cookie) {
    if (typeof cookie === "string") {
        cookie = $$.Buffer.from(cookie);
    }
    return encodeURIComponent(cookie.toString("base64"));
}

function decodeCookie(cookie) {
    return $$.Buffer.from(decodeURIComponent(cookie), "base64");
}

function parseCookies(cookies) {
    const parsedCookies = {};
    if (!cookies) {
        return parsedCookies;
    }
    let splitCookies = cookies.split(";");
    splitCookies = splitCookies.map(splitCookie => splitCookie.trim());
    splitCookies.forEach(cookie => {
        const cookieComponents = cookie.split("=");
        const cookieName = cookieComponents[0].trim();
        let cookieValue = cookieComponents[1].trim();
        if (cookieValue === "null" || cookieValue === "undefined") {
            cookieValue = undefined;
        }
        parsedCookies[cookieName] = cookieValue;
    })

    return parsedCookies;
}

function parseAccessToken(rawAccessToken) {
    let [header, payload, signature] = rawAccessToken.split(".");
    header = JSON.parse($$.Buffer.from(header, "base64").toString())
    payload = JSON.parse($$.Buffer.from(payload, "base64").toString())
    return {
        header, payload, signature
    }
}

function getCurrentEncryptionKey(callback) {
    if(!keyManager){
        return callback(new Error("keyManager not instantiated"));
    }

    return callback(undefined, keyManager.getCurrentEncryptionKey());
}

function getPreviousEncryptionKey(callback) {
    if(!keyManager){
        return callback(new Error("keyManager not instantiated"));
    }

    return callback(undefined, keyManager.getPreviousEncryptionKey());
}

const SSODetectedIdsAndUserIds = {};
function encryptTokenSet(tokenSet, callback) {
    delete SSODetectedIdsAndUserIds[tokenSet.access_token];
    getSSODetectedIdAndUserId(tokenSet, (err, {SSODetectedId})=>{
        if (err) {
            return callback(err);
        }

        const accessTokenPayload = {
            date: Date.now(),
            token: tokenSet.access_token,
            SSODetectedId
        }

        const refreshTokenPayload = {
            date: Date.now(),
            token: tokenSet.refresh_token
        }


        getCurrentEncryptionKey((err, encryptionKey) => {
            if (err) {
                return callback(err);
            }

            let encryptedTokenSet;
            try {
                let encryptedAccessToken = crypto.encrypt(JSON.stringify(accessTokenPayload), encryptionKey);
                let encryptedRefreshToken = crypto.encrypt(JSON.stringify(refreshTokenPayload), encryptionKey);
                encryptedTokenSet = {
                    encryptedAccessToken: encodeCookie(encryptedAccessToken),
                    encryptedRefreshToken: encodeCookie(encryptedRefreshToken)
                }
            } catch (e) {
                return callback(e);
            }
            callback(undefined, encryptedTokenSet);
        })
    })
}

function encryptLoginInfo(loginInfo, callback) {
    getCurrentEncryptionKey((err, encryptionKey) => {
        if (err) {
            return callback(err);
        }

        let encryptedContext;
        try {
            encryptedContext = crypto.encrypt(JSON.stringify(loginInfo), encryptionKey);
            encryptedContext = encodeCookie(encryptedContext);
        } catch (e) {
            return callback(e);
        }
        callback(undefined, encryptedContext);
    })
}

function encryptAccessToken(accessToken, SSODetectedId, callback) {
    const accessTokenTimestamp = Date.now();
    const accessTokenPayload = {
        date: accessTokenTimestamp, token: accessToken, SSODetectedId
    }

    getCurrentEncryptionKey((err, currentEncryptionKey) => {
        if (err) {
            return callback(err);
        }

        let encryptedAccessToken;
        try {
            encryptedAccessToken = crypto.encrypt(JSON.stringify(accessTokenPayload), currentEncryptionKey);
            encryptedAccessToken = encodeCookie(encryptedAccessToken);
        } catch (e) {
            return callback(e);
        }
        callback(undefined, encryptedAccessToken);
    });
}

function decryptData(encryptedData, encryptionKey, callback) {
    let plainData;
    try {
        plainData = crypto.decrypt(encryptedData, encryptionKey);
    } catch (e) {
        return callback(e);
    }

    callback(undefined, plainData);
}

function decryptDataWithCurrentKey(encryptedData, callback) {
    getCurrentEncryptionKey((err, currentEncryptionKey) => {
        if (err) {
            return callback(err);
        }

        decryptData(encryptedData, currentEncryptionKey, callback);
    })
}

function decryptDataWithPreviousKey(encryptedData, callback) {
    getPreviousEncryptionKey((err, previousEncryptionKey) => {
        if (err) {
            return callback(err);
        }

        decryptData(encryptedData, previousEncryptionKey, callback);
    })
}

function decryptAccessTokenCookie(accessTokenCookie, callback) {
    function parseAccessTokenCookie(accessTokenCookie, callback) {
        let parsedAccessTokenCookie;
        try {
            parsedAccessTokenCookie = JSON.parse(accessTokenCookie.toString());
        } catch (e) {
            return callback(e);
        }

        callback(undefined, parsedAccessTokenCookie);
    }

    decryptDataWithCurrentKey(decodeCookie(accessTokenCookie), (err, plainAccessTokenCookie) => {
        if (err) {
            decryptDataWithPreviousKey(decodeCookie(accessTokenCookie), (err, plainAccessTokenCookie) => {
                if (err) {
                    return callback(err);
                }

                parseAccessTokenCookie(plainAccessTokenCookie, callback);
            })

            return;
        }


        parseAccessTokenCookie(plainAccessTokenCookie, callback);
    })
}

function getSSODetectedIdFromPayload(obj) {
    return obj.email || obj.preferred_username || obj.upn || obj.sub;
}

function getSSODetectedIdAndUserId(tokenSet, callback) {
    let parsedToken;
    let payload;
    const cachedSSODetectedIdObj = SSODetectedIdsAndUserIds[tokenSet.access_token];
    if(cachedSSODetectedIdObj){
        return callback(undefined, cachedSSODetectedIdObj);
    }
    try {
        parsedToken = parseAccessToken(tokenSet.id_token);
        payload = parsedToken.payload;
        const res =  {
            SSOUserId: payload.sub,
            SSODetectedId: getSSODetectedIdFromPayload(payload)
        }
        SSODetectedIdsAndUserIds[tokenSet.access_token] = res;
        return callback(undefined, res);
    } catch (e) {
        const config = require("../../../config");
        const oauthConfig = config.getConfig("oauthConfig");
        const WebClient = require("./WebClient");
        const webClient = new WebClient(oauthConfig);
        webClient.getUserInfo(tokenSet.access_token, (err, userInfo) => {
            if (err) {
                return callback(err);
            }

            const res =  {
                SSOUserId: userInfo.sub,
                SSODetectedId: getSSODetectedIdFromPayload(userInfo)
            }
            SSODetectedIdsAndUserIds[tokenSet.access_token] = res;
            return callback(undefined, res);
        })
    }
}

function getSSODetectedIdFromEncryptedToken(accessTokenCookie, callback) {
    decryptAccessTokenCookie(accessTokenCookie, (err, decryptedAccessTokenCookie) => {
        if (err) {
            return callback(err);
        }

        return callback(undefined, decryptedAccessTokenCookie.SSODetectedId);
    })
}

function decryptRefreshTokenCookie(encryptedRefreshToken, callback) {
    if (!encryptedRefreshToken) {
        return callback(Error(errorMessages.REFRESH_TOKEN_UNDEFINED));
    }

    decryptDataWithCurrentKey(encryptedRefreshToken, (err, refreshToken) => {
        if (err) {
            decryptDataWithPreviousKey(encryptedRefreshToken, (err, refreshToken) => {
                if (err) {
                    err.message = errorMessages.REFRESH_TOKEN_DECRYPTION_FAILED;
                    return callback(err);
                }

                callback(undefined, refreshToken.toString());
            });
            return
        }

        callback(undefined, refreshToken.toString());
    });
}

function getPublicKey(jwksEndpoint, rawAccessToken, callback) {
    if (publicKey) {
        return callback(undefined, publicKey);
    }

    http.doGet(jwksEndpoint, (err, rawData) => {
        if (err) {
            return callback(err);
        }
        try {
            const parsedData = JSON.parse(rawData);
            const accessToken = parseAccessToken(rawAccessToken);
            publicKey = parsedData.keys.find(key => key.use === "sig" && key.kid === accessToken.header.kid);
            if (!publicKey) {
                return callback(Error(`Could not get private key for the provided token's signature verification.`))
            }
        } catch (e) {
            return callback(e);
        }

        callback(undefined, publicKey);
    })
}

function validateAccessToken(jwksEndpoint, accessToken, callback) {
    getPublicKey(jwksEndpoint, accessToken, (err, publicKey) => {
        if (err) {
            return callback(err);
        }

        crypto.jsonWebTokenAPI.verify(accessToken, publicKey, callback);
    })
}

function validateEncryptedAccessToken(jwksEndpoint, accessTokenCookie, sessionTimeout, callback) {
    decryptAccessTokenCookie(accessTokenCookie, (err, decryptedAccessTokenCookie) => {
        if (err) {
            return callback(Error(errorMessages.ACCESS_TOKEN_DECRYPTION_FAILED));
        }

        if (Date.now() - decryptedAccessTokenCookie.date > sessionTimeout) {
            return callback(Error(errorMessages.SESSION_EXPIRED));
        }
        callback();
        // validateAccessToken(jwksEndpoint, decryptedAccessTokenCookie.token, callback);
    })
}

function decryptLoginInfo(encryptedLoginInfo, callback) {
    decryptDataWithCurrentKey(decodeCookie(encryptedLoginInfo), (err, loginContext) => {
        function parseLoginContext(loginContext, callback) {
            let parsedLoginContext;
            try {
                parsedLoginContext = JSON.parse(loginContext.toString());
            } catch (e) {
                return callback(e);
            }

            callback(undefined, parsedLoginContext);
        }

        if (err) {
            decryptDataWithPreviousKey(decodeCookie(encryptedLoginInfo), (err, loginContext) => {
                if (err) {
                    return callback(err);
                }

                parseLoginContext(loginContext, callback);
            })

            return;
        }

        parseLoginContext(loginContext, callback);
    })
}

function getUrlsToSkip() {
    const config = require("../../../config");
    const skipOAuth = config.getConfig("skipOAuth");
    let urlsToSkip = skipOAuth && Array.isArray(skipOAuth) ? skipOAuth : [];
    const configuredDomains = config.getConfiguredDomains();
    configuredDomains.forEach(domain => {
        const domainConfig = config.getDomainConfig(domain);
        if (domainConfig.skipOAuth) {
            urlsToSkip = urlsToSkip.concat(domainConfig.skipOAuth);
        }
    })

    return urlsToSkip;
}

function updateAccessTokenExpiration(accessTokenCookie, callback) {
    decryptAccessTokenCookie(accessTokenCookie, (err, decryptedTokenCookie) => {
        if (err) {
            return callback(err);
        }

        encryptAccessToken(decryptedTokenCookie.token, decryptedTokenCookie.SSODetectedId, callback);
    })
}

function printDebugLog(...args) {
    const config = require("../../../config");
    const oauthConfig = config.getConfig("oauthConfig");
    if (oauthConfig.debugLogEnabled) {
        logger.debug(...args);
    }
}

module.exports = {
    pkce,
    urlEncodeForm,
    parseCookies,
    initializeKeyManager,
    parseAccessToken,
    encryptTokenSet,
    encryptLoginInfo,
    decryptLoginInfo,
    decryptRefreshTokenCookie,
    getPublicKey,
    validateAccessToken,
    validateEncryptedAccessToken,
    getUrlsToSkip,
    getSSODetectedIdAndUserId,
    getSSODetectedIdFromEncryptedToken,
    updateAccessTokenExpiration,
    printDebugLog,
    getSSODetectedIdFromPayload
}

},{"../../../config":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/apihub/config/index.js","./WebClient":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/apihub/middlewares/oauth/lib/WebClient.js","./errorMessages":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/apihub/middlewares/oauth/lib/errorMessages.js","fs":false,"opendsu":"opendsu","path":false}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/apihub/middlewares/readOnly/index.js":[function(require,module,exports){
let path = "path";
path = require(path);
let fs = "fs";
fs = require(fs);

let readOnly = false;

function ReadOnlyMiddleware(server, registerHandler = true) {
    let config = server.config;
    let readOnlyFlag = config.readOnlyFile || "readonly";
    let interval = config.readOnlyInterval || 60 * 1000;
    let rootStorage = path.resolve(config.storage);
    readOnlyFlag = path.resolve(rootStorage, readOnlyFlag);

    if (readOnlyFlag.indexOf(rootStorage) === -1) {
        console.warn(`ReadOnly flag location resolved outside of ApiHUB root folder. (${readOnlyFlag})`);
    }

    Object.defineProperty(server, "readOnlyModeActive", {
        get: function () {
            return readOnly;
        }
    });

    function enableReadOnly() {
        if (!readOnly) {
            console.info("Read only mode is activated.");
            readOnly = true;
        }
    }

    function disableReadOnly() {
        if (readOnly) {
            console.info("Read only mode is disabled.");
            readOnly = false;
        }
    }

    function checkReadOnlyFlag() {
        let envFlag = process.env.READ_ONLY_MODE;
        if (typeof envFlag === "string" && envFlag.toLowerCase().trim() === "true") {
            console.info("READ_ONLY_MODE env flag was detected.");
            enableReadOnly();
            return;
        }
        fs.access(readOnlyFlag, fs.constants.F_OK, (err) => {
            if (!err) {
                enableReadOnly();
            } else {
                disableReadOnly();
            }
        });
    }

    checkReadOnlyFlag();
    setInterval(checkReadOnlyFlag, interval);

    if(registerHandler){
        server.use("*", function (req, res, next) {
            if (readOnly && req.method !== "GET" && req.method !== "HEAD") {
                res.statusCode = 405;
                res.write("read only mode is active");
                return res.end();
            }
            next();
        });
    }
}

module.exports = ReadOnlyMiddleware;
},{}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/apihub/middlewares/requestEnhancements/index.js":[function(require,module,exports){
function setupRequestEnhancements(server) {
    const logger = $$.getLogger("setupRequestEnhancements", "apihub/requestEnhancements");

    const constants = require("./../../moduleConstants");

	server.use(function (req, res, next) {
        const logs = [];
        req.log = function(...args){
            logs.push(args);
        };

        req.getLogs = function(){
            return logs;
        }

		next();
	});

    logger.debug(`${constants.LOG_IDENTIFIER}`, "Request API enhancements were set up.");
}

module.exports = setupRequestEnhancements;

},{"./../../moduleConstants":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/apihub/moduleConstants.js"}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/apihub/middlewares/responseHeader/index.js":[function(require,module,exports){
function ResponseHeaders(server) {
    const logger = $$.getLogger("ResponseHeaders", "apihub/responseHeaders");

    logger.debug(`Registering Response Headers middleware`);

    const config = require("../../config");
    const responseHeaders = config.getConfig("responseHeaders");

    server.use(function (req, res, next) {
        if (!responseHeaders) {
            return next();
        }
        for (let header in responseHeaders) {
            res.setHeader(header, responseHeaders[header]);
        }

        next();
    });
}

module.exports = ResponseHeaders;

},{"../../config":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/apihub/config/index.js"}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/apihub/middlewares/simpleAuth/index.js":[function(require,module,exports){
const fs = require('fs');
const fsPromises = fs.promises;
const path = require('path');
const openDSU = require("opendsu");
const crypto = openDSU.loadAPI("crypto");
const querystring = require('querystring');
const cookieUtils = require("../../utils/cookie-utils");
const SecretsService = require("../../components/secrets/SecretsService");
const appName = 'simpleAuth'
const PUT_SECRETS_URL_PATH = "/putSSOSecret/simpleAuth";
const GET_SECRETS_URL_PATH = "/getSSOSecret/simpleAuth";

// Utility function to read .htpassword.secrets file
function readSecretsFile(filePath) {
    try {
        const data = fs.readFileSync(filePath, 'utf8');
        let userEntries = data.split('\n').filter(function (item) {
            //remove empty results
            return item !== "";
        });
        return userEntries;
    } catch (err) {
        // console.error(err);
        return null;
    }
}

function getSSOId(mail) {
    if (mail) {
        return mail;
    }
    return crypto.generateRandom(32).toString("base64");
}

function getPwdSecret(user, pwd, mail, ssoId) {
    let secret = `${user}:${pwd}:${mail}`;

    if (ssoId) {
        secret = `${secret}:${ssoId}`
    }

    return secret;
}

// SimpleAuthentication Middleware
module.exports = function (server) {
    const serverRootFolder = server.rootFolder;
    const secretsFilePath = path.join(serverRootFolder, '.htpassword.secret');
    const htpPwdSecrets = readSecretsFile(secretsFilePath);
    const skipUrls = ['/simpleAuth', '/simpleAuth?wrongCredentials=true', '/favicon.ico', '/redirect', GET_SECRETS_URL_PATH, PUT_SECRETS_URL_PATH]
    const util = require("../oauth/lib/util.js");
    const urlsToSkip = [...util.getUrlsToSkip(), ...skipUrls];
    let secretsService;
    setTimeout(async () => {
        secretsService = await SecretsService.getSecretsServiceInstanceAsync(server.rootFolder);
    });

    server.use(function (req, res, next) {
        if (!fs.existsSync(secretsFilePath)) {
            return next();
        }

        if (!htpPwdSecrets) {
            return res.writeHead(500).end('Error reading secrets file');
        }

        const canSkipOAuth = urlsToSkip.some((urlToSkip) => req.url.indexOf(urlToSkip) !== -1);
        if (canSkipOAuth) {
            return next();
        }

        if (req.headers.authorization) {
            const [username, password] = req.headers.authorization.split(" ")[1].split(":");
            const index = htpPwdSecrets.findIndex(entry => entry.startsWith(username));
            let [user, pwd, mail, ssoId] = htpPwdSecrets[index].split(':');
            if (pwd === password) {
                req.headers["user-id"] = ssoId;
                return next();
            }
        }

        let {SimpleAuthorisation} = cookieUtils.parseCookies(req.headers.cookie);

        if (!SimpleAuthorisation) {
            res.setHeader('Set-Cookie', `originalUrl=${req.url}; HttpOnly`);
            return res.writeHead(302, {'Location': '/simpleAuth'}).end();
        }

        // Verify API Key
        const authorisationData = SimpleAuthorisation.split(":");

        if (authorisationData.length !== 2 || !secretsService.getSecretSync(appName, authorisationData[0])) {
            res.writeHead(302, {'Location': '/simpleAuth'});
            //    res.setHeader('Set-Cookie', 'SimpleAuthorisation=; HttpOnly; Max-Age=0');
            return res.end();
        }

        const index = htpPwdSecrets.findIndex(entry => entry.startsWith(authorisationData[0]));
        let [user, pwd, mail, ssoId] = htpPwdSecrets[index].split(':');
        req.headers["user-id"] = ssoId;
        next();
    });

    const httpUtils = require("../../libs/http-wrapper/src/httpUtils");

    server.get('/simpleAuth/*', (req, res) => {
        let wrongCredentials = req.query.wrongCredentials || false;
        res.writeHead(200, {'Content-Type': 'text/html'});
        const errHtml = `<div id="err-container">${wrongCredentials ? "Invalid username or password" : ""}</div>`
        const returnHtml = `
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <meta name="viewport" content="width=device-width, initial-scale=1.0">
            <title>Login Page</title>
             <style>
             #form-container{
                 width: fit-content;
                 margin: auto;
                 text-align: center;
             }
             form div{
                 display: flex;
                 justify-content: space-between;
                 gap: 10px;
             }
             #err-container{
                 color: red;
             }
             </style>
        </head>
        <body>
        <div id="form-container">
            <h2>Login</h2>
            <form action="/simpleAuth" method="post">
               <div> <label for="username">Username:</label>
                <input type="text" id="username" name="username" required>
               </div>
               <br>
               <div>
                <label for="password">Password:</label>
                <input type="password" id="password" name="password" required>
               </div>
                <br>
                <button type="submit">Submit</button>
            </form>
            ${errHtml}
            </div>

        </body>
        </html>
`
        return res.end(returnHtml);
    })

    const simpleAuthHandler = async (req, res, next) => {
        const {body} = req;
        const formResult = querystring.parse(body);
        const hashedPassword = crypto.sha256JOSE(formResult.password).toString("hex");
        const index = htpPwdSecrets.findIndex(entry => entry.startsWith(formResult.username));
        if (index === -1) {
            res.writeHead(302, {'Location': '/simpleAuth?wrongCredentials=true'});
            return res.end();
        }

        let [user, pwd, mail, ssoId] = htpPwdSecrets[index].split(':');
        if (pwd === hashedPassword) {
            if (!ssoId) {
                ssoId = getSSOId(mail);
                htpPwdSecrets[index] = getPwdSecret(user, pwd, mail, ssoId)
                // Join the entries back into a single string
                const updatedData = htpPwdSecrets.join('\n');
                try {
                    await fsPromises.writeFile(secretsFilePath, updatedData, 'utf8');
                } catch (e) {
                    res.statusCode = 500;
                    return res.end(`Error writing file: ${e.message}`);
                }
            }
            let apiKey;
            try {
                apiKey = await secretsService.generateAPIKeyAsync(formResult.username, false);
                await secretsService.putSecretAsync(appName, formResult.username, apiKey);
            } catch (e) {
                res.statusCode = 500;
                return res.end(`Error writing secret: ${e.message}`);
            }
            res.setHeader('Set-Cookie', [`SimpleAuthorisation=${formResult.username}:${apiKey}; HttpOnly`, `ssoId=${ssoId}; HttpOnly`, `apiKey=${apiKey}; HttpOnly`]);
            res.writeHead(302, {'Location': '/redirect'});
            return res.end();
        }
    };


    server.get('/redirect', (req, res) => {
        let {originalUrl, ssoId} = cookieUtils.parseCookies(req.headers.cookie);
        res.setHeader('Set-Cookie', ['originalUrl=; HttpOnly; Max-Age=0', 'ssoId=; HttpOnly; Max-Age=0']);
        res.writeHead(200, {'Content-Type': 'text/html'});

        return res.end(`<script>localStorage.setItem('SSODetectedId', '${ssoId}'); window.location.href = '${originalUrl || "/"}';</script>`);
    });

    server.post('/simpleAuth', httpUtils.bodyParser);
    server.post('/simpleAuth', simpleAuthHandler)

    server.put('/simpleAuth', httpUtils.bodyParser);
    server.put('/simpleAuth', simpleAuthHandler);
}

},{"../../components/secrets/SecretsService":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/apihub/components/secrets/SecretsService.js","../../libs/http-wrapper/src/httpUtils":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/apihub/libs/http-wrapper/src/httpUtils.js","../../utils/cookie-utils":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/apihub/utils/cookie-utils.js","../oauth/lib/util.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/apihub/middlewares/oauth/lib/util.js","fs":false,"opendsu":"opendsu","path":false,"querystring":false}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/apihub/middlewares/throttler/index.js":[function(require,module,exports){
const TokenBucket = require("../../libs/TokenBucket");

function Throttler(server) {
    const logger = $$.getLogger("Throttler", "apihub");
    const START_TOKENS = 6000000;
    const tokenBucket = new TokenBucket(START_TOKENS, 1, 10);
    let remainingTokens = START_TOKENS;
    const conf = require('../../config').getConfig();

    function throttlerHandler(req, res, next) {
        const ip = res.socket.remoteAddress;
        tokenBucket.takeToken(ip, tokenBucket.COST_MEDIUM, function (err, remainedTokens) {
            res.setHeader('X-RateLimit-Limit', tokenBucket.getLimitByCost(tokenBucket.COST_MEDIUM));
            res.setHeader('X-RateLimit-Remaining', tokenBucket.getRemainingTokenByCost(remainedTokens, tokenBucket.COST_MEDIUM));
            remainingTokens = remainedTokens;
            if (err) {
                if (err === TokenBucket.ERROR_LIMIT_EXCEEDED) {
                    res.statusCode = 429;
                } else {
                    res.statusCode = 500;
                }

                res.end();
                return;
            }

            next();
        });
    }

    function readyProbeHandler(req, res) {
        const stats = {
            remainingTokens: tokenBucket.getRemainingTokenByCost(remainingTokens, tokenBucket.COST_MEDIUM),
            tokenLimit: tokenBucket.getLimitByCost(tokenBucket.COST_MEDIUM)
        }

        res.setHeader('Content-Type', 'application/json');
        res.statusCode = 200;
        res.write(JSON.stringify(stats));
        res.end();
    }

    if (conf.preventRateLimit !== true) {
        server.use(throttlerHandler);
        server.get("/ready-probe", readyProbeHandler);
    } else {
        logger.debug(`Rate limit mechanism disabled!`);
        server.get("/ready-probe", function (req, res) {
            res.statusCode = 200;
            res.write("Server ready");
            res.end();
        });
    }
}

module.exports = Throttler;
},{"../../config":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/apihub/config/index.js","../../libs/TokenBucket":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/apihub/libs/TokenBucket.js"}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/apihub/moduleConstants.js":[function(require,module,exports){
module.exports = {
	LOG_IDENTIFIER: "[API-HUB]"
};
},{}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/apihub/utils/ExpiringFileLock.js":[function(require,module,exports){
function ExpiringFileLock(folderLock, timeout) {
    const fsPromisesName = 'node:fs/promises';
    const fsPromises = require(fsPromisesName);

    function asyncSleep(ms) {
        return new Promise(resolve => setTimeout(resolve, ms));
    }

    this.lock = async () => {
        while (true) {
            try {
                const stat = await fsPromises.stat(folderLock);
                const currentTime = Date.now();
                // console.log("checking if lock is expired", folderLock, stat.ctime.getTime(), currentTime - timeout, stat.ctime.getTime() < currentTime - timeout);
                if (stat.ctime.getTime() < currentTime - timeout) {
                    await fsPromises.rmdir(folderLock);
                    console.log("Removed expired lock", folderLock);
                }
            } catch (e) {
                // No such file or directory
            }

            try {
                await fsPromises.mkdir(folderLock, {recursive: true});
                return;
            } catch (e) {
                console.log("Retrying to acquire lock", folderLock, "after 100ms");
                await asyncSleep(100);
            }
        }
    }

    this.unlock = async () => {
        try {
            await fsPromises.rmdir(folderLock);
        }catch (e) {
            // Nothing to do
        }
    }
}

module.exports = {
    getLock: (folderLock, timeout) => {
        return new ExpiringFileLock(folderLock, timeout);
    }
};
},{}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/apihub/utils/cookie-utils.js":[function(require,module,exports){
const COOKIE_REGEX = /([^;=\s]*)=([^;]*)/g;

function parseCookies(str) {
    let cookies = {};
    if (!str) {
        return cookies;
    }
    for (let m; (m = COOKIE_REGEX.exec(str)); ) {
        cookies[m[1]] = decodeURIComponent(m[2]);
    }
    return cookies;
}

/**
 * @param {Object} options
 * @param {string} [options.name='']
 * @param {string} [options.value='']
 * @param {Date} [options.expires]
 * @param {number} [options.maxAge]
 * @param {string} [options.domain]
 * @param {string} [options.path]
 * @param {boolean} [options.secure]
 * @param {boolean} [options.httpOnly]
 * @param {'Strict'|'Lax'|'None'} [options.sameSite]
 * @return {string}
 */
function createSetCookieEntry(options) {
    return (
        `${options.name || ""}=${encodeURIComponent(options.value || "")}` +
        (options.expires != null ? `; Expires=${options.expires.toUTCString()}` : "") +
        (options.maxAge != null ? `; Max-Age=${options.maxAge}` : "") +
        (options.domain != null ? `; Domain=${options.domain}` : "") +
        (options.path != null ? `; Path=${options.path}` : "") +
        (options.secure ? "; Secure" : "") +
        (options.httpOnly ? "; HttpOnly" : "") +
        (options.sameSite != null ? `; SameSite=${options.sameSite}` : "")
    );
}

function stringifyCookies(cookies) {
    if (!Array.isArray(cookies)) {
        cookies = [cookies];
    }

    return cookies.map(createSetCookieEntry).join("; ");
}

module.exports = {
    parseCookies,
    stringifyCookies,
};

},{}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/apihub/utils/index.js":[function(require,module,exports){
module.exports.clone = function(data) {
    return JSON.parse(JSON.stringify(data));
}

module.exports.streams = require("./streams");
module.exports.requests = require("./requests");
module.exports.responseWrapper = require("./responseWrapper");
module.exports.getMimeTypeFromExtension = require("./mimeType");
},{"./mimeType":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/apihub/utils/mimeType.js","./requests":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/apihub/utils/requests.js","./responseWrapper":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/apihub/utils/responseWrapper.js","./streams":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/apihub/utils/streams.js"}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/apihub/utils/middlewares/index.js":[function(require,module,exports){
(function (Buffer){(function (){
const responseWrapper = require('../responseWrapper');
const logger = $$.getLogger("middlewares", "apihub/utils");

function requestBodyJSONMiddleware(request, response, next) {
    /**
     * Prepare headers for response
     */
    response.setHeader('Content-Type', 'application/json');

    const data = [];

    request.on('data', (chunk) => {
        data.push(chunk);
    });

    request.on('end', () => {
        if (!data.length) {
            request.body = {};
            return next();
        }

        let body;

        try {
            body = JSON.parse(data);
        } catch (e) {
            response.statusCode = 500;
            return response.end("Unable to decode JSON request body");
        }
        request.body = body;
        next();
    });
}

function responseModifierMiddleware(request, response, next) {
    if (!response.hasOwnProperty('send')) {
        response.send = function (statusCode, body, callback = response.end) {
            response.statusCode = statusCode;

            if (body) {
                response.write(responseWrapper(body));
            }

            callback.call(response);
            // callback();
        };
    }

    next();
}

function headersMiddleware(req, res, next) {
    res.setHeader('Access-Control-Allow-Origin', '*');

    // Request methods you wish to allow
    res.setHeader('Access-Control-Allow-Methods', 'GET, POST, OPTIONS, PUT, PATCH, DELETE');

    // Request headers you wish to allow
    res.setHeader('Access-Control-Allow-Headers', 'X-Requested-With, Content-Type, Content-Length, X-Content-Length');
    next();
}

function bodyReaderMiddleware(req, res, next) {
    const data = [];

    req.on('data', (chunk) => {
        data.push(chunk);
    });

    req.on('end', () => {
        req.body = Buffer.concat(data);
        next();
    });
}

function sendUnauthorizedResponse(req, res, reason, error) {
    logger.error(`[Auth] [${req.method}] ${req.url} blocked: ${reason}`, error);
    res.statusCode = 403;
    res.end();
}

module.exports = { requestBodyJSONMiddleware, responseModifierMiddleware, headersMiddleware , bodyReaderMiddleware, sendUnauthorizedResponse};

}).call(this)}).call(this,require("buffer").Buffer)

},{"../responseWrapper":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/apihub/utils/responseWrapper.js","buffer":false}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/apihub/utils/mimeType.js":[function(require,module,exports){
const extensionsMimeTypes = {
    "aac": {
        name: "audio/aac",
        binary: true
    },
    "abw": {
        name: "application/x-abiword",
        binary: true
    },
    "arc": {
        name: "application/x-freearc",
        binary: true
    },
    "avi": {
        name: "video/x-msvideo",
        binary: true
    },
    "azw": {
        name: "application/vnd.amazon.ebook",
        binary: true
    },
    "bin": {
        name: "application/octet-stream",
        binary: true
    }, "bmp": {
        name: "image/bmp",
        binary: true
    }, "bz": {
        name: "application/x-bzip",
        binary: true
    }, "bz2": {
        name: "application/x-bzip2",
        binary: true
    }, "csh": {
        name: "application/x-csh",
        binary: false
    }, "css": {
        name: "text/css",
        binary: false
    }, "csv": {
        name: "text/csv",
        binary: false
    }, "doc": {
        name: "application/msword",
        binary: true
    }, "docx": {
        name: "application/vnd.openxmlformats-officedocument.wordprocessingml.document",
        binary: true
    }, "eot": {
        name: "application/vnd.ms-fontobject",
        binary: true
    }, "epub": {
        name: "application/epub+zip",
        binary: true
    }, "gz": {
        name: "application/gzip",
        binary: true
    }, "gif": {
        name: "image/gif",
        binary: true
    }, "htm": {
        name: "text/html",
        binary: false
    }, "html": {
        name: "text/html",
        binary: false
    }, "ico": {
        name: "image/vnd.microsoft.icon",
        binary: true
    }, "ics": {
        name: "text/calendar",
        binary: false
    }, "jpeg": {
        name: "image/jpeg",
        binary: true
    }, "jpg": {
        name: "image/jpeg",
        binary: true
    }, "js": {
        name: "text/javascript",
        binary: false
    }, "json": {
        name: "application/json",
        binary: false
    }, "jsonld": {
        name: "application/ld+json",
        binary: false
    }, "mid": {
        name: "audio/midi",
        binary: true
    }, "midi": {
        name: "audio/midi",
        binary: true
    }, "mjs": {
        name: "text/javascript",
        binary: false
    }, "mp3": {
        name: "audio/mpeg",
        binary: true
    }, "mpeg": {
        name: "video/mpeg",
        binary: true
    }, "mpkg": {
        name: "application/vnd.apple.installer+xm",
        binary: true
    }, "odp": {
        name: "application/vnd.oasis.opendocument.presentation",
        binary: true
    }, "ods": {
        name: "application/vnd.oasis.opendocument.spreadsheet",
        binary: true
    }, "odt": {
        name: "application/vnd.oasis.opendocument.text",
        binary: true
    }, "oga": {
        name: "audio/ogg",
        binary: true
    },
    "ogv": {
        name: "video/ogg",
        binary: true
    },
    "ogx": {
        name: "application/ogg",
        binary: true
    },
    "opus": {
        name: "audio/opus",
        binary: true
    },
    "otf": {
        name: "font/otf",
        binary: true
    },
    "png": {
        name: "image/png",
        binary: true
    },
    "pdf": {
        name: "application/pdf",
        binary: true
    },
    "php": {
        name: "application/php",
        binary: false
    },
    "ppt": {
        name: "application/vnd.ms-powerpoint",
        binary: true
    },
    "pptx": {
        name: "application/vnd.openxmlformats-officedocument.presentationml.presentation",
        binary: true
    },
    "rtf": {
        name: "application/rtf",
        binary: true
    },
    "sh": {
        name: "application/x-sh",
        binary: false
    },
    "svg": {
        name: "image/svg+xml",
        binary: false
    },
    "swf": {
        name: "application/x-shockwave-flash",
        binary: true
    },
    "tar": {
        name: "application/x-tar",
        binary: true
    },
    "tif": {
        name: "image/tiff",
        binary: true
    },
    "tiff": {
        name: "image/tiff",
        binary: true
    },
    "ts": {
        name: "video/mp2t",
        binary: true
    },
    "ttf": {
        name: "font/ttf",
        binary: true
    },
    "txt": {
        name: "text/plain",
        binary: false
    },
    "vsd": {
        name: "application/vnd.visio",
        binary: true
    },
    "wav": {
        name: "audio/wav",
        binary: true
    },
    "weba": {
        name: "audio/webm",
        binary: true
    },
    "webm": {
        name: "video/webm",
        binary: true
    },
    "webp": {
        name: "image/webp",
        binary: true
    },
    "woff": {
        name: "font/woff",
        binary: true
    },
    "woff2": {
        name: "font/woff2",
        binary: true
    },
    "xhtml": {
        name: "application/xhtml+xml",
        binary: false
    },
    "xls": {
        name: "application/vnd.ms-excel",
        binary: true
    },
    "xlsx": {
        name: "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
        binary: true
    },
    "xml": {
        name: "text/xml",
        binary: false
    },
    "xul": {
        name: "application/vnd.mozilla.xul+xml",
        binary: true
    },
    "zip": {
        name: "application/zip",
        binary: true
    },
    "3gp": {
        name: "video/3gpp",
        binary: true
    },
    "3g2": {
        name: "video/3gpp2",
        binary: true
    },
    "7z": {
        name: "application/x-7z-compressed",
        binary: true
    }
};

const defaultMimeType = {
    name: "text/plain",
    binary: false
};
module.exports = function (extension) {
    if (typeof extensionsMimeTypes[extension] !== "undefined") {
        return extensionsMimeTypes[extension];
    }
    return defaultMimeType;
};
},{}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/apihub/utils/request-utils.js":[function(require,module,exports){
const logger = $$.getLogger("request-utils", "apihub/utils");

function getCurrentApiHubUrl(server) {
    const config = require("../config");
    const currentApiHubUrl = `${server.protocol}://${config.getConfig("host")}:${config.getConfig("port")}`;
    return currentApiHubUrl;
}

function getExcludedProvidersFromRequest(request) {
    let excludedProviders = request.headers["excluded-providers"];
    if (!excludedProviders) {
        return [];
    }

    excludedProviders = excludedProviders
        .split(",")
        .map((provider) => provider.trim())
        .filter((provider) => provider);
    return excludedProviders;
}

function getHeadersWithExcludedProvidersIncludingSelf(request) {
    let excludedProviders = request.headers["excluded-providers"] || "";
    if (excludedProviders) {
        excludedProviders += ",";
    }
    const currentApiHubUrl = getCurrentApiHubUrl(request.server);
    excludedProviders = `${excludedProviders}${currentApiHubUrl}`;

    return {
        "Excluded-Providers": excludedProviders,
    };
}

async function getLocalBdnsEntryListExcludingSelfAsync(request, domain, entryName) {
    const { server } = request;
    let entries;
    const code = 0x401;
    try {
        // trying to get the entries via contract call
        const entriesUrl = `/contracts/${domain}/bdns-entries/anchoringServices`;
        entries = await server.makeLocalRequestAsync("GET", entriesUrl);
    } catch (error) {
        logger.info(code, `[${entryName}] Failed to call contract to get ${entryName}. Falling back to local bdns check`);

        try {
            const bdnsUrl = `/bdns`;
            const bdns = await server.makeLocalRequestAsync("GET", bdnsUrl);
            if (bdns && bdns[domain]) {
                entries = bdns[domain][entryName];
            }
        } catch (error) {
            logger.info(code, `[${entryName}] Failed to call BDNS to get ${entryName}`);
        }
    }

    if (entries && Array.isArray(entries)) {
        // remove self url from the list
        const currentApiHubUrl = getCurrentApiHubUrl(server);
        const {host} = require("./../config/default");
        entries = entries.filter((url) =>{
            let result = false;
            if(url){
                if(url.indexOf(currentApiHubUrl) === -1){
                    result = true;
                }

                if(url.indexOf(host) === -1){
                    result = true;
                }
            }
            return result;
        });

        // remove providers specified in the Excluded-Providers headers in order to avoid cyclic calls
        const excludedProviders = getExcludedProvidersFromRequest(request);
        if (excludedProviders.length) {
            entries = entries.filter(
                (provider) => !excludedProviders.some((excludedProvider) => excludedProvider.indexOf(provider) !== -1)
            );
        }
    }

    return entries;
}

module.exports = {
    getLocalBdnsEntryListExcludingSelfAsync,
    getHeadersWithExcludedProvidersIncludingSelf,
};

},{"../config":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/apihub/config/index.js","./../config/default":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/apihub/config/default.js"}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/apihub/utils/requests.js":[function(require,module,exports){

const http = require("http");
const https = require("https");

function makeRequest(url, method = 'GET', requestData, requestOptions = {}) {
    return new Promise((resolve, reject) => {
        const myURL = new URL(url);

        const options = {
            hostname: myURL.hostname,
            path: myURL.pathname,
            protocol: myURL.protocol,
            port: myURL.port,
            method: method,
            headers: getHeaders(requestData, requestOptions.headers)
        };

        const request = (options.protocol === 'https:' ? https : http).request(options, (response) => {
            let data = [];

            response.on('data', (chunk) => {
                data.push(chunk);
            });

            response.on('end', () => {
                const stringData = $$.Buffer.concat(data).toString();

                return resolve({
                    statusCode: response.statusCode,
                    body: isJSON(stringData) ? JSON.parse(stringData) : stringData
                });
            });
        }).on("error", (err) => {
            return reject({
                statusCode: err.statusCode,
                body: err.message || 'Internal error'
            });
        });

        if ((method === 'POST' || method === 'PUT') && requestData) {
            request.write(typeof requestData === 'object' ? JSON.stringify(requestData) : requestData);
        }

        request.end();
    })
}

function isJSON(data) {
    try {
        JSON.parse(data)
    } catch (err) {
        return false;
    }

    return true;
}

function getHeaders(data, headers) {
    const dataString = data ? JSON.stringify(data) : null;
    return Object.assign({}, { 'Content-Type': 'application/json' }, dataString ? { 'Content-Length': dataString.length } : null, headers);
}

module.exports = makeRequest;

},{"http":false,"https":false}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/apihub/utils/responseWrapper.js":[function(require,module,exports){

function responseWrapper(body) {
    if (typeof body === 'string') {
        return JSON.stringify({ message: body });
    }

    return JSON.stringify(body);
}

module.exports = responseWrapper;

},{}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/apihub/utils/streams.js":[function(require,module,exports){
function readStringFromStream(stream, callback){
    let data = "";
    stream.on("data", (messagePart)=>{
        data += messagePart;
    });

    stream.on("end", ()=>{
        callback(null, data);
    });

    stream.on("error", (err)=>{
        callback(err);
    });
}

function readMessageBufferFromHTTPStream(reqORres, callback) {
    const contentType = reqORres.headers['content-type'];

    if (contentType === 'application/octet-stream') {
        const contentLength = Number.parseInt(reqORres.headers['content-length'], 10);

        if (Number.isNaN(contentLength)) {
            return callback(new Error("Wrong content length header received!"));
        }

        streamToBuffer(reqORres, contentLength, (err, bodyAsBuffer) => {
            if (err) {
                return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to convert stream to buffer`, err));
            }
            callback(undefined, bodyAsBuffer);
        });
    } else {
        callback(new Error("Wrong message format received!"));
    }

    function streamToBuffer(stream, bufferSize, callback) {
        const buffer = $$.Buffer.alloc(bufferSize);
        let currentOffset = 0;

        stream.on('data', function (chunk) {
            const chunkSize = chunk.length;
            const nextOffset = chunkSize + currentOffset;

            if (currentOffset > bufferSize - 1) {
                stream.close();
                return callback(new Error('Stream is bigger than reported size'));
            }

            write2Buffer(buffer, chunk, currentOffset);
            currentOffset = nextOffset;
            

        });
        stream.on('end', function () {
            callback(undefined, buffer);
        });
        stream.on('error', callback);
    }

    function write2Buffer(buffer, dataToAppend, offset) {
        const dataSize = dataToAppend.length;

        for (let i = 0; i < dataSize; i++) {
            buffer[offset++] = dataToAppend[i];
        }
    }
}

module.exports = {
    readStringFromStream,
    readMessageBufferFromHTTPStream
}

},{}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/bar-fs-adapter/lib/FsAdapter.js":[function(require,module,exports){
function FsAdapter() {
    const fsModule = "fs";
    const fs = require(fsModule);
    const pathModule = "path";
    const path = require(pathModule);
    const PathAsyncIterator = require('./PathAsyncIterator');

    this.getFileSize = function (filePath, callback) {
        fs.stat(filePath, (err, stats) => {
            if (err) {
                return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper("Failed to get file size", err));
            }

            callback(undefined, stats.size);
        });
    };

    this.readBlockFromFile = function (filePath, blockStart, blockEnd, callback) {
        const readStream = fs.createReadStream(filePath, {
            start: blockStart,
            end: blockEnd
        });

        let data = $$.Buffer.alloc(0);

        readStream.on("data", (chunk) => {
            data = $$.Buffer.concat([data, chunk]);
        });

        readStream.on("error", (err) => {
            return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper("Failed to read data from file " + filePath, err));
        });

        readStream.on("end", () => {
            callback(undefined, data);
        });
    };

    this.getFilesIterator = function (inputPath) {
        return new PathAsyncIterator(inputPath);
    };

    this.appendBlockToFile = function (filePath, data, callback) {
        fs.access(filePath, (err) => {
            if (err) {
                fs.mkdir(path.dirname(filePath), {recursive: true}, (err) => {
                    if (err && err.code !== "EEXIST") {
                        return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper("Failed to append block to file "+ filePath, err));
                    }

                    fs.appendFile(filePath, data, callback);
                });
            } else {
                fs.appendFile(filePath, data, callback);
            }
        });
    };
}

module.exports = FsAdapter;
},{"./PathAsyncIterator":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/bar-fs-adapter/lib/PathAsyncIterator.js"}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/bar-fs-adapter/lib/PathAsyncIterator.js":[function(require,module,exports){
function PathAsyncIterator(inputPath) {
    const fsModule = "fs";
    const fs = require(fsModule);
    const pathModule = "path";
    const path = require(pathModule);
    const TaskCounter = require("swarmutils").TaskCounter;

    inputPath = path.normalize(inputPath);
    let removablePathLen;
    const fileList = [];
    const folderList = [];
    let isFirstCall = true;
    let pathIsFolder;

    this.next = function (callback) {
        if (isFirstCall === true) {
            isDir(inputPath, (err, status) => {
                if (err) {
                    return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to check if <${inputPath}> is directory`, err));
                }

                isFirstCall = false;
                pathIsFolder = status;
                if (status === true) {
                    if(!inputPath.endsWith(path.sep)) {
                        inputPath += path.sep;
                    }

                    removablePathLen = inputPath.length;
                    folderList.push(inputPath);
                    getNextFileFromFolder(callback);
                } else {
                    const fileName = path.basename(inputPath);
                    const fileParentFolder = path.dirname(inputPath);
                    callback(undefined, fileName, fileParentFolder);
                }
            });
        } else if (pathIsFolder) {
            getNextFileFromFolder(callback);
        } else {
            callback();
        }
    };

    function walkFolder(folderPath, callback) {
        const taskCounter = new TaskCounter(() => {
            if (fileList.length > 0) {
                const fileName = fileList.shift();
                return callback(undefined, fileName, inputPath);
            }

            if (folderList.length > 0) {
                const folderName = folderList.shift();
                return walkFolder(folderName, callback);
            }

            return callback();
        });

        fs.readdir(folderPath, (err, files) => {
            if (err) {
                return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to read dir  <${folderPath}>`, err));
            }

            if (files.length === 0 && folderList.length === 0) {
                return callback();
            }

            if (files.length === 0) {
                walkFolder(folderList.shift(), callback);
            }
            taskCounter.increment(files.length);

            files.forEach(file => {
                let filePath = path.join(folderPath, file);
                isDir(filePath, (err, status) => {
                    if (err) {
                        return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to check if <${filePath}> is directory`, err));
                    }

                    if (status) {
                        folderList.push(filePath);
                    } else {
                        fileList.push(filePath.substring(removablePathLen));
                    }

                    taskCounter.decrement();
                });
            });
        });
    }

    function isDir(filePath, callback) {
        fs.stat(filePath, (err, stats) => {
            if (err) {
                return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to get stats for file <${filePath}>`, err));
            }

            return callback(undefined, stats.isDirectory());
        });
    }

    function getNextFileFromFolder(callback) {
        if (fileList.length === 0 && folderList.length === 0) {
            return callback();
        }

        if (fileList.length > 0) {
            const fileName = fileList.shift();
            return callback(undefined, fileName, inputPath);
        }

        const folder = folderList.shift();
        walkFolder(folder, (err, file) => {
            if (err) {
                return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to walk folder  <${folder}>`, err));
            }

            callback(undefined, file, inputPath);
        });
    }
}

module.exports = PathAsyncIterator;
},{"swarmutils":"swarmutils"}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/bar/lib/AnchorValidator.js":[function(require,module,exports){
'use strict'

/**
 * 
 * @param {object} options 
 * @param {object} options.rules
 * @param {object} options.rules.preWrite
 * @param {object} options.rules.afterLoad
 */
function AnchorValidator(options) {
    options = options || {};

    let validationRules = options.rules || {};

    ////////////////////////////////////////////////////////////
    // Public methods
    ////////////////////////////////////////////////////////////

    /**
     * @param {string} stage The validation stage (afterLoad, preWrite, ...)
     * @param {...} args
     */
    this.validate = (stage, ...args) => {
        const callback = args[args.length - 1];
        if (typeof validationRules[stage] !== 'object') {
            return callback();
        }

        const stageValidation = validationRules[stage];
        if (typeof stageValidation.validate !== 'function') {
            return callback(new Error('Validation rules invalid. Missing the `validate` method'));
        }
        stageValidation.validate(...args);
    }

    /**
     * @param {object} rules
     * @param {object} rules.preWrite
     * @param {object} rules.afterLoad
     */
    this.setRules = (rules) => {
        validationRules = rules;
    }
}

module.exports = AnchorValidator;
},{}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/bar/lib/Archive.js":[function(require,module,exports){
const Brick = require('./Brick');
const BrickStorageService = require('./BrickStorageService').Service;
const BrickMapController = require('./BrickMapController');
const Manifest = require("./Manifest");

/**
 * @param {ArchiveConfigurator} archiveConfigurator
 */
function Archive(archiveConfigurator) {
    const swarmutils = require("swarmutils");
    const TaskCounter = swarmutils.TaskCounter;
    const pskPth = swarmutils.path;
    const openDSU = require("opendsu");
    const anchoring = openDSU.loadAPI("anchoring");
    const anchoringx = anchoring.getAnchoringX();

    const mountedArchivesForBatchOperations = [];

    let brickMapController;
    let brickStorageService;
    let manifestHandler;
    let batchOperationsInProgress = false;
    let refreshInProgress = false;
    let refreshPromise = Promise.resolve();
    let prevAnchoringDecisionFn;
    let prevConflictResolutionFunction;

    ////////////////////////////////////////////////////////////
    // Private methods
    ////////////////////////////////////////////////////////////
    const initialize = (callback) => {
        archiveConfigurator.getKeySSI((err, keySSI) => {
            if (err) {
                return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper("Failed to retrieve keySSI", err));
            }

            brickStorageService = buildBrickStorageServiceInstance(keySSI);
            brickMapController = new BrickMapController({
                config: archiveConfigurator,
                brickStorageService,
                keySSI,
                ...archiveConfigurator.getOptions()
            });

            callback();
        });
    }

    /**
     * Create and configure the BrickStorageService
     *
     * @param {object} storageProvider
     * @return {BrickStorageService}
     */
    function buildBrickStorageServiceInstance(keySSI) {
        const instance = new BrickStorageService({
            cache: archiveConfigurator.getCache(),
            bufferSize: archiveConfigurator.getBufferSize(),
            keySSI,

            brickFactoryFunction: (encrypt) => {
                encrypt = (typeof encrypt === 'undefined') ? true : !!encrypt;
                // Strip the encryption key from the SeedSSI
                return new Brick({templateKeySSI: keySSI, encrypt});
            },

            brickDataExtractorCallback: (brickMeta, brick, callback) => {
                brick.setTemplateKeySSI(keySSI);

                function extractData() {
                    const brickEncryptionKeySSI = brickMapController.getBrickEncryptionKeySSI(brickMeta);
                    brick.setKeySSI(brickEncryptionKeySSI);
                    brick.getRawData(callback);
                }

                if (refreshInProgress) {
                    return waitIfDSUIsRefreshing(() => {
                        extractData();
                    })
                }
                extractData();
            },

            fsAdapter: archiveConfigurator.getFsAdapter()
        });

        return instance;
    }

    const cancelBatchesInMountedArchives = (callback) => {
        const cancelBatch = (dossierContext) => {
            if (!dossierContext) {
                return callback();
            }

            dossierContext.archive.cancelBatch((err) => {
                if (err) {
                    return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper("Failed to cancel batch operation", err));
                }

                cancelBatch(mountedArchivesForBatchOperations.pop());
            })
        }

        cancelBatch(mountedArchivesForBatchOperations.pop());
    }

    const commitBatchesInMountedArchives = (onConflict, callback) => {
        const results = [];

        const commitBatch = (dossierContext) => {
            if (!dossierContext) {
                return callback(undefined, results);
            }

            dossierContext.archive.commitBatch(onConflict, (err, result) => {
                if (err) {
                    return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper("Failed to commit batch", err));
                }

                results.push(result);
                commitBatch(mountedArchivesForBatchOperations.pop());
            });
        }

        commitBatch(mountedArchivesForBatchOperations.pop());
    }

    /**
     * This function waits for an existing "refresh" operation to finish
     * before executing the `callback`.
     * If no refresh operation is in progress, the `callback` is executed
     * immediately.
     * This function is called by the public methods in order to prevent
     * calling methods on an uninitialized brickMapController instance
     *
     * @param {function} callback
     */
    const waitIfDSUIsRefreshing = (callback) => {
        if (refreshInProgress === false) {
            return callback();
        }

        refreshPromise.then(() => {
            callback();
        })
    }

    const getArchiveForBatchOperations = (manifestHandler, path, callback) => {
        manifestHandler.getArchiveForPath(path, (err, result) => {
            if (err) {
                return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to load DSU instance mounted at path ${path}`, err));
            }

            if (result.archive === this) {
                return callback(undefined, result);
            }

            result.archive.getKeySSIAsString((err, keySSI) => {
                if (err) {
                    return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper("Failed to retrieve keySSI", err));
                }

                const cachedArchive = mountedArchivesForBatchOperations.find((archive) => {
                    return archive.identifier === keySSI;
                });

                if (cachedArchive) {
                    cachedArchive.relativePath = result.relativePath;
                    return callback(undefined, cachedArchive);
                }

                result.identifier = keySSI;
                result.archive.beginBatch();
                mountedArchivesForBatchOperations.push(result);
                callback(undefined, result);
            });
        });
    };

    ////////////////////////////////////////////////////////////
    // Public methods
    ////////////////////////////////////////////////////////////
    /**
     * @param {callback} callback
     */
    this.init = (callback) => {
        initialize((err) => {
            if (err) {
                return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper("Failed to initialize DSU", err));
            }

            brickMapController.init(callback);
        });
    }

    /**
     * @param {callback} callback
     */
    this.load = (callback) => {
        initialize((err) => {
            if (err) {
                return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper("Failed to initialise DSU", err));
            }

            brickMapController.load(callback);
        });
    };

    this.hasNewVersion = (callback) => {
        this.getLatestAnchoredHashLink((err, latestAnchoredHashLink) => {
            if (err) {
                return callback(err);
            }
            let latestAnchor = latestAnchoredHashLink ? latestAnchoredHashLink.getIdentifier() : "UNDEFINED1";
            let fromNetwork = this.getAnchoringStrategy().getCurrentHashLink(); 
            fromNetwork =  fromNetwork ? fromNetwork.getIdentifier() : " UNDEFINED2";
            return callback(undefined, fromNetwork !== latestAnchor );
        })
    }

    this.loadVersion = (versionHash, callback) => {
        initialize((err) => {
            if (err) {
                return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper("Failed to initialise DSU", err));
            }
            brickMapController.loadVersion(versionHash, callback);
        });
    };

    this.getBrickMapController = () => {
        return brickMapController;
    }
    /**
     * @param {callback} callback
     */
    this.refresh = (callback) => {
        this.getLatestAnchoredHashLink((err, latestAnchoredHashlink) => {
            if (err || !latestAnchoredHashlink) {
                return callback()
            }

            waitIfDSUIsRefreshing(() => {
                refreshInProgress = true;
                refreshPromise = refreshPromise.then(() => {
                    return new Promise((resolve) => {
                        this.load((err) => {
                            if (err) {
                                refreshInProgress = false;
                                return resolve(OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper("Failed to load DSU", err)));
                            }

                            resolve(callback());
                        });
                    }).catch(() => {
                        console.trace("This shouldn't happen. Refresh errors should have been already caught");
                    })
                })
            });
        })
    }

    /**
     * Returns the latest anchor
     *
     * @param {callback} function
     * @return {HashLinkSSI}
     */
    this.getLastHashLinkSSI = (callback) => {
        console.log("This method is obsolete. Please use `dsu.getLatestAnchoredHashLink()` instead.");
        return this.getLatestAnchoredHashLink(callback);
    };

    /**
     * Returns the latest anchored Hashlink
     *
     * @param {callback} function
     * @return {HashLinkSSI}
     */
    this.getLatestAnchoredHashLink = (callback) => {
        archiveConfigurator.getKeySSI((err, keySSI) => {
            if (err) {
                return callback(createOpenDSUErrorWrapper("Failed to get KeySSI", err));
            }
            anchoringx.getLastVersion(keySSI, (err, latestHashLink) => {
                if (err || !latestHashLink) {
                    return callback(createOpenDSUErrorWrapper("Failed to get the list of hashlinks", err));
                }

                const keySSISpace = require("opendsu").loadAPI("keyssi");
                if (typeof latestHashLink === "string") {
                    try {
                        latestHashLink = keySSISpace.parse(latestHashLink);
                    } catch (e) {
                        return callback(createOpenDSUErrorWrapper("Failed to get the list of hashlinks", e));
                    }
                }
                return callback(undefined, latestHashLink)
            })
        })
    }

    /**
     * Returns the current anchor
     *
     * @return {HashLinkSSI}
     */
    this.getCurrentAnchoredHashLink = (callback) => {
        return waitIfDSUIsRefreshing(() => {
            return callback(undefined, brickMapController.getCurrentAnchoredHashLink());
        })
    }

    /**
     * @return {string}
     */
    this.getKeySSI = (keySSIType, callback) => {
        console.trace("Obsolete function: use getKeySSIAsString or getKeySSIAsObject Instead");
        if (typeof keySSIType === "function") {
            callback = keySSIType;
            keySSIType = undefined;
        }
        return archiveConfigurator.getKeySSI(keySSIType, ((err, keySSI) => callback(err, keySSI.getIdentifier())));
    }

    /**
     * @return {string}
     */
    this.getKeySSIAsObject = (keySSIType, callback) => {
        if (typeof keySSIType === "function") {
            callback = keySSIType;
            keySSIType = undefined;
        }
        archiveConfigurator.getKeySSI(keySSIType, callback);
    }

    this.getKeySSIAsObjectSync = () => {
        return archiveConfigurator.getKeySSISync();
    }
    /**
     * @return {string}
     */
    this.getKeySSIAsString = (keySSIType, callback) => {
        if (typeof keySSIType === "function") {
            callback = keySSIType;
            keySSIType = undefined;
        }
        archiveConfigurator.getKeySSI(keySSIType, ((err, keySSI) => callback(err, keySSI.getIdentifier())));
    }

    this.getKeySSIAsStringSync = () => {
        return this.getKeySSIAsObjectSync().getIdentifier();
    }

    /**
     * @return {string}
     */
    this.getCreationSSI = (plain) => {
        return archiveConfigurator.getCreationSSI(plain);
    }

    this.getUniqueIdAsync = async () => {
        let keySSI = await $$.promisify(this.getKeySSIAsObject)();
        return await keySSI.getAnchorIdAsync();
    }

    this.getAnchorIdSync = () => {
        return this.getKeySSIAsObjectSync().getAnchorIdSync();
    }

    /**
     * @return {string}
     */
    this.getAnchorId = (callback) => {
        this.getKeySSIAsObject((err, keySSIInstance) => {
            if (err) {
                return callback(createOpenDSUErrorWrapper(`Failed to get keySSI`, err));
            }

            keySSIInstance.getAnchorId(callback);
        });
    }

    const _fileIsEmbedded = (barPath, callback) => {
        brickMapController.fileIsEmbedded(barPath, callback);
    };

    const _ingestData = (barPath, data, options, callback) => {
        brickStorageService.ingestData(data, options, callback)
    }

    const _embedFile = (barPath, data, options, callback) => {
        brickStorageService.createEmbedSSIFromData(data, options, (err, result) => {
            if (err) {
                return callback(createOpenDSUErrorWrapper(`Failed to embed file ${barPath}`, err));
            }

            brickMapController.addFile(barPath, result, callback);
        })
    }

    /**
     * @param {string} barPath
     * @param {string|$$.Buffer|stream.ReadableStream} data
     * @param {object} options
     * @param {callback} callback
     */
    const _writeFile = (barPath, data, options, callback) => {
        barPath = pskPth.normalize(barPath);

        if (typeof data === "undefined") {
            return _createFile(barPath, callback);
        }

        if (options.embed) {
            return brickMapController.embedData(barPath, data, options, callback);
        }

        _fileIsEmbedded(barPath, (err, fileIsEmbedded) => {
            if (err) {
                return callback(err);
            }

            if (fileIsEmbedded) {
                return brickMapController.embedData(barPath, data, options, callback);
            }

            _ingestData(barPath, data, options, (err, result) => {
                if (err) {
                    return callback(err);
                }
                brickMapController.addFile(barPath, result, callback);

            });
        });
    };

    const _appendToFile = (barPath, data, options, callback) => {
        barPath = pskPth.normalize(barPath);

        if (options.embed) {
            return brickMapController.appendToEmbeddedFile(barPath, data, options, callback);
        }

        _fileIsEmbedded(barPath, (err, fileIsEmbedded) => {
            if (err) {
                return callback(err);
            }

            if (fileIsEmbedded) {
                return brickMapController.appendToEmbeddedFile(barPath, data, options, callback);
            }

            _ingestData(barPath, data, options, (err, result) => {
                if (err) {
                    return callback(err);
                }

                brickMapController.appendToFile(barPath, result, callback);
            });
        });
    };

    /**
     * @param {string} barPath
     * @param {object[]} bricks
     * @param {callback} callback
     */
    const _writeFileFromBricks = (barPath, bricks, callback) => {
        barPath = pskPth.normalize(barPath);
        brickMapController.addFile(barPath, bricks, callback);
    };

    /**
     * @param {sizeSSI} sizeSSI
     */
    const _isAvailableSpaceInLastBrick = (sizeSSI) => {
        if (typeof sizeSSI === "string") {
            const keySSISpace = require("opendsu").loadAPI("keyssi");
            sizeSSI = keySSISpace.parse(sizeSSI);
        }
        const totalSize = sizeSSI.getTotalSize();
        const bufferSize = sizeSSI.getBufferSize();
        return totalSize % bufferSize !== 0;
    };

    /**
     * @param {string} barPath
     * @param {object} newSizeSSI
     * @param {object} brick
     * @param {callback} callback
     */
    const _appendBigFileBrick = (barPath, newSizeSSI, brick, callback) => {
        _getBigFileBricksMeta(barPath, (error, bricksMeta) => {
            if (error) {
                return callback(error);
            }

            if (!_isSizeSSIPresentInBricksMetaAndIsValid(bricksMeta)) {
                return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Provided path ${barPath} is not a BigFile`));
            }

            // check using the current sizeSSI if there is available space inside the last brick
            if (_isAvailableSpaceInLastBrick(bricksMeta[0].size)) {
                return brickMapController.updateBigFileLastBrick(barPath, newSizeSSI, brick, callback);
            }
            return brickMapController.appendBigFile(barPath, newSizeSSI, brick, callback);
        });
    };

    /**
     * @param {string} barPath
     * @param {callback} callback
     */
    const _getBigFileBricksMeta = (barPath, callback) => {
        barPath = pskPth.normalize(barPath);
        try {
            const bricksMeta = brickMapController.getBricksMeta(barPath);
            callback(null, bricksMeta);
        } catch (err) {
            return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper("Failed to find any info for path " + barPath, err));
        }
    };

    /**
     * @param {object} bricksMeta
     */
    const _isSizeSSIPresentInBricksMeta = (bricksMeta) => {
        return !!bricksMeta && !!bricksMeta[0] && !!bricksMeta[0].size;
    }

    const _isSizeSSIValid = (sizeSSI) => {
        try {
            const keySSISpace = require("opendsu").loadAPI("keyssi");
            keySSISpace.parse(sizeSSI);
            return true;
        } catch (error) {
            return false;
        }
    }

    const _isSizeSSIPresentInBricksMetaAndIsValid = (bricksMeta) => {
        if (!_isSizeSSIPresentInBricksMeta(bricksMeta)) {
            return false;
        }

        return _isSizeSSIValid(bricksMeta[0].size);
    }

    /**
     * @param {string} barPath
     * @param {callback} callback
     */
    const _readFile = (barPath, callback) => {
        barPath = pskPth.normalize(barPath);

        let bricksMeta;
        let embeddedData;
        try {
            embeddedData = brickMapController.getEmbeddedFile(barPath);
        } catch (e) {
            return callback(e);
        }

        if (typeof embeddedData !== "undefined") {
            return callback(undefined, embeddedData);
        }

        try {
            bricksMeta = brickMapController.getBricksMeta(barPath);
        } catch (err) {
            return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper("Failed to find any info for path " + barPath + " in brickmap", err));
        }

        if (_isSizeSSIPresentInBricksMeta(bricksMeta)) {
            return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to read big file as normal file for path ${barPath}`));
        }

        brickStorageService.createBufferFromBricks(bricksMeta, (err, buffer) => {
            if (err) {
                return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper("Failed to create buffer from bricks", err));
            }

            callback(undefined, buffer);
        });
    };

    /**
     * @param {string} barPath
     * @param {callback} callback
     */
    const _createReadStream = (barPath, callback) => {
        barPath = pskPth.normalize(barPath);

        let bricksMeta;
        try {
            bricksMeta = brickMapController.getBricksMeta(barPath);
        } catch (err) {
            return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper("Failed to find any info for path " + barPath, err));
        }

        if (_isSizeSSIPresentInBricksMeta(bricksMeta)) {
            return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to read big file as normal file for path ${barPath}`));
        }

        brickStorageService.createStreamFromBricks(bricksMeta, (err, stream) => {
            if (err) {
                return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper("Failed to create stream from bricks", err));
            }

            callback(undefined, stream);
        });
    };

    /**
     * @param {string} barPath
     * @param {callback} callback
     */
    const _createBigFileReadStreamWithRange = (barPath, range, callback) => {
        barPath = pskPth.normalize(barPath);

        let bricksMeta;
        try {
            bricksMeta = brickMapController.getBricksMeta(barPath);
        } catch (err) {
            return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper("Failed to find any info for path " + barPath, err));
        }

        if (!bricksMeta || !bricksMeta.length) {
            return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper("Failed to find any info for path " + barPath));
        }

        if (!bricksMeta[0].size) {
            return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Cannot stream path ${barPath} since it's not a BigFile`));
        }

        let sizeSSI;
        try {
            const keySSISpace = require("opendsu").loadAPI("keyssi");
            sizeSSI = keySSISpace.parse(bricksMeta[0].size);
        } catch (e) {
            return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`The provided keyssi is not a valid SSI string.`, e));
        }

        let canCreateStream = !!sizeSSI && !!sizeSSI.isSizeSSI && sizeSSI.isSizeSSI();
        if (!canCreateStream) {
            return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Cannot stream path ${barPath} since it's not a BigFile`));
        }

        bricksMeta = bricksMeta.slice(1); // remove SizeSSI from bricksMeta
        brickStorageService.createStreamFromBricksWithRange(sizeSSI, bricksMeta, range, (err, stream) => {
            if (err) {
                return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper("Failed to create stream from bricks", err));
            }

            callback(undefined, {totalSize: sizeSSI.getTotalSize(), stream});
        });
    };

    /**
     * @param {string} fsFilePath
     * @param {string} barPath
     * @param {object} options
     * @param {callback} callback
     */
    const _addFile = (fsFilePath, barPath, options, callback) => {
        if (typeof options === "function") {
            callback = options;
            options = {
                encrypt: true
            }
        }

        barPath = pskPth.normalize(barPath);

        brickStorageService.ingestFile(fsFilePath, options, (err, result) => {
            if (err) {
                return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper("Failed to ingest data into bricks storage", err));
            }

            brickMapController.addFile(barPath, result, callback);
        })
    };

    /**
     * @param {string} files
     * @param {string} barPath
     * @param {object} options
     * @param {callback} callback
     */
    const _addFiles = (files, barPath, options, callback) => {
        if (typeof options === "function") {
            callback = options;
            options = {
                encrypt: true,
                embedded: false
            };
        }

        barPath = pskPth.normalize(barPath);

        const filesArray = files.slice();

        const ingestionMethod = (!options.embedded) ? 'ingestFiles' : 'createBrickFromFiles';

        brickStorageService[ingestionMethod](filesArray, options, (err, result) => {
            if (err) {
                return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper("Failed to add files at path " + barPath, err));
            }

            brickMapController.addFiles(barPath, result, callback);
        });
    };

    this.addFiles = (files, barPath, options, callback) => {
        waitIfDSUIsRefreshing(() => {
            if (typeof options === "function") {
                callback = options;
                options = {
                    encrypt: true,
                    ignoreMounts: false,
                    embedded: false
                };
            }

            if (options.ignoreMounts === true) {
                _addFiles(files, barPath, options, callback);
            } else {
                this.getArchiveForPath(barPath, (err, dossierContext) => {
                    if (err) {
                        return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to load DSU instance mounted at path ${barPath}`, err));
                    }

                    options.ignoreMounts = true;
                    dossierContext.archive.addFiles(files, dossierContext.relativePath, options, callback);
                });
            }
        })
    }

    /**
     * @param {string} fsFilePath
     * @param {string} barPath
     * @param {callback} callback
     */
    const _extractFile = (fsFilePath, barPath, callback) => {
        if (typeof barPath === "function") {
            callback = barPath;
            barPath = pskPth.normalize(fsFilePath);
        }

        let bricksMeta;

        try {
            bricksMeta = brickMapController.getBricksMeta(barPath);
        } catch (err) {
            return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper("Failed to any information for path " + barPath, err));
        }


        brickStorageService.createFileFromBricks(fsFilePath, bricksMeta, callback);
    };

    /**
     * @param {string} barPath
     * @param {string|$$.Buffer|stream.ReadableStream} data
     * @param {callback} callback
     */
    this.appendToFile = (barPath, data, options, callback) => {
        waitIfDSUIsRefreshing(() => {
            const defaultOpts = {encrypt: true, ignoreMounts: false};
            if (typeof options === "function") {
                callback = options;
                options = {};
            }

            Object.assign(defaultOpts, options);
            options = defaultOpts;

            if (options.ignoreMounts) {
                barPath = pskPth.normalize(barPath);
                _appendToFile(barPath, data, options, callback);
            } else {
                this.getArchiveForPath(barPath, (err, dossierContext) => {
                    if (err) {
                        return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to load DSU instance mounted at path ${barPath}`, err));
                    }
                    if (dossierContext.readonly === true) {
                        return callback(Error("Tried to write in a readonly mounted RawDossier"));
                    }

                    options.ignoreMounts = true;
                    dossierContext.archive.appendToFile(dossierContext.relativePath, data, options, callback);
                });
            }
        })
    };


    this.dsuLog = (message, callback) => {
        waitIfDSUIsRefreshing(() => {
            this.appendToFile("/dsu-metadata-log", message + "\n", {ignoreMissing: true}, callback);
        })
    }
    /**
     * @param {string} fsFolderPath
     * @param {string} barPath
     * @param {object} options
     * @param {callback} callback
     */
    const _addFolder = (fsFolderPath, barPath, options, callback) => {
        if (typeof options === "function") {
            callback = options;
            options = {
                encrypt: true,
                embedded: false
            };
        }
        barPath = pskPth.normalize(barPath);

        const ingestionMethod = (!options.embedded) ? 'ingestFolder' : 'createBrickFromFolder';

        brickStorageService[ingestionMethod](fsFolderPath, options, (err, result) => {
            if (err) {
                return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to add folder ${fsFolderPath} to  ${barPath}`, err));
            }

            brickMapController.addFiles(barPath, result, callback);
        });
    };

    /**
     * @param {string} fsFolderPath
     * @param {string} barPath
     * @param {callback} callback
     */
    const _extractFolder = (fsFolderPath, barPath, callback) => {
        if (typeof barPath === "function") {
            callback = barPath;
            barPath = pskPth.normalize(fsFolderPath);
        }

        const filePaths = brickMapController.getFileList(barPath);
        const taskCounter = new TaskCounter(() => {
            callback();
        });
        taskCounter.increment(filePaths.length);
        filePaths.forEach(filePath => {
            let actualPath;
            if (fsFolderPath) {
                if (fsFolderPath.includes(filePath)) {
                    actualPath = fsFolderPath;
                } else {
                    actualPath = require("path").join(fsFolderPath, filePath);
                }
            } else {
                actualPath = filePath;
            }

            this.extractFile(actualPath, filePath, (err) => {
                if (err) {
                    return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to extract file ${actualPath} to ${filePath}`, err));
                }

                taskCounter.decrement();
            });
        });
    };

    /**
     * @param {string} barPath
     * @param {callback} callback
     */
    const _delete = (barPath, callback) => {
        brickMapController.deleteFile(barPath, callback);
        //this resets the state in case a folder gets removed and under the same path are other dsu mounted.
        manifestHandler = undefined;
    };

    /**
     * @param {string} srcPath
     * @param {dstPath} dstPath
     */

    const _rename = (srcPath, dstPath, callback) => {
        srcPath = pskPth.normalize(srcPath);
        dstPath = pskPth.normalize(dstPath);

        brickMapController.renameFile(srcPath, dstPath, callback);
    }

    /**
     * @param {string} folderBarPath
     * @param {object} options
     * @param {function} callback
     */
    const _listFiles = (folderBarPath, options, callback) => {
        if (typeof options === "function") {
            callback = options;
            options = {recursive: true};
        } else if (typeof folderBarPath === "function") {
            callback = folderBarPath;
            options = {recursive: true};
            folderBarPath = "/";
        }

        let fileList;
        let error;
        try {
            fileList = brickMapController.getFileList(folderBarPath, options.recursive);
        } catch (e) {
            error = e;
        }

        setTimeout(() => {
            callback(error, fileList);
        }, 0)
    };

    const _listMountedFiles = (mountPoints, result, callback) => {
        if (typeof result === 'function') {
            callback = result;
            result = [];
        }
        let mountPoint = mountPoints.shift();

        if (!mountPoint) {
            return callback(undefined, result)
        }

        mountPoint = pskPth.normalize(mountPoint);

        this.listFiles(mountPoint, {
            recursive: true,
            ignoreMounts: false
        }, (err, files) => {
            if (err) {
                return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to list files at path ${mountPoint}`, err));
            }

            result.push(files.map((file) => {
                let prefix = mountPoint;
                if (prefix[0] === '/') {
                    prefix = prefix.substring(1);
                }

                return pskPth.normalize(`${prefix}/${file}`);
            }));

            _listMountedFiles(mountPoints, result, callback);
        });
    };

    /**
     * @param {string} folderBarPath
     * @param {object} options
     * @param {boolean} options.recursive
     * @param {callback} callback
     */
    const _listFolders = (folderBarPath, options, callback) => {
        if (typeof options === "function") {
            callback = options;
            options = {recursive: true};
        }

        callback(undefined, brickMapController.getFolderList(folderBarPath, options.recursive));
    };

    const _listMountedFolders = (mountPoints, result, callback) => {
        if (typeof result === 'function') {
            callback = result;
            result = [];
        }

        let mountPoint = mountPoints.shift();
        if (!mountPoint) {
            return callback(undefined, result);
        }

        mountPoint = pskPth.normalize(mountPoint);

        this.listFolders(mountPoint, {
            recursive: true,
            ignoreMounts: false
        }, (err, folders) => {
            if (err) {
                return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to list mounted folders at path ${mountPoint}`, err));
            }

            result.push((folders.map((folder) => {
                let prefix = mountPoint;
                if (prefix[0] === '/') {
                    prefix = prefix.substring(1);
                }

                return pskPth.normalize(`${prefix}/${folder}`);
            })));

            _listMountedFolders(mountPoints, result, callback);
        })
    };

    /**
     * @param {string} barPath
     * @param {callback} callback
     */
    const _createFolder = (barPath, callback) => {
        brickMapController.createDirectory(barPath, callback);
    };

    const _createFile = (barPath, callback) => {
        brickMapController.createEmptyFile(barPath, callback);
    };

    /**
     * @param {object} rules
     * @param {object} rules.preWrite
     * @param {object} rules.afterLoad
     */
    this.setValidationRules = (rules) => {
        brickMapController.setValidationRules(rules);
    }

    /**
     * @param {callback} listener
     */
    this.setAnchoringEventListener = (listener) => {
        this.getAnchoringStrategy().setAnchoringEventListener(listener);
    }

    /**
     * @param {callback} callback
     */
    this.setDecisionCallback = (callback) => {
        this.getAnchoringStrategy().setDecisionCallback(callback);
    }

    /**
     * @return {AnchoringStrategy}
     */
    this.getAnchoringStrategy = () => {
        return archiveConfigurator.getBrickMapStrategy();
    }

    /**
     * Manually anchor any changes
     */
    this.doAnchoring = (callback) => {
        const strategy = this.getAnchoringStrategy();
        let alreadyCalled = false;
        let saneCallback = function (err) {
            if (alreadyCalled) {
                throw Error("Already called");
            }

            if (err) {
                return callback(err);
            }

            return callback();
        }
        const anchoringEventListener = strategy.getAnchoringEventListener() || saneCallback;
        if (typeof anchoringEventListener !== 'function') {
            throw new Error('An anchoring event listener is required');
        }

        brickMapController.anchorChanges(anchoringEventListener);
    }

    const getManifest = (callback) => {
        let options = archiveConfigurator.getOptions();
        const defaultOptions = {skipCache: archiveConfigurator.dsuCachingEnabled()};
        options = Object.assign(defaultOptions, options);
        if (typeof manifestHandler === "undefined") {
            Manifest.getManifest(this, options, (err, handler) => {
                if (err) {
                    return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to get manifest handler`, err));
                }

                manifestHandler = handler;
                return callback(undefined, manifestHandler);
            });
        } else {
            return callback(undefined, manifestHandler);
        }
    }

    this.getSSIForMount = (mountPoint, callback) => {
        getManifest((err, manifestHandler) => {
            if (err) {
                return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper("Failed to load manifest for " + mountPoint, err));
            }
            manifestHandler.getArchiveIdentifier(mountPoint, callback);
        });
    }

    this.addFolder = (fsFolderPath, barPath, options, callback) => {
        waitIfDSUIsRefreshing(() => {
            const defaultOpts = {encrypt: true, ignoreMounts: false, embedded: false};
            if (typeof options === "function") {
                callback = options;
                options = {};
            }
            callback = $$.makeSaneCallback(callback);
            Object.assign(defaultOpts, options);
            options = defaultOpts;


            if (options.ignoreMounts === true) {
                _addFolder(fsFolderPath, barPath, options, callback);
            } else {
                this.getArchiveForPath(barPath, (err, result) => {
                    if (err) {
                        return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to load DSU instance mounted at path ${barPath}`, err));
                    }

                    options.ignoreMounts = true;
                    result.archive.addFolder(fsFolderPath, result.relativePath, options, callback);
                });
            }

        })
    };

    this.addFile = (fsFilePath, barPath, options, callback) => {
        waitIfDSUIsRefreshing(() => {
            const defaultOpts = {encrypt: true, ignoreMounts: false};
            if (typeof options === "function") {
                callback = options;
                options = {};
            }

            callback = $$.makeSaneCallback(callback);
            Object.assign(defaultOpts, options);
            options = defaultOpts;

            if (options.ignoreMounts === true) {
                _addFile(fsFilePath, barPath, options, callback);
            } else {
                this.getArchiveForPath(barPath, (err, result) => {
                    if (err) {
                        return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to load DSU instance mounted at path ${barPath}`, err));
                    }

                    options.ignoreMounts = true;
                    result.archive.addFile(fsFilePath, result.relativePath, options, callback);
                });
            }
        })
    };

    this.readFile = (fileBarPath, options, callback) => {
        waitIfDSUIsRefreshing(() => {
            const defaultOpts = {ignoreMounts: false};
            if (typeof options === "function") {
                callback = options;
                options = {};
            }

            callback = $$.makeSaneCallback(callback);
            Object.assign(defaultOpts, options);
            options = defaultOpts;
            if (options.ignoreMounts === true) {
                _readFile(fileBarPath, callback);
            } else {
                this.getArchiveForPath(fileBarPath, (err, result) => {
                    if (err) {
                        return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to load DSU instance mounted at path ${fileBarPath}`, err));
                    }

                    options.ignoreMounts = true
                    result.archive.readFile(result.relativePath, options, callback);
                });
            }
        })
    };

    this.createReadStream = (fileBarPath, options, callback) => {
        waitIfDSUIsRefreshing(() => {
            const defaultOpts = {encrypt: true, ignoreMounts: false};
            if (typeof options === "function") {
                callback = options;
                options = {};
            }

            callback = $$.makeSaneCallback(callback);
            Object.assign(defaultOpts, options);
            options = defaultOpts;
            if (options.ignoreMounts === true) {
                _createReadStream(fileBarPath, callback);
            } else {
                this.getArchiveForPath(fileBarPath, (err, result) => {
                    if (err) {
                        return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to load DSU instance mounted at path ${fileBarPath}`, err));
                    }

                    options.ignoreMounts = true;
                    result.archive.createReadStream(result.relativePath, options, callback);
                });
            }
        })
    };

    this.createBigFileReadStreamWithRange = (fileBarPath, range, options, callback) => {
        waitIfDSUIsRefreshing(() => {
            const defaultOpts = {encrypt: true, ignoreMounts: false};
            if (typeof options === "function") {
                callback = options;
                options = {};
            }
            if (typeof range === "function") {
                callback = range;
                range = {start: 0};
                options = {};
            }

            callback = $$.makeSaneCallback(callback);
            Object.assign(defaultOpts, options);
            options = defaultOpts;
            if (options.ignoreMounts === true) {
                _createBigFileReadStreamWithRange(fileBarPath, range, callback);
            } else {
                this.getArchiveForPath(fileBarPath, (err, result) => {
                    if (err) {
                        return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to load DSU instance mounted at path ${fileBarPath}`, err));
                    }

                    options.ignoreMounts = true;
                    result.archive.createBigFileReadStreamWithRange(result.relativePath, range, options, callback);
                });
            }
        })
    };

    this.extractFolder = (fsFolderPath, barPath, options, callback) => {
        waitIfDSUIsRefreshing(() => {
            const defaultOpts = {ignoreMounts: false};
            if (typeof options === "function") {
                callback = options;
                options = {};
            }

            callback = $$.makeSaneCallback(callback);
            Object.assign(defaultOpts, options);
            options = defaultOpts;
            if (options.ignoreMounts === true) {
                _extractFolder(fsFolderPath, barPath, callback);
            } else {
                this.getArchiveForPath(barPath, (err, result) => {
                    if (err) {
                        return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to load DSU instance mounted at path ${barPath}`, err));
                    }

                    options.ignoreMounts = true;
                    result.archive.extractFolder(fsFolderPath, result.relativePath, options, callback);
                });
            }
        })
    };

    this.extractFile = (fsFilePath, barPath, options, callback) => {
        waitIfDSUIsRefreshing(() => {
            const defaultOpts = {ignoreMounts: false};
            if (typeof options === "function") {
                callback = options;
                options = {};
            }

            callback = $$.makeSaneCallback(callback);
            Object.assign(defaultOpts, options);
            options = defaultOpts;

            if (options.ignoreMounts === true) {
                _extractFile(fsFilePath, barPath, callback);
            } else {
                this.getArchiveForPath(barPath, (err, result) => {
                    if (err) {
                        return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to load DSU instance mounted at path ${barPath}`, err));
                    }

                    options.ignoreMounts = true;
                    result.archive.extractFile(fsFilePath, result.relativePath, options, callback);
                });
            }
        })
    };

    this.writeFile = (path, data, options, callback) => {
        waitIfDSUIsRefreshing(() => {
            const defaultOpts = {encrypt: true, ignoreMounts: false, embed: false};
            if (typeof data === "function") {
                callback = data;
                data = undefined;
                options = undefined;
            }
            if (typeof options === "function") {
                callback = options;
                options = defaultOpts;
            }
            if (typeof options === "undefined") {
                options = defaultOpts;
            }

            callback = $$.makeSaneCallback(callback);

            Object.assign(defaultOpts, options);
            options = defaultOpts;
            if (options.embed) {
                options.encrypt = false;
            }

            if (options.ignoreMounts === true) {
                _writeFile(path, data, options, callback);
            } else {
                this.getArchiveForPath(path, (err, dossierContext) => {
                    if (err) {
                        return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to load DSU instance mounted at path ${path}`, err));
                    }
                    if (dossierContext.readonly === true) {
                        return callback(Error("Tried to write in a readonly mounted RawDossier"));
                    }

                    options.ignoreMounts = true;
                    dossierContext.archive.writeFile(dossierContext.relativePath, data, options, callback);
                });
            }
        })
    };

    this.embedFile = (path, data, options, callback) => {
        waitIfDSUIsRefreshing(() => {
            const defaultOpts = {encrypt: true, ignoreMounts: false};
            if (typeof data === "function") {
                callback = data;
                data = undefined;
                options = undefined;
            }
            if (typeof options === "function") {
                callback = options;
                options = {
                    encrypt: true
                };
            }
            if (typeof options === "undefined") {
                options = {
                    encrypt: true
                };
            }

            callback = $$.makeSaneCallback(callback);

            Object.assign(defaultOpts, options);
            options = defaultOpts;

            if (options.ignoreMounts === true) {
                _embedFile(path, data, options, callback);
            } else {
                this.getArchiveForPath(path, (err, dossierContext) => {
                    if (err) {
                        return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to load DSU instance mounted at path ${path}`, err));
                    }
                    if (dossierContext.readonly === true) {
                        return callback(Error("Tried to write in a readonly mounted RawDossier"));
                    }

                    options.ignoreMounts = true;
                    dossierContext.archive.embedFile(dossierContext.relativePath, data, options, callback);
                });
            }
        })
    };

    this.writeFileFromBricks = (path, bricks, options, callback) => {
        waitIfDSUIsRefreshing(() => {
            const defaultOpts = {ignoreMounts: false};
            if (typeof options === "function") {
                callback = options;
                options = {};
            }
            if (typeof options === "undefined") {
                options = {};
            }

            callback = $$.makeSaneCallback(callback);
            if (typeof path !== "string") {
                return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper("Provided path for writeFileFromBricks must be a string"));
            }
            if (!Array.isArray(bricks) || !_isSizeSSIPresentInBricksMetaAndIsValid(bricks)) {
                return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper("Provided bricks for writeFileFromBricks must be an array of a single sizeSSI and multiple hashlinks"));
            }

            Object.assign(defaultOpts, options);
            options = defaultOpts;

            if (options.ignoreMounts === true) {
                _writeFileFromBricks(path, bricks, callback);
            } else {
                this.getArchiveForPath(path, (err, dossierContext) => {
                    if (err) {
                        return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to load DSU instance mounted at path ${path}`, err));
                    }
                    if (dossierContext.readonly === true) {
                        return callback(Error("Tried to write in a readonly mounted RawDossier"));
                    }

                    options.ignoreMounts = true;
                    dossierContext.archive.writeFileFromBricks(dossierContext.relativePath, bricks, options, callback);
                });
            }
        });
    }

    this.appendBigFileBrick = (path, newSizeSSI, brick, options, callback) => {
        waitIfDSUIsRefreshing(() => {
            const defaultOpts = {ignoreMounts: false};
            if (typeof options === "function") {
                callback = options;
                options = {};
            }
            if (typeof options === "undefined") {
                options = {};
            }

            callback = $$.makeSaneCallback(callback);
            if (typeof path !== "string") {
                return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper("Provided path for appendBigFileBrick must be a string"));
            }
            if (!newSizeSSI || !_isSizeSSIValid(newSizeSSI)) {
                return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper("Provided newSizeSSI is not a valid sizeSSI"));
            }

            Object.assign(defaultOpts, options);
            options = defaultOpts;

            if (options.ignoreMounts === true) {
                _appendBigFileBrick(path, newSizeSSI, brick, callback);
            } else {
                this.getArchiveForPath(path, (err, dossierContext) => {
                    if (err) {
                        return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to load DSU instance mounted at path ${path}`, err));
                    }
                    if (dossierContext.readonly === true) {
                        return callback(Error("Tried to write in a readonly mounted RawDossier"));
                    }

                    options.ignoreMounts = true;
                    dossierContext.archive.appendBigFileBrick(dossierContext.relativePath, newSizeSSI, brick, options, callback);
                });
            }
        });
    }

    this.getBigFileBricksMeta = (path, options, callback) => {
        waitIfDSUIsRefreshing(() => {
            const defaultOpts = {ignoreMounts: false};
            if (typeof options === "function") {
                callback = options;
                options = {};
            }
            if (typeof options === "undefined") {
                options = {};
            }

            callback = $$.makeSaneCallback(callback);
            if (typeof path !== "string") {
                return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper("Provided path for writeFileFromBricks must be a string"));
            }

            Object.assign(defaultOpts, options);
            options = defaultOpts;

            if (options.ignoreMounts === true) {
                _getBigFileBricksMeta(path, callback);
            } else {
                this.getArchiveForPath(path, (err, dossierContext) => {
                    if (err) {
                        return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to load DSU instance mounted at path ${path}`, err));
                    }
                    if (dossierContext.readonly === true) {
                        return callback(Error("Tried to write in a readonly mounted RawDossier"));
                    }

                    options.ignoreMounts = true;
                    dossierContext.archive.getBigFileBricksMeta(dossierContext.relativePath, options, callback);
                });
            }
        });
    }

    this.delete = (path, options, callback) => {
        waitIfDSUIsRefreshing(() => {
            const defaultOpts = {ignoreMounts: false, ignoreError: false};
            if (typeof options === 'function') {
                callback = options;
                options = {};
            }
            callback = $$.makeSaneCallback(callback);

            Object.assign(defaultOpts, options);
            options = defaultOpts;

            if (options.ignoreMounts) {
                return _delete(path, err => {
                    if (!err || (err && options.ignoreError)) {
                        return callback();
                    }

                    callback(err);
                });
            }

            this.getArchiveForPath(path, (err, dossierContext) => {
                if (err) {
                    return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to load DSU instance mounted at path ${path}`, err));
                }

                if (dossierContext.readonly === true) {
                    return callback(Error("Tried to delete in a readonly mounted RawDossier"));
                }

                options.ignoreMounts = true;
                dossierContext.archive.delete(dossierContext.relativePath, options, callback);
            });
        })
    };

    this.rename = (srcPath, dstPath, options, callback) => {
        waitIfDSUIsRefreshing(() => {
            const defaultOpts = {ignoreMounts: false};
            if (typeof options === 'function') {
                callback = options;
                options = {};
            }

            callback = $$.makeSaneCallback(callback);
            Object.assign(defaultOpts, options);
            options = defaultOpts;

            if (options.ignoreMounts) {
                _rename(srcPath, dstPath, callback);
                return;
            }

            this.getArchiveForPath(srcPath, (err, dossierContext) => {
                if (err) {
                    return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to load DSU instance mounted at path ${srcPath}`, err));
                }
                if (dossierContext.readonly === true) {
                    return callback(Error("Tried to rename in a readonly mounted RawDossier"));
                }

                const relativeSrcPath = dossierContext.relativePath;
                this.getArchiveForPath(dstPath, (err, dstDossierContext) => {
                    if (err) {
                        return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to load DSU instance mounted at path ${dstPath}`, err));
                    }

                    if (dstDossierContext.prefixPath !== dossierContext.prefixPath) {
                        return callback(Error('Destination is invalid. Renaming must be done in the scope of the same dossier'));
                    }

                    options.ignoreMounts = true;
                    dossierContext.archive.rename(relativeSrcPath, dstDossierContext.relativePath, options, callback);
                })
            });
        })
    };

    this.listFiles = (path, options, callback) => {
        waitIfDSUIsRefreshing(() => {
            const defaultOpts = {ignoreMounts: false, recursive: true};
            if (typeof options === 'function') {
                callback = options;
                options = {};
            }

            callback = $$.makeSaneCallback(callback);
            Object.assign(defaultOpts, options);
            options = defaultOpts;
            if (options.ignoreMounts === true) {
                if (!options.recursive) {
                    return _listFiles(path, options, callback);
                }

                return _listFiles(path, options, (err, files) => {
                    if (err) {
                        return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to list files at path ${path}`, err));
                    }

                    getManifest((err, manifest) => {
                        if (err) {
                            return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to get manifest`, err));
                        }

                        const mountPoints = manifest.getMountPoints();
                        if (!mountPoints.length) {
                            return callback(undefined, files);
                        }

                        _listMountedFiles(mountPoints, (err, mountedFiles) => {
                            if (err) {
                                return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to list mounted files at mountPoints ${mountPoints}`, err));
                            }

                            files = files.concat(...mountedFiles);
                            return callback(undefined, files);
                        });
                    })
                })
            }

            this.getArchiveForPath(path, (err, result) => {
                if (err) {
                    return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to load DSU instance mounted at path ${path}`, err));
                }

                options.ignoreMounts = true;
                result.archive.listFiles(result.relativePath, options, callback);
            });
        })
    };

    this.listFolders = (path, options, callback) => {
        waitIfDSUIsRefreshing(() => {
            const defaultOpts = {ignoreMounts: false, recursive: false};
            if (typeof options === 'function') {
                callback = options;
                options = {};
            }

            callback = $$.makeSaneCallback(callback);
            Object.assign(defaultOpts, options);
            options = defaultOpts;

            if (options.ignoreMounts === true) {
                if (!options.recursive) {
                    return _listFolders(path, options, callback);
                }

                return _listFolders(path, options, (err, folders) => {
                    if (err) {
                        return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to list folders at path ${path}`, err));
                    }

                    getManifest((err, manifest) => {
                        if (err) {
                            return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to get manifest`, err));
                        }

                        const mountPoints = manifest.getMountPoints();
                        if (!mountPoints.length) {
                            return callback(undefined, folders);
                        }

                        _listMountedFolders(mountPoints, (err, mountedFolders) => {
                            if (err) {
                                return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to list mounted folders at mountPoints ${mountPoints}`, err));
                            }

                            folders = folders.concat(...mountedFolders);
                            return callback(undefined, folders);
                        });
                    })
                })
            }

            this.getArchiveForPath(path, (err, result) => {
                if (err) {
                    return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to load DSU instance mounted at path ${path}`, err));
                }

                options.ignoreMounts = true;
                result.archive.listFolders(result.relativePath, options, callback);
            });
        })
    };

    this.createFolder = (barPath, options, callback) => {
        waitIfDSUIsRefreshing(() => {
            const defaultOpts = {ignoreMounts: false, encrypt: true};
            if (typeof options === "function") {
                callback = options;
                options = {};
            }

            callback = $$.makeSaneCallback(callback);
            Object.assign(defaultOpts, options);
            options = defaultOpts;

            if (options.ignoreMounts === true) {
                _createFolder(barPath, callback);
            } else {
                this.getArchiveForPath(barPath, (err, dossierContext) => {
                    if (err) {
                        return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to load DSU instance mounted at path ${barPath}`, err));
                    }
                    if (dossierContext.readonly === true) {
                        return callback(Error("Tried to write in a readonly mounted RawDossier"));
                    }

                    options.ignoreMounts = true;
                    dossierContext.archive.createFolder(dossierContext.relativePath, options, callback);
                });
            }
        })
    };

    this.readDir = (folderPath, options, callback) => {
        waitIfDSUIsRefreshing(() => {
            if (typeof options === "function") {
                callback = options;
                options = {
                    withFileTypes: false
                };
            }

            callback = $$.makeSaneCallback(callback);
            const entries = {};
            this.getArchiveForPath(folderPath, (err, result) => {
                if (err) {
                    return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to load DSU instance mounted at path ${folderPath}`, err));
                }

                result.archive.listFiles(result.relativePath, {recursive: false, ignoreMounts: true}, (err, files) => {
                    if (err) {
                        return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to list files at path ${result.relativePath}`, err));
                    }

                    entries.files = files;

                    result.archive.listFolders(result.relativePath, {
                        recursive: false,
                        ignoreMounts: true
                    }, (err, folders) => {
                        if (err) {
                            return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to list folders at path ${result.relativePath}`, err));
                        }

                        if (options.withFileTypes) {
                            entries.folders = folders;
                        } else {
                            entries.files = [...entries.files, ...folders];
                        }
                        if (result.archive === this) {
                            getManifest(listMounts);
                        } else {
                            Manifest.getManifest(result.archive, listMounts);
                        }

                        function listMounts(err, handler) {
                            if (err) {
                                return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to list mounts`, err));
                            }

                            handler.getMountedDossiers(result.relativePath, (err, mounts) => {
                                if (err) {
                                    return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to get mounted DSUs at path ${result.relativePath}`, err));
                                }
                                let mountPaths = mounts.map(mount => mount.path);
                                let folders = mountPaths.filter(mountPath => mountPath.split('/').length >= 2);
                                folders = folders.map(mountPath => mountPath.split('/').shift());
                                let mountedDossiers = mountPaths.filter(mountPath => mountPath.split('/').length === 1);
                                mountedDossiers = mountedDossiers.map(mountPath => mountPath.split('/').shift());
                                if (options.withFileTypes) {
                                    entries.mounts = mountedDossiers;
                                    entries.folders = Array.from(new Set([...entries.folders, ...folders]));
                                    entries.mounts = entries.mounts.filter(mount => entries.folders.indexOf(mount) === -1);
                                    return callback(undefined, entries);
                                }
                                entries.files = Array.from(new Set([...entries.files, ...mounts, ...folders]));
                                return callback(undefined, entries.files);
                            });
                        }
                    });
                });
            });
        })
    };

    this.cloneFolder = (srcPath, destPath, options, callback) => {
        waitIfDSUIsRefreshing(() => {
            const defaultOpts = {ignoreMounts: false};
            if (typeof options === 'function') {
                callback = options;
                options = {};
            }

            callback = $$.makeSaneCallback(callback);
            Object.assign(defaultOpts, options);
            options = defaultOpts;

            if (options.ignoreMounts) {
                brickMapController.cloneFolder(srcPath, destPath, callback);
                return;
            }

            this.getArchiveForPath(srcPath, (err, dossierContext) => {
                if (err) {
                    return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to load DSU instance mounted at path ${srcPath}`, err));
                }
                if (dossierContext.readonly === true) {
                    return callback(Error("Tried to rename in a readonly mounted RawDossier"));
                }

                this.getArchiveForPath(destPath, (err, dstDossierContext) => {
                    if (err) {
                        return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to load DSU instance mounted at path ${destPath}`, err));
                    }

                    if (dstDossierContext.prefixPath !== dossierContext.prefixPath) {
                        return callback(Error('Destination is invalid. Renaming must be done in the scope of the same dossier'));
                    }

                    options.ignoreMounts = true;
                    dossierContext.archive.cloneFolder(dossierContext.relativePath, dstDossierContext.relativePath, options, callback);
                })
            });
        })
    }

    this.mount = (path, archiveSSI, options, callback) => {
        waitIfDSUIsRefreshing(() => {
            if (typeof options === "function") {
                callback = options;
                options = undefined;
            }

            callback = $$.makeSaneCallback(callback);

            const keySSISpace = require("opendsu").loadAPI("keyssi");

            if (typeof archiveSSI === "string") {
                try {
                    archiveSSI = keySSISpace.parse(archiveSSI);
                } catch (e) {
                    return callback(createOpenDSUErrorWrapper(`The provided archiveSSI is not a valid SSI string.`, e));
                }
            }

            if (typeof archiveSSI === "object") {
                try {
                    archiveSSI = archiveSSI.getIdentifier();
                } catch (e) {
                    return callback(createOpenDSUErrorWrapper(`The provided archiveSSI is not a valid SSI instance`));
                }
            } else {
                return callback(createOpenDSUErrorWrapper(`The provided archiveSSI is neither a string nor a valid SSI instance`));
            }

            function internalMount() {
                _listFiles(path, (err, files) => {
                    if (!err && files.length > 0) {
                        return callback(Error("Tried to mount in a non-empty folder"));
                    }
                    getManifest((err, manifestHandler) => {
                        if (err) {
                            return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to get manifest handler`, err));
                        }

                        manifestHandler.mount(path, archiveSSI, options, callback);
                    });
                });
            }

            this.getArchiveForPath(path, (err, result) => {
                if (err) {
                    return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to load DSU instance mounted at path ${path}`, err));
                }
                if (result.relativePath === path) {
                    internalMount()
                } else {
                    result.archive.mount(result.relativePath, archiveSSI, options, callback)
                }
            });
        })
    };

    this.unmount = (path, callback) => {
        waitIfDSUIsRefreshing(() => {
            callback = $$.makeSaneCallback(callback);

            getManifest((err, manifestHandler) => {
                if (err) {
                    return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to get manifest handler`, err));
                }

                manifestHandler.unmount(path, callback);
            });
        })
    };

    this.listMountedDossiers = (path, callback) => {
        waitIfDSUIsRefreshing(() => {
            callback = $$.makeSaneCallback(callback);

            this.getArchiveForPath(path, (err, result) => {
                if (err) {
                    return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to load DSU instance mounted at path ${path}`, err));
                }

                if (result.archive === this) {
                    getManifest(listMounts);
                } else {
                    Manifest.getManifest(result.archive, listMounts);
                }

                function listMounts(err, handler) {
                    if (err) {
                        return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to list mounts`, err));
                    }

                    handler.getMountedDossiers(result.relativePath, callback);
                }
            });
        })
    };

    this.listMountedDSUs = this.listMountedDossiers;

    this.hasUnanchoredChanges = (callback) => {
        const detectChangesInMountedDSU = (callback, changesExist = false, dsuIndex = 0) => {
            if (dsuIndex >= mountedArchivesForBatchOperations.length) {
                return callback(undefined, changesExist);
            }

            const context = mountedArchivesForBatchOperations[dsuIndex++];
            context.archive.hasUnanchoredChanges((err, result) => {
                if (err) {
                    return callback(err);
                }

                detectChangesInMountedDSU(callback, result || changesExist, dsuIndex);
            })
        }

        waitIfDSUIsRefreshing(() => {
            detectChangesInMountedDSU((err, changesExist) => {
                if (err) {
                    return callback(err);
                }

                callback(undefined, brickMapController.hasUnanchoredChanges() || changesExist);
            })
        });
    };

    this.getArchiveForPath = (path, callback) => {
        waitIfDSUIsRefreshing(() => {
            callback = $$.makeSaneCallback(callback);

            getManifest((err, handler) => {
                if (err) {
                    return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to get manifest handler`, err));
                }

                if (this.batchInProgress()) {
                    return getArchiveForBatchOperations(handler, path, callback);
                }


                handler.getArchiveForPath(path, (err, result) => {
                    if (err) {
                        return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to load DSU instance mounted at path ${path}`, err));
                    }


                    if (result.archive === this) {
                        return callback(undefined, result);
                    }

                    callback(undefined, result);
                });
            });
        })
    };

    /**
     * Start a batch of operations
     * This will force the anchoring when the
     * batch is commited
     */
    this.beginBatch = () => {
        if (batchOperationsInProgress) {
            throw new Error("Another anchoring transaction is already in progress. Cancel the previous batch and try again.");
        }

        batchOperationsInProgress = true;

        // Save the previous decision function
        const anchoringStrategy = this.getAnchoringStrategy();
        prevAnchoringDecisionFn = anchoringStrategy.getDecisionFunction();

        // Prevent anchoring after each operation
        anchoringStrategy.setDecisionFunction((brickMap, callback) => {
            return callback(undefined, false);
        })
    };

    /**
     * @return {boolean}
     */
    this.batchInProgress = () => {
        return batchOperationsInProgress;
    }

    /**
     * Anchor batch of changes
     * @param {callback} onConflict If defined it will be called if a conflict occurs
     * @param {callback} callback
     */
    this.commitBatch = (onConflict, callback) => {
        if (typeof callback === 'undefined') {
            callback = onConflict;
            onConflict = undefined;
        }
        if (!batchOperationsInProgress) {
            const err = new Error("Unable to commit batch because no batch operations have been started");
            const constants = require("opendsu").constants;
            return callback(createOpenDSUErrorWrapper(`Failed to commit batch`, err, constants.ERROR_ROOT_CAUSE.DSU_INVALID_OPERATION));
        }

        let usesOnConflictCallback = false;

        const anchoringStrategy = this.getAnchoringStrategy();
        if (!anchoringStrategy.getConflictResolutionFunction() && typeof onConflict !== 'undefined') {
            prevConflictResolutionFunction = anchoringStrategy.getConflictResolutionFunction();
            // Set 'onConflict' callback
            anchoringStrategy.setConflictResolutionFunction(onConflict);
            usesOnConflictCallback = true;
        }

        commitBatchesInMountedArchives(onConflict, (err) => {
            if (err) {
                batchOperationsInProgress = false;
                return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to anchor`, err));
            }

            this.doAnchoring((err, result) => {
                anchoringStrategy.setDecisionFunction(prevAnchoringDecisionFn);
                if (usesOnConflictCallback) {
                    // Restore the 'conflictResolutionFn'
                    anchoringStrategy.setConflictResolutionFunction(prevConflictResolutionFunction);
                }

                if (err) {
                    batchOperationsInProgress = false;
                    return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to anchor`, err));
                }

                batchOperationsInProgress = false;
                callback(undefined, result);
            });
        });
    };

    /**
     * Cancel the current anchoring batch
     */
    this.cancelBatch = (callback) => {
        if (!batchOperationsInProgress) {
            const err = new Error("Unable to cancel batch because no batch operations have been started");
            const constants = require("opendsu").constants;
            return callback(createOpenDSUErrorWrapper(`Failed to cancel batch`, err, constants.ERROR_ROOT_CAUSE.DSU_INVALID_OPERATION));
        }

        cancelBatchesInMountedArchives((err) => {
            if (err) {
                return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to cancel batches in mounted archive`, err));
            }

            batchOperationsInProgress = false;
            this.getAnchoringStrategy().setDecisionFunction(prevAnchoringDecisionFn);
            this.load((err) => {
                if (err) {
                    return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to load current DSU`, err));
                }
                callback();
            })
        });
    };

    /**
     * Execute a batch of operations
     * then anchor the changes
     *
     * @param {function} batch
     * @param {callback} callback
     */
    this.batch = (batch, callback) => {
        this.beginBatch();
        batch((err) => {
            if (err) {
                return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to execute batch operations`, err));
            }

            this.commitBatch(callback);
        });
    }

    /**
     * @param {function} handler
     */
    this.setMergeConflictsHandler = (handler) => {
        this.getAnchoringStrategy().setConflictResolutionFunction(handler);
    }

    this.stat = (path, callback) => {
        waitIfDSUIsRefreshing(() => {
            callback = $$.makeSaneCallback(callback);

            this.getArchiveForPath(path, (err, res) => {
                if (err) {
                    return callback(undefined, {type: undefined});
                }

                if (res.archive === this) {
                    let stats;
                    try {
                        stats = brickMapController.stat(path);
                    } catch (e) {
                        return callback(undefined, {type: undefined});
                    }

                    callback(undefined, stats);
                } else {
                    res.archive.stat(res.relativePath, callback);
                }
            });
        })
    };
}

module.exports = Archive;

},{"./Brick":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/bar/lib/Brick.js","./BrickMapController":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/bar/lib/BrickMapController.js","./BrickStorageService":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/bar/lib/BrickStorageService/index.js","./Manifest":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/bar/lib/Manifest.js","opendsu":"opendsu","path":false,"swarmutils":"swarmutils"}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/bar/lib/ArchiveConfigurator.js":[function(require,module,exports){
const storageProviders = {};
const fsAdapters = {};

function ArchiveConfigurator(options) {
    const config = {};
    let dsuCaching = false;
    let cache;
    let keySSI;

    this.getCreationSSI = function (plain) {
        return config.keySSI.getIdentifier(plain);
    }

    this.setBufferSize = (bufferSize) => {
        if (bufferSize < 65535) {
            throw Error(`Brick size should be equal to or greater than 65535. The provided brick size is ${bufferSize}`);
        }
        config.bufferSize = bufferSize;
    };

    this.setKeySSI = (keySSI) => {
        config.keySSI = keySSI;
    };

    this.getKeySSI = (keySSIType, callback) => {
        if (typeof keySSIType === "function") {
            callback = keySSIType;
            keySSIType = undefined;
        }

        if (typeof keySSIType === "undefined") {
            return callback(undefined, config.keySSI);
        }

        config.keySSI.getDerivedType(keySSIType, callback);
    }

    this.getKeySSISync = () => {
        return config.keySSI;
    }

    this.getDLDomain = () => {
        if (!config.keySSI) {
            return;
        }

        keySSI = config.keySSI;
        return keySSI.getDLDomain();
    }

    this.getBufferSize = () => {
        return config.bufferSize;
    };

    this.setFsAdapter = (fsAdapterName, ...args) => {
        config.fsAdapter = fsAdapters[fsAdapterName](...args);
    };

    this.getFsAdapter = () => {
        return config.fsAdapter;
    };

    this.setEncryptionAlgorithm = (algorithm) => {
        if (!config.encryption) {
            config.encryption = {};
        }

        config.encryption.algorithm = algorithm;
    };

    this.getEncryptionAlgorithm = () => {
        if (!config.encryption) {
            return;
        }
        return config.encryption.algorithm;
    };

    this.setEncryptionOptions = (options) => {
        if (!config.encryption) {
            config.encryption = {};
        }

        config.encryption.encOptions = options;
    };

    this.getEncryptionOptions = () => {
        if (!config.encryption) {
            return;
        }
        return config.encryption.encOptions;
    };

    this.setCompressionAlgorithm = (algorithm) => {
        if (!config.compression) {
            config.compression = {};
        }

        config.compression.algorithm = algorithm;
    };

    this.getCompressionAlgorithm = () => {
        if (!config.compression) {
            return;
        }

        return config.compression.algorithm;

    };

    this.setCompressionOptions = (options) => {
        if (!config.compression) {
            config.compression = {};
        }

        config.compression.options = options;
    };

    this.getCompressionOptions = () => {
        if (!config.compression) {
            return;
        }
        return config.compression.options;
    };

    this.setAuthTagLength = (authTagLength = 16) => {
        const encOptions = this.getEncryptionOptions();
        if (!encOptions) {
            config.encryption.encOptions = {};
        }

        config.encryption.encOptions.authTagLength = authTagLength;
    };

    this.getAuthTagLength = () => {
        if (!config.encryption || !config.encryption.encOptions) {
            return;
        }

        return config.encryption.encOptions.authTagLength;
    };

    this.setBrickMapStrategy = (strategy) => {
        config.brickMapStrategy = strategy;
    }

    this.getBrickMapStrategy = () => {
        return config.brickMapStrategy;
    }

    this.setValidationRules = (rules) => {
        config.validationRules = rules;
    }

    this.getValidationRules = () => {
        return config.validationRules;
    }

    this.getKey = () => {
        if (config.keySSI) {
            return config.keySSI.getKeyHash();
        }

        // @TODO: obsolete
        return this.getSeedKey();
    };

    this.getMapEncryptionKey = () => {
        if (!config.encryption) {
            return;
        }
        if (config.keySSI) {
            return config.keySSI.getEncryptionKey();
        }
    };


    this.setCache = (cacheInstance) => {
        cache = cacheInstance;
    };

    this.getCache = () => {
        return cache;
    };

    this.disableDSUCaching = () => {
        dsuCaching = false;
    }

    this.dsuCachingEnabled = () => {
        return dsuCaching;
    }

    this.getOptions = () => {
        return options;
    }
}

// @TODO: obsolete
ArchiveConfigurator.prototype.registerStorageProvider = (storageProviderName, factory) => {
    storageProviders[storageProviderName] = factory;
};

ArchiveConfigurator.prototype.registerFsAdapter = (fsAdapterName, factory) => {
    fsAdapters[fsAdapterName] = factory;
};

module.exports = ArchiveConfigurator;

},{}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/bar/lib/Brick.js":[function(require,module,exports){
const openDSU = require("opendsu");
const crypto = openDSU.loadApi("crypto");
const keySSISpace = openDSU.loadApi("keyssi");
const brickTransforms = require("./brick-transforms");

function Brick(options) {
    options = options || {};
    if (typeof options.encrypt === "undefined") {
        options.encrypt = true;
    }
    let rawData;
    let transformedData;
    let hashLink;
    let transform;
    let keySSI;

    this.setTemplateKeySSI = (templateKeySSI) => {
        options.templateKeySSI = templateKeySSI;
    };

    this.setKeySSI = (_keySSI) => {
        if (typeof _keySSI === "string") {
            _keySSI = keySSISpace.parse(_keySSI);
        }
        keySSI = _keySSI;
    };

    this.getKeySSI = () => {
        if (typeof keySSI !== "undefined") {
            return keySSI;
        }

        return generateBrickKeySSI(options);
    };

    this.getHashLink = (callback) => {
        if (typeof hashLink !== "undefined") {
            return callback(undefined, hashLink);
        }

        this.getTransformedData((err, _transformedData) => {
            if (err) {
                return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to get transformed data`, err));
            }

            const hashFn = crypto.getCryptoFunctionForKeySSI(options.templateKeySSI, "hash");
            const _hash = hashFn(_transformedData);

            hashLink = keySSISpace.createHashLinkSSI(options.templateKeySSI.getBricksDomain(), _hash, options.templateKeySSI.getVn(), options.templateKeySSI.getHint());
            callback(undefined, hashLink);
        });
    };

    this.setRawData = (data) => {
        rawData = data;
    };

    this.getRawData = (callback) => {
        if (typeof rawData !== "undefined") {
            return callback(undefined, rawData);
        }

        if (!keySSI) {
            rawData = transformedData;
            return this.getRawData(callback);
        }

        if (transformedData) {
            transform = brickTransforms.createBrickTransformation(options);
            return transform.undo(keySSI, transformedData, (err, _rawData) => {
                if (err) {
                    return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to apply inverse transform`, err));
                }

                rawData = _rawData;
                callback(undefined, _rawData);
            });
        }

        callback(Error("The brick does not contain any data."));
    };

    this.setTransformedData = (data) => {
        transformedData = data;
    };

    this.getTransformedData = (callback) => {
        if (typeof transformedData !== "undefined") {
            return callback(undefined, transformedData);
        }

        if (!options.templateKeySSI.getSpecificString()) {
            transformedData = rawData;
            return this.getTransformedData(callback);
        }

        transformData((err, _transformedData) => {
            if (err) {
                return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to transform data`, err));
            }

            if (typeof transformedData === "undefined") {
                if (typeof rawData !== "undefined") {
                    callback(undefined, rawData);
                } else {
                    callback(Error("The brick does not contain any data."));
                }
            } else {
                callback(undefined, transformedData);
            }
        });
    };

    this.getTransformedSize = () => {
        if (!transformedData) {
            return rawData.length;
        }

        return transformedData.length;
    };

    this.getSummary = (callback) => {
        let keySSIIdentifier = keySSI;
        if (typeof keySSIIdentifier === "object") {
            keySSIIdentifier = keySSI.getIdentifier();
        }
        const summary = {
            encryptionKey: keySSIIdentifier
        };

        this.getHashLink((err, _hashLink) => {
            if (err) {
                return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to get hash link`, err));
            }

            summary.hashLink = _hashLink.getIdentifier();
            callback(undefined, summary);
        });
    }

//----------------------------------------------- internal methods -----------------------------------------------------
    function transformData(callback) {
        transform = brickTransforms.createBrickTransformation(options);
        if (rawData) {
            keySSI = generateBrickKeySSI(options);
            if (typeof keySSI === "undefined") {
                transformedData = rawData;
                return callback(undefined, rawData)
            }
            transform.do(keySSI, rawData, (err, _transformedData) => {
                if (err) {
                    return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to apply direct transform`, err));
                }

                if (typeof _transformedData === "undefined") {
                    transformedData = rawData;
                } else {
                    transformedData = _transformedData;
                }

                callback(undefined, transformedData);
            });
        } else {
            callback();
        }
    }

    function generateBrickKeySSI(options) {
        if (typeof options.templateKeySSI === "undefined") {
            throw Error('A template keySSI should be provided when generating a keySSI used for brick encryption.')
        }
        const keySSISpace = require("opendsu").loadAPI("keyssi");
        if (options.encrypt && !options.brickMap) {
            keySSI = keySSISpace.createTemplateSymmetricalEncryptionSSI(options.templateKeySSI.getDLDomain(), undefined, '', options.templateKeySSI.getVn());
        } else {
            if (options.brickMap && options.encrypt === false) {
                keySSI = keySSISpace.createTemplateSeedSSI(options.templateKeySSI.getDLDomain(), undefined, options.templateKeySSI.getControlString(), options.templateKeySSI.getVn());
            } else if (options.brickMap && options.encrypt) {
                keySSI = options.templateKeySSI;
            } else {
                keySSI = undefined;
            }
        }

        return keySSI;
    }
}

module.exports = Brick;

},{"./brick-transforms":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/bar/lib/brick-transforms/index.js","opendsu":"opendsu"}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/bar/lib/BrickMap.js":[function(require,module,exports){
const BrickMapMixin = require('./BrickMapMixin');

/**
 * Maps file paths to bricks and metadata
 *
 * The state of the BrickMap has the following structure
 *
 * header: {
 *  metadata: {
 *      createdAt: 'utc timestamp string'
 *  },
 *  items: {
 *      folder1: {
 *          metadata: {
 *              createdAt: 'utc timestamp string'
 *          },
 *          items: {
 *              file.txt: {
 *                  metadata: {
 *                      createdAt: 'utc timestamp string',
 *                      updatedAt: 'utc timestamp string'
 *                  },
 *                  hashes: [... list of bricks hashes and check sums ...]
 *              }
 *          }
 *
 *      },
 *
 *      file2.txt: {
 *          metadata: {
 *              createdAt: 'utc timestamp string',
 *              updatedAt: 'utc timestamp string'
 *          },
 *          hashes: [... list of bricks hashes and check sums ...]
 *      }
 *  }
 * }
 *
 * @param {object|undefined} header
 */

function BrickMap(header, options) {
    Object.assign(this, BrickMapMixin);
    this.initialize(header, options);

    /**
     * Clone object/array
     */
    const clone = (obj) => {
        const cloned = Object.keys(obj).reduce((acc, key) => {
            if (typeof obj[key] === 'object' && !Array.isArray(obj[key])) {
                acc[key] = clone(obj[key]);
                return acc;
            }

            if (Array.isArray(obj[key])) {
                acc[key] = [];
                for (const i in obj[key]) {
                    if (typeof obj[key][i] === 'object' || Array.isArray(obj[key][i])) {
                        acc[key][i] = clone(obj[key][i]);
                        continue;
                    }

                    acc[key][i] = obj[key][i];
                }

                return acc;
            }

            acc[key] = obj[key];
            return acc;
        }, {});
        return cloned;
    };

    /**
     * Compare two BrickMap paths for changes
     */
    const pathChanged = (src, dst) => {
        if (this.nodeIsDirectory(src) !== this.nodeIsDirectory(dst)) {
            return true;
        }

        // Compare directories
        if (this.nodeIsDirectory(src)) {
            const srcFiles = Object.keys(src.items).sort();
            const dstFiles = Object.keys(dst.items).sort();

            if (srcFiles.length !== dstFiles.length) {
                return true;
            }

            const max = Math.max(srcFiles.length, dstFiles.length);

            for (let i = 0; i < max; i++) {
                const srcKey = srcFiles[i];
                const dstKey = dstFiles[i];


                if (srcKey !== dstKey) {
                    return true;
                }

                if (pathChanged(src.items[srcKey], dst.items[dstKey])) {
                    return true;
                }
            }
            return false;
        }

        // Compare files
        if (src.hashLinks.length !== dst.hashLinks.length) {
            return true;
        }

        const max = Math.max(src.hashLinks.length, dst.hashLinks.length);
        for (let i = 0; i < max; i++) {
            const srcHashLink = src.hashLinks[i];
            const dstHashLink = dst.hashLinks[i];

            if (typeof srcHashLink !== typeof dstHashLink) {
                return true;
            }

            const srcKeys = Object.keys(srcHashLink).sort();
            const dstKeys = Object.keys(dstHashLink).sort();
            const max = Math.max(srcKeys.length, dstKeys.length);

            for (let i = 0; i < max; i++) {
                if (srcKeys[i] !== dstKeys[i]) {
                    return true;
                }

                if (srcHashLink[srcKeys[i]] !== dstHashLink[dstKeys[i]]) {
                    return true;
                }
            }
        }

        return false;
    };


    /**
     * Merge `brickMap` items into
     * this instance
     * @param {BrickMap} brickMap
     */
    this.merge = function (brickMap) {
        const changes = this.diff(brickMap);

        if (!changes.hasItems()) {
            return;
        }

        const merge = (target, source) => {
            for (const key in source) {
                if (typeof source[key] === 'object' && !Array.isArray(source[key])) {
                    if (typeof target[key] !== 'object' || Array.isArray(target[key])) {
                        target[key] = {};
                    }
                    merge(target[key], source[key]);
                    continue;
                }

                if (Array.isArray(source[key])) {
                    target[key] = [];
                    for (let i = 0; i < source[key].length; i++) {
                        if (typeof source[key][i] === 'object') {
                            target[key][i] = {}
                            merge(target[key][i], source[key][i])
                            continue;
                        }
                        target[key][i] = source[key][i];
                    }
                    continue;
                }

                target[key] = source[key];
            }
        };
        merge(this.header.items, changes.header.items);
        merge(this.header.embedded, changes.header.embedded);
        this.updateTimeMetadata('/', 'updatedAt', this.getTimestamp());
    }

    /**
     * Return all items that changed in `brickMap`
     * compared to our version
     * @param {BrickMap} brickMap
     */
    this.diff = function (brickMap) {
        const dst = brickMap.header.items;
        const dstKeys = Object.keys(dst)
                              .filter(item => item !== 'dsu-metadata-log')
                              .sort();

        const src = this.header.items;
        const changes = {};
        for (const key of dstKeys) {
            // New items
            if (typeof src[key] === 'undefined') {
                changes[key] = clone(dst[key]);
                continue;
            }

            // Existing items
            if (pathChanged(src[key], dst[key])) {
                changes[key] = clone(dst[key]);
                continue;
            }
        }

        let embedClone = {};
        if(brickMap.header.embedded){
            embedClone = JSON.parse(JSON.stringify(brickMap.header.embedded));
            let embeddedSrc = this.header.embedded;
            for (let f in embeddedSrc) {
                if (embedClone[f] === embeddedSrc[f]) {
                    delete embedClone[f];
                }
            }
        }


        const brickMapDiff = new this.constructor({
            metadata: {
                createdAt: this.getTimestamp()
            },
            items: changes,
            embedded: embedClone
        }, options);
        return brickMapDiff;
    }

    /**
     * @param {object} operation
     * @param {string} operation.op
     * @param {string} operation.path
     * @param {string} operation.timestamp UTC string timestamp
     * @param {*} operation.data
     * @throws {Error}
     */
    this.replayOperation = function (operation) {
        const {op, path, timestamp, data} = operation;

        switch (op) {
            case 'add':
                this.addFileEntry(path, data);
                this.updateTimeMetadata(path, 'updatedAt', timestamp);
                break;
            case 'append':
                this.appendBricksToFile(path, data);
                this.updateTimeMetadata(path, 'updatedAt', timestamp);
                break;
            case 'truncate':
                this.emptyList(path);
                this.updateTimeMetadata(path, 'updatedAt', timestamp);
                break;
            case 'delete':
                this.delete(path);
                this.updateTimeMetadata(path, 'deletedAt', timestamp);
                break;
            case 'copy':
                const dstPath = data;
                this.copy(path, dstPath);
                this.updateTimeMetadata(dstPath, 'createdAt', timestamp);
                break;
            case 'createFolder':
                this.createFolder(path);
                this.updateTimeMetadata(path, 'createdAt', timestamp);
                break;
            case 'createFile':
                this.createFile(path);
                this.updateTimeMetadata(path, 'createdAt', timestamp);
                break;
            case 'replaceFirstBrick':
                this.replaceFirstBrick(path, data);
                this.updateTimeMetadata(path, 'updatedAt', timestamp);
                break;
            case 'replaceLastBrick':
                this.replaceLastBrick(path, data);
                this.updateTimeMetadata(path, 'updatedAt', timestamp);
                break;
            case 'embed':
                this.putEmbeddedFile(path, data);
                break;
            case 'appendToEmbed':
                this.appendToEmbedded(path, data);
                break;
            default:
                throw new Error(`Unknown operation <${JSON.stringify(operation)}>`);
        }
    }

    /**
     * @param {BrickMap} brickMap
     * @throws {Error}
     */
    this.applyDiff = function (brickMap) {
        if (brickMap.constructor === BrickMap) {
            // This is not a BrickMapDiff so we need to merge the changes from a regular BrickMap instance
            this.merge(brickMap);
            return;
        }

        const metadata = brickMap.getMetadata('/');
        const operationsLog = metadata.log;

        if (!Array.isArray(operationsLog)) {
            throw new Error('Invalid BrickMapDiff. No replay log found');
        }

        if (!operationsLog.length) {
            return;
        }

        for (const operation of operationsLog) {
            this.replayOperation(operation, brickMap);
        }
        this.updateTimeMetadata('/', 'updatedAt', this.getTimestamp());
        this.header.metadata.prevDiffHashLink = metadata.prevDiffHashLink;
    }

    /**
     * Check for same path conflicts
     * @param {Array<BrickMapDiff>} localChangesList
     * @return {object}
     */
    this.detectMergeConflicts = function (changes) {
        if(options.useMineMergeStrategy){
            return undefined;
        }
        const conflicts = changes.reduce((acc, changeSet) => {
            const metadata = changeSet.getMetadata('/');
            const operationsLog = metadata.log;

            if (!Array.isArray(operationsLog)) {
                return acc;
            }

            if (!operationsLog.length) {
                return acc;
            }

            for (const operation of operationsLog) {
                switch (operation.op) {
                    case 'add':
                    case 'createFolder':
                    case 'createFile':
                    case 'truncate':
                        if (this.fileExists(operation.path)) {
                            acc[operation.path] = {
                                error: 'LOCAL_OVERWRITE',
                                message: `Path ${operation.path} will overwrite a previously anchored file or directory`,
                            }
                        }
                        break;

                    case 'copy':
                        if (this.fileDeleted(operation.path)) {
                            acc[operation.path] = {
                                error: 'REMOTE_DELETE',
                                message: `Unable to copy ${operation.path} to ${operation.data}. Source was previously deleted`
                            };
                        }

                        if (this.fileExists(operation.data)) {
                            acc[operation.data] = {
                                error: 'LOCAL_OVERWRITE',
                                message: `Unable to copy ${operation.path} to ${operation.data}. The destination path will overwrite a previously anchored file or directory`,
                            };
                        }
                        break;

                    case 'delete':
                        if (this.fileExists(operation.path)) {
                            acc[operation.path] = {
                                error: 'LOCAL_DELETE',
                                message: `Unable to delete ${operation.path}. This will delete a previously anchored file.`
                            }
                        }
                        break;

                }
            }

            return acc;
        }, {});

        if (!Object.keys(conflicts).length) {
            return;
        }
        return conflicts;
    }
}
module.exports = BrickMap;

},{"./BrickMapMixin":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/bar/lib/BrickMapMixin.js"}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/bar/lib/BrickMapController.js":[function(require,module,exports){
'use strict';

// HTTP error code returned by the anchoring middleware
// when trying to anchor outdated changes
const ALIAS_SYNC_ERR_CODE = 428;


/**
 * The current state of the BrickMapController
 */
function State(options) {
    const brickMap = {
        // The latest anchored BrickMap
        anchored: undefined,
        // The current BrickMap, cloned from `anchored`. Contains un-anchored changes
        dirty: undefined,
    };
    const diffs = {
        inAnchoring: [], // BrickMapDiff objects which are in the process of anchoring
        new: [], // BrickMapDiff objects which haven't been scheduled for anchoring
        current: undefined, // A reference to the current BrickMapDiff
        latestHash: undefined // Used for chaining multiple BrickMapDiff objects
    };
    let currentAnchoredHashLink = undefined;

    this.init = (anchoredBrickMap, latestHashLink, callback) => {
        if (typeof latestHashLink === 'function') {
            callback = latestHashLink;
            latestHashLink = undefined;
        }

        brickMap.anchored = anchoredBrickMap;
        this.cloneAnchoredBrickMap((err, clone) => {
            if (err) {
                return callback(err);
            }
            brickMap.dirty = clone;
            currentAnchoredHashLink = latestHashLink;
            diffs.inAnchoring = [];
            diffs.new = [];
            diffs.current = undefined;
            diffs.latestHash = latestHashLink;
            callback();
        });
    }

    /**
     * @return {boolean}
     */
    this.canBeAnchored = () => {
        return this.hasNewDiffs() || this.hasDiffsForAnchoring();
    }

    /**
     * @return {Array<BrickMapDiff>}
     */
    this.getDiffsForAnchoring = () => {
        return diffs.inAnchoring;
    }

    /**
     * @param {BrickMap} anchoredBrickMap
     */
    this.setAnchoredBrickMap = (anchoredBrickMap) => {
        brickMap.anchored = anchoredBrickMap;
    }

    /**
     * @return {BrickMap}
     */
    this.getAnchoredBrickMap = () => {
        return brickMap.anchored;
    }

    /**
     * @return {BrickMapDiff}
     */
    this.getCurrentDiff = () => {
        return diffs.current;
    }

    /**
     * @param {BrickMapDiff} diff
     */
    this.setCurrentDiff = (diff) => {
        diffs.current = diff;
    }

    /**
     * Returns the BrickMap containing un-anchored changes
     * @return {BrickMap}
     */
    this.getDirtyBrickMap = () => {
        return brickMap.dirty;
    }

    /**
     * @param {BrickMap} dirtyBrickMap
     */
    this.setDirtyBrickMap = (dirtyBrickMap) => {
        brickMap.dirty = dirtyBrickMap;
    }

    /**
     * Returns the latest BrickMapDiff in the "new" list
     * @return {BrickMapDiff}
     */
    this.getLastestNewDiff = () => {
        const newDiffsLength = diffs.new.length;
        return diffs.new[newDiffsLength - 1];
    }

    /**
     * @param {BrickMapDiff} diff
     */
    this.pushNewDiff = (diff) => {
        diffs.new.push(diff);
    }

    this.getCurrentAnchoredHashLink = () => {
        return currentAnchoredHashLink;
    }

    this.setCurrentAnchoredHashLink = (hashLink) => {
        currentAnchoredHashLink = hashLink;
    }

    this.getLatestDiffHashLink = () => {
        return diffs.latestHash;
    }

    this.setLatestDiffHashLink = (hashLink) => {
        diffs.latestHash = hashLink;
    }

    /**
     * @return {boolean}
     */
    this.hasNewDiffs = () => {
        return diffs.new.length > 0;
    }

    /**
     * @return {boolean}
     */
    this.hasDiffsForAnchoring = () => {
        return diffs.inAnchoring.length > 0;
    }

    /**
     * Moves the BrickMapDiffs from the 'new' array to the 'inAnchoring' array
     * @param {function} callback
     */
    this.prepareNewChangesForAnchoring = (callback) => {
        if (!this.hasNewDiffs()) {
            return callback();
        }

        const diff = diffs.new.shift();
        diff.getHashLink((err, lastDiffHashLink) => {
            if (err) {
                return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to get hashLink`, err));
            }

            diffs.latestHash = lastDiffHashLink;
            diffs.inAnchoring.push(diff);
            this.prepareNewChangesForAnchoring(callback);
        });
    }

    this.rollback = (mergedDiffs) => {
        diffs.inAnchoring.unshift(...mergedDiffs);
    }

    /**
     * Clone the anchored brickmap
     * @param {function} callback
     */
    this.cloneAnchoredBrickMap = (callback) => {
        brickMap.anchored.clone(options, (err, brickMap) => {
            if (err) {
                return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to clone BrickMap`, err));
            }
            callback(undefined, brickMap);
        })
    }
}

/**
 * BrickMap Proxy
 *
 * Handles loading and anchoring a BrickMap using the provided BrickMapStrategy
 * in the ArchiveConfigurator
 *
 * BrickMap write operations are proxied to a copy of a valid BrickMap and to a BrickMapDiff
 * used later for anchoring. The reason for that is to preserve read consistency during
 * a session. Writing only to a BrickMapDiff object will cause subsequent reads to fail;
 * in order to simplify the implementation the same "write" operation is written to the
 * "dirty" BrickMap and to the BrickMapDiff object (only this object will be anchored). Any
 * read operations will go directly to the "dirty" BrickMap.
 *
 * After anchoring any changes, the anchored BrickMap is updated with the changes stored in BrickMapDiff
 * thus being in sync with the "dirty" copy
 *
 * @param {object} options
 * @param {ArchiveConfigurator} options.config
 * @param {BrickStorageService} options.brickStorageService
 */
function BrickMapController(options) {
    const swarmutils = require("swarmutils");
    const BrickMap = require('./BrickMap');
    const AnchorValidator = require('./AnchorValidator');
    const pskPth = swarmutils.path;
    const BrickMapDiff = require('./BrickMapDiff');
    const BrickMapStrategyFactory = require('./BrickMapStrategy');
    const anchoringStatus = require('./constants').anchoringStatus;
    const openDSU = require("opendsu");
    const bricking = openDSU.loadAPI("bricking");
    const anchoring = openDSU.loadAPI("anchoring");
    const anchoringx = anchoring.getAnchoringX();

    const notifications = openDSU.loadAPI("notifications");
    options = options || {};

    const config = options.config;
    const keySSI = options.keySSI;
    const brickStorageService = options.brickStorageService;
    const keySSISpace = openDSU.loadApi("keyssi");
    if (!config) {
        throw new Error('An ArchiveConfigurator is required!');
    }

    if (!brickStorageService) {
        throw new Error('BrickStorageService is required');
    }

    let anchoringInProgress = false;

    let publishAnchoringNotifications = false;

    let strategy = config.getBrickMapStrategy();
    let validator = new AnchorValidator({
        rules: config.getValidationRules()
    });
    const state = new State(options);


    ////////////////////////////////////////////////////////////
    // Private methods
    ////////////////////////////////////////////////////////////

    /**
     * Configure the strategy and create
     * proxy methods for BrickMap
     */
    const initialize = () => {
        if (!strategy) {
            strategy = getDefaultStrategy();
        }
        strategy.setCache(config.getCache());
        strategy.setBrickMapController(this);
        strategy.setBrickMapState(state);
        strategy.setValidator(validator);

        const brickMap = new BrickMap(undefined, options);
        const brickMapProperties = Object.getOwnPropertyNames(brickMap);
        for (const propertyName of brickMapProperties) {
            if (typeof brickMap[propertyName] !== 'function' || propertyName === 'load') {
                continue;
            }
            // Proxy method calls to BrickMap through BrickMapController
            const method = propertyName;
            this[propertyName] = new Proxy(function () {
            }, {
                apply: (...args) => {
                    const targetHandlerName = `${method}ProxyHandler`;

                    if (typeof this[targetHandlerName] === 'function') {
                        return this[targetHandlerName](...args.pop());
                    }

                    const dirtyBrickMap = state.getDirtyBrickMap();
                    return dirtyBrickMap[method].apply(dirtyBrickMap, args.pop());
                }
            });
        }
    }

    this.getStrategy = () => {
        return strategy;
    };
    /**
     * @return {BrickMapStrategyMixin}
     */
    const getDefaultStrategy = () => {
        const factory = new BrickMapStrategyFactory();
        const strategy = factory.create();

        return strategy;
    }

    const createBrickMapDiff = (data, callback) => {
        if (typeof data === 'function') {
            callback = data;
            data = undefined;
        }

        const brickMapDiff = new BrickMapDiff(data);
        if (typeof data !== 'undefined') {
            return this.configureBrickMap(brickMapDiff, (err) => {
                if (err) {
                    return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to configure brickMap`, err));
                }
                callback(undefined, brickMapDiff);
            });
        }
        brickMapDiff.initialize((err) => {
            if (err) {
                return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to initialize brickMapDiff`, err));
            }

            brickMapDiff.setPrevDiffHashLink(state.getLatestDiffHashLink());
            this.configureBrickMap(brickMapDiff, (err) => {
                if (err) {
                    return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to configure brickMap`, err));
                }
                callback(undefined, brickMapDiff);
            });
        });
    }

    /**
     * Returns the latest BrickMapDiff that
     * hasn't been scheduled for anchoring
     *
     * Write operations will be added into this object
     *
     * If no such object exists, a new object is created
     * and push into the list
     *
     * @return {BrickMapDiff}
     */
    const getCurrentDiffBrickMap = (callback) => {
        let brickMapDiff = state.getLastestNewDiff();
        if (!brickMapDiff) {
            return createBrickMapDiff((err, brickMapDiff) => {
                if (err) {
                    return callback(err);
                }

                state.setCurrentDiff(brickMapDiff);
                state.pushNewDiff(brickMapDiff);
                callback(undefined, brickMapDiff);
            })
        }

        state.setCurrentDiff(brickMapDiff);
        callback(undefined, brickMapDiff);
    }

    const notifySubscribers = (hashLink, callback) => {
        hashLink.getAnchorId((err, anchorId) => {
            if (err) {
                return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to get anchor id for hashlink ${hashLink.getIdentifier()}`, err));
            }

            const message = {
                event: "dsu:newAnchor",
                payload: anchorId
            };

            notifications.publish(keySSI, message, 0, (err) => {
                if (err) {
                    return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to publish anchoring notification`, err));
                }

                callback();
            });
        })
    }

    /**
     * Release the "anchoringInProgress" lock
     * and notify the anchoring listener of
     * the status and data of the current anchoring process
     *
     * To preserve backwards compatibility with the existing
     * code, the listener is called in the same way as
     *  the classic NodeJS callback convention: callback(err, result)
     *
     * If the anchoring status is OK, the listener is called as: listener(undefined, anchoringResult)
     * If the anchoring process has failed, the `status` parameter will contain
     * the error type (string) and the `data` parameter will contain
     * the actual error object. The error type is added as a property
     * tot the error object and the listener will be called as: listener(err)
     *
     * @param {callback} listener
     * @param {number} status
     * @param {*} data
     */
    const endAnchoring = (listener, status, data) => {
        anchoringInProgress = false;

        if (status === anchoringStatus.OK) {
            if (!publishAnchoringNotifications) {
                return listener(undefined, data);
            }

            return notifySubscribers(data, (err) => {
                if (err) {
                    console.warn("Unable to publish anchoring notification");
                    console.error(err);
                }

                return listener(undefined, data);
            });
        }

        if (status === anchoringStatus.BRICKMAP_RECONCILIATION_HANDOFF) {
            return listener(undefined, data);
        }

        const error = data;
        error.type = status;
        listener(error);
    }

    /**
     * Returns true if any BrickMapDiff objects
     * exist in the pending state.
     *
     * This function is used to determine if a new anchoring
     * process should be started after the current one has ended
     *
     * @return {boolean}
     */
    const anchoringRequestExists = () => {
        return state.hasDiffsForAnchoring();
    }

    /**
     * Returns true if the anchoring service returned an 'out of sync' error
     * @return {boolean}
     */
    const isAliasSyncError = (err) => {
        let error = err;
        do {
            if (error.statusCode === ALIAS_SYNC_ERR_CODE) {
                return true;
            }

            error = error.previousError;
        } while (error && (error.previousError || error.statusCode));
        return false;
    }

    ////////////////////////////////////////////////////////////
    // Public methods
    ////////////////////////////////////////////////////////////

    /**
     * Create an empty BrickMap
     */
    this.init = (callback) => {
        this.createBrickMap((err, brickMap) => {
            if (err) {
                return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to create new brickMap`, err));
            }

            state.init(brickMap, callback);
        });
    }

    /**
     * Load an existing BrickMap using the BrickMap strategy
     */
    this.load = (callback) => {
        strategy.load(keySSI, (err, brickMap) => {
            if (err) {
                return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to load brickMap`, err));
            }


            state.init(brickMap, strategy.getCurrentHashLink(), callback);
        });
    }

    this.loadVersion = (versionHash, callback) => {
        strategy.loadVersion(keySSI, versionHash, (err, brickMap) => {
            if (err) {
                return callback(err);
            }

            state.init(brickMap, versionHash, callback);
        });
    }

    /**
     * @param {string} path
     * @param {Array<object>} bricksData
     * @param {callback} callback
     */
    this.addFile = (path, bricksData, callback) => {
        validator.validate('preWrite', state.getDirtyBrickMap(), 'addFile', path, {
            bricksData
        }, (err) => {
            if (err) {
                return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to validate addFile operation`, err));
            }

            getCurrentDiffBrickMap((err, _brickMap) => {
                if (err) {
                    return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to retrieve current diffBrickMap`, err));
                }

                this.addFileEntry(path, bricksData);
                this.attemptAnchoring(callback);
            });
        })
    }

    /**
     * @param {string} srcPath
     * @param {string} dstPath
     * @param {callback} callback
     */
    this.renameFile = (srcPath, dstPath, callback) => {
        validator.validate('preWrite', state.getDirtyBrickMap(), 'rename', srcPath, {
            dstPath
        }, (err) => {
            if (err) {
                return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to validate rename operation`, err));
            }

            getCurrentDiffBrickMap((err, _brickMap) => {
                if (err) {
                    return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to retrieve current diffBrickMap`, err));
                }
                try {
                    this.copy(srcPath, dstPath);
                } catch (e) {
                    return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to copy`, e));
                }
                this.delete(srcPath);
                this.attemptAnchoring(callback);
            })
        })
    }
    /**
     * @param {string} srcPath
     * @param {string} dstPath
     * @param {callback} callback
     */
    this.cloneFolder = (srcPath, dstPath, callback) => {
        validator.validate('preWrite', state.getDirtyBrickMap(), 'clone', srcPath, {
            dstPath
        }, (err) => {
            if (err) {
                return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to validate copy operation`, err));
            }

            getCurrentDiffBrickMap((err, _brickMap) => {
                if (err) {
                    return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to retrieve current diffBrickMap`, err));
                }
                try {
                    this.copy(srcPath, dstPath);
                } catch (e) {
                    return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to copy`, e));
                }

                this.attemptAnchoring(callback);
            })
        })
    }

    /**
     * @param {string} path
     * @param {Array<object>} bricksData
     * @param {callback} callback
     */
    this.appendToFile = (path, bricksData, callback) => {
        validator.validate('preWrite', state.getDirtyBrickMap(), 'appendToFile', path, {
            bricksData
        }, (err) => {
            if (err) {
                return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to validate appendToFile operation`, err));
            }

            getCurrentDiffBrickMap((err, _brickMap) => {
                if (err) {
                    return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to retrieve current diffBrickMap`, err));
                }

                this.appendBricksToFile(path, bricksData);
                this.attemptAnchoring(callback);
            })
        })
    }

    /**
     * @param {string} path
     * @param {Array<object>} filesBricksData
     * @param {callback} callback
     */
    this.addFiles = (path, filesBricksData, callback) => {
        validator.validate('preWrite', state.getDirtyBrickMap(), 'addFiles', path, {
            filesBricksData
        }, (err) => {
            if (err) {
                return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to validate addFiles operation`, err));
            }

            getCurrentDiffBrickMap((err, _brickMap) => {
                if (err) {
                    return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to retrieve current diffBrickMap`, err));
                }

                for (const filePath in filesBricksData) {
                    const bricks = filesBricksData[filePath];
                    this.addFileEntry(pskPth.join(path, filePath), bricks);
                }
                this.attemptAnchoring(callback);
            })
        })
    }

    /**
     * @param {string} path
     * @param {Array<object>} bricksData
     * @param {callback} callback
     */
    this.updateBigFileLastBrick = (path, sizeSSI, brick, callback) => {
        validator.validate('preWrite', state.getDirtyBrickMap(), 'updateBigFile', path, {
            sizeSSI,
            brick
        }, (err) => {
            if (err) {
                return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to validate updateBigFile operation`, err));
            }

            getCurrentDiffBrickMap((err, _brickMap) => {
                if (err) {
                    return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to retrieve current diffBrickMap`, err));
                }

                this.replaceFirstBrick(path, {size: sizeSSI});
                this.replaceLastBrick(path, brick);
                this.attemptAnchoring(callback);
            })
        })
    }

    /**
     * @param {string} path
     * @param {Array<object>} bricksData
     * @param {callback} callback
     */
    this.appendBigFile = (path, sizeSSI, brick, callback) => {
        validator.validate('preWrite', state.getDirtyBrickMap(), 'appendBigFile', path, {
            sizeSSI,
            brick
        }, (err) => {
            if (err) {
                return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to validate appendBigFile operation`, err));
            }

            getCurrentDiffBrickMap((err, _brickMap) => {
                if (err) {
                    return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to retrieve current diffBrickMap`, err));
                }

                this.replaceFirstBrick(path, {size: sizeSSI});
                this.appendBricksToFile(path, [brick]);
                this.attemptAnchoring(callback);
            })
        })
    }

    /**
     * @param {string} path
     * @param {callback} callback
     */
    this.deleteFile = (path, callback) => {
        validator.validate('preWrite', state.getDirtyBrickMap(), 'deleteFile', path, (err) => {
            if (err) {
                return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to validate deleteFile operation`, err));
            }

            getCurrentDiffBrickMap((err, _brickMap) => {
                if (err) {
                    return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to retrieve current diffBrickMap`, err));
                }

                try {
                    this.delete(path);
                } catch (e) {
                    return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to delete`, e));
                }
                this.attemptAnchoring(callback);
            })
        })
    }

    /**
     * @param {string} path
     * @param {callback} callback
     */
    this.createDirectory = (path, callback) => {
        validator.validate('preWrite', state.getDirtyBrickMap(), 'createFolder', path, (err) => {
            if (err) {
                return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to validate createFolder operation`, err));
            }

            getCurrentDiffBrickMap((err, _brickMap) => {
                if (err) {
                    return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to retrieve current diffBrickMap`, err));
                }

                try {
                    this.createFolder(path);
                } catch (e) {
                    return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to create folder ${path}`, e));
                }
                this.attemptAnchoring(callback);
            })
        })
    }

    /**
     * @param {string} path
     * @param {callback} callback
     */
    this.createEmptyFile = (path, callback) => {
        validator.validate('preWrite', state.getDirtyBrickMap(), 'createFile', path, (err) => {
            if (err) {
                return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to validate createFile operation`, err));
            }

            getCurrentDiffBrickMap((err, _brickMap) => {
                if (err) {
                    return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to retrieve current diffBrickMap`, err));
                }

                try {
                    this.createFile(path);
                } catch (e) {
                    return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to create file ${path}`, e));
                }
                this.attemptAnchoring(callback);
            })
        })
    }

    this.fileIsEmbedded = (path, callback) => {
        getCurrentDiffBrickMap((err, _brickMap) => {
            if (err) {
                return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to retrieve current diffBrickMap`, err));
            }

            const embeddedFile = this.getEmbeddedFile(path);
            callback(undefined, !!embeddedFile);
        })
    }

    this.embedData = (path, data, options, callback) => {
        getCurrentDiffBrickMap((err, _brickMap) => {
            if (err) {
                return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to retrieve current diffBrickMap`, err));
            }

            try {
                this.putEmbeddedFile(path, data);
            } catch (e) {
                return callback(e);
            }

            this.attemptAnchoring(callback);
        });
    }

    this.appendToEmbeddedFile = (path, data, options, callback) => {
        getCurrentDiffBrickMap((err, _brickMap) => {
            if (err) {
                return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to retrieve current diffBrickMap`, err));
            }
            try {
                this.appendToEmbedded(path, data);
            } catch (e) {
                return callback(e);
            }

            this.attemptAnchoring(callback);
        });
    }

    /**
     * Proxy for BatMap.addFileEntry()
     *
     * @param {string} path
     * @param {Array<object>} bricks
     * @throws {Error}
     */
    this.addFileEntryProxyHandler = (path, bricks) => {
        const dirtyBrickMap = state.getDirtyBrickMap();
        let truncateFileIfExists = false;
        if (!dirtyBrickMap.isEmpty(path)) {
            truncateFileIfExists = true;
        }

        dirtyBrickMap.addFileEntry(path, bricks);
        if (truncateFileIfExists) {
            state.getCurrentDiff().emptyList(path);
        }
        state.getCurrentDiff().addFileEntry(path, bricks);
    }

    /**
     * Proxy for BrickMap.appendBricksToFile()
     *
     * @param {string} path
     * @param {Array<object>} bricks
     * @throws {Error}
     */
    this.appendBricksToFileProxyHandler = (path, bricks) => {
        const dirtyBrickMap = state.getDirtyBrickMap();
        dirtyBrickMap.appendBricksToFile(path, bricks);
        state.getCurrentDiff().appendBricksToFile(path, bricks);
    }

    /**
     * Proxy for BrickMap.replaceFirstBrick()
     *
     * @param {string} path
     * @param {Array<object>} bricks
     * @throws {Error}
     */
    this.replaceFirstBrickProxyHandler = (path, brick) => {
        const dirtyBrickMap = state.getDirtyBrickMap();
        dirtyBrickMap.replaceFirstBrick(path, brick);
        state.getCurrentDiff().replaceFirstBrick(path, brick);
    }

    /**
     * Proxy for BrickMap.replaceLastBrick()
     *
     * @param {string} path
     * @param {Array<object>} bricks
     * @throws {Error}
     */
    this.replaceLastBrickProxyHandler = (path, brick) => {
        const dirtyBrickMap = state.getDirtyBrickMap();
        dirtyBrickMap.replaceLastBrick(path, brick);
        state.getCurrentDiff().replaceLastBrick(path, brick);
    }

    /**
     * Proxy for BrickMap.delete();
     *
     * @param {string} path
     * @throws {Error}
     */
    this.deleteProxyHandler = (path) => {
        const dirtyBrickMap = state.getDirtyBrickMap();
        dirtyBrickMap.delete(path);
        state.getCurrentDiff().delete(path);
    }

    /**
     * Proxy for BrickMap.copy()
     *
     * @param {string} srcPath
     * @param {string} dstPath
     * @throws {Error}
     */
    this.copyProxyHandler = (srcPath, dstPath) => {
        const dirtyBrickMap = state.getDirtyBrickMap();
        dirtyBrickMap.copy(srcPath, dstPath);
        state.getCurrentDiff().copy(srcPath, dstPath);
    }

    /**
     * Proxy for BrickMap.createFolder()
     *
     * @param {string} path
     */
    this.createFolderProxyHandler = (path) => {
        const dirtyBrickMap = state.getDirtyBrickMap();
        dirtyBrickMap.createFolder(path);
        state.getCurrentDiff().createFolder(path);
    }

    /**
     * Proxy for BrickMap.createFile()
     *
     * @param {string} path
     */
    this.createFileProxyHandler = (path) => {
        const dirtyBrickMap = state.getDirtyBrickMap();
        dirtyBrickMap.createFile(path);
        state.getCurrentDiff().createFile(path);
    }

    /**
     * Proxy for BrickMap.putEmbeddedFile()
     *
     * @param {string} path
     * @param {string} data
     */
    this.putEmbeddedFileProxyHandler = (path, data) => {
        const dirtyBrickMap = state.getDirtyBrickMap();
        dirtyBrickMap.putEmbeddedFile(path, data);
        state.getCurrentDiff().putEmbeddedFile(path, data);
    }

    /**
     * Proxy for BrickMap.appendToEmbedded()
     *
     * @param {string} path
     * @param {string} data
     */
    this.appendToEmbeddedProxyHandler = (path, data) => {
        const dirtyBrickMap = state.getDirtyBrickMap();
        dirtyBrickMap.appendToEmbedded(path, data);
        state.getCurrentDiff().appendToEmbedded(path, data);
    }

    /**
     * Persists a BrickMap Brick
     *
     * @param {BrickMap} brickMap
     * @param {callback} callback
     */
    this.saveBrickMap = (domain, brickMap, callback) => {
        const brickMapBrick = brickMap.toBrick();

        brickMapBrick.setKeySSI(brickMap.getBrickEncryptionKeySSI());
        brickMapBrick.getTransformedData((err, brickData) => {
            if (err) {
                return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to get brickMap brick's transformed data`, err));
            }

            bricking.putBrick(domain, brickData, callback);
        });
    }

    /**
     * @param {Brick|undefined} brick
     * @param {function} callback
     */
    this.createBrickMap = (brick, callback) => {
        if (typeof brick === "function") {
            callback = brick;
            brick = undefined;
        }

        const brickMap = new BrickMap(brick, options);
        this.configureBrickMap(brickMap, (err => callback(err, brickMap)));
    }

    /**
     * @param {Brick|undefined} brick
     * @return {function} callback
     */
    this.createBrickMapDiff = (brick, callback) => {
        return createBrickMapDiff(brick, callback);
    }

    /**
     * @param {BrickMap} brickMap
     * @param callback
     */
    this.configureBrickMap = (brickMap, callback) => {
        if (!brickMap.getTemplateKeySSI()) {
            brickMap.setKeySSI(keySSI);
        }

        brickMap.load(callback);
    }

    /**
     * @param {object} rules
     * @param {object} rules.preWrite
     * @param {object} rules.afterLoad
     */
    this.setValidationRules = (rules) => {
        validator.setRules(rules);
    }

    /**
     * Start the anchoring process only
     * if the BrickMapStrategy decides it's time
     *
     * @param {callback} callback
     */
    this.attemptAnchoring = (callback) => {
        const dirtyBrickMap = state.getDirtyBrickMap();
        strategy.ifChangesShouldBeAnchored(dirtyBrickMap, (err, shouldBeAnchored) => {
            if (err) {
                return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to determine if changes should be anchored`, err));
            }

            if (!shouldBeAnchored) {
                return callback();
            }

            // In order to preserve backwards compatibility
            // with the existing code, if no "anchoring event listener"
            // is set, use the `callback` as a listener
            const anchoringEventListener = strategy.getAnchoringEventListener(callback);
            if (anchoringEventListener !== callback) {
                // Resume execution and perform the anchoring in the background
                // When anchoring has been done the `anchoringEventListener` will be notified
                callback();
            }

            this.anchorChanges(anchoringEventListener);
        });
    }

    /**
     * @param {callback} listener
     * @param {BrickMap|undefined} brickMap
     */
    this.anchorChanges = (listener, brickMap) => {
        if (anchoringInProgress) {
            return listener(undefined, anchoringStatus.ANCHORING_IN_PROGRESS);
        }

        if (!state.canBeAnchored() && !brickMap) {
            return listener(undefined, anchoringStatus.NOTHING_TO_ANCHOR);
        }

        anchoringInProgress = true;

        // Use the strategy to compact/merge any BrickMapDiff objects into a single
        // BrickMap instance
        strategy.compactDiffs(brickMap, (err, result) => {
            if (err) {
                return OpenDSUSafeCallback(listener)(createOpenDSUErrorWrapper(`Failed to compact diffs`, err));
            }

            const [brickMap, mergedDiffs] = result;
            const bricksDomain = keySSI.getBricksDomain();
            this.saveBrickMap(bricksDomain, brickMap, (err, hash) => {
                if (err) {
                    state.rollback(mergedDiffs);
                    return endAnchoring(listener, anchoringStatus.PERSIST_BRICKMAP_ERR, err);
                }

                keySSI.getAnchorId((err, anchorId) => {
                    if (err) {
                        return OpenDSUSafeCallback(listener)(createOpenDSUErrorWrapper(`Failed to get anchorId for keySSI ${keySSI.getIdentifier()}`, err));
                    }

                    const __storeAnchor = (anchorValue) => {
                        //signedHashLink should not contain any hint because is not trusted

                        const updateAnchorCallback = (err) => {
                            if (err) {
                                // In case of any errors, the compacted BrickMapDiff objects
                                // are put back into the "pending anchoring" state in case
                                // we need to retry the anchoring process
                                state.rollback(mergedDiffs);

                                // The anchoring middleware detected that we were trying
                                // to anchor outdated changes. In order to finish the anchoring
                                // process the conflict must be first resolved
                                if (isAliasSyncError(err)) {
                                    return this.handleAnchoringConflict(listener);
                                }

                                return endAnchoring(listener, anchoringStatus.ANCHOR_VERSION_ERR, err);
                            }

                            // After the alias is updated, the strategy is tasked
                            // with updating our anchored BrickMap with the new changes
                            strategy.afterBrickMapAnchoring(brickMap, anchorValue, (err, hashLink) => {
                                if (err) {
                                    return endAnchoring(listener, anchoringStatus.BRICKMAP_UPDATE_ERR, err);
                                }

                                endAnchoring(listener, anchoringStatus.OK, hashLink);

                                if (anchoringRequestExists()) {
                                    // Another anchoring was requested during the time this one
                                    // was in progress, as such, we start the process again
                                    this.anchorChanges(listener);
                                }
                            });
                        }

                        const currentAnchoredHashLink = state.getCurrentAnchoredHashLink();
                        /*if (!currentAnchoredHashLink) {
                            anchoring.createAnchor(keySSI, (err) => {
                                if (err) {
                                    return OpenDSUSafeCallback(listener)(createOpenDSUErrorWrapper(`Failed to create anchor`, err));
                                }

                                anchoring.appendToAnchor(keySSI, signedHashLink, '', updateAnchorCallback);
                            });
                        } else {
                            anchoring.appendToAnchor(keySSI, signedHashLink, currentAnchoredHashLink, updateAnchorCallback);
                        }*/

                        if (anchoringx.testIfRecoveryActiveFor(anchorId)) {
                            if (!keySSI.canAppend()) {
                                //if we are in recovery mode, and we are const keyssi type then we don't create the anchor
                                return updateAnchorCallback();
                            }
                            //if in recovery then we faked the last hashlink even if we couldn't load...
                            return anchoringx.appendAnchor(anchorId, anchorValue, updateAnchorCallback);
                        }

                        //TODO: update the smart contract and after that uncomment the above code and eliminate the following if statement
                        if (!currentAnchoredHashLink) {
                            anchoringx.getLastVersion(keySSI, (err, version) => {
                                if (err || !version) {
                                    // return OpenDSUSafeCallback(listener)(createOpenDSUErrorWrapper(`Failed to retrieve versions of anchor`, err));
                                    return anchoringx.createAnchor(anchorId, anchorValue, updateAnchorCallback);
                                }
                                return listener(createOpenDSUErrorWrapper(`Failed to create anchor`, err));
                            });
                        } else {
                            anchoringx.getLastVersion(keySSI, (err, version) => {
                                if (err || !version) {
                                    return listener(createOpenDSUErrorWrapper(`Failed to retrieve last anchor version`, err));
                                }

                                if (!anchoringx.testIfRecoveryActiveFor(anchorId) && version.getIdentifier() !== currentAnchoredHashLink.getIdentifier()) {
                                    return updateAnchorCallback({statusCode: 428, message: "Versions out of sync"})
                                }

                                anchoringx.appendAnchor(anchorId, anchorValue, updateAnchorCallback);
                            });
                        }
                    }

                    let lastEntryInAnchor;
                    let getCurrentHashLink = (callback) => {
                        callback(undefined, state.getCurrentAnchoredHashLink());
                    }

                    if (anchoringx.testIfRecoveryActiveFor(anchorId)) {
                        getCurrentHashLink = (callback) => {
                            return anchoringx.getLastVersion(anchorId, callback);
                        }
                    }

                    let proceed = (lastEntryInAnchor) => {
                        keySSI.createAnchorValue(hash, lastEntryInAnchor, (err, anchorValue) => {
                            if (err) {
                                return OpenDSUSafeCallback(listener)(createOpenDSUErrorWrapper(`The SSI type does not have write access`, err));
                            }

                            __storeAnchor(anchorValue);
                        });
                    }

                    if (state.getCurrentAnchoredHashLink() || anchoringx.testIfRecoveryActiveFor(anchorId)) {
                        return getCurrentHashLink((err, lastHashLink) => {
                            if (err) {
                                //ignorable error. can't happen
                            }
                            if (typeof lastHashLink === "string") {
                                lastHashLink = keySSISpace.parse(lastHashLink);
                            }
                            lastEntryInAnchor = lastHashLink.getIdentifier();
                            proceed(lastEntryInAnchor);
                        })
                    }
                    proceed(lastEntryInAnchor);
                });

            })
        });
    }

    /**
     * If an anchoring conflict occurs, reload our anchored BrickMap
     * in order to get the new changes and then try to merge our BrickMapDiff
     * instances
     *
     * @param {callback} listener
     */
    this.handleAnchoringConflict = (listener) => {
        const currentAnchoredHashLinkSSI = strategy.getCurrentHashLink();
        strategy.load(keySSI, (err, brickMap) => {
            if (err) {
                return endAnchoring(listener, anchoringStatus.BRICKMAP_LOAD_ERR, err);
            }
            state.setCurrentAnchoredHashLink(strategy.getCurrentHashLink());

            // Try and merge our changes
            strategy.reconcile(brickMap, currentAnchoredHashLinkSSI, (err, result) => {
                if (err) {
                    return endAnchoring(listener, anchoringStatus.BRICKMAP_RECONCILE_ERR, err);
                }

                anchoringInProgress = false;

                if (!result.status) {
                    return endAnchoring(listener, anchoringStatus.BRICKMAP_RECONCILIATION_HANDOFF)
                }
                this.anchorChanges(listener, result.brickMap);
            });
        });
    }

    /**
     * @return {boolean}
     */
    this.hasUnanchoredChanges = () => {
        return state.hasNewDiffs() || anchoringRequestExists();
    }

    /**
     * @return {object}
     */
    this.getState = () => {
        return state;
    }

    this.getCurrentAnchoredHashLink = () => {
        return state.getCurrentAnchoredHashLink();
    }


    /**
     * Toggle notifications publishing for new anchors
     * @param {boolean} status
     */
    this.enableAnchoringNotifications = (status) => {
        publishAnchoringNotifications = status;
    }

    /**
     * @return {boolean}
     */
    this.anchoringNotificationsEnabled = () => {
        return publishAnchoringNotifications;
    }

    /**
     * Load the latest BrickMaps then try and merge
     * the latest changes
     * @param {function} callback
     */
    this.mergeUpstreamChanges = (callback) => {
        const currentAnchoredHashLinkSSI = strategy.getCurrentHashLink();
        strategy.load(keySSI, (err, brickMap) => {
            if (err) {
                return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to load brickMap`, err));
            }

            strategy.merge(brickMap, currentAnchoredHashLinkSSI, (err, result) => {
                if (err) {
                    return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to merge latest DSU changes`, err));
                }


                callback(undefined, result.status);
            })
        })
    }

    initialize();
}

module.exports = BrickMapController;

},{"./AnchorValidator":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/bar/lib/AnchorValidator.js","./BrickMap":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/bar/lib/BrickMap.js","./BrickMapDiff":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/bar/lib/BrickMapDiff.js","./BrickMapStrategy":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/bar/lib/BrickMapStrategy/index.js","./constants":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/bar/lib/constants.js","opendsu":"opendsu","swarmutils":"swarmutils"}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/bar/lib/BrickMapDiff.js":[function(require,module,exports){
'use strict';

const BrickMapMixin = require('./BrickMapMixin');

/**
 * Auguments a BrickMap with an operations
 * log
 * @param {object} options
 * @param {string} options.prevDiffHash
 */
function BrickMapDiff(header) {
    Object.assign(this, BrickMapMixin);
    this.initialize(header);

    this.initialize = function (header, callback) {
        if (typeof header === "function") {
            callback = header;
            header = undefined;
        }

        BrickMapMixin.initialize.call(this, header);
        this.load((err) => {
            if (err) {
                return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to load BrickMapDiff`, err));
            }

            if (!this.header.metadata.log) {
                this.header.metadata.log = [];
            }

            callback();
        });
    }

    /**
     * @param {BrickMapDiff} brickMap
     * @throws {Error}
     */
    this.applyDiff = function (brickMap) {
        if (brickMap.constructor !== BrickMapDiff) {
            throw new Error('Unable to merge: expected a BrickMapDiff instance')
        }

        const metadata = brickMap.getMetadata('/');
        const operationsLog = metadata.log;

        if (!Array.isArray(operationsLog)) {
            throw new Error('Invalid BrickMapDiff. No replay log found');
        }

        if (!operationsLog.length) {
            return;
        }

        for (const operation of operationsLog) {
            const data = (typeof operation.data !== 'undefined') ? JSON.parse(JSON.stringify(operation.data))
                                                                 : operation.data;
            this.log(operation.op, operation.path, data);
        }
        this.updateMetadata('/', 'updatedAt', this.getTimestamp());
    }

    /**
     * @return {boolean}
     */
    this.hasItems = function () {
        return this.header.metadata.log.length > 0;
    };

    this.setPrevDiffHashLink = function (hashLink) {
        if (typeof hashLink === 'undefined') {
            return;
        }
        this.header.metadata.prevDiffHashLink = hashLink.getIdentifier();
    }

    /**
     * @param {string} op
     * @param {string} path
     * @param {object|undefined} data
     */
    this.log = function (op, path, data) {
        const timestamp = this.getTimestamp()
        this.header.metadata.log.push({ op, path, timestamp, data });
    }

    /**
     * @param {string} path
     * @param {Array<object>} bricks
     */
    this.addFileEntry = function (path, bricks) {
        this.log('add', path, bricks);
    }

    /**
     * @param {string} path
     * @param {Array<object>} bricks
     */
    this.appendBricksToFile = function (path, bricks) {
        this.log('append', path, bricks);
    }

    /**
     * @param {string} path
     */
    this.emptyList = function (path) {
        this.log('truncate', path);
    }

    /**
     * @param {string} path
     */
    this.delete = function (path) {
        this.log('delete', path);
    }

    /**
     * @param {string} srcPath
     * @param {string} dstPath
     */
    this.copy = function (srcPath, dstPath) {
        this.log('copy', srcPath, dstPath)
    }

    /**
     * @param {string} path
     */
    this.createFolder = function (path) {
        this.log('createFolder', path);
    }

    /**
     * @param {string} path
     */
    this.createFile = function (path) {
        this.log('createFile', path);
    }

    /**
     * @param {string} filePath
     * @param {object} brick
     */
    this.replaceFirstBrick = function (filePath, brick) {
        this.log('replaceFirstBrick', filePath, brick);
    }

    /**
     * @param {string} filePath
     * @param {object} brick
     */
    this.replaceLastBrick = function (filePath, brick) {
        this.log('replaceLastBrick', filePath, brick);
    }

    this.putEmbeddedFile = function(filePath, data) {
        this.log('embed', filePath, data);
    }

    this.appendToEmbedded = function(filePath, data){
        this.log('appendToEmbed', filePath, data);
    }
}
module.exports = BrickMapDiff;

},{"./BrickMapMixin":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/bar/lib/BrickMapMixin.js"}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/bar/lib/BrickMapMixin.js":[function(require,module,exports){
'use strict';

const Brick = require("./Brick");
const pskPath = require("swarmutils").path;
const pathModule = "path";
let path;
try {
    path = require(pathModule);
} catch (err) {
} finally {
    if (typeof path === "undefined") {
        path = {sep: "/"};
    }
}

const BrickMapMixin = {
    header: null,
    templateKeySSI: null,

    /**
     * @param {Brick|string|object} header
     */
    initialize: function (header, options) {
        options = options || {};
        this.header = header;
        if (this.header) {
            if(typeof this.header === "object" && !this.header.embedded){
                //for backwards compatibility reasons
                this.header.embedded = {};
            }
            return;
        }

        this.header = {
            v: 1,
            items: {},
            metadata: {},
            embedded: {}
        }

        if (!options.disableTimeMetadata) {
            this.header.metadata.createdAt = this.getTimestamp();
        }
    },

    updateTimeMetadata: function (target, prop, timestamp) {
        if (typeof target === "string") {
            target = this.getDeepestNode(target);
        }

        if(!target){
            return ;
        }

        prop = prop || "updatedAt";
        timestamp = timestamp || this.getTimestamp();
        if (this.header.metadata.createdAt) {
            if (!target.metadata) {
                target.metadata = {};
            }
            target.metadata[prop] = timestamp;
        }
    },

    /**
     * @return {boolean}
     */
    hasItems: function () {
        return Object.keys(this.header.items).length > 0 || (this.header.embedded && Object.keys(this.header.embedded).length > 0);
    },

    /**
     * @return {string}
     */
    getTimestamp: function () {
        return new Date().toUTCString();
    },

    /**
     * @param {object} node
     * @param {object} brick
     */
    appendBrick: function (node, brick) {
        this.updateTimeMetadata(node);
        const index = node.hashLinks.findIndex(br => br.hashLink === brick.hashLink);
        if (index !== -1) {
            throw Error(`Trying to add the same brick`);
        }

        node.hashLinks.push(brick);
    },

    /**
     * @param {string} filePath
     */
    getNodeFromPath: function (filePath) {
        filePath = pskPath.normalize(filePath);
        if (filePath === "") {
            throw new Error(`File path must not be empty.`);
        }

        const filePathNode = this.createNodesFromPath(filePath);
        // If this node was previously deleted, remove the "deletedAt" timestamp
        if (filePathNode.metadata.deletedAt) {
            delete filePathNode.metadata.deletedAt;
        }

        return filePathNode;
    },

    /**
     * @param {string} filePath
     * @param {object} brick
     */
    replaceFirstBrick: function (filePath, brick) {
        const node = this.getNodeFromPath(filePath);
        this.updateTimeMetadata(node);
        if (node.hashLinks.length > 0) {
            node.hashLinks[0] = brick;
        }
    },

    /**
     * @param {string} filePath
     * @param {object} brick
     */
    replaceLastBrick: function (filePath, brick) {
        const node = this.getNodeFromPath(filePath);
        this.updateTimeMetadata(node);
        if (node.hashLinks.length > 0) {
            node.hashLinks[node.hashLinks.length - 1] = brick;
        }
    },

    /**
     * @param {object} parent
     * @param {string} name
     */
    createFileNode: function (parent, name) {
        const node = {
            hashLinks: [],
            metadata: {}
        };
        parent.items[name] = node;
        this.updateTimeMetadata(node, "createdAt");
    },

    /**
     * @param {object} root
     * @param {string} name
     */
    createDirectoryNode: function (root, name) {
        const node = {
            metadata: {},
            items: {}
        }
        root.items[name] = node;
        this.updateTimeMetadata(node, "createdAt");
    },

    /**
     * Create all the nodes required to traverse `path`
     * and return the deepest node in the tree
     *
     * @param {string} path
     * @param {object} options
     * @param {string} options.trailingNodeType Possible values are 'child' or 'parent'
     * @return {object}
     */
    createNodesFromPath: function (path, options) {
        options = options || {
            trailingNodeType: 'child',
            addCreatedAtTimestamp: true
        };

        const pathSegments = path.split('/');

        let parentNode = this.header;
        let nodeName;

        while (pathSegments.length) {
            nodeName = pathSegments.shift();
            if (nodeName === "") {
                nodeName = pathSegments.shift();
            }

            if (parentNode.items[nodeName]) {
                delete parentNode.items[nodeName].metadata.deletedAt;
            }

            if (typeof parentNode.metadata === 'object') {
                // remove the "deletedAt" attribute in case we're trying
                // to add an entry in a previously deleted folder
                delete parentNode.metadata.deletedAt;
            }

            if (!pathSegments.length) {
                break;
            }


            if (!parentNode.items[nodeName]) {
                this.createDirectoryNode(parentNode, nodeName);
            }
            parentNode = parentNode.items[nodeName];
        }

        if (!parentNode.items[nodeName]) {
            if (options.trailingNodeType === 'child') {
                this.createFileNode(parentNode, nodeName);
            } else {
                this.createDirectoryNode(parentNode, nodeName);
            }
        }

        return parentNode.items[nodeName];
    },

    /**
     * @param {string} nodePath
     * @return {string} Returns a parent directory's path
     */
    dirname: function (path) {
        const segments = path.split('/');
        if (segments.length === 2 && segments[0] === "") {
            return '/';
        }
        return segments.slice(0, -1).join('/');
    },

    /**
     * @param {string} nodePath
     * @return {string} Returns trailing name component of a path
     */
    basename: function (path) {
        const segments = path.split('/');
        return segments.pop();
    },

    /**
     * @param {object} node
     * @return {boolean}
     */
    nodeIsDeleted: function (node) {
        return typeof node.metadata.deletedAt !== 'undefined';
    },

    /**
     * @param {object} node
     * @return {boolean}
     */
    nodeIsDirectory: function (node) {
        return typeof node.items === 'object';
    },

    /**
     * @param {object} node
     */
    deleteNode: function (node) {
        this.updateTimeMetadata(node, "deletedAt");
        if (this.nodeIsDirectory(node)) {
            node.items = {};
            return;
        }

        node.hashLinks = [];
    },

    /**
     * @param {object} node
     */
    truncateNode: function (node) {
        delete node.metadata.deletedAt;
        this.updateTimeMetadata(node);
        if (this.nodeIsDirectory(node)) {
            node.items = {};
        }

        node.hashLinks = [];
    },

    /**
     * Traverse the nodes identified by `toPath`
     * and return the deepest parent node in the tree
     *
     * @param {string} toPath
     * @return {object|undefined}
     */
    navigate: function (toPath) {
        let parentNode = this.header;
        const segments = toPath.split("/");

        for (let i in segments) {
            let segment = segments[i];
            if (!segment) {
                continue;
            }


            if (typeof parentNode.items[segment] === 'undefined') {
                return;
            }

            if (this.nodeIsDirectory(parentNode.items[segment])) {
                parentNode = parentNode.items[segment];

            }
        }

        return parentNode;
    },

    /**
     * Traverse `path` and return the deepest node
     * in the tree
     *
     * @param {string} path
     * @return {object}
     */
    getDeepestNode: function (path) {
        path = pskPath.normalize(path);
        if (path === '/') {
            return this.header;
        }

        const filename = this.basename(path);
        const dirPath = this.dirname(path);

        const parentNode = this.navigate(dirPath);

        if (!parentNode) {
            return;
        }

        return parentNode.items[filename];
    },


    /**
     * @param {string} path
     * @param {Array<object>} bricks
     */
    addFileEntry: function (path, bricks) {
        if (!this.isEmpty(path)) {
            this.emptyList(path);
        }

        this.appendBricksToFile(path, bricks);
    },

    /**
     * @param {string} path
     * @param {Array<object>} bricks
     */
    appendBricksToFile: function (path, bricks) {
        if (!Array.isArray(bricks)) {
            bricks = [bricks];
        }
        for (const data of bricks) {
            this.add(path, data);
        }
    },

    /**
     * Add brick data for `filePath`
     *
     * @param {string} filePath
     * @param {object} brick
     * @param {string} brick.hash
     * @param {object} brick.encryptionKey
     * @param {string} brick.checkSum
     *
     * @throws {Error}
     */
    add: function (filePath, brick) {
        filePath = pskPath.normalize(filePath);
        if (filePath === "") {
            throw new Error(`File path must not be empty.`);
        }

        const brickObj = {
            checkSum: brick.checkSum,
            hashLink: brick.hashLink
        };
        if (brick.size) {
            brickObj.size = brick.size;
        }

        if (brick.encryptionKey) {
            brickObj.key = brick.encryptionKey
        }

        const filePathNode = this.createNodesFromPath(filePath);
        // If this node was previously deleted, remove the "deletedAt" timestamp
        if (filePathNode.metadata.deletedAt) {
            delete filePathNode.metadata.deletedAt;
        }
        this.appendBrick(filePathNode, brickObj);
    },

    /**
     * @param {string} barPath
     * @throws {Error}
     */
    delete: function (barPath) {
        barPath = pskPath.normalize(barPath);
        const childNode = this.getDeepestNode(barPath);
        if (!childNode) {
            return;
        }
        if (this.nodeIsDeleted(childNode)) {
            return;
        }

        this.deleteNode(childNode);

        let deleteEmbedded = ()=>{
            if(this.header && this.header.embedded){
                let embeddedFiles = Object.keys(this.header.embedded);
                for(let filepath of embeddedFiles){
                    if(filepath.startsWith(barPath)){
                        delete this.header.embedded[filepath];
                    }
                }
            }
        }

        deleteEmbedded();
    },

    createNode: function (barPath, options) {
        barPath = pskPath.normalize(barPath);

        if (barPath === '/') {
            throw new Error('Invalid path: /');
        }

        const dirName = this.basename(barPath);
        const dirPath = this.dirname(barPath);
        const parentDir = this.getDeepestNode(dirPath);

        if (!dirName) {
            throw new Error('Missing folder name.');
        }

        if (dirPath && parentDir) {
            if (!this.nodeIsDirectory(parentDir)) {
                throw new Error('Unable to create a folder in a file.');
            }

            if (typeof parentDir.items[dirName] !== 'undefined' && options.trailingNodeType === "parent") {
                const currentNode = parentDir.items[dirName];
                if(this.nodeIsDeleted(currentNode)) {
                    // trying to create an already deleted node
                    // so we need remove the "deletedAt" timestamp
                    delete currentNode.metadata.deletedAt;
                    this.updateTimeMetadata(currentNode, "createdAt");
                    return;
                }

                throw new Error('Unable to create folder. A file or folder already exists in that location.');
            }
        }

        this.createNodesFromPath(barPath, options);
    },
    /**
     * Create an empty directory
     *
     * @param {string} barPath
     * @throws {Error}
     */
    createFolder: function (barPath) {
        this.createNode(barPath, {trailingNodeType: "parent"});
    },

    createFile: function (barPath) {
        this.createNode(barPath, {trailingNodeType: "child"});
    },
    /**
     * @param {string} filePath
     * @return {Array<object>}
     * @throws {Error}
     */
    getBricksMeta: function (filePath) {
        const fileNode = this.getDeepestNode(filePath);
        if (!fileNode) {
            throw new Error(`Path <${filePath}> not found.`);
        }
        if (this.nodeIsDirectory(fileNode)) {
            throw new Error(`Path <${filePath}> is a folder.`);
        }

        if (this.nodeIsDeleted(fileNode)) {
            throw new Error(`Path <${filePath}> not found.`);
        }

        return fileNode.hashLinks;
    },

    /**
     * @param {string} filePath
     * @return {Array<string>}
     * @throws {Error}
     */
    getHashList: function (filePath) {
        if (filePath === "") {
            throw new Error(`File path must not be empty.`);
        }

        const fileNode = this.getDeepestNode(filePath);
        if (!fileNode) {
            throw new Error(`Path <${filePath}> not found.`);
        }
        if (this.nodeIsDirectory(fileNode)) {
            throw new Error(`Path <${filePath}> is a folder.`);
        }

        const hashes = fileNode.hashLinks.map(brickObj => brickObj.hashLink);
        return hashes;
    },

    getEmbeddedFile: function (filePath) {
        if (filePath === "") {
            throw Error(`File path must not be empty.`);
        }

        let data;
        if (this.header.embedded && this.header.embedded[filePath]) {
            data = this.header.embedded[filePath].content;
        }

        return data;
    },

    putEmbeddedFile:  function (filePath, data) {
        if (filePath === "") {
            throw Error(`File path must not be empty.`);
        }

        if (!this.header.embedded) {
            this.header.embedded = {};
        }

        let embeddedFile = this.header.embedded[filePath];
        if(!embeddedFile){
            embeddedFile = {
                content: data,
                metadata:{}
            };
            this.header.embedded[filePath] = embeddedFile;
            this.updateTimeMetadata(embeddedFile, 'createdAt');
            return;
        }

        embeddedFile.content = data;
        this.updateTimeMetadata(embeddedFile);
    },

    appendToEmbedded: function (filePath, data) {
        let existingData = this.getEmbeddedFile(filePath);
        if (!existingData) {
            existingData = "";
        }

        this.putEmbeddedFile(filePath, existingData + data);
},
    /**
     * @param {string} filePath
     * @return {boolean}
     */
    isEmpty: function (filePath) {
        const node = this.getDeepestNode(filePath);
        if (!node) {
            return true;
        }

        if (this.nodeIsDirectory(node)) {
            return !Object.keys(node.items);
        }
        return !node.hashLinks.length;
    },

    /**
     * Truncates `filePath`
     * @param {string} filePath
     * @throws {Error}
     */
    emptyList: function (filePath) {
        const node = this.getDeepestNode(filePath);
        if (!node) {
            throw new Error(`Path <${filePath}> not found.`);
        }

        this.truncateNode(node);
    },

    /**
     * @param {string} path
     * @return {boolean}
     */
    fileExists: function (path) {
        const node = this.getDeepestNode(path);
        return node && !this.nodeIsDeleted(node);
    },

    /**
     * @param {string} path
     * @return {boolean}
     */
    fileDeleted: function (path) {
        const node = this.getDeepestNode(path);
        return node && this.nodeIsDeleted(node);
    },

    /**
     * @param {string} srcPath
     * @param {string} dstPath
     * @throws {Error}
     */
    copy: function (srcPath, dstPath) {
        const srcNode = this.getDeepestNode(srcPath);
        if (!srcNode) {
            throw new Error(`Source path <${srcPath}> not found.`);
        }

        const dstNode = this.createNodesFromPath(dstPath, {
            trailingNodeType: this.nodeIsDirectory(srcNode) ? 'parent' : 'child',
            addCreatedAtTimestamp: true
        });

        if (this.nodeIsDirectory(srcNode)) {
            // Clone hashlinks
            dstNode.items = JSON.parse(JSON.stringify(srcNode.items));
            return;
        }

        dstNode.hashLinks = JSON.parse(JSON.stringify(srcNode.hashLinks));
    },


    /**
     * @return {Brick}
     */
    toBrick: function () {
        let brickOptions = {templateKeySSI: this.templateKeySSI, brickMap: true};
        let hint = this.templateKeySSI.getHint();
        if(hint && hint.get("avoidRandom")){
            brickOptions.avoidRandom = true;
        }
        const brick = new Brick(brickOptions);
        brick.setKeySSI(this.templateKeySSI);
        brick.setRawData($$.Buffer.from(JSON.stringify(this.header)));
        return brick;
    },


    /**
     * @param {string} folderBarPath
     * @param {boolean} recursive
     * @return {Array<string>}
     */
    getFileList: function (folderBarPath, recursive) {
        let listEmbeddedFiles = ()=>{
            let files = [];
            if(this.header.embedded){
                if(recursive){
                    let embeddedFiles = Object.keys(this.header.embedded);
                    for(let filePath of embeddedFiles){
                        if(filePath.startsWith(folderBarPath)){
                            files.push(filePath.replace(folderBarPath, ""));
                        }
                    }
                }else{
                    let embeddedFiles = Object.keys(this.header.embedded);
                    for(let filePath of embeddedFiles){
                        if(filePath.startsWith(folderBarPath)){
                            let relativePath = filePath.replace(folderBarPath, "");
                            if(relativePath.indexOf("/")===-1){
                                files.push(relativePath);
                            }else{
                                //we skip this file because seems to be a directory (contains at least one more / character)
                            }
                        }
                    }
                }
            }
            return files;
        }

        if (typeof recursive === "undefined") {
            recursive = true;
        }
        const node = this.getDeepestNode(folderBarPath);
        if (!node) {
            let embeddedFiles = listEmbeddedFiles();
            return embeddedFiles;
        }

        const findFiles = (nodes, currentPath) => {
            let files = [];
            currentPath = currentPath || '';

            for (const itemName in nodes) {
                const item = nodes[itemName];
                const itemPath = pskPath.join(currentPath, itemName);

                if (this.nodeIsDirectory(item) && recursive) {
                    files = files.concat(findFiles(item.items, itemPath));
                    continue;
                }

                if (!this.nodeIsDeleted(item) && !this.nodeIsDirectory(item)) {
                    files.push(itemPath);
                }

            }

            return files;
        }

        const files = findFiles(node.items);
        const embeddedFiles = listEmbeddedFiles();

        return files.concat(embeddedFiles);
    },

    /**
     * @param {string} barPath
     * @param {boolean} recursive
     * @return {Array<string>}
     */
    getFolderList: function (barPath, recursive) {
        const node = this.getDeepestNode(barPath);
        if (!node) {
            return [];
        }

        const findFolders = (nodes, currentPath) => {
            let folders = [];
            currentPath = currentPath || '';

            for (const itemName in nodes) {
                const item = nodes[itemName];
                const itemPath = pskPath.join(currentPath, itemName);

                if (!this.nodeIsDirectory(item) || this.nodeIsDeleted(item)) {
                    continue;
                }

                folders.push(itemPath);

                if (recursive) {
                    folders = folders.concat(findFolders(item.items, itemPath));

                }
            }

            return folders;
        }

        const folders = findFolders(node.items);
        return folders;
    },

    getBrickEncryptionKeySSI: function (brickMeta) {
        if (typeof brickMeta === "undefined") {
            return this.templateKeySSI.getIdentifier();
        }

        return brickMeta.key;
    },

    /**
     * Load BrickMap state
     */
    load: function (callback) {
        /**
         * JSON reviver callback
         * Convert serialized $$.Buffer to $$.Buffer instance
         * @param {string} key
         * @param {string} value
         * @return {*}
         */
        const reviver = (key, value) => {
            if (key !== 'key') {
                return value;
            }

            if (typeof value !== 'object') {
                return value;
            }

            if (Object.keys(value).length !== 2) {
                return value;
            }

            if (value.type !== '$$.Buffer' || !Array.isArray(value.data)) {
                return value;
            }
            return $$.Buffer.from(value.data);
        };

        if (this.header instanceof Brick) {
            this.header.setKeySSI(this.templateKeySSI);
            this.header.setKeySSI(this.templateKeySSI.getIdentifier());
            this.header.getRawData((err, rawData) => {
                if (err) {
                    return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to get raw data`, err));
                }

                this.header = JSON.parse(rawData.toString(), reviver);
                setTimeout(() => {
                    callback();
                });
            });
        } else {
            if ($$.Buffer.isBuffer(this.header)) {
                this.header = this.header.toString();
            }

            if (typeof this.header === "string") {
                this.header = JSON.parse(this.header, reviver);
            }
            setTimeout(() => {
                callback();
            });
        }
    },

    /**
     * @param {KeySSI} keySSI
     */
    setKeySSI: function (keySSI) {
        this.templateKeySSI = keySSI;
    },

    /**
     * @return {KeySSI}
     */
    getTemplateKeySSI: function () {
        return this.templateKeySSI;
    },

    /**
     * @return {BrickMap}
     */
    clone: function (options, callback) {
        if (typeof options === "function") {
            callback = options;
            options = {};
        }
        const InstanceClass = this.constructor;
        const brickMap = new InstanceClass(JSON.stringify(this.header), options);
        brickMap.setKeySSI(this.templateKeySSI);
        brickMap.load((err) => {
            if (err) {
                return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to load brickMap`, err));
            }

            callback(undefined, brickMap);
        });
    },

    /**
     * @return {object}
     */
    getState: function () {
        return JSON.parse(JSON.stringify(this.header));
    },

    /**
     * @param {string} path
     * @return {object}
     * @throws {Error}
     */
    getMetadata: function (path) {
        const node = this.getDeepestNode(path);
        if (!node) {
            throw new Error(`Path <${path}> not found.`);
        }

        if (typeof node.metadata === 'undefined') {
            throw new Error(`Path dosn't have any metadata associated.`);
        }

        return node.metadata
    },

    /**
     * @param {object} metadata
     * @throws {Error}
     */
    setMetadata: function (path, metadata) {
        const node = this.getDeepestNode(path);
        if (!node) {
            throw new Error(`Path <${path}> not found.`);
        }
        node.metadata = JSON.parse(JSON.stringify(metadata));
    },

    /**
     * @param {string} path
     * @param {string} key
     * @param {*} value
     * @throws {Error}
     */
    updateMetadata: function (path, key, value) {
        const node = this.getDeepestNode(path);
        if (!node) {
            throw new Error(`Unable to update metadata. Path <${path}> not found.`);
        }

        node.metadata[key] = value;
    },

    getHashLink: function (callback) {
        const brick = this.toBrick();
        brick.setKeySSI(this.getBrickEncryptionKeySSI());
        brick.getHashLink(callback);
    },

    stat: function (path) {
        const node = this.getDeepestNode(path);
        if (this.nodeIsDirectory(node)) {
            return {type: "directory"}
        } else {
            return {type: "file"}
        }
    }
}

module.exports = BrickMapMixin;

},{"./Brick":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/bar/lib/Brick.js","swarmutils":"swarmutils"}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/bar/lib/BrickMapStrategy/BrickMapStrategyMixin.js":[function(require,module,exports){
const BrickMapStrategyMixin = {
    brickMapController: null,
    brickMapState: null,
    anchoringEventListener: null,
    conflictResolutionFunction: null,
    decisionFunction: null,
    signingFunction: null,
    cache: null,
    currentHashLink: null,
    validator: null,
    delay: null,
    anchoringTimeout: null,

    initialize: function (options) {
        this.options = options;
        if (typeof options.anchoringEventListener === 'function') {
            this.setAnchoringEventListener(options.anchoringEventListener);
        }

        if (typeof options.decisionFn === 'function') {
            this.setDecisionFunction(options.decisionFn);
        }

        if (typeof options.conflictResolutionFn === 'function') {
            this.setConflictResolutionFunction(options.conflictResolutionFn);
        }

        if (typeof options.signingFn === 'function') {
            this.setSigningFunction(options.signingFn);
        }

        if (typeof options.delay !== 'undefined' ) {
            if (!this.anchoringEventListener) {
                throw new Error("An anchoring event listener is required when choosing to delay anchoring");
            }
            this.delay = options.delay;
        }
    },

    /**
     * @param {BrickMapController} controller
     */
    setBrickMapController: function (controller) {
        this.brickMapController = controller;
    },

    /**
     * @param {object} state The BrickMap state
     */
    setBrickMapState: function (state) {
        this.brickMapState = state;
    },

    /**
     * @param {function} callback
     */
    setConflictResolutionFunction: function (fn) {
        this.conflictResolutionFunction = fn;
    },

    /**
     * @return {function}
     */
    getConflictResolutionFunction: function () {
        return this.conflictResolutionFunction;
    },

    /**
     *
     * @param {function} listener
     */
    setAnchoringEventListener: function (listener) {
        this.anchoringEventListener = listener;
    },

    /**
     * @param {function} fn
     */
    setSigningFunction: function (fn) {
        this.signingFunction = fn;
    },

    /**
     * @param {function} fn
     */
    setDecisionFunction: function (fn) {
        this.decisionFunction = fn;
    },

    /**
     * @return {function}
     */
    getDecisionFunction: function () {
        return this.decisionFunction;
    },

    /**
     * @param {object} validator 
     */
    setValidator: function (validator) {
        this.validator = validator;
    },

    /**
     * @param {psk-cache.Cache} cache 
     */
    setCache: function (cache) {
        this.cache = cache;
    },

    /**
     * @param {string} key 
     * @return {boolean}
     */
    hasInCache: function (key) {
        if (!this.cache) {
            return false;
        }

        return this.cache.has(key);
    },

    /**
     * @param {string} key 
     * @return {*}
     */
    getFromCache: function (key) {
        if (!this.cache) {
            return;
        }

        return this.cache.get(key);
    },

    /**
     * @param {string} key 
     * @param {*} value 
     */
    storeInCache: function (key, value) {
        if (!this.cache) {
            return;
        }

        this.cache.set(key, value)
    },

    /**
     *
     * @param {BrickMap} brickMap
     * @param {function} callback
     */
    ifChangesShouldBeAnchored: function (brickMap, callback) {
        if (typeof this.decisionFunction === 'function') {
            return this.decisionFunction(brickMap, callback);
        }

        if (this.delay !== null) {
            clearTimeout(this.anchoringTimeout);
            this.anchoringTimeout = setTimeout(() => {
                const anchoringEventListener = this.getAnchoringEventListener(function(){console.log("Anchoring...")});
                this.brickMapController.anchorChanges(anchoringEventListener);
            }, this.delay);
            return callback(undefined, false);
        }
        return callback(undefined, true);
    },

    /**
     * @return {string|null}
     */
    getCurrentHashLink: function () {
        return this.currentHashLink;
    },

    afterBrickMapAnchoring: function () {
        throw new Error('Unimplemented');
    },

    load: function () {
        throw new Error('Unimplemented');
    },

    /**
     * Merge diffs into a single BrickMap object
     * Handles the case when the list of diffs contains
     * whole BrickMap objects
     *
     * @param {BrickMap} brickMap
     * @param {Array<BrickMapDiff>} diffs
     * @return {BrickMap}
     */
    mergeDiffs: function (brickMap, diffs) {
        if (!brickMap && (!Array.isArray(diffs) || !diffs.length)) {
            throw new Error('A target and a list of diffs is required');
        }

        const mergedDiffs = [];

        while (diffs.length) {
            const brickMapDiff = diffs.shift();
            mergedDiffs.push(brickMapDiff);
            brickMap.applyDiff(brickMapDiff);
        }

        return [brickMap, mergedDiffs];
    },

    /* Detect any merge conflicts
     * @param {BrickMap} theirBrickMap The latest anchored BrickMap
     * @param {BrickMap} ourBrickMap Our anchored brickmap
     * @param {KeySSI} ourHashLinkSSI
     */
    detectMergeConflicts: function (theirBrickMap, ourBrickMap, ourHashLinkSSI) {
        // Detect the upstream changeset
        /* @var {BrickMap} */
        const theirChanges = ourBrickMap.diff(theirBrickMap);

        // Check if any of our changes conflict with upstream changeset
        const filesInConflict = theirChanges.detectMergeConflicts(this.brickMapState.getDiffsForAnchoring());

        let conflicts;

        // Call the conflict resolution function if it is defined, or return with error
        if (filesInConflict) {
            conflicts = {
                files: filesInConflict,
                ourHashLinkSSI: ourHashLinkSSI.getIdentifier(),
                theirHashLinkSSI: this.brickMapState.getCurrentAnchoredHashLink().getIdentifier()
            };
        }
        return conflicts;
    },

    /**
     * Detect merge conflicts and if any, call the conflict resolution function
     * or call the callback with an error
     * @param {BrickMap} theirBrickMap The latest anchored BrickMap
     * @param {BrickMap} ourBrickMap Our anchored brickmap
     * @param {KeySSI} ourHashLinkSSI
     * @param {function} callback
     * @return {boolean} True if merge conflicts were detected, False otherwise
     */
    mergeConflictsHandled: function (theirBrickMap, ourBrickMap, ourHashLinkSSI, callback) {
        const mergeConflicts = this.detectMergeConflicts(theirBrickMap, ourBrickMap, ourHashLinkSSI);

        if (!mergeConflicts) {
            return false;
        }

        // Call the conflict resolution function if it is defined, or return with error
        if (typeof this.conflictResolutionFunction === 'function') {
            this.conflictResolutionFunction(mergeConflicts, (err) => {
                if (err) {
                    return callback(err);
                }

                callback(undefined, {
                    status: false
                });
            });
            return true;
        }

        const conflictError = new Error('Anchoring conflict error');
        conflictError.conflicts = mergeConflicts;
        callback(conflictError);
        return true;
    },

    /**
     * Merge remote changes. This method is used when subscring to remote changes
     * on this DSU
     * @param {BrickMap} theirBrickMap The latest anchored BrickMap
     * @param {KeySSI} ourHashLinkSSI
     * @param {function} callback
     */
    merge: function (theirBrickMap, ourHashLinkSSI, callback) {
        const state = this.brickMapState;

        const ourAnchoredBrickMap = state.getAnchoredBrickMap();
        state.prepareNewChangesForAnchoring((err) => {
            if (err) {
                return callback(err);
            }

            if (this.mergeConflictsHandled(theirBrickMap, ourAnchoredBrickMap, ourHashLinkSSI, callback)) {
                return;
            }

            theirBrickMap.clone(this.options, (err, brickMap) => {
                if (err) {
                    return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to clone BrickMap`, err));
                }
                const dirtyBrickMap = theirBrickMap;

                // No conflicts detected, merge changes
                try {
                    const diffsForAnchoring = [...state.getDiffsForAnchoring()];
                    if (diffsForAnchoring.length) {
                        this.mergeDiffs(dirtyBrickMap, diffsForAnchoring);
                    }
                } catch (e) {
                    return callback(e);
                }

                state.setDirtyBrickMap(dirtyBrickMap);
                state.setAnchoredBrickMap(brickMap);
                state.setCurrentAnchoredHashLink(this.getCurrentHashLink());
                return callback(undefined, {
                    status: true
                });
            })
        });
    },


    /**
     * @param {function} defaultListener
     * @return {function}
     */
    getAnchoringEventListener: function (defaultListener) {
        let anchoringEventListener = this.anchoringEventListener;
        if (typeof anchoringEventListener !== 'function') {
            anchoringEventListener = defaultListener;
        }

        return anchoringEventListener;
    }
}

module.exports = BrickMapStrategyMixin;

},{}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/bar/lib/BrickMapStrategy/DiffStrategy.js":[function(require,module,exports){
'use strict';

const BrickMapStrategyMixin = require('./BrickMapStrategyMixin');
/**
 * @param {object} options
 * @param {callback} options.decisionFn Callback which will decide when to effectively anchor changes
 *                                                              If empty, the changes will be anchored after each operation
 * @param {callback} options.conflictResolutionFn Callback which will handle anchoring conflicts
 *                                                              The default strategy is to reload the BrickMap and then apply the new changes
 * @param {callback} options.anchoringCb A callback which is called when the strategy anchors the changes
 * @param {callback} options.signingFn  A function which will sign the new alias
 * @param {callback} callback
 */
function DiffStrategy(options) {
    options = options || {};
    Object.assign(this, BrickMapStrategyMixin);
    const openDSU = require("opendsu")
    const anchoring = openDSU.loadAPI("anchoring");
    const anchoringx = anchoring.getAnchoringX();
    const bricking = openDSU.loadAPI("bricking");
    ////////////////////////////////////////////////////////////
    // Private methods
    ////////////////////////////////////////////////////////////


    /**
     *
     * @param {Array<BrickMapDiff>} brickMapDiffs
     * @param {callback} callback
     */
    const createBrickMapFromDiffs = (brickMapDiffs, callback) => {
        this.brickMapController.createBrickMap((err, brickMap) => {
            if (err) {
                return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to create a new BrickMap`, err));
            }

            try {
                for (const brickMapDiff of brickMapDiffs) {
                    brickMap.applyDiff(brickMapDiff);
                }
            } catch (e) {
                return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to apply diffs on brickMap`, e));
            }

            callback(undefined, brickMap);

        });
    }

    /**
     * @param {Array<string>} hashLinks
     * @return {string}
     */
    const createBricksCacheKey = (hashLinks) => {
        return hashLinks.map(hashLink => {
            return hashLink.getIdentifier();
        }).join(':');
    };

    /**
     * @param {Array<Brick>} bricks
     * @return {Array<BrickMapDiff}
     */
    const createDiffsFromBricks = (bricks, callback) => {
        const diffs = [];
        const __createDiffsRecursively = (_bricks) => {
            if (_bricks.length === 0) {
                return callback(undefined, diffs);
            }

            const brick = _bricks.shift();
            this.brickMapController.createBrickMapDiff(brick, (err, brickMap) => {
                if (err) {
                    return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to create diffs from bricks`, err));
                }

                diffs.push(brickMap);
                __createDiffsRecursively(_bricks);
            });
        };

        __createDiffsRecursively(bricks);
    }

    /**
     * Get the list of BrickMapDiffs either from cache
     * or from Brick storage
     *
     * @param {Array<string>} hashLinks
     * @param {callback} callback
     */
    const getBrickMapDiffs = (hashLinks, callback) => {
        const cacheKey = createBricksCacheKey(hashLinks);
        if (this.hasInCache(cacheKey)) {
            const brickMapDiffs = this.getFromCache(cacheKey);
            return callback(undefined, brickMapDiffs);
        }

        const TaskCounter = require("swarmutils").TaskCounter;
        const bricks = [];
        const taskCounter = new TaskCounter(() => {
            createDiffsFromBricks(bricks, (err, brickMapDiffs) => {
                if (err) {
                    return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to create diffs from bricks`, err));
                }

                this.storeInCache(cacheKey, brickMapDiffs);
                callback(undefined, brickMapDiffs);
            });
        });
        taskCounter.increment(hashLinks.length);
        bricking.getMultipleBricks(hashLinks, (err, brickData) => {
            if (err) {
                return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to retrieve multiple bricks`, err));
            }

            bricks.push(createBrick(brickData));
            taskCounter.decrement();
        });
    }

    const createBrick = (brickData) => {
        const Brick = require("../../lib/Brick");
        const brick = new Brick();
        brick.setTransformedData(brickData);
        return brick;
    };
    /**
     * Assemble a final BrickMap from several BrickMapDiffs
     * after validating the history
     *
     * @param {Array<string>} hashLinks
     * @param {callback} callback
     */
    const assembleBrickMap = (hashLinks, callback) => {
        this.currentHashLink = hashLinks[hashLinks.length - 1];
        getBrickMapDiffs(hashLinks, (err, brickMapDiffs) => {
            if (err) {
                return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to retrieve brickMap diffs`, err));
            }

            this.validator.validate('brickMapHistory', brickMapDiffs, (err) => {
                if (err) {
                    return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to validate brickMapDiffs`, err));
                }

                createBrickMapFromDiffs(brickMapDiffs, callback);
            });
        })
    }


    ////////////////////////////////////////////////////////////
    // Public methods
    ////////////////////////////////////////////////////////////

    this.load = (keySSI, callback) => {
        keySSI.getAnchorId((err, anchorId) => {
            if (err) {
                return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to get anchorId for keySSI ${keySSI.getIdentifier()}`, err));
            }
            anchoringx.getAllVersions(keySSI, (err, hashLinks) => {
                if (err) {
                    return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to retrieve versions for anchor ${anchorId}`, err));
                }

                if (!hashLinks.length) {
                    return callback(new Error(`No data found for anchor <${anchorId}>`));
                }

                assembleBrickMap(hashLinks, callback);
            });
        })
    }


    /**
     * Compact a list of BrickMapDiff objects
     * into a single BrickMap object
     *
     * @param {BrickMap|undefined} dstBrickMap
     * @return {BrickMapDiff}
     */
    this.compactDiffs = (dstBrickMap, callback) => {
        if (typeof dstBrickMap === 'function') {
            callback = dstBrickMap;
            dstBrickMap = undefined;
        }
        this.brickMapState.prepareNewChangesForAnchoring((err) => {
            if (err) {
                return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to prepare diffs for anchoring`, err));
            }

            const mergedDiffs = (dstBrickMap, callback) => {
                const diffsForAnchoring = this.brickMapState.getDiffsForAnchoring();
                let result;
                let error;
                try {
                    result = this.mergeDiffs(dstBrickMap, diffsForAnchoring);
                } catch (e) {
                    error = e;
                }
                callback(error, result);
            }

            if (!dstBrickMap) {
                return this.brickMapController.createBrickMapDiff((err, dstBrickMap) => {
                    if (err) {
                        return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to create empty BrickMapDiff`, err));
                    }

                    mergedDiffs(dstBrickMap, callback);
                })

            }

            mergedDiffs(dstBrickMap, callback);
        })
    }

    /**
     * Merge the `diff` object into the current valid
     * BrickMap object
     *
     * @param {BrickMapDiff} diff
     * @param {string} diffHash
     * @param {callback} callback
     */
    this.afterBrickMapAnchoring = (diff, diffHash, callback) => {
        const anchoredBrickMap = this.brickMapState.getAnchoredBrickMap();
        try {
            anchoredBrickMap.applyDiff(diff);
        } catch (e) {
            return callback(e);
        }
        this.currentHashLink = diffHash;
        this.lastAnchorTimestamp = new Date().getTime();
        this.brickMapState.setCurrentAnchoredHashLink(diffHash);
        callback(undefined, diffHash);
    }


    /**
     * Try and fix an anchoring conflict
     *
     * Merge any "pending anchoring" BrickMapDiff objects in a clone
     * of our anchored BrickMap. If merging fails, call the 'conflictResolutionFn'
     * in order to fix the conflict. If merging succeeds, update the "dirtyBrickMap"
     *
     * If no 'conflictResolutionFn' function was defined
     * The callback will be called with the following error:
     *
     *  error: Error {
     *      message: 'Anchoring conflict error',
     *      conflicts: {
     *          files: {
     *              '/file/path/in/conflict': {
     *                  error: 'LOCAL_OVERWRITE|REMOTE_DELETE|LOCAL_DELETE', // type of conflict
     *                  message: '[User friendly error message]'
     *              },
     *              ...
     *          },
     *          theirHashLinkSSI: '...', // HashLinkSSI of the latest anchored BrickMap
     *          ourHashLinkSSI: '...' // The HashLinkSSI of our version
     *      }
     *  }
     *
     *  Where conflicts.*.error:
     *      LOCAL_OVERWRITE - Our changes will overwrite a newly anchored file/directory
     *      REMOTE_DELETE - The file path we're trying to anchor has been deleted
     *      LOCAL_DELETE - Our changes will delete a newly anchored file/directory
     *
     * If a 'conflictResolutionFn' is defined it will be called with the following arguments:
     *  conflicts - The conflicts object described above
     *  callback
     *
     * @param {BrickMap} theirBrickMap The latest anchored BrickMap
     * @param {KeySSI} ourHashLinkSSI
     * @param {function} callback
     */
    this.reconcile = (theirBrickMap, ourHashLinkSSI, callback) => {
        const state = this.brickMapState;

        const ourAnchoredBrickMap = state.getAnchoredBrickMap();
        state.prepareNewChangesForAnchoring((err) => {
            if (err) {
                return callback(err);
            }

            if (this.mergeConflictsHandled(theirBrickMap, ourAnchoredBrickMap, ourHashLinkSSI, callback)) {
                return;
            }

            // We only need to update the dirty brick map
            // The BrickMapController will compact our diffs and try to anchor them again
            try {
                this.mergeDiffs(theirBrickMap, [...state.getDiffsForAnchoring()]);
                state.setDirtyBrickMap(theirBrickMap);
            } catch (e) {
                return callback(e);
            }
            callback(undefined, {
                status: true
            });
        });
    }

    this.initialize(options);
}

module.exports = DiffStrategy;

},{"../../lib/Brick":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/bar/lib/Brick.js","./BrickMapStrategyMixin":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/bar/lib/BrickMapStrategy/BrickMapStrategyMixin.js","opendsu":"opendsu","swarmutils":"swarmutils"}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/bar/lib/BrickMapStrategy/LatestVersionStrategy.js":[function(require,module,exports){
'use strict';

const BrickMapStrategyMixin = require('./BrickMapStrategyMixin');
const Brick = require("../../lib/Brick");

/**
 * @param {object} options
 * @param {function} options.decisionFn Callback which will decide when to effectively anchor changes
 *                                                              If empty, the changes will be anchored after each operation
 * @param {function} options.anchoringCb A callback which is called when the strategy anchors the changes
 * @param {function} options.signingFn  A function which will sign the new alias
 * @param {function} callback
 */
function LatestVersionStrategy(options) {
    options = options || {};
    Object.assign(this, BrickMapStrategyMixin);
    const openDSU = require("opendsu");
    const anchoring = openDSU.loadAPI("anchoring");
    const anchoringx = anchoring.getAnchoringX();
    const bricking = openDSU.loadAPI("bricking");
    ////////////////////////////////////////////////////////////
    // Private methods
    ////////////////////////////////////////////////////////////

    /**
     * @param {Array<string>} hashes
     * @return {string}
     */
    const createBricksCacheKey = (hashes) => {
        return hashes.map(hash => {
            return hash.getIdentifier();
        }).join(':');
    };

    /**
     * @param {Array<Brick>} bricks
     * @return {Array<BrickMapDiff}
     */
    const createMapsFromBricks = (bricks, callback) => {
        const brickMaps = [];
        const __createBrickMapsRecursively = (_bricks) => {
            if (_bricks.length === 0) {
                return setTimeout(() => {
                    callback(undefined, brickMaps);
                });
            }

            const brick = _bricks.shift();
            this.brickMapController.createBrickMap(brick, (err, brickMap) => {
                if (err) {
                    return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to create a new BrickMap`, err));
                }

                brickMaps.push(brickMap);
                __createBrickMapsRecursively(_bricks);
            });
        };

        __createBrickMapsRecursively(bricks);
    }

    /**
     * Get a list of BrickMap objects either from cache
     * or from Brick storage
     *
     * @param {Array<string>} hashes
     * @param {function} callback
     */
    const createBrickMapsFromHistory = (hashes, callback) => {
        callback = $$.makeSaneCallback(callback);
        const cacheKey = createBricksCacheKey(hashes);
        if ($$.BRICK_CACHE_ENABLED) {
            if (this.hasInCache(cacheKey)) {
                const brickMaps = this.getFromCache(cacheKey);
                return setTimeout(() => {
                    callback(undefined, brickMaps);
                });
            }
        }

        const TaskCounter = require("swarmutils").TaskCounter;
        const bricks = [];
        const taskCounter = new TaskCounter(() => {
            createMapsFromBricks(bricks, (err, brickMaps) => {
                if (err) {
                    return callback(createOpenDSUErrorWrapper(`Failed to create maps from bricks`, err));
                }

                this.storeInCache(cacheKey, brickMaps);
                return setTimeout(() => {
                    callback(undefined, brickMaps);
                });
            });
        });
        taskCounter.increment(hashes.length);
        bricking.getMultipleBricks(hashes, (err, brickData) => {
            if (err) {
                return callback(createOpenDSUErrorWrapper(`Failed to retrieve multiple bricks`, err));
            }

            bricks.push(createBrick(brickData));
            taskCounter.decrement();
        });
    }

    const createBrick = (brickData) => {
        const brick = new Brick();
        brick.setTransformedData(brickData);
        return brick;
    };

    ////////////////////////////////////////////////////////////
    // Public methods
    ////////////////////////////////////////////////////////////

    /**
     * Get the latest BrickMap version after validating the
     * history
     *
     * @param {object} versionHash
     * @param {function} callback
     */
    this.loadBrickMapVersion = (versionHash, callback) => {
        this.currentHashLink = versionHash;
        const brickingAPI = openDSU.loadAPI("bricking");
        brickingAPI.brickExistsOnServer(versionHash, (err, exists) => {
            if (err) {
                return callback(err);
            }

            if (!exists) {
                return callback(new Error(`Brick with hash <${versionHash.getIdentifier()}> does not exist on server`));
            }

            createBrickMapsFromHistory([this.currentHashLink], (err, brickMaps) => {
                if (err) {
                    return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to create BrickMaps from history`, err));
                }

                this.validator.validate('brickMapHistory', brickMaps, (err) => {
                    if (err) {
                        return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to validate BrickMaps`, err));
                    }

                    const latestBrickMap = brickMaps[brickMaps.length - 1];
                    callback(undefined, latestBrickMap);
                });
            })
        })
    }

    this.load = (keySSI, callback) => {
        keySSI.getAnchorId((err, anchorId) => {
            if (err) {
                return callback(createOpenDSUErrorWrapper(`Failed to get anchorId for keySSI ${keySSI.getIdentifier()}`, err));
            }

            anchoringx.getLastVersion(keySSI, (err, versionHash) => {
                if (err) {
                    return callback(createOpenDSUErrorWrapper(`Failed to get versions for anchor ${anchorId}`, err));
                }
                if (!versionHash) {
                    return callback(new Error(`No data found for anchor <${anchorId}>`));
                }

                const openDSU = require("opendsu");
                const brickingAPI = openDSU.loadAPI("bricking");
                brickingAPI.brickExistsOnServer(versionHash, (err, exists) => {
                    if (err) {
                        return callback(err);
                    }

                    if (!exists) {
                        return callback(new Error(`Brick with hash <${versionHash.getIdentifier()}> does not exist on server`));
                    }

                    const keySSISpace = openDSU.loadAPI("keyssi");
                    if (typeof versionHash === "string") {
                        try {
                            versionHash = keySSISpace.parse(versionHash);
                        } catch (e) {
                            return callback(e);
                        }
                    }
                    this.loadBrickMapVersion(versionHash, callback);
                })
            });
        })
    }

    this.loadVersion = (keySSI, versionHash, callback) => {
        const keySSISpace = require("opendsu").loadAPI("keyssi");
        if (typeof versionHash === "string") {
            try {
                versionHash = keySSISpace.parse(versionHash);
            } catch (e) {
                return callback(e);
            }
        }
        this.loadBrickMapVersion(versionHash, callback);
    };

    /**
     * Compact a list of BrickMapDiff objects
     * into a single BrickMap object
     *
     * @param {BrickMap|undefined} dstBrickMap
     * @return {BrickMapDiff}
     */
    this.compactDiffs = (dstBrickMap, callback) => {
        if (typeof dstBrickMap === 'function') {
            callback = dstBrickMap;
            dstBrickMap = undefined;
        }
        this.brickMapState.prepareNewChangesForAnchoring((err) => {
            if (err) {
                return callback(err);
            }

            const mergeDiffs = (err, dst) => {
                if (err) {
                    return callback(err);
                }

                let result;
                try {
                    result = this.mergeDiffs(dst, this.brickMapState.getDiffsForAnchoring());
                } catch (e) {
                    return callback(e);
                }
                callback(undefined, result);
            }

            if (!dstBrickMap) {
                return this.brickMapState.cloneAnchoredBrickMap(mergeDiffs);
            }

            mergeDiffs(undefined, dstBrickMap);
        })
    }

    /**
     * Tell the BrickMapController to use the newly anchored
     * BrickMap as a valid one
     *
     * @param {BrickMap} diff
     * @param {string} brickMapHashLink
     * @param {function} callback
     */
    this.afterBrickMapAnchoring = (brickMap, brickMapHashLink, callback) => {
        this.currentHashLink = brickMapHashLink;
        this.lastAnchorTimestamp = new Date().getTime();
        this.brickMapState.setAnchoredBrickMap(brickMap);
        this.brickMapState.setCurrentAnchoredHashLink(brickMapHashLink);
        callback(undefined, brickMapHashLink);
    }

    /**
     * Try and fix an anchoring conflict
     *
     * Merge any "pending anchoring" BrickMapDiff objects in a clone
     * of our anchored BrickMap. If merging fails, call the 'conflictResolutionFn'
     * in order to fix the conflict. If merging succeeds, update the "dirtyBrickMap"
     *
     * If no 'conflictResolutionFn' function was defined
     * The callback will be called with the following error:
     *
     *  error: Error {
     *      message: 'Anchoring conflict error',
     *      conflicts: {
     *          files: {
     *              '/file/path/in/conflict': {
     *                  error: 'LOCAL_OVERWRITE|REMOTE_DELETE|LOCAL_DELETE', // type of conflict
     *                  message: '[User friendly error message]'
     *              },
     *              ...
     *          },
     *          theirHashLinkSSI: '...', // HashLinkSSI of the latest anchored BrickMap
     *          ourHashLinkSSI: '...' // The HashLinkSSI of our version
     *      }
     *  }
     *
     *  Where conflicts.*.error:
     *      LOCAL_OVERWRITE - Our changes will overwrite a newly anchored file/directory
     *      REMOTE_DELETE - The file path we're trying to anchor has been deleted
     *      LOCAL_DELETE - Our changes will delete a newly anchored file/directory
     *
     * If a 'conflictResolutionFn' is defined it will be called with the following arguments:
     *  conflicts - The conflicts object described above
     *  callback
     *
     * @param {BrickMap} theirBrickMap The latest anchored BrickMap
     * @param {KeySSI} ourHashLinkSSI
     * @param {function} callback
     */
    this.reconcile = (theirBrickMap, ourHashLinkSSI, callback) => {
        const state = this.brickMapState;

        state.cloneAnchoredBrickMap((err, ourAnchoredBrickMap) => {
            if (err) {
                return callback(err);
            }

            state.prepareNewChangesForAnchoring((err) => {
                if (err) {
                    return callback(err);
                }

                if (this.mergeConflictsHandled(theirBrickMap, ourAnchoredBrickMap, ourHashLinkSSI, callback)) {
                    return;
                }

                // No conflicts detected, merge changes
                let ourChanges;
                let mergedDiffs;
                try {
                    const diffsForAnchoring = state.getDiffsForAnchoring();

                    if (diffsForAnchoring.length) {
                        [ourChanges, mergedDiffs] = this.mergeDiffs(ourAnchoredBrickMap, diffsForAnchoring);
                        theirBrickMap.merge(ourChanges);
                    }

                    // Their BrickMap now has our changes
                    // and becomes ours
                    state.setDirtyBrickMap(theirBrickMap);
                } catch (e) {
                    state.rollback(mergedDiffs)
                    return callback(e);
                }
                return callback(undefined, {
                    status: true,
                    brickMap: theirBrickMap
                });
            });
        })
    };


    this.initialize(options);
}

module.exports = LatestVersionStrategy;

},{"../../lib/Brick":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/bar/lib/Brick.js","./BrickMapStrategyMixin":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/bar/lib/BrickMapStrategy/BrickMapStrategyMixin.js","opendsu":"opendsu","swarmutils":"swarmutils"}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/bar/lib/BrickMapStrategy/builtinBrickMapStrategies.js":[function(require,module,exports){
module.exports = {
    DIFF: 'Diff',
    LATEST_VERSION: 'LatestVersion',
    DEFAULT_BRICK_MAP_STRATEGY: 'LatestVersion'
    //DEFAULT_BRICK_MAP_STRATEGY: 'Diff'
}

},{}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/bar/lib/BrickMapStrategy/index.js":[function(require,module,exports){
function BrickMapStrategyFactory() {
    const DiffStrategy = require('./DiffStrategy');
    const LastestVersionStrategy = require('./LatestVersionStrategy');
    const builtInStrategies = require("./builtinBrickMapStrategies");
    const factories = {};

    ////////////////////////////////////////////////////////////
    // Private methods
    ////////////////////////////////////////////////////////////

    const initialize = () => {
        const builtinStrategies = require("./builtinBrickMapStrategies");
        this.registerStrategy(builtinStrategies.DIFF, this.createDiffStrategy);
        this.registerStrategy(builtinStrategies.LATEST_VERSION, this.createLatestVersionStrategy);
    }

    ////////////////////////////////////////////////////////////
    // Public methods
    ////////////////////////////////////////////////////////////

    /**
     * @param {string} strategyName
     * @param {object} factory
     */
    this.registerStrategy = (strategyName, factory) => {
        factories[strategyName] = factory;
    }

    /**
     * @param {string} strategyName
     * @param {object} options
     * @return {BrickMapStrategyMixin}
     */
    this.create = (strategyName, options) => {
        if (typeof strategyName === "undefined") {
            strategyName = builtInStrategies.DEFAULT_BRICK_MAP_STRATEGY;
        }
        const factory = factories[strategyName];
        options = options || {};
        return factory(options);
    }

    /**
     * @param {object} options
     * @return {DiffStrategy}
     */
    this.createDiffStrategy = (options) => {
        return new DiffStrategy(options);
    }

    /**
     * @param {object} options
     * @return {LastestVersionStrategy}
     */
    this.createLatestVersionStrategy = (options) => {
        return new LastestVersionStrategy(options);
    }

    initialize();
}

module.exports = BrickMapStrategyFactory;

},{"./DiffStrategy":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/bar/lib/BrickMapStrategy/DiffStrategy.js","./LatestVersionStrategy":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/bar/lib/BrickMapStrategy/LatestVersionStrategy.js","./builtinBrickMapStrategies":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/bar/lib/BrickMapStrategy/builtinBrickMapStrategies.js"}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/bar/lib/BrickStorageService/Service.js":[function(require,module,exports){
'use strict';


/**
 * Brick storage layer
 * Wrapper over EDFSBrickStorage
 *
 * @param {object} options
 * @param {Cache} options.cache
 * @param {number} options.bufferSize
 * @param {EDFSBrickStorage} options.storageProvider
 * @param {callback} options.brickFactoryFunction
 * @param {FSAdapter} options.fsAdapter
 * @param {callback} options.brickDataExtractorCallback
 */
function Service(options) {
    const envTypes = require("overwrite-require").constants;
    const isStream = require("../../utils/isStream");
    const stream = require('stream');
    const utils = require("swarmutils");
    const crypto = require("opendsu").loadAPI("crypto");

    options = options || {};
    this.cache = options.cache;
    this.bufferSize = parseInt(options.bufferSize, 10);
    this.brickFactoryFunction = options.brickFactoryFunction;
    this.fsAdapter = options.fsAdapter;
    this.brickDataExtractorCallback = options.brickDataExtractorCallback;
    this.keySSI = options.keySSI;

    const openDSU = require("opendsu");
    const SSIKeys = openDSU.loadApi("keyssi");
    const bricking = openDSU.loadApi("bricking");

    if (isNaN(this.bufferSize) || this.bufferSize < 1) {
        throw new Error('$$.Buffer size is required');
    }

    if (typeof this.brickFactoryFunction !== 'function') {
        throw new Error('A brick factory function is required');
    }

    if (!this.fsAdapter && $$.environmentType !== envTypes.BROWSER_ENVIRONMENT_TYPE &&
        $$.environmentType !== envTypes.SERVICE_WORKER_ENVIRONMENT_TYPE &&
        $$.environmentType !== envTypes.WEB_WORKER_ENVIRONMENT_TYPE) {
        throw new Error('A file system adapter is required');
    }

    if (typeof this.brickDataExtractorCallback !== 'function') {
        throw new Error('A Brick data extractor callback is required');
    }

    /**
     * @param {HashLinkSSI} hlSSI
     * @return {HashLinkSSI}
     */
    const stripHintFromHashLinkSSI = (hlSSI) => {
        //TODO: remove the stripHintFromHashLinkSSI and use direct
        return hlSSI.getNoHintIdentifier();
    };

    /**
     * @param {*} key
     * @return {Boolean}
     */
    const hasInCache = (key) => {
        if (!this.cache) {
            return false;
        }

        return this.cache.has(key);
    };

    /**
     * @param {*} key
     * @param {*} value
     */
    const storeInCache = (key, value) => {
        if (!this.cache) {
            return;
        }

        this.cache.set(key, value);
    };

    /**
     * Creates writable stream to a EDFSBrickStorage instance
     *
     * @param {EDFSBrickStorage} storageProvider
     * @param {callback} beforeCopyCallback
     * @return {stream.Writable}
     */
    const createBricksWritableStream = (storageProvider, beforeCopyCallback) => {
        const self = this;
        return ((storageProvider, beforeCopyCallback) => {

            const writableStream = new stream.Writable({
                write(brickContainer, encoding, callback) {
                    let {brick, brickMeta} = brickContainer;
                    if (typeof beforeCopyCallback === 'function') {
                        brick = beforeCopyCallback(brickMeta, brick);
                    }

                    brick.getTransformedData((err, brickData) => {
                        if (err) {
                            return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to get transformed data`, err));
                        }

                        bricking.putBrick(self.keySSI.getBricksDomain(), brickData, (err, digest) => {
                            if (err) {
                                return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to put brick`, err));
                            }

                            brick.getSummary((err, brickSummary) => {
                                if (err) {
                                    return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to get bricks summary`, err));
                                }


                                brickSummary.digest = digest;
                                this.bricksSummary.push(brickSummary);

                                callback();
                            });
                        })
                    });
                },
                objectMode: true
            });

            writableStream.bricksSummary = [];
            return writableStream;

        })(storageProvider, beforeCopyCallback);
    };

    /**
     * Create a readable stream of Brick objects
     * retrieved from EDFSBrickStorage
     *
     * @param {Array<object>} bricksMeta
     * @return {stream.Readable}
     */
    const createBricksReadableStream = (bricksMeta) => {
        return ((bricksMeta) => {

            let brickIndex = 0;

            const readableStream = new stream.Readable({
                read() {
                    if (!bricksMeta.length) {
                        return self.push(null);
                    }
                    if (brickIndex < bricksMeta.length) {
                        self.getBrick(brickIndex++);
                    }
                },
                objectMode: true
            });

            // Get a brick and push it into the stream
            const self = this;
            readableStream.getBrick = function (brickIndex) {
                const brickMeta = bricksMeta[brickIndex];
                const hlSSI = SSIKeys.parse(brickMeta.hashLink);
                bricking.getBrick(hlSSI, (err, brick) => {
                    if (err) {
                        this.destroy(err);
                        return;
                    }

                    this.push({
                        brickMeta,
                        brick
                    });

                    if (brickIndex >= (bricksMeta.length - 1)) {
                        this.push(null);
                    }
                });
            };

            return readableStream;

        })(bricksMeta);
    };

    const createBrick = (brickData) => {
        const Brick = require("../Brick");
        const brick = new Brick();
        brick.setTransformedData(brickData);
        return brick;
    };

    /**
     * @param {HashLinkSSI} hlSSI
     * @return {boolean}
     */
    const hashLinkHasEmbeddedHint = (hlSSI) => {
        return (hlSSI && typeof hlSSI.getEmbeddedData() !== "undefined");
    }

    /**
     * Extract an embedded Brick from an unencrypted Brick container
     * @param {HashLinkSSI} hlSSI
     * @param {object} brickMeta
     * @param {callback} callback
     */
    const getEmbeddedBrickAsBuffer = (hlSSI, brickMeta, callback) => {
        const hintSegments = hlSSI.getEmbeddedData();
        let [offset, size, embeddedHlSSI] = hintSegments.split(',');

        offset = parseInt(offset, 10);
        size = parseInt(size, 10);

        if (isNaN(offset) || isNaN(size) || !embeddedHlSSI) {
            return callback(new Error(`Embedded hint is invalid. Expected offset,size,hlSSI and got: ${hintSegments}`));
        }

        const cacheKey = embeddedHlSSI;

        if (hasInCache(cacheKey)) {
            const data = this.cache.get(cacheKey);
            return callback(undefined, data);
        }

        const containerBrickMeta = Object.assign({}, brickMeta);
        // The container Brick is not encrypted
        delete containerBrickMeta.key;
        // The container Brick doesn't need the hint
        containerBrickMeta.hashLink = stripHintFromHashLinkSSI(hlSSI);

        // Get the container Brick data
        getBrickAsBuffer(containerBrickMeta, (err, data) => {
            if (err) {
                return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to get bricks as buffer`, err));
            }

            const brickData = data.slice(offset, offset + size);
            return this.brickDataExtractorCallback(brickMeta, createBrick(brickData), (err, data) => {
                if (err) {
                    return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to process brick data`, err));
                }

                storeInCache(cacheKey, data);
                return callback(undefined, data);
            });
        });
    }

    /**
     * Retrieves a Brick from storage and converts
     * it into a $$.Buffer
     *
     * @param {object} brickMeta
     * @param {callback} callback
     */
    const getBrickAsBuffer = (brickMeta, callback) => {
        const hlSSI = SSIKeys.parse(brickMeta.hashLink);

        if (hlSSI.isEmbed()) {
            return callback(undefined, hlSSI.getSpecificString());
        }

        if (hashLinkHasEmbeddedHint(hlSSI)) {
            return getEmbeddedBrickAsBuffer(hlSSI, brickMeta, callback);
        }

        let cacheKey = brickMeta.hashLink;
        if (hasInCache(cacheKey)) {
            const data = this.cache.get(cacheKey);
            return callback(undefined, data);
        }

        bricking.getBrick(hlSSI, (err, brickData) => {
            if (err) {
                return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to get brick data`, err));
            }

            function checkBrickDataIntegrity(brickData, callback) {
                brickData = utils.ensureIsBuffer(brickData);
                const hashFn = crypto.getCryptoFunctionForKeySSI(hlSSI, "hash");
                const _brickHash = hashFn(brickData);
                if (err) {
                    return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to compute brick hash`, err));
                }

                const brickHash = hlSSI.getHash();

                if (brickHash !== _brickHash) {
                    return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Got invalid data for brick ${brickHash}`, Error("Possible brick data corruption")));
                }

                callback();
            }

            checkBrickDataIntegrity(brickData, (err) => {
                if (err) {
                    return callback(err);
                }

                this.brickDataExtractorCallback(brickMeta, createBrick(brickData), (err, data) => {
                    if (err) {
                        return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to process brick data`, err));
                    }

                    if (!$$.Buffer.isBuffer(data) && (data instanceof ArrayBuffer || ArrayBuffer.isView(data))) {
                        data = utils.ensureIsBuffer(data);
                    }
                    storeInCache(cacheKey, data);
                    return callback(undefined, data);
                });
            });
        });
    };

    /**
     * Counts the number of blocks in a file
     *
     * @param {string} filePath
     * @param {callback} callback
     */
    const getFileBlocksCount = (filePath, callback) => {
        this.fsAdapter.getFileSize(filePath, (err, size) => {
            if (err) {
                return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to get size for file <${filePath}>`, err));
            }

            let blocksCount = Math.floor(size / this.bufferSize);
            if (size % this.bufferSize > 0) {
                ++blocksCount;
            }

            callback(undefined, blocksCount);
        })
    };

    /**
     * Creates a Brick from a $$.Buffer
     * and saves it into brick storage
     *
     * @param {$$.Buffer} data
     * @param {boolean|callback} encrypt Defaults to `true`
     * @param {callback|undefined} callback
     */
    const convertDataBlockToBrick = (data, encrypt, callback) => {
        if (typeof encrypt === 'function') {
            callback = encrypt;
            encrypt = true;
        }
        const brick = this.brickFactoryFunction(encrypt);
        brick.setRawData(data);
        brick.getTransformedData((err, brickData) => {
            if (err) {
                return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to get transformed data`, err));
            }

            bricking.putBrick(this.keySSI.getBricksDomain(), brickData, (err, digest) => {
                if (err) {
                    return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to put brick`, err));
                }

                brick.getSummary((err, brickSummary) => {
                    if (err) {
                        return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to get bricks summary`, err));
                    }


                    brickSummary.digest = digest;
                    callback(undefined, brickSummary);
                });
            });
        });
    };

    /**
     * Recursively breaks a buffer into Brick objects and
     * stores them into storage
     *
     * @param {Array<object>} resultContainer
     * @param {$$.Buffer} buffer
     * @param {number} blockIndex
     * @param {object} options
     * @param {number} options.bufferSize
     * @param {callback} callback
     */
    const convertBufferToBricks = (resultContainer, buffer, blockIndex, options, callback) => {
        const bufferSize = options.bufferSize;
        let blocksCount = Math.floor(buffer.length / bufferSize);
        if ((buffer.length % bufferSize) > 0) {
            ++blocksCount;
        }

        const encrypt = (typeof options.encrypt === 'undefined') ? true : options.encrypt;
        const blockData = buffer.slice(blockIndex * bufferSize, (blockIndex + 1) * bufferSize);

        convertDataBlockToBrick(blockData, encrypt, (err, result) => {
            if (err) {
                return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to convert data block to brick`, err));
            }

            resultContainer.push(result);
            ++blockIndex;

            if (blockIndex < blocksCount) {
                return convertBufferToBricks(resultContainer, buffer, blockIndex, options, callback);
            }

            return callback();
        });
    };

    /**
     * Copy the contents of a file into brick storage
     *
     * @param {Array<object>} resultContainer
     * @param {string} filePath
     * @param {object} options
     * @param {number} options.blockIndex
     * @param {number} options.blocksCount
     * @param {boolean} options.encrypt
     * @param {callback} callback
     */
    const convertFileToBricks = (resultContainer, filePath, options, callback) => {
        if (typeof options === 'function') {
            callback = options;
            options = {
                encrypt: true
            }
        }

        if (typeof options.blockIndex === 'undefined') {
            options.blockIndex = 0;
        }

        let blockIndex = options.blockIndex;
        const blocksCount = options.blocksCount;
        const blockOffset = blockIndex * this.bufferSize;
        const blockEndOffset = (blockIndex + 1) * this.bufferSize - 1;
        this.fsAdapter.readBlockFromFile(filePath, blockOffset, blockEndOffset, (err, data) => {
            if (err) {
                return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to read block from file <${filePath}>`, err));
            }

            convertDataBlockToBrick(data, options.encrypt, (err, result) => {
                if (err) {
                    return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to convert data block to brick`, err));
                }

                resultContainer.push(result);
                ++blockIndex;

                if (blockIndex < blocksCount) {
                    options.blockIndex = blockIndex;
                    return convertFileToBricks(resultContainer, filePath, options, callback);
                }

                return callback();
            })
        })
    };

    /**
     * Save the buffer containing multiple files as a single brick
     * and generate the proper HashLinkSSI for each file in the brick
     *
     * Each file's HashLinkSSI is constructed by appending the `embedded/${offset},${size}` hint
     * at the end of the Brick's HashLinkSSI. Ex:
     * Brick HashLinkSSI:
     *      ssi:hl:default:29LuHPtSrCG7u4nKNPB8KbG2EuK1U84X5pTTTko2GGcpxZGyPFC1jG8hAh6g2DbYKJxYumJFmNyQWu3iNpQe5jHR::v0
     * File in brick HashLinkSSI:
     *      ssi:hl:default:29LuHPtSrCG7u4nKNPB8KbG2EuK1U84X5pTTTko2GGcpxZGyPFC1jG8hAh6g2DbYKJxYumJFmNyQWu3iNpQe5jHR::v0:embedded/0,5
     *
     * @param {$$.Buffer} buffer
     * @param {Array<Object>} filesList
     * @param {string} filesList[].filename
     * @param {Number} filesList[].offset
     * @param {Number} filesList[].size
     * @param {callback} callback
     */
    const storeCompactedFiles = (buffer, filesList, callback) => {
        return convertDataBlockToBrick(buffer, false, (err, brickMeta) => {
            if (err) {
                return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to convert data block to brick`, err));
            }
            const files = {};
            const brickHLSSI = SSIKeys.parse(brickMeta.hashLink);

            for (const fileInfo of filesList) {

                const fileHLSSI = SSIKeys.createHashLinkSSI(
                    brickHLSSI.getDLDomain(),
                    brickHLSSI.getSpecificString(),
                    brickHLSSI.getVn()
                );

                fileHLSSI.setEmbeddedData(`${fileInfo.offset},${fileInfo.size},${fileInfo.brickSummary.hashLink}`);
                fileInfo.brickSummary.hashLink = fileHLSSI.getIdentifier();
                files[fileInfo.filename] = [fileInfo.brickSummary];
            }

            return callback(undefined, files);
        });
    }

    /**
     * Stores a $$.Buffer as Bricks into brick storage
     *
     * @param {$$.Buffer} buffer
     * @param {objects|callback} options
     * @param {number|callback} options.bufferSize
     * @param {callback|undefined} callback
     */
    this.ingestBuffer = (buffer, options, callback) => {
        if (typeof options === 'function') {
            callback = options;
            options = {
                encrypt: true
            }
        }

        if (!options.bufferSize) {
            options.bufferSize = this.bufferSize;
        }

        const bricksSummary = [];
        convertBufferToBricks(bricksSummary, buffer, 0, options, (err) => {
            if (err) {
                return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to convert buffer to bricks`, err));
            }

            callback(undefined, bricksSummary);
        });
    };

    /**
     * Reads a stream of data into multiple Brick objects
     * stored in brick storage
     *
     * @param {stream.Readable} stream
     * @param {object|callback} options
     * @param {boolean} options.encrypt
     * @param {callback}
     */
    this.ingestStream = (stream, options, callback) => {
        if (typeof options === 'function') {
            callback = options;
            options = {
                encrypt: true
            };
        }

        let bricksSummary = [];
        let receivedData = [];
        stream.on('data', (chunk) => {
            if (typeof chunk === 'string') {
                chunk = $$.Buffer.from(chunk);
            }

            receivedData.push(chunk);
            let chunksCount = this.bufferSize / chunk.length;
            if (receivedData.length >= chunksCount) {
                const buffer = $$.Buffer.concat(receivedData.splice(0, chunksCount));
                stream.pause();
                const ingestBufferOptions = {
                    bufferSize: buffer.length,
                    encrypt: options.encrypt
                };
                this.ingestBuffer(buffer, ingestBufferOptions, (err, summary) => {
                    if (err) {
                        stream.destroy(err);
                        return;
                    }
                    bricksSummary = bricksSummary.concat(summary);
                    stream.resume();
                });
            }
        });
        stream.on('error', (err) => {
            return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to ingest stream`, err));
        });
        stream.on('end', () => {
            const buffer = $$.Buffer.concat(receivedData);
            const ingestBufferOptions = {
                bufferSize: buffer.length,
                encrypt: options.encrypt
            };
            this.ingestBuffer(buffer, ingestBufferOptions, (err, summary) => {
                if (err) {
                    return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to ingest buffer`, err));
                }

                bricksSummary = bricksSummary.concat(summary);
                callback(undefined, bricksSummary);
            });
        })
    };

    /**
     * @param {string|$$.Buffer|stream.Readable} data
     * @param {callback} callback
     */
    this.ingestData = (data, options, callback) => {
        if (typeof data === 'string') {
            data = $$.Buffer.from(data);
        }

        if (typeof options === 'function') {
            callback = options;
            options = {
                encrypt: true,
            };
        }

        if (!$$.Buffer.isBuffer(data) && !isStream.isReadable(data)) {
            return callback(Error(`Type of data is ${typeof data}. Expected $$.Buffer or Stream.Readable`));
        }

        if ($$.Buffer.isBuffer(data)) {
            return this.ingestBuffer(data, options, callback);
        }

        return this.ingestStream(data, options, callback);
    };

    /**
     * Copy the contents of a file into brick storage
     *
     * @param {string} filePath
     * @param {object|callback} options
     * @param {boolean} options.encrypt
     * @param {callback} callback
     */
    this.ingestFile = (filePath, options, callback) => {
        if (typeof options === 'function') {
            callback = options;
            options = {
                encrypt: true
            }
        }
        const bricksSummary = [];

        getFileBlocksCount(filePath, (err, blocksCount) => {
            if (err) {
                return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed get blocks for file <${filePath}>`, err));
            }

            const conversionOptions = Object.assign({}, options);
            conversionOptions.blocksCount = blocksCount;
            convertFileToBricks(bricksSummary, filePath, conversionOptions, (err) => {
                if (err) {
                    return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to convert file <${filePath}> to bricks`, err));
                }

                callback(undefined, bricksSummary);
            });
        });
    };

    /**
     * Copy the contents of multiple files into brick storage
     *
     * @param {Array<string>} filePath
     * @param {object|callback} options
     * @param {boolean} options.encrypt
     * @param {callback} callback
     */
    this.ingestFiles = (files, options, callback) => {
        if (typeof options === 'function') {
            callback = options;
            options = {
                encrypt: true
            }
        }

        const bricksSummary = {};

        const ingestFilesRecursive = (files, callback) => {
            if (!files.length) {
                return callback(undefined, bricksSummary);
            }

            const filePath = files.pop();
            const filename = require("path").basename(filePath);

            this.ingestFile(filePath, options, (err, result) => {
                if (err) {
                    return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to ingest file <${filePath}>`, err));
                }

                bricksSummary[filename] = result;

                ingestFilesRecursive(files, callback);
            });
        };

        ingestFilesRecursive(files, callback);
    };
    
    /**
     * Copy the contents of folder into a single brick
     *
     * @param {string} folderPath
     * @param {object|callback} options
     * @param {boolean} options.encrypt
     * @param {callback} callback
     */
    this.createBrickFromFolder = (folderPath, options, callback) => {
        if (typeof options === 'function') {
            callback = options;
            options = {
                encrypt: true
            }
        }
        const filesIterator = this.fsAdapter.getFilesIterator(folderPath);
        const filesList = [];

        const brickBuffers = [];
        let currentOffset = 0;

        const iteratorHandler = (err, filename, dirname) => {
            if (err) {
                return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to create brick from folder <${folderPath}>`, err));
            }

            if (typeof filename === 'undefined') {
                const buffer = $$.Buffer.concat(brickBuffers);
                return storeCompactedFiles(buffer, filesList, callback);
            }

            const filePath = require("path").join(dirname, filename);
            this.readFile(filePath, (err, fileBuffer) => {
                if (err) {
                    return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to read file <${filePath}>`, err));
                }

                const fileBrick = this.brickFactoryFunction(options.encrypt);
                fileBrick.setRawData(fileBuffer);
                fileBrick.getTransformedData((err, brickData) => {
                    if (err) {
                        return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to get transformed data`, err));
                    }

                    fileBrick.getSummary((err, brickSummary) => {
                        if (err) {
                            return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to get brick summary`, err));
                        }

                        const size = brickData.length;
                        const offset = currentOffset;

                        currentOffset += size;
                        filesList.push({
                            filename,
                            offset,
                            size,
                            brickSummary
                        });
                        brickBuffers.push(brickData);

                        filesIterator.next(iteratorHandler);
                    })
                });
            });
        };

        filesIterator.next(iteratorHandler);

    };

    /**
     * Copy the contents of multiple files into a single brick
     *
     * @param {string} folderPath
     * @param {object|callback} options
     * @param {boolean} options.encrypt
     * @param {callback} callback
     */
    this.createBrickFromFiles = (files, options, callback) => {
        if (typeof options === 'function') {
            callback = options;
            options = {
                encrypt: true
            }
        }
        const filesList = [];

        const brickBuffers = [];
        let currentOffset = 0;
        const readFilesRecursive = (files, callback) => {
            if (!files.length) {
                const buffer = $$.Buffer.concat(brickBuffers);
                return storeCompactedFiles(buffer, filesList, callback);
            }

            const filePath = files.pop();
            const filename = require("path").basename(filePath);

            this.readFile(filePath, (err, fileBuffer) => {
                if (err) {
                    return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to read file <${filePath}>`, err));
                }

                const fileBrick = this.brickFactoryFunction(options.encrypt);
                fileBrick.setRawData(fileBuffer);
                fileBrick.getTransformedData((err, brickData) => {
                    if (err) {
                        return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to get transformed data`, err));
                    }

                    fileBrick.getSummary((err, brickSummary) => {
                        if (err) {
                            return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to ingest file <${filePath}>`, err));
                        }

                        const size = brickData.length;
                        const offset = currentOffset;

                        currentOffset += size;
                        filesList.push({
                            filename,
                            offset,
                            size,
                            brickSummary
                        });
                        brickBuffers.push(brickData);

                        readFilesRecursive(files, callback);
                    });
                });
            });
        }

        readFilesRecursive(files, callback);
    };

    /**
     * Copy the contents of folder into brick storage
     *
     * @param {string} folderPath
     * @param {object|callback} options
     * @param {boolean} options.encrypt
     * @param {callback} callback
     */
    this.ingestFolder = (folderPath, options, callback) => {
        if (typeof options === 'function') {
            callback = options;
            options = {
                encrypt: true
            };
        }
        const bricksSummary = {};
        const filesIterator = this.fsAdapter.getFilesIterator(folderPath);

        const iteratorHandler = (err, filename, dirname) => {
            if (err) {
                return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to ingest folder <${folderPath}>`, err));
            }

            if (typeof filename === 'undefined') {
                return callback(undefined, bricksSummary);
            }

            const filePath = require("path").join(dirname, filename);
            this.ingestFile(filePath, options, (err, result) => {
                if (err) {
                    return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to ingest file <${filePath}>`, err));
                }

                bricksSummary[filename] = result;
                filesIterator.next(iteratorHandler);
            });
        };

        filesIterator.next(iteratorHandler);
    };

    /**
     * Retrieve all the Bricks identified by `bricksMeta`
     * from storage and create a $$.Buffer using their data
     *
     * @param {Array<object>} bricksMeta
     * @param {callback} callback
     */
    this.createBufferFromBricks = (bricksMeta, callback) => {
        const buffers = [];
        const getBricksAsBufferRecursive = (index, callback) => {
            const brickMeta = bricksMeta[index];
            getBrickAsBuffer(brickMeta, (err, data) => {
                if (err) {
                    return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to get bricks as buffer`, err));
                }

                buffers.push(data);
                ++index;

                if (index < bricksMeta.length) {
                    return getBricksAsBufferRecursive(index, callback);
                }

                const buffer = $$.Buffer.concat(buffers);
                callback(undefined, buffer);
            });
        };

        getBricksAsBufferRecursive(0, callback);
    };

    /**
     * Retrieve all the Bricks identified by `bricksMeta`
     * from storage and create a readable stream
     * from their data
     *
     * @param {Array<object>} bricksMeta
     * @param {callback} callback
     */
    this.createStreamFromBricks = (bricksMeta, callback) => {
        let brickIndex = 0;

        const readableStream = new stream.Readable({
            read() {
                if (!bricksMeta.length) {
                    return this.push(null);
                }

                if (brickIndex < bricksMeta.length) {
                    this.readBrickData(brickIndex++);
                }
            }
        });

        // Get a brick and push it into the stream
        readableStream.readBrickData = function (brickIndex) {
            const brickMeta = bricksMeta[brickIndex];
            getBrickAsBuffer(brickMeta, (err, data) => {
                if (err) {
                    this.destroy(err);
                    return;
                }

                this.push(data);

                if (brickIndex >= (bricksMeta.length - 1)) {
                    this.push(null);
                }
            });
        };

        callback(undefined, readableStream);
    };

    /**
     * Retrieve all the Bricks identified by `sizeSSI` and `bricksMeta`
     * from storage and create a readable stream
     * from their data
     *
     * @param {SizeSSI} sizeSSI
     * @param {Array<object>} bricksMeta
     * @param {callback} callback
     */
    this.createStreamFromBricksWithRange = (sizeSSI, bricksMeta, range, callback) => {
        const totalSize = sizeSSI.getTotalSize();
        const bufferSize = sizeSSI.getBufferSize();
        const {start, end} = range;
        let brickIndex = Math.floor(start / bufferSize);

        const readableStream = new stream.Readable({
            read() {
                if (!bricksMeta.length) {
                    return this.push(null);
                }

                if (brickIndex < bricksMeta.length) {
                    this.readBrickData(brickIndex++);
                }
            }
        });

        readableStream.readBrickData = function (brickIndex) {
            const brickMeta = bricksMeta[brickIndex];
            getBrickAsBuffer(brickMeta, (err, data) => {
                if (err) {
                    this.destroy(err);
                    return;
                }

                const currentIndexStartByte = brickIndex > 0 ? brickIndex * bufferSize : 0;
                const currentIndexEndByte = currentIndexStartByte + data.byteLength;

                const isCurrentBrickAfterStart = currentIndexStartByte >= start;
                if (isCurrentBrickAfterStart) {
                    const slice = end < currentIndexEndByte
                        ? data.slice(0, end - currentIndexStartByte + 1)
                        : data.slice(0);
                    this.push(slice);
                } else {
                    let offset = start - currentIndexStartByte;
                    const mustSliceBeforeCurrentIndexEnd = end < currentIndexEndByte && end < totalSize;
                    const slice = mustSliceBeforeCurrentIndexEnd
                        ? data.slice(offset, end - currentIndexStartByte + 1)
                        : data.slice(offset);
                    this.push(slice);
                }

                if (currentIndexEndByte > end || brickIndex >= (bricksMeta.length - 1)) {
                    this.push(null);
                }
            });
        };

        callback(undefined, readableStream);
    };

    /**
     * Retrieve all the Bricks identified by `bricksMeta`
     * and store their data into a file
     *
     * @param {string} filePath
     * @param {Array<object>} bricksMeta
     * @param {callback} callback
     */
    this.createFileFromBricks = (filePath, bricksMeta, callback) => {
        const getBricksAsBufferRecursive = (index, callback) => {
            const brickMeta = bricksMeta[index];

            getBrickAsBuffer(brickMeta, (err, data) => {
                if (err) {
                    return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to get bricks as buffer`, err));
                }

                this.fsAdapter.appendBlockToFile(filePath, data, (err) => {
                    if (err) {
                        return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to append block to file <${filePath}>`, err));
                    }

                    ++index;

                    if (index < bricksMeta.length) {
                        return getBricksAsBufferRecursive(index, callback);
                    }

                    callback();
                });
            });
        };

        getBricksAsBufferRecursive(0, callback);
    };

    /**
     * Copy all the Bricks identified by `bricksList`
     * into another storage provider
     *
     * @param {object} bricksList
     * @param {object} options
     * @param {FSAdapter} options.dstStorage
     * @param {callback} options.beforeCopyCallback
     * @param {callback} callback
     */
    this.copyBricks = (bricksList, options, callback) => {
        const bricksSetKeys = Object.keys(bricksList);
        const newBricksSetKeys = {};

        const copyBricksRecursive = (callback) => {
            if (!bricksSetKeys.length) {
                return callback();
            }

            const setKey = bricksSetKeys.shift();
            const bricksMeta = bricksList[setKey];

            const srcStream = createBricksReadableStream(bricksMeta);
            const dstStream = createBricksWritableStream(options.dstStorage, options.beforeCopyCallback);

            srcStream.on('error', (err) => {
                OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to copy bricks`, err));
                dstStream.destroy(err);
            });

            dstStream.on('finish', () => {
                newBricksSetKeys[setKey] = dstStream.bricksSummary;
                dstStream.destroy();
                copyBricksRecursive(callback);
            });

            srcStream.pipe(dstStream);
        };

        copyBricksRecursive((err) => {
            if (err) {
                return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to copy bricks recursive`, err));

            }

            callback(undefined, newBricksSetKeys);
        });
    };

    /**
     * @param {string} filePath
     * @param {callback} callback
     */
    this.readFile = (filePath, callback) => {
        this.fsAdapter.getFileSize(filePath, (err, size) => {
            if (err) {
                return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to get size for file <${filePath}>`, err));
            }

            if (!size) {
                size = 1;
            }
            this.fsAdapter.readBlockFromFile(filePath, 0, size - 1, callback);
        });
    };
}

module.exports = Service;

},{"../../utils/isStream":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/bar/utils/isStream.js","../Brick":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/bar/lib/Brick.js","opendsu":"opendsu","overwrite-require":"overwrite-require","path":false,"stream":false,"swarmutils":"swarmutils"}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/bar/lib/BrickStorageService/index.js":[function(require,module,exports){
'use strict'

module.exports = {
    Service: require('./Service')
};

},{"./Service":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/bar/lib/BrickStorageService/Service.js"}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/bar/lib/Manifest.js":[function(require,module,exports){
const MANIFEST_PATH = "/manifest";

function Manifest(archive, options, callback) {
    const pskPath = require("swarmutils").path;
    let manifest;
    let temporary = {};
    let manifestHandler = {};

    if (typeof options === 'function') {
        callback = options;
        options = {};
    }

    options = options || {};


    manifestHandler.mount = function (path, archiveIdentifier, options, callback) {
        if (typeof options === "function") {
            callback = options;
            options = {persist: true};
        }

        if (typeof options === "undefined") {
            options = {persist: true};
        }
        // if (/\W-_/.test(name) === true) {
        //     return callback(Error("Invalid mount name"));
        // }

        for (let mountingPoint in manifest.mounts) {
            if (pskPath.isSubpath(path, mountingPoint) || pskPath.isSubpath(path, mountingPoint)) {
                return callback(Error(`Mount not allowed. Already exist a mount for ${mountingPoint}`));
            }
        }

        manifest.mounts[path] = archiveIdentifier;
        if (options.persist === true) {
            return persist(callback);
        } else {
            temporary[path] = true;
        }

        callback(undefined);
    };

    manifestHandler.unmount = function (path, callback) {
        if (typeof manifest.mounts[path] === "undefined") {
            return callback(Error(`No mount found at path ${path}`));
        }

        delete manifest.mounts[path];

        if (temporary[path]) {
            delete temporary[path];
            callback();
        } else {
            persist(callback);
        }
    };

    manifestHandler.getArchiveIdentifier = function (path, callback) {
        if (typeof manifest.mounts[path] === "undefined") {
            return callback(Error(`No mount found at path ${path}`));
        }

        callback(undefined, manifest.mounts[path]);
    };

    manifestHandler.getArchiveForPath = function (path, callback) {
        if (path[0] !== '/') {
            path = `/${path}`;
        }
        for (let mountingPoint in manifest.mounts) {
            if (mountingPoint === path) {
                return getArchive(manifest.mounts[mountingPoint], (err, archive) => {
                    if (err) {
                        return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to load DSU mounted at mounting point ${manifest.mounts[mountingPoint]}`, err));
                    }

                    return callback(undefined, {prefixPath: mountingPoint, relativePath: "/", archive: archive, identifier: manifest.mounts[mountingPoint]});
                });
            }

            if (pskPath.isSubpath(path, mountingPoint)) {
                return getArchive(manifest.mounts[mountingPoint], (err, archive) => {
                    if (err) {
                        return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to load DSU mounted at mounting point ${manifest.mounts[mountingPoint]}`, err));
                    }

                    let remaining = path.substring(mountingPoint.length);
                    remaining = pskPath.ensureIsAbsolute(remaining);
                    return archive.getArchiveForPath(remaining, function (err, result) {
                        if (err) {
                            return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to load DSU mounted at path ${remaining}`, err));
                        }
                        result.prefixPath = pskPath.join(mountingPoint, result.prefixPath);
                        callback(undefined, result);
                    });
                });
            }
        }

        callback(undefined, {prefixPath: "/", relativePath: path, archive: archive});
    };

    manifestHandler.getMountPoints = function () {
        return Object.keys(manifest.mounts);
    }

    manifestHandler.getMountedDossiers = function (path, callback) {
        let mountedDossiers = [];
        for (let mountPoint in manifest.mounts) {
            if (path === "/" || pskPath.isSubpath(mountPoint, path)) {
                let mountPath;
                if (path === "/") {
                    if (mountPoint[0] === "/") {
                        mountPath = mountPoint.substring(1);
                    } else {
                        mountPath = mountPoint;
                    }
                } else {
                    mountPath = mountPoint.substring(path.length);
                    if (mountPath[0] === "/") {
                        mountPath = mountPath.substring(1);
                    }
                }
                mountedDossiers.push({
                    path: mountPath,
                    identifier: manifest.mounts[mountPoint]
                });
            }
        }

        const mountPaths = mountedDossiers.map(mountedDossier => mountedDossier.path);
        mountedDossiers = mountedDossiers.filter((mountedDossier, index) => {
            return mountPaths.indexOf(mountedDossier.path) === index;
        });

        callback(undefined, mountedDossiers);
    };

    function getArchive(seed, callback) {
        const resolver = require("opendsu").loadApi("resolver");
        if (typeof options.skipCache === 'boolean' && !options.skipCache) {
            options.skipCache = true;
        }

        resolver.loadDSU(seed, options, (err, dossier) => {
            if (err) {
                return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to load DSU from keySSI ${seed}`, err));
            }

            callback(undefined, dossier);
        })
    }

    function persist(callback) {
        archive.writeFile(MANIFEST_PATH, JSON.stringify(manifest), {embed: true}, callback);
    }

    function init(callback) {
        archive.readFile(MANIFEST_PATH, {ignoreMounts: true}, (err, manifestContent) => {
            if (err) {
                manifest = {mounts: {}};
            } else {
                try {
                    manifest = JSON.parse(manifestContent.toString());
                } catch (e) {
                    return callback(e);
                }
            }

            callback(undefined, manifestHandler);
        });
    }

    init(callback);
}

module.exports.getManifest = function getManifest(archive, options, callback) {
    Manifest(archive, options, callback);
};


},{"opendsu":"opendsu","swarmutils":"swarmutils"}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/bar/lib/brick-transforms/EncryptionTransformation.js":[function(require,module,exports){
const openDSU = require("opendsu");
const crypto = openDSU.loadApi("crypto");

function EncryptionTransformation(options) {
    this.do = (keySSI, data, callback) => {
        const encrypt = crypto.getCryptoFunctionForKeySSI(keySSI, "encryption");
        let encryptedData;
        keySSI.getEncryptionKey((err, encryptionKey) => {
            if (err) {
                return callback(err);
            }
            try {
                encryptedData = encrypt(data, encryptionKey, options);
            } catch (e) {
                return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to encrypt data`, e));
            }

            setTimeout(() => {
                callback(undefined, encryptedData);
            });
        });
    };

    this.undo = (keySSI, data, callback) => {
        const decrypt = crypto.getCryptoFunctionForKeySSI(keySSI, "decryption");
        let plainData;
        keySSI.getEncryptionKey((err, encryptionKey) => {
            if (err) {
                return callback(err);
            }
            try {
                plainData = decrypt(data, encryptionKey);
            } catch (e) {
                return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to decrypt data`, e));
            }

            setTimeout(() => {
                callback(undefined, plainData);
            });
        });
    };
}

module.exports = EncryptionTransformation;
},{"opendsu":"opendsu"}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/bar/lib/brick-transforms/index.js":[function(require,module,exports){
const EncryptionTransformation = require("./EncryptionTransformation");

const createBrickTransformation = (options) => {
    options = options || {};
    return new EncryptionTransformation(options);
};


module.exports = {
    createBrickTransformation
};


},{"./EncryptionTransformation":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/bar/lib/brick-transforms/EncryptionTransformation.js"}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/bar/lib/constants.js":[function(require,module,exports){
'use strict';

module.exports = {
    anchoringStatus: {
        NOTHING_TO_ANCHOR: 2,
        ANCHORING_IN_PROGRESS: 1,
        OK: 0,
        PERSIST_BRICKMAP_ERR: -1,
        ANCHOR_VERSION_ERR: -2,
        BRICKMAP_UPDATE_ERR: -3,
        BRICKMAP_LOAD_ERR: -4,
        BRICKMAP_RECONCILE_ERR: -5,
        BRICKMAP_RECONCILIATION_HANDOFF: -6
    }
}

},{}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/bar/lib/obsolete/FileBrickMap.js":[function(require,module,exports){
const Brick = require("../Brick");
const util = require("../../utils/utilities");
const pathModule = "path";
const path = require(pathModule);

function FileBrickMap(header) {
    header = header || {};

    let brickOffset = util.getBrickMapOffsetSize();
    let archiveConfig;
    let encryptionKey;

    this.addFileEntry = (path, bricks) => {
        this.appendBricksToEntry(path, bricks);
    };

    this.appendBricksToEntry = (path, bricks) => {
        for (const data of bricks) {
            this.add(path, data);
        }
    }

    this.add = (filePath, brick) => {
        filePath = filePath.split(path.sep).join(path.posix.sep);
        this.load();
        if (typeof header[filePath] === "undefined") {
            header[filePath] = [];
        }

        const brickObj = {
            checkSum: brick.getAdler32(),
            offset: brickOffset,
            hash: brick.getHash()
        };

        const encKey = brick.getTransformParameters() ? brick.getTransformParameters().key : undefined;
        if (encKey) {
            brickObj.key = encKey;
        }

        header[filePath].push(brickObj);
        brickOffset += brick.getTransformedSize();
    };

    this.getHashList = (filePath) => {
        this.load();
        return header[filePath].map(brickObj => brickObj.offset);
    };

    this.getFileList = (folderBarPath) => {
        this.load();
        if (!folderBarPath) {
            return Object.keys(header);
        }
        return Object.keys(header).filter(fileName => fileName.includes(folderBarPath));
    };

    this.getDictionaryObject = () => {
        let objectDict = {};
        Object.keys(header).forEach((fileName) => {
            let brickObjects = header[fileName];
            for (let j = 0; j < brickObjects.length; j++) {
                if (typeof objectDict[brickObjects[j]['checkSum']] === 'undefined') {
                    objectDict[brickObjects[j]['checkSum']] = [];
                }
                objectDict[brickObjects[j]['checkSum']].push(brickObjects[j]['hash']);
            }
        });
        return objectDict;
    };

    this.getTransformParameters = (brickId) => {
        if (!brickId) {
            return encryptionKey ? {key: encryptionKey} : {};
        }

        this.load();
        let bricks = [];
        const files = this.getFileList();

        files.forEach(filePath => {
            bricks = bricks.concat(header[filePath]);
        });

        const brickObj = bricks.find(brick => {
            return brick.offset === brickId;
        });

        const addTransformData = {};
        if (brickObj.key) {
            addTransformData.key = $$.Buffer.from(brickObj.key);
        }

        return addTransformData;
    };

    this.toBrick = () => {
        this.load();
        const brick = new Brick(archiveConfig);
        brick.setTransformParameters({key: encryptionKey});
        brick.setRawData($$.Buffer.from(JSON.stringify(header)));
        return brick;
    };

    this.load = () => {
        if (header instanceof Brick) {
            header.setConfig(archiveConfig);
            if (encryptionKey) {
                header.setTransformParameters({key: encryptionKey});
            }
            header = JSON.parse(header.getRawData().toString());
        }
    };

    this.setConfig = (config) => {
        archiveConfig = config;
    };

    this.getConfig = () => {
        return archiveConfig;
    };

    this.setEncryptionKey = (encKey) => {
        encryptionKey = encKey;
    };

    this.removeFile = (filePath) => {
        this.load();
        delete header[filePath];
    };
}

module.exports = FileBrickMap;

},{"../../utils/utilities":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/bar/utils/utilities.js","../Brick":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/bar/lib/Brick.js"}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/bar/lib/obsolete/FileBrickStorage.js":[function(require,module,exports){
function FileBrickStorage(filePath) {
    const fsModuleName = "fs";
    const fs = require(fsModuleName);
    const BrickMap = require("./FileBrickMap");
    const util = require("../../utils/utilities");
    const Brick = require("../Brick");

    let isFirstBrick = true;
    let map;
    let mapOffset;

    this.setBrickMap = (brickMap) => {
        map = brickMap;
    };

    this.putBrick = (brick, callback) => {
        if (isFirstBrick) {
            isFirstBrick = false;
            const writeStream = fs.createWriteStream(filePath, {start: util.getBrickMapOffsetSize()});
            writeStream.on("error", (err) => {
                return callback(err);
            });

            writeStream.write(brick.getTransformedData(), callback);
        } else {
            fs.appendFile(filePath, brick.getTransformedData(), callback);
        }
    };

    this.getBrick = (brickId, callback) => {
        this.getBrickMap((err, brickMap) => {
            if (err) {
                return callback(err);
            }
            let brickOffsets = [];
            const fileList = brickMap.getFileList();
            fileList.forEach(file => {
                brickOffsets = brickOffsets.concat(brickMap.getHashList(file));
            });

            const brickIndex = brickOffsets.findIndex(el => {
                return el === brickId;
            });

            let nextBrickId = brickOffsets[brickIndex + 1];
            if (!nextBrickId) {
                nextBrickId = Number(mapOffset);
            }

            readBrick(brickId, nextBrickId, callback);
        });

    };

    this.deleteFile = (fileName, callback) => {
        this.getBrickMap((err, brickMap) => {
            if (err) {
                return callback(err);
            }

            brickMap.delete(fileName);
            this.putBrickMap(brickMap, callback);
        });
    };


    this.putBrickMap = (brickMap, callback) => {
        map = brickMap;
        readBrickMapOffset((err, offset) => {
            if(offset) {
                offset = Number(offset);
                fs.truncate(filePath, offset, (err) => {
                    if (err) {
                        return callback(err);
                    }

                    __writeBrickMap(offset);
                });
            }else{
                fs.stat(filePath, (err, stats) => {
                    if (err) {
                        return callback(err);
                    }

                    const brickMapOffset = stats.size;

                    const bufferBrickMapOffset = $$.Buffer.alloc(util.getBrickMapOffsetSize());
                    bufferBrickMapOffset.writeBigUInt64LE(BigInt(brickMapOffset));
                    mapOffset = brickMapOffset;
                    const offsetWriteStream = fs.createWriteStream(filePath, {flags: "r+", start: 0});

                    offsetWriteStream.on("error", (err) => {
                        return callback(err);
                    });

                    offsetWriteStream.write(bufferBrickMapOffset, (err) => {
                        if (err) {
                            return callback(err);
                        }

                        __writeBrickMap(brickMapOffset);
                    });
                });
            }
        });

        function __writeBrickMap(offset) {
            const mapWriteStream = fs.createWriteStream(filePath, {flags: "r+", start: offset});
            mapWriteStream.on("error", (err) => {
                return callback(err);
            });

            const mapBrick = brickMap.toBrick();
            mapBrick.setTransformParameters(brickMap.getTransformParameters());
            mapWriteStream.write(mapBrick.getTransformedData(), callback);
        }

    };

    this.getBrickMap = (mapDigest, callback) => {
        if (typeof mapDigest === "function") {
            callback = mapDigest;
        }

        if (map) {
            return callback(undefined, map);
        }

        readBrickMap((err, brickMap) => {
            if (err) {
                return callback(err);
            }

            map = brickMap;
            callback(undefined, brickMap);
        });
    };

    //------------------------------------------ Internal functions ---------------------------------------------------

    function readBrickMapOffset(callback) {
        const readStream = fs.createReadStream(filePath, {start: 0, end: util.getBrickMapOffsetSize() - 1});

        const buffer = $$.Buffer.alloc(util.getBrickMapOffsetSize());
        let offsetBuffer = 0;

        readStream.on("data", (chunk) => {
            chunk.copy(buffer, offsetBuffer);
            offsetBuffer += chunk.length;
        });

        readStream.on("end", () => {
            callback(undefined, buffer.readBigUInt64LE());
        });

        readStream.on("error", (err) => {
            return callback(err);
        });
    }

    function readBrickMap(callback) {
        readBrickMapOffset((err, brickMapOffset) => {
            if (err) {
                if (err.code === "ENOENT") {
                    return callback(undefined, new BrickMap());
                }

                return callback(err)
            }

            mapOffset = brickMapOffset;
            const readStream = fs.createReadStream(filePath, {start: Number(brickMapOffset)});
            const buffs = [];

            readStream.on("data", (chunk) => {
                buffs.push(chunk);
            });

            readStream.on("error", (err) => {
                return callback(err);
            });

            readStream.on("end", () => {
                const brickMapData = $$.Buffer.concat(buffs);
                const mapBrick = new Brick();
                mapBrick.setTransformedData(brickMapData);
                callback(undefined, new BrickMap(mapBrick));
            });
        });
    }

    function readBrick(brickOffsetStart, brickOffsetEnd, callback) {
        const readStream = fs.createReadStream(filePath, {start: brickOffsetStart, end: brickOffsetEnd - 1});
        const buffs = [];

        readStream.on("data", (chunk) => {
            buffs.push(chunk);
        });

        readStream.on("error", (err) => {
            return callback(err);
        });

        readStream.on("end", () => {
            const brick = new Brick();
            const brickData = $$.Buffer.concat(buffs);
            brick.setTransformedData(brickData);
            callback(undefined, brick);
        });
    }
}

module.exports = {
    createFileBrickStorage(filePath) {
        return new FileBrickStorage(filePath);
    }
};

},{"../../utils/utilities":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/bar/utils/utilities.js","../Brick":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/bar/lib/Brick.js","./FileBrickMap":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/bar/lib/obsolete/FileBrickMap.js"}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/bar/lib/obsolete/FolderBrickStorage.js":[function(require,module,exports){
const BrickMap = require("../BrickMap");
const Brick = require("../Brick");

function FolderBrickStorage(location) {
    const fs = require("fs");
    const path = require("path");
    let map;

    this.setBrickMap = (brickMap) => {
        map = brickMap;
    };

    this.putBrick = (brick, callback) => {
        const writeStream = fs.createWriteStream(path.join(location, brick.getHash()));
        writeStream.write(brick.getTransformedData(), (...args) => {
            writeStream.end();
            callback(...args);
        });
    };

    this.getBrick = (brickHash, callback) => {
        fs.readFile(path.join(location, brickHash), (err, brickData) => {
            if (err) {
                return callback(err);
            }

            const brick = new Brick();
            brick.setTransformedData(brickData);
            callback(err, brick);
        });
    };

    this.deleteFile = (filePath, callback) => {
        this.getBrickMap((err, brickMap) => {
            if (err) {
                return callback(err);
            }

            fs.unlink(path.join(location, brickMap.toBrick().getHash()), (err) => {
                if (err) {
                    return callback(err);
                }

                brickMap.delete(filePath);
                this.putBrickMap(brickMap, callback);
            });
        });
    };

    this.putBrickMap = (brickMap, callback) => {
        map = brickMap;
        const brickMapBrick = brickMap.toBrick();
        brickMapBrick.setTransformParameters(brickMap.getTransformParameters());
       
        let brickId = brickMapBrick.getKey();
        if (!brickId) {
            brickId = brickMapBrick.getHash();
        }

        brickMapBrick.setKey(brickId);
        const writeStream = fs.createWriteStream(path.join(location, brickId));
        writeStream.write(brickMapBrick.getTransformedData(), (err) => {
            writeStream.end();
            callback(err, brickMapBrick.getSeed());
        });
    };

    this.getBrickMap = (mapDigest, callback) => {
        if (typeof mapDigest === "function") {
            callback = mapDigest;
            mapDigest = undefined;
        }

        if (map) {
            return callback(undefined, map);
        }

        if (typeof mapDigest === "undefined") {
            return callback(undefined, new BrickMap());
        }

        this.getBrick(mapDigest, (err, mapBrick) => {
            if (err) {
                return callback(err);
            }

            const brickMap = new BrickMap(mapBrick);
            map = brickMap;
            callback(undefined, brickMap);
        });
    }
}

module.exports = {
    createFolderBrickStorage(location) {
        return new FolderBrickStorage(location);
    }
};

},{"../Brick":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/bar/lib/Brick.js","../BrickMap":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/bar/lib/BrickMap.js","fs":false,"path":false}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/bar/utils/isStream.js":[function(require,module,exports){
function isStream(stream){
    return stream !== null && typeof stream === 'object' && typeof stream.pipe === 'function';
}

function isWritable(stream) {
    return isStream(stream) &&
        stream.writable !== false &&
        typeof stream._write === 'function' &&
        typeof stream._writableState === 'object';

}

function isReadable(stream) {
    return isStream(stream) &&
        stream.readable !== false &&
        typeof stream._read === 'function' &&
        typeof stream._readableState === 'object';
}

function isDuplex(stream){
    return isWritable(stream) &&
        isReadable(stream);
}

module.exports = {
    isStream,
    isReadable,
    isWritable,
    isDuplex
};

},{}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/bar/utils/utilities.js":[function(require,module,exports){
const OFFSET_SIZE = 8;

function getBrickMapOffsetSize() {
    return OFFSET_SIZE;
}

function ensureFileDoesNotExist(filePath, callback) {
    const fs = require('fs');
    fs.access(filePath, (err) => {
        if (!err) {
            fs.unlink(filePath, callback);
        } else {
            return callback();
        }
    });
}

module.exports = {getBrickMapOffsetSize, ensureFileDoesNotExist};
},{"fs":false}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/cloud-enclave/src/CloudEnclaveBootService.js":[function(require,module,exports){
(function (__dirname){(function (){
const openDSU = require("opendsu");
const w3cDID = openDSU.loadAPI("w3cdid");
const keySSISpace = openDSU.loadAPI("keyssi");
const enclaveAPI = openDSU.loadAPI("enclave");

const path = require("path");
const fs = require("fs");
function CloudEnclaveBootService(server) {
    const processList = {}
    this.createEnclave = async (req, res) => {
        const key = require('crypto').randomBytes(16).toString("base64")
        const didDocument = await $$.promisify(w3cDID.createIdentity)("key", undefined, key);
        this.createFolderForDID(didDocument.getIdentifier(), (err) => {
            if (err) {
                res.end(err);
            }
            // initEnclave(logger, didDocument, didDir);
            //to do
            res.end(didDocument.getIdentifier())
        })

    }

    this.bootEnclave = async (enclaveConfig) => {
        const child = require("child_process").fork(path.join(process.env.PSK_ROOT_INSTALATION_FOLDER, ".", __dirname, "./CloudEnclave.js"), [JSON.stringify(enclaveConfig)]);
        const listenForMessage = () => {
            return new Promise((resolve) => {
                child.on('message', (didIdentifier) => {
                    processList[didIdentifier] = child;
                    resolve();
                });
            });
        };

        await listenForMessage();
    }

    this.bootEnclaves = async () => {
        const configFolder = this.getConfigFolder();
        const _boot = async () => {
            const enclaveConfigFolders = fs.readdirSync(configFolder).filter(file => fs.statSync(path.join(configFolder, file)).isDirectory());
            for (let i = 0; i < enclaveConfigFolders.length; i++) {
                const enclaveConfigFolder = enclaveConfigFolders[i];
                const enclaveConfigFile = fs.readdirSync(path.join(configFolder, enclaveConfigFolder)).find(file => file.endsWith(".json"));
                if (enclaveConfigFile) {
                    const enclaveConfig = JSON.parse(fs.readFileSync(path.join(configFolder, enclaveConfigFolder, enclaveConfigFile)));
                    enclaveConfig.rootFolder = this.getStorageFolder();
                    enclaveConfig.configLocation = configFolder;
                    await this.bootEnclave(enclaveConfig);
                }
            }

            return server.dispatchEvent("initialised", Object.keys(processList));
        }

        const scApi = require("opendsu").loadApi("sc");
        const sc = scApi.getSecurityContext();
        if (sc.isInitialised()) {
            return await _boot();
        }
        sc.on("initialised", async () => {
            return await _boot();
        });
    }
    const initAudit = async (currentDID, auditDID) => {
        const clientSeedSSI = keySSISpace.createSeedSSI("vault", "other secret");
        const clientDIDDocument = await $$.promisify(w3cDID.createIdentity)("ssi:key", clientSeedSSI);

        const auditClient = enclaveAPI.initialiseRemoteEnclave(clientDIDDocument.getIdentifier(), auditDID);
        auditClient.on("initialised", () => {
            this.main.auditClient = auditClient;
            this.main.addEnclaveMethod("audit", (...args) => {
                auditClient.callLambda("addAudit", ...args, server.serverConfig.name, () => {
                });
            })
            server.initialised = true;
            server.dispatchEvent("initialised", currentDID);
        })

    }

    const loadLambdas = (cloudEnclaveProcess, server) => {
        const lambdasPath = server.serverConfig.lambdas;
        try {
            fs.readdirSync(lambdasPath).forEach(file => {
                if (file.endsWith(".js")) {
                    const importedObj = require(lambdasPath + "/" + file);
                    for (let prop in importedObj) {
                        if (typeof importedObj[prop] === "function") {
                            importedObj[prop](cloudEnclaveProcess);
                        }
                    }
                }
            })
        } catch (err) {
            server.dispatchEvent("error", err);
        }
    }

    this.getStorageFolder = () => {
        return path.resolve(server.serverConfig.rootFolder);
    }

    this.getConfigFolder = () => {
        return path.resolve(server.serverConfig.configLocation);
    }
}


module.exports = {
    CloudEnclaveBootService
};

}).call(this)}).call(this,"/modules/cloud-enclave/src")

},{"child_process":false,"crypto":false,"fs":false,"opendsu":"opendsu","path":false}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/cloud-enclave/src/config.js":[function(require,module,exports){
module.exports = {
    rootFolder: "../cloud-enclave-root",
    name: "cloud-enclave"
}
},{}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/fast-svd/src/core/SVDBase.js":[function(require,module,exports){
const constants = require("../moduleConstants");
const stateVariables = ["__timeOfLastChange", "__version"];
/*
    Description is a JSON in format { [functionName:function1], actions : [action1, action2, ...] }
    The SVDBase instances will look like normal JS objects with methods from description and actions mixed together.
 */

function SVDBase( svdIdentifier, state, description, transaction, callCtor){
    let self = this;

    this.getUID = function(){
        return svdIdentifier.getUID();
    }

    this.getStringId = function(){
        return svdIdentifier.getStringId();
    }

    this.getTransaction = function(){
        return transaction;
    }
    function generateReadOnlyFunction(f){
        return f.bind(self);
    }

    this.now = function(){
        return self.__timeOfLastChange;
    }

    function generateModifier(fn, f){
        let boundFunc = f.bind(self);
        return function(...args){
            self.__timeOfLastChange = Date.now();
            transaction.audit(self, fn, ...args);
            return boundFunc(...args);
        }.bind(self)
    }

    for(let fn in description){
        if(typeof description[fn] == 'function'){
            this[fn] = generateReadOnlyFunction(description[fn])
        }
    }

    let actions = description[constants.ACTIONS];
    if(actions == undefined){
        throw new Error("No actions defined for destiption of SVD  " + svdIdentifier.getType() + "  !!! actions:{} is mandatory" );
    }
    for(let fn in actions){
        if(this[fn] != undefined){
            throw new Error("Function name collision in action: " + fn);
        }
        this[fn] = generateModifier(fn, actions[fn])
    }

    if(callCtor)
    {
        if(this.ctor){
            try{
                transaction.audit(self, "ctor", ...state);
                this.ctor(...state);
                if(this._ctor){
                    this._ctor();
                }
            }catch (err){
                let newError = new Error("Ctor initialisation for" + svdIdentifier.getTypeName() +" failed to run properly. See .previous for details");
                newError.previous = err;
                throw newError;
            }
        } else {
            throw new Error("Ctor not defined for " + svdIdentifier.getTypeName());
        }
    } else {
        if(state){
            for(let key in state){
                if(this[key] != undefined){
                    throw new Error("State cant contain functions. Key name collision in state: " + key);
                }
                this[key] = state[key];
            }
        }
        if(this._ctor){
            this._ctor();
        }
    }

    this.getState = function(){
        let state = {};
        for(let key in self){
            if(typeof self[key] != 'function'){
                if(key.charAt(0) != "_" || stateVariables.includes(key))
                state[key] = self[key];
            }
        }
        return state;
    }
}

module.exports = SVDBase;
},{"../moduleConstants":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/fast-svd/src/moduleConstants.js"}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/fast-svd/src/core/SVDFactory.js":[function(require,module,exports){
/*
    A SVDIdentifiers is in format svd:type:id
 */
const FSStrategy = require("../persistenceStrategies/FSStrategy");
const SVDBase = require("./SVDBase");


function SVDFactory(persistenceStrategy, signatureProvider){
    let typesRegistry = {};

    if(!persistenceStrategy){
        persistenceStrategy = new FSStrategy("./svds");
    }

    this.registerType  = function(typeName, description){
        typesRegistry[typeName] = description;
    }

    this.restore = function(svdId, transaction, callback){
        persistenceStrategy.loadState(svdId, function(err, state){
            if(err){
                console.log("@@Error at loading state: " + err);
                callback(err);
                return;
            }
            const svdInstance = new SVDBase(svdId, state, typesRegistry[svdId.getTypeName()], transaction, false);
            callback(undefined, svdInstance);
        });
    }

    this.store = function(changesForAllSVDS, transactionHandler, callback){
        changesForAllSVDS.forEach(entry => {
            entry.signature = signatureProvider.sign(entry.state.__version, entry.changes);
        })
        //console.debug("Storing diff: ", changesForAllSVDS);
        persistenceStrategy.storeAndUnlock(changesForAllSVDS, transactionHandler, callback);
    }

    this.create = function(svdId,  transaction, ...args){
         return new SVDBase(svdId, args, typesRegistry[svdId.getTypeName()], transaction, true);
    }
}

module.exports = SVDFactory;
},{"../persistenceStrategies/FSStrategy":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/fast-svd/src/persistenceStrategies/FSStrategy.js","./SVDBase":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/fast-svd/src/core/SVDBase.js"}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/fast-svd/src/core/SVDIdentifier.js":[function(require,module,exports){
function SVDIdentifier(svdUID){
    if(typeof svdUID != "string"){
        svdUID = svdUID.getUID();
    }
    let parsed = svdUID.split(":");

    this.getUID = function(){
        return svdUID;
    }

    this.getStringId  = function(){
        return svdUID;
    }

    if(parsed[0] != "svd" && parsed.length != 3){
        throw new Error("Invalid SVD Unique identifier " + svdUID + " !!! Expected format: svd:<type>:<id>");
    }

    this.getTypeName = function(){
        return parsed[1];
    }

    /* Type Unique ID */
    this.getId = function(){
        return parsed[2];
    }
}

module.exports = SVDIdentifier;
},{}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/fast-svd/src/core/SVDSession.js":[function(require,module,exports){
let SVDIdentifier = require("./SVDIdentifier.js");
function SVDTransaction(svdFactory){
    let currentSVDs = {};
    let self = this;


    this.create = function(svdId, ...args){
        if(typeof svdId == 'string'){
            svdId = new SVDIdentifier(svdId);
        }
        let svdInstance = svdFactory.create(svdId, self, ...args);
        currentSVDs[svdInstance.getUID()] = svdInstance;
        return svdInstance;
    }

    this.lookup = function(svdId, callback){
        if(typeof callback != 'function'){
            throw new Error("Invalid callback function");
        }

        setTimeout(function(){//force async behaviour
            if(typeof svdId == 'string'){
                svdId = new SVDIdentifier(svdId);
            }
            let svdInstance = currentSVDs[svdId.getUID()];
            if(!svdInstance) {
                svdFactory.restore(svdId, self, function (err, svdInstance) {
                    if(err){
                        return callback(err);
                    }

                    currentSVDs[svdId.getUID()] = svdInstance;
                    callback(undefined, svdInstance);
                });
            } else {
                callback(undefined, svdInstance);
            }
        }, 0);
    }

    this.lookupAsync = async function(svdId){
        //make callback in promise
        return new Promise((resolve, reject) => {
                self.lookup(svdId, (err, res) => {
                    if(err){
                        reject(err);
                    } else {
                        resolve(res);
                    }
                });
        });
    }

    let auditLog = {};
    function addAuditEntry(uid, nowValue, fn, args){
        if(typeof uid == 'object'){
            uid = uid.getUID();
        }
        if(!auditLog[uid]){
            auditLog[uid] = [];
        }
        let entry = {
            fn: fn,
            args: args,
            now: nowValue
        }
        auditLog[uid].push(entry);
    }

    this.transactionHandler = undefined;
    this.begin = function(lockList, callback){
        if(typeof lockList == "function"){
            callback = lockList;
            lockList = undefined;
        }
        console.log("@@Begin transaction");
        if(this.transactionHandler != undefined){
            throw new Error("Transaction already in progress");
        }
        let crypto = require('crypto');

        this.transactionHandler = crypto.randomBytes(32).toString('hex');
        if(!lockList || lockList.length == 0){
            callback(undefined, this);
        } else {
            let locksListClone = lockList.slice();
            function recursiveLock(){
                if(locksListClone.length == 0){
                    callback(undefined, this);
                } else {
                    let uid = locksListClone.pop();
                    svdFactory.lock(uid, this, function(err, res) {
                        if (err) {
                            self.abortTransaction();
                            callback(err);
                        }
                        recursiveLock();
                    });
                }
            }
        }
    }

    this.abort = function(){
        svdFactory.abortLocks(auditLog, this.transactionHandler);
        this.transactionHandler = undefined;
    }


    function detectDiffsToBeSaved(callback){
        let diff = [];
        let counter = 0;
        for(let uid in auditLog){
            counter++
            self.lookup(uid, function(err, svdInstance){
                diff.push({
                    uid: uid,
                    state: svdInstance.getState(),
                    changes: auditLog[uid],
                    now:Date.now()
                })
                counter--;
                if(counter == 0){
                    callback(diff);
                }
                if(counter < 0){
                    throw new Error("Counter can't be negative");
                }
            });
        }
    }

    function updateVersion (svdInfo){
        if(!svdInfo.state){
            svdInfo.state = {__version: 0};
        }

        if(!svdInfo.state.__version){
            svdInfo.state.__version = 0;
        }
        svdInfo.state.__version++;
    }

    this.commit = function(callback){
        detectDiffsToBeSaved(function(diff){

            diff.forEach( function(svdInfo){
                updateVersion(svdInfo);
            });
            //console.debug("Committing: ", diff);
            svdFactory.store(diff, this.transactionHandler, callback);
            this.transactionHandler = undefined;
        });
    }

    this.audit = function(svdInstance, fn, ...args){
        if(!this.transactionHandler){
            throw new Error(`Modifier ${fn} must be called only during the transactions lifetimes`);
        }
        //console.log("Audit: ", svdInstance.getUID(), fn, args);
        addAuditEntry(svdInstance.getUID(), svdInstance.__timeOfLastChange, fn, args);
    }
}

module.exports = SVDTransaction;
},{"./SVDIdentifier.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/fast-svd/src/core/SVDIdentifier.js","crypto":false}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/fast-svd/src/index.js":[function(require,module,exports){
let FSStrategy = require("./persistenceStrategies/FSStrategy.js");
let SVDFactory = require("./core/SVDFactory.js");
let SVDTransaction = require("./core/SVDSession.js");
let NullSignatureProvider = require("./signatureProvider/NullSignatureProvider.js");

const constants = require("./moduleConstants.js");


module.exports = {
    constants: constants,
    createTransaction: function(svdFactory){
        return new SVDTransaction(svdFactory);
    },
    createFSPersistence: function(path){
        return new FSStrategy(path);
    },
    createFactory: function(strategy, signatureProvider){
        if(!strategy)
        {
            strategy = new FSStrategy(path);
        }

        if(!signatureProvider)
        {
            signatureProvider = NullSignatureProvider.create();
        }
        
        return new SVDFactory(strategy, signatureProvider);
    }



}
},{"./core/SVDFactory.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/fast-svd/src/core/SVDFactory.js","./core/SVDSession.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/fast-svd/src/core/SVDSession.js","./moduleConstants.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/fast-svd/src/moduleConstants.js","./persistenceStrategies/FSStrategy.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/fast-svd/src/persistenceStrategies/FSStrategy.js","./signatureProvider/NullSignatureProvider.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/fast-svd/src/signatureProvider/NullSignatureProvider.js"}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/fast-svd/src/moduleConstants.js":[function(require,module,exports){
module.exports = {
    "ACTIONS": "actions"
}
},{}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/fast-svd/src/persistenceStrategies/FSStrategy.js":[function(require,module,exports){
function FSStrategy(rootPath) {
    let fs = require('fs');
    let path = require('path');
    let crypto = require('opendsu').loadApi('crypto');

    let lockedSVds = {};

    this.lock = function (uid, transactionHandler) {
        let stringUID = uid.getUID();
        if (lockedSVds[uid] != undefined) {
            throw new Error("SVD already locked by transaction  " + lockedSVds[stringUID] + " and " + transactionHandler + " tried to lock it again)");
        }
        lockedSVds[stringUID] = transactionHandler;
    }

    this.storeAndUnlock = function (diff, transactionHandler, callback) {
        let parallelTaskRunner = require("../util/parallelTask").createNewParallelTaskRunner(callback);
        let self = this;

        let getTask = function (entry) {
            return (callback) => {
                //console.log("storeAndUnlock: ", entry.uid, " with ", entry.changes.length, " changes: ", entry.changes);
                saveSVD(entry.uid, entry.state, entry.changes, entry.signature, callback);
                lockedSVds[entry.uid] = undefined;
            }
        }
        diff.forEach(entry => {
            parallelTaskRunner.addTask(getTask(entry));
        });
    }


    this.abortLocks = function (diff, transactionHandler) {
        diff.forEach(entry => {
            if (lockedSVds[entry.uid] != transactionHandler) {
                console.error("Transaction " + transactionHandler + " tried to abort transaction " + lockedSVds[entry.uid] + "on " + entry.uid + "without owning the lock")
            } else {
                lockedSVds[entry.uid] = undefined;
            }
        });
    }

    this.loadState = function (uid, callback) {
        let stringUID = uid.getUID();
        const base58UID = crypto.encodeBase58(stringUID)
        
        fs.readFile(path.join(rootPath, base58UID, "state"), 'utf8', function (err, res) {
            if (err) {
                return callback(err);
            }
            let obj;
            try {
                obj = JSON.parse(res);
            } catch (err) {
                callback(err);
            }
            callback(undefined, obj);
        });
    }

    function saveSVD(stringUID, svdState, changes, signature, callback) {
        const base58UID = crypto.encodeBase58(stringUID)
        let dirPath = path.join(rootPath, base58UID);
        fs.mkdir(dirPath, function () {
            fs.writeFile(path.join(dirPath, "state"), JSON.stringify(svdState), function () {
                let auditEntry = {
                    changes: changes,
                    signature: signature
                }
                //make stringify as an audit single line removing all newlines
                let auditLogLine = JSON.stringify(auditEntry).replace(/\n/g, " ");
                fs.appendFile(path.join(rootPath, base58UID, "history"), auditLogLine + "\n", callback);
            });
        });
    }

    function checkPathExistence() {
        if (!fs.existsSync(rootPath)) {
            fs.mkdirSync(rootPath);
        }
    }
    checkPathExistence();
}

module.exports = FSStrategy;
},{"../util/parallelTask":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/fast-svd/src/util/parallelTask.js","fs":false,"opendsu":"opendsu","path":false}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/fast-svd/src/signatureProvider/NullSignatureProvider.js":[function(require,module,exports){

function NullSignatureProvider(){
    this.sign = function (blockNo, change) {
        if(change == undefined) {
            throw new Error("Invalid attempt to sign an undefined change");
        }
        return "<<NULLSIGNATURE>>";
    }
}

module.exports.create = function(){
    return new NullSignatureProvider();
}
},{}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/fast-svd/src/util/parallelTask.js":[function(require,module,exports){
function ParallelTasks(callback){
    let counter = 0;
    let self = this;
    let result = [];
    let alreadyReturned = false;

    this.addTask = function(func){
        counter++;
        func(function(err, res){
            if(err){
                return self.onEnd(err);
            }
             result.push(res);

            counter--;
            if(counter == 0){
                self.onEnd(undefined,result);
            }

            if(counter < 0){
                throw new Error("Assert failure! Counter is negative!");
            }
        });
    }

    this.onEnd = function(fail, res) {
        if(!alreadyReturned){
            alreadyReturned = true;
            callback(fail, res);
        }
    }
}

module.exports.createNewParallelTaskRunner = function(callback){
    return new ParallelTasks(callback);
};
},{}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/key-ssi-resolver/lib/CryptoAlgorithms/CryptoAlgorithmsMixin.js":[function(require,module,exports){
function CryptoAlgorithmsMixin(target) {
    target = target || {};
    const crypto = require("pskcrypto");

    target.hash = (data) => {
        return target.encoding(crypto.hash('sha256', data));
    }

    target.keyDerivation = (password, iterations) => {
        return crypto.deriveKey('aes-256-gcm', password, iterations);
    }

    target.encryptionKeyGeneration = () => {
        const pskEncryption = crypto.createPskEncryption('aes-256-gcm');
        return pskEncryption.generateEncryptionKey();
    }

    target.encryption = (plainData, encryptionKey, options) => {
        const pskEncryption = crypto.createPskEncryption('aes-256-gcm');
        return pskEncryption.encrypt(plainData, encryptionKey, options);
    }

    target.decryption = (encryptedData, decryptionKey, authTagLength, options) => {
        const pskEncryption = crypto.createPskEncryption('aes-256-gcm');
        const utils = require("swarmutils");
        if (!$$.Buffer.isBuffer(decryptionKey) && (decryptionKey instanceof ArrayBuffer || ArrayBuffer.isView(decryptionKey))) {
            decryptionKey = utils.ensureIsBuffer(decryptionKey);
        }
        if (!$$.Buffer.isBuffer(encryptedData) && (decryptionKey instanceof ArrayBuffer || ArrayBuffer.isView(decryptionKey))) {
            encryptedData = utils.ensureIsBuffer(encryptedData);
        }
        return pskEncryption.decrypt(encryptedData, decryptionKey, 16, options);
    }

    target.encoding = (data) => {
        return crypto.pskBase58Encode(data);
    }

    target.decoding = (data) => {
        return crypto.pskBase58Decode(data);
    }

    target.base64Encoding = (data) => {
        return crypto.pskBase64Encode(data);
    }

    target.base64Decoding = (data) => {
        return crypto.pskBase64Decode(data);
    }

    target.keyPairGenerator = () => {
        return crypto.createKeyPairGenerator();
    }

    target.convertPublicKey = (rawPublicKey, options) => {
        const keyGenerator = crypto.createKeyPairGenerator();
        return keyGenerator.convertPublicKey(rawPublicKey, options);
    };

    target.verify = (data, publicKey, signature) => {
        return crypto.verifyETH(data, signature, publicKey);
    }

    target.ecies_encryption = (receiverPublicKey, message) => {
        return crypto.ecies_encrypt(receiverPublicKey, message, target.getConfigForIES())
    };

    target.ecies_decryption = (receiverPrivateKey, encEnvelope) => {
        return crypto.ecies_decrypt(receiverPrivateKey, encEnvelope, target.getConfigForIES());
    };

    target.ecies_encryption_ds = (senderKeyPair, receiverPublicKey, message) => {
        return crypto.ecies_encrypt_ds(senderKeyPair, receiverPublicKey, message, target.getConfigForIES())
    };

    target.ecies_decryption_ds = (receiverPrivateKey, encEnvelope) => {
        return crypto.ecies_decrypt_ds(receiverPrivateKey, encEnvelope, target.getConfigForIES());
    };

    target.ecies_encryption_kmac = (senderKeyPair, receiverPublicKey, message) => {
        return crypto.ecies_encrypt_kmac(senderKeyPair, receiverPublicKey, message, target.getConfigForIES())
    };

    target.ecies_decryption_kmac = (receiverPrivateKey, encEnvelope) => {
        return crypto.ecies_decrypt_kmac(receiverPrivateKey, encEnvelope, target.getConfigForIES());
    };

    let config = {
        curveName: 'secp256k1',
        encodingFormat: 'base64',
        macAlgorithmName: 'sha256',
        macKeySize: 16,
        hashFunctionName: 'sha256',
        hashSize: 32,
        signAlgorithmName: 'sha256',
        symmetricCipherName: 'aes-128-cbc',
        symmetricCipherKeySize: 16,
        ivSize: 16
    };

    target.getConfigForIES = () => {
        return config;
    };

    target.setConfigForIES = (_config) => {
        config = _config;
    }

    return target;
}

module.exports = CryptoAlgorithmsMixin;

},{"pskcrypto":"pskcrypto","swarmutils":"swarmutils"}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/key-ssi-resolver/lib/CryptoAlgorithms/CryptoAlgorithmsRegistry.js":[function(require,module,exports){
const SSITypes = require("../KeySSIs/SSITypes");
const CryptoFunctionTypes = require("./CryptoFunctionTypes");
const CryptoAlgorithmsMixin = require("./CryptoAlgorithmsMixin");
const SeedSSICryptoAlgorithms = require("./SeedSSICryptoAlgorithms");
const cryptoInterfaces = {};

const registerCryptoInterface = (keySSIType, vn, cryptoInterface) => {
    if (typeof cryptoInterfaces[keySSIType] !== "undefined" && typeof cryptoInterfaces[keySSIType][vn] !== "undefined") {
        throw Error(`A crypto interface for Key SSI ${keySSIType} is already registered for version ${vn}`);
    }

    if (typeof cryptoInterfaces[keySSIType] === "undefined") {
        cryptoInterfaces[keySSIType] = {};
    }

    cryptoInterfaces[keySSIType][vn] = cryptoInterface;
};

const getCryptoFunction = (keySSI, algorithmType) => {
    let cryptoFunction;
    try {
        cryptoFunction = cryptoInterfaces[keySSI.getTypeName()][keySSI.getVn()][algorithmType];
    } catch (e) {
        throw Error(`Algorithm type <${algorithmType}> not recognized for <${keySSI.getIdentifier(true)}>`);
    }

    if (typeof cryptoFunction === "undefined") {
        throw Error(`Algorithm type <${algorithmType}> not recognized for <${keySSI.getIdentifier(true)}>`);
    }
    return cryptoFunction;
};

function CryptoAlgorithmsRegistry() {
}

module.exports = new CryptoAlgorithmsRegistry();
CryptoAlgorithmsRegistry.prototype.getHashFunction = (keySSI) => {
    return getCryptoFunction(keySSI, CryptoFunctionTypes.HASH);
};

CryptoAlgorithmsRegistry.prototype.getKeyDerivationFunction = (keySSI) => {
    return getCryptoFunction(keySSI, CryptoFunctionTypes.KEY_DERIVATION);
};

CryptoAlgorithmsRegistry.prototype.getEncryptionFunction = (keySSI) => {
    return getCryptoFunction(keySSI, CryptoFunctionTypes.ENCRYPTION);
};

CryptoAlgorithmsRegistry.prototype.getEncryptionKeyGenerationFunction = (keySSI) => {
    return getCryptoFunction(keySSI, CryptoFunctionTypes.ENCRYPTION_KEY_GENERATION);
};

CryptoAlgorithmsRegistry.prototype.getDecryptionFunction = (keySSI) => {
    return getCryptoFunction(keySSI, CryptoFunctionTypes.DECRYPTION);
};

CryptoAlgorithmsRegistry.prototype.getEncodingFunction = (keySSI) => {
    return getCryptoFunction(keySSI, CryptoFunctionTypes.ENCODING);
};

CryptoAlgorithmsRegistry.prototype.getDecodingFunction = (keySSI) => {
    return getCryptoFunction(keySSI, CryptoFunctionTypes.DECODING);
};

CryptoAlgorithmsRegistry.prototype.getBase64EncodingFunction = (keySSI) => {
    return getCryptoFunction(keySSI, CryptoFunctionTypes.BASE64_ENCODING);
};

CryptoAlgorithmsRegistry.prototype.getBase64DecodingFunction = (keySSI) => {
    return getCryptoFunction(keySSI, CryptoFunctionTypes.BASE64_DECODING);
};

CryptoAlgorithmsRegistry.prototype.getKeyPairGenerator = (keySSI) => {
    return getCryptoFunction(keySSI, CryptoFunctionTypes.KEY_PAIR_GENERATOR);
};

CryptoAlgorithmsRegistry.prototype.getSignFunction = (keySSI) => {
    return getCryptoFunction(keySSI, CryptoFunctionTypes.SIGN);
};

CryptoAlgorithmsRegistry.prototype.getVerifyFunction = (keySSI) => {
    return getCryptoFunction(keySSI, CryptoFunctionTypes.VERIFY);
};

CryptoAlgorithmsRegistry.prototype.getDerivePublicKeyFunction = (keySSI) => {
    return getCryptoFunction(keySSI, CryptoFunctionTypes.DERIVE_PUBLIC_KEY);
};

CryptoAlgorithmsRegistry.prototype.getConvertPublicKeyFunction = (keySSI) => {
    return getCryptoFunction(keySSI, CryptoFunctionTypes.CONVERT_PUBLIC_KEY);
};

CryptoAlgorithmsRegistry.prototype.getCryptoFunction = getCryptoFunction;
CryptoAlgorithmsRegistry.prototype.registerCryptoInterface = registerCryptoInterface;

CryptoAlgorithmsRegistry.prototype.registerCryptoInterface(SSITypes.SEED_SSI, 'v0', new SeedSSICryptoAlgorithms());
CryptoAlgorithmsRegistry.prototype.registerCryptoInterface(SSITypes.PATH_SSI, 'v0', new CryptoAlgorithmsMixin());
CryptoAlgorithmsRegistry.prototype.registerCryptoInterface(SSITypes.WALLET_SSI, 'v0', new SeedSSICryptoAlgorithms());
CryptoAlgorithmsRegistry.prototype.registerCryptoInterface(SSITypes.SREAD_SSI, 'v0', new CryptoAlgorithmsMixin());
CryptoAlgorithmsRegistry.prototype.registerCryptoInterface(SSITypes.SZERO_ACCESS_SSI, 'v0', new CryptoAlgorithmsMixin());

CryptoAlgorithmsRegistry.prototype.registerCryptoInterface(SSITypes.PASSWORD_SSI, 'v0', new CryptoAlgorithmsMixin());
CryptoAlgorithmsRegistry.prototype.registerCryptoInterface(SSITypes.ARRAY_SSI, 'v0', new SeedSSICryptoAlgorithms());
CryptoAlgorithmsRegistry.prototype.registerCryptoInterface(SSITypes.CONST_SSI, 'v0', new SeedSSICryptoAlgorithms());
CryptoAlgorithmsRegistry.prototype.registerCryptoInterface(SSITypes.CONSTANT_ZERO_ACCESS_SSI, 'v0', new CryptoAlgorithmsMixin());
CryptoAlgorithmsRegistry.prototype.registerCryptoInterface(SSITypes.HASH_LINK_SSI, 'v0', new CryptoAlgorithmsMixin());
CryptoAlgorithmsRegistry.prototype.registerCryptoInterface(SSITypes.SYMMETRICAL_ENCRYPTION_SSI, 'v0', new CryptoAlgorithmsMixin());
CryptoAlgorithmsRegistry.prototype.registerCryptoInterface(SSITypes.EMBED_SSI, 'v0', new CryptoAlgorithmsMixin());

CryptoAlgorithmsRegistry.prototype.registerCryptoInterface(SSITypes.TOKEN_SSI, 'v0', new CryptoAlgorithmsMixin());
CryptoAlgorithmsRegistry.prototype.registerCryptoInterface(SSITypes.OWNERSHIP_SSI, 'v0', new SeedSSICryptoAlgorithms());
CryptoAlgorithmsRegistry.prototype.registerCryptoInterface(SSITypes.OWNERSHIP_READ_SSI, 'v0', new CryptoAlgorithmsMixin());
CryptoAlgorithmsRegistry.prototype.registerCryptoInterface(SSITypes.TRANSFER_SSI, 'v0', new SeedSSICryptoAlgorithms());
CryptoAlgorithmsRegistry.prototype.registerCryptoInterface(SSITypes.ZERO_ACCESS_TOKEN_SSI, 'v0', new CryptoAlgorithmsMixin());
CryptoAlgorithmsRegistry.prototype.registerCryptoInterface(SSITypes.SIGNED_HASH_LINK_SSI, 'v0', new CryptoAlgorithmsMixin());

CryptoAlgorithmsRegistry.prototype.registerCryptoInterface(SSITypes.CONSENSUS_SSI, 'v0', new CryptoAlgorithmsMixin());
CryptoAlgorithmsRegistry.prototype.registerCryptoInterface(SSITypes.PUBLIC_KEY_SSI, 'v0', new CryptoAlgorithmsMixin());


},{"../KeySSIs/SSITypes":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/key-ssi-resolver/lib/KeySSIs/SSITypes.js","./CryptoAlgorithmsMixin":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/key-ssi-resolver/lib/CryptoAlgorithms/CryptoAlgorithmsMixin.js","./CryptoFunctionTypes":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/key-ssi-resolver/lib/CryptoAlgorithms/CryptoFunctionTypes.js","./SeedSSICryptoAlgorithms":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/key-ssi-resolver/lib/CryptoAlgorithms/SeedSSICryptoAlgorithms.js"}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/key-ssi-resolver/lib/CryptoAlgorithms/CryptoFunctionTypes.js":[function(require,module,exports){
module.exports = {
    HASH: "hash",
    ENCRYPTION: "encryption",
    DECRYPTION: "decryption",
    ECIES_ENCRYPTION: "ecies_encryption",
    ECIES_DECRYPTION: "ecies_decryption",
    ECIES_ENCRYPTION_KMAC: "ecies_encryption_kmac",
    ECIES_DECRYPTION_KMAC: "ecies_decryption_kmac",
    ECIES_ENCRYPTION_DS: "ecies_encryption_ds",
    ECIES_DECRYPTION_DS: "ecies_decryption_ds",
    ENCRYPTION_KEY_GENERATION: "encryptionKeyGeneration",
    KEY_DERIVATION: "keyDerivation",
    ENCODING: "encoding",
    DECODING: "decoding",
    BASE64_ENCODING:"base64Encoding",
    BASE64_DECODING:"base64Decoding",
    SIGN: "sign",
    VERIFY: "verify",
    DERIVE_PUBLIC_KEY: "derivePublicKey",
    CONVERT_PUBLIC_KEY: "convertPublicKey",
    KEY_PAIR_GENERATOR: "keyPairGenerator",
    GET_IES_CONFIG: "getConfigForIES",
    SET_IES_CONFIG: "setConfigForIES",
};

},{}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/key-ssi-resolver/lib/CryptoAlgorithms/SeedSSICryptoAlgorithms.js":[function(require,module,exports){
function SeedSSICryptoAlgorithms() {
    const crypto = require("pskcrypto");
    const CryptoAlgorithmsMixin = require("./CryptoAlgorithmsMixin");
    CryptoAlgorithmsMixin(this);
    const self = this;

    self.sign = (data, privateKey) => {
        return crypto.signETH(data, privateKey);
    }

    self.derivePublicKey = (privateKey, format) => {
        if (typeof format === "undefined") {
            format = "pem";
        }
        const keyGenerator = crypto.createKeyPairGenerator();
        let publicKey = keyGenerator.getPublicKey(privateKey, 'secp256k1');
        switch (format) {
            case "raw":
                return publicKey;
            case "pem":
                return keyGenerator.getPemKeys(privateKey, publicKey).publicKey;
            default:
                throw Error("Invalid format name");
        }
    }
}

module.exports = SeedSSICryptoAlgorithms;

},{"./CryptoAlgorithmsMixin":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/key-ssi-resolver/lib/CryptoAlgorithms/CryptoAlgorithmsMixin.js","pskcrypto":"pskcrypto"}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/key-ssi-resolver/lib/DSUFactoryRegistry/DSUTypes.js":[function(require,module,exports){
module.exports = {
    LEGACY_DSU: "legacyDSU",
    BAR: "bar"
}
},{}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/key-ssi-resolver/lib/DSUFactoryRegistry/factories/BarFactory.js":[function(require,module,exports){
/**
 * @param {object} options
 * @param {KeySSIFactory} options.keySSIFactory
 * @param {BrickMapStrategyFactory} options.brickMapStrategyFactory
 */
const cache = require('psk-cache').getDefaultInstance();

function BarFactory(factoryOptions) {
    const barModule = require('bar');
    const fsAdapter = require('bar-fs-adapter');
    factoryOptions = factoryOptions || {};
    const MAX_BRICK_SIZE = factoryOptions.maxBrickSize || 10000000;
    this.keySSIFactory = factoryOptions.keySSIFactory;
    this.brickMapStrategyFactory = factoryOptions.brickMapStrategyFactory || new barModule.BrickMapStrategyFactory();
    const openDSU = require("opendsu");
    const keySSISpace = openDSU.loadAPI("keyssi");
    const INSTANCE_CREATION_METHODS = {
        INIT: "init",
        LOAD: "load",
        LOAD_VERSION: "loadVersion"
    }
    function castSSI(ssi) {
        if (typeof ssi !== "undefined") {
            if (typeof ssi === "string") {
                ssi = keySSISpace.parse(ssi);
            } else {
                if (ssi.getTypeName === undefined || ssi.getIdentifier === undefined) {
                    throw Error("Please provide a proper SSI instance ");
                }
            }
        } else {
            throw Error("SSI should not be undefined");
        }
        return ssi;
    }

    ////////////////////////////////////////////////////////////
    // Private methods
    ////////////////////////////////////////////////////////////

    /**
     * @param {SeedSSI} keySSI
     * @param {object} options
     * @return {Archive}
     */
    const createInstance = (keySSI, options, initializationMethod, callback) => {
        const allowedInitMethods = Object.values(INSTANCE_CREATION_METHODS);
        if (typeof options.useMineMergeStrategy === "undefined") {
            options.useMineMergeStrategy = false;
        }

        if (allowedInitMethods.indexOf(initializationMethod) === -1) {
            throw Error("Wrong usage of the createInstance method");
        }

        let bar;
        try {
            const ArchiveConfigurator = barModule.ArchiveConfigurator;
            ArchiveConfigurator.prototype.registerFsAdapter("FsAdapter", fsAdapter.createFsAdapter);
            const archiveConfigurator = new ArchiveConfigurator(options);
            archiveConfigurator.setCache(cache);
            const envTypes = require("overwrite-require").constants;
            if ($$.environmentType !== envTypes.BROWSER_ENVIRONMENT_TYPE &&
                $$.environmentType !== envTypes.SERVICE_WORKER_ENVIRONMENT_TYPE &&
                $$.environmentType !== envTypes.WEB_WORKER_ENVIRONMENT_TYPE) {
                archiveConfigurator.setFsAdapter("FsAdapter");
            }
            archiveConfigurator.setBufferSize(MAX_BRICK_SIZE);
            archiveConfigurator.setKeySSI(keySSI);
            let brickMapStrategyName = options.brickMapStrategy;
            let anchoringOptions = options.anchoringOptions;

            let brickMapStrategy = createBrickMapStrategy(brickMapStrategyName, anchoringOptions);
            archiveConfigurator.setBrickMapStrategy(brickMapStrategy);

            if (options.validationRules) {
                archiveConfigurator.setValidationRules(options.validationRules);
            }

            if (options.skipCache) {
                archiveConfigurator.disableDSUCaching()
            }

            bar = barModule.createArchive(archiveConfigurator);
            const DSUBase = require("../mixins/DSUBase");
            DSUBase(bar);
        } catch (err) {
            return callback(err);
        }

        let defaultCallback = err => {
            callback(err, bar)
        };

        let initCallback = (err) => {
            if (err) {
                return callback(err);
            }

            if (typeof options === "object" && options.addLog) {
                return bar.dsuLog("DSU created on " + Date.now(), defaultCallback);
            }

            callback(err, bar);
        }

        if (initializationMethod === INSTANCE_CREATION_METHODS.LOAD) {
            if (options && options.versionHashlink) {
                initializationMethod = INSTANCE_CREATION_METHODS.LOAD_VERSION;
                return bar[initializationMethod](options.versionHashlink, defaultCallback);
            }

            initializationMethod = INSTANCE_CREATION_METHODS.LOAD;
        }

        bar[initializationMethod](initializationMethod === INSTANCE_CREATION_METHODS.INIT ? initCallback : defaultCallback);
    }

    /**
     * @return {object}
     */
    const createBrickMapStrategy = (name, options) => {
        const strategy = this.brickMapStrategyFactory.create(name, options);
        return strategy;
    }

    /**
     * @return {SecretDID}
     * @param templateKeySSI
     * @param callback
     */
    const initializeKeySSI = (templateKeySSI, callback) => {
        if (typeof templateKeySSI === "function") {
            callback = templateKeySSI;
            templateKeySSI = undefined;
        }

        if (typeof templateKeySSI === "undefined") {
            return callback(Error("A template keySSI should be provided when creating a new DSU."));
        }

        keySSISpace.createSeedSSI(templateKeySSI.getDLDomain(), undefined, templateKeySSI.getHint(), callback);
    }

    ////////////////////////////////////////////////////////////
    // Public methods
    ////////////////////////////////////////////////////////////

    /**
     * @param {object} options
     * @param {string} options.brickMapStrategy 'Diff', 'Versioned' or any strategy registered with the factory
     * @param {object} options.anchoringOptions Anchoring options to pass to bar map strategy
     * @param {callback} options.anchoringOptions.decisionFn Callback which will decide when to effectively anchor changes
     *                                                              If empty, the changes will be anchored after each operation
     * @param {callback} options.anchoringOptions.conflictResolutionFn Callback which will handle anchoring conflicts
     *                                                              The default strategy is to reload the BrickMap and then apply the new changes
     * @param {callback} options.anchoringOptions.anchoringEventListener An event listener which is called when the strategy anchors the changes
     * @param {callback} options.anchoringOptions.signingFn  A function which will sign the new alias
     * @param {object} options.validationRules
     * @param {object} options.validationRules.preWrite An object capable of validating operations done in the "preWrite" stage of the BrickMap
     * @param {callback} callback
     */
    this.create = (keySSI, options, callback) => {
        keySSI = castSSI(keySSI);
        if (typeof options === "function") {
            callback = options;
            options = undefined;
        }
        options = options || {};
        if (options.useSSIAsIdentifier) {
            return createInstance(keySSI, options, INSTANCE_CREATION_METHODS.INIT, callback);
        }

        initializeKeySSI(keySSI, (err, _keySSI) => {
            if (err) {
                return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to initialize keySSI <${keySSI.getIdentifier(true)}>`, err));
            }
            return createInstance(_keySSI, options, INSTANCE_CREATION_METHODS.INIT, callback);
        });
    }

    /**
     * @param {string} keySSI
     * @param {object} options
     * @param {string} options.brickMapStrategy 'Diff', 'Versioned' or any strategy registered with the factory
     * @param {object} options.anchoringOptions Anchoring options to pass to bar map strategy
     * @param {callback} options.anchoringOptions.decisionFn Callback which will decide when to effectively anchor changes
     *                                                              If empty, the changes will be anchored after each operation
     * @param {callback} options.anchoringOptions.conflictResolutionFn Callback which will handle anchoring conflicts
     *                                                              The default strategy is to reload the BrickMap and then apply the new changes
     * @param {callback} options.anchoringOptions.anchoringEventListener An event listener which is called when the strategy anchors the changes
     * @param {callback} options.anchoringOptions.signingFn  A function which will sign the new alias
     * @param {object} options.validationRules
     * @param {object} options.validationRules.preWrite An object capable of validating operations done in the "preWrite" stage of the BrickMap
     * @param {callback} callback
     */
    this.load = (keySSI, options, callback) => {
        keySSI = castSSI(keySSI);
        if (typeof options === "function") {
            callback = options;
            options = undefined;
        }
        options = options || {};
        createInstance(keySSI, options, INSTANCE_CREATION_METHODS.LOAD, callback);
    }
}

module.exports = BarFactory;

},{"../mixins/DSUBase":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/key-ssi-resolver/lib/DSUFactoryRegistry/mixins/DSUBase.js","bar":"bar","bar-fs-adapter":"bar-fs-adapter","opendsu":"opendsu","overwrite-require":"overwrite-require","psk-cache":"psk-cache"}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/key-ssi-resolver/lib/DSUFactoryRegistry/factories/ConstDSUFactory.js":[function(require,module,exports){
/**
 * @param {object} options
 * @param {KeySSIFactory} options.keySSIFactory
 * @param {BrickMapStrategyFactory} options.brickMapStrategyFactory
 */
function ConstDSUFactory(options) {
    options = options || {};
    this.barFactory = options.barFactory;

    /**
     * @param {object} options
     * @param {string} options.brickMapStrategy 'Diff', 'Versioned' or any strategy registered with the factory
     * @param {object} options.anchoringOptions Anchoring options to pass to bar map strategy
     * @param {callback} options.anchoringOptions.decisionFn Callback which will decide when to effectively anchor changes
     *                                                              If empty, the changes will be anchored after each operation
     * @param {callback} options.anchoringOptions.conflictResolutionFn Callback which will handle anchoring conflicts
     *                                                              The default strategy is to reload the BrickMap and then apply the new changes
     * @param {callback} options.anchoringOptions.anchoringEventListener An event listener which is called when the strategy anchors the changes
     * @param {callback} options.anchoringOptions.signingFn  A function which will sign the new alias
     * @param {object} options.validationRules
     * @param {object} options.validationRules.preWrite An object capable of validating operations done in the "preWrite" stage of the BrickMap
     * @param {callback} callback
     */
    this.create = (keySSI, options, callback) => {
        if (typeof options === 'function') {
            callback = options;
            options = {};
        }
        if(typeof options.useSSIAsIdentifier === "undefined" || !options.useSSIAsIdentifier){
            throw Error("Creating a DSU using keySSI from the arraySSI family not allowed. Use the resolver.createDSUForExisting method instead.");
        }
        //preventing default mechanism that forces an anchor at the dsu creation
        options.addLog = false;
        //testing if a constDSU already exists in order to prevent new instances
        options.disableTimeMetadata = true;
        this.barFactory.load(keySSI, options, (err)=>{
            if(!err){
                return callback(new Error("ConstDSU already exists! Can't be created again."));
            }
            // enable options.validationRules.preWrite to stop content update
            this.barFactory.create(keySSI, options, callback);
        });
    };

    /**
     * @param {string} keySSI
     * @param {object} options
     * @param {string} options.brickMapStrategy 'Diff', 'Versioned' or any strategy registered with the factory
     * @param {object} options.anchoringOptions Anchoring options to pass to bar map strategy
     * @param {callback} options.anchoringOptions.decisionFn Callback which will decide when to effectively anchor changes
     *                                                              If empty, the changes will be anchored after each operation
     * @param {callback} options.anchoringOptions.conflictResolutionFn Callback which will handle anchoring conflicts
     *                                                              The default strategy is to reload the BrickMap and then apply the new changes
     * @param {callback} options.anchoringOptions.anchoringEventListener An event listener which is called when the strategy anchors the changes
     * @param {callback} options.anchoringOptions.signingFn  A function which will sign the new alias
     * @param {object} options.validationRules
     * @param {object} options.validationRules.preWrite An object capable of validating operations done in the "preWrite" stage of the BrickMap
     * @param {callback} callback
     */
    this.load = (keySSI, options, callback) => {
        if (typeof options === 'function') {
            callback = options;
            options = {};
        }

        if (typeof options === "undefined") {
            options = {};
        }

        options.disableTimeMetadata = true;
        // enable options.validationRules.preWrite to stop content update
        this.barFactory.load(keySSI, options, callback);
    };
}

module.exports = ConstDSUFactory;

},{}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/key-ssi-resolver/lib/DSUFactoryRegistry/factories/DSUFactory.js":[function(require,module,exports){
const dsuTypesFactoryRegistry = {}
const DSUTypes = require("../DSUTypes");

function DSUFactory(factoryOptions) {
    const dsuFactoryInstancesRegistry = {};
    for(let dsuType in dsuTypesFactoryRegistry){
        dsuFactoryInstancesRegistry[dsuType] = dsuTypesFactoryRegistry[dsuType](factoryOptions);
    }

    this.create = (keySSI, options, callback) => {
        const defaultInstanceOptions = {dsuType: DSUTypes.LEGACY_DSU};
        if (typeof options === "function") {
            callback = options;
            options = {};
        }

        Object.assign(defaultInstanceOptions, options);
        options = defaultInstanceOptions;
        if (typeof dsuTypesFactoryRegistry[options.dsuType] !== "function") {
            return callback(Error(`No factory registered for dsu type <${options.dsuType}>`));
        }

        const factoryInstance = dsuFactoryInstancesRegistry[options.dsuType];
        factoryInstance.create(keySSI, options, callback);
    }

    this.load = (keySSI, options, callback) => {
        const defaultInstanceOptions = {dsuType: DSUTypes.LEGACY_DSU};
        if (typeof options === "function") {
            callback = options;
            options = {};
        }

        Object.assign(defaultInstanceOptions, options);
        options = defaultInstanceOptions;
        if (typeof dsuTypesFactoryRegistry[options.dsuType] !== "function") {
            return callback(Error(`No factory registered for dsu type <${options.dsuType}>`));
        }

        const factoryInstance = dsuFactoryInstancesRegistry[options.dsuType];
        factoryInstance.load(keySSI, options, callback);
    }
}

DSUFactory.prototype.registerDSUTypeFactory = (dsuType, factory) => {
    dsuTypesFactoryRegistry[dsuType] = factory;
}

const LegacyDSUFactory = require("./LegacyDSUFactory");
const BarFactory = require("./BarFactory");

DSUFactory.prototype.registerDSUTypeFactory(DSUTypes.LEGACY_DSU, function (factoryOptions) {
    return new LegacyDSUFactory(factoryOptions);
});
DSUFactory.prototype.registerDSUTypeFactory(DSUTypes.BAR, function (factoryOptions) {
    return new BarFactory(factoryOptions);
});

module.exports = DSUFactory;

},{"../DSUTypes":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/key-ssi-resolver/lib/DSUFactoryRegistry/DSUTypes.js","./BarFactory":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/key-ssi-resolver/lib/DSUFactoryRegistry/factories/BarFactory.js","./LegacyDSUFactory":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/key-ssi-resolver/lib/DSUFactoryRegistry/factories/LegacyDSUFactory.js"}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/key-ssi-resolver/lib/DSUFactoryRegistry/factories/LegacyDSUFactory.js":[function(require,module,exports){
function LegacyDSUFactory(factoryOptions) {
    const LegacyDSU = require("../../dsu/LegacyDSU");
    const BarFactory = require("./BarFactory");
    const barFactoryInstance = new BarFactory(factoryOptions);
    const DSUInstancesRegistry = require("../../utils/RaceConditionPreventer");
    const dsuInstancesRegistry = new DSUInstancesRegistry();

    const storeDSUInstance = (legacyDSU) => {
        dsuInstancesRegistry.put(legacyDSU.getAnchorIdSync(), legacyDSU);
    }

    this.create = (keySSI, options, callback) => {
        barFactoryInstance.create(keySSI, options, (err, barInstance) => {
            if (err) {
                return callback(err);
            }

            const legacyDSU = new LegacyDSU(barInstance, dsuInstancesRegistry);
            storeDSUInstance(legacyDSU);
            callback(undefined, legacyDSU);
        })
    }

    this.load = (keySSI, options, callback) => {
        barFactoryInstance.load(keySSI, options, (err, barInstance) => {
            if (err) {
                return callback(err);
            }

            const legacyDSU = new LegacyDSU(barInstance, dsuInstancesRegistry);
            storeDSUInstance(legacyDSU);
            callback(undefined, legacyDSU);
        })
    }
}

module.exports = LegacyDSUFactory;

},{"../../dsu/LegacyDSU":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/key-ssi-resolver/lib/dsu/LegacyDSU.js","../../utils/RaceConditionPreventer":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/key-ssi-resolver/lib/utils/RaceConditionPreventer.js","./BarFactory":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/key-ssi-resolver/lib/DSUFactoryRegistry/factories/BarFactory.js"}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/key-ssi-resolver/lib/DSUFactoryRegistry/factories/VersionlessDSUFactory.js":[function(require,module,exports){
function VersionlessDSUFactory() {
    const VersionlessDSU = require("../../dsu/VersionlessDSU");

    /**
     * @param {object} options
     * @param {string} options.addLog boolean, specify if log create entry should be added
     * @param {callback} callback
     */
    this.create = (keySSI, options, callback) => {
        if (typeof options === "function") {
            callback = options;
            options = undefined;
        }

        if (typeof options === "undefined") {
            options = {};
        }

        const versionlessDSU = new VersionlessDSU({ keySSI });

        const initCallback = (error, result) => {
            if (error) {
                return callback(error);
            }

            if (options.addLog) {
                return versionlessDSU.dsuLog(`DSU created on ${Date.now()}`, (err) => {
                    callback(err, result);
                });
            }
            callback(undefined, result);
        };

        versionlessDSU.init(initCallback);
    };

    /**
     * @param {string} keySSI
     * @param {object} options
     * @param {callback} callback
     */
    this.load = (keySSI, options, callback) => {
        if (typeof options === "function") {
            callback = options;
            options = {};
        }

        const versionlessDSU = new VersionlessDSU({ keySSI });
        versionlessDSU.load(callback);
    };
}

module.exports = VersionlessDSUFactory;

},{"../../dsu/VersionlessDSU":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/key-ssi-resolver/lib/dsu/VersionlessDSU.js"}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/key-ssi-resolver/lib/DSUFactoryRegistry/factories/WalletFactory.js":[function(require,module,exports){
/**
 * @param {object} options
 * @param {KeySSIFactory} options.keySSIFactory
 * @param {BrickMapStrategyFactory} options.brickMapStrategyFactory
 */
function WalletFactory(options) {
    options = options || {};
    this.dsuFactory = options.barFactory;
    const WALLET_MOUNT_POINT = "/writableDSU";
    /**
     * @param {object} options
     * @param {string} options.brickMapStrategy 'Diff', 'Versioned' or any strategy registered with the factory
     * @param {object} options.anchoringOptions Anchoring options to pass to bar map strategy
     * @param {callback} options.anchoringOptions.decisionFn Callback which will decide when to effectively anchor changes
     *                                                              If empty, the changes will be anchored after each operation
     * @param {callback} options.anchoringOptions.conflictResolutionFn Callback which will handle anchoring conflicts
     *                                                              The default strategy is to reload the BrickMap and then apply the new changes
     * @param {callback} options.anchoringOptions.anchoringEventListener An event listener which is called when the strategy anchors the changes
     * @param {callback} options.anchoringOptions.signingFn  A function which will sign the new alias
     * @param {object} options.validationRules
     * @param {object} options.validationRules.preWrite An object capable of validating operations done in the "preWrite" stage of the BrickMap
     * @param {object} options.walletKeySSI - KeySSI of the wallet to be mounted in constDSUWallet
     * @param {callback} callback
     */
    this.create = (keySSI, options, callback) => {
        const defaultOpts = {overwrite: false};

        if (typeof options === 'function') {
            callback = options;
            options = {};
        }
        let writableWallet;
        let constDSUWallet;

        Object.assign(defaultOpts, options);
        options = defaultOpts;

        let createWritableDSU = () => {
            let templateSSI = require("opendsu").loadApi("keyssi").createTemplateSeedSSI(keySSI.getDLDomain(), undefined, undefined, undefined, keySSI.getHint());
            this.dsuFactory.create(templateSSI, (err, writableDSU) => {
                if (err) {
                    return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to create writable using templateSSI <${templateSSI.getIdentifier(true)}>`, err));
                }
                writableWallet = writableDSU;
                mountDSUType();
            })
        }

        let mountDSUType = () => {
            writableWallet.safeBeginBatch(err => {
                if (err) {
                    return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to start batch writable DSU`, err));
                }
                writableWallet.mount("/code", options.dsuTypeSSI, async err => {
                    if (err) {
                        const mountError = createOpenDSUErrorWrapper(`Failed to mount DSU type <${options.dsuTypeSSI.getIdentifier(true)}>`, err);
                        try{
                            await writableWallet.cancelBatchAsync();
                        }catch (e) {
                            return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to cancel batch writable DSU`, e, mountError));
                        }
                        return OpenDSUSafeCallback(callback)(mountError);
                    }

                    writableWallet.commitBatch(err => {
                        if (err) {
                            return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to commit batch writable DSU`, err));
                        }
                        createConstDSU();
                    })
                });
            })
        }

        let createConstDSU = () => {
            const newOptions = JSON.parse(JSON.stringify(options));
            newOptions.addLog = false;
            this.dsuFactory.create(keySSI, newOptions, (err, constWallet) => {
                if (err) {
                    return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to create ConstDSU using keySSI <${keySSI.getIdentifier(true)}>`, err));
                }

                constDSUWallet = constWallet;
                constDSUWallet.getWritableDSU = function () {
                    return writableWallet;
                }
                mountWritableWallet();
            })
        }


        let mountWritableWallet = () => {
            writableWallet.getKeySSIAsString((err, seedSSI) => {
                if (err) {
                    return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper("Failed to get seedSSI", err));
                }

                constDSUWallet.safeBeginBatch(err => {
                    if (err) {
                        return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper("Failed to start batch on const DSU", err));
                    }
                    constDSUWallet.mount(WALLET_MOUNT_POINT, seedSSI, async err => {
                        if (err) {
                            const mountError = createOpenDSUErrorWrapper("Failed to mount writable SSI in wallet", err);
                            try{
                                await constDSUWallet.cancelBatchAsync();
                            }catch (e) {
                                return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper("Failed to cancel batch on const DSU", e, mountError));
                            }
                            return OpenDSUSafeCallback(callback)(mountError);
                        }

                        constDSUWallet.commitBatch(err => {
                            if (err) {
                                return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper("Failed to commit batch on const DSU", err));
                            }
                            callback(undefined, constDSUWallet);
                        });
                    });
                })
            });
        }

        if (options.walletKeySSI) {
            this.dsuFactory.load(options.walletKeySSI, (err, dsu) => {
                if (err) {
                    return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper("Failed to load writable DSU from ConstDSU Wallet ------->>>>>>", err));
                }
                writableWallet = dsu;
                createConstDSU();
            });
        } else {
            createWritableDSU();
        }

    };


    /**
     * @param {string} keySSI
     * @param {object} options
     * @param {string} options.brickMapStrategy 'Diff', 'Versioned' or any strategy registered with the factory
     * @param {object} options.anchoringOptions Anchoring options to pass to bar map strategy
     * @param {callback} options.anchoringOptions.decisionFn Callback which will decide when to effectively anchor changes
     *                                                              If empty, the changes will be anchored after each operation
     * @param {callback} options.anchoringOptions.conflictResolutionFn Callback which will handle anchoring conflicts
     *                                                              The default strategy is to reload the BrickMap and then apply the new changes
     * @param {callback} options.anchoringOptions.anchoringEventListener An event listener which is called when the strategy anchors the changes
     * @param {callback} options.anchoringOptions.signingFn  A function which will sign the new alias
     * @param {object} options.validationRules
     * @param {object} options.validationRules.preWrite An object capable of validating operations done in the "preWrite" stage of the BrickMap
     * @param {callback} callback
     */
    this.load = (keySSI, options, callback) => {
        const defaultOpts = {overwrite: false};
        if (typeof options === 'function') {
            callback = options;
            options = {};
        }
        Object.assign(defaultOpts, options);
        options = defaultOpts;
        let constDSU;
        let writableDSU;
        let writableSSI;

        let loadConstDSU = () => {
            this.dsuFactory.load(keySSI, options, (err, dsu) => {
                if (err) {
                    return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper("Failed to load ConstDSU", err));
                }
                constDSU = dsu;
                getSSIFromMountPoint();
            });
        }

        let getSSIFromMountPoint = () => {
            constDSU.getSSIForMount(WALLET_MOUNT_POINT, (err, ssi) => {
                if (err) {
                    return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper("Failed to get mount point in ConstDSU", err));
                }
                writableSSI = require("opendsu").loadApi("keyssi").parse(ssi);
                loadWritableDSU();
            });
        }

        let loadWritableDSU = () => {
            this.dsuFactory.load(writableSSI, options, (err, dsu) => {
                if (err) {
                    return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper("Failed to load writable DSU from ConstDSU Wallet", err));
                }
                writableDSU = dsu;
                constDSU.getWritableDSU = function () {
                    return writableDSU;
                }
                return callback(undefined, constDSU);
            });
        }

        loadConstDSU();

    };
}

module.exports = WalletFactory;

},{"opendsu":"opendsu"}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/key-ssi-resolver/lib/DSUFactoryRegistry/index.js":[function(require,module,exports){
const DSUFactory = require('./factories/DSUFactory');
const SSITypes = require("../KeySSIs/SSITypes");
/**
 * @param {object} options
 * @param {KeySSIFactory} options.keySSIFactory
 * @param {BrickMapStrategyFactory} options.brickMapStrategyFactory
 */
const factories = {};

function Registry(options) {
    options = options || {};

    const keySSIFactory = options.keySSIFactory;
    const brickMapStrategyFactory = options.brickMapStrategyFactory

    if (!keySSIFactory) {
        throw new Error('A KeySSI factory is required');
    }

    if (!brickMapStrategyFactory) {
        throw new Error('A BrickMapStratregy factory is required');
    }

    /**
     * Initialize the factory state
     */
    const initialize = () => {
        let dsuFactory = new DSUFactory({
            keySSIFactory,
            brickMapStrategyFactory
        });
        this.registerDSUType(SSITypes.SEED_SSI, dsuFactory);
        this.registerDSUType(SSITypes.SREAD_SSI, dsuFactory);

        const WalletFactory = require("./factories/WalletFactory");
        const walletFactory = new WalletFactory({barFactory: dsuFactory});
        this.registerDSUType(SSITypes.WALLET_SSI, walletFactory);
        const ConstDSUFactory = require("./factories/ConstDSUFactory");
        const constDSUFactory = new ConstDSUFactory({barFactory: dsuFactory});
        this.registerDSUType(SSITypes.CONST_SSI, constDSUFactory);
        this.registerDSUType(SSITypes.ARRAY_SSI, constDSUFactory);

        const OwnershipDSUFactory = require("./obsolete/OwnershipDSUFactory");
        const ownershipDSUFactory = new OwnershipDSUFactory({barFactory: dsuFactory})
        this.registerDSUType(SSITypes.OWNERSHIP_SSI, ownershipDSUFactory);
        this.registerDSUType(SSITypes.OWNERSHIP_READ_SSI, ownershipDSUFactory);

        const ConsensusDSUFactory = require("./obsolete/ConsensusDSUFactory");
        const consensusDSUFactory = new ConsensusDSUFactory({barFactory: dsuFactory});
        this.registerDSUType(SSITypes.CONSENSUS_SSI, consensusDSUFactory);

        const VersionlessDSUFactory = require("./factories/VersionlessDSUFactory");
        const versionlessDSUFactory = new VersionlessDSUFactory();
        this.registerDSUType(SSITypes.VERSIONLESS_SSI, versionlessDSUFactory);
    }

    ////////////////////////////////////////////////////////////
    // Public methods
    ////////////////////////////////////////////////////////////

    /**
     * @param {string} representation
     * @return {boolean}
     */
    this.isValidKeySSI = (keySSI) => {
        try {
            return typeof factories[keySSI.getTypeName()] !== 'undefined';
        } catch (err) {
            return false;
        }
    };


    /**
     * @param {object} keySSI
     * @param {object} dsuConfiguration
     * @param {string} dsuConfiguration.brickMapStrategyFactory 'Diff', 'Versioned' or any strategy registered with the factory
     * @param {object} dsuConfiguration.anchoringOptions Anchoring options to pass to bar map strategy
     * @param {callback} dsuConfiguration.anchoringOptions.decisionFn Callback which will decide when to effectively anchor changes
     *                                                              If empty, the changes will be anchored after each operation
     * @param {callback} dsuConfiguration.anchoringOptions.conflictResolutionFn Callback which will handle anchoring conflicts
     *                                                              The default strategy is to reload the BrickMap and then apply the new changes
     * @param {callback} dsuConfiguration.anchoringOptions.anchoringCb A callback which is called when the strategy anchors the changes
     * @param {callback} dsuConfiguration.anchoringOptions.signingFn  A function which will sign the new alias
     * @param {object} dsuConfiguration.validationRules
     * @param {object} dsuConfiguration.validationRules.preWrite An object capable of validating operations done in the "preWrite" stage of the BrickMap
     * @param {callback} callback
     */
    this.create = (keySSI, dsuConfiguration, callback) => {
        let type = keySSI.getTypeName();
        if (keySSI.options && keySSI.options.dsuFactoryType) {
            type = keySSI.options.dsuFactoryType;
        }
        const factory = factories[type];
        factory.create(keySSI, dsuConfiguration, callback);
    }

    /**
     * @param {object} keySSI
     * @param {string} representation
     * @param {object} dsuConfiguration
     * @param {string} dsuConfiguration.brickMapStrategyFactory 'Diff', 'Versioned' or any strategy registered with the factory
     * @param {object} dsuConfiguration.anchoringOptions Anchoring options to pass to bar map strategy
     * @param {callback} dsuConfiguration.anchoringOptions.decisionFn Callback which will decide when to effectively anchor changes
     *                                                              If empty, the changes will be anchored after each operation
     * @param {callback} dsuConfiguration.anchoringOptions.conflictResolutionFn Callback which will handle anchoring conflicts
     *                                                              The default strategy is to reload the BrickMap and then apply the new changes
     * @param {callback} dsuConfiguration.anchoringOptions.anchoringCb A callback which is called when the strategy anchors the changes
     * @param {callback} dsuConfiguration.anchoringOptions.signingFn  A function which will sign the new alias
     * @param {object} dsuConfiguration.validationRules
     * @param {object} dsuConfiguration.validationRules.preWrite An object capable of validating operations done in the "preWrite" stage of the BrickMap
     * @param {callback} callback
     */
    this.load = (keySSI, dsuConfiguration, callback) => {
        let type = keySSI.getTypeName();
        if (keySSI.options && keySSI.options.dsuFactoryType) {
            type = keySSI.options.dsuFactoryType;
        }
        const factory = factories[type];
        return factory.load(keySSI, dsuConfiguration, callback);
    }

    initialize();
}

/**
 * @param {string} dsuType
 * @param {object} factory
 */
Registry.prototype.registerDSUType = (dsuType, factory) => {
    factories[dsuType] = factory;
}

Registry.prototype.getDSUFactory = (dsuType) => {
    return factories[dsuType];
}

module.exports = Registry;

},{"../KeySSIs/SSITypes":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/key-ssi-resolver/lib/KeySSIs/SSITypes.js","./factories/ConstDSUFactory":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/key-ssi-resolver/lib/DSUFactoryRegistry/factories/ConstDSUFactory.js","./factories/DSUFactory":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/key-ssi-resolver/lib/DSUFactoryRegistry/factories/DSUFactory.js","./factories/VersionlessDSUFactory":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/key-ssi-resolver/lib/DSUFactoryRegistry/factories/VersionlessDSUFactory.js","./factories/WalletFactory":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/key-ssi-resolver/lib/DSUFactoryRegistry/factories/WalletFactory.js","./obsolete/ConsensusDSUFactory":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/key-ssi-resolver/lib/DSUFactoryRegistry/obsolete/ConsensusDSUFactory.js","./obsolete/OwnershipDSUFactory":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/key-ssi-resolver/lib/DSUFactoryRegistry/obsolete/OwnershipDSUFactory.js"}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/key-ssi-resolver/lib/DSUFactoryRegistry/mixins/DSUBase.js":[function(require,module,exports){
module.exports = function(archive){
	archive.call = (functionName, ...args) => {
		if(args.length === 0){
			throw Error('Missing arguments. Usage: call(functionName, [arg1, arg2 ...] callback)');
		}
		const callback = args.pop();
		if(typeof  callback !== "function"){
			throw Error('Last argument is always a callback function. Usage: call(functionName, [arg1, arg2 ...] callback)');
		}

		let evaluatedAPICode;

		function doEval(apiCode){
			const or = require("overwrite-require");

			switch($$.environmentType){
				case or.constants.BROWSER_ENVIRONMENT_TYPE:
				case or.constants.WEB_WORKER_ENVIRONMENT_TYPE:
				case or.constants.SERVICE_WORKER_ENVIRONMENT_TYPE:
					apiCode = new TextDecoder("utf-8").decode(apiCode);
					break;
				default:
					apiCode = apiCode.toString();
			}
			apiCode = "let module = {exports: {}}\n" + apiCode + "\nmodule.exports";
			evaluatedAPICode = eval(apiCode);
		}

		function execute(){
			try{
				//before eval we need to convert from $$.Buffer/ArrayBuffer to String
				evaluatedAPICode[functionName].call(this, ...args, callback);
			}catch(err){
				return callback(createOpenDSUErrorWrapper(`Failed to  execute api.js code `, err));
			}
		}

		if(!evaluatedAPICode){
			archive.readFile("/code/api.js", function(err, apiCode){
				if(err){
					archive.readFile("/app/api.js", function(err, apiCode){
						if(err){
							return callback(createOpenDSUErrorWrapper(`Failed to  read file api.js in /code or /app`, err));
						} else {
							doEval(apiCode);
							execute();
						}
					});
				} else {
					doEval(apiCode);
					execute();
				}
			});
		} else {
			execute();
		}
	}
	return archive;
}

},{"overwrite-require":"overwrite-require"}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/key-ssi-resolver/lib/DSUFactoryRegistry/obsolete/ConsensusDSUFactory.js":[function(require,module,exports){
/**
 * @param {object} options
 * @param {KeySSIFactory} options.keySSIFactory
 * @param {BrickMapStrategyFactory} options.brickMapStrategyFactory
 */
function ConsensusDSUFactory(options) {
    options = options || {};
    this.barFactory = options.barFactory;

    /**
     * @param {object} options
     * @param {string} options.brickMapStrategy 'Diff', 'Versioned' or any strategy registered with the factory
     * @param {object} options.anchoringOptions Anchoring options to pass to bar map strategy
     * @param {callback} options.anchoringOptions.decisionFn Callback which will decide when to effectively anchor changes
     *                                                              If empty, the changes will be anchored after each operation
     * @param {callback} options.anchoringOptions.conflictResolutionFn Callback which will handle anchoring conflicts
     *                                                              The default strategy is to reload the BrickMap and then apply the new changes
     * @param {callback} options.anchoringOptions.anchoringEventListener An event listener which is called when the strategy anchors the changes
     * @param {callback} options.anchoringOptions.signingFn  A function which will sign the new alias
     * @param {object} options.validationRules
     * @param {object} options.validationRules.preWrite An object capable of validating operations done in the "preWrite" stage of the BrickMap
     * @param {callback} callback
     */
    this.create = (keySSI, options, callback) => {
        if (typeof options === 'function') {
            callback = options;
            options = undefined;
        }

        if (typeof options === "undefined") {
            options = {};
        }

        if(typeof options.useSSIAsIdentifier === "undefined" || !options.useSSIAsIdentifier){
            throw Error("Creating a DSU using keySSI from the ConsensusSSI family not allowed. Use the resolver.createDSUForExisting method instead.");
        }

        // enable options.validationRules.preWrite to stop content update
        this.barFactory.create(keySSI, options, callback);
    };

    /**
     * @param {string} keySSI
     * @param {object} options
     * @param {string} options.brickMapStrategy 'Diff', 'Versioned' or any strategy registered with the factory
     * @param {object} options.anchoringOptions Anchoring options to pass to bar map strategy
     * @param {callback} options.anchoringOptions.decisionFn Callback which will decide when to effectively anchor changes
     *                                                              If empty, the changes will be anchored after each operation
     * @param {callback} options.anchoringOptions.conflictResolutionFn Callback which will handle anchoring conflicts
     *                                                              The default strategy is to reload the BrickMap and then apply the new changes
     * @param {callback} options.anchoringOptions.anchoringEventListener An event listener which is called when the strategy anchors the changes
     * @param {callback} options.anchoringOptions.signingFn  A function which will sign the new alias
     * @param {object} options.validationRules
     * @param {object} options.validationRules.preWrite An object capable of validating operations done in the "preWrite" stage of the BrickMap
     * @param {callback} callback
     */
    this.load = (keySSI, options, callback) => {
        if (typeof options === 'function') {
            callback = options;
            options = {};
        }

        // enable options.validationRules.preWrite to stop content update
        this.barFactory.load(keySSI, options, callback);
    };
}

module.exports = ConsensusDSUFactory;

},{}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/key-ssi-resolver/lib/DSUFactoryRegistry/obsolete/OwnershipDSUFactory.js":[function(require,module,exports){
/**
 * @param {object} options
 * @param {KeySSIFactory} options.keySSIFactory
 * @param {BrickMapStrategyFactory} options.brickMapStrategyFactory
 */
function OwnershipDSUFactory(options) {
    options = options || {};
    this.barFactory = options.barFactory;

    /**
     * @param {object} options
     * @param {string} options.brickMapStrategy 'Diff', 'Versioned' or any strategy registered with the factory
     * @param {object} options.anchoringOptions Anchoring options to pass to bar map strategy
     * @param {callback} options.anchoringOptions.decisionFn Callback which will decide when to effectively anchor changes
     *                                                              If empty, the changes will be anchored after each operation
     * @param {callback} options.anchoringOptions.conflictResolutionFn Callback which will handle anchoring conflicts
     *                                                              The default strategy is to reload the BrickMap and then apply the new changes
     * @param {callback} options.anchoringOptions.anchoringEventListener An event listener which is called when the strategy anchors the changes
     * @param {callback} options.anchoringOptions.signingFn  A function which will sign the new alias
     * @param {object} options.validationRules
     * @param {object} options.validationRules.preWrite An object capable of validating operations done in the "preWrite" stage of the BrickMap
     * @param {callback} callback
     */
    this.create = (keySSI, options, callback) => {
        if (typeof options === 'function') {
            callback = options;
            options = undefined;
        }

        if (typeof options === "undefined") {
            options = {};
        }

        if(typeof options.useSSIAsIdentifier === "undefined" || !options.useSSIAsIdentifier){
            throw Error("Creating a DSU using keySSI from the OwnershipSSI family not allowed. Use the resolver.createDSUForExisting method instead.");
        }

        // enable options.validationRules.preWrite to stop content update
        this.barFactory.create(keySSI, options, callback);
    };

    /**
     * @param {string} keySSI
     * @param {object} options
     * @param {string} options.brickMapStrategy 'Diff', 'Versioned' or any strategy registered with the factory
     * @param {object} options.anchoringOptions Anchoring options to pass to bar map strategy
     * @param {callback} options.anchoringOptions.decisionFn Callback which will decide when to effectively anchor changes
     *                                                              If empty, the changes will be anchored after each operation
     * @param {callback} options.anchoringOptions.conflictResolutionFn Callback which will handle anchoring conflicts
     *                                                              The default strategy is to reload the BrickMap and then apply the new changes
     * @param {callback} options.anchoringOptions.anchoringEventListener An event listener which is called when the strategy anchors the changes
     * @param {callback} options.anchoringOptions.signingFn  A function which will sign the new alias
     * @param {object} options.validationRules
     * @param {object} options.validationRules.preWrite An object capable of validating operations done in the "preWrite" stage of the BrickMap
     * @param {callback} callback
     */
    this.load = (keySSI, options, callback) => {
        if (typeof options === 'function') {
            callback = options;
            options = {};
        }

        // enable options.validationRules.preWrite to stop content update
        this.barFactory.load(keySSI, options, callback);
    };
}

module.exports = OwnershipDSUFactory;

},{}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/key-ssi-resolver/lib/KeySSIResolver.js":[function(require,module,exports){
/**
 * @param {BrickMapStrategyFactory} options.brickMapStrategyFactory
 * @param {DSUFactory} options.dsuFactory
 */
function KeySSIResolver(options) {
    options = options || {};
    const brickMapStrategyFactory = options.brickMapStrategyFactory;

    const dsuFactory = options.dsuFactory;


    ////////////////////////////////////////////////////////////
    // Public methods
    ////////////////////////////////////////////////////////////

    /**
     * @param {SeedSSI} dsuRepresentation
     * @param {object} options
     * @param {string} options.brickMapStrategy 'Diff' or any strategy registered with the factory
     * @param {object} options.anchoringOptions Anchoring options to pass to bar map strategy
     * @param {callback} options.anchoringOptions.decisionFn A function which will decide when to effectively anchor changes
     *                                                              If empty, the changes will be anchored after each operation
     * @param {callback} options.anchoringOptions.conflictResolutionFn A function which will handle anchoring conflicts
     *                                                              The default strategy is to reload the BrickMap and then apply the new changes
     * @param {callback} options.anchoringOptions.anchoringEventListener An event listener which is called when the strategy anchors the changes
     * @param {callback} options.anchoringOptions.signingFn  A function which will sign the new alias
     * @param {object} options.validationRules
     * @param {object} options.validationRules.preWrite An object capable of validating operations done in the "preWrite" stage of the BrickMap
     * @param {callback} callback
     */
    this.createDSU = (keySSI, options, callback) => {
        if (typeof options === 'function') {
            callback = options;
            options = {};
        }

        dsuFactory.create(keySSI, options, callback);
    };

    /**
     * @param {string} keySSI
     * @param {object} options
     * @param {string} options.brickMapStrategy 'Diff', 'Versioned' or any strategy registered with the factory
     * @param {object} options.anchoringOptions Anchoring options to pass to bar map strategy
     * @param {callback} options.anchoringOptions.decisionFn A function which will decide when to effectively anchor changes
     *                                                              If empty, the changes will be anchored after each operation
     * @param {callback} options.anchoringOptions.conflictResolutionFn Callback which will handle anchoring conflicts
     *                                                              The default strategy is to reload the BrickMap and then apply the new changes
     * @param {callback} options.anchoringOptions.anchoringEventListener An event listener which is called when the strategy anchors the changes
     * @param {callback} options.anchoringOptions.signingFn  A function which will sign the new alias
     * @param {object} options.validationRules
     * @param {object} options.validationRules.preWrite An object capable of validating operations done in the "preWrite" stage of the BrickMap
     * @param {boolean} options.skipCache If `true` the DSU will skip caching when loading any mounted DSUs
     * @param {callback} callback
     */
    this.loadDSU = (keySSI, options, callback) => {
        if (typeof options === 'function') {
            callback = options;
            options = {};
        }
        if (!dsuFactory.isValidKeySSI(keySSI)) {
            let helpString;
            if(typeof keySSI === "string"){
                helpString = keySSI;
            } else {
                helpString = keySSI.getIdentifier(true);
            }
            return callback(new Error(`Invalid KeySSI: ${helpString}`));
        }
        dsuFactory.load(keySSI, options, callback);
    };

    /**
     * @return {DSUFactory}
     */
    this.getDSUFactory = () => {
        return dsuFactory;
    }

    /**
     * @return {BrickMapStrategyFactory}
     */
    this.getBrickMapStrategyFactory = () => {
        return brickMapStrategyFactory;
    }
}

module.exports = KeySSIResolver;

},{}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/key-ssi-resolver/lib/KeySSIs/ConstSSIs/ArraySSI.js":[function(require,module,exports){
function ArraySSI(enclave, identifier) {
    if (typeof enclave === "string") {
        identifier = enclave;
        enclave = undefined;
    }
    const SSITypes = require("../SSITypes");
    const SSIFamilies = require("../SSIFamilies");
    const KeySSIMixin = require("../KeySSIMixin");
    const cryptoRegistry = require("../../CryptoAlgorithms/CryptoAlgorithmsRegistry");

    KeySSIMixin(this, enclave);
    const self = this;

    if (typeof identifier !== "undefined") {
        self.autoLoad(identifier);
    }

    self.getTypeName = function () {
        return SSITypes.ARRAY_SSI;
    }

    self.initialize = (dlDomain, arr, vn, hint) => {
        if (typeof vn === "undefined") {
            vn = 'v0';
        }
        const key = cryptoRegistry.getKeyDerivationFunction(self)(arr.join(''), 1000);
        self.load(SSITypes.ARRAY_SSI, dlDomain, cryptoRegistry.getBase64EncodingFunction(self)(key), "", vn, hint);
    };

    self.deriveSync = () => {
        const ConstSSI = require("./ConstSSI");
        const constSSI = ConstSSI.createConstSSI();
        constSSI.load(SSITypes.CONST_SSI, self.getDLDomain(), self.getSpecificString(), self.getControlString(), self.getVn(), self.getHint());
        return constSSI;
    }

    self.derive = (callback) => {
        try {
            const constSSI = self.deriveSync();
            callback(undefined, constSSI)
        } catch (e) {
            callback(e);
        }
    };

    self.getEncryptionKeySync = () => {
        return self.deriveSync().getEncryptionKeySync();
    }

    self.getEncryptionKey = (callback) => {
        self.derive((err, derivedKeySSI) => {
            if (err) {
                return callback(err);
            }

            derivedKeySSI.getEncryptionKey(callback);
        });
    };

    self.createAnchorValue = function (brickMapHash, previousAnchorValue, callback) {
        if (typeof previousAnchorValue === "function") {
            callback = previousAnchorValue;
            previousAnchorValue = undefined;
        }
        try {
            const keySSIFactory = require("../KeySSIFactory");
            const hashLinkSSI = keySSIFactory.createType(SSITypes.HASH_LINK_SSI);
            hashLinkSSI.initialize(self.getBricksDomain(), brickMapHash, self.getVn(), self.getHint());
            callback(undefined, hashLinkSSI);
        } catch (e) {
            callback(e);
        }
    }

    self.canAppend = function () {
        return false;
    }

    self.getFamilyName = () => {
        return SSIFamilies.CONST_SSI_FAMILY;
    }
}

function createArraySSI(enclave, identifier) {
    return new ArraySSI(enclave, identifier);
}

module.exports = {
    createArraySSI
};

},{"../../CryptoAlgorithms/CryptoAlgorithmsRegistry":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/key-ssi-resolver/lib/CryptoAlgorithms/CryptoAlgorithmsRegistry.js","../KeySSIFactory":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/key-ssi-resolver/lib/KeySSIs/KeySSIFactory.js","../KeySSIMixin":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/key-ssi-resolver/lib/KeySSIs/KeySSIMixin.js","../SSIFamilies":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/key-ssi-resolver/lib/KeySSIs/SSIFamilies.js","../SSITypes":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/key-ssi-resolver/lib/KeySSIs/SSITypes.js","./ConstSSI":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/key-ssi-resolver/lib/KeySSIs/ConstSSIs/ConstSSI.js"}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/key-ssi-resolver/lib/KeySSIs/ConstSSIs/CZaSSI.js":[function(require,module,exports){
const KeySSIMixin = require("../KeySSIMixin");
const SSITypes = require("../SSITypes");
const SSIFamilies = require("../SSIFamilies");

function CZaSSI(enclave, identifier) {
    if (typeof enclave === "string") {
        identifier = enclave;
        enclave = undefined;
    }
    KeySSIMixin(this, enclave);
    const self = this;
    if (typeof identifier !== "undefined") {
        self.autoLoad(identifier);
    }

    self.getTypeName = function () {
        return SSITypes.CONSTANT_ZERO_ACCESS_SSI;
    }

    self.initialize = (dlDomain, hpk, vn, hint) => {
        self.load(SSITypes.CONSTANT_ZERO_ACCESS_SSI, dlDomain, '', hpk, vn, hint);
    };

    self.canAppend = function () {
        return false;
    }

    self.getFamilyName = () => {
        return SSIFamilies.CONST_SSI_FAMILY;
    }
}

function createCZaSSI(enclave, identifier) {
    return new CZaSSI(enclave, identifier);
}

module.exports = {
    createCZaSSI
};

},{"../KeySSIMixin":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/key-ssi-resolver/lib/KeySSIs/KeySSIMixin.js","../SSIFamilies":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/key-ssi-resolver/lib/KeySSIs/SSIFamilies.js","../SSITypes":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/key-ssi-resolver/lib/KeySSIs/SSITypes.js"}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/key-ssi-resolver/lib/KeySSIs/ConstSSIs/ConstSSI.js":[function(require,module,exports){
const KeySSIMixin = require("../KeySSIMixin");
const CZaSSI = require("./CZaSSI");
const SSITypes = require("../SSITypes");
const cryptoRegistry = require("../../CryptoAlgorithms/CryptoAlgorithmsRegistry");
const SSIFamilies = require("../SSIFamilies");

function ConstSSI(enclave, identifier) {
    if (typeof enclave === "string") {
        identifier = enclave;
        enclave = undefined;
    }
    KeySSIMixin(this, enclave);
    const self = this;
    if (typeof identifier !== "undefined") {
        self.autoLoad(identifier);
    }

    self.getTypeName = function () {
        return SSITypes.CONST_SSI;
    }

    self.initialize = (dlDomain, constString, vn, hint) => {
        const key = cryptoRegistry.getKeyDerivationFunction(self)(constString, 1000);
        self.load(SSITypes.CONST_SSI, dlDomain, cryptoRegistry.getBase64EncodingFunction(self)(key), "", vn, hint);
    };

    self.getEncryptionKeySync = () => {
        const encryptionKey = cryptoRegistry.getBase64DecodingFunction(self)(self.getSpecificString());
        return encryptionKey;
    }

    self.getEncryptionKey = (callback) => {
        try {
            const encryptionKey = self.getEncryptionKeySync();
            return callback(undefined, encryptionKey);
        } catch (e) {
            return callback(e);
        }
    };

    self.deriveSync = () => {
        const cZaSSI = CZaSSI.createCZaSSI();
        const encryptionKey = self.getEncryptionKeySync();
        const subtypeKey = cryptoRegistry.getHashFunction(self)(encryptionKey);
        cZaSSI.load(SSITypes.CONSTANT_ZERO_ACCESS_SSI, self.getDLDomain(), subtypeKey, self.getControlString(), self.getVn(), self.getHint());
        return cZaSSI;
    }

    self.derive = (callback) => {
        try {
            const cZaSSI = self.deriveSync();
            return callback(undefined, cZaSSI);
        } catch (e) {
            return callback(e);
        }
    };

    self.createAnchorValue = function (brickMapHash, previousAnchorValue, callback) {
        if (typeof previousAnchorValue === "function") {
            callback = previousAnchorValue;
            previousAnchorValue = undefined;
        }
        try {
            const keySSIFactory = require("../KeySSIFactory");
            const hashLinkSSI = keySSIFactory.createType(SSITypes.HASH_LINK_SSI);
            hashLinkSSI.initialize(self.getBricksDomain(), brickMapHash, self.getVn(), self.getHint());
            callback(undefined, hashLinkSSI);
        } catch (e) {
            return callback(e);
        }
    }

    self.canAppend = function () {
        return false;
    }

    self.getFamilyName = () => {
        return SSIFamilies.CONST_SSI_FAMILY;
    }
}

function createConstSSI(enclave, identifier) {
    return new ConstSSI(enclave, identifier);
}

module.exports = {
    createConstSSI
};

},{"../../CryptoAlgorithms/CryptoAlgorithmsRegistry":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/key-ssi-resolver/lib/CryptoAlgorithms/CryptoAlgorithmsRegistry.js","../KeySSIFactory":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/key-ssi-resolver/lib/KeySSIs/KeySSIFactory.js","../KeySSIMixin":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/key-ssi-resolver/lib/KeySSIs/KeySSIMixin.js","../SSIFamilies":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/key-ssi-resolver/lib/KeySSIs/SSIFamilies.js","../SSITypes":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/key-ssi-resolver/lib/KeySSIs/SSITypes.js","./CZaSSI":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/key-ssi-resolver/lib/KeySSIs/ConstSSIs/CZaSSI.js"}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/key-ssi-resolver/lib/KeySSIs/ConstSSIs/PasswordSSI.js":[function(require,module,exports){
const KeySSIMixin = require("../KeySSIMixin");
const ConstSSI = require("./ConstSSI");
const SSITypes = require("../SSITypes");
const cryptoRegistry = require("../../CryptoAlgorithms/CryptoAlgorithmsRegistry");

function PasswordSSI(enclave, identifier){
    if (typeof enclave === "string") {
        identifier = enclave;
        enclave = undefined;
    }
    KeySSIMixin(this, enclave);
    const self = this;

    if (typeof identifier !== "undefined") {
        self.autoLoad(identifier);
    }

    self.initialize = (dlDomain, context, password, kdfOptions, vn, hint) => {
        const subtypeSpecificString = cryptoRegistry.getKeyDerivationFunction(self)(context + password, kdfOptions);
        self.load(SSITypes.PASSWORD_SSI, dlDomain, subtypeSpecificString, '', vn, hint);
    };

    self.derive = (callback) => {
        const constSSI = ConstSSI.createConstSSI();
        constSSI.load(SSITypes.CONST_SSI, self.getDLDomain(), self.getSpecificString(), self.getControlString(), self.getVn(), self.getHint());
        callback(constSSI);
    };

    self.getEncryptionKey = (callback) => {
        self.derive((err, constSSI)=>{
            if (err) {
                return callback(err);
            }

            constSSI.getEncryptionKey(callback);
        })
    };
}

function createPasswordSSI(enclave, identifier) {
    return new PasswordSSI(enclave, identifier);
}

module.exports = {
    createPasswordSSI
};

},{"../../CryptoAlgorithms/CryptoAlgorithmsRegistry":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/key-ssi-resolver/lib/CryptoAlgorithms/CryptoAlgorithmsRegistry.js","../KeySSIMixin":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/key-ssi-resolver/lib/KeySSIs/KeySSIMixin.js","../SSITypes":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/key-ssi-resolver/lib/KeySSIs/SSITypes.js","./ConstSSI":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/key-ssi-resolver/lib/KeySSIs/ConstSSIs/ConstSSI.js"}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/key-ssi-resolver/lib/KeySSIs/ContractSSIs/ConsensusSSI.js":[function(require,module,exports){
const KeySSIMixin = require("../KeySSIMixin");
const SSITypes = require("../SSITypes");

function ConsensusSSI(identifier) {
    KeySSIMixin(this);
    const self = this;

    if (typeof identifier !== "undefined") {
        self.autoLoad(identifier);
    }

    self.initialize = (dlDomain, contractName, vn, hint) => {
        self.load(SSITypes.CONSENSUS_SSI, dlDomain, contractName, undefined, vn, hint);
    };
}

function createConsensusSSI(identifier) {
    return new ConsensusSSI(identifier);
}

module.exports = {
    createConsensusSSI,
};

},{"../KeySSIMixin":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/key-ssi-resolver/lib/KeySSIs/KeySSIMixin.js","../SSITypes":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/key-ssi-resolver/lib/KeySSIs/SSITypes.js"}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/key-ssi-resolver/lib/KeySSIs/DSURepresentationNames.js":[function(require,module,exports){
const DSURepresentationNames = {
    "seed": "RawDossier"
}

module.exports = DSURepresentationNames;
},{}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/key-ssi-resolver/lib/KeySSIs/HashLinkSSIs/HashLinkSSI.js":[function(require,module,exports){
const KeySSIMixin = require("../KeySSIMixin");
const SSITypes = require("../SSITypes");
const SSIFamilies = require("../SSIFamilies");

function HashLinkSSI(enclave, identifier) {
    if (typeof enclave === "string") {
        identifier = enclave;
        enclave = undefined;
    }
    KeySSIMixin(this, enclave);
    const self = this;

    if (typeof identifier !== "undefined") {
        self.autoLoad(identifier);
    }

    self.getTypeName = function () {
        return SSITypes.HASH_LINK_SSI;
    }

    self.initialize = (dlDomain, hash, vn, hint) => {
        self.load(SSITypes.HASH_LINK_SSI, dlDomain, hash, '', vn, hint);
    };

    self.getHash = () => {
        const specificString = self.getSpecificString();
        if (typeof specificString !== "string") {
            console.trace("Specific string is not string", specificString.toString());
        }
        return specificString;
    };

    self.getFamilyName = () => {
        return SSIFamilies.HASH_LINK_SSI_FAMILY;
    }
}

function createHashLinkSSI(enclave, identifier) {
    return new HashLinkSSI(enclave, identifier);
}

module.exports = {
    createHashLinkSSI
};

},{"../KeySSIMixin":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/key-ssi-resolver/lib/KeySSIs/KeySSIMixin.js","../SSIFamilies":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/key-ssi-resolver/lib/KeySSIs/SSIFamilies.js","../SSITypes":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/key-ssi-resolver/lib/KeySSIs/SSITypes.js"}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/key-ssi-resolver/lib/KeySSIs/HashLinkSSIs/SignedHashLinkSSI.js":[function(require,module,exports){
const KeySSIMixin = require("../KeySSIMixin");
const {createHashLinkSSI} = require("./HashLinkSSI");
const SSITypes = require("../SSITypes");
const cryptoRegistry = require("../../CryptoAlgorithms/CryptoAlgorithmsRegistry");
const SSIFamilies = require("../SSIFamilies");

function SignedHashLinkSSI(enclave, identifier) {
    if (typeof enclave === "string") {
        identifier = enclave;
        enclave = undefined;
    }
    const SEPARATOR = "|";
    KeySSIMixin(this, enclave);
    const self = this;

    if (typeof identifier !== "undefined") {
        self.autoLoad(identifier);
    }

    self.getTypeName = function () {
        return SSITypes.SIGNED_HASH_LINK_SSI;
    }

    self.initialize = (dlDomain, hash, timestamp, signature, vn, hint) => {
        self.load(SSITypes.SIGNED_HASH_LINK_SSI, dlDomain, hash, `${timestamp}${SEPARATOR}${signature}`, vn, hint);
    };

    self.canBeVerified = () => {
        return true;
    };

    self.getHash = () => {
        const specificString = self.getSpecificString();
        if (typeof specificString !== "string") {
            console.trace("Specific string is not string", specificString.toString());
        }
        return specificString;
    };


    self.deriveSync = () => {
        const hashLinkSSI = createHashLinkSSI();
        hashLinkSSI.load(SSITypes.HASH_LINK_SSI, self.getDLDomain(), self.getHash(), "", self.getVn(), self.getHint());
        return hashLinkSSI;
    };


    self.derive = (callback) => {
        try {
            const hashLinkSSI = self.deriveSync();
            callback(undefined, hashLinkSSI);
        }catch (e) {
            return callback(e);
        }
    };

    self.getTimestamp = function () {
        let control = self.getControlString();
        return control.split(SEPARATOR)[0];
    }

    self.getSignature = function (encoding) {
        if (typeof encoding === "undefined") {
            encoding = "base64";
        }
        let control = self.getControlString();
        let splitControl = control.split(SEPARATOR);
        let signature = splitControl[1];
        if (encoding === "raw") {
            const base64Decode = cryptoRegistry.getBase64DecodingFunction(self);
            return base64Decode(signature);
        }

        return signature;
    }

    self.getDataToSign = function (anchorSSI, previousAnchorValue) {
        const keySSIFactory = require("../KeySSIFactory");

        if (typeof anchorSSI === "string") {
            anchorSSI = keySSIFactory.create(anchorSSI);
        }

        if (typeof previousAnchorValue === "string") {
            previousAnchorValue = keySSIFactory.create(previousAnchorValue);
        }

        let previousIdentifier = '';
        const timestamp = self.getTimestamp();
        if (previousAnchorValue) {
            previousIdentifier = previousAnchorValue.getIdentifier(true);
        }
        return anchorSSI.getIdentifier(true) + self.getSpecificString() + previousIdentifier + timestamp;
    }

    self.getFamilyName = () => {
        return SSIFamilies.HASH_LINK_SSI_FAMILY;
    }
}

function createSignedHashLinkSSI(enclave, identifier) {
    return new SignedHashLinkSSI(enclave, identifier);
}

module.exports = {
    createSignedHashLinkSSI
};

},{"../../CryptoAlgorithms/CryptoAlgorithmsRegistry":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/key-ssi-resolver/lib/CryptoAlgorithms/CryptoAlgorithmsRegistry.js","../KeySSIFactory":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/key-ssi-resolver/lib/KeySSIs/KeySSIFactory.js","../KeySSIMixin":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/key-ssi-resolver/lib/KeySSIs/KeySSIMixin.js","../SSIFamilies":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/key-ssi-resolver/lib/KeySSIs/SSIFamilies.js","../SSITypes":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/key-ssi-resolver/lib/KeySSIs/SSITypes.js","./HashLinkSSI":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/key-ssi-resolver/lib/KeySSIs/HashLinkSSIs/HashLinkSSI.js"}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/key-ssi-resolver/lib/KeySSIs/Hint.js":[function(require,module,exports){
const constants = require("./constants");

function Hint(hintSerialisation) {
    const {BRICKS_DOMAIN_KEY} = require('opendsu').constants;
    let _hintObject;

    const init = () => {
        if (hintSerialisation) {
            if (typeof hintSerialisation === "object") {
                _hintObject = hintSerialisation;
            } else {
                try {
                    _hintObject = JSON.parse(hintSerialisation);
                } catch (e) {
                    throw Error(`Hint should be a JSON. Received <${hintSerialisation}>`);
                }
            }
        }
    }

    this.set = (key, value) => {
        if (typeof _hintObject === "undefined") {
            _hintObject = {};
        }

        _hintObject[key] = value;
    }

    this.get = (key) => {
        return _hintObject[key];
    }

    this.setDSUVersion = (dsuVersion) => {
        this.set(constants.DSU_VERSION_KEY, dsuVersion);
    }

    this.getDSUVersion = () => {
        return this.get(constants.DSU_VERSION_KEY);
    }

    this.setBricksDomain = (bricksDomain) => {
        this.set(BRICKS_DOMAIN_KEY, bricksDomain);
    };

    this.getBricksDomain = () => {
        return this.get(BRICKS_DOMAIN_KEY);
    };

    this.setEmbeddedData = (embeddedData) => {
        this.set(constants.EMBEDDED_DATA_KEY, embeddedData);
    }

    this.getEmbeddedData = () => {
        return this.get(constants.EMBEDDED_DATA_KEY);
    }

    this.getSerialisation = () => {
        if (typeof _hintObject === "undefined") {
            return undefined;
        }

        let versionFreeHint = JSON.parse(JSON.stringify(_hintObject));
        if (typeof versionFreeHint[constants.DSU_VERSION_KEY] !== "undefined") {
            delete versionFreeHint[constants.DSU_VERSION_KEY];
        }

        return JSON.stringify(versionFreeHint);
    }

    init();
}

module.exports = Hint;

},{"./constants":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/key-ssi-resolver/lib/KeySSIs/constants.js","opendsu":"opendsu"}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/key-ssi-resolver/lib/KeySSIs/KeySSIFactory.js":[function(require,module,exports){
const createSecretSSI = require("./SecretSSIs/SecretSSI").createSecretSSI;
const createAnchorSSI = require("./SecretSSIs/AnchorSSI").createAnchorSSI;
const createReadSSI = require("./SecretSSIs/ReadSSI").createReadSSI;
const createPublicSSI = require("./SecretSSIs/PublicSSI").createPublicSSI;
const createZaSSI = require("./SecretSSIs/ZaSSI").createZaSSI;

const createPathKeySSI = require("./SeedSSIs/PathKeySSI").createPathKeySSI;
const createSeedSSI = require("./SeedSSIs/SeedSSI").createSeedSSI;
const createSReadSSI = require("./SeedSSIs/SReadSSI").createSReadSSI;
const createSZaSSI = require("./SeedSSIs/SZaSSI").createSZaSSI;

const createWalletSSI = require("./OtherKeySSIs/WalletSSI").createWalletSSI;
const createPasswordSSI = require("./ConstSSIs/PasswordSSI").createPasswordSSI;
const createArraySSI = require("./ConstSSIs/ArraySSI").createArraySSI;
const createConstSSI = require("./ConstSSIs/ConstSSI").createConstSSI;
const createCZaSSI = require("./ConstSSIs/CZaSSI").createCZaSSI;
const createHashLinkSSI = require("./HashLinkSSIs/HashLinkSSI").createHashLinkSSI;
const createSymmetricalEncryptionSSI = require("./OtherKeySSIs/SymmetricalEncryptionSSI").createSymmetricalEncryptionSSI;

const createTokenSSI = require("./TokenSSIs/TokenSSI").createTokenSSI;
const createOwnershipSSI = require("./OwnershipSSIs/OwnershipSSI").createOwnershipSSI;
const createOReadSSI = require("./OwnershipSSIs/OReadSSI").createOReadSSI;
const createZATSSI = require("./OwnershipSSIs/ZATSSI").createZATSSI;
const createTransferSSI = require("./TransferSSIs/TransferSSI").createTransferSSI;
const createSignedHashLinkSSI = require("./HashLinkSSIs/SignedHashLinkSSI").createSignedHashLinkSSI;

const createConsensusSSI = require("./ContractSSIs/ConsensusSSI").createConsensusSSI;
const createPublicKeySSI = require("./OtherKeySSIs/PublicKeySSI").createPublicKeySSI;

const createAliasSSI = require("./OtherKeySSIs/AliasSSI").createAliasSSI;
const createEmbedSSI = require("./OtherKeySSIs/EmbedSSI").createEmbedSSI;

const createSizeSSI = require("./OtherKeySSIs/SizeSSI").createSizeSSI;

const createVersionlessSSI = require("./OtherKeySSIs/VersionlessSSI").createVersionlessSSI;

const SSITypes = require("./SSITypes");

const registry = {};

function KeySSIFactory() {
}

KeySSIFactory.prototype.registerFactory = (typeName, vn, derivedType, functionFactory) => {
    if (typeof derivedType === "function") {
        functionFactory = derivedType;
        derivedType = undefined;
    }

    if (typeof registry[typeName] !== "undefined") {
        throw Error(`A function factory for KeySSI of type ${typeName} is already registered.`);
    }

    registry[typeName] = {derivedType, functionFactory};
};

KeySSIFactory.prototype.create = (enclave, identifier, options) => {
    if (typeof enclave === "string") {
        identifier = enclave;
        enclave = undefined;
    }

    if (typeof identifier === "undefined") {
        throw Error("An SSI should be provided");
    }

    const KeySSIMixin = require("./KeySSIMixin");
    let keySSI = {}
    KeySSIMixin(keySSI, enclave);

    try {
        keySSI.autoLoad(identifier);
    } catch (e) {
        throw createOpenDSUErrorWrapper(`Invalid format for keySSI ${identifier}`, e);
    }

    const typeName = keySSI.getTypeName();

    return KeySSIFactory.prototype.createByType(typeName, enclave, identifier, options);
};

KeySSIFactory.prototype.createByType = (typeName, enclave, identifier, options) => {
    if (typeof enclave === "string") {
        identifier = enclave;
        enclave = undefined;
    }

    if (typeof identifier === "undefined") {
        throw Error("An SSI should be provided");
    }

    if (typeof registry[typeName] === "undefined") {
        throw Error(`The type ${typeName} is not a registered KeySSI type`);
    }
    const keySSI = registry[typeName].functionFactory(enclave, identifier);
    keySSI.options = options;
    return keySSI;
};

KeySSIFactory.prototype.createType = (typeName, enclave) => {
    return registry[typeName].functionFactory(enclave);
}

KeySSIFactory.prototype.getDerivedType = (keySSI, otherType, callback) => {
    if (keySSI.getTypeName() === otherType) {
        return callback(undefined, keySSI);
    }
    let currentEntry = registry[otherType];
    if (typeof currentEntry === "undefined") {
        return callback(Error(`${otherType} is not a registered KeySSI type.`))
    }

    while (typeof currentEntry.derivedType !== "undefined") {
        if (currentEntry.derivedType === keySSI.getTypeName()) {
            return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`${otherType} is not derived from ${keySSI.getTypeName()}`));
        }
        currentEntry = registry[currentEntry.derivedType];
    }

    getDerivedKeySSI(keySSI, otherType, callback);
};

KeySSIFactory.prototype.getRelatedType = (keySSI, otherType, callback) => {
    console.log(".getRelatedType function is obsolete. Use .getDerivedType instead.");
    KeySSIFactory.prototype.getDerivedType(keySSI, otherType, callback);
}

KeySSIFactory.prototype.getAnchorType = (keySSI, callback) => {
    const __getAnchorTypeRecursively = (currentKeySSI) => {
        if (typeof registry[currentKeySSI.getTypeName()].derivedType === "undefined") {
            return callback(undefined, currentKeySSI);
        }

        currentKeySSI.derive((err, derivedKeySSI) => {
            if (err) {
                return callback(err);
            }

            __getAnchorTypeRecursively(derivedKeySSI);
        })
    }

    try {
        __getAnchorTypeRecursively(keySSI);
    } catch (e) {
        return callback(e);
    }
};

KeySSIFactory.prototype.getAnchorTypeSync = (keySSI) => {
    let localKeySSI = keySSI;
    while (typeof registry[localKeySSI.getTypeName()].derivedType !== "undefined") {
        localKeySSI = localKeySSI.deriveSync();
    }
    return localKeySSI;
};

KeySSIFactory.prototype.getRootKeySSITypeName = (keySSI) => {
    if (typeof keySSI === "object") {
        return KeySSIFactory.prototype.getRootKeySSITypeName(keySSI.getTypeName())
    } else if (typeof keySSI === "string") {
        let found = 0
        for (let parentKey in registry) {
            if (registry[parentKey].derivedType === keySSI) {
                found++
                return KeySSIFactory.prototype.getRootKeySSITypeName(parentKey)
            }
        }

        if (!found || found > 1) {
            return typeof keySSI === "object" ? keySSI.getTypeName() : keySSI
        }
    } else {
        return false
    }
}

const getDerivedKeySSI = (keySSI, derivedTypeName, callback) => {

    const __getDerivedKeySSIRecursively = (currentKeySSI) => {
        let currentEntry = registry[currentKeySSI.getTypeName()];
        if (typeof currentEntry.derivedType === "undefined") {
            return callback(Error(`${derivedTypeName} is not a valid KeySSI Type`));
        }

        if (currentEntry.derivedType === derivedTypeName) {
            return currentKeySSI.derive(callback);
        }

        currentKeySSI.derive((err, derivedKeySSI) => {
            if (err) {
                return callback(err);
            }

            __getDerivedKeySSIRecursively(derivedKeySSI);
        })
    }

    try {
        __getDerivedKeySSIRecursively(keySSI);
    } catch (e) {
        return callback(e);
    }
};

KeySSIFactory.prototype.registerFactory(SSITypes.SECRET_SSI, 'v0', SSITypes.ANCHOR_SSI, createSecretSSI);
KeySSIFactory.prototype.registerFactory(SSITypes.ANCHOR_SSI, 'v0', SSITypes.READ_SSI, createAnchorSSI);
KeySSIFactory.prototype.registerFactory(SSITypes.READ_SSI, 'v0', SSITypes.PUBLIC_SSI, createReadSSI);
KeySSIFactory.prototype.registerFactory(SSITypes.PUBLIC_SSI, 'v0', SSITypes.ZERO_ACCESS_SSI, createPublicSSI);
KeySSIFactory.prototype.registerFactory(SSITypes.ZERO_ACCESS_SSI, 'v0', undefined, createZaSSI);
KeySSIFactory.prototype.registerFactory(SSITypes.PATH_SSI, 'v0', SSITypes.PATH_SSI, createPathKeySSI);
KeySSIFactory.prototype.registerFactory(SSITypes.SEED_SSI, 'v0', SSITypes.SREAD_SSI, createSeedSSI);
KeySSIFactory.prototype.registerFactory(SSITypes.WALLET_SSI, 'v0', SSITypes.CONST_SSI, createWalletSSI);
KeySSIFactory.prototype.registerFactory(SSITypes.SREAD_SSI, 'v0', SSITypes.SZERO_ACCESS_SSI, createSReadSSI);
KeySSIFactory.prototype.registerFactory(SSITypes.SZERO_ACCESS_SSI, 'v0', undefined, createSZaSSI);
KeySSIFactory.prototype.registerFactory(SSITypes.PASSWORD_SSI, 'v0', SSITypes.CONST_SSI, createPasswordSSI);
KeySSIFactory.prototype.registerFactory(SSITypes.ARRAY_SSI, 'v0', SSITypes.CONST_SSI, createArraySSI);
KeySSIFactory.prototype.registerFactory(SSITypes.CONST_SSI, 'v0', SSITypes.CONSTANT_ZERO_ACCESS_SSI, createConstSSI);
KeySSIFactory.prototype.registerFactory(SSITypes.CONSTANT_ZERO_ACCESS_SSI, 'v0', undefined, createCZaSSI);
KeySSIFactory.prototype.registerFactory(SSITypes.HASH_LINK_SSI, 'v0', undefined, createHashLinkSSI);
KeySSIFactory.prototype.registerFactory(SSITypes.SYMMETRICAL_ENCRYPTION_SSI, 'v0', undefined, createSymmetricalEncryptionSSI);

KeySSIFactory.prototype.registerFactory(SSITypes.TOKEN_SSI, 'v0', undefined, createTokenSSI);
KeySSIFactory.prototype.registerFactory(SSITypes.OWNERSHIP_SSI, 'v0', SSITypes.OWNERSHIP_READ_SSI, createOwnershipSSI);
KeySSIFactory.prototype.registerFactory(SSITypes.OWNERSHIP_READ_SSI, 'v0', SSITypes.ZERO_ACCESS_TOKEN_SSI, createOReadSSI);
KeySSIFactory.prototype.registerFactory(SSITypes.ZERO_ACCESS_TOKEN_SSI, 'v0', undefined, createZATSSI);
KeySSIFactory.prototype.registerFactory(SSITypes.TRANSFER_SSI, 'v0', undefined, createTransferSSI);
KeySSIFactory.prototype.registerFactory(SSITypes.SIGNED_HASH_LINK_SSI, 'v0', SSITypes.HASH_LINK_SSI, createSignedHashLinkSSI);

KeySSIFactory.prototype.registerFactory(SSITypes.CONSENSUS_SSI, 'v0', undefined, createConsensusSSI);
KeySSIFactory.prototype.registerFactory(SSITypes.PUBLIC_KEY_SSI, 'v0', undefined, createPublicKeySSI);

KeySSIFactory.prototype.registerFactory(SSITypes.ALIAS_SSI, 'v0', undefined, createAliasSSI);
KeySSIFactory.prototype.registerFactory(SSITypes.EMBED_SSI, 'v0', undefined, createEmbedSSI);

KeySSIFactory.prototype.registerFactory(SSITypes.SIZE_SSI, 'v0', undefined, createSizeSSI);

KeySSIFactory.prototype.registerFactory(SSITypes.VERSIONLESS_SSI, 'v0', undefined, createVersionlessSSI);

module.exports = new KeySSIFactory();

},{"./ConstSSIs/ArraySSI":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/key-ssi-resolver/lib/KeySSIs/ConstSSIs/ArraySSI.js","./ConstSSIs/CZaSSI":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/key-ssi-resolver/lib/KeySSIs/ConstSSIs/CZaSSI.js","./ConstSSIs/ConstSSI":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/key-ssi-resolver/lib/KeySSIs/ConstSSIs/ConstSSI.js","./ConstSSIs/PasswordSSI":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/key-ssi-resolver/lib/KeySSIs/ConstSSIs/PasswordSSI.js","./ContractSSIs/ConsensusSSI":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/key-ssi-resolver/lib/KeySSIs/ContractSSIs/ConsensusSSI.js","./HashLinkSSIs/HashLinkSSI":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/key-ssi-resolver/lib/KeySSIs/HashLinkSSIs/HashLinkSSI.js","./HashLinkSSIs/SignedHashLinkSSI":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/key-ssi-resolver/lib/KeySSIs/HashLinkSSIs/SignedHashLinkSSI.js","./KeySSIMixin":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/key-ssi-resolver/lib/KeySSIs/KeySSIMixin.js","./OtherKeySSIs/AliasSSI":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/key-ssi-resolver/lib/KeySSIs/OtherKeySSIs/AliasSSI.js","./OtherKeySSIs/EmbedSSI":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/key-ssi-resolver/lib/KeySSIs/OtherKeySSIs/EmbedSSI.js","./OtherKeySSIs/PublicKeySSI":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/key-ssi-resolver/lib/KeySSIs/OtherKeySSIs/PublicKeySSI.js","./OtherKeySSIs/SizeSSI":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/key-ssi-resolver/lib/KeySSIs/OtherKeySSIs/SizeSSI.js","./OtherKeySSIs/SymmetricalEncryptionSSI":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/key-ssi-resolver/lib/KeySSIs/OtherKeySSIs/SymmetricalEncryptionSSI.js","./OtherKeySSIs/VersionlessSSI":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/key-ssi-resolver/lib/KeySSIs/OtherKeySSIs/VersionlessSSI.js","./OtherKeySSIs/WalletSSI":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/key-ssi-resolver/lib/KeySSIs/OtherKeySSIs/WalletSSI.js","./OwnershipSSIs/OReadSSI":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/key-ssi-resolver/lib/KeySSIs/OwnershipSSIs/OReadSSI.js","./OwnershipSSIs/OwnershipSSI":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/key-ssi-resolver/lib/KeySSIs/OwnershipSSIs/OwnershipSSI.js","./OwnershipSSIs/ZATSSI":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/key-ssi-resolver/lib/KeySSIs/OwnershipSSIs/ZATSSI.js","./SSITypes":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/key-ssi-resolver/lib/KeySSIs/SSITypes.js","./SecretSSIs/AnchorSSI":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/key-ssi-resolver/lib/KeySSIs/SecretSSIs/AnchorSSI.js","./SecretSSIs/PublicSSI":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/key-ssi-resolver/lib/KeySSIs/SecretSSIs/PublicSSI.js","./SecretSSIs/ReadSSI":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/key-ssi-resolver/lib/KeySSIs/SecretSSIs/ReadSSI.js","./SecretSSIs/SecretSSI":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/key-ssi-resolver/lib/KeySSIs/SecretSSIs/SecretSSI.js","./SecretSSIs/ZaSSI":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/key-ssi-resolver/lib/KeySSIs/SecretSSIs/ZaSSI.js","./SeedSSIs/PathKeySSI":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/key-ssi-resolver/lib/KeySSIs/SeedSSIs/PathKeySSI.js","./SeedSSIs/SReadSSI":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/key-ssi-resolver/lib/KeySSIs/SeedSSIs/SReadSSI.js","./SeedSSIs/SZaSSI":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/key-ssi-resolver/lib/KeySSIs/SeedSSIs/SZaSSI.js","./SeedSSIs/SeedSSI":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/key-ssi-resolver/lib/KeySSIs/SeedSSIs/SeedSSI.js","./TokenSSIs/TokenSSI":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/key-ssi-resolver/lib/KeySSIs/TokenSSIs/TokenSSI.js","./TransferSSIs/TransferSSI":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/key-ssi-resolver/lib/KeySSIs/TransferSSIs/TransferSSI.js"}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/key-ssi-resolver/lib/KeySSIs/KeySSIMixin.js":[function(require,module,exports){
const cryptoRegistry = require("../CryptoAlgorithms/CryptoAlgorithmsRegistry");
const pskCrypto = require("pskcrypto");
const SSITypes = require("./SSITypes");
const Hint = require("./Hint");
const MAX_KEYSSI_LENGTH = 2048

function keySSIMixin(target, enclave) {
    let _prefix = "ssi";
    let _subtype;
    let _dlDomain;
    let _subtypeSpecificString;
    let _controlString;
    let _vn = "v0";
    let _hint;
    let _canSign = false;

    const _createHint = (hintSerialisation) => {
        if (_hint instanceof Hint) {
            return;
        }

        _hint = new Hint(hintSerialisation);
    }

    target.autoLoad = function (identifier) {
        if (typeof identifier === "undefined") {
            return;
        }

        if (typeof identifier !== "string") {
            throw new Error("The identifier should be string");
        }

        target.validateKeySSICharLength();

        let originalId = identifier;
        if (identifier.indexOf(":") === -1) {
            identifier = pskCrypto.pskBase58Decode(identifier).toString();
        }

        if (identifier.indexOf(":") === -1) {
            throw new Error(`Wrong format of SSI. ${originalId} ${identifier}`);
        }

        let segments = identifier.split(":");
        segments.shift();
        _subtype = segments.shift();
        _dlDomain = segments.shift();
        _subtypeSpecificString = segments.shift();
        _controlString = segments.shift();
        let version = segments.shift();
        if (version !== '') {
            _vn = version;
        }
        if (segments.length > 0) {
            _hint = segments.join(":");
            _createHint(_hint);
        }

        // _subtypeSpecificString = cryptoRegistry.getDecodingFunction(target)(_subtypeSpecificString);
    }

    target.validateKeySSICharLength = () => {
        if (target.getIdentifier() > MAX_KEYSSI_LENGTH) {
            throw new Error(`The identifier length exceed maximum char length ${MAX_KEYSSI_LENGTH}`);
        }
    }

    target.load = function (subtype, dlDomain, subtypeSpecificString, control, vn, hint) {
        _subtype = subtype;
        _dlDomain = dlDomain;
        _subtypeSpecificString = subtypeSpecificString;
        _controlString = control || '';
        _vn = vn || "v0";
        _hint = hint;

        if (_hint) {
            _createHint(_hint)
        }
        target.validateKeySSICharLength();
    }

    /**
     *
     * @param ssiType - string
     * @param callback - function
     */
    target.getDerivedType = function (ssiType, callback) {
        const KeySSIFactory = require("./KeySSIFactory");
        KeySSIFactory.getDerivedType(target, ssiType, callback);
    }

    target.getRelatedType = function (ssiType, callback) {
        console.log(".getRelatedType function is obsolete. Use .getDerivedType instead.");
        target.getDerivedType(ssiType, callback);
    }

    target.getRootKeySSITypeName = function () {
        const KeySSIFactory = require("./KeySSIFactory");
        return KeySSIFactory.getRootKeySSITypeName(target);
    }

    target.getAnchorIdAsync = function (plain) {
        return new Promise((resolve, reject) => {
            if (typeof plain === "undefined") {
                plain = false;
            }
            target.getAnchorId(plain, (err, anchorId) => {
                if (err) {
                    return reject(err);
                }
                resolve(anchorId);
            })
        });
    }

    target.getAnchorIdSync = (plain) => {
        const keySSIFactory = require("./KeySSIFactory");
        return keySSIFactory.getAnchorTypeSync(target).getNoHintIdentifier(plain);
    }

    target.getAnchorId = function (plain, callback) {
        if (typeof plain === "function") {
            callback = plain;
            plain = false;
        }
        const keySSIFactory = require("./KeySSIFactory");
        keySSIFactory.getAnchorType(target, (err, anchorSSI) => {
            if (err) {
                return callback(err);
            }

            callback(undefined, anchorSSI.getNoHintIdentifier(plain));
        })
    }

    target.getSpecificString = function () {
        return _subtypeSpecificString;
    }

    target.getName = function () {
        console.trace("Obsolete function. Replace with getTypeName");
        return _subtype;
    }

    target.getTypeName = function () {
        return _subtype;
    }

    target.getDLDomain = function () {
        if (_dlDomain === '' || typeof _dlDomain === "undefined") {
            return undefined;
        }

        if (_dlDomain.startsWith("$")) {
            return process.env[_dlDomain.slice(1)];
        }

        return _dlDomain;
    }

    target.getControlString = function () {
        return _controlString || '';
    }

    target.getHint = function () {
        return _hint;
    }

    target.getVn = function () {
        return _vn;
    }

    target.getDSURepresentationName = function () {
        const DSURepresentationNames = require("./DSURepresentationNames");
        return DSURepresentationNames[_subtype];
    }

    target.getNoHintIdentifier = function (plain) {
        const dlDomain = target.getDLDomain() || '';
        const specificString = target.getSpecificString() || '';
        const controlString = target.getControlString() || '';
        let identifier = `${_prefix}:${target.getTypeName()}:${dlDomain}:${specificString}:${controlString}:${target.getVn()}`;
        return plain ? identifier : pskCrypto.pskBase58Encode(identifier);
    }

    target.getIdentifier = function (plain) {
        let id = target.getNoHintIdentifier(true);

        if (typeof _hint !== "undefined") {
            id += ":" + _hint.getSerialisation();
        }

        return plain ? id : pskCrypto.pskBase58Encode(id);
    }

    target.getBricksDomain = function () {
        let bricksDomain
        try {
            bricksDomain = _hint.getBricksDomain();
        } catch (e) {

        }
        return bricksDomain ? bricksDomain : _dlDomain;
    }

    target.getDSUVersionHint = function () {
        if (typeof _hint !== "undefined") {
            return _hint.getDSUVersion();
        }

        return undefined;
    }

    target.setDSUVersionHint = function (version) {
        if (typeof _hint === "undefined") {
            _createHint();
        }

        _hint.setDSUVersion(version);
    }

    target.setEmbeddedData = function (embeddedData) {
        if (typeof _hint === "undefined") {
            _createHint();
        }

        _hint.setEmbeddedData(embeddedData);
    }

    target.getEmbeddedData = function () {
        if (typeof _hint === "undefined") {
            return;
        }

        return _hint.getEmbeddedData();
    }

    target.clone = function () {
        let clone = {};
        clone.prototype = target.prototype;
        for (let attr in target) {
            if (target.hasOwnProperty(attr)) {
                clone[attr] = target[attr];
            }
        }
        keySSIMixin(clone);
        return clone;
    }

    /*
    * This method is meant to be used in order to cast between similar types of SSIs
    * e.g. WalletSSI to ArraySSI
    *
    * */
    target.cast = function (newType) {
        target.getTypeName = () => {
            return newType;
        };
        target.load(newType, _dlDomain, _subtypeSpecificString, _controlString, _vn, _hint);
    }

    target.canSign = () => {
        return _canSign;
    }

    target.setCanSign = (canSign) => {
        _canSign = canSign;
    }

    target.canBeVerified = () => {
        return false;
    };

    target.sign = (dataToSign, callback) => {
        if (typeof enclave !== "undefined") {
            return enclave.signForKeySSI(undefined, target, dataToSign, callback);
        }
        const sc = require("opendsu").loadAPI("sc").getSecurityContext();
        sc.signForKeySSI(undefined, target, dataToSign, callback);
    };

    target.verify = (data, signature) => {
        const decode = cryptoRegistry.getBase64DecodingFunction(target);
        signature = decode(signature);
        const verify = cryptoRegistry.getVerifyFunction(target);

        return verify(data, target.getPublicKey(), signature);
    };

    target.hash = (data) => {
        return cryptoRegistry.getHashFunction(target)(data);
    }

    target.encode = (data) => {
        return cryptoRegistry.getEncodingFunction(target)(data);
    }

    target.decode = (data) => {
        return cryptoRegistry.getDecodingFunction(target)(data);
    }

    target.base64Encode = (data) => {
        return cryptoRegistry.getBase64EncodingFunction(target)(data);
    }

    target.base64Decode = (data) => {
        return cryptoRegistry.getBase64DecodingFunction(target)(data);
    }

    target.toJSON = function () {
        return target.getIdentifier();
    }

    target.canAppend = function () {
        return true;
    }

    target.isTransfer = function () {
        return false;
    }

    target.isAlias = function () {
        return false;
    }

    target.isEmbed = function () {
        return false;
    }

    target.withoutCryptoData = function () {
        if (!_subtypeSpecificString && !_controlString) {
            return true;
        }

        return false;
    }

    target.createAnchorValue = function (brickMapHash, previousAnchorValue, callback) {
        const keySSIFactory = require("./KeySSIFactory");

        const signedHashLinkSSI = keySSIFactory.createType(SSITypes.SIGNED_HASH_LINK_SSI);
        target.getAnchorId(true, (err, anchorId) => {
            if (err) {
                return callback(err);
            }
            if (typeof previousAnchorValue === "string") {
                previousAnchorValue = keySSIFactory.create(previousAnchorValue);
            }

            let previousIdentifier = '';
            let timestamp = Date.now();
            if (previousAnchorValue && typeof previousAnchorValue.getTimestamp === "function" && timestamp < previousAnchorValue.getTimestamp()) {
                timestamp = previousAnchorValue.getTimestamp() + 10000;
            }
            if (previousAnchorValue) {
                previousIdentifier = previousAnchorValue.getIdentifier(true);
            }
            let dataToSign = anchorId + brickMapHash + previousIdentifier + timestamp;
            target.sign(dataToSign, (err, signature) => {
                if (err) {
                    return callback(err);
                }

                signedHashLinkSSI.initialize(target.getBricksDomain(), brickMapHash, timestamp, signature, target.getVn(), target.getHint());
                callback(undefined, signedHashLinkSSI);
            })
        })
    }

    target.getFamilyName = () => {
        return undefined
    }

    return target;
}

module.exports = keySSIMixin;

},{"../CryptoAlgorithms/CryptoAlgorithmsRegistry":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/key-ssi-resolver/lib/CryptoAlgorithms/CryptoAlgorithmsRegistry.js","./DSURepresentationNames":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/key-ssi-resolver/lib/KeySSIs/DSURepresentationNames.js","./Hint":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/key-ssi-resolver/lib/KeySSIs/Hint.js","./KeySSIFactory":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/key-ssi-resolver/lib/KeySSIs/KeySSIFactory.js","./SSITypes":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/key-ssi-resolver/lib/KeySSIs/SSITypes.js","opendsu":"opendsu","pskcrypto":"pskcrypto"}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/key-ssi-resolver/lib/KeySSIs/OtherKeySSIs/AliasSSI.js":[function(require,module,exports){
const SSITypes = require("../SSITypes");
const SSIFamilies = require("../SSIFamilies");

function AliasSSI(enclave, identifier) {
    if (typeof enclave === "string") {
        identifier = enclave;
        enclave = undefined;
    }
    const KeySSIMixin = require("../KeySSIMixin");
    KeySSIMixin(this, enclave);

    if (typeof identifier !== "undefined") {
        this.autoLoad(identifier);
    }

    this.initialize = (domain, alias, vn, hint, callback) => {
        if (typeof alias === "function") {
            callback = alias;
            alias = domain;
            domain = undefined;
        }

        if (typeof vn === "function") {
            callback = vn;
            vn = 'v0';
        }
        if (typeof hint === "function") {
            callback = hint;
            hint = undefined;
        }
        if (typeof domain === "undefined") {
            if (process.env.VAULT_DOMAIN) {
                this.load(SSITypes.ALIAS_SSI, process.env.VAULT_DOMAIN, alias, '', vn, hint);
                return callback(undefined, this);
            }

            const scAPI = require("opendsu").loadAPI("sc");
            return scAPI.getVaultDomain((err, vaultDomain) => {
                if (err) {
                    return callback(err);
                }

                this.load(SSITypes.ALIAS_SSI, vaultDomain, alias, '', vn, hint);
                return callback(undefined, this);
            });
        }

        this.load(SSITypes.ALIAS_SSI, domain, alias, '', vn, hint);
        callback(undefined, this);
    };

    this.isAlias = () => {
        return true;

    }
    this.deriveSync = () => {
        throw Error("Alias SSI cannot be derived");
    }

    this.derive = (callback) => {
        callback(Error("Alias SSI cannot be derived"));
    }

    this.getSSIFamilyName = () => {
        return SSIFamilies.SEED_SSI_FAMILY;
    }
}

const createAliasSSI = (enclave, identifier) => {
    return new AliasSSI(enclave, identifier);
}

module.exports = {
    createAliasSSI
};
},{"../KeySSIMixin":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/key-ssi-resolver/lib/KeySSIs/KeySSIMixin.js","../SSIFamilies":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/key-ssi-resolver/lib/KeySSIs/SSIFamilies.js","../SSITypes":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/key-ssi-resolver/lib/KeySSIs/SSITypes.js","opendsu":"opendsu"}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/key-ssi-resolver/lib/KeySSIs/OtherKeySSIs/EmbedSSI.js":[function(require,module,exports){
const KeySSIMixin = require("../KeySSIMixin");
const SSITypes = require("../SSITypes");
const cryptoRegistry = require("../../CryptoAlgorithms/CryptoAlgorithmsRegistry");

function EmbedSSI(enclave, identifier) {
    if (typeof enclave === "string") {
        identifier = enclave;
        enclave = undefined;
    }
    KeySSIMixin(this, enclave);
    const self = this;

    if (typeof identifier !== "undefined") {
        self.autoLoad(identifier);
    }

    self.getTypeName = function () {
        return SSITypes.EMBED_SSI;
    }

    const originalGetSpecificString = self.getSpecificString;

    self.initialize = (dlDomain, data, vn, hint) => {
        if (!$$.Buffer.isBuffer(data)) {
            data = $$.Buffer.from(data);
        }
        data = cryptoRegistry.getBase64EncodingFunction(self)(data);
        self.load(SSITypes.EMBED_SSI, dlDomain, data, '', vn, hint);
    };

    self.getSpecificString = () => {
        return cryptoRegistry.getBase64DecodingFunction(self)(originalGetSpecificString());
    }

    self.isEmbed = () => {
        return true;
    }

    
}

function createEmbedSSI(enclave, identifier) {
    return new EmbedSSI(enclave, identifier);
}

module.exports = {
    createEmbedSSI
};

},{"../../CryptoAlgorithms/CryptoAlgorithmsRegistry":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/key-ssi-resolver/lib/CryptoAlgorithms/CryptoAlgorithmsRegistry.js","../KeySSIMixin":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/key-ssi-resolver/lib/KeySSIs/KeySSIMixin.js","../SSITypes":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/key-ssi-resolver/lib/KeySSIs/SSITypes.js"}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/key-ssi-resolver/lib/KeySSIs/OtherKeySSIs/PublicKeySSI.js":[function(require,module,exports){
const KeySSIMixin = require("../KeySSIMixin");
const SSITypes = require("../SSITypes");
const cryptoRegistry = require("../../CryptoAlgorithms/CryptoAlgorithmsRegistry");

function PublicKeySSI(enclave, identifier) {
    if (typeof enclave === "string") {
        identifier = enclave;
        enclave = undefined;
    }
    KeySSIMixin(this, enclave);
    const self = this;

    if (typeof identifier !== "undefined") {
        self.autoLoad(identifier);
    }

    self.getTypeName = function () {
        return SSITypes.PUBLIC_KEY_SSI;
    }

    self.initialize = (compatibleFamilyName, publicKey, vn) => {
        publicKey = cryptoRegistry.getBase64EncodingFunction(self)(publicKey);
        self.load(SSITypes.PUBLIC_KEY_SSI, '', compatibleFamilyName, publicKey, vn);
    };

    self.getPublicKey = (format) => {
        let publicKey = cryptoRegistry.getBase64DecodingFunction(self)(self.getControlString());
        if (format !== "raw") {
            publicKey = cryptoRegistry.getConvertPublicKeyFunction(self)(publicKey, {outputFormat: format});
        }

        return publicKey;
    };

    self.generateCompatiblePowerfulKeySSI = (callback) => {
        const keySSIFactory = require("../KeySSIFactory");
        const powerfulSSI = keySSIFactory.createType(self.getSpecificString());
        powerfulSSI.initialize(self.getDLDomain(), undefined, undefined, self.getVn(), callback);
    }
    
}

function createPublicKeySSI(enclave, identifier) {
    return new PublicKeySSI(enclave, identifier);
}

module.exports = {
    createPublicKeySSI
};

},{"../../CryptoAlgorithms/CryptoAlgorithmsRegistry":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/key-ssi-resolver/lib/CryptoAlgorithms/CryptoAlgorithmsRegistry.js","../KeySSIFactory":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/key-ssi-resolver/lib/KeySSIs/KeySSIFactory.js","../KeySSIMixin":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/key-ssi-resolver/lib/KeySSIs/KeySSIMixin.js","../SSITypes":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/key-ssi-resolver/lib/KeySSIs/SSITypes.js"}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/key-ssi-resolver/lib/KeySSIs/OtherKeySSIs/SizeSSI.js":[function(require,module,exports){
const SSITypes = require("../SSITypes");
const KeySSIMixin = require("../KeySSIMixin");

function SizeSSI(enclave, identifier) {
    if (typeof enclave === "string") {
        identifier = enclave;
        enclave = undefined;
    }

    KeySSIMixin(this);
    const self = this;

    if (typeof identifier !== "undefined") {
        self.autoLoad(identifier);
    }

    self.initialize = (domain, totalSize, bufferSize, vn, hint) => {
        if (!domain) {
            throw new Error("domain is required");
        }
        if (totalSize == null) {
            throw new Error("totalSize is required");
        }
        if (bufferSize == null) {
            bufferSize = totalSize;
            vn = "v0";
        }
        if (vn == null) {
            vn = "v0";
        }

        self.load(SSITypes.SIZE_SSI, domain, totalSize, bufferSize, vn, hint);
    };

    self.isSizeSSI = () => {
        return true;
    };

    self.getTotalSize = () => {
        return parseInt(self.getSpecificString(), 10);
    };

    self.getBufferSize = () => {
        return parseInt(self.getControlString(), 10);
    };

    self.derive = () => {
        throw Error("Size SSI cannot be derived");
    };
}

const createSizeSSI = (enclave, identifier) => {
    return new SizeSSI(enclave, identifier);
};

module.exports = {
    createSizeSSI,
};

},{"../KeySSIMixin":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/key-ssi-resolver/lib/KeySSIs/KeySSIMixin.js","../SSITypes":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/key-ssi-resolver/lib/KeySSIs/SSITypes.js"}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/key-ssi-resolver/lib/KeySSIs/OtherKeySSIs/SymmetricalEncryptionSSI.js":[function(require,module,exports){
const KeySSIMixin = require("../KeySSIMixin");
const SSITypes = require("../SSITypes");
const cryptoRegistry = require("../../CryptoAlgorithms/CryptoAlgorithmsRegistry");

function SymmetricalEncryptionSSI(enclave, identifier) {
    if (typeof enclave === "string") {
        identifier = enclave;
        enclave = undefined;
    }
    KeySSIMixin(this, enclave);
    const self = this;
    if (typeof identifier !== "undefined") {
        self.autoLoad(identifier);
    }

    self.getTypeName = () => {
        return SSITypes.SYMMETRICAL_ENCRYPTION_SSI;
    };

    let load = self.load;
    self.load = function (subtype, dlDomain, encryptionKey, control, vn, hint){
        if (typeof encryptionKey === "undefined") {
            encryptionKey = cryptoRegistry.getEncryptionKeyGenerationFunction(self)();
        }

        if ($$.Buffer.isBuffer(encryptionKey)) {
            encryptionKey = cryptoRegistry.getBase64EncodingFunction(self)(encryptionKey);
        }

        load(subtype, dlDomain, encryptionKey, '', vn, hint);
    }

    self.getEncryptionKey = function(callback) {
        const encryptionKey = cryptoRegistry.getBase64DecodingFunction(self)(self.getSpecificString());
        callback(undefined, encryptionKey);
    };

    self.derive = function (){
        throw Error("Not implemented");
    }
}

function createSymmetricalEncryptionSSI(enclave, identifier) {
    return new SymmetricalEncryptionSSI(enclave, identifier);
}

module.exports = {
    createSymmetricalEncryptionSSI
};

},{"../../CryptoAlgorithms/CryptoAlgorithmsRegistry":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/key-ssi-resolver/lib/CryptoAlgorithms/CryptoAlgorithmsRegistry.js","../KeySSIMixin":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/key-ssi-resolver/lib/KeySSIs/KeySSIMixin.js","../SSITypes":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/key-ssi-resolver/lib/KeySSIs/SSITypes.js"}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/key-ssi-resolver/lib/KeySSIs/OtherKeySSIs/VersionlessSSI.js":[function(require,module,exports){
const KeySSIMixin = require("../KeySSIMixin");
const SSITypes = require("../SSITypes");

function VersionlessSSI(enclave, identifier) {
    if (typeof enclave === "string") {
        identifier = enclave;
        enclave = undefined;
    }
    KeySSIMixin(this, enclave);
    const self = this;

    if (typeof identifier !== "undefined") {
        self.autoLoad(identifier);
    }

    const crypto = require("opendsu").loadApi("crypto");

    self.getTypeName = function () {
        return SSITypes.VERSIONLESS_SSI;
    };

    self.initialize = (dlDomain, filePath, encryptionKey, vn, hint) => {
        if (!encryptionKey) {
            encryptionKey = "";
        }
        self.load(SSITypes.VERSIONLESS_SSI, dlDomain, filePath, encryptionKey, vn, hint);
    };

    // required to overwrite in order to cache the DSU instance
    self.getAnchorId = function (plain, callback) {
        if (typeof plain === "function") {
            callback = plain;
        }
        // use hash in order to limit anchorId length
        const anchorId = crypto.sha256(self.getFilePath());

        if (!callback) {
            return anchorId;
        }
        callback(undefined, anchorId);
    };

    // required for opendsu resolver loader
    self.getHash = () => {
        return self.getAnchorId();
    };

    self.getFilePath = () => {
        return self.getSpecificString();
    };

    self.getEncryptionKey = () => {
        return self.getControlString();
    };

    self.isEncrypted = () => {
        return !!self.getEncryptionKey();
    };

    self.encrypt = (data, callback) => {
        if (!self.isEncrypted()) {
            return callback(undefined, data);
        }

        try {
            const encryptionKey = self.getEncryptionKey();
            const result = crypto.encrypt(data, encryptionKey);
            callback(undefined, result);
        } catch (error) {
            callback(error);
        }
    };

    self.decrypt = (data, callback) => {
        if (!self.isEncrypted()) {
            return callback(undefined, data);
        }

        try {
            const encryptionKey = self.getEncryptionKey();
            const result = crypto.decrypt(data, encryptionKey);
            callback(undefined, result);
        } catch (error) {
            callback(error);
        }
    };
}

function createVersionlessSSI(enclave, identifier) {
    return new VersionlessSSI(enclave, identifier);
}

module.exports = {
    createVersionlessSSI,
};

},{"../KeySSIMixin":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/key-ssi-resolver/lib/KeySSIs/KeySSIMixin.js","../SSITypes":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/key-ssi-resolver/lib/KeySSIs/SSITypes.js","opendsu":"opendsu"}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/key-ssi-resolver/lib/KeySSIs/OtherKeySSIs/WalletSSI.js":[function(require,module,exports){
const ArraySSI = require("./../ConstSSIs/ArraySSI");
const SSITypes = require("../SSITypes");

function WalletSSI(enclave, identifier) {
    const self = this;
    const arraySSI = ArraySSI.createArraySSI(enclave, identifier);

    arraySSI.getTypeName = () => {
        return SSITypes.WALLET_SSI;
    };

    Object.assign(self, arraySSI);
}

function createWalletSSI(enclave, identifier) {
    return new WalletSSI(enclave, identifier);
}

module.exports = {
    createWalletSSI
}

},{"../SSITypes":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/key-ssi-resolver/lib/KeySSIs/SSITypes.js","./../ConstSSIs/ArraySSI":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/key-ssi-resolver/lib/KeySSIs/ConstSSIs/ArraySSI.js"}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/key-ssi-resolver/lib/KeySSIs/OwnershipSSIs/OReadSSI.js":[function(require,module,exports){
const KeySSIMixin = require("../KeySSIMixin");
const ZATSSI = require("./ZATSSI");
const SSITypes = require("../SSITypes");
const cryptoRegistry = require("../../CryptoAlgorithms/CryptoAlgorithmsRegistry");

function OReadSSI(identifier) {
    KeySSIMixin(this);
    const self = this;

    if (typeof identifier !== "undefined") {
        self.autoLoad(identifier);
    }

    self.getTypeName = function () {
        return SSITypes.OWNERSHIP_READ_SSI;
    }

    self.initialize = (dlDomain, hashPrivateKey, hashPublicKeyLevelAndToken, vn, hint) => {
        self.load(SSITypes.OWNERSHIP_READ_SSI, dlDomain, hashPrivateKey, hashPublicKeyLevelAndToken, vn, hint);
    };

    self.derive = (callback) => {
        const zatSSI = ZATSSI.createZATSSI();
        const token = self.getToken();
        const hashPublicKey = self.getHashPublicKey();
        zatSSI.load(
            SSITypes.ZERO_ACCESS_TOKEN_SSI,
            self.getDLDomain(),
            token,
            hashPublicKey,
            self.getVn(),
            self.getHint()
        );
        callback(undefined, zatSSI);
    };

    self.getEncryptionKey = (callback) => {
        const encryptionKey = cryptoRegistry.getBase64DecodingFunction(self)(self.getHashPublicKey());
        callback(undefined, encryptionKey);
    };

    const getControlParts = function () {
        let control = self.getControlString();
        if (control == null) {
            throw Error("Operation requested on an invalid OwnershipSSI. Initialise first");
        }
        return control.split("/");
    };

    self.getHashPublicKey = function () {
        let token = getControlParts()[0];
        return token;
    };

    self.getLevel = function () {
        let level = getControlParts()[1];
        return level;
    };

    self.getToken = function () {
        let token = getControlParts()[2];
        return token;
    };
}

function createOReadSSI(identifier) {
    return new OReadSSI(identifier);
}

module.exports = {
    createOReadSSI
};

},{"../../CryptoAlgorithms/CryptoAlgorithmsRegistry":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/key-ssi-resolver/lib/CryptoAlgorithms/CryptoAlgorithmsRegistry.js","../KeySSIMixin":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/key-ssi-resolver/lib/KeySSIs/KeySSIMixin.js","../SSITypes":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/key-ssi-resolver/lib/KeySSIs/SSITypes.js","./ZATSSI":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/key-ssi-resolver/lib/KeySSIs/OwnershipSSIs/ZATSSI.js"}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/key-ssi-resolver/lib/KeySSIs/OwnershipSSIs/OwnershipSSI.js":[function(require,module,exports){
const KeySSIMixin = require("../KeySSIMixin");
const OReadSSI = require("./OReadSSI");
const SSITypes = require("../SSITypes");
const cryptoRegistry = require("../../CryptoAlgorithms/CryptoAlgorithmsRegistry");

function OwnershipSSI(identifier) {
    KeySSIMixin(this);
    const self = this;
    if (typeof identifier !== "undefined") {
        self.autoLoad(identifier);
    }

    self.getTypeName = function () {
        return SSITypes.OWNERSHIP_SSI;
    }

    self.setCanSign(true);

    self.initialize = function (dlDomain, privateKey, levelAndToken, vn, hint, callback) {
        if (typeof privateKey === "function") {
            callback = privateKey;
            privateKey = undefined;
        }
        if (typeof levelAndToken === "function") {
            callback = levelAndToken;
            levelAndToken = undefined;
        }
        if (typeof vn === "function") {
            callback = vn;
            vn = "v0";
        }
        if (typeof hint === "function") {
            callback = hint;
            hint = undefined;
        }

        if (typeof privateKey === "undefined") {
            cryptoRegistry
                .getKeyPairGenerator(self)()
                .generateKeyPair((err, publicKey, privateKey) => {
                    if (err) {
                        return OpenDSUSafeCallback(callback)(
                            createOpenDSUErrorWrapper(`Failed generate private/public key pair`, err)
                        );
                    }
                    privateKey = cryptoRegistry.getBase64EncodingFunction(self)(privateKey);
                    self.load(SSITypes.OWNERSHIP_SSI, dlDomain, privateKey, levelAndToken, vn, hint);
                    if (callback) {
                        callback(undefined, self);
                    }
                });
        } else {
            self.load(SSITypes.OWNERSHIP_SSI, dlDomain, privateKey, levelAndToken, vn, hint);
            if (callback) {
                callback(undefined, self);
            }
        }
        self.initialize = function () {
            throw Error("KeySSI already initialized");
        };
    };

    self.derive = function (callback) {
        const oReadSSI = OReadSSI.createOReadSSI();
        const privateKey = self.getPrivateKey();
        const publicKey = cryptoRegistry.getDerivePublicKeyFunction(self)(privateKey, "raw");
        const publicKeyHash = cryptoRegistry.getHashFunction(self)(publicKey);
        const levelAndToken = self.getControlString();

        const oReadSpecificString = cryptoRegistry.getHashFunction(self)(privateKey);
        const oReadControl = `${publicKeyHash}/${levelAndToken}`;
        oReadSSI.load(
            SSITypes.OWNERSHIP_READ_SSI,
            self.getDLDomain(),
            oReadSpecificString,
            oReadControl,
            self.getVn(),
            self.getHint()
        );
        callback(undefined, oReadSSI);
    };

    self.getPrivateKey = function (format) {
        let validSpecificString = self.getSpecificString();
        if (validSpecificString === undefined) {
            throw Error("Operation requested on an invalid OwnershipSSI. Initialise first");
        }
        let privateKey = validSpecificString;
        if (typeof privateKey === "string") {
            privateKey = cryptoRegistry.getBase64DecodingFunction(self)(privateKey);
        }
        if (format === "pem") {
            const pemKeys = cryptoRegistry.getKeyPairGenerator(self)().getPemKeys(privateKey, self.getPublicKey("raw"));
            privateKey = pemKeys.privateKey;
        }
        return privateKey;
    };

    self.sign = function (dataToSign, callback) {
        const privateKey = self.getPrivateKey();
        const sign = cryptoRegistry.getSignFunction(self);
        const encode = cryptoRegistry.getBase64EncodingFunction(self);
        const digitalProof = {};
        digitalProof.signature = encode(sign(dataToSign, privateKey));
        digitalProof.publicKey = encode(self.getPublicKey("raw"));

        callback(undefined, digitalProof);
    }


    self.getPrivateKeyHash = function () {
        return cryptoRegistry.getHashFunction(self)(self.getPrivateKey());
    };

    self.getPublicKey = function (format) {
        return cryptoRegistry.getDerivePublicKeyFunction(self)(self.getPrivateKey(), format);
    };

    self.getPublicKeyHash = function () {
        // const publicKey = cryptoRegistry.getDerivePublicKeyFunction(self)(self.getPrivateKey(), "raw");
        const publicKey = self.getPublicKey("raw");
        const publicKeyHash = cryptoRegistry.getHashFunction(self)(publicKey);
        return publicKeyHash;
    };

    self.getEncryptionKey = function (callback) {
        self.derive((err, derivedKeySSI) => {
            if (err) {
                return callback(err);
            }

            derivedKeySSI.getEncryptionKey(callback);
        });
    };

    const getControlParts = function () {
        let control = self.getControlString();
        if (control == null) {
            throw Error("Operation requested on an invalid OwnershipSSI. Initialise first");
        }
        return control.split("/");
    };

    self.getLevel = function () {
        let level = getControlParts()[0];
        return level;
    };

    self.getToken = function () {
        let token = getControlParts()[1];
        return token;
    };

    self.getAnchorId = function () {
        return self.getToken();
    };
}

function createOwnershipSSI(identifier) {
    return new OwnershipSSI(identifier);
}

module.exports = {
    createOwnershipSSI
};

},{"../../CryptoAlgorithms/CryptoAlgorithmsRegistry":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/key-ssi-resolver/lib/CryptoAlgorithms/CryptoAlgorithmsRegistry.js","../KeySSIMixin":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/key-ssi-resolver/lib/KeySSIs/KeySSIMixin.js","../SSITypes":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/key-ssi-resolver/lib/KeySSIs/SSITypes.js","./OReadSSI":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/key-ssi-resolver/lib/KeySSIs/OwnershipSSIs/OReadSSI.js"}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/key-ssi-resolver/lib/KeySSIs/OwnershipSSIs/ZATSSI.js":[function(require,module,exports){
const KeySSIMixin = require("../KeySSIMixin");
const SSITypes = require("../SSITypes");

function ZATSSI(identifier) {
    const self = this;
    KeySSIMixin(self);

    if (typeof identifier !== "undefined") {
        self.autoLoad(identifier);
    }

    self.getTypeName = function () {
        return SSITypes.ZERO_ACCESS_TOKEN_SSI;
    }

    self.initialize = (dlDomain, token, hashInitialOwnerPublicKey, vn, hint) => {
        self.load(SSITypes.ZERO_ACCESS_TOKEN_SSI, dlDomain, token, hashInitialOwnerPublicKey, vn, hint);
    };

    
}

function createZATSSI(identifier) {
    return new ZATSSI(identifier);
}

module.exports = {
    createZATSSI
};

},{"../KeySSIMixin":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/key-ssi-resolver/lib/KeySSIs/KeySSIMixin.js","../SSITypes":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/key-ssi-resolver/lib/KeySSIs/SSITypes.js"}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/key-ssi-resolver/lib/KeySSIs/SSIFamilies.js":[function(require,module,exports){
module.exports = {
    DEFAULT_SSI_FAMILY: "defaultSSIFamily",
    SECRET_SSI_FAMILY: "secretSSIFamily",
    SEED_SSI_FAMILY: "seedSSIFamily",
    CONST_SSI_FAMILY: "constSSIFamily",
    HASH_LINK_SSI_FAMILY: "hlSSIFamily",
    OWNERSHIP_SSI_FAMILY: "ownSSIFamily",
    ALIAS_SSI_FAMILY: "aliasSSIFamily",
    SIZE_SSI_FAMILY: "sizeSSIFamily",
    EMBED_SSI_FAMILY: "embedSSIFamily"
};

},{}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/key-ssi-resolver/lib/KeySSIs/SSITypes.js":[function(require,module,exports){
module.exports = {
    DEFAULT: "default",
    SECRET_SSI: "secret",
    ANCHOR_SSI: "anchor",
    READ_SSI: "read",
    PUBLIC_SSI: "public",
    ZERO_ACCESS_SSI: "za",
    PATH_SSI: "path",
    SEED_SSI: "seed",
    SREAD_SSI: "sread",
    SZERO_ACCESS_SSI: "sza",
    PASSWORD_SSI: "pass",
    CONST_SSI: "const",
    CONSTANT_ZERO_ACCESS_SSI: "cza",
    ARRAY_SSI: "array",
    HASH_LINK_SSI: "hl",
    WALLET_SSI: "wallet",
    SYMMETRICAL_ENCRYPTION_SSI: "se",
    TOKEN_SSI: "token",
    OWNERSHIP_SSI: "own",
    OWNERSHIP_READ_SSI: "oread",
    ZERO_ACCESS_TOKEN_SSI: "zat",
    TRANSFER_SSI: "transfer",
    SIGNED_HASH_LINK_SSI: "shl",
    CONSENSUS_SSI: "consensus",
    PUBLIC_KEY_SSI: "pk",
    ALIAS_SSI: "alias",
    SIZE_SSI: "size",
    EMBED_SSI: "embed",
    VERSIONLESS_SSI: "vs"
};

},{}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/key-ssi-resolver/lib/KeySSIs/SecretSSIs/AnchorSSI.js":[function(require,module,exports){
const KeySSIMixin = require("../KeySSIMixin");
const ReadSSI = require("./ReadSSI");
const SSITypes = require("../SSITypes");
const cryptoRegistry = require("../../CryptoAlgorithms/CryptoAlgorithmsRegistry");

function AnchorSSI(identifier) {
    KeySSIMixin(this);

    if (typeof identifier !== "undefined") {
        this.autoLoad(identifier);
    }

    this.derive = (callback) => {
        const readSSI = ReadSSI.createReadSSI();
        this.getEncryptionKey((err, encryptionKey) => {
            if (err) {
                return callback(err);
            }

            const subtypeKey = cryptoRegistry.getHashFunction(this)(encryptionKey);
            readSSI.load(SSITypes.READ_SSI, this.getDLDomain(), subtypeKey, this.getControlString(), this.getVn(), this.getHint());
            callback(undefined, readSSI);
        });
    };
}

function createAnchorSSI(identifier) {
    return new AnchorSSI(identifier);
}

module.exports = {
    createAnchorSSI
}

},{"../../CryptoAlgorithms/CryptoAlgorithmsRegistry":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/key-ssi-resolver/lib/CryptoAlgorithms/CryptoAlgorithmsRegistry.js","../KeySSIMixin":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/key-ssi-resolver/lib/KeySSIs/KeySSIMixin.js","../SSITypes":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/key-ssi-resolver/lib/KeySSIs/SSITypes.js","./ReadSSI":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/key-ssi-resolver/lib/KeySSIs/SecretSSIs/ReadSSI.js"}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/key-ssi-resolver/lib/KeySSIs/SecretSSIs/PublicSSI.js":[function(require,module,exports){
const KeySSIMixin = require("../KeySSIMixin");
const ZaSSI = require("./ZaSSI");
const SSITypes = require("../SSITypes");
const cryptoRegistry = require("../../CryptoAlgorithms/CryptoAlgorithmsRegistry");

function PublicSSI(identifier) {
    KeySSIMixin(this);

    if (typeof identifier !== "undefined") {
        this.autoLoad(identifier);
    }

    this.derive = () => {
        const zaSSI = ZaSSI.createZaSSI();
        const subtypeKey = cryptoRegistry.getHashFunction(this)(this.getEncryptionKey())
        zaSSI.initialize(SSITypes.ZERO_ACCESS_SSI, this.getDLDomain(), subtypeKey, this.getControlString(), this.getVn(), this.getHint());
        return zaSSI;
    };
}

function createPublicSSI(identifier) {
    return new PublicSSI(identifier);
}

module.exports = {
    createPublicSSI
};

},{"../../CryptoAlgorithms/CryptoAlgorithmsRegistry":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/key-ssi-resolver/lib/CryptoAlgorithms/CryptoAlgorithmsRegistry.js","../KeySSIMixin":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/key-ssi-resolver/lib/KeySSIs/KeySSIMixin.js","../SSITypes":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/key-ssi-resolver/lib/KeySSIs/SSITypes.js","./ZaSSI":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/key-ssi-resolver/lib/KeySSIs/SecretSSIs/ZaSSI.js"}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/key-ssi-resolver/lib/KeySSIs/SecretSSIs/ReadSSI.js":[function(require,module,exports){
const KeySSIMixin = require("../KeySSIMixin");
const PublicSSI = require("./PublicSSI");
const SSITypes = require("../SSITypes");
const cryptoRegistry = require("../../CryptoAlgorithms/CryptoAlgorithmsRegistry");

function ReadSSI(identifier) {
    KeySSIMixin(this);

    if (typeof identifier !== "undefined") {
        this.load(identifier);
    }

    this.derive = () => {
        const publicSSI = PublicSSI.createPublicSSI();
        const subtypeKey = cryptoRegistry.getHashFunction(this)(this.getEncryptionKey());
        publicSSI.load(SSITypes.PUBLIC_SSI, this.getDLDomain(), subtypeKey, this.getControlString(), this.getVn(), this.getHint());
        return publicSSI;
    };
}

function createReadSSI(identifier) {
    return new ReadSSI(identifier);
}

module.exports = {
    createReadSSI
};

},{"../../CryptoAlgorithms/CryptoAlgorithmsRegistry":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/key-ssi-resolver/lib/CryptoAlgorithms/CryptoAlgorithmsRegistry.js","../KeySSIMixin":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/key-ssi-resolver/lib/KeySSIs/KeySSIMixin.js","../SSITypes":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/key-ssi-resolver/lib/KeySSIs/SSITypes.js","./PublicSSI":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/key-ssi-resolver/lib/KeySSIs/SecretSSIs/PublicSSI.js"}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/key-ssi-resolver/lib/KeySSIs/SecretSSIs/SecretSSI.js":[function(require,module,exports){
const KeySSIMixin = require("../KeySSIMixin");
const AnchorSSI = require("./AnchorSSI");
const SSITypes = require("../SSITypes");
const cryptoRegistry = require("../../CryptoAlgorithms/CryptoAlgorithmsRegistry");

function SecretSSI(identifier) {
    KeySSIMixin(this);

    if (typeof identifier !== "undefined") {
        this.autoLoad(identifier);
    }

    this.derive = () => {
        const anchorSSI = AnchorSSI.createAnchorSSI();
        const subtypeKey = cryptoRegistry.getHashFunction(this)(this.getEncryptionKey())
        anchorSSI.load(SSITypes.ANCHOR_SSI, this.getDLDomain(), subtypeKey, this.getControlString(), this.getVn(), this.getHint());
        return anchorSSI;
    };
}

function createSecretSSI (identifier){
    return new SecretSSI(identifier);
}
module.exports = {
    createSecretSSI
}

},{"../../CryptoAlgorithms/CryptoAlgorithmsRegistry":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/key-ssi-resolver/lib/CryptoAlgorithms/CryptoAlgorithmsRegistry.js","../KeySSIMixin":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/key-ssi-resolver/lib/KeySSIs/KeySSIMixin.js","../SSITypes":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/key-ssi-resolver/lib/KeySSIs/SSITypes.js","./AnchorSSI":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/key-ssi-resolver/lib/KeySSIs/SecretSSIs/AnchorSSI.js"}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/key-ssi-resolver/lib/KeySSIs/SecretSSIs/ZaSSI.js":[function(require,module,exports){
const KeySSIMixin = require("../KeySSIMixin");
function ZaSSI(identifier) {
    KeySSIMixin(this);

    if (typeof identifier !== "undefined") {
        this.autoLoad(identifier);
    }

    this.derive = () => {
        throw Error("Not implemented");
    };
}

function createZaSSI(identifier) {
    return new ZaSSI(identifier);
}

module.exports = {
    createZaSSI
};
},{"../KeySSIMixin":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/key-ssi-resolver/lib/KeySSIs/KeySSIMixin.js"}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/key-ssi-resolver/lib/KeySSIs/SeedSSIs/PathKeySSI.js":[function(require,module,exports){
const KeySSIMixin = require("../KeySSIMixin");
const SeedSSI = require("./SeedSSI");
const SSITypes = require("../SSITypes");
const cryptoRegistry = require("../../CryptoAlgorithms/CryptoAlgorithmsRegistry");
const SSIFamilies = require("../SSIFamilies");

function PathKeySSI(enclave, identifier) {
    if (typeof enclave === "string") {
        identifier = enclave;
        enclave = undefined;
    }
    KeySSIMixin(this, enclave);
    const self = this;
    let privateKey;

    if (typeof identifier !== "undefined") {
        self.autoLoad(identifier);
    }

    self.getTypeName = function () {
        return SSITypes.PATH_SSI;
    }

    self.setCanSign(true);

    const _getEnclave = (callback) => {
        const openDSU = require("opendsu")
        const scAPI = openDSU.loadAPI("sc")
        scAPI.getSharedEnclave((err, sharedEnclave) => {
            if (err) {
                return scAPI.getMainEnclave(callback);
            }

            callback(undefined, sharedEnclave);
        });
    }

    self.deriveSync = () => {
        throw Error("PathSSIs cannot be derived synchronously");
    }

    self.derive = function (callback) {
        const specificString = self.getSpecificString();
        const index = specificString.indexOf("/");
        const slot = specificString.slice(0, index);
        const path = specificString.slice(index + 1);

        const __getPrivateKeyForSlot = () => {
            enclave.getPrivateKeyForSlot(slot, (err, _privateKey) => {
                if (err) {
                    return callback(err);
                }

                try {
                    privateKey = _privateKey;
                    privateKey = cryptoRegistry.getHashFunction(self)(`${path}${toString(privateKey)}`);
                    privateKey = cryptoRegistry.getDecodingFunction(self)(privateKey);
                    const seedSpecificString = cryptoRegistry.getBase64EncodingFunction(self)(privateKey);
                    const seedSSI = SeedSSI.createSeedSSI(enclave);
                    seedSSI.load(SSITypes.SEED_SSI, self.getDLDomain(), seedSpecificString, undefined, self.getVn(), self.getHint());
                    callback(undefined, seedSSI);
                } catch (e) {
                    callback(e);
                }
            });
        }

        if (typeof enclave === "undefined") {
            _getEnclave((err, _enclave) => {
                if (err) {
                    return callback(err);
                }

                enclave = _enclave;
                __getPrivateKeyForSlot();
            })

            return;
        }

        __getPrivateKeyForSlot();
    };

    self.getPrivateKey = function (format) {
        let validSpecificString = self.getSpecificString();
        if (validSpecificString === undefined) {
            throw Error("Operation requested on an invalid SeedSSI. Initialise first")
        }
        let privateKey = cryptoRegistry.getBase64DecodingFunction(self)(validSpecificString);
        if (format === "pem") {
            const pemKeys = cryptoRegistry.getKeyPairGenerator(self)().getPemKeys(privateKey, self.getPublicKey("raw"));
            privateKey = pemKeys.privateKey;
        }
        return privateKey;
    }

    self.sign = function (dataToSign, callback) {
        self.derive((err, seedSSI) => {
            if (err) {
                return callback(err);
            }

            seedSSI.sign(dataToSign, callback);
        })
    }

    self.getPublicKey = function (format) {
        return cryptoRegistry.getDerivePublicKeyFunction(self)(self.getPrivateKey(), format);
    }

    self.getEncryptionKey = function (callback) {
        self.derive((err, seedSSI) => {
            if (err) {
                return callback(err);
            }

            seedSSI.getEncryptionKey(callback);
        })
    };

    self.getKeyPair = function () {
        const keyPair = {
            privateKey: self.getPrivateKey("pem"),
            publicKey: self.getPublicKey("pem")
        }

        return keyPair;
    }

    self.getFamilyName = () => {
        return SSIFamilies.SEED_SSI_FAMILY;
    }

    function toString (buf) {
        let MAX_ARGUMENTS_LENGTH = 0x1000

        function decodeCodePointsArray (codePoints) {
            let len = codePoints.length
            if (len <= MAX_ARGUMENTS_LENGTH) {
                return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
            }

            // Decode in chunks to avoid "call stack size exceeded".
            let res = ''
            let i = 0
            while (i < len) {
                res += String.fromCharCode.apply(
                    String,
                    codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
                )
            }
            return res
        }

        let start = 0;
        let end = buf.length;
        let res = []

        let i = start
        while (i < end) {
            let firstByte = buf[i]
            let codePoint = null
            let bytesPerSequence = (firstByte > 0xEF) ? 4
                : (firstByte > 0xDF) ? 3
                    : (firstByte > 0xBF) ? 2
                        : 1

            if (i + bytesPerSequence <= end) {
                let secondByte, thirdByte, fourthByte, tempCodePoint

                switch (bytesPerSequence) {
                    case 1:
                        if (firstByte < 0x80) {
                            codePoint = firstByte
                        }
                        break
                    case 2:
                        secondByte = buf[i + 1]
                        if ((secondByte & 0xC0) === 0x80) {
                            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
                            if (tempCodePoint > 0x7F) {
                                codePoint = tempCodePoint
                            }
                        }
                        break
                    case 3:
                        secondByte = buf[i + 1]
                        thirdByte = buf[i + 2]
                        if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
                            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
                            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
                                codePoint = tempCodePoint
                            }
                        }
                        break
                    case 4:
                        secondByte = buf[i + 1]
                        thirdByte = buf[i + 2]
                        fourthByte = buf[i + 3]
                        if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
                            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
                            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
                                codePoint = tempCodePoint
                            }
                        }
                }
            }

            if (codePoint === null) {
                // we did not generate a valid codePoint so insert a
                // replacement char (U+FFFD) and advance only 1 byte
                codePoint = 0xFFFD
                bytesPerSequence = 1
            } else if (codePoint > 0xFFFF) {
                // encode to utf16 (surrogate pair dance)
                codePoint -= 0x10000
                res.push(codePoint >>> 10 & 0x3FF | 0xD800)
                codePoint = 0xDC00 | codePoint & 0x3FF
            }

            res.push(codePoint)
            i += bytesPerSequence
        }

        return decodeCodePointsArray(res)
    }
}

function createPathKeySSI(enclave, identifier) {
    return new PathKeySSI(enclave, identifier);
}

module.exports = {
    createPathKeySSI
};

},{"../../CryptoAlgorithms/CryptoAlgorithmsRegistry":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/key-ssi-resolver/lib/CryptoAlgorithms/CryptoAlgorithmsRegistry.js","../KeySSIMixin":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/key-ssi-resolver/lib/KeySSIs/KeySSIMixin.js","../SSIFamilies":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/key-ssi-resolver/lib/KeySSIs/SSIFamilies.js","../SSITypes":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/key-ssi-resolver/lib/KeySSIs/SSITypes.js","./SeedSSI":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/key-ssi-resolver/lib/KeySSIs/SeedSSIs/SeedSSI.js","opendsu":"opendsu"}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/key-ssi-resolver/lib/KeySSIs/SeedSSIs/SReadSSI.js":[function(require,module,exports){
const KeySSIMixin = require("../KeySSIMixin");
const SZaSSI = require("./SZaSSI");
const SSITypes = require("../SSITypes");
const cryptoRegistry = require("../../CryptoAlgorithms/CryptoAlgorithmsRegistry");
const SSIFamilies = require("../SSIFamilies");

function SReadSSI(enclave, identifier) {
    if (typeof enclave === "string") {
        identifier = enclave;
        enclave = undefined;
    }
    KeySSIMixin(this, enclave);
    const self = this;

    if (typeof identifier !== "undefined") {
        self.autoLoad(identifier);
    }

    self.getTypeName = function () {
        return SSITypes.SREAD_SSI;
    }

    self.initialize = (dlDomain, vn, hint) => {
        self.load(SSITypes.SREAD_SSI, dlDomain, "", undefined, vn, hint);
    };

    self.deriveSync = () => {
        const sZaSSI = SZaSSI.createSZaSSI();
        const subtypeKey = '';
        const subtypeControl = self.getControlString();
        sZaSSI.load(SSITypes.SZERO_ACCESS_SSI, self.getDLDomain(), subtypeKey, subtypeControl, self.getVn(), self.getHint());

        return sZaSSI;
    }

    self.derive = (callback) => {
        try {
            const sZaSSI = self.deriveSync();
            return callback(undefined, sZaSSI);
        } catch (e) {
            return callback(e);
        }
    };

    self.getEncryptionKey = (callback) => {
        const encryptionKey = cryptoRegistry.getDecodingFunction(self)(self.getSpecificString());
        callback(undefined, encryptionKey);
    };

    self.getPublicKey = (options) => {
        let publicKey = cryptoRegistry.getBase64DecodingFunction(self)(self.getControlString());
        return cryptoRegistry.getConvertPublicKeyFunction(self)(publicKey, options);
    };

    self.getFamilyName = () => {
        return SSIFamilies.SEED_SSI_FAMILY;
    }
}

function createSReadSSI(enclave, identifier) {
    return new SReadSSI(enclave, identifier)
}

module.exports = {
    createSReadSSI
};

},{"../../CryptoAlgorithms/CryptoAlgorithmsRegistry":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/key-ssi-resolver/lib/CryptoAlgorithms/CryptoAlgorithmsRegistry.js","../KeySSIMixin":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/key-ssi-resolver/lib/KeySSIs/KeySSIMixin.js","../SSIFamilies":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/key-ssi-resolver/lib/KeySSIs/SSIFamilies.js","../SSITypes":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/key-ssi-resolver/lib/KeySSIs/SSITypes.js","./SZaSSI":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/key-ssi-resolver/lib/KeySSIs/SeedSSIs/SZaSSI.js"}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/key-ssi-resolver/lib/KeySSIs/SeedSSIs/SZaSSI.js":[function(require,module,exports){
const KeySSIMixin = require("../KeySSIMixin");
const SSITypes = require("../SSITypes");
const cryptoRegistry = require("../../CryptoAlgorithms/CryptoAlgorithmsRegistry");
const SSIFamilies = require("../SSIFamilies");

function SZaSSI(enclave, identifier) {
    if (typeof enclave === "string") {
        identifier = enclave;
        enclave = undefined;
    }
    const self = this;
    KeySSIMixin(self, enclave);

    if (typeof identifier !== "undefined") {
        self.autoLoad(identifier);
    }

    self.getTypeName = function () {
        return SSITypes.SZERO_ACCESS_SSI;
    }

    self.initialize = (dlDomain, hpk, vn, hint) => {
        self.load(SSITypes.SZERO_ACCESS_SSI, dlDomain, '', hpk, vn, hint);
    };

    self.getPublicKey = (options) => {
        let publicKey = cryptoRegistry.getBase64DecodingFunction(self)(self.getControlString());
        return cryptoRegistry.getConvertPublicKeyFunction(self)(publicKey, options);
    };

    self.getFamilyName = () => {
        return SSIFamilies.SEED_SSI_FAMILY;
    }
}

function createSZaSSI(enclave, identifier) {
    return new SZaSSI(enclave, identifier);
}

module.exports = {
    createSZaSSI
};

},{"../../CryptoAlgorithms/CryptoAlgorithmsRegistry":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/key-ssi-resolver/lib/CryptoAlgorithms/CryptoAlgorithmsRegistry.js","../KeySSIMixin":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/key-ssi-resolver/lib/KeySSIs/KeySSIMixin.js","../SSIFamilies":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/key-ssi-resolver/lib/KeySSIs/SSIFamilies.js","../SSITypes":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/key-ssi-resolver/lib/KeySSIs/SSITypes.js"}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/key-ssi-resolver/lib/KeySSIs/SeedSSIs/SeedSSI.js":[function(require,module,exports){
const KeySSIMixin = require("../KeySSIMixin");
const SReadSSI = require("./SReadSSI");
const SSITypes = require("../SSITypes");
const cryptoRegistry = require("../../CryptoAlgorithms/CryptoAlgorithmsRegistry");
const SSIFamilies = require("../SSIFamilies");

function SeedSSI(enclave, identifier) {
    if (typeof enclave === "string") {
        identifier = enclave;
        enclave = undefined;
    }
    KeySSIMixin(this, enclave);
    const self = this;
    if (typeof identifier !== "undefined") {
        self.autoLoad(identifier);
    }

    self.getTypeName = function () {
        return SSITypes.SEED_SSI;
    }

    self.setCanSign(true);

    self.initialize = function (dlDomain, privateKey, control, vn, hint, callback) {
        if (typeof privateKey === "function") {
            callback = privateKey;
            privateKey = undefined;
        }
        if (typeof control === "function") {
            callback = control;
            control = undefined;
        }
        if (typeof vn === "function") {
            callback = vn;
            vn = 'v0';
        }
        if (typeof hint === "function") {
            callback = hint;
            hint = undefined;
        }

        if (!privateKey) {
            cryptoRegistry.getKeyPairGenerator(self)().generateKeyPair((err, publicKey, privateKey) => {
                if (err) {
                    return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed generate private/public key pair`, err));
                }
                privateKey = cryptoRegistry.getBase64EncodingFunction(self)(privateKey);
                self.load(SSITypes.SEED_SSI, dlDomain, privateKey, '', vn, hint);
                if (callback) {
                    callback(undefined, self);
                }
            });
        } else {
            privateKey = cryptoRegistry.getBase64EncodingFunction(self)(privateKey);
            self.load(SSITypes.SEED_SSI, dlDomain, privateKey, '', vn, hint);
            if (callback) {
                callback(undefined, self);
            }
        }
        self.initialize = function () {
            throw Error("KeySSI already initialized");
        }
    };

    self.deriveSync = () => {
        const sReadSSI = SReadSSI.createSReadSSI();
        const privateKey = self.getPrivateKey();
        const sreadSpecificString = cryptoRegistry.getHashFunction(self)(privateKey);
        const publicKey = cryptoRegistry.getDerivePublicKeyFunction(self)(privateKey, "raw");
        const controlString = cryptoRegistry.getBase64EncodingFunction(self)(publicKey);
        sReadSSI.load(SSITypes.SREAD_SSI, self.getDLDomain(), sreadSpecificString, controlString, self.getVn(), self.getHint());

        return sReadSSI;
    }

    self.derive = function (callback) {
        try {
            const sReadSSI = self.deriveSync();
            callback(undefined, sReadSSI);
        } catch (e) {
            return callback(e);
        }
    };

    self.getPrivateKey = function (format) {
        let validSpecificString = self.getSpecificString();
        if (validSpecificString === undefined) {
            throw Error("Operation requested on an invalid SeedSSI. Initialise first")
        }
        let privateKey = cryptoRegistry.getBase64DecodingFunction(self)(validSpecificString);
        if (format === "pem") {
            const pemKeys = cryptoRegistry.getKeyPairGenerator(self)().getPemKeys(privateKey, self.getPublicKey("raw"));
            privateKey = pemKeys.privateKey;
        }
        return privateKey;
    }

    self.sign = function (dataToSign, callback) {
        let signature;
        try {
            const privateKey = self.getPrivateKey();
            const sign = cryptoRegistry.getSignFunction(self);
            const encode = cryptoRegistry.getBase64EncodingFunction(self);
            signature = encode(sign(dataToSign, privateKey));
        } catch (e) {
            if (callback) {
                return callback(e);
            }
            throw e;
        }

        if (callback) {
            callback(undefined, signature);
        }

        return signature;
    }

    self.getPublicKey = function (format) {
        return cryptoRegistry.getDerivePublicKeyFunction(self)(self.getPrivateKey(), format);
    }

    self.getEncryptionKey = function (callback) {
        self.derive((err, derivedKeySSI) => {
            if (err) {
                return callback(err);
            }

            derivedKeySSI.getEncryptionKey(callback);
        });
    };

    self.getKeyPair = function () {
        const keyPair = {
            privateKey: self.getPrivateKey("pem"),
            publicKey: self.getPublicKey("pem")
        }

        return keyPair;
    }

    self.getFamilyName = () => {
        return SSIFamilies.SEED_SSI_FAMILY;
    }
}

function createSeedSSI(enclave, identifier) {
    return new SeedSSI(enclave, identifier);
}

module.exports = {
    createSeedSSI
};

},{"../../CryptoAlgorithms/CryptoAlgorithmsRegistry":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/key-ssi-resolver/lib/CryptoAlgorithms/CryptoAlgorithmsRegistry.js","../KeySSIMixin":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/key-ssi-resolver/lib/KeySSIs/KeySSIMixin.js","../SSIFamilies":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/key-ssi-resolver/lib/KeySSIs/SSIFamilies.js","../SSITypes":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/key-ssi-resolver/lib/KeySSIs/SSITypes.js","./SReadSSI":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/key-ssi-resolver/lib/KeySSIs/SeedSSIs/SReadSSI.js"}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/key-ssi-resolver/lib/KeySSIs/TokenSSIs/TokenSSI.js":[function(require,module,exports){
const KeySSIMixin = require("../KeySSIMixin");
const SSITypes = require("../SSITypes");

function TokenSSI(enclave, identifier) {
    if (typeof enclave === "string") {
        identifier = enclave;
        enclave = undefined;
    }
    KeySSIMixin(this, enclave);
    const self = this;
    if (typeof identifier !== "undefined") {
        self.autoLoad(identifier);
    }

    self.getTypeName = function () {
        return SSITypes.TOKEN_SSI;
    }

    self.initialize = function (dlDomain, amount, hashInitialOwnerPublicKey, vn, hint, callback) {
        if (typeof amount === "function") {
            callback = amount;
            amount = undefined;
        }
        if (typeof hashInitialOwnerPublicKey === "function") {
            callback = hashInitialOwnerPublicKey;
            hashInitialOwnerPublicKey = undefined;
        }
        if (typeof vn === "function") {
            callback = vn;
            vn = "v0";
        }
        if (typeof hint === "function") {
            callback = hint;
            hint = undefined;
        }

        self.load(SSITypes.TOKEN_SSI, dlDomain, amount, hashInitialOwnerPublicKey, vn, hint);
        if (callback) {
            callback(undefined, self);
        }

        self.initialize = function () {
            throw Error("KeySSI already initialized");
        };
    };

    self.takeOwnership = function (ownershipSSI, callback) {
        // will give token ownership to another generated ownershipSSI
        throw Error("Not implemented");
        // callback(err, newOwnershipSSI);
    };

    self.giveOwnership = function (ownershipSSI, oReadSSI, callback) {
        // will give token ownership to another specified oReadSSI
        throw Error("Not implemented");
        // callback(err, transferSSI);
    };
}

function createTokenSSI(enclave, identifier) {
    return new TokenSSI(enclave, identifier);
}

module.exports = {
    createTokenSSI
};

},{"../KeySSIMixin":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/key-ssi-resolver/lib/KeySSIs/KeySSIMixin.js","../SSITypes":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/key-ssi-resolver/lib/KeySSIs/SSITypes.js"}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/key-ssi-resolver/lib/KeySSIs/TransferSSIs/TransferSSI.js":[function(require,module,exports){
const KeySSIMixin = require("../KeySSIMixin");
const SSITypes = require("../SSITypes");
const cryptoRegistry = require("../../CryptoAlgorithms/CryptoAlgorithmsRegistry");
const keySSIFactory = require("../KeySSIFactory");

function TransferSSI(enclave, identifier) {
    if (typeof enclave === "string") {
        identifier = enclave;
        enclave = undefined;
    }
    KeySSIMixin(this, enclave);
    const self = this;
    if (typeof identifier !== "undefined") {
        self.autoLoad(identifier);
    }

    self.getTypeName = function () {
        return SSITypes.TRANSFER_SSI;
    }

    self.initialize = function (dlDomain, newPublicKey, timestamp, signature, vn, hint, callback) {
        if (typeof vn === "function") {
            callback = vn;
            vn = "v0";
        }
        if (typeof hint === "function") {
            callback = hint;
            hint = undefined;
        }

        self.load(SSITypes.TRANSFER_SSI, dlDomain, newPublicKey, `${timestamp}/${signature}`, vn, hint);

        if (callback) {
            callback(undefined, self);
        }

        self.initialize = function () {
            throw Error("KeySSI already initialized");
        };
    };

    self.getPublicKeyHash = function () {
        return self.getSpecificString();
    };

    self.getTimestamp = function () {
        let control = self.getControlString();
        return control.split("/")[0];
    }

    self.getSignature = function (encoding) {
        if (typeof encoding === "undefined") {
            encoding = "base64";
        }
        let control = self.getControlString();
        let splitControl = control.split("/");
        let signature = splitControl[1];
        if (encoding === "raw") {
            const base64Decode = cryptoRegistry.getBase64DecodingFunction(self);
            return base64Decode(signature);
        }
        return signature;
    }

    self.getPublicKey = (options) => {
        let publicKey = cryptoRegistry.getBase64DecodingFunction(self)(self.getSpecificString());
        return cryptoRegistry.getConvertPublicKeyFunction(self)(publicKey, options);
    };

    self.getDataToSign = function (anchorSSI, previousAnchorValue) {
        if (typeof anchorSSI === "string") {
            anchorSSI = keySSIFactory.create(anchorSSI);
        }

        if (typeof previousAnchorValue === "string") {
            previousAnchorValue = keySSIFactory.create(previousAnchorValue);
        }

        let previousIdentifier = '';
        const timestamp = self.getTimestamp();
        if (previousAnchorValue) {
            previousIdentifier = previousAnchorValue.getIdentifier(true);
        }
        return anchorSSI.getIdentifier(true) + self.getSpecificString() + previousIdentifier + timestamp;
    }

    self.isTransfer = function () {
        return true;
    }
}

function createTransferSSI(enclave, identifier) {
    return new TransferSSI(enclave, identifier);
}

module.exports = {
    createTransferSSI
};

},{"../../CryptoAlgorithms/CryptoAlgorithmsRegistry":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/key-ssi-resolver/lib/CryptoAlgorithms/CryptoAlgorithmsRegistry.js","../KeySSIFactory":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/key-ssi-resolver/lib/KeySSIs/KeySSIFactory.js","../KeySSIMixin":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/key-ssi-resolver/lib/KeySSIs/KeySSIMixin.js","../SSITypes":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/key-ssi-resolver/lib/KeySSIs/SSITypes.js"}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/key-ssi-resolver/lib/KeySSIs/constants.js":[function(require,module,exports){
module.exports = {
    DSU_VERSION_KEY: "dsuVersion",
    EMBEDDED_DATA_KEY: "embedded"
}
},{}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/key-ssi-resolver/lib/dsu/LegacyDSU.js":[function(require,module,exports){
let DSUSIntaceNo = 0;
let BatchInstacesNo = 0;

function LegacyDSU(bar, dsuInstancesRegistry) {
    let opendsu = require("opendsu");
    let keySSISpace = opendsu.loadAPI("keyssi");
    const resolver = opendsu.loadAPI("resolver");
    let instanceUid = "DSU NOT Ready";
    let dsuAnchorId = keySSISpace.parse(bar.getAnchorIdSync()).getIdentifier(true);

    this.getInstanceUID = () => {
        if (instanceUid == "DSU NOT Ready") {
            DSUSIntaceNo++
            instanceUid = `DSU${DSUSIntaceNo}`;
        }
        return instanceUid;
    }

    this.getAnchorIdSync = () => {
        return dsuAnchorId;
    }

    this.getAnchorId = (callback) => {
        bar.getAnchorId(callback);
    }

    $$.debug.logDSUEvent(this, "created");

    let inProgressBatches = new Set();

    const convertUpdateFnToAsync = (updateFn, ...args) => {
        if (!this.batchInProgress()) {
            throw Error("No batch has been started");
        }

        return $$.promisify(updateFn)(...args);
    }

    this.setBarInstance = (_barInstance) => {
        bar = _barInstance;
        $$.debug.logDSUEvent(this, "bar instance set");
    }

    this.getBarInstance = () => {
        return bar;
    }

    this.load = (callback) => {
        bar.load(callback);
    }

    this.loadAsync = async () => {
        return convertUpdateFnToAsync(this.load);
    }

    this.hasNewVersion = (callback) => {
        bar.hasNewVersion(callback);
    }

    this.loadVersion = (versionHash, callback) => {
        bar.loadVersion(versionHash, callback);
    }

    this.loadVersionAsync = async (versionHash) => {
        return convertUpdateFnToAsync(this.loadVersion, versionHash);
    }

    this.getLastHashLinkSSI = (callback) => {
        bar.getLastHashLinkSSI(callback);
    }

    this.getLastHashLinkSSIAsync = async (...args) => {
        return $$.promisify(this.getLastHashLinkSSI, this)(...args);
    }

    this.getLatestAnchoredHashLink = (callback) => {
        bar.getLatestAnchoredHashLink(callback);
    }

    this.getLatestAnchoredHashLinkAsync = async (...args) => {
        return $$.promisify(this.getLatestAnchoredHashLink, this)(...args);
    }

    this.getCurrentAnchoredHashLink = (callback) => {
        bar.getCurrentAnchoredHashLink(callback);
    }

    this.getCurrentAnchoredHashLinkAsync = async (...args) => {
        return $$.promisify(this.getCurrentAnchoredHashLink, this)(...args);
    }

    this.getKeySSI = (keySSIType, callback) => {
        bar.getKeySSI(keySSIType, callback);
    }

    this.getKeySSIAsync = async (keySSIType) => {
        return $$.promisify(this.getKeySSI, this)(keySSIType);
    }

    this.getKeySSIAsObject = (keySSIType, callback) => {
        bar.getKeySSIAsObject(keySSIType, callback);
    }

    this.getKeySSIAsObjectAsync = async (keySSIType) => {
        return $$.promisify(this.getKeySSIAsObject, this)(keySSIType);
    }

    this.getKeySSIAsString = (keySSIType, callback) => {
        bar.getKeySSIAsString(keySSIType, callback);
    }

    this.getKeySSIAsStringAsync = async (keySSIType) => {
        return $$.promisify(this.getKeySSIAsString, this)(keySSIType);
    }

    this.getCreationSSI = (plain) => {
        return bar.getCreationSSI(plain);
    }

    this.getUniqueIdAsync = async () => {
        return await bar.getUniqueIdAsync();
    }


    this.addFiles = (files, barPath, options, callback) => {
        preventUpdateOutsideBatch(bar.addFiles, files, barPath, options, callback);
    }

    this.addFilesAsync = async (files, barPath, options) => {
        return convertUpdateFnToAsync(this.addFiles, files, barPath, options);
    }

    this.appendToFile = (barPath, data, options, callback) => {
        preventUpdateOutsideBatch(bar.appendToFile, barPath, data, options, callback);
    }

    this.appendToFileAsync = async (barPath, data, options) => {
        return convertUpdateFnToAsync(this.appendToFile, barPath, data, options);
    }

    this.dsuLog = (message, callback) => {
        bar.dsuLog(message, callback);
        // preventUpdateOutsideBatch(bar.dsuLog, message, callback);
    }

    this.dsuLogAsync = async (message) => {
        return convertUpdateFnToAsync(this.dsuLog, message);
    }

    this.setValidationRules = (rules) => {
        bar.setValidationRules(rules);
    }

    this.setAnchoringEventListener = (listener) => {
        bar.setAnchoringEventListener(listener);
    }

    this.setDecisionCallback = (callback) => {
        bar.setDecisionCallback(callback);
    }

    this.getAnchoringStrategy = () => {
        return bar.getAnchoringStrategy();
    }

    this.addFolder = (fsFolderPath, barPath, options, callback) => {
        if (typeof options === "function") {
            callback = options;
            options = undefined;
        }

        preventUpdateOutsideBatch(bar.addFolder, fsFolderPath, barPath, options, callback);
    }

    this.addFolderAsync = async (fsFolderPath, barPath, options) => {
        return convertUpdateFnToAsync(this.addFolder, fsFolderPath, barPath, options);
    }

    this.addFile = (fsFilePath, barPath, options, callback) => {
        if (typeof options === "function") {
            callback = options;
            options = undefined;
        }

        preventUpdateOutsideBatch(bar.addFile, fsFilePath, barPath, options, callback);
    }

    this.addFileAsync = async (fsFilePath, barPath, options) => {
        return convertUpdateFnToAsync(this.addFile, fsFilePath, barPath, options);
    }

    this.readFile = (fileBarPath, options, callback) => {
        bar.readFile(fileBarPath, options, callback)
    }

    this.readFileAsync = async (...args) => {
        return $$.promisify(this.readFile, this)(...args);
    }

    this.createReadStream = (fileBarPath, options, callback) => {
        bar.createReadStream(fileBarPath, options, callback);
    }

    this.createReadStreamAsync = async (...args) => {
        return $$.promisify(this.createReadStream, this)(...args);
    }

    this.createBigFileReadStreamWithRange = (fileBarPath, range, options, callback) => {
        bar.createBigFileReadStreamWithRange(fileBarPath, range, options, callback);
    }

    this.createBigFileReadStreamWithRangeAsync = async (...args) => {
        return $$.promisify(this.createBigFileReadStreamWithRange, this)(...args);
    }

    this.extractFolder = (fsFolderPath, barPath, options, callback) => {
        bar.extractFolder(fsFolderPath, barPath, options, callback);
    }

    this.extractFolderAsync = async (...args) => {
        return $$.promisify(this.extractFolder, this)(...args);
    }

    this.extractFile = (fsFilePath, barPath, options, callback) => {
        bar.extractFile(fsFilePath, barPath, options, callback);
    }

    this.extractFileAsync = async (...args) => {
        return $$.promisify(this.extractFile, this)(...args);
    }

    const preventUpdateOutsideBatch = (updateFn, ...args) => {
        if ($$.LEGACY_BEHAVIOUR_ENABLED) {
            return updateFn(...args);
        }

        if (!this.batchInProgress()) {
            const callback = args.pop();
            return callback(Error("Batch not started. Use safeBeginBatch() or safeBeginBatchAsync before calling this method."));
        }

        updateFn(...args);
    }

    this.writeFile = (path, data, options, callback) => {
        if (typeof data === "function") {
            callback = data;
            data = undefined;
            options = undefined;
        }

        if (typeof options === "function") {
            callback = options;
            options = undefined;
        }

        preventUpdateOutsideBatch(bar.writeFile, path, data, options, callback);
    }

    this.writeFileAsync = async (path, data, options) => {
        return convertUpdateFnToAsync(this.writeFile, path, data, options);
    }

    this.embedFile = (path, data, options, callback) => {
        if (typeof data === "function") {
            callback = data;
            data = undefined;
            options = undefined;
        }

        if (typeof options === "function") {
            callback = options;
            options = undefined;
        }

        preventUpdateOutsideBatch(bar.embedFile, path, data, options, callback);
    }

    this.embedFileAsync = async (path, data, options) => {
        return convertUpdateFnToAsync(this.embedFile, path, data, options);
    }

    this.writeFileFromBricks = (path, bricks, options, callback) => {
        bar.writeFileFromBricks(path, bricks, options, callback);
    }

    this.writeFileFromBricksAsync = async (path, bricks, options) => {
        return convertUpdateFnToAsync(this.writeFileFromBricks, path, bricks, options);
    }

    this.appendBigFileBrick = (path, newSizeSSI, brick, options, callback) => {
        if (typeof options === "function") {
            callback = options;
            options = undefined;
        }

        preventUpdateOutsideBatch(bar.appendBigFileBrick, path, newSizeSSI, brick, options, callback);
    }

    this.appendBigFileBrickAsync = async (path, newSizeSSI, brick, options) => {
        return convertUpdateFnToAsync(this.appendBigFileBrick, path, newSizeSSI, brick, options);
    }

    this.getBigFileBricksMeta = (path, options, callback) => {
        bar.getBigFileBricksMeta(path, options, callback)
    }

    this.delete = (path, options, callback) => {
        if (typeof options === "function") {
            callback = options;
            options = undefined;
        }

        preventUpdateOutsideBatch(bar.delete, path, options, callback);
    }

    this.deleteAsync = async (path, options) => {
        return convertUpdateFnToAsync(this.delete, path, options);
    }

    this.rename = (srcPath, dstPath, options, callback) => {
        if (typeof options === "function") {
            callback = options;
            options = undefined;
        }

        preventUpdateOutsideBatch(bar.rename, srcPath, dstPath, options, callback);
    }

    this.renameAsync = async (srcPath, dstPath, options) => {
        return convertUpdateFnToAsync(this.rename, srcPath, dstPath, options);
    }

    this.listFiles = (path, options, callback) => {
        bar.listFiles(path, options, callback);
    }

    this.listFolders = (path, options, callback) => {
        bar.listFolders(path, options, callback);
    }

    this.createFolder = (barPath, options, callback) => {
        if (typeof options === "function") {
            callback = options;
            options = undefined;
        }

        preventUpdateOutsideBatch(bar.createFolder, barPath, options, callback);
    }

    this.createFolderAsync = async (barPath, options) => {
        return convertUpdateFnToAsync(this.createFolder, barPath, options);
    }

    this.readDir = (folderPath, options, callback) => {
        bar.readDir(folderPath, options, callback);
    }

    this.readDirAsync = async (...args) => {
        return $$.promisify(this.readDir, this)(...args);
    }

    this.cloneFolder = (srcPath, destPath, options, callback) => {
        if (typeof options === "function") {
            callback = options;
            options = undefined;
        }

        preventUpdateOutsideBatch(bar.cloneFolder, srcPath, destPath, options, callback);
    }

    this.cloneFolderAsync = async (srcPath, destPath, options) => {
        return convertUpdateFnToAsync(this.cloneFolder, srcPath, destPath, options);
    }

    this.mount = (path, archiveSSI, options, callback) => {
        if (typeof options === "function") {
            callback = options;
            options = undefined;
        }

        preventUpdateOutsideBatch(bar.mount, path, archiveSSI, options, callback);
    }

    this.mountAsync = async (path, archiveSSI, options) => {
        return convertUpdateFnToAsync(this.mount, path, archiveSSI, options);
    }

    this.unmount = (path, callback) => {
        preventUpdateOutsideBatch(bar.unmount, path, callback);
    };

    this.unmountAsync = async (path) => {
        return convertUpdateFnToAsync(this.unmount, path);
    }

    this.listMountedDSUs = (path, callback) => {
        bar.listMountedDSUs(path, callback);
    };

    this.listMountedDSUsAsync = async (...args) => {
        return $$.promisify(this.listMountedDSUs, this)(...args);
    }

    this.listMountedDossiers = this.listMountedDSUs;

    this.hasUnanchoredChanges = (callback) => {
        bar.hasUnanchoredChanges(callback);
    }

    this.hasUnanchoredChangesAsync = async (...args) => {
        return $$.promisify(this.hasUnanchoredChanges, this)(...args);
    }

    this.getArchiveForPath = (path, callback) => {
        bar.getArchiveForPath(path, callback);
    }

    this.getArchiveForPathAsync = async (...args) => {
        return $$.promisify(this.getArchiveForPath, this)(...args);
    }

    this.stat = (path, callback) => {
        bar.stat(path, callback);
    }

    this.statAsync = async (...args) => {
        return $$.promisify(this.stat, this)(...args);
    }

    let _beginBatch = (isVirtual, callback) => {
        let initBatch = (isVirtualBeginBatch)=>{
            try{
                if(!isVirtualBeginBatch) {
                    this.beginBatchAsync().then((batchId) => {
                        return callback(undefined, batchId);
                    }).catch((err) => {
                        return callback(err);
                    });
                } else {
                    return startVirtualBatch(callback);
                }
            }catch(err){
                return callback(err);
            }
        }

        let anchorId = dsuAnchorId;
        if(dsuInstancesRegistry.isLocked(anchorId)){
            dsuInstancesRegistry.waitUntilCanBeginBatch(anchorId, initBatch, this);
            return;
        }

        initBatch(isVirtual);
    }

    let startVirtualBatch = (callback) => {
        let attachedBatchId = generateBatchId(true);
        inProgressBatches.add(attachedBatchId);
        $$.debug.logDSUEvent(this, "Virtual batch started", attachedBatchId);
        return callback(undefined, attachedBatchId);
    }

    const atLeastOneMountedDSUIsInBatchMode = async () => {
        const keySSISpace = require("opendsu").loadAPI("keyssi");
        const mountedDSUs = await $$.promisify(this.listMountedDSUs)("/");
        for (const mountedDSU of mountedDSUs) {
            const anchorId = await $$.promisify(keySSISpace.parse(mountedDSU.identifier).getAnchorId)(true);
            if (dsuInstancesRegistry.batchInProgress(anchorId)) {
                return true;
            }
        }
        return false;
    }

    const parentDSUIsInBatchMode = async () => {
        const anchorId = this.getAnchorIdSync();
        const instances = dsuInstancesRegistry.getAllInstances();
        for (let dsuInstance of instances) {
            if (dsuInstance.batchInProgress()) {
                const mountedDSUs = await $$.promisify(dsuInstance.listMountedDSUs)("/");
                for (const mountedDSU of mountedDSUs) {
                    const mountedDSUAnchorId = await $$.promisify(keySSISpace.parse(mountedDSU.identifier).getAnchorId)(true);
                    if (mountedDSUAnchorId === anchorId) {
                        return true;
                    }
                }
            }
        }

        return false;
    }

    this.safeBeginBatch = (wait, callback) => {
        $$.debug.logDSUEvent(this, "safeBeginBatch called", wait);
        if (typeof wait === "function") {
            callback = wait;
            wait = false;
        }
        if (bar.batchInProgress()) {
            console.warn(Error("This DSU instance is already in batch mode when called safeBeginBatch!"));
            return startVirtualBatch(callback);
        }

        let _safeBeginBatch = (isVirtual) => {
            let {
                testIfRecoveryActiveFor
            } = opendsu.loadApi("anchoring").getAnchoringX();

            if(testIfRecoveryActiveFor(dsuAnchorId)){
                return _beginBatch(isVirtual, callback);
            }

            this.refresh((err)=>{
                if(err){
                    return callback(err);
                }
                return _beginBatch(isVirtual, callback);
            });
        }

        if (dsuInstancesRegistry.batchInProgress(this.getAnchorIdSync())) {
            if (wait) {
                dsuInstancesRegistry.waitUntilCanBeginBatch(dsuAnchorId, _safeBeginBatch, this);
                return;
            }
            return callback(Error("Another DSU instance is already in batch mode. Please wait for it to finish."));
        }

        _safeBeginBatch();
    }
    this.safeBeginBatchAsync = async (...args) => {
        return $$.promisify(this.safeBeginBatch, this)(...args);
    }

    this.startOrAttachBatch = (callback) => {
        $$.debug.logDSUEvent(this, "startOrAttachBatch called");
        console.debug("startOrAttachBatch called");
        if (!this.batchInProgress && dsuInstancesRegistry.batchInProgress(this.getAnchorIdSync())) {
            return callback(Error("Another instance of the LegacyDSU is currently in batch."));
        }
        this.getKeySSIAsObject((err, keySSI) => {
            if (err) {
                return callback(err);
            }

            if (keySSI.getFamilyName() === opendsu.constants.KEY_SSI_FAMILIES.CONST_SSI) {
                return resolver.dsuExists(keySSI, (err, exists) => {
                    if (err) {
                        return callback(err);
                    }

                    if (exists) {
                        return callback(Error("An anchored ConstDSU cannot be put in batch mode."));
                    }

                    if (!this.batchInProgress()) {
                        return this.beginBatch(callback);
                    }

                    if (dsuInstancesRegistry.batchInProgress(this.getAnchorIdSync())) {
                        return callback(Error("Another instance of the LegacyDSU is currently in batch."));
                    }

                    return _beginBatch(false, callback);
                })
            }
        });

        if(this.batchInProgress()){
            return startVirtualBatch(callback);
        }

        return _beginBatch(false, callback);
    }

    this.startOrAttachBatchAsync = async () => {
        return $$.promisify(this.startOrAttachBatch, this)();
    }

    function generateBatchId(isVirtual){
        BatchInstacesNo++;
        if(isVirtual){
            return `VB:${BatchInstacesNo}`
        } else {
            return `RB:${BatchInstacesNo}`
        }
    }

    this.beginBatch = () => {
        console.info("Synchronous version of beginBatch will be removed in the future (2025). Please use safeBeginBatch or safeBeginBatchAsync instead");
        let anchorId = dsuAnchorId;
        if(dsuInstancesRegistry.isLocked(anchorId)){
            console.trace("anchor is Locked");
            throw Error(`AnchorId is locked`);
        }
        bar.beginBatch();
        const batchId = generateBatchId(false);
        inProgressBatches.add(batchId);
        $$.debug.logDSUEvent(this, "Real batch started", batchId);
        console.debug(`Real batch started ${batchId}`);
        return batchId;
    }

    this.beginBatchAsync = async () => {
        let anchorId = dsuAnchorId;
        if(dsuInstancesRegistry.isLocked(anchorId)){
            console.trace("anchor is Locked");
            throw Error(`AnchorId is locked`);
        }
        const isMountedDSUInBatchMode = await atLeastOneMountedDSUIsInBatchMode();
        if (isMountedDSUInBatchMode) {
            throw Error("At least one mounted DSU is in batch mode");
        }

        if (await parentDSUIsInBatchMode()) {
            throw Error("Parent DSU is in batch mode");
        }
        bar.beginBatch();
        const batchId = generateBatchId(false);
        inProgressBatches.add(batchId);
        $$.debug.logDSUEvent(this, "Real batch started", batchId);
        console.debug(`Real batch started ${batchId}`);
        return batchId;
    }

    this.batch = async (batch, callback) => {
        bar.batch(batch, callback);
        /*let error, batchResult, batchId;
        try{
            batchId = await this.startOrAttachBatchAsync();
            let batchMethod = $$.promisify(bar.batch, bar);
            batchResult = await batchMethod(batch);
            await this.commitBatchAsync(batchId);
        }catch(err){
            error = err;
            await this.cancelBatchAsync(batchId);
        }

        callback(error, batchResult);*/
    }

    this.batchInProgress = () => {
        return !!inProgressBatches.size;
    }

    this.cancelBatch = (batchId, callback) => {

        if(typeof batchId === "function"){
            callback = batchId;
            batchId = undefined;
        }

        if(inProgressBatches.size === 0){
            console.warn(Error("Unable to cancel a batch that seems to not be in batch mode"));
            return callback(undefined, undefined);
        }

        if(!batchId && inProgressBatches.size > 1){
            console.warn(Error("Cancel batch was called without batchId"));            
            return callback(undefined, undefined);
        }

        if(!batchId && inProgressBatches.size === 1){
            inProgressBatches.clear();
        }

        if(batchId){
            if(inProgressBatches.has(batchId)){
                inProgressBatches.delete(batchId);
                if(inProgressBatches.size){
                    return callback(Error("Unable to cancel because of another attached batch is in progress."));
                }
            }else{
                return callback(Error("Invalid batchId"));
            }
        }
        let anchorId = dsuAnchorId;
        try{
            $$.debug.logDSUEvent(this, "lockAnchorId in cancelBatch");
            dsuInstancesRegistry.lockAnchorId(anchorId, this);
        }catch(err){
            return callback(Error("Failed to lock before commit batch"));
        }
        bar.cancelBatch(err => {
            if (err) {
                $$.debug.logDSUEvent(this, "unlockAnchorId in cancelBatch because of error", err);
                dsuInstancesRegistry.unlockAnchorId(anchorId);
                return callback(err);
            }
            dsuInstancesRegistry.notifyBatchCancelled(dsuAnchorId, (...args)=>{
                $$.debug.logDSUEvent(this, "unlockAnchorId in cancelBatch");
                dsuInstancesRegistry.unlockAnchorId(anchorId);
                callback(...args);
            });
        });
    }

    this.cancelBatchAsync = async (...args) => {
        return $$.promisify(this.cancelBatch, this)(...args);
    }

    this.setMergeConflictsHandler = (handler) => {
        bar.setMergeConflictsHandler(handler);
    }

    this.commitBatch = (onConflict, batchId, callback) => {
        let args = [];

        if(onConflict) {
            args.push(onConflict);
        }

        if(batchId){
            args.push(batchId);
        }

        if(callback){
            args.push(callback);
        }

        switch(args.length){
            case 3:
                break;
            case 2:
                callback = args[1];
                if(typeof onConflict === "function"){
                    batchId = undefined;
                }else{
                    onConflict = undefined;
                    batchId = args[0];
                }
                break;
            case 1:
                callback = args[0];
                onConflict = undefined;
                batchId = undefined;
                break;
            default:
                throw Error("Wrong api usage");
        }

        if(inProgressBatches.size === 0){
            return callback(Error("Unable to commit a batch that seems to don't be in batch mode"));
        }

        if(!batchId && inProgressBatches.size > 1){
            return callback(Error("startOrAttachBatch mode is active but commit batch was called without batchId."));
        }

        if(!batchId && inProgressBatches.size === 1){
            console.log("Possible dev error: forgot to pass the batchId on the commit method");
            inProgressBatches.clear();
        }

        if(batchId){
            if(inProgressBatches.has(batchId)){
                inProgressBatches.delete(batchId);
                if(inProgressBatches.size){
                    console.debug(`Closing attachedBatch ${batchId}`);
                    $$.debug.logDSUEvent(this, "Closing attachedBatch", batchId);
                    return callback();
                }
            }else{
                $$.debug.logDSUEvent(this, "Invalid batchId", batchId);
                return callback(Error("Invalid batchId"));
            }
        }

        let anchorId = dsuAnchorId;
        try{
            dsuInstancesRegistry.lockAnchorId(anchorId, this);
            $$.debug.logDSUEvent(this, "lockAnchorId in commitBatch", batchId);
        }catch(err){
            $$.debug.logDSUEvent(this, "\"Failed to lock before commit batch\"", batchId);
            return callback(Error("Failed to lock before commit batch"));
        }

        if(inProgressBatches.size){
            console.trace("Status of in progress batches", inProgressBatches.size);
        }
        console.debug(`Closing batch ${batchId}`);
        bar.commitBatch(onConflict, err => {
            if (err) {
                return dsuInstancesRegistry.notifyBatchCommitted(dsuAnchorId, (error)=>{
                    //we log this second error because we want to exit with the first one...
                    if(error){
                        console.log("Caught an error when notifying other LegacyDSU instances", error);
                    }
                    dsuInstancesRegistry.unlockAnchorId(anchorId);
                    $$.debug.logDSUEvent(this, "unlockAnchorId in commitBatch because of error in notifying other bars", batchId, err);
                    return callback(err);
                });
            }

            dsuInstancesRegistry.notifyBatchCommitted(dsuAnchorId, (...args)=>{
                dsuInstancesRegistry.unlockAnchorId(anchorId);
                $$.debug.logDSUEvent(this, "unlockAnchorId in commitBatch", batchId);
                setTimeout(this.notifyOnCommitBatch, 0);
                callback(...args);
            });
        });
    };

    this.commitBatchAsync = async (...args) => {
        return convertUpdateFnToAsync(this.commitBatch, ...args);
    }

    this.refresh = (callback) => {
        $$.debug.logDSUEvent(this, "Refresh called", `${inProgressBatches.size} batches in progress`);
        if(inProgressBatches.size >= 1){
             console.warn(Error("DSU is in batch mode. Refresh was not possible"));
             console.log(Array.from(inProgressBatches));
             $$.debug.status();
             return callback(undefined, undefined);
        }

        bar.getKeySSIAsObject((err, keySSI)=>{
            if(err){
                return callback(err);
            }

            const anchoring = require("opendsu").loadApi("anchoring").getAnchoringX();
            return anchoring.getAllVersions(keySSI, (err, versions)=>{
                if(err){
                    return callback(err);
                }
                if(versions.length !== 0){
                    return dsuInstancesRegistry.loadNewBarInstance(bar, (err, newInstance)=>{
                        if(err){
                            return callback(err);
                        }
                        bar = newInstance;
                        return callback(undefined, bar);
                    });
                }
                callback(undefined, bar);
            });
        });
    };

    this.refreshAsync = async () => {
        return $$.promisify(this.refresh, this)();
    }

    this.getSSIForMount = (mountPoint, callback) => {
        bar.getSSIForMount(mountPoint, callback);
    }

    let listeners = new Set();
    this.onCommitBatch = (notify, once)=>{
        if(typeof notify !== "function"){
            throw Error("Not a function");
        }

        if(typeof once === "undefined"){
            once = true;
        }

        listeners.add({notify, once});
    }

    this.notifyOnCommitBatch = ()=>{
        let numberOfListeners = listeners.size;
        numberOfListeners = numberOfListeners? "but no": numberOfListeners

        $$.debug.logDSUEvent(this, "notifyOnCommitBatch   ", numberOfListeners , " listeners");
        let clonedListeners = new Set(listeners);

        clonedListeners.forEach((listener)=>{
            let observer = listener;
            if(observer){
                let {notify, once} = observer;
                if(once){
                    listeners.delete(listener);
                }
                notify();
            }
        })
    }

    return this;
}

module.exports = LegacyDSU;
},{"opendsu":"opendsu"}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/key-ssi-resolver/lib/dsu/VersionlessDSU.js":[function(require,module,exports){
const VersionlessDSUController = require("./VersionlessDSUController");
const DSU_ENTRY_TYPES = {
    FILE: "FILE",
    FOLDER: "FOLDER",
};

let BatchInstacesNo = 0;
function VersionlessDSU(config) {
    const { keySSI } = config;
    const keySSISpace = require("opendsu").loadAPI("keyssi");
    let keySSIString;
    let keySSIObject;
    if (typeof keySSI === "string") {
        keySSIString = keySSI;
        keySSIObject = keySSISpace.parse(keySSI);
    } else {
        keySSIString = keySSI.getIdentifier();
        keySSIObject = keySSI;
    }

    let refreshInProgress = false;
    let refreshPromise = Promise.resolve();

    const controllerConfig = {
        keySSIString,
        keySSIObject,
    };
    const versionlessDSUController = new VersionlessDSUController(this, controllerConfig);

    const pskPath = require("swarmutils").path;

    const processPath = (path) => {
        path = pskPath.normalize(path);
        if (path.startsWith("/")) {
            path = path.substring(1);
        }
        return path;
    };

    function generateBatchId(isVirtual){
        BatchInstacesNo++;
        if(isVirtual){
            return `VB:${BatchInstacesNo}`
        } else {
            return `RB:${BatchInstacesNo}`
        }
    }

    /**
     * This function waits for an existing "refresh" operation to finish
     * before executing the `callback`.
     * If no refresh operation is in progress, the `callback` is executed
     * immediately.
     * This function is called by the public methods in order to prevent
     * calling methods on possible outdated content (content before reload)
     *
     * @param {function} callback
     */
    const waitIfDSUIsRefreshing = (callback) => {
        if (refreshInProgress === false) {
            return callback();
        }

        refreshPromise.then(() => {
            callback();
        });
    };

    const executeMountAwareOperation = ({ path, options, onIgnoreMounts, checkReadonly, onMountCallback }) => {
        if (!options) {
            options = { ignoreMounts: false };
        }
        if (checkReadonly !== false) {
            checkReadonly = true;
        }

        waitIfDSUIsRefreshing(() => {
            if (options.ignoreMounts) {
                onIgnoreMounts();
            } else {
                this.getArchiveForPath(path, (err, archiveContext) => {
                    if (err) {
                        return OpenDSUSafeCallback(onMountCallback)(
                            createOpenDSUErrorWrapper(`Failed to load DSU instance mounted at path ${path}`, err)
                        );
                    }

                    if (checkReadonly && archiveContext.readonly === true) {
                        return onMountCallback(Error("Tried to write in a readonly mounted RawDossier"));
                    }

                    let onMountCallbackOptions = {
                        options: { ...options, ignoreMounts: true },
                        archive: archiveContext.archive,
                        relativePath: archiveContext.relativePath,
                        prefixPath: archiveContext.prefixPath,
                    };
                    onMountCallback(undefined, onMountCallbackOptions);
                });
            }
        });
    };

    const getSaneCallbackFunction = (...args) => {
        for (let i = args.length - 1; i >= 0; i--) {
            if (typeof args[i] === "function") {
                return $$.makeSaneCallback(args[i]);
            }
        }
        throw new Error("No callback argument found!");
    };

    this.init = (callback) => {
        callback = $$.makeSaneCallback(callback);
        const controllerCallback = (error) => {
            if (error) {
                return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to create versionless DSU`, error));
            }

            // return VersionlessDSU instance
            callback(null, this);
        };
        versionlessDSUController.createDSU(controllerCallback);
    };

    this.load = (callback) => {
        callback = $$.makeSaneCallback(callback);
        const controllerCallback = (error) => {
            if (error) {
                return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to get versionless DSU`, error));
            }

            // return VersionlessDSU instance
            callback(null, this);
        };

        versionlessDSUController.loadDSU(controllerCallback);
    };

    this.loadVersion = (versionHash, callback) => {
        callback("NotApplicableForVersionlessDSU");
    };
    this.getBrickMapController = () => {
        throw new Error("NotApplicableForVersionlessDSU");
    };

    this.refresh = (callback) => {
        callback = $$.makeSaneCallback(callback);
        waitIfDSUIsRefreshing(() => {
            refreshInProgress = true;
            refreshPromise = refreshPromise.then(() => {
                return new Promise((resolve) => {
                    this.load((err) => {
                        if (err) {
                            refreshInProgress = false;
                            return resolve(OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper("Failed to load DSU", err)));
                        }

                        resolve(callback());
                    });
                }).catch(() => {
                    console.trace("This shouldn't happen. Refresh errors should have been already caught");
                });
            });
        });
    };

    this.getLastHashLinkSSI = (callback) => {
        console.log("This method is obsolete. Please use `dsu.getLatestAnchoredHashLink()` instead.");
        return this.getLatestAnchoredHashLink(callback);
    };

    this.getLatestAnchoredHashLink = (callback) => {
        // required for opendsu resolver loader
        return this.getKeySSIAsObject(callback);
    };

    this.getCurrentAnchoredHashLink = (callback) => {
        // required for opendsu resolver loader
        return this.getKeySSIAsObject(callback);
    };

    this.getKeySSI = (keySSIType, callback) => {
        console.trace("Obsolete function: use getKeySSIAsString or getKeySSIAsObject Instead");
        this.getKeySSIAsObject(keySSIType, callback);
    };

    this.getKeySSIAsObject = (keySSIType, callback) => {
        if (typeof keySSIType === "function") {
            callback = keySSIType;
        }
        callback = $$.makeSaneCallback(callback);
        callback(undefined, keySSIObject);
    };

    this.getKeySSIAsString = (keySSIType, callback) => {
        if (typeof keySSIType === "function") {
            callback = keySSIType;
        }
        callback = $$.makeSaneCallback(callback);
        callback(undefined, keySSIString);
    };

    this.getCreationSSI = (plain) => {
        return keySSIObject.getIdentifier(plain);
    };

    /**
     * @param {string} path
     * @param {string|$$.Buffer|stream.ReadableStream} data
     * @param {callback} callback
     */
    this.appendToFile = (path, data, options, callback) => {
        const defaultOpts = { encrypt: true, ignoreMounts: false };
        if (typeof options === "function") {
            callback = options;
            options = {};
        }

        callback = $$.makeSaneCallback(callback);
        options = Object.assign(defaultOpts, options);

        executeMountAwareOperation({
            path,
            options,
            onIgnoreMounts: () => {
                versionlessDSUController.appendToFile(path, data, options, callback);
            },
            onMountCallback: (error, { options, archive, relativePath }) => {
                if (error) {
                    return callback(error);
                }
                archive.appendToFile(relativePath, data, options, callback);
            },
        });
    };

    this.dsuLog = (message, callback) => {
        this.appendToFile("/dsu-metadata-log", message + "\n", { ignoreMissing: true }, callback);
    };

    /**
     * @param {object} rules
     * @param {object} rules.preWrite
     * @param {object} rules.afterLoad
     */
    this.setValidationRules = () => {
        throw Error("NotApplicableForVersionlessDSU");
    };

    this.setAnchoringEventListener = () => {
        throw new Error("NotApplicableForVersionlessDSU");
    };

    this.setDecisionCallback = (callback) => {
        callback("NotApplicableForVersionlessDSU");
    };

    this.getAnchoringStrategy = () => {
        throw new Error("NotApplicableForVersionlessDSU");
    };

    this.doAnchoring = (callback) => {
        callback("NotApplicableForVersionlessDSU");
    };

    this.getSSIForMount = (mountPoint, callback) => {
        callback = $$.makeSaneCallback(callback);
        waitIfDSUIsRefreshing(() => {
            versionlessDSUController.getSSIForMount(mountPoint, callback);
        });
    };

    this.addFolder = (folderPath, basePath, options, callback) => {
        const defaultOpts = {
            encrypt: true,
            ignoreMounts: false,
            embedded: false,
        };
        if (typeof options === "function") {
            callback = options;
            options = {};
        }

        callback = $$.makeSaneCallback(callback);
        options = Object.assign(defaultOpts, options);

        executeMountAwareOperation({
            path: basePath,
            options,
            onIgnoreMounts: () => {
                versionlessDSUController.addFolder(folderPath, basePath, options, callback);
            },
            onMountCallback: (error, { options, archive, relativePath }) => {
                if (error) {
                    return callback(error);
                }
                archive.addFolder(folderPath, relativePath, options, callback);
            },
        });
    };

    this.addFile = (filePath, destinationFilePath, options, callback) => {
        const defaultOpts = {
            encrypt: true,
            ignoreMounts: false,
            embedded: false,
        };
        if (typeof options === "function") {
            callback = options;
            options = {};
        }

        callback = $$.makeSaneCallback(callback);
        options = Object.assign(defaultOpts, options);

        executeMountAwareOperation({
            path: destinationFilePath,
            options,
            onIgnoreMounts: () => {
                versionlessDSUController.addFile(filePath, destinationFilePath, options, callback);
            },
            onMountCallback: (error, { options, archive, relativePath }) => {
                if (error) {
                    return callback(error);
                }
                archive.addFile(filePath, relativePath, options, callback);
            },
        });
    };

    this.addFiles = (filePaths, basePath, options, callback) => {
        const defaultOpts = {
            encrypt: true,
            ignoreMounts: false,
            embedded: false,
        };
        if (typeof options === "function") {
            callback = options;
            options = {};
        }

        callback = $$.makeSaneCallback(callback);
        options = Object.assign(defaultOpts, options);

        executeMountAwareOperation({
            path: basePath,
            options,
            onIgnoreMounts: () => {
                versionlessDSUController.addFiles(filePaths, basePath, options, callback);
            },
            onMountCallback: (error, { options, archive, relativePath }) => {
                if (error) {
                    return callback(error);
                }
                archive.addFiles(filePaths, relativePath, options, callback);
            },
        });
    };

    this.readFile = (filePath, options, callback) => {
        const defaultOpts = { ignoreMounts: false };
        if (typeof options === "function") {
            callback = options;
            options = {};
        }

        callback = $$.makeSaneCallback(callback);
        options = Object.assign(defaultOpts, options);

        executeMountAwareOperation({
            path: filePath,
            options,
            onIgnoreMounts: () => {
                versionlessDSUController.readFile(filePath, callback);
            },
            checkReadonly: false,
            onMountCallback: (error, { options, archive, relativePath }) => {
                if (error) {
                    return callback(error);
                }
                archive.readFile(relativePath, options, callback);
            },
        });
    };

    this.createReadStream = (fileBarPath, options, callback) => {
        callback = getSaneCallbackFunction(fileBarPath, options, callback);
        callback("NotApplicableForVersionlessDSU");
    };

    this.createBigFileReadStreamWithRange = (fileBarPath, range, options, callback) => {
        callback = getSaneCallbackFunction(fileBarPath, range, options, callback);
        callback("NotApplicableForVersionlessDSU");
    };

    this.extractFolder = (fsFolderPath, barPath, options, callback) => {
        callback = getSaneCallbackFunction(fsFolderPath, barPath, options, callback);
        callback("NotImplemented");
    };

    this.extractFile = (fsDestinationFilePath, sourceFilePath, options, callback) => {
        waitIfDSUIsRefreshing(() => {
            const defaultOpts = { ignoreMounts: false };
            if (typeof options === "function") {
                callback = options;
                options = {};
            }

            callback = $$.makeSaneCallback(callback);
            options = Object.assign(defaultOpts, options);

            if (options.ignoreMounts === true) {
                versionlessDSUController.extractFile(fsDestinationFilePath, sourceFilePath, callback);
            } else {
                this.getArchiveForPath(sourceFilePath, (err, archiveContext) => {
                    if (err) {
                        return OpenDSUSafeCallback(callback)(
                            createOpenDSUErrorWrapper(`Failed to load DSU instance mounted at path ${sourceFilePath}`, err)
                        );
                    }

                    options.ignoreMounts = true;
                    archiveContext.archive.extractFile(fsDestinationFilePath, archiveContext.relativePath, options, callback);
                });
            }
        });
    };

    this.extractFolder = (fsDestinationFolderPath, sourceFolderPath, options, callback) => {
        waitIfDSUIsRefreshing(() => {
            const defaultOpts = { ignoreMounts: false };
            if (typeof options === "function") {
                callback = options;
                options = {};
            }

            callback = $$.makeSaneCallback(callback);
            options = Object.assign(defaultOpts, options);

            if (options.ignoreMounts === true) {
                versionlessDSUController.extractFolder(fsDestinationFolderPath, sourceFolderPath, callback);
            } else {
                this.getArchiveForPath(sourceFolderPath, (err, archiveContext) => {
                    if (err) {
                        return OpenDSUSafeCallback(callback)(
                            createOpenDSUErrorWrapper(`Failed to load DSU instance mounted at path ${sourceFolderPath}`, err)
                        );
                    }

                    options.ignoreMounts = true;
                    archiveContext.archive.extractFolder(fsDestinationFolderPath, archiveContext.relativePath, options, callback);
                });
            }
        });
    };

    this.writeFile = (path, data, options, callback) => {
        const defaultOpts = { encrypt: true, ignoreMounts: false, embed: false };
        if (typeof data === "function") {
            callback = data;
            data = undefined;
            options = undefined;
        }
        if (typeof options === "function") {
            callback = options;
            options = defaultOpts;
        }
        if (typeof options === "undefined") {
            options = defaultOpts;
        }

        callback = $$.makeSaneCallback(callback);
        options = Object.assign(defaultOpts, options);

        if (options.embed) {
            options.encrypt = false;
        }

        executeMountAwareOperation({
            path,
            options,
            onIgnoreMounts: () => {
                versionlessDSUController.writeFile(path, data, options, callback);
            },
            onMountCallback: (error, { options, archive, relativePath }) => {
                if (error) {
                    return callback(error);
                }
                archive.writeFile(relativePath, data, options, callback);
            },
        });
    };

    this.embedFile = (path, data, options, callback) => {
        this.writeFile(path, data, options, callback);
    };

    this.writeFileFromBricks = (path, bricks, options, callback) => {
        callback = getSaneCallbackFunction(path, bricks, options, callback);
        callback("NotApplicableForVersionlessDSU");
    };

    this.appendBigFileBrick = (path, newSizeSSI, brick, options, callback) => {
        callback = getSaneCallbackFunction(path, newSizeSSI, brick, options, callback);
        callback("NotApplicableForVersionlessDSU");
    };

    this.getBigFileBricksMeta = (path, options, callback) => {
        callback = getSaneCallbackFunction(path, options, callback);
        callback("NotApplicableForVersionlessDSU");
    };

    this.delete = (path, options, callback) => {
        const defaultOpts = { ignoreMounts: false, ignoreError: false };
        if (typeof options === "function") {
            callback = options;
            options = {};
        }

        callback = $$.makeSaneCallback(callback);
        options = Object.assign(defaultOpts, options);

        executeMountAwareOperation({
            path,
            options,
            onIgnoreMounts: () => {
                versionlessDSUController.delete(path, (err) => {
                    if (!err || (err && options.ignoreError)) {
                        return callback();
                    }

                    callback(err);
                });
            },
            onMountCallback: (error, { options, archive, relativePath }) => {
                if (error) {
                    return callback(error);
                }
                archive.delete(relativePath, options, callback);
            },
        });
    };

    this.rename = (srcPath, dstPath, options, callback) => {
        const defaultOpts = { ignoreMounts: false };
        if (typeof options === "function") {
            callback = options;
            options = {};
        }

        callback = $$.makeSaneCallback(callback);
        options = Object.assign(defaultOpts, options);

        executeMountAwareOperation({
            path: srcPath,
            options,
            onIgnoreMounts: () => {
                versionlessDSUController.rename(srcPath, dstPath, callback);
            },
            onMountCallback: (error, { options, archive, relativePath, prefixPath }) => {
                if (error) {
                    return callback(error);
                }
                this.getArchiveForPath(dstPath, (err, destinationArchiveContext) => {
                    if (err) {
                        return OpenDSUSafeCallback(callback)(
                            createOpenDSUErrorWrapper(`Failed to load DSU instance mounted at path ${dstPath}`, err)
                        );
                    }

                    if (destinationArchiveContext.prefixPath !== prefixPath) {
                        return callback(Error("Destination is invalid. Renaming must be done in the scope of the same dossier"));
                    }

                    archive.rename(relativePath, destinationArchiveContext.relativePath, options, callback);
                });
            },
        });
    };

    const listMountedEntries = async (dsuEntryType, mountPoints, callback) => {
        const results = [];
        const listEntriesAsync =
            dsuEntryType === DSU_ENTRY_TYPES.FOLDER
                ? $$.promisify(this.listFolders.bind(this))
                : $$.promisify(this.listFiles.bind(this));

        for (const mountPoint of mountPoints) {
            const mountPath = processPath(mountPoint.path);

            try {
                const mountPointEntries = await listEntriesAsync(mountPath, {
                    recursive: true,
                    ignoreMounts: false,
                });
                const mountPointEntryPaths = mountPointEntries.map((file) => {
                    let prefix = mountPath;
                    if (prefix[0] === "/") {
                        prefix = prefix.substring(1);
                    }

                    return processPath(`${prefix}/${file}`);
                });
                mountPointEntryPaths.forEach((path) => results.push(path));
            } catch (error) {
                const entryType = dsuEntryType === DSU_ENTRY_TYPES.FOLDER ? "folders" : "files";
                return OpenDSUSafeCallback(callback)(
                    createOpenDSUErrorWrapper(`Failed to list ${entryType} at path ${mountPath}`, error)
                );
            }
        }

        callback(undefined, results);
    };

    const listMountedFiles = (mountPoints, callback) => {
        listMountedEntries(DSU_ENTRY_TYPES.FILE, mountPoints, callback);
    };

    const listMountedFolders = (mountPoints, callback) => {
        listMountedEntries(DSU_ENTRY_TYPES.FOLDER, mountPoints, callback);
    };

    this.listFiles = (path, options, callback) => {
        const defaultOpts = { ignoreMounts: false, recursive: true };
        if (typeof options === "function") {
            callback = options;
            options = {};
        }

        callback = $$.makeSaneCallback(callback);
        options = Object.assign(defaultOpts, options);

        if (options.ignoreMounts === true) {
            if (!options.recursive) {
                return versionlessDSUController.listFiles(path, options, callback);
            }

            return versionlessDSUController.listFiles(path, options, (error, files) => {
                if (error) {
                    return OpenDSUSafeCallback(callback)(
                        createOpenDSUErrorWrapper(`Failed to list files at path ${path}`, error)
                    );
                }

                versionlessDSUController.getMountedDSUs("/", (error, mountPoints) => {
                    if (error) {
                        return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to get manifest`, error));
                    }

                    if (!mountPoints.length) {
                        return callback(undefined, files);
                    }

                    listMountedFiles(mountPoints, (error, mountedFiles) => {
                        if (error) {
                            return OpenDSUSafeCallback(callback)(
                                createOpenDSUErrorWrapper(`Failed to list mounted files at mountPoints ${mountPoints}`, error)
                            );
                        }

                        files = files.concat(...mountedFiles);
                        return callback(undefined, files);
                    });
                });
            });
        }

        this.getArchiveForPath(path, (error, archiveContext) => {
            if (error) {
                return OpenDSUSafeCallback(callback)(
                    createOpenDSUErrorWrapper(`Failed to load DSU instance mounted at path ${path}`, error)
                );
            }

            options.ignoreMounts = true;
            archiveContext.archive.listFiles(archiveContext.relativePath, options, callback);
        });
    };

    this.listFolders = (path, options, callback) => {
        const defaultOpts = { ignoreMounts: false, recursive: false };
        if (typeof options === "function") {
            callback = options;
            options = {};
        }

        callback = $$.makeSaneCallback(callback);
        options = Object.assign(defaultOpts, options);

        if (options.ignoreMounts === true) {
            if (!options.recursive) {
                return versionlessDSUController.listFolders(path, options, callback);
            }

            return versionlessDSUController.listFolders(path, options, (error, folders) => {
                if (error) {
                    return OpenDSUSafeCallback(callback)(
                        createOpenDSUErrorWrapper(`Failed to list folders at path ${path}`, error)
                    );
                }

                versionlessDSUController.getMountedDSUs("/", (error, mountPoints) => {
                    if (error) {
                        return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to get manifest`, error));
                    }

                    if (!mountPoints.length) {
                        return callback(undefined, folders);
                    }

                    listMountedFolders(mountPoints, (error, mountedFolders) => {
                        if (error) {
                            return OpenDSUSafeCallback(callback)(
                                createOpenDSUErrorWrapper(`Failed to list mounted folders at mountPoints ${mountPoints}`, error)
                            );
                        }

                        folders = folders.concat(...mountedFolders);
                        return callback(undefined, folders);
                    });
                });
            });
        }

        this.getArchiveForPath(path, (error, archiveContext) => {
            if (error) {
                return OpenDSUSafeCallback(callback)(
                    createOpenDSUErrorWrapper(`Failed to load DSU instance mounted at path ${path}`, error)
                );
            }

            options.ignoreMounts = true;
            archiveContext.archive.listFolders(archiveContext.relativePath, options, callback);
        });
    };

    this.createFolder = (folderPath, options, callback) => {
        const defaultOpts = { ignoreMounts: false, encrypt: true };
        if (typeof options === "function") {
            callback = options;
            options = {};
        }

        callback = $$.makeSaneCallback(callback);
        options = Object.assign(defaultOpts, options);

        executeMountAwareOperation({
            path: folderPath,
            options,
            onIgnoreMounts: () => {
                versionlessDSUController.createFolder(folderPath, callback);
            },
            onMountCallback: (error, { options, archive, relativePath }) => {
                if (error) {
                    return callback(error);
                }
                archive.createFolder(relativePath, options, callback);
            },
        });
    };

    this.readDir = (folderPath, options, callback) => {
        const defaultOpts = { withFileTypes: false };
        if (typeof options === "function") {
            callback = options;
            options = {};
        }

        callback = $$.makeSaneCallback(callback);
        options = Object.assign(defaultOpts, options);

        this.getArchiveForPath(folderPath, async (err, archiveContext) => {
            if (err) {
                return OpenDSUSafeCallback(callback)(
                    createOpenDSUErrorWrapper(`Failed to load DSU instance mounted at path ${folderPath}`, err)
                );
            }

            const { relativePath, archive } = archiveContext;

            const entries = {};

            try {
                entries.files = await $$.promisify(archive.listFiles.bind(this))(relativePath, {
                    recursive: false,
                    ignoreMounts: true,
                });
            } catch (error) {
                return OpenDSUSafeCallback(callback)(
                    createOpenDSUErrorWrapper(`Failed to list files at path ${relativePath}`, err)
                );
            }

            try {
                const folders = await $$.promisify(archive.listFolders.bind(this))(relativePath, {
                    recursive: false,
                    ignoreMounts: true,
                });

                if (options.withFileTypes) {
                    entries.folders = folders;
                } else {
                    entries.files = [...entries.files, ...folders];
                }
            } catch (error) {
                return OpenDSUSafeCallback(callback)(
                    createOpenDSUErrorWrapper(`Failed to list folders at path ${relativePath}`, err)
                );
            }

            try {
                const mounts = await $$.promisify(archive.listMountedDossiers)(relativePath);

                let mountPaths = mounts.map((mount) => mount.path);
                let folders = mountPaths.filter((mountPath) => mountPath.split("/").length >= 2);
                folders = folders.map((mountPath) => mountPath.split("/").shift());
                let mountedDossiers = mountPaths.filter((mountPath) => mountPath.split("/").length === 1);
                mountedDossiers = mountedDossiers.map((mountPath) => mountPath.split("/").shift());
                if (options.withFileTypes) {
                    entries.mounts = mountedDossiers;
                    entries.folders = Array.from(new Set([...entries.folders, ...folders]));
                    entries.mounts = entries.mounts.filter((mount) => entries.folders.indexOf(mount) === -1);
                    return callback(undefined, entries);
                }
                entries.files = Array.from(new Set([...entries.files, ...mounts, ...folders]));
                return callback(undefined, entries.files);
            } catch (error) {
                return OpenDSUSafeCallback(callback)(
                    createOpenDSUErrorWrapper(`Failed to get mounted DSUs at path ${relativePath}`, error)
                );
            }
        });
    };

    this.cloneFolder = (srcPath, destPath, options, callback) => {
        const defaultOpts = { ignoreMounts: false };
        if (typeof options === "function") {
            callback = options;
            options = {};
        }

        callback = $$.makeSaneCallback(callback);
        options = Object.assign(defaultOpts, options);

        executeMountAwareOperation({
            path: srcPath,
            options,
            onIgnoreMounts: () => {
                versionlessDSUController.cloneFolder(srcPath, destPath, callback);
            },
            onMountCallback: (error, { options, archive, relativePath, prefixPath }) => {
                if (error) {
                    return callback(error);
                }
                this.getArchiveForPath(destPath, (err, destinationArchiveContext) => {
                    if (err) {
                        return OpenDSUSafeCallback(callback)(
                            createOpenDSUErrorWrapper(`Failed to load DSU instance mounted at path ${destPath}`, err)
                        );
                    }

                    if (destinationArchiveContext.prefixPath !== prefixPath) {
                        return callback(Error("Destination is invalid. Renaming must be done in the scope of the same dossier"));
                    }

                    archive.cloneFolder(relativePath, destinationArchiveContext.relativePath, options, callback);
                });
            },
        });
    };

    this.mount = (path, identifier, options, callback) => {
        if (typeof options === "function") {
            callback = options;
            options = {};
        }

        callback = $$.makeSaneCallback(callback);

        function internalMount() {
            versionlessDSUController.listFiles(path, {}, (err, files) => {
                if (!err && files.length > 0) {
                    return callback(Error("Tried to mount in a non-empty folder"));
                }
                // archiveContext.archive.mount(archiveContext.relativePath, identifier, options, callback);
                versionlessDSUController.mount(path, identifier, options, callback);
            });
        }

        this.getArchiveForPath(path, (err, archiveContext) => {
            if (err) {
                return OpenDSUSafeCallback(callback)(
                    createOpenDSUErrorWrapper(`Failed to load DSU instance mounted at path ${path}`, err)
                );
            }
            if (archiveContext.relativePath === processPath(path)) {
                internalMount();
            } else {
                archiveContext.archive.mount(archiveContext.relativePath, identifier, options, callback);
            }
        });
    };

    this.unmount = (path, callback) => {
        callback = $$.makeSaneCallback(callback);
        versionlessDSUController.unmount(path, callback);
    };

    this.listMountedDossiers = (path, callback) => {
        callback = $$.makeSaneCallback(callback);

        this.getArchiveForPath(path, (err, archiveContext) => {
            if (err) {
                return OpenDSUSafeCallback(callback)(
                    createOpenDSUErrorWrapper(`Failed to load DSU instance mounted at path ${path}`, err)
                );
            }
            if (archiveContext.archive === this) {
                versionlessDSUController.getMountedDSUs(path, callback);
            } else {
                archiveContext.archive.listMountedDossiers(archiveContext.relativePath, callback);
            }
        });
    };
    this.listMountedDSUs = this.listMountedDossiers;

    this.hasUnanchoredChanges = (callback) => {
        callback("NotImplemented");
    };

    this.getArchiveForPath = (path, callback) => {
        callback = $$.makeSaneCallback(callback);
        versionlessDSUController.getArchiveContextForPath(path, callback);
    };

    /**
     * Start a batch of operations
     * This will force the persist changes when the
     * batch is commited
     */
    this.beginBatch = () => {
        if (this.batchInProgress()) {
            throw new Error("Another anchoring transaction is already in progress. Cancel the previous batch and try again.");
        }

        versionlessDSUController.beginBatch();
        return generateBatchId(false);
    };

    /**
     * Start a batch of operations
     * This will force the persist changes when the
     * batch is commited
     */
    this.startOrAttachBatch = (callback) => {
        if (this.batchInProgress()) {
            throw new Error("Another anchoring transaction is already in progress. Cancel the previous batch and try again.");
        }
        let batchId;
        try {
            batchId = this.beginBatch();
        }catch (e) {
            return callback(e);
        }

        callback(undefined, batchId);
    };


    this.startOrAttachBatchAsync = async () => {
        return $$.promisify(this.startOrAttachBatch, this)();
    }

    this.batchInProgress = () => {
        return versionlessDSUController.isBatchInProgress();
    };

    //just an alias due to LegacyDSU apis
    this.safeBeginBatch = (wait, callback) => {
        if(typeof callback === "undefined"){
            callback = wait;
            wait = undefined;
        }
        if(typeof wait !== "undefined"){
            console.trace("\n\n VersionLessDSU.safeBeginBatch was called with wait argument and this is ignored for the moment \n\n");
        }
        try {
            this.beginBatch();
            callback(undefined, true);
        }
        catch (err) {
            callback(err, false);
        }
    };

    /**
     * Persist batch of changes
     * @param {callback} onConflict defined by StandardDSU interface
     * @param {callback} callback
     */
    this.commitBatch = (onConflict, callback) => {
        if (typeof callback === "undefined") {
            callback = onConflict;
            onConflict = undefined;
        }

        callback = $$.makeSaneCallback(callback);
        if (!this.batchInProgress()) {
            return callback(new Error("No batch operations have been scheduled"));
        }

        versionlessDSUController.commitBatch(callback);
    };

    this.commitBatchAsync = async (...args) => {
        return $$.promisify(this.commitBatch, this)( ...args);
    }

    /**
     * Cancel the current persisting batch
     */
    this.cancelBatch = (callback) => {
        callback = $$.makeSaneCallback(callback);
        if (!this.batchInProgress()) {
            return callback(new Error("No batch operations have been scheduled"));
        }

        versionlessDSUController.cancelBatch(callback);
    };

    this.cancelBatchAsync = async () => {
        return $$.promisify(this.cancelBatch, this)();
    }

    /**
     * Execute a batch of operations
     * then anchor the changes
     *
     * @param {function} batch
     * @param {callback} callback
     */
    this.batch = (batch, callback) => {
        this.beginBatch();
        batch((error) => {
            if (error) {
                callback = $$.makeSaneCallback(callback);
                return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to execute batch operations`, error));
            }

            this.commitBatch(callback);
        });
    };

    this.setMergeConflictsHandler = () => {
        throw new Error("NotApplicableForVersionlessDSU");
    };

    this.enableAnchoringNotifications = (status, options, callback) => {
        callback = getSaneCallbackFunction(status, options, callback);
        callback("NotApplicableForVersionlessDSU");
    };

    this.enableAutoSync = (status, options, callback) => {
        callback = getSaneCallbackFunction(status, options, callback);
        callback("NotImplemented");
    };

    this.stat = (path, callback) => {
        callback = $$.makeSaneCallback(callback);

        this.getArchiveForPath(path, (error, archiveContext) => {
            if (error) {
                return callback(undefined, { type: undefined });
            }
            if (archiveContext.archive === this) {
                versionlessDSUController.stat(path, callback);
            } else {
                archiveContext.archive.stat(archiveContext.relativePath, callback);
            }
        });
    };
}

module.exports = VersionlessDSU;

},{"./VersionlessDSUController":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/key-ssi-resolver/lib/dsu/VersionlessDSUController.js","opendsu":"opendsu","swarmutils":"swarmutils"}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/key-ssi-resolver/lib/dsu/VersionlessDSUContentHandler.js":[function(require,module,exports){
function VersionlessDSUContentHandler(versionlessDSU, content) {
    const crypto = require("opendsu").loadAPI("crypto");
    const pskPath = require("swarmutils").path;
    const MANIFEST_PATH = "manifest";
    const getCurrentTime = () => {
        return new Date().getTime();
    };

    const readManifestFileContent = () => {
        let manifestContent;
        try {
            manifestContent = this.readFile(MANIFEST_PATH);
            manifestContent = JSON.parse(manifestContent);
        } catch (e) {
            manifestContent = {mounts: {}};
        }
        return manifestContent;
    }

    /**
     * @param {string} nodePath
     * @return {string} Returns trailing name component of a path
     */
    const basename = (path) => {
        const segments = path.split("/");
        return segments.pop();
    };

    const processPath = (path) => {
        path = pskPath.normalize(path);
        if (path.startsWith("/")) {
            path = path.substring(1);
        }
        return path;
    };

    const joinPath = (...paths) => {
        return pskPath.join(...paths);
    };

    const processPathForSearching = (path) => {
        path = processPath(path);
        if (path && !path.endsWith("/")) {
            // ensure we are excluding the desired folder (if provided)
            path = `${path}/`;
        }
        return path;
    };

    const isSubPath = (path, subPath) => {
        if (!path.startsWith("/")) {
            path = `/${path}`;
        }
        if (!subPath.startsWith("/")) {
            subPath = `/${subPath}`;
        }
        // the method doesn't handle that case of relative path very well,
        // so we force absolute paths
        return pskPath.isSubpath(path, subPath);
    };

    const isFilePresent = (path) => {
        return !!content.files[path];
    };

    const isFolderPresent = (path) => {
        return !!content.folders[path];
    };

    const isEntryPresentForSearching = (entry, path, recursive) => {
        if (!entry.startsWith(path)) {
            return false;
        }

        if (recursive) {
            return true;
        }

        // for non recursive, we need to ignore inner files/folders
        const relativePathFromSearch = entry.substring(path.length);
        return !relativePathFromSearch || relativePathFromSearch.indexOf("/") === -1;
    };

    const getParentFolderForFile = (filePath) => {
        filePath = processPath(filePath);
        const lastSlashIndex = filePath.lastIndexOf("/");
        if (lastSlashIndex === -1) {
            // parent folder is root
            return "/";
        }
        const parentFolder = filePath.substring(0, lastSlashIndex);
        return parentFolder;
    };

    const ensureFolderStructureForFilePath = (path) => {
        path = processPath(path);
        const segments = path.split("/");
        segments.pop(); // remove file name

        // ensure root folder exists
        if (!isFolderPresent("/")) {
            updateFolderWriteTime("/");
        }

        let currentPath = "";
        segments.forEach((segment) => {
            currentPath = joinPath(currentPath, segment);
            if (!isFolderPresent(currentPath)) {
                updateFolderWriteTime(currentPath);
            }
        });
    };

    const updateRecordWriteTime = (record) => {
        const currentTime = getCurrentTime();
        record.ctime = currentTime;
        record.mtime = currentTime;
        record.atime = currentTime;
    };

    const ensureFileEntry = (path) => {
        if (!content.files[path]) {
            content.files[path] = {
                content: null,
            };
            updateRecordWriteTime(content.files[path]);
        }
        return content.files[path];
    };

    const updateFileWriteTime = (path) => {
        const fileEntry = ensureFileEntry(path);
        updateRecordWriteTime(fileEntry);
    };

    const updateFileAccessTime = (path) => {
        const fileEntry = ensureFileEntry(path);
        fileEntry.atime = getCurrentTime();
    };

    const ensureFolderEntry = (path) => {
        if (!content.folders[path]) {
            content.folders[path] = {};
            updateRecordWriteTime(content.folders[path]);
        }
        return content.folders[path];
    };

    const updateFolderWriteTime = (path) => {
        const folderEntry = ensureFolderEntry(path);
        updateRecordWriteTime(folderEntry);
    };

    const updateFolderAccessTime = (path) => {
        const folderEntry = ensureFolderEntry(path);
        folderEntry.atime = getCurrentTime();
    };

    const addFileFromFsAsync = async (filePath, destinationFilePath) => {
        const fsModule = "fs";
        const fs = require(fsModule);

        const content = await $$.promisify(fs.readFile.bind(fs))(filePath);
        this.writeFile(destinationFilePath, content);
    };

    const getFilesFromFsAsync = async (folder) => {
        const fsModule = "fs";
        const pathModule = "path";
        const fs = require(fsModule).promises;
        const path = require(pathModule);

        const dirents = await fs.readdir(folder, {withFileTypes: true});

        const files = await Promise.all(
            dirents.map((dirent) => {
                const res = path.resolve(folder, dirent.name);
                return dirent.isDirectory() ? getFilesFromFsAsync(res) : res;
            })
        );
        return Array.prototype.concat(...files);
    };

    const getRelativeFilesFromFsAsync = async (folder) => {
        const pathModule = "path";
        const path = require(pathModule);
        const fullPathFiles = await getFilesFromFsAsync(folder);
        const relativePathFiles = fullPathFiles.map((file) => path.relative(folder, file));
        return relativePathFiles;
    };

    const ensureFSDirectoryExistence = async (filePath) => {
        const fsModule = "fs";
        const pathModule = "path";
        const fs = require(fsModule).promises;
        const path = require(pathModule);
        let dirname = path.dirname(filePath);
        try {
            await fs.stat(dirname);
        } catch (error) {
            await ensureFSDirectoryExistence(dirname);
            await fs.mkdir(dirname);
        }
    };

    const getArchive = (seed, mountOptions, callback) => {
        if (typeof mountOptions === "function") {
            callback = mountOptions;
            mountOptions = {};
        }

        const resolver = require("opendsu").loadApi("resolver");
        resolver.loadDSU(seed, (err, dsu) => {
            if (err) {
                return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to load DSU from keySSI ${seed}`, err));
            }

            if(typeof dsu.getBarInstance === "function"){
                return callback(undefined, dsu.getBarInstance());
            }

            callback(undefined, dsu);
        });
    };

    this.createFolder = (path) => {
        path = processPath(path);
        ensureFolderStructureForFilePath(path);
        updateFolderWriteTime(path);
    };

    this.delete = (path) => {
        path = processPath(path);

        if (isFilePresent(path)) {
            delete content.files[path];
            return;
        }

        if (isFolderPresent(path)) {
            // remove file/folders under path
            const files = this.getFiles(path, true);
            files.forEach((file) => {
                const fullFilePath = processPath(joinPath(path, file));
                delete content.files[fullFilePath];
            });

            const folders = this.getFolders(path, true);
            folders.forEach((folder) => {
                const fullFolderPath = processPath(joinPath(path, folder));
                delete content.folders[fullFolderPath];
            });

            delete content.folders[path];
            return;
        }

        // comment out error in order to be compliant with standard DSU interface
        // throw new Error(`No file/folder present at ${path}!`);
    };

    this.rename = (sourcePath, destinationPath) => {
        sourcePath = processPath(sourcePath);
        destinationPath = processPath(destinationPath);

        if (isFilePresent(sourcePath)) {
            if (isFilePresent(destinationPath)) {
                throw new Error(`Cannot rename file ${sourcePath} to ${destinationPath} since destination already exists!`);
            }

            ensureFileEntry(destinationPath);
            updateFileWriteTime(destinationPath);
            content.files[destinationPath].content = content.files[sourcePath].content;
            delete content.files[sourcePath];
            return;
        }

        if (isFolderPresent(sourcePath)) {
            if (isFolderPresent(destinationPath)) {
                throw new Error(`Cannot rename folder ${sourcePath} to ${destinationPath} since destination already exists!`);
            }

            // rename file/folders under path
            const files = this.getFiles(sourcePath, true);
            files.forEach((file) => {
                const initialFullFilePath = processPath(joinPath(sourcePath, file));
                const destinationFullFilePath = processPath(joinPath(destinationPath, file));
                updateFileWriteTime(destinationFullFilePath);
                content.files[destinationFullFilePath].content = content.files[initialFullFilePath].content;
                delete content.files[initialFullFilePath];
            });

            const folders = this.getFolders(sourcePath, true);
            folders.forEach((folder) => {
                const initialFullFolderPath = processPath(joinPath(sourcePath, folder));
                const destinationFullFolderPath = processPath(joinPath(destinationPath, folder));
                content.folders[destinationFullFolderPath] = content.folders[initialFullFolderPath];
                updateFolderWriteTime(destinationFullFolderPath);
                delete content.folders[initialFullFolderPath];
            });

            updateFolderWriteTime(destinationPath);
            content.folders[destinationPath] = content.folders[sourcePath];
            delete content.folders[sourcePath];
            return;
        }

        throw new Error(`No file/folder present at ${sourcePath}!`);
    };

    this.getFolders = (path, recursive) => {
        const currentPath = processPath(path);
        if (isFolderPresent(currentPath)) {
            updateFolderAccessTime(currentPath);
        }

        path = processPathForSearching(path);
        const folders = Object.keys(content.folders)
            .filter((folder) => folder !== "/" && isEntryPresentForSearching(folder, path, recursive))
            .map((folder) => {
                return folder.substring(path.length);
            });
        return folders;
    };

    this.getFiles = (path, recursive) => {
        path = processPathForSearching(path);
        const files = Object.keys(content.files)
            .filter((file) => isEntryPresentForSearching(file, path, recursive))

            .map((file) => {
                return file.substring(path.length);
            });
        return files;
    };

    this.addFile = async (sourceFilePath, destinationFilePath, callback) => {
        try {
            await addFileFromFsAsync(sourceFilePath, destinationFilePath);
            callback();
        } catch (error) {
            callback(error);
        }
    };

    this.addFiles = async (filePaths, basePath, callback) => {
        try {
            for (const filePath of filePaths) {
                const fileName = basename(processPath(filePath));
                const destinationFilePath = joinPath(basePath, fileName);
                await addFileFromFsAsync(filePath, destinationFilePath);
            }
            callback();
        } catch (error) {
            callback(error);
        }
    };

    this.addFolder = async (folderPath, basePath, callback) => {
        try {
            const relativeFilePaths = await getRelativeFilesFromFsAsync(folderPath);
            for (const relativeFilePath of relativeFilePaths) {
                const fullFilePath = joinPath(folderPath, relativeFilePath);
                const destinationFilePath = joinPath(basePath, relativeFilePath);
                await addFileFromFsAsync(fullFilePath, destinationFilePath);
            }
            callback();
        } catch (error) {
            callback(error);
        }
    };

    this.extractFile = async (fsDestinationFilePath, sourceFilePath, callback) => {
        sourceFilePath = processPath(sourceFilePath);
        try {
            const sourceFileContent = this.readFile(sourceFilePath);

            await ensureFSDirectoryExistence(fsDestinationFilePath);
            const fs = require("fs");
            await $$.promisify(fs.writeFile.bind(fs))(fsDestinationFilePath, sourceFileContent);
            callback();
        } catch (error) {
            callback(error);
        }
    };

    this.extractFolder = async (fsDestinationFolderPath, sourceFolderPath, callback) => {
        try {
            sourceFolderPath = processPath(sourceFolderPath);
            if (!isFolderPresent(sourceFolderPath)) {
                return callback(new Error(`Source path <${sourceFolderPath}> not found.`));
            }

            const sourceFolders = this.getFolders(sourceFolderPath, true);
            if (sourceFolders.length) {
                for (const sourceFolder of sourceFolders) {
                    // const sourceFolderFullPath = joinPath(sourceFolderPath, sourceFolder);
                    const destinationFolderPath = joinPath(fsDestinationFolderPath, sourceFolder);
                    await ensureFSDirectoryExistence(destinationFolderPath);
                }
            }

            const sourceFiles = this.getFiles(sourceFolderPath, true);
            if (sourceFiles.length) {
                for (const sourceFile of sourceFiles) {
                    const sourceFilePath = joinPath(sourceFolderPath, sourceFile);
                    const destinationFilePath = joinPath(fsDestinationFolderPath, sourceFile);
                    await $$.promisify(this.extractFile.bind(this))(destinationFilePath, sourceFilePath);
                }
            }
            callback();
        } catch (error) {
            callback(error);
        }
    };

    this.writeFile = (path, data) => {
        path = processPath(path);

        ensureFolderStructureForFilePath(path);

        if (!isFilePresent(path)) {
            const parentFolderPath = getParentFolderForFile(path);
            updateFolderWriteTime(parentFolderPath);
        }

        const fileEntry = ensureFileEntry(path);
        updateFileWriteTime(path);
        fileEntry.content = crypto.base64URLEncode(data);
    };

    this.readFile = (path) => {
        path = processPath(path);
        if (!content.files[path]) {
            throw new Error(`No file present at ${path}!`);
        }

        updateFileAccessTime(path);
        let fileContent = crypto.base64URLDecode(content.files[path].content);
        if (!$$.Buffer.isBuffer(fileContent)) {
            fileContent = $$.Buffer.from(fileContent);
        }
        return fileContent;
    };

    this.appendToFile = (path, data) => {
        path = processPath(path);
        if (!$$.Buffer.isBuffer(data)) {
            data = $$.Buffer.from(data);
        }

        const fileEntry = ensureFileEntry(path);
        ensureFolderStructureForFilePath(path);

        let fileContent = fileEntry.content;
        if (fileContent != null) {
            fileContent = crypto.base64URLDecode(fileContent);
            if (!$$.Buffer.isBuffer(fileContent)) {
                fileContent = $$.Buffer.from(fileContent);
            }

            fileContent = $$.Buffer.concat([fileContent, data]);
        } else {
            fileContent = data;
        }

        updateFileWriteTime(path);
        fileEntry.content = crypto.base64URLEncode(fileContent);
    };

    this.validatePathToMount = (path) => {
        path = processPath(path);
        const manifestContent = readManifestFileContent();
        if (manifestContent.mounts[path]) {
            throw new Error(`Path ${path} is already mounted!`);
        }

        const filesAtPath = this.getFiles(path);
        if (filesAtPath.length > 0) {
            throw new Error(`Tried to mount in a non-empty folder at ${path}`);
        }
    };

    this.cloneFolder = (sourcePath, destinationPath) => {
        sourcePath = processPath(sourcePath);
        if (!isFolderPresent(sourcePath)) {
            throw new Error(`Source path <${sourcePath}> not found.`);
        }

        destinationPath = processPath(destinationPath);
        if (!isFolderPresent(destinationPath)) {
            this.createFolder(destinationPath);
        }

        const sourceFiles = this.getFiles(sourcePath, true);
        if (sourceFiles.length) {
            sourceFiles.forEach((sourceFile) => {
                const sourceFilePath = joinPath(sourcePath, sourceFile);
                const destinationFilePath = joinPath(destinationPath, sourceFile);
                updateFileWriteTime(destinationFilePath);
                content.files[destinationFilePath].content = content.files[sourceFilePath].content;
            });
        }

        const sourceFolders = this.getFolders(sourcePath, true);
        if (sourceFolders.length) {
            sourceFolders.forEach((sourceFolder) => {
                const sourceFolderPath = joinPath(sourcePath, sourceFolder);
                const destinationFilePath = joinPath(destinationPath, sourceFolder);
                content.folders[destinationFilePath] = content.folders[sourceFolderPath];
                updateFolderWriteTime(destinationFilePath);
            });
        }
    };

    this.stat = (path) => {
        path = processPath(path);
        if (!path || isFolderPresent(path)) {
            const folderInfo = content.folders[path] || {};
            return {type: "directory", ...folderInfo};
        }

        if (isFilePresent(path)) {
            const {ctime, mtime, atime} = content.folders[path] || {};
            return {type: "file", ctime, mtime, atime};
        }

        // default case in order to be compliant with standard DSU interface
        return {type: undefined};
    };

    this.getSSIForMount = (path) => {
        path = processPath(path);
        const manifestContent = readManifestFileContent();
        const mountPoint = manifestContent.mounts[path];
        return mountPoint ? mountPoint : null;
    };

    this.mount = (path, identifier) => {
        path = processPath(path);
        let manifestContent = readManifestFileContent();
        manifestContent.mounts[path] = identifier;
        // set manifest file in order to be compliant with standard DSU interface
        if (!content.files[MANIFEST_PATH]) {
            content.files[MANIFEST_PATH] = {};
        }
        this.writeFile(MANIFEST_PATH, JSON.stringify(manifestContent));
    };

    this.unmount = (path) => {
        path = processPath(path);
        const manifestContent = readManifestFileContent();
        if (!manifestContent.mounts[path]) {
            throw new Error(`No mount found at path ${path}`);
        }

        delete manifestContent.mounts[path]
        this.writeFile(MANIFEST_PATH, JSON.stringify(manifestContent));
    };

    this.getMountedDSUs = (path) => {
        path = processPath(path);
        const manifestContent = readManifestFileContent();
        const mountedDSUs = Object.keys(manifestContent.mounts)
            .filter((mountPointPath) => {
                return isSubPath(mountPointPath, path);
            })
            .map((mountPointPath) => {
                const identifier = manifestContent.mounts[mountPointPath];
                const result = {
                    path: mountPointPath,
                    identifier
                };
                return result;
            });

        return mountedDSUs;
    };

    this.getArchiveContextForPath = (path, callback) => {
        path = processPath(path);
        const manifestContent = readManifestFileContent();
        for (let mountPath in manifestContent.mounts) {
            const identifier = manifestContent.mounts[mountPath];
            if (mountPath === path) {
                return getArchive(identifier, (err, archive) => {
                    if (err) {
                        return OpenDSUSafeCallback(callback)(
                            createOpenDSUErrorWrapper(`Failed to load DSU mounted at mounting point ${mountPath}`, err)
                        );
                    }

                    return callback(undefined, {
                        prefixPath: path,
                        relativePath: "/",
                        archive: archive,
                        identifier,
                    });
                });
            }

            if (isSubPath(path, mountPath)) {
                return getArchive(identifier, (err, archive) => {
                    if (err) {
                        return OpenDSUSafeCallback(callback)(
                            createOpenDSUErrorWrapper(`Failed to load DSU mounted at mounting point ${mountPath}`, err)
                        );
                    }

                    let remainingPath = path.substring(mountPath.length);
                    remainingPath = processPath(remainingPath);
                    return archive.getArchiveForPath(remainingPath, function (err, result) {
                        if (err) {
                            return OpenDSUSafeCallback(callback)(
                                createOpenDSUErrorWrapper(`Failed to load DSU mounted at path ${remainingPath}`, err)
                            );
                        }
                        result.prefixPath = pskPath.join(mountPath, result.prefixPath);
                        callback(undefined, result);
                    });
                });
            }
        }

        callback(undefined, {prefixPath: "/", relativePath: path, archive: versionlessDSU});
    };
}

module.exports = VersionlessDSUContentHandler;

},{"fs":false,"opendsu":"opendsu","swarmutils":"swarmutils"}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/key-ssi-resolver/lib/dsu/VersionlessDSUController.js":[function(require,module,exports){
const VersionlessDSUContentHandler = require("./VersionlessDSUContentHandler");

function VersionlessDSUController(versionlessDSU, config) {
    this.versionlessDSU = versionlessDSU;
    const { keySSIObject } = config;
    let isEncrypted = keySSIObject.isEncrypted();

    const openDSU = require("opendsu");
    const crypto = openDSU.loadAPI("crypto");
    const { SmartUrl } = openDSU.loadAPI("utils");
    const bdns = openDSU.loadApi("bdns");

    const dlDomain = keySSIObject.getDLDomain();

    let versionlessFilePath = keySSIObject.getFilePath();

    let apihubBaseUrl;
    if (!dlDomain || dlDomain.toUpperCase() === bdns.getOriginPlaceholder()) {
        apihubBaseUrl = bdns.getOrigin();
    } else {
        apihubBaseUrl = dlDomain;
    }

    const encryptAsync = $$.promisify(keySSIObject.encrypt);
    const decryptAsync = $$.promisify(keySSIObject.decrypt);

    // current DSU content
    this.dsuContent = null;

    let isBatchCurrentlyInProgress = false;
    let isPersistChangesNeeded = false;
    let dsuContentBeforeBatchChanges = null;
    const mountedArchivesForBatchOperations = [];

    const getContentHandler = () => {
        return new VersionlessDSUContentHandler(this.versionlessDSU, this.dsuContent);
    };

    const resetBatchCurrentlyInProgress = () => {
        isBatchCurrentlyInProgress = false;
        isPersistChangesNeeded = false;
    };

    const persistDSU = async () => {
        let smartUrl = new SmartUrl(apihubBaseUrl);
        let path = "/versionlessdsu";
        if (versionlessFilePath.startsWith("/")) {
            path = path.concat(versionlessFilePath);
        } else {
            path = path.concat("/").concat(versionlessFilePath);
        }
        smartUrl = smartUrl.concatWith(path);

        let requestBody = JSON.stringify(this.dsuContent);

        if (isEncrypted) {
            try {
                requestBody = await encryptAsync(requestBody);
            } catch (error) {
                createOpenDSUErrorWrapper(`Failed to encrypt versionless DSU content`, error);
            }
        }

        requestBody = crypto.base64URLEncode(requestBody);
        return $$.promisify(smartUrl.doPut)(requestBody);
    };

    const persistChanges = async (callback) => {
        if (this.isBatchInProgress()) {
            // don't persist changes until batch is commited
            isPersistChangesNeeded = true;
            return callback();
        }

        try {
            const result = await persistDSU();
            callback(undefined, result);
        } catch (error) {
            OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to persist versionless DSU changes`, error));
        }
    };

    this.createDSU = async (callback) => {
        this.dsuContent = {
            folders: {},
            files: {}
        };

        try {
            await persistDSU();
            // return VersionlessDSU instance
            callback(undefined, this);
        } catch (error) {
            OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to create versionless DSU changes`, error));
        }
    };

    this.loadDSU = async (callback) => {
        const loadDSU = () => {
            let smartUrl = new SmartUrl(apihubBaseUrl);
            let path = "/versionlessdsu";
            if (versionlessFilePath.startsWith("/")) {
                path = path.concat(versionlessFilePath);
            } else {
                path = path.concat("/").concat(versionlessFilePath);
            }
            smartUrl = smartUrl.concatWith(path);
            return smartUrl.fetch().then((response) => response.text());
        };

        try {
            let result = await loadDSU();
            result = crypto.base64URLDecode(result);
            if (isEncrypted) {
                try {
                    result = await decryptAsync(result);
                } catch (error) {
                    return OpenDSUSafeCallback(callback)(
                        createOpenDSUErrorWrapper(`Failed to decrypt versionless DSU content`, error)
                    );
                }
            }

            if (typeof result === "string" || $$.Buffer.isBuffer(result)) {
                result = JSON.parse(result);
            }

            this.dsuContent = result;
            callback(undefined, this);
        } catch (error) {
            OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to get versionless DSU`, error));
        }
    };

    this.appendToFile = (path, data, options, callback) => {
        const contentHandler = getContentHandler();
        contentHandler.appendToFile(path, data, options);
        persistChanges(callback);
    };

    this.getSSIForMount = (mountPoint, callback) => {
        const contentHandler = getContentHandler();
        const ssi = contentHandler.getSSIForMount(mountPoint);
        if (!ssi) {
            return callback(Error(`No mount found at path ${mountPoint}`));
        }
        callback(undefined, ssi);
    };

    this.addFolder = (folderPath, basePath, options, callback) => {
        const contentHandler = getContentHandler();
        const addFolderCallback = (error) => {
            if (error) {
                return callback(error);
            }
            persistChanges(callback);
        };
        contentHandler.addFolder(folderPath, basePath, addFolderCallback);
    };

    this.addFile = (sourceFilePath, destinationFilePath, options, callback) => {
        const contentHandler = getContentHandler();
        const addFileCallback = (error) => {
            if (error) {
                return callback(error);
            }
            persistChanges(callback);
        };
        contentHandler.addFile(sourceFilePath, destinationFilePath, addFileCallback);
    };

    this.addFiles = (filePaths, basePath, options, callback) => {
        const contentHandler = getContentHandler();
        const addFilesCallback = (error) => {
            if (error) {
                return callback(error);
            }
            persistChanges(callback);
        };
        contentHandler.addFiles(filePaths, basePath, addFilesCallback);
    };

    this.extractFile = (fsDestinationFilePath, sourceFilePath, callback) => {
        const contentHandler = getContentHandler();
        contentHandler.extractFile(fsDestinationFilePath, sourceFilePath, callback);
    };

    this.extractFolder = (fsDestinationFolderPath, sourceFolderPath, callback) => {
        const contentHandler = getContentHandler();
        contentHandler.extractFolder(fsDestinationFolderPath, sourceFolderPath, callback);
    };

    this.readFile = (filePath, callback) => {
        const contentHandler = getContentHandler();
        try {
            const buffer = contentHandler.readFile(filePath);
            callback(undefined, buffer);
        } catch (error) {
            return callback(error);
        }
    };

    this.writeFile = (path, data, options, callback) => {
        const contentHandler = getContentHandler();
        contentHandler.writeFile(path, data, options);
        persistChanges(callback);
    };

    this.delete = (path, callback) => {
        const contentHandler = getContentHandler();

        try {
            contentHandler.delete(path);
        } catch (error) {
            return callback(error);
        }

        persistChanges(callback);
    };

    this.rename = (sourcePath, destinationPath, callback) => {
        const contentHandler = getContentHandler();

        try {
            contentHandler.rename(sourcePath, destinationPath);
        } catch (error) {
            return callback(error);
        }

        persistChanges(callback);
    };

    this.listFiles = (path, options, callback) => {
        const contentHandler = getContentHandler();
        const files = contentHandler.getFiles(path, options.recursive);
        callback(null, files);
    };

    this.listFolders = (path, options, callback) => {
        const contentHandler = getContentHandler();
        const folders = contentHandler.getFolders(path, options.recursive);
        callback(null, folders);
    };

    this.createFolder = (path, callback) => {
        const contentHandler = getContentHandler();
        contentHandler.createFolder(path);
        persistChanges(callback);
    };

    this.cloneFolder = (sourcePath, destinationPath, callback) => {
        const contentHandler = getContentHandler();

        try {
            contentHandler.cloneFolder(sourcePath, destinationPath);
        } catch (error) {
            return callback(error);
        }

        persistChanges(callback);
    };

    this.mount = (path, identifier, options, callback) => {
        const contentHandler = getContentHandler();

        try {
            contentHandler.validatePathToMount(path);
        } catch (error) {
            return callback(error);
        }

        contentHandler.mount(path, identifier, options);
        persistChanges(callback);
    };
    this.unmount = (path, callback) => {
        const contentHandler = getContentHandler();

        try {
            contentHandler.unmount(path);
        } catch (error) {
            return callback(error);
        }

        persistChanges(callback);
    };

    this.getMountedDSUs = (path, callback) => {
        const contentHandler = getContentHandler();
        const mountedDSUs = contentHandler.getMountedDSUs(path);
        callback(undefined, mountedDSUs);
    };

    this.getArchiveContextForPath = (path, callback) => {
        const contentHandler = getContentHandler();

        contentHandler.getArchiveContextForPath(path, (error, archiveContext) => {
            if (error) {
                return callback(error);
            }

            if (archiveContext.archive === this.versionlessDSU || !this.isBatchInProgress()) {
                return callback(undefined, archiveContext);
            }

            archiveContext.archive.getKeySSIAsString((err, keySSI) => {
                if (err) {
                    return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper("Failed to retrieve keySSI", err));
                }

                const cachedArchive = mountedArchivesForBatchOperations.find((archive) => {
                    return archive.identifier === keySSI;
                });

                if (cachedArchive) {
                    cachedArchive.relativePath = archiveContext.relativePath;
                    return callback(undefined, cachedArchive);
                }

                archiveContext.identifier = keySSI;
                archiveContext.archive.beginBatch();
                mountedArchivesForBatchOperations.push(archiveContext);

                callback(undefined, archiveContext);
            });
        });
    };

    this.beginBatch = () => {
        isBatchCurrentlyInProgress = true;
        isPersistChangesNeeded = false;
        dsuContentBeforeBatchChanges = this.dsuContent;
    };

    this.isBatchInProgress = () => {
        return isBatchCurrentlyInProgress;
    };

    const runBatchActionInMountedArchives = async (batchActionName, callback) => {
        const archivesForBatch = [...mountedArchivesForBatchOperations];
        archivesForBatch.reverse();

        const results = [];
        for (const archiveContext of archivesForBatch) {
            try {
                const result = await $$.promisify(archiveContext.archive[batchActionName].bind(archiveContext.archive))();
                results.push(result);
            } catch (error) {
                return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper("Failed to commit batch", error));
            }
        }

        callback(undefined, results);
    };

    this.commitBatch = (callback) => {
        runBatchActionInMountedArchives("commitBatch", (error) => {
            if (error) {
                resetBatchCurrentlyInProgress();
                return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to anchor`, error));
            }

            isBatchCurrentlyInProgress = false;
            persistChanges((error) => {
                resetBatchCurrentlyInProgress();
                if (error) {
                    return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to anchor`, error));
                }

                callback(undefined);
            });
        });
    };

    this.cancelBatch = (callback) => {
        runBatchActionInMountedArchives("cancelBatch", (error) => {
            if (error) {
                return OpenDSUSafeCallback(callback)(
                    createOpenDSUErrorWrapper(`Failed to cancel batches in mounted archive`, error)
                );
            }

            resetBatchCurrentlyInProgress();
            if (dsuContentBeforeBatchChanges) {
                this.dsuContent = dsuContentBeforeBatchChanges;
                dsuContentBeforeBatchChanges = null;
            }
            // ensure we have the latest version by loading the DSU again
            this.loadDSU((error) => {
                if (error) {
                    return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to load current DSU`, error));
                }
                callback();
            });
        });
    };

    this.stat = (path, callback) => {
        const contentHandler = getContentHandler();
        const result = contentHandler.stat(path);
        callback(undefined, result);
    };
}

module.exports = VersionlessDSUController;

},{"./VersionlessDSUContentHandler":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/key-ssi-resolver/lib/dsu/VersionlessDSUContentHandler.js","opendsu":"opendsu"}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/key-ssi-resolver/lib/utils/RaceConditionPreventer.js":[function(require,module,exports){
const BarFactory = require("../DSUFactoryRegistry/factories/BarFactory");
const barFactoryInstance = new BarFactory();

function RaceConditionPreventer() {
    let opendsu = require("opendsu");
    let keySSI = opendsu.loadApi("keyssi");
    const TaskCounter = require("swarmutils").TaskCounter;

    const instancesRegistry = {};
    const self = this;

    $$.weakDSUCache = {
        get:async (key) => {
            if(typeof key === "string"){
                key = keySSI.parse(key);
            }
            key = await key.getAnchorIdAsync(true);
            let instances = getDerefedInstances(key);
            if(instances.length){
                return instances[0];
            }
            return;
        }
    };

    self.put = (key, instance) => {
        if (!instancesRegistry[key]) {
            instancesRegistry[key] = new Set();
        }
        instance = instance ? new WeakRef(instance) : instance;
        instancesRegistry[key].add(instance);
    }

    self.set = self.put;
    self.loadNewBarInstance = (bar, callback) => {
        bar.getKeySSIAsObject((err, keySSI) => {
            if (err) {
                return callback(err);
            }
            barFactoryInstance.load(keySSI, (err, _barInstance) => {
                if (err) {
                    return callback(err);
                }

                bar = _barInstance;
                callback(undefined, _barInstance);
            });
        })
    };

    const getDerefedInstances = (key) => {
        const instances = [];
        const weakRefs = instancesRegistry[key];
        if (!weakRefs) {
            return instances;
        }
        for (let weakRef of weakRefs) {
            let inst = weakRef.deref();
            if(inst){
                instances.push(inst);
            }
        }

        return instances;
    }

    self.getAllInstances = () => {
        const instances = [];
        const keys = Object.keys(instancesRegistry);
        for (let key of keys) {
            instances.push(...getDerefedInstances(key));
        }
        return instances;
    }

    self.beginBatch = (key, _instance) => {
        for (let instance of getDerefedInstances(key)) {
            if (instance && instance === _instance) {
                instance.beginBatch();
                return;
            }
        }
    }

    self.batchInProgress = (key) => {
        const instances = getDerefedInstances(key);
        for (let instance of instances) {
            if (instance && instance.batchInProgress()) {
                return true;
            }
        }
        return false;
    }

    self.notifyBatchCommitted = (key, callback) => {
        const instances = getDerefedInstances(key);
        if (!instances || !instances.length) {
            return callback();
        }
        const taskCounter = new TaskCounter(() => {
            callback();
        });

        taskCounter.increment(instances.length);
        instances.forEach((instance) => {
            if (!instance) {
                taskCounter.decrement();
                return;
            }
            instance.refresh((err) => {
                if (err) {
                    return callback(err);
                }
                taskCounter.decrement();
            });
        })
    }

    let continuations = {};
    //this api is meant only for beginBatch family of function, and it should not be used for anything else!
    self.waitUntilCanBeginBatch = (anchorId, continuation, instance)=> {
        if(!continuations[anchorId]){
            continuations[anchorId] = [];
        }
        continuations[anchorId].push({continuation, instance});
    }

    let locks = {};

    self.lockAnchorId = (anchorId, instance) => {
        if(locks[anchorId]){
            throw new Error(`AnchorId ${anchorId} already locked`);
        }
        locks[anchorId] = instance.getInstanceUID();
        return true;
    }

    self.unlockAnchorId = (anchorId) => {
        let executeAllContinuations = (myInstance)=>{
            let isVirtual = false;
            for (let i = possibleContinuations.length - 1; i >= 0; i--) {
                let {continuation, instance} = possibleContinuations[i];
                if(instance === myInstance){
                    if(typeof continuation !== "function"){
                        console.error(Error(`Failed to execution continuation because is not a function: ${continuation ? continuation.toString(): continuation}`));
                    }
                    try{
                        continuation(isVirtual);
                        isVirtual = true;
                    } catch(err){
                        console.error(Error("Continuation functions should not throw exceptions. Ignoring code, possible invalid state."));
                    }
                    possibleContinuations.splice(i, 1);
                }  
          }
        } 
        if(!locks[anchorId]){
            throw new Error(`AnchorId ${anchorId} wasn't locked`);
        }
        locks[anchorId] = undefined;
        delete locks[anchorId];

        let possibleContinuations = continuations[anchorId];
        if(possibleContinuations && possibleContinuations.length > 0){
            let {instance} = possibleContinuations[0];
            executeAllContinuations(instance);
        }
        return true;
    }

    self.isLocked = (anchorId) =>{
        return !!locks[anchorId];
    }

    self.notifyBatchCancelled = self.notifyBatchCommitted;

    if($$.environmentType === "browser" && window.top.location === window.location){
        return;
    }

    /*  DEBUG Stuff */
    let sharedEnclaveId;
    let mainEnclaveId;
    let mainAnchorId;

    setTimeout(async ()=> {
        try{
            let envData = await $$.promisify(opendsu.loadApi("config").readEnvFile)();
            sharedEnclaveId = envData["sharedEnclaveKeySSI"];
            if(sharedEnclaveId){
                sharedEnclaveId = await keySSI.parse(sharedEnclaveId).getAnchorIdAsync(true)
            }

            mainEnclaveId = envData["enclaveKeySSI"];
            if(mainEnclaveId){
                mainEnclaveId = await keySSI.parse(mainEnclaveId).getAnchorIdAsync(true);
            }

            let mainDSU = await $$.promisify(opendsu.loadApi("sc").getMainDSU)();
            if(mainDSU){
                mainAnchorId = mainDSU.getAnchorIdSync(true);
            }
        } catch(err){
            //issues with maindsu, could happen in some environments
        }
    }, 1000);

    function dumpBatchInfo(){
        let anchorIds = Object.keys(instancesRegistry);

        for(let anchorId of anchorIds){
            let instances = instancesRegistry[anchorId];
            let noInstances = 0;
            let noInstancesInBatch = 0;
            let instancesInBatchMode = [];
            let allInstances = [];
            let dsuContent = "";

            let guessType = (instance)=>{
                /*const contentMaxLength = 100;
                let dsuContent = await $$.promisify(instance.listFiles, instance)("/");
                dsuContent = dsuContent.toString();
                if(dsuContent.length >= contentMaxLength){
                    dsuContent = dsuContent.slice(0, contentMaxLength-3) + "...";
                }
                //console.log(dsuContent);
                if(dsuContent.indexOf("publicKeys") !== -1){
                    return "DID_DSU";
                } */
                return "DATA_DSU"
            }

            let type = "system";
            let displayContent = false;
            switch (anchorId){
                case mainAnchorId:
                    type = "MAIN_DSU";
                    break;
                case sharedEnclaveId:
                    type = "SHRD_ENC";
                    break;
                case mainEnclaveId:
                    type = "MAIN_ENC";
                    break;
                default:
                    displayContent = true;
                    type = "UNKN_DSU";
            }

            for(let instance of instances){
                instance = instance.deref();
                if(instance){
                    noInstances++;
                    allInstances.push(instance.getInstanceUID());
                    if(type==="UNKN_DSU"){
                        type = guessType(instance);
                    }
                    if(instance.batchInProgress()){
                        noInstancesInBatch++;
                        instancesInBatchMode.push(instance.getInstanceUID());
                    }
                }
            }

            let anchor = keySSI.parse(anchorId);
            if(!noInstances){
                continue;
            }

            anchor = anchor.getIdentifier(true);
            anchor = anchor.substring(4, 27)+"...";

            console.log(`\tDSU [${anchor}] [${type}]:  In batch mode [${instancesInBatchMode}] All instances: [${allInstances}]`);
        }
    }

    function dumpLocks(){
        console.log(`\tCurrent locks ${JSON.stringify(locks)}`);
    }

    function dumpContinuations(){
        console.log(`\tContinuations on ${JSON.stringify(Object.keys(continuations))}`);
    }

    if($$ && $$.debug){
        console.log(">>> $$.debug.status() available");
        $$.debug.status = ()=>{
            console.log("Registry status===============================");
            dumpLocks();
            dumpContinuations();
            dumpBatchInfo();
            console.log("=============================================");
        }
    }
    /* END DEBUG Stuff */
}

module.exports = RaceConditionPreventer;
},{"../DSUFactoryRegistry/factories/BarFactory":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/key-ssi-resolver/lib/DSUFactoryRegistry/factories/BarFactory.js","opendsu":"opendsu","swarmutils":"swarmutils"}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/loki-enclave-facade/LightDBServer.js":[function(require,module,exports){
const logger = $$.getLogger("LightDBServer", "LokiEnclaveFacade");
const DATABASE = "database";
process.on('uncaughtException', err => {
    logger.critical('There was an uncaught error', err, err.message, err.stack);
});

process.on('SIGTERM', (signal) => {
    process.shuttingDown = true;
    logger.info('Received signal:', signal, ". Activating the gracefulTerminationWatcher.");
});

function LightDBServer(config, callback) {
    let {lightDBStorage, lightDBPort, lightDBDynamicPort, host} = config;
    const apihubModule = require("apihub");
    const LokiEnclaveFacade = require("./LokiEnclaveFacade");
    const httpWrapper = apihubModule.getHttpWrapper();
    const Server = httpWrapper.Server;
    const CHECK_FOR_RESTART_COMMAND_FILE_INTERVAL = 500;
    //in read only mode if the time from the last refresh is bigger than this timeout then a refresh will be executed
    const LAST_REFRESH_TIMEOUT = 30000;
    const lastRefreshes = {};

    host = host || "127.0.0.1";
    lightDBPort = lightDBPort || 8081;

    const server = new Server();
    server.config = config.serverConfig || config;
    if (!config.storage) {
        config.storage = lightDBStorage;
    }
    const enclaves = {};
    const path = require("path");
    const fs = require("fs");
    try {
        fs.accessSync(lightDBStorage);
        const folderContent = fs.readdirSync(lightDBStorage, {withFileTypes: true});
        for (let entry of folderContent) {
            if (entry.isDirectory()) {
                let enclaveName = entry.name;
                logger.info(`Loading database ${enclaveName}`);
                enclaves[enclaveName] = new LokiEnclaveFacade(path.join(lightDBStorage, enclaveName, DATABASE));
            }
        }
    } catch (err) {
        logger.info(`Failed to access the storage folder: ${lightDBStorage}. Ensuring folder structure...`);
        fs.mkdirSync(lightDBStorage, {recursive: true});
    }

    let accessControlAllowHeaders = new Set();
    accessControlAllowHeaders.add("Content-Type");
    accessControlAllowHeaders.add("Content-Length");
    accessControlAllowHeaders.add("X-Content-Length");
    accessControlAllowHeaders.add("Access-Control-Allow-Origin");
    accessControlAllowHeaders.add("User-Agent");
    accessControlAllowHeaders.add("Authorization");

    let listenCallback = (err) => {
        if (err) {
            if (lightDBDynamicPort && err.code === 'EADDRINUSE') {
                logger.debug("Failed to listen on port <" + lightDBPort + ">", err);
                function getRandomPort() {
                    const min = 9000;
                    const max = 65535;
                    return Math.floor(Math.random() * (max - min) + min);
                }

                lightDBPort = getRandomPort();
                if (Number.isInteger(lightDBDynamicPort)) {
                    lightDBDynamicPort -= 1;
                }
                setTimeout(boot, CHECK_FOR_RESTART_COMMAND_FILE_INTERVAL);
                return
            }
            logger.error(err);
            if (!lightDBDynamicPort && callback) {
                return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to listen on port <${lightDBPort}>`, err));
            }
        }
    };

    function bindFinished(err) {
        if (err) {
            logger.error(err);
            if (callback) {
                return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to bind on port <${lightDBPort}>`, err));
            }
            return;
        }

        process.env.LIGHT_DB_SERVER_ADDRESS = `http://${host}:${lightDBPort}`;
        logger.info(`LightDB server running at port: ${lightDBPort}`);
        registerEndpoints();
        if (callback) {
            callback(undefined, server);
        }
    }

    function boot() {
        logger.debug(`Trying to listen on port ${lightDBPort}`);
        server.listen(lightDBPort, host, listenCallback);
    }

    boot();

    server.on('listening', bindFinished);
    server.on('error', listenCallback);

    function registerEndpoints() {
        server.getAccessControlAllowHeadersAsString = function () {
            let headers = "";
            let notFirst = false;
            for (let header of accessControlAllowHeaders) {
                if (notFirst) {
                    headers += ", ";
                }
                notFirst = true;
                headers += header;
            }
            return headers;
        }

        server.use(function gracefulTerminationWatcher(req, res, next) {
            if (process.shuttingDown) {
                //uncaught exception was caught so server is shutting down gracefully and not accepting any requests
                res.statusCode = 503;
                logger.log(0x02, `Rejecting ${req.url} with status code ${res.statusCode} because process is shutting down.`);
                res.end();
                return;
            }
            //if the shuttingDown flag not present, we let the request go on...
            next();
        });


        server.use(function (req, res, next) {
            res.setHeader('Access-Control-Allow-Origin', req.headers.origin || req.headers.host || "*");
            res.setHeader('Access-Control-Allow-Methods', 'GET, PUT, OPTIONS');
            res.setHeader('Access-Control-Allow-Headers', server.getAccessControlAllowHeadersAsString());
            res.setHeader('Access-Control-Allow-Credentials', true);
            next();
        });

        //we activate the readOnly without the server.use handler becase we expose only PUT type of http methods
        apihubModule.middlewares.ReadOnly(server, false);

        server.put(`/executeCommand/:dbName`, (req, res, next) => {
            const {dbName} = req.params;
            if (!enclaves[dbName]) {
                res.statusCode = 400;
                res.write(`No db with name ${dbName} was found!`);
                res.end();
                return;
            }
            httpWrapper.httpUtils.bodyParser(req, res, next);
        });

        server.put(`/executeCommand/:dbName`, function (req, res) {
            let body = req.body;
            try {
                body = JSON.parse(body);
            } catch (e) {
                logger.error("Invalid body", body);
                res.statusCode = 400;
                res.write("Invalid body");
                return res.end();
            }

            if (typeof body.command !== "string") {
                logger.error("Invalid command", body.command);
                res.statusCode = 400;
                res.write("Invalid command");
                return res.end();
            }

            let command;
            try {
                command = JSON.parse(body.command);
            } catch (e) {
                logger.error("Invalid command", command);
                res.statusCode = 400;
                res.write("Invalid command");
                return res.end();
            }

            const didAPI = require("opendsu").loadAPI("w3cdid");
            const args = command.params;
            if (!Array.isArray(args)) {
                logger.error("Invalid args", args);
                return res.send(400, "Invalid args");
            }

            let didDocument;
            const __verifySignatureAndExecuteCommand = () => {
                didDocument.verify(body.command, $$.Buffer.from(body.signature, "base64"), async (err, result) => {
                    if (err) {
                        logger.error(`Failed to verify signature`, err);
                        res.statusCode = 500;
                        res.write(`Failed to verify signature`);
                        return res.end();
                    }

                    if (!result) {
                        logger.error(`Invalid signature`);
                        res.statusCode = 500;
                        res.write(`Invalid signature`);
                        return res.end();
                    }

                    if(server.readOnlyModeActive ) {
                        if (enclaves[req.params.dbName].allowedInReadOnlyMode &&
                            !enclaves[req.params.dbName].allowedInReadOnlyMode(command.commandName)) {

                            res.statusCode = 403;
                            res.end();
                            return;
                        }

                        //at this point we know that will execute a read cmd so first of all we need to ensure that a refresh is made if needed
                        try {
                            let lastRefresh = lastRefreshes[req.params.dbName];
                            if (!lastRefresh || LAST_REFRESH_TIMEOUT < Date.now() - lastRefresh) {
                                await enclaves[req.params.dbName].refreshAsync();
                                lastRefreshes[req.params.dbName] = Date.now();
                            }
                        } catch (err) {
                            //we ignore any refresh errors for now...
                        }
                    }

                    const cb = (err, result) => {
                        if (err) {
                            res.statusCode = 500;
                            logger.debug(`Error while executing command ${command.commandName}`, err);
                            res.write(`Error while executing command ${command.commandName}: ${err.message}`);
                            return res.end();
                        }

                        res.statusCode = 200;
                        if(typeof result !== "undefined"){
                            res.write(JSON.stringify(result));
                        }

                        res.end();
                    }

                    args.push(cb);

                    // trying to capture any sync error that might occur during the execution of the command
                    try {
                        enclaves[req.params.dbName][command.commandName](...args);
                    }catch (e) {
                        cb(e);
                    }
                });
            }
            if(args[0] === $$.SYSTEM_IDENTIFIER){
                didDocument = $$.SYSTEM_DID_DOCUMENT;
                return __verifySignatureAndExecuteCommand();
            }

            didAPI.resolveDID(args[0], (err, _didDocument) => {
                if (err) {
                    logger.error(`Failed to resolve DID ${args[0]}`, err);
                    res.statusCode = 500;
                    res.write(`Failed to resolve DID ${args[0]}`);
                    return res.end();
                }

                didDocument = _didDocument;
                __verifySignatureAndExecuteCommand();
            });
        });

        server.put(`/createDatabase/:dbName`, function (req, res) {
            const {dbName} = req.params;
            if (enclaves[dbName]) {
                res.statusCode = 409;
                res.write("Already exists");
                res.end();
                return;
            }

            const storage = path.join(lightDBStorage, dbName);
            logger.info(`Creating new Database at ${storage}`);
            let fsModule = "fs";
            fsModule = require(fsModule);
            fsModule.mkdir(storage, {recursive: true}, (err) => {
                if (err) {
                    logger.error("Failed to create database", err);
                    res.statusCode = 500;
                    res.end();
                    return;
                }
                if(enclaves[dbName]){
                    logger.error("Race condition detected and resolved during lightDB database creation");
                    res.statusCode = 409;
                    res.write("Already exists");
                    return res.end();
                }
                enclaves[dbName] = new LokiEnclaveFacade(path.join(storage, DATABASE));
                res.statusCode = 201;
                res.end();
            })
        });
    }
}

module.exports = LightDBServer;
},{"./LokiEnclaveFacade":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/loki-enclave-facade/LokiEnclaveFacade.js","apihub":"apihub","fs":false,"opendsu":"opendsu","path":false}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/loki-enclave-facade/LokiDb.js":[function(require,module,exports){
(function (Buffer){(function (){
const Adaptors = require("./adaptors.js");
const loki = require("./lib/lokijs/src/lokijs.js");

let filterOperationsMap = {
    "!=": "$ne",
    "==": "$aeq",
    ">": "$jgt",
    ">=": "$jgte",
    "<": "$jlt",
    "<=": "$jlte",
    "like": "$regex"
}

function LokiDb(rootFolder, autosaveInterval, adaptorConstructorFunction) {
    const logger = $$.getLogger("LokiDb", "lokiDb");
    const openDSU = require("opendsu");
    const aclAPI = require("acl-magic");
    const keySSISpace = openDSU.loadAPI("keyssi")
    const w3cDID = openDSU.loadAPI("w3cdid")
    const utils = openDSU.loadAPI("utils");
    const CryptoSkills = w3cDID.CryptographicSkills;
    const KEY_SSIS_TABLE = "keyssis";
    const SEED_SSIS_TABLE = "seedssis";
    const DIDS_PRIVATE_KEYS = "dids_private";
    const AUTOSAVE_INTERVAL = 5000;
    const adapter = adaptorConstructorFunction === undefined ? new Adaptors.STRUCTURED() : new adaptorConstructorFunction();

    logger.info(`Initializing Loki database ${rootFolder}`);
    autosaveInterval = autosaveInterval || AUTOSAVE_INTERVAL;
    if (typeof rootFolder === "undefined") {
        throw Error("Root folder was not specified for LokiEnclaveFacade");
    }
    let db = new loki(rootFolder, {
        adapter: adapter,
        autoload: true,
        autoloadCallback: initialized.bind(this),
        autosave: true,
        autosaveInterval: autosaveInterval,
        autosaveCallback: function (err) {
            if (err) {
                logger.error(`Failed to save db on disk.`, err)
            }
            logger.info(`Loki database ${rootFolder} saved on disk.`);
        }
    });

    this.close = async () => {
        return new Promise((resolve, reject) => {
            db.close((err) => {
                if (err) {
                    return reject(err);
                }
                resolve();
            });
        });
    }

    this.refresh = function (callback) {
        logger.info(`Refreshing database ${rootFolder}`);
        db.loadDatabaseInternal(undefined, callback);
    }

    this.saveDatabase = function (callback) {
        logger.info(`Saving Loki database ${rootFolder}`);
        db.saveDatabase((err)=>{
            if(err){
                return callback(err);
            }
            callback(undefined, {message: `Database ${rootFolder} saved`});
        });
    }

    const WRITE_ACCESS = "write";
    const READ_ACCESS = "read";
    const WILDCARD = "*";
    const persistence = aclAPI.createEnclavePersistence(this);

    this.grantWriteAccess = (callback) => {
        persistence.grant(WRITE_ACCESS, WILDCARD, (err) => {
            if (err) {
                return callback(err);
            }

            this.grantReadAccess(callback);
        });
    }

    this.hasWriteAccess = (callback) => {
        persistence.loadResourceDirectGrants(WRITE_ACCESS, (err, usersWithAccess) => {
            if (err) {
                return callback(err);
            }

            callback(undefined, usersWithAccess.indexOf(WILDCARD) !== -1);
        });
    }

    this.revokeWriteAccess = (callback) => {
        persistence.ungrant(WRITE_ACCESS, WILDCARD, callback);
    }

    this.grantReadAccess = (callback) => {
        persistence.grant(READ_ACCESS, WILDCARD, callback);
    }

    this.hasReadAccess = (callback) => {
        persistence.loadResourceDirectGrants(READ_ACCESS, (err, usersWithAccess) => {
            if (err) {
                return callback(err);
            }

            callback(undefined, usersWithAccess.indexOf(WILDCARD) !== -1);
        });
    }

    this.revokeReadAccess = (callback) => {
        persistence.ungrant(READ_ACCESS, WILDCARD, err => {
            if (err) {
                return callback(err);
            }

            this.revokeWriteAccess(callback);
        });
    }

    this.count = function (tableName, callback) {
        let table = db.getCollection(tableName);
        if (!table) {
            return callback(createOpenDSUErrorWrapper(`Table ${tableName} not found`))
        }
        let result;
        try {
            result = table.count();
        } catch (err) {
            return callback(createOpenDSUErrorWrapper(`Could not count on ${tableName}`, err))
        }

        callback(null, result)
    }

    this.getCollections = (callback) => {
        const collections = db.listCollections();
        if (Array.isArray(collections)) {
            return callback(undefined, collections.map(collection => collection.name));
        }

        callback(undefined, []);
    }

    this.createCollection = function (tableName, indicesList, callback) {
        if (typeof indicesList === "function") {
            callback = indicesList;
            indicesList = undefined;
        }

        try {
            db.addCollection(tableName, {indices: indicesList});
        } catch (err) {
            return callback(createOpenDSUErrorWrapper(`Could not create collection ${tableName}`, err))
        }
        callback();
    }

    this.addIndex = function (tableName, property, callback) {
        let table = db.getCollection(tableName) || db.addCollection(tableName);
        try {
            table.ensureIndex(property, true);
        } catch (err) {
            return callback(createOpenDSUErrorWrapper(`Could not add index ${property} on ${tableName}`, err))
        }
        callback();
    }

    this.insertRecord = (tableName, pk, record, callback) => {
        let table = db.getCollection(tableName) || db.addCollection(tableName);
        if (record.meta) {
            delete record.meta;
        }

        if (record.$loki) {
            delete record.$loki;
        }

        let foundRecord = table.findObject({'pk': pk});

        if (foundRecord) {
            let error = `A record with pk ${pk} already exists in ${tableName}`
            logger.log(error);
            return callback(createOpenDSUErrorWrapper(error));
        }
        let result;
        try {
            result = table.insert({
                "pk": pk, ...record,
                "__timestamp": record.__timestamp || Date.now()
            });
        } catch (err) {
            logger.log(`Failed to insert ${pk} into table ${tableName}`, err);
            return callback(createOpenDSUErrorWrapper(` Could not insert record in table ${tableName} `, err))
        }

        callback(null, result);
    }

    this.updateRecord = function (tableName, pk, record, callback) {
        let table = db.getCollection(tableName) || db.addCollection(tableName);
        let doc;
        try {
            doc = table.by("pk", pk);
            if (!doc && record.__fallbackToInsert) {
                //this __fallbackToInsert e.g. is used by fixedURL component
                record.__fallbackToInsert = undefined;
                delete record.__fallbackToInsert;
                return self.insertRecord(tableName, pk, record, callback);
            }
            for (let prop in record) {
                doc[prop] = record[prop];
            }
        } catch (err) {
            logger.error(err);
            logger.debug(`Failed to update ${pk} in table ${tableName}`);
            return callback(createOpenDSUErrorWrapper(`Could not update record in table ${tableName}`, err));
        }

        doc.__timestamp = Date.now();
        let result;
        try {
            result = table.update(doc);
        } catch (err) {
            return callback(createOpenDSUErrorWrapper(` Could not insert record in table ${tableName} `, err));
        }

        callback(null, result);
    }

    this.deleteRecord = function (tableName, pk, callback) {
        let table = db.getCollection(tableName);
        if (!table) {
            return callback();
        }

        let record = table.findOne({'pk': pk});
        if (!record) {
            return callback(undefined, {pk});
        }

        try {
            table.findAndRemove({'pk': pk});
        } catch (err) {
            return callback(createOpenDSUErrorWrapper(`Couldn't do remove for pk ${pk} in ${tableName}`, err))
        }

        callback(null, record);
    }

    this.getRecord = function (tableName, pk, callback) {
        let table = db.getCollection(tableName);
        if (!table) {
            return callback(Error(`Table ${tableName} not found`));
        }
        let result;
        try {
            result = table.findObject({'pk': pk});
        } catch (err) {
            return callback(createOpenDSUErrorWrapper(`Could not find object with pk ${pk}`, err));
        }

        callback(null, result)
    }

    function __parseQuery(filterConditions) {
        let lokiQuery = {}
        if (!filterConditions) {
            return lokiQuery;
        }

        filterConditions.forEach(condition => {
            const splitCondition = condition.split(" ");
            const field = splitCondition[0];
            const operator = splitCondition[1];
            const value = splitCondition[2];
            lokiQuery[field] = {};
            lokiQuery[field][`${filterOperationsMap[operator]}`] = value;
        })
        return lokiQuery;
    }

    function __getSortingField(filterConditions) {
        let sortingField = "__timestamp";
        if (filterConditions && filterConditions.length) {
            const splitCondition = filterConditions[0].split(" ");
            sortingField = splitCondition[0];
        }

        return sortingField;
    }

    this.filter = function (tableName, filterConditions, sort, max, callback) {
        if (typeof filterConditions === "string") {
            filterConditions = [filterConditions];
        }

        if (typeof filterConditions === "function") {
            callback = filterConditions;
            filterConditions = undefined;
            sort = "asc";
            max = Infinity;
        }

        if (typeof sort === "function") {
            callback = sort;
            sort = "asc";
            max = Infinity;
        }

        if (typeof max === "function") {
            callback = max;
            max = Infinity;
        }

        if (!max) {
            max = Infinity;
        }

        const sortingField = __getSortingField(filterConditions);
        filterConditions = __parseQuery(filterConditions);

        let table = db.getCollection(tableName);
        if (!table) {
            return callback(undefined, []);
        }
        let direction = false;
        if (sort === "desc" || sort === "dsc") {
            direction = true;
        }

        let result;
        try {
            result = table.chain().find(filterConditions).simplesort(sortingField, direction).limit(max).data();
        } catch (err) {
            return callback(createOpenDSUErrorWrapper(`Filter operation failed on ${tableName}`, err));
        }


        callback(null, result);
    }

    this.getAllRecords = (tableName, callback) => {
        let table = db.getCollection(tableName);
        if (!table) {
            return callback(undefined, []);
        }

        let results;
        try {
            results = table.find();
        } catch (err) {
            return callback(createOpenDSUErrorWrapper(`Filter operation failed on ${tableName}`, err));
        }

        if (!results) {
            results = [];
        }
        callback(null, results);
    };

    utils.bindAutoPendingFunctions(this);

    const READ_WRITE_KEY_TABLE = "KeyValueTable";

    this.writeKey = (key, value, callback) => {
        let valueObject = {
            type: typeof value,
            value: value
        };

        if (typeof value === "object") {
            if (Buffer.isBuffer(value)) {
                valueObject = {
                    type: "buffer",
                    value: value.toString()
                }
            } else {
                valueObject = {
                    type: "object",
                    value: JSON.stringify(value)
                }
            }
        }
        this.insertRecord(READ_WRITE_KEY_TABLE, key, valueObject, callback);
    }

    this.readKey = (key, callback) => {
        this.getRecord(READ_WRITE_KEY_TABLE, key, (err, record) => {
            if (err) {
                return callback(createOpenDSUErrorWrapper(`Failed to read key ${key}`, err));
            }

            callback(undefined, record);
        })
    }

    //------------------ queue -----------------
    let self = this;
    this.addInQueue = function (queueName, encryptedObject, ensureUniqueness, callback) {
        if (typeof ensureUniqueness === "function") {
            callback = ensureUniqueness;
            ensureUniqueness = false;
        }
        const crypto = require("opendsu").loadApi("crypto");
        const hash = crypto.sha256(encryptedObject);
        let pk = hash;
        if (ensureUniqueness) {
            pk = `${hash}_${Date.now()}_${crypto.encodeBase58(crypto.generateRandom(10))}`;
        }
        self.insertRecord(queueName, pk, encryptedObject, (err) => callback(err, pk));
    }

    this.queueSize = function (queueName, callback) {
        self.count(queueName, callback);
    }

    this.listQueue = function (queueName, sortAfterInsertTime, onlyFirstN, callback) {
        if (typeof sortAfterInsertTime === "function") {
            callback = sortAfterInsertTime;
            sortAfterInsertTime = "asc";
            onlyFirstN = undefined
        }
        if (typeof onlyFirstN === "function") {
            callback = onlyFirstN;
            onlyFirstN = undefined;
        }

        self.filter(queueName, undefined, sortAfterInsertTime, onlyFirstN, (err, result) => {
            if (err) {
                if (err.code === 404) {
                    return callback(undefined, []);
                }

                return callback(err);
            }

            /*            result = result.filter(item => {
                            if(typeof item.$loki !== "undefined"){
                                return true;
                            }
                            logger.warn("A message was filtered out because wrong loki document structure");
                            return false;
                        });*/

            result = result.map(item => {
                return item.pk
            })
            return callback(null, result);
        })
    }

    this.getObjectFromQueue = function (queueName, hash, callback) {
        return self.getRecord(queueName, hash, callback)
    }

    this.deleteObjectFromQueue = function (queueName, hash, callback) {
        return self.deleteRecord(queueName, hash, callback)
    }

    //------------------ KeySSIs -----------------
    const getCapableOfSigningKeySSI = (keySSI, callback) => {
        if (typeof keySSI === "undefined") {
            return callback(Error(`A SeedSSI should be specified.`));
        }

        if (typeof keySSI === "string") {
            try {
                keySSI = keySSISpace.parse(keySSI);
            } catch (e) {
                return callback(createOpenDSUErrorWrapper(`Failed to parse keySSI ${keySSI}`, e))
            }
        }

        this.getRecord(undefined, KEY_SSIS_TABLE, keySSI.getIdentifier(), (err, record) => {
            if (err) {
                return callback(createOpenDSUErrorWrapper(`No capable of signing keySSI found for keySSI ${keySSI.getIdentifier()}`, err));
            }

            let capableOfSigningKeySSI;
            try {
                capableOfSigningKeySSI = keySSISpace.parse(record.capableOfSigningKeySSI);
            } catch (e) {
                return callback(createOpenDSUErrorWrapper(`Failed to parse keySSI ${record.capableOfSigningKeySSI}`, e))
            }

            callback(undefined, capableOfSigningKeySSI);
        });
    };

    this.storeSeedSSI = (seedSSI, alias, callback) => {
        if (typeof seedSSI === "string") {
            try {
                seedSSI = keySSISpace.parse(seedSSI);
            } catch (e) {
                return callback(createOpenDSUErrorWrapper(`Failed to parse keySSI ${seedSSI}`, e))
            }
        }

        const keySSIIdentifier = seedSSI.getIdentifier();

        const registerDerivedKeySSIs = (derivedKeySSI) => {
            this.insertRecord(KEY_SSIS_TABLE, derivedKeySSI.getIdentifier(), {capableOfSigningKeySSI: keySSIIdentifier}, (err) => {
                if (err) {
                    return callback(err);
                }

                try {
                    derivedKeySSI = derivedKeySSI.derive();
                } catch (e) {
                    return callback();
                }

                registerDerivedKeySSIs(derivedKeySSI);
            });
        }

        this.insertRecord(SEED_SSIS_TABLE, alias, {seedSSI: keySSIIdentifier}, (err) => {
            if (err) {
                return callback(err);
            }

            return registerDerivedKeySSIs(seedSSI);
        })
    }

    this.signForKeySSI = (keySSI, hash, callback) => {
        getCapableOfSigningKeySSI(keySSI, (err, capableOfSigningKeySSI) => {
            if (err) {
                return callback(err);
            }
            if (typeof capableOfSigningKeySSI === "undefined") {
                return callback(Error(`The provided SSI does not grant writing rights`));
            }

            capableOfSigningKeySSI.sign(hash, callback);
        });
    }

    //------------------ DIDs -----------------
    const getPrivateInfoForDID = (did, callback) => {
        this.getRecord(undefined, DIDS_PRIVATE_KEYS, did, (err, record) => {
            if (err) {
                return callback(err);
            }

            const privateKeysAsBuff = record.privateKeys.map(privateKey => {
                if (privateKey) {
                    return $$.Buffer.from(privateKey)
                }

                return privateKey;
            });
            callback(undefined, privateKeysAsBuff);
        });
    };

    const __ensureAreDIDDocumentsThenExecute = (did, fn, callback) => {
        if (typeof did === "string") {
            return w3cDID.resolveDID(did, (err, didDocument) => {
                if (err) {
                    return callback(err);
                }

                fn(didDocument, callback);
            })
        }

        fn(did, callback);
    }

    this.storeDID = (storedDID, privateKeys, callback) => {
        this.getRecord(DIDS_PRIVATE_KEYS, storedDID, (err, res) => {
            if (err || !res) {
                return this.insertRecord(DIDS_PRIVATE_KEYS, storedDID, {privateKeys: privateKeys}, callback);
            }

            privateKeys.forEach(privateKey => {
                res.privateKeys.push(privateKey);
            })
            this.updateRecord(DIDS_PRIVATE_KEYS, storedDID, res, callback);
        });
    }

    this.signForDID = (didThatIsSigning, hash, callback) => {
        const __signForDID = (didThatIsSigning, callback) => {
            getPrivateInfoForDID(didThatIsSigning.getIdentifier(), (err, privateKeys) => {
                if (err) {
                    return callback(createOpenDSUErrorWrapper(`Failed to get private info for did ${didThatIsSigning.getIdentifier()}`, err));
                }

                let signature;
                try{
                    signature = CryptoSkills.applySkill(didThatIsSigning.getMethodName(), CryptoSkills.NAMES.SIGN, hash, privateKeys[privateKeys.length - 1]);
                }catch(err){
                    return callback(err);
                }
                callback(undefined, signature);
            });
        }

        __ensureAreDIDDocumentsThenExecute(didThatIsSigning, __signForDID, callback);
    }

    this.verifyForDID = (didThatIsVerifying, hash, signature, callback) => {
        const __verifyForDID = (didThatIsVerifying, callback) => {
            didThatIsVerifying.getPublicKey("pem", (err, publicKey) => {
                if (err) {
                    return callback(createOpenDSUErrorWrapper(`Failed to read public key for did ${didThatIsVerifying.getIdentifier()}`, err));
                }

                const verificationResult = CryptoSkills.applySkill(didThatIsVerifying.getMethodName(), CryptoSkills.NAMES.VERIFY, hash, publicKey, $$.Buffer.from(signature));
                callback(undefined, verificationResult);
            });
        }

        __ensureAreDIDDocumentsThenExecute(didThatIsVerifying, __verifyForDID, callback);
    }

    this.encryptMessage = (didFrom, didTo, message, callback) => {
        const __encryptMessage = () => {
            getPrivateInfoForDID(didFrom.getIdentifier(), (err, privateKeys) => {
                if (err) {
                    return callback(createOpenDSUErrorWrapper(`Failed to get private info for did ${didFrom.getIdentifier()}`, err));
                }

                CryptoSkills.applySkill(didFrom.getMethodName(), CryptoSkills.NAMES.ENCRYPT_MESSAGE, privateKeys, didFrom, didTo, message, callback);
            });
        }
        if (typeof didFrom === "string") {
            w3cDID.resolveDID(didFrom, (err, didDocument) => {
                if (err) {
                    return callback(err);
                }

                didFrom = didDocument;


                if (typeof didTo === "string") {
                    w3cDID.resolveDID(didTo, (err, didDocument) => {
                        if (err) {
                            return callback(err);
                        }

                        didTo = didDocument;
                        __encryptMessage();
                    })
                } else {
                    __encryptMessage();
                }
            })
        } else {
            __encryptMessage();
        }
    }

    this.decryptMessage = (didTo, encryptedMessage, callback) => {
        const __decryptMessage = (didTo, callback) => {
            getPrivateInfoForDID(didTo.getIdentifier(), (err, privateKeys) => {
                if (err) {
                    return callback(createOpenDSUErrorWrapper(`Failed to get private info for did ${didTo.getIdentifier()}`, err));
                }

                CryptoSkills.applySkill(didTo.getMethodName(), CryptoSkills.NAMES.DECRYPT_MESSAGE, privateKeys, didTo, encryptedMessage, callback);
            });
        }
        __ensureAreDIDDocumentsThenExecute(didTo, __decryptMessage, callback);
    };
}

function initialized() {
    this.finishInitialisation();
}

LokiDb.prototype.Adaptors = Adaptors;
module.exports = LokiDb;
}).call(this)}).call(this,{"isBuffer":require("../../node_modules/is-buffer/index.js")})

},{"../../node_modules/is-buffer/index.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/node_modules/is-buffer/index.js","./adaptors.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/loki-enclave-facade/adaptors.js","./lib/lokijs/src/lokijs.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/loki-enclave-facade/lib/lokijs/src/lokijs.js","acl-magic":"acl-magic","opendsu":"opendsu"}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/loki-enclave-facade/LokiEnclaveFacade.js":[function(require,module,exports){
function LokiEnclaveFacade(rootFolder, autosaveInterval, adaptorConstructorFunction) {
    const logger = $$.getLogger("LokiEnclaveFacade", "LokiEnclaveFacade.js");
    const LokiDb = require("./LokiDb");
    const openDSU = require("opendsu");
    const aclAPI = require("acl-magic");
    const utils = openDSU.loadAPI("utils");
    logger.info("Creating LokiEnclaveFacade instance");
    const EnclaveMixin = openDSU.loadAPI("enclave").EnclaveMixin;
    EnclaveMixin(this);

    this.close = async () => {
        return await this.storageDB.close();
    }

    this.refresh =  (callback) => {
        this.storageDB.refresh(callback);
    }

    this.saveDatabase =  (forDID, callback) => {
        this.storageDB.saveDatabase(callback);
    }

    this.refreshAsync =  () => {
        let self = this;
        return new Promise((resolve, reject) => {
            self.storageDB.refresh((err)=>{
                if(err){
                    return reject(err);
                }
                resolve();
            });
        });
    }

    const WRITE_ACCESS = "write";
    const READ_ACCESS = "read";
    const WILDCARD = "*";
    const persistence = aclAPI.createEnclavePersistence(this);

    this.grantWriteAccess = (forDID, callback) => {
        persistence.grant(WRITE_ACCESS, WILDCARD, forDID, (err) => {
            if (err) {
                return callback(err);
            }

            this.grantReadAccess(forDID, callback);
        });
    }

    this.hasWriteAccess = (forDID, callback) => {
        persistence.loadResourceDirectGrants(WRITE_ACCESS, forDID, (err, usersWithAccess) => {
            if (err) {
                return callback(err);
            }

            callback(undefined, usersWithAccess.indexOf(WILDCARD) !== -1);
        });
    }

    this.revokeWriteAccess = (forDID, callback) => {
        persistence.ungrant(WRITE_ACCESS, WILDCARD, forDID, callback);
    }

    this.grantReadAccess = (forDID, callback) => {
        persistence.grant(READ_ACCESS, WILDCARD, forDID, callback);
    }

    this.hasReadAccess = (forDID, callback) => {
        persistence.loadResourceDirectGrants(READ_ACCESS, forDID, (err, usersWithAccess) => {
            if (err) {
                return callback(err);
            }

            callback(undefined, usersWithAccess.indexOf(WILDCARD) !== -1);
        });
    }

    this.revokeReadAccess = (forDID, callback) => {
        persistence.ungrant(READ_ACCESS, WILDCARD, forDID, err => {
            if (err) {
                return callback(err);
            }

            this.revokeWriteAccess(forDID, callback);
        });
    }

    this.count = (tableName, callback) => {
        this.storageDB.count(tableName, callback);
    }

    this.addInQueue = (forDID, queueName, encryptedObject, ensureUniqueness, callback) => {
        this.storageDB.addInQueue(queueName, encryptedObject, ensureUniqueness, callback);
    }

    this.queueSize = (forDID, queueName, callback) => {
        this.count(queueName, callback);
    }

    this.listQueue = (forDID, queueName, sortAfterInsertTime, onlyFirstN, callback) => {
        this.storageDB.listQueue(queueName, sortAfterInsertTime, onlyFirstN, callback);
    }

    this.getObjectFromQueue = (forDID, queueName, hash, callback) => {
        return this.getRecord(forDID, queueName, hash, callback)
    }

    this.deleteObjectFromQueue = (forDID, queueName, hash, callback) => {
        return this.deleteRecord(forDID, queueName, hash, callback)
    }

    this.getCollections = (callback) => {
        this.storageDB.getCollections(callback);
    }

    this.createCollection =  (forDID, tableName, indicesList, callback) => {
        if (typeof indicesList === "function") {
            callback = indicesList;
            indicesList = undefined;
        }
        this.storageDB.createCollection(tableName, indicesList, callback);
    }

    this.allowedInReadOnlyMode = function (functionName){
        let readOnlyFunctions = ["getCollections",
            "listQueue",
            "queueSize",
            "count",
            "hasReadAccess",
            "getPrivateInfoForDID",
            "getCapableOfSigningKeySSI",
            "getPathKeyMapping",
            "getDID",
            "getPrivateKeyForSlot",
            "getIndexedFields",
            "getRecord",
            "getAllTableNames",
            "filter",
            "readKey",
            "getAllRecords",
            "getReadForKeySSI",
            "verifyForDID",
            "encryptMessage",
            "decryptMessage"];

        return readOnlyFunctions.indexOf(functionName) !== -1;
    }

    utils.bindAutoPendingFunctions(this, ["on", "off", "dispatchEvent", "beginBatch", "isInitialised", "getEnclaveType", "getDID", "getUniqueIdAsync"]);

    this.storageDB = new LokiDb(rootFolder, autosaveInterval, adaptorConstructorFunction);
    this.finishInitialisation();
}

module.exports = LokiEnclaveFacade;
},{"./LokiDb":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/loki-enclave-facade/LokiDb.js","acl-magic":"acl-magic","opendsu":"opendsu"}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/loki-enclave-facade/adaptors.js":[function(require,module,exports){
const lfsa = require("./lib/lokijs/src/loki-fs-sync-adapter.js");
const lfssa = require("./lib/lokijs/src/loki-fs-structured-adapter.js");

const Adaptors = {
    FS: lfsa,
    STRUCTURED: lfssa
}

module.exports = Adaptors;
},{"./lib/lokijs/src/loki-fs-structured-adapter.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/loki-enclave-facade/lib/lokijs/src/loki-fs-structured-adapter.js","./lib/lokijs/src/loki-fs-sync-adapter.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/loki-enclave-facade/lib/lokijs/src/loki-fs-sync-adapter.js"}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/loki-enclave-facade/lib/lokijs/src/loki-fs-structured-adapter.js":[function(require,module,exports){

/*
  Loki (node) fs structured Adapter (need to require this script to instance and use it).

  This adapter will save database container and each collection to separate files and
  save collection only if it is dirty.  It is also designed to use a destructured serialization 
  method intended to lower the memory overhead of json serialization.
  
  This adapter utilizes ES6 generator/iterator functionality to stream output and
  uses node linereader module to stream input.  This should lower memory pressure 
  in addition to individual object serializations rather than loki's default deep object
  serialization.
*/

(function (root, factory) {
    if (typeof define === 'function' && define.amd) {
        // AMD
        define([], factory);
    } else if (typeof exports === 'object') {
        // Node, CommonJS-like
        module.exports = factory();
    } else {
        // Browser globals (root is window)
        root.LokiFsStructuredAdapter = factory();
    }
}(this, function () {
  return (function() {

    const fs = require('fs');
    const readline = require('readline');
    const stream = require('stream');

    /**
     * Loki structured (node) filesystem adapter class.
     *     This class fulfills the loki 'reference' abstract adapter interface which can be applied to other storage methods. 
     *
     * @constructor LokiFsStructuredAdapter
     *
     */
    function LokiFsStructuredAdapter()
    {
        this.mode = "reference";
        this.dbref = null;
        this.dirtyPartitions = [];
    }

    /**
     * Generator for constructing lines for file streaming output of db container or collection.
     *
     * @param {object=} options - output format options for use externally to loki
     * @param {int=} options.partition - can be used to only output an individual collection or db (-1)
     *
     * @returns {string|array} A custom, restructured aggregation of independent serializations.
     * @memberof LokiFsStructuredAdapter
     */
    LokiFsStructuredAdapter.prototype.generateDestructured = function*(options) {
      var idx, sidx;
      var dbcopy;

      options = options || {};

      if (!options.hasOwnProperty("partition")) {
        options.partition = -1;
      }

      // if partition is -1 we will return database container with no data
      if (options.partition === -1) {
        // instantiate lightweight clone and remove its collection data
        dbcopy = this.dbref.copy();
        
        for(idx=0; idx < dbcopy.collections.length; idx++) {
          dbcopy.collections[idx].data = [];
        }

        yield dbcopy.serialize({
          serializationMethod: "normal"
        });

        return;
      }

      // 'partitioned' along with 'partition' of 0 or greater is a request for single collection serialization
      if (options.partition >= 0) {
        var doccount,
          docidx;

        // dbref collections have all data so work against that
        doccount = this.dbref.collections[options.partition].data.length;

        for(docidx=0; docidx<doccount; docidx++) {
          yield JSON.stringify(this.dbref.collections[options.partition].data[docidx]);
        }
      }
    };

    /**
     * Loki persistence adapter interface function which outputs un-prototype db object reference to load from.
     *
     * @param {string} dbname - the name of the database to retrieve.
     * @param {function} callback - callback should accept string param containing db object reference.
     * @memberof LokiFsStructuredAdapter
     */
    LokiFsStructuredAdapter.prototype.loadDatabase = function(dbname, callback)
    {
      var instream,
        outstream,
        rl,
        self=this;

      this.dbref = null;

      // make sure file exists
      fs.stat(dbname, function (fileErr, stats) {
        var jsonErr;

        if (fileErr) {
          if (fileErr.code === "ENOENT") {
            // file does not exist, so callback with null
            callback(null);
            return;
          }
          else {
            // some other file system error.
            callback(fileErr);
            return;
          }
        }
        else if (!stats.isFile()) {
          // something exists at this path but it isn't a file.
          callback(new Error(dbname + " is not a valid file."));
          return;
        }

        instream = fs.createReadStream(dbname);
        outstream = new stream();
        rl = readline.createInterface(instream, outstream);

        // first, load db container component
        rl.on('line', function(line) {
          // it should single JSON object (a one line file)
          if (self.dbref === null && line !== "") {              
            try {                
              self.dbref = JSON.parse(line);
            } catch (e) {
              jsonErr = e;
            }
          }
        });

        // when that is done, examine its collection array to sequence loading each
        rl.on('close', function() {
          if (jsonErr) {
            // a json error was encountered reading the container file.
            callback(jsonErr);
          } 
          else if (self.dbref.collections.length > 0) {
            self.loadNextCollection(dbname, 0, function() {
              callback(self.dbref);
            });
          }
        });
      });
    };

    /**
     * Recursive function to chain loading of each collection one at a time. 
     * If at some point i can determine how to make async driven generator, this may be converted to generator.
     *
     * @param {string} dbname - the name to give the serialized database within the catalog.
     * @param {int} collectionIndex - the ordinal position of the collection to load.
     * @param {function} callback - callback to pass to next invocation or to call when done
     * @memberof LokiFsStructuredAdapter
     */
    LokiFsStructuredAdapter.prototype.loadNextCollection = function(dbname, collectionIndex, callback) {
      var instream = fs.createReadStream(dbname + "." + collectionIndex);
      var outstream = new stream();
      var rl = readline.createInterface(instream, outstream);
      var self=this,
        obj;

      rl.on('line', function (line) {
        if (line !== "") {
          try {
            obj = JSON.parse(line);
          } catch(e) {
            callback(e);
          }
          self.dbref.collections[collectionIndex].data.push(obj);
        }
      });

      rl.on('close', function (line) {
        instream = null;
        outstream = null;
        rl = null;
        obj = null;

        // if there are more collections, load the next one
        if (++collectionIndex < self.dbref.collections.length) {
          self.loadNextCollection(dbname, collectionIndex, callback);
        }
        // otherwise we are done, callback to loadDatabase so it can return the new db object representation.
        else {
          callback();
        }
      });
    };

    /**
     * Generator for yielding sequence of dirty partition indices to iterate.
     *
     * @memberof LokiFsStructuredAdapter
     */
    LokiFsStructuredAdapter.prototype.getPartition = function*() {
      var idx,
        clen = this.dbref.collections.length;

      // since database container (partition -1) doesn't have dirty flag at db level, always save
      yield -1;
      
      // yield list of dirty partitions for iterateration
      for(idx=0; idx<clen; idx++) {
        if (this.dbref.collections[idx].dirty) {
          yield idx;
        }
      }
    };

    /**
     * Loki reference adapter interface function.  Saves structured json via loki database object reference.
     *
     * @param {string} dbname - the name to give the serialized database within the catalog.
     * @param {object} dbref - the loki database object reference to save.
     * @param {function} callback - callback passed obj.success with true or false
     * @memberof LokiFsStructuredAdapter
     */
    LokiFsStructuredAdapter.prototype.exportDatabase = function(dbname, dbref, callback)
    {
      var idx;

      this.dbref = dbref;

      // create (dirty) partition generator/iterator
      var pi = this.getPartition();

      this.saveNextPartition(dbname, pi, function() {
        callback(null);
      });
      
    };

    /**
     * Utility method for queueing one save at a time
     */
    LokiFsStructuredAdapter.prototype.saveNextPartition = function(dbname, pi, callback) {
      var li;
      var filename;
      var self = this;
      var pinext = pi.next();

      if (pinext.done) {
        callback();
        return;
      }

      // db container (partition -1) uses just dbname for filename,
      // otherwise append collection array index to filename
      filename = dbname + ((pinext.value === -1)?"":("." + pinext.value));

      var wstream = fs.createWriteStream(filename);
      //wstream.on('finish', function() {
      wstream.on('close', function() {
        self.saveNextPartition(dbname, pi, callback);
      });

      li = this.generateDestructured({ partition: pinext.value });

      // iterate each of the lines generated by generateDestructured()
      for(var outline of li) {
        wstream.write(outline + "\n");
      }

      wstream.end();
    };
    
    return LokiFsStructuredAdapter;

  }());
}));

},{"fs":false,"readline":false,"stream":false}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/loki-enclave-facade/lib/lokijs/src/loki-fs-sync-adapter.js":[function(require,module,exports){
/*
  A synchronous version of the Loki Filesystem adapter for node.js

  Intended for diagnostics or environments where synchronous i/o is required.

  This adapter will perform worse than the default LokiFsAdapter but 
  is provided for quick adaptation to synchronous code.
*/

(function (root, factory) {
    if (typeof define === 'function' && define.amd) {
        // AMD
        define([], factory);
    } else if (typeof exports === 'object') {
        // Node, CommonJS-like
        module.exports = factory();
    } else {
        // Browser globals (root is window)
        root.LokiFsSyncAdapter = factory();
    }
}(this, function () {
  return (function() {
    'use strict';

    /**
     * A loki persistence adapter which persists using node fs module
     * @constructor LokiFsSyncAdapter
     */
    function LokiFsSyncAdapter() {
      this.fs = require('fs');
    }

    /**
     * loadDatabase() - Load data from file, will throw an error if the file does not exist
     * @param {string} dbname - the filename of the database to load
     * @param {function} callback - the callback to handle the result
     * @memberof LokiFsSyncAdapter
     */
    LokiFsSyncAdapter.prototype.loadDatabase = function loadDatabase(dbname, callback) {
      var self = this;
      var contents;

      try {
        var stats = this.fs.statSync(dbname);
        if (stats.isFile()) {
          contents = self.fs.readFileSync(dbname, {
            encoding: 'utf8'
          });
          
          callback(contents);
        }
        else {
          callback(null);
        }
      }
      catch (err) {
        // first autoload when file doesn't exist yet
        // should not throw error but leave default
        // blank database.
        if (err.code === "ENOENT") {
          callback(null);
        }
        
        callback(err);
      }
    };

    /**
     * saveDatabase() - save data to file, will throw an error if the file can't be saved
     * might want to expand this to avoid dataloss on partial save
     * @param {string} dbname - the filename of the database to load
     * @param {function} callback - the callback to handle the result
     * @memberof LokiFsSyncAdapter
     */
    LokiFsSyncAdapter.prototype.saveDatabase = function saveDatabase(dbname, dbstring, callback) {
      try {
        this.fs.writeFileSync(dbname, dbstring);
        callback();
      }
      catch (err) {
        callback(err);
      }
    };

    /**
     * deleteDatabase() - delete the database file, will throw an error if the
     * file can't be deleted
     * @param {string} dbname - the filename of the database to delete
     * @param {function} callback - the callback to handle the result
     * @memberof LokiFsSyncAdapter
     */
    LokiFsSyncAdapter.prototype.deleteDatabase = function deleteDatabase(dbname, callback) {
      try {
        this.fs.unlinkSync(dbname);
        callback();
      }
      catch (err) {
        callback(err);
      }
    };

    return LokiFsSyncAdapter;

  }());
}));

},{"fs":false}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/loki-enclave-facade/lib/lokijs/src/loki-indexed-adapter.js":[function(require,module,exports){
/*
  Loki IndexedDb Adapter (need to include this script to use it)

  Console Usage can be used for management/diagnostic, here are a few examples :
  adapter.getDatabaseList(); // with no callback passed, this method will log results to console
  adapter.saveDatabase('UserDatabase', JSON.stringify(myDb));
  adapter.loadDatabase('UserDatabase'); // will log the serialized db to console
  adapter.deleteDatabase('UserDatabase');
*/

(function (root, factory) {
    if (typeof define === 'function' && define.amd) {
        // AMD
        define([], factory);
    } else if (typeof exports === 'object') {
        // Node, CommonJS-like
        module.exports = factory();
    } else {
        // Browser globals (root is window)
        root.LokiIndexedAdapter = factory();
    }
}(this, function () {
  return (function() {

    /**
     * Loki persistence adapter class for indexedDb.
     *     This class fulfills abstract adapter interface which can be applied to other storage methods.
     *     Utilizes the included LokiCatalog app/key/value database for actual database persistence.
     *     Indexeddb is highly async, but this adapter has been made 'console-friendly' as well.
     *     Anywhere a callback is omitted, it should return results (if applicable) to console.
     *     IndexedDb storage is provided per-domain, so we implement app/key/value database to
     *     allow separate contexts for separate apps within a domain.
     *
     * @example
     * var idbAdapter = new LokiIndexedAdapter('finance');
     *
     * @constructor LokiIndexedAdapter
     *
     * @param {string} appname - (Optional) Application name context can be used to distinguish subdomains, 'loki' by default
     * @param {object=} options Configuration options for the adapter
     * @param {boolean} options.closeAfterSave Whether the indexedDB database should be closed after saving.
     */
    function LokiIndexedAdapter(appname, options)
    {
      this.app = 'loki';
      this.options = options || {};

      if (typeof (appname) !== 'undefined')
      {
        this.app = appname;
      }

      // keep reference to catalog class for base AKV operations
      this.catalog = null;

      if (!this.checkAvailability()) {
        throw new Error('indexedDB does not seem to be supported for your environment');
      }
    }

    /**
     * Used for closing the indexeddb database.
     */
    LokiIndexedAdapter.prototype.closeDatabase = function ()
    {
      if (this.catalog && this.catalog.db) {
        this.catalog.db.close();
        this.catalog.db = null;
      }
    };

    /**
     * Used to check if adapter is available
     *
     * @returns {boolean} true if indexeddb is available, false if not.
     * @memberof LokiIndexedAdapter
     */
    LokiIndexedAdapter.prototype.checkAvailability = function()
    {
      if (typeof indexedDB !== 'undefined' && indexedDB) return true;

      return false;
    };

    /**
     * Retrieves a serialized db string from the catalog.
     *
     * @example
     * // LOAD
     * var idbAdapter = new LokiIndexedAdapter('finance');
     * var db = new loki('test', { adapter: idbAdapter });
     *   db.loadDatabase(function(result) {
     *   console.log('done');
     * });
     *
     * @param {string} dbname - the name of the database to retrieve.
     * @param {function} callback - callback should accept string param containing serialized db string.
     * @memberof LokiIndexedAdapter
     */
    LokiIndexedAdapter.prototype.loadDatabase = function(dbname, callback)
    {
      var appName = this.app;
      var adapter = this;

      // lazy open/create db reference so dont -need- callback in constructor
      if (this.catalog === null || this.catalog.db === null) {
        this.catalog = new LokiCatalog(function(cat) {
          adapter.catalog = cat;

          adapter.loadDatabase(dbname, callback);
        });

        return;
      }

      // lookup up db string in AKV db
      this.catalog.getAppKey(appName, dbname, function(result) {
        if (typeof (callback) === 'function') {
          if (result.id === 0) {
            callback(null);
            return;
          }
          callback(result.val);
        }
        else {
          // support console use of api
          console.log(result.val);
        }
      });
    };

    // alias
    LokiIndexedAdapter.prototype.loadKey = LokiIndexedAdapter.prototype.loadDatabase;

    /**
     * Saves a serialized db to the catalog.
     *
     * @example
     * // SAVE : will save App/Key/Val as 'finance'/'test'/{serializedDb}
     * var idbAdapter = new LokiIndexedAdapter('finance');
     * var db = new loki('test', { adapter: idbAdapter });
     * var coll = db.addCollection('testColl');
     * coll.insert({test: 'val'});
     * db.saveDatabase();  // could pass callback if needed for async complete
     *
     * @param {string} dbname - the name to give the serialized database within the catalog.
     * @param {string} dbstring - the serialized db string to save.
     * @param {function} callback - (Optional) callback passed obj.success with true or false
     * @memberof LokiIndexedAdapter
     */
    LokiIndexedAdapter.prototype.saveDatabase = function(dbname, dbstring, callback)
    {
      var appName = this.app;
      var adapter = this;

      function saveCallback(result) {
        if (result && result.success === true) {
          callback(null);
        }
        else {
          callback(new Error("Error saving database"));
        }

        if (adapter.options.closeAfterSave) {
          adapter.closeDatabase();
        }
      }

      // lazy open/create db reference so dont -need- callback in constructor
      if (this.catalog === null || this.catalog.db === null) {
        this.catalog = new LokiCatalog(function(cat) {
          adapter.saveDatabase(dbname, dbstring, saveCallback);
        });

        return;
      }

      // set (add/update) entry to AKV database
      this.catalog.setAppKey(appName, dbname, dbstring, saveCallback);
    };

    // alias
    LokiIndexedAdapter.prototype.saveKey = LokiIndexedAdapter.prototype.saveDatabase;

    /**
     * Deletes a serialized db from the catalog.
     *
     * @example
     * // DELETE DATABASE
     * // delete 'finance'/'test' value from catalog
     * idbAdapter.deleteDatabase('test', function {
     *   // database deleted
     * });
     *
     * @param {string} dbname - the name of the database to delete from the catalog.
     * @param {function=} callback - (Optional) executed on database delete
     * @memberof LokiIndexedAdapter
     */
    LokiIndexedAdapter.prototype.deleteDatabase = function(dbname, callback)
    {
      var appName = this.app;
      var adapter = this;

      // lazy open/create db reference and pass callback ahead
      if (this.catalog === null || this.catalog.db === null) {
        this.catalog = new LokiCatalog(function(cat) {
          adapter.catalog = cat;

          adapter.deleteDatabase(dbname, callback);
        });

        return;
      }

      // catalog was already initialized, so just lookup object and delete by id
      this.catalog.getAppKey(appName, dbname, function(result) {
        var id = result.id;

        if (id !== 0) {
          adapter.catalog.deleteAppKey(id, callback);
        } else if (typeof (callback) === 'function') {
          callback({ success: true });
        }
      });
    };

    // alias
    LokiIndexedAdapter.prototype.deleteKey = LokiIndexedAdapter.prototype.deleteDatabase;

    /**
     * Removes all database partitions and pages with the base filename passed in.
     * This utility method does not (yet) guarantee async deletions will be completed before returning
     *
     * @param {string} dbname - the base filename which container, partitions, or pages are derived
     * @memberof LokiIndexedAdapter
     */
    LokiIndexedAdapter.prototype.deleteDatabasePartitions = function(dbname) {
      var self=this;
      this.getDatabaseList(function(result) {
        result.forEach(function(str) {
          if (str.startsWith(dbname)) {
            self.deleteDatabase(str);
          }
        });
      });
    };

    /**
     * Retrieves object array of catalog entries for current app.
     *
     * @example
     * idbAdapter.getDatabaseList(function(result) {
     *   // result is array of string names for that appcontext ('finance')
     *   result.forEach(function(str) {
     *     console.log(str);
     *   });
     * });
     *
     * @param {function} callback - should accept array of database names in the catalog for current app.
     * @memberof LokiIndexedAdapter
     */
    LokiIndexedAdapter.prototype.getDatabaseList = function(callback)
    {
      var appName = this.app;
      var adapter = this;

      // lazy open/create db reference so dont -need- callback in constructor
      if (this.catalog === null || this.catalog.db === null) {
        this.catalog = new LokiCatalog(function(cat) {
          adapter.catalog = cat;

          adapter.getDatabaseList(callback);
        });

        return;
      }

      // catalog already initialized
      // get all keys for current appName, and transpose results so just string array
      this.catalog.getAppKeys(appName, function(results) {
        var names = [];

        for(var idx = 0; idx < results.length; idx++) {
          names.push(results[idx].key);
        }

        if (typeof (callback) === 'function') {
          callback(names);
        }
        else {
          names.forEach(function(obj) {
            console.log(obj);
          });
        }
      });
    };

    // alias
    LokiIndexedAdapter.prototype.getKeyList = LokiIndexedAdapter.prototype.getDatabaseList;

    /**
     * Allows retrieval of list of all keys in catalog along with size
     *
     * @param {function} callback - (Optional) callback to accept result array.
     * @memberof LokiIndexedAdapter
     */
    LokiIndexedAdapter.prototype.getCatalogSummary = function(callback)
    {
      var appName = this.app;
      var adapter = this;

      // lazy open/create db reference
      if (this.catalog === null || this.catalog.db === null) {
        this.catalog = new LokiCatalog(function(cat) {
          adapter.catalog = cat;

          adapter.getCatalogSummary(callback);
        });

        return;
      }

      // catalog already initialized
      // get all keys for current appName, and transpose results so just string array
      this.catalog.getAllKeys(function(results) {
        var entries = [];
        var obj,
          size,
          oapp,
          okey,
          oval;

        for(var idx = 0; idx < results.length; idx++) {
          obj = results[idx];
          oapp = obj.app || '';
          okey = obj.key || '';
          oval = obj.val || '';

          // app and key are composited into an appkey column so we will mult by 2
          size = oapp.length * 2 + okey.length * 2 + oval.length + 1;

          entries.push({ "app": obj.app, "key": obj.key, "size": size });
        }

        if (typeof (callback) === 'function') {
          callback(entries);
        }
        else {
          entries.forEach(function(obj) {
            console.log(obj);
          });
        }
      });
    };

    /**
     * LokiCatalog - underlying App/Key/Value catalog persistence
     *    This non-interface class implements the actual persistence.
     *    Used by the IndexedAdapter class.
     */
    function LokiCatalog(callback)
    {
      this.db = null;
      this.initializeLokiCatalog(callback);
    }

    LokiCatalog.prototype.initializeLokiCatalog = function(callback) {
      var openRequest = indexedDB.open('LokiCatalog', 1);
      var cat = this;

      // If database doesn't exist yet or its version is lower than our version specified above (2nd param in line above)
      openRequest.onupgradeneeded = function(e) {
        var thisDB = e.target.result;
        if (thisDB.objectStoreNames.contains('LokiAKV')) {
          thisDB.deleteObjectStore('LokiAKV');
        }

        if(!thisDB.objectStoreNames.contains('LokiAKV')) {
          var objectStore = thisDB.createObjectStore('LokiAKV', { keyPath: 'id', autoIncrement:true });
          objectStore.createIndex('app', 'app', {unique:false});
          objectStore.createIndex('key', 'key', {unique:false});
          // hack to simulate composite key since overhead is low (main size should be in val field)
          // user (me) required to duplicate the app and key into comma delimited appkey field off object
          // This will allow retrieving single record with that composite key as well as
          // still supporting opening cursors on app or key alone
          objectStore.createIndex('appkey', 'appkey', {unique:true});
        }
      };

      openRequest.onsuccess = function(e) {
        cat.db = e.target.result;

        if (typeof (callback) === 'function') callback(cat);
      };

      openRequest.onerror = function(e) {
        throw e;
      };
    };

    LokiCatalog.prototype.getAppKey = function(app, key, callback) {
      var transaction = this.db.transaction(['LokiAKV'], 'readonly');
      var store = transaction.objectStore('LokiAKV');
      var index = store.index('appkey');
      var appkey = app + "," + key;
      var request = index.get(appkey);

      request.onsuccess = (function(usercallback) {
        return function(e) {
          var lres = e.target.result;

          if (lres === null || typeof(lres) === 'undefined') {
            lres = {
              id: 0,
              success: false
            };
          }

          if (typeof(usercallback) === 'function') {
            usercallback(lres);
          }
          else {
            console.log(lres);
          }
        };
      })(callback);

      request.onerror = (function(usercallback) {
        return function(e) {
          if (typeof(usercallback) === 'function') {
            usercallback({ id: 0, success: false });
          }
          else {
            throw e;
          }
        };
      })(callback);
    };

    LokiCatalog.prototype.getAppKeyById = function (id, callback, data) {
      var transaction = this.db.transaction(['LokiAKV'], 'readonly');
      var store = transaction.objectStore('LokiAKV');
      var request = store.get(id);

      request.onsuccess = (function(data, usercallback){
        return function(e) {
          if (typeof(usercallback) === 'function') {
            usercallback(e.target.result, data);
          }
          else {
            console.log(e.target.result);
          }
        };
      })(data, callback);
    };

    LokiCatalog.prototype.setAppKey = function (app, key, val, callback) {
      var transaction = this.db.transaction(['LokiAKV'], 'readwrite');
      var store = transaction.objectStore('LokiAKV');
      var index = store.index('appkey');
      var appkey = app + "," + key;
      var request = index.get(appkey);

      // first try to retrieve an existing object by that key
      // need to do this because to update an object you need to have id in object, otherwise it will append id with new autocounter and clash the unique index appkey
      request.onsuccess = function(e) {
        var res = e.target.result;

        if (res === null || res === undefined) {
          res = {
            app:app,
            key:key,
            appkey: app + ',' + key,
            val:val
          };
        }
        else {
          res.val = val;
        }

        var requestPut = store.put(res);

        requestPut.onerror = (function(usercallback) {
          return function(e) {
            if (typeof(usercallback) === 'function') {
              usercallback({ success: false });
            }
            else {
              console.error('LokiCatalog.setAppKey (set) onerror');
              console.error(request.error);
            }
          };

        })(callback);

        requestPut.onsuccess = (function(usercallback) {
          return function(e) {
            if (typeof(usercallback) === 'function') {
              usercallback({ success: true });
            }
          };
        })(callback);
      };

      request.onerror = (function(usercallback) {
        return function(e) {
          if (typeof(usercallback) === 'function') {
            usercallback({ success: false });
          }
          else {
            console.error('LokiCatalog.setAppKey (get) onerror');
            console.error(request.error);
          }
        };
      })(callback);
    };

    LokiCatalog.prototype.deleteAppKey = function (id, callback) {
      var transaction = this.db.transaction(['LokiAKV'], 'readwrite');
      var store = transaction.objectStore('LokiAKV');
      var request = store.delete(id);

      request.onsuccess = (function(usercallback) {
        return function(evt) {
          if (typeof(usercallback) === 'function') usercallback({ success: true });
        };
      })(callback);

      request.onerror = (function(usercallback) {
        return function(evt) {
          if (typeof(usercallback) === 'function') {
            usercallback({ success: false });
          }
          else {
            console.error('LokiCatalog.deleteAppKey raised onerror');
            console.error(request.error);
          }
        };
      })(callback);
    };

    LokiCatalog.prototype.getAppKeys = function(app, callback) {
      var transaction = this.db.transaction(['LokiAKV'], 'readonly');
      var store = transaction.objectStore('LokiAKV');
      var index = store.index('app');

      // We want cursor to all values matching our (single) app param
      var singleKeyRange = IDBKeyRange.only(app);

      // To use one of the key ranges, pass it in as the first argument of openCursor()/openKeyCursor()
      var cursor = index.openCursor(singleKeyRange);

      // cursor internally, pushing results into this.data[] and return
      // this.data[] when done (similar to service)
      var localdata = [];

      cursor.onsuccess = (function(data, callback) {
        return function(e) {
          var cursor = e.target.result;
          if (cursor) {
            var currObject = cursor.value;

            data.push(currObject);

            cursor.continue();
          }
          else {
            if (typeof(callback) === 'function') {
              callback(data);
            }
            else {
              console.log(data);
            }
          }
        };
      })(localdata, callback);

      cursor.onerror = (function(usercallback) {
        return function(e) {
          if (typeof(usercallback) === 'function') {
            usercallback(null);
          }
          else {
            console.error('LokiCatalog.getAppKeys raised onerror');
            console.error(e);
          }
        };
      })(callback);

    };

    // Hide 'cursoring' and return array of { id: id, key: key }
    LokiCatalog.prototype.getAllKeys = function (callback) {
      var transaction = this.db.transaction(['LokiAKV'], 'readonly');
      var store = transaction.objectStore('LokiAKV');
      var cursor = store.openCursor();

      var localdata = [];

      cursor.onsuccess = (function(data, callback) {
        return function(e) {
          var cursor = e.target.result;
          if (cursor) {
            var currObject = cursor.value;

            data.push(currObject);

            cursor.continue();
          }
          else {
            if (typeof(callback) === 'function') {
              callback(data);
            }
            else {
              console.log(data);
            }
          }
        };
      })(localdata, callback);

      cursor.onerror = (function(usercallback) {
        return function(e) {
          if (typeof(usercallback) === 'function') usercallback(null);
        };
      })(callback);

    };

    return LokiIndexedAdapter;

  }());
}));

},{}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/loki-enclave-facade/lib/lokijs/src/lokijs.js":[function(require,module,exports){
(function (global){(function (){
/**
 * LokiJS
 * @author Joe Minichino <joe.minichino@gmail.com>
 *
 * A lightweight document oriented javascript database
 */
(function (root, factory) {
  if (typeof define === 'function' && define.amd) {
    // AMD
    define([], factory);
  } else if (typeof exports === 'object') {
    // CommonJS
    module.exports = factory();
  } else {
    // Browser globals
    root.loki = factory();
  }
}(this, function () {

  return (function () {
    'use strict';

    var hasOwnProperty = Object.prototype.hasOwnProperty;

    function deepFreeze(obj) {
      var prop, i;
      if (Array.isArray(obj)) {
        for (i = 0; i < obj.length; i++) {
          deepFreeze(obj[i]);
        }
        freeze(obj);
      } else if (obj !== null && (typeof obj === 'object')) {
        for (prop in obj) {
          if (obj.hasOwnProperty(prop)) {
            deepFreeze(obj[prop]);
          }
        }
        freeze(obj);
      }
    }

    function freeze(obj) {
      if (!Object.isFrozen(obj)) {
        Object.freeze(obj);
      }
    }

    function unFreeze(obj) {
      if (!Object.isFrozen(obj)) {
        return obj;
      }
      return clone(obj, 'shallow');
    }

    var Utils = {
      copyProperties: function (src, dest) {
        var prop;
        for (prop in src) {
          dest[prop] = src[prop];
        }
      },
      // used to recursively scan hierarchical transform step object for param substitution
      resolveTransformObject: function (subObj, params, depth) {
        var prop,
          pname;

        if (typeof depth !== 'number') {
          depth = 0;
        }

        if (++depth >= 10) return subObj;

        for (prop in subObj) {
          if (typeof subObj[prop] === 'string' && subObj[prop].indexOf("[%lktxp]") === 0) {
            pname = subObj[prop].substring(8);
            if (params.hasOwnProperty(pname)) {
              subObj[prop] = params[pname];
            }
          } else if (typeof subObj[prop] === "object") {
            subObj[prop] = Utils.resolveTransformObject(subObj[prop], params, depth);
          }
        }

        return subObj;
      },
      // top level utility to resolve an entire (single) transform (array of steps) for parameter substitution
      resolveTransformParams: function (transform, params) {
        var idx,
          clonedStep,
          resolvedTransform = [];

        if (typeof params === 'undefined') return transform;

        // iterate all steps in the transform array
        for (idx = 0; idx < transform.length; idx++) {
          // clone transform so our scan/replace can operate directly on cloned transform
          clonedStep = clone(transform[idx], "shallow-recurse-objects");
          resolvedTransform.push(Utils.resolveTransformObject(clonedStep, params));
        }

        return resolvedTransform;
      },

      // By default (if usingDotNotation is false), looks up path in
      // object via `object[path]`
      //
      // If `usingDotNotation` is true, then the path is assumed to
      // represent a nested path. It can be in the form of an array of
      // field names, or a period delimited string. The function will
      // look up the value of object[path[0]], and then call
      // result[path[1]] on the result, etc etc.
      //
      // If `usingDotNotation` is true, this function still supports
      // non nested fields.
      //
      // `usingDotNotation` is a performance optimization. The caller
      // may know that a path is *not* nested. In which case, this
      // function avoids a costly string.split('.')
      //
      // examples:
      // getIn({a: 1}, "a") => 1
      // getIn({a: 1}, "a", true) => 1
      // getIn({a: {b: 1}}, ["a", "b"], true) => 1
      // getIn({a: {b: 1}}, "a.b", true) => 1
      getIn: function (object, path, usingDotNotation) {
        if (object == null) {
          return undefined;
        }
        if (!usingDotNotation) {
          return object[path];
        }

        if (typeof (path) === "string") {
          path = path.split(".");
        }

        if (!Array.isArray(path)) {
          throw new Error("path must be a string or array. Found " + typeof (path));
        }

        var index = 0,
          length = path.length;

        while (object != null && index < length) {
          object = object[path[index++]];
        }
        return (index && index == length) ? object : undefined;
      }
    };

    // wrapping in object to expose to default export for potential user override.
    // warning: overriding these methods will override behavior for all loki db instances in memory.
    // warning: if you use binary indices these comparators should be the same for all inserts/updates/removes.
    var Comparators = {
      aeq: aeqHelper,
      lt: ltHelper,
      gt: gtHelper
    };

    /** Helper function for determining 'loki' abstract equality which is a little more abstract than ==
     *     aeqHelper(5, '5') === true
     *     aeqHelper(5.0, '5') === true
     *     aeqHelper(new Date("1/1/2011"), new Date("1/1/2011")) === true
     *     aeqHelper({a:1}, {z:4}) === true (all objects sorted equally)
     *     aeqHelper([1, 2, 3], [1, 3]) === false
     *     aeqHelper([1, 2, 3], [1, 2, 3]) === true
     *     aeqHelper(undefined, null) === true
     */
    function aeqHelper(prop1, prop2) {
      var cv1, cv2, t1, t2;

      if (prop1 === prop2) return true;

      // 'falsy' and Boolean handling
      if (!prop1 || !prop2 || prop1 === true || prop2 === true || prop1 !== prop1 || prop2 !== prop2) {
        // dates and NaN conditions (typed dates before serialization)
        switch (prop1) {
          case undefined: t1 = 1; break;
          case null: t1 = 1; break;
          case false: t1 = 3; break;
          case true: t1 = 4; break;
          case "": t1 = 5; break;
          default: t1 = (prop1 === prop1) ? 9 : 0; break;
        }

        switch (prop2) {
          case undefined: t2 = 1; break;
          case null: t2 = 1; break;
          case false: t2 = 3; break;
          case true: t2 = 4; break;
          case "": t2 = 5; break;
          default: t2 = (prop2 === prop2) ? 9 : 0; break;
        }

        // one or both is edge case
        if (t1 !== 9 || t2 !== 9) {
          return (t1 === t2);
        }
      }

      // Handle 'Number-like' comparisons
      cv1 = Number(prop1);
      cv2 = Number(prop2);

      // if one or both are 'number-like'...
      if (cv1 === cv1 || cv2 === cv2) {
        return (cv1 === cv2);
      }

      // not strict equal nor less than nor gt so must be mixed types, convert to string and use that to compare
      cv1 = prop1.toString();
      cv2 = prop2.toString();

      return (cv1 == cv2);
    }

    /** Helper function for determining 'less-than' conditions for ops, sorting, and binary indices.
     *     In the future we might want $lt and $gt ops to use their own functionality/helper.
     *     Since binary indices on a property might need to index [12, NaN, new Date(), Infinity], we
     *     need this function (as well as gtHelper) to always ensure one value is LT, GT, or EQ to another.
     */
    function ltHelper(prop1, prop2, equal) {
      var cv1, cv2, t1, t2;

      // if one of the params is falsy or strictly true or not equal to itself
      // 0, 0.0, "", NaN, null, undefined, not defined, false, true
      if (!prop1 || !prop2 || prop1 === true || prop2 === true || prop1 !== prop1 || prop2 !== prop2) {
        switch (prop1) {
          case undefined: t1 = 1; break;
          case null: t1 = 1; break;
          case false: t1 = 3; break;
          case true: t1 = 4; break;
          case "": t1 = 5; break;
          // if strict equal probably 0 so sort higher, otherwise probably NaN so sort lower than even null
          default: t1 = (prop1 === prop1) ? 9 : 0; break;
        }

        switch (prop2) {
          case undefined: t2 = 1; break;
          case null: t2 = 1; break;
          case false: t2 = 3; break;
          case true: t2 = 4; break;
          case "": t2 = 5; break;
          default: t2 = (prop2 === prop2) ? 9 : 0; break;
        }

        // one or both is edge case
        if (t1 !== 9 || t2 !== 9) {
          return (t1 === t2) ? equal : (t1 < t2);
        }
      }

      // if both are numbers (string encoded or not), compare as numbers
      cv1 = Number(prop1);
      cv2 = Number(prop2);

      if (cv1 === cv1 && cv2 === cv2) {
        if (cv1 < cv2) return true;
        if (cv1 > cv2) return false;
        return equal;
      }

      if (cv1 === cv1 && cv2 !== cv2) {
        return true;
      }

      if (cv2 === cv2 && cv1 !== cv1) {
        return false;
      }

      if (prop1 < prop2) return true;
      if (prop1 > prop2) return false;
      if (prop1 == prop2) return equal;

      // not strict equal nor less than nor gt so must be mixed types, convert to string and use that to compare
      cv1 = prop1.toString();
      cv2 = prop2.toString();

      if (cv1 < cv2) {
        return true;
      }

      if (cv1 == cv2) {
        return equal;
      }

      return false;
    }

    function gtHelper(prop1, prop2, equal) {
      var cv1, cv2, t1, t2;

      // 'falsy' and Boolean handling
      if (!prop1 || !prop2 || prop1 === true || prop2 === true || prop1 !== prop1 || prop2 !== prop2) {
        switch (prop1) {
          case undefined: t1 = 1; break;
          case null: t1 = 1; break;
          case false: t1 = 3; break;
          case true: t1 = 4; break;
          case "": t1 = 5; break;
          // NaN 0
          default: t1 = (prop1 === prop1) ? 9 : 0; break;
        }

        switch (prop2) {
          case undefined: t2 = 1; break;
          case null: t2 = 1; break;
          case false: t2 = 3; break;
          case true: t2 = 4; break;
          case "": t2 = 5; break;
          default: t2 = (prop2 === prop2) ? 9 : 0; break;
        }

        // one or both is edge case
        if (t1 !== 9 || t2 !== 9) {
          return (t1 === t2) ? equal : (t1 > t2);
        }
      }

      // if both are numbers (string encoded or not), compare as numbers
      cv1 = Number(prop1);
      cv2 = Number(prop2);
      if (cv1 === cv1 && cv2 === cv2) {
        if (cv1 > cv2) return true;
        if (cv1 < cv2) return false;
        return equal;
      }

      if (cv1 === cv1 && cv2 !== cv2) {
        return false;
      }

      if (cv2 === cv2 && cv1 !== cv1) {
        return true;
      }

      if (prop1 > prop2) return true;
      if (prop1 < prop2) return false;
      if (prop1 == prop2) return equal;

      // not strict equal nor less than nor gt so must be dates or mixed types
      // convert to string and use that to compare
      cv1 = prop1.toString();
      cv2 = prop2.toString();

      if (cv1 > cv2) {
        return true;
      }

      if (cv1 == cv2) {
        return equal;
      }

      return false;
    }

    function sortHelper(prop1, prop2, desc) {
      if (Comparators.aeq(prop1, prop2)) return 0;

      if (Comparators.lt(prop1, prop2, false)) {
        return (desc) ? (1) : (-1);
      }

      if (Comparators.gt(prop1, prop2, false)) {
        return (desc) ? (-1) : (1);
      }

      // not lt, not gt so implied equality-- date compatible
      return 0;
    }

    /**
     * compoundeval() - helper function for compoundsort(), performing individual object comparisons
     *
     * @param {array} properties - array of property names, in order, by which to evaluate sort order
     * @param {object} obj1 - first object to compare
     * @param {object} obj2 - second object to compare
     * @returns {integer} 0, -1, or 1 to designate if identical (sortwise) or which should be first
     */
    function compoundeval(properties, obj1, obj2) {
      var res = 0;
      var prop, field, val1, val2, arr, path;
      for (var i = 0, len = properties.length; i < len; i++) {
        prop = properties[i];
        field = prop[0];
        if (~field.indexOf('.')) {
          arr = field.split('.');
          val1 = Utils.getIn(obj1, arr, true);
          val2 = Utils.getIn(obj2, arr, true);
        } else {
          val1 = obj1[field];
          val2 = obj2[field];
        }
        res = sortHelper(val1, val2, prop[1]);
        if (res !== 0) {
          return res;
        }
      }
      return 0;
    }

    /**
     * dotSubScan - helper function used for dot notation queries.
     *
     * @param {object} root - object to traverse
     * @param {array} paths - array of properties to drill into
     * @param {function} fun - evaluation function to test with
     * @param {any} value - comparative value to also pass to (compare) fun
     * @param {any} extra - extra arg to also pass to compare fun
     * @param {number} poffset - index of the item in 'paths' to start the sub-scan from
     */
    function dotSubScan(root, paths, fun, value, extra, poffset) {
      var pathOffset = poffset || 0;
      var path = paths[pathOffset];

      var valueFound = false;
      var element;
      if (typeof root === 'object' && path in root) {
        element = root[path];
      }
      if (pathOffset + 1 >= paths.length) {
        // if we have already expanded out the dot notation,
        // then just evaluate the test function and value on the element
        valueFound = fun(element, value, extra);
      } else if (Array.isArray(element)) {
        for (var index = 0, len = element.length; index < len; index += 1) {
          valueFound = dotSubScan(element[index], paths, fun, value, extra, pathOffset + 1);
          if (valueFound === true) {
            break;
          }
        }
      } else {
        valueFound = dotSubScan(element, paths, fun, value, extra, pathOffset + 1);
      }

      return valueFound;
    }

    function containsCheckFn(a) {
      if (typeof a === 'string' || Array.isArray(a)) {
        return function (b) {
          return a.indexOf(b) !== -1;
        };
      } else if (typeof a === 'object' && a !== null) {
        return function (b) {
          return hasOwnProperty.call(a, b);
        };
      }
      return null;
    }

    function doQueryOp(val, op, record) {
      for (var p in op) {
        if (hasOwnProperty.call(op, p)) {
          return LokiOps[p](val, op[p], record);
        }
      }
      return false;
    }

    var LokiOps = {
      // comparison operators
      // a is the value in the collection
      // b is the query value
      $eq: function (a, b) {
        return a === b;
      },

      // abstract/loose equality
      $aeq: function (a, b) {
        return a == b;
      },

      $ne: function (a, b) {
        // ecma 5 safe test for NaN
        if (b !== b) {
          // ecma 5 test value is not NaN
          return (a === a);
        }

        return a !== b;
      },
      // date equality / loki abstract equality test
      $dteq: function (a, b) {
        return Comparators.aeq(a, b);
      },

      // loki comparisons: return identical unindexed results as indexed comparisons
      $gt: function (a, b) {
        return Comparators.gt(a, b, false);
      },

      $gte: function (a, b) {
        return Comparators.gt(a, b, true);
      },

      $lt: function (a, b) {
        return Comparators.lt(a, b, false);
      },

      $lte: function (a, b) {
        return Comparators.lt(a, b, true);
      },

      // lightweight javascript comparisons
      $jgt: function (a, b) {
        return a > b;
      },

      $jgte: function (a, b) {
        return a >= b;
      },

      $jlt: function (a, b) {
        return a < b;
      },

      $jlte: function (a, b) {
        return a <= b;
      },

      // ex : coll.find({'orderCount': {$between: [10, 50]}});
      $between: function (a, vals) {
        if (a === undefined || a === null) return false;
        return (Comparators.gt(a, vals[0], true) && Comparators.lt(a, vals[1], true));
      },

      $jbetween: function (a, vals) {
        if (a === undefined || a === null) return false;
        return (a >= vals[0] && a <= vals[1]);
      },

      $in: function (a, b) {
        return b.indexOf(a) !== -1;
      },

      $inSet: function(a, b) {
        return b.has(a);
      },

      $nin: function (a, b) {
        return b.indexOf(a) === -1;
      },

      $keyin: function (a, b) {
        return a in b;
      },

      $nkeyin: function (a, b) {
        return !(a in b);
      },

      $definedin: function (a, b) {
        return b[a] !== undefined;
      },

      $undefinedin: function (a, b) {
        return b[a] === undefined;
      },

      $regex: function (a, b) {
        return b.test(a);
      },

      $containsString: function (a, b) {
        return (typeof a === 'string') && (a.indexOf(b) !== -1);
      },

      $containsNone: function (a, b) {
        return !LokiOps.$containsAny(a, b);
      },

      $containsAny: function (a, b) {
        var checkFn = containsCheckFn(a);
        if (checkFn !== null) {
          return (Array.isArray(b)) ? (b.some(checkFn)) : (checkFn(b));
        }
        return false;
      },

      $contains: function (a, b) {
        var checkFn = containsCheckFn(a);
        if (checkFn !== null) {
          return (Array.isArray(b)) ? (b.every(checkFn)) : (checkFn(b));
        }
        return false;
      },

      $elemMatch: function (a, b) {
        if (Array.isArray(a)) {
          return a.some(function (item) {
            return Object.keys(b).every(function (property) {
              var filter = b[property];
              if (!(typeof filter === 'object' && filter)) {
                filter = { $eq: filter };
              }

              if (property.indexOf('.') !== -1) {
                return dotSubScan(item, property.split('.'), doQueryOp, b[property], item);
              }
              return doQueryOp(item[property], filter, item);
            });
          });
        }
        return false;
      },

      $type: function (a, b, record) {
        var type = typeof a;
        if (type === 'object') {
          if (Array.isArray(a)) {
            type = 'array';
          } else if (a instanceof Date) {
            type = 'date';
          }
        }
        return (typeof b !== 'object') ? (type === b) : doQueryOp(type, b, record);
      },

      $finite: function (a, b) {
        return (b === isFinite(a));
      },

      $size: function (a, b, record) {
        if (Array.isArray(a)) {
          return (typeof b !== 'object') ? (a.length === b) : doQueryOp(a.length, b, record);
        }
        return false;
      },

      $len: function (a, b, record) {
        if (typeof a === 'string') {
          return (typeof b !== 'object') ? (a.length === b) : doQueryOp(a.length, b, record);
        }
        return false;
      },

      $where: function (a, b) {
        return b(a) === true;
      },

      // field-level logical operators
      // a is the value in the collection
      // b is the nested query operation (for '$not')
      //   or an array of nested query operations (for '$and' and '$or')
      $not: function (a, b, record) {
        return !doQueryOp(a, b, record);
      },

      $and: function (a, b, record) {
        for (var idx = 0, len = b.length; idx < len; idx += 1) {
          if (!doQueryOp(a, b[idx], record)) {
            return false;
          }
        }
        return true;
      },

      $or: function (a, b, record) {
        for (var idx = 0, len = b.length; idx < len; idx += 1) {
          if (doQueryOp(a, b[idx], record)) {
            return true;
          }
        }
        return false;
      },

      $exists: function (a, b) {
        if (b) {
          return a !== undefined;
        } else {
          return a === undefined;
        }
      }
    };

    // ops that can be used with { $$op: 'column-name' } syntax
    var valueLevelOps = ['$eq', '$aeq', '$ne', '$dteq', '$gt', '$gte', '$lt', '$lte', '$jgt', '$jgte', '$jlt', '$jlte', '$type'];
    valueLevelOps.forEach(function (op) {
      var fun = LokiOps[op];
      LokiOps['$' + op] = function (a, spec, record) {
        if (typeof spec === 'string') {
          return fun(a, record[spec]);
        } else if (typeof spec === 'function') {
          return fun(a, spec(record));
        } else {
          throw new Error('Invalid argument to $$ matcher');
        }
      };
    });

    // if an op is registered in this object, our 'calculateRange' can use it with our binary indices.
    // if the op is registered to a function, we will run that function/op as a 2nd pass filter on results.
    // those 2nd pass filter functions should be similar to LokiOps functions, accepting 2 vals to compare.
    var indexedOps = {
      $eq: LokiOps.$eq,
      $aeq: true,
      $dteq: true,
      $gt: true,
      $gte: true,
      $lt: true,
      $lte: true,
      $in: true,
      $between: true
    };

    function clone(data, method) {
      if (data === null || data === undefined) {
        return null;
      }

      var cloneMethod = method || 'parse-stringify',
        cloned;

      switch (cloneMethod) {
        case "parse-stringify":
          cloned = JSON.parse(JSON.stringify(data));
          break;
        case "jquery-extend-deep":
          cloned = jQuery.extend(true, {}, data);
          break;
        case "shallow":
          // more compatible method for older browsers
          cloned = Object.create(data.constructor.prototype);
          Object.keys(data).map(function (i) {
            cloned[i] = data[i];
          });
          break;
        case "shallow-assign":
          // should be supported by newer environments/browsers
          cloned = Object.create(data.constructor.prototype);
          Object.assign(cloned, data);
          break;
        case "shallow-recurse-objects":
          // shallow clone top level properties
          cloned = clone(data, "shallow");
          var keys = Object.keys(data);
          // for each of the top level properties which are object literals, recursively shallow copy
          keys.forEach(function (key) {
            if (typeof data[key] === "object" && data[key].constructor.name === "Object") {
              cloned[key] = clone(data[key], "shallow-recurse-objects");
            } else if (Array.isArray(data[key])) {
              cloned[key] = cloneObjectArray(data[key], "shallow-recurse-objects");
            }
          });
          break;
        default:
          break;
      }

      return cloned;
    }

    function cloneObjectArray(objarray, method) {
      if (method == "parse-stringify") {
        return clone(objarray, method);
      }
      var result = [];
      for (var i = 0, len = objarray.length; i < len; i++) {
        result[i] = clone(objarray[i], method);
      }
      return result;
    }

    function localStorageAvailable() {
      try {
        return (window && window.localStorage !== undefined && window.localStorage !== null);
      } catch (e) {
        return false;
      }
    }


    /**
     * LokiEventEmitter is a minimalist version of EventEmitter. It enables any
     * constructor that inherits EventEmitter to emit events and trigger
     * listeners that have been added to the event through the on(event, callback) method
     *
     * @constructor LokiEventEmitter
     */
    function LokiEventEmitter() { }

    /**
     * @prop {hashmap} events - a hashmap, with each property being an array of callbacks
     * @memberof LokiEventEmitter
     */
    LokiEventEmitter.prototype.events = {};

    /**
     * @prop {boolean} asyncListeners - boolean determines whether or not the callbacks associated with each event
     * should happen in an async fashion or not
     * Default is false, which means events are synchronous
     * @memberof LokiEventEmitter
     */
    LokiEventEmitter.prototype.asyncListeners = false;

    /**
     * on(eventName, listener) - adds a listener to the queue of callbacks associated to an event
     * @param {string|string[]} eventName - the name(s) of the event(s) to listen to
     * @param {function} listener - callback function of listener to attach
     * @returns {int} the index of the callback in the array of listeners for a particular event
     * @memberof LokiEventEmitter
     */
    LokiEventEmitter.prototype.on = function (eventName, listener) {
      var event;
      var self = this;

      if (Array.isArray(eventName)) {
        eventName.forEach(function (currentEventName) {
          self.on(currentEventName, listener);
        });
        return listener;
      }

      event = this.events[eventName];
      if (!event) {
        event = this.events[eventName] = [];
      }
      event.push(listener);
      return listener;
    };

    /**
     * emit(eventName, data) - emits a particular event
     * with the option of passing optional parameters which are going to be processed by the callback
     * provided signatures match (i.e. if passing emit(event, arg0, arg1) the listener should take two parameters)
     * @param {string} eventName - the name of the event
     * @param {object=} data - optional object passed with the event
     * @memberof LokiEventEmitter
     */
    LokiEventEmitter.prototype.emit = function (eventName) {
      var self = this;
      var selfArgs;
      if (eventName && this.events[eventName]) {
        if (this.events[eventName].length) {
          selfArgs = Array.prototype.slice.call(arguments, 1);
          this.events[eventName].forEach(function (listener) {
            if (self.asyncListeners) {
              setTimeout(function () {
                listener.apply(self, selfArgs);
              }, 1);
            } else {
              listener.apply(self, selfArgs);
            }
          });
        }
      } else {
        throw new Error('No event ' + eventName + ' defined');
      }
    };

    /**
     * Alias of LokiEventEmitter.prototype.on
     * addListener(eventName, listener) - adds a listener to the queue of callbacks associated to an event
     * @param {string|string[]} eventName - the name(s) of the event(s) to listen to
     * @param {function} listener - callback function of listener to attach
     * @returns {int} the index of the callback in the array of listeners for a particular event
     * @memberof LokiEventEmitter
     */
    LokiEventEmitter.prototype.addListener = LokiEventEmitter.prototype.on;

    /**
     * removeListener() - removes the listener at position 'index' from the event 'eventName'
     * @param {string|string[]} eventName - the name(s) of the event(s) which the listener is attached to
     * @param {function} listener - the listener callback function to remove from emitter
     * @memberof LokiEventEmitter
     */
    LokiEventEmitter.prototype.removeListener = function (eventName, listener) {
      var self = this;

      if (Array.isArray(eventName)) {
        eventName.forEach(function (currentEventName) {
          self.removeListener(currentEventName, listener);
        });

        return;
      }

      if (this.events[eventName]) {
        var listeners = this.events[eventName];
        listeners.splice(listeners.indexOf(listener), 1);
      }
    };

    /**
     * Loki: The main database class
     * @constructor Loki
     * @implements LokiEventEmitter
     * @param {string} filename - name of the file to be saved to
     * @param {object=} options - (Optional) config options object
     * @param {string} options.env - override environment detection as 'NODEJS', 'BROWSER', 'CORDOVA'
     * @param {boolean} [options.verbose=false] - enable console output
     * @param {boolean} [options.autosave=false] - enables autosave
     * @param {int} [options.autosaveInterval=5000] - time interval (in milliseconds) between saves (if dirty)
     * @param {boolean} [options.autoload=false] - enables autoload on loki instantiation
     * @param {function} options.autoloadCallback - user callback called after database load
     * @param {adapter} options.adapter - an instance of a loki persistence adapter
     * @param {string} [options.serializationMethod='normal'] - ['normal', 'pretty', 'destructured']
     * @param {string} options.destructureDelimiter - string delimiter used for destructured serialization
     * @param {boolean} [options.throttledSaves=true] - debounces multiple calls to to saveDatabase reducing number of disk I/O operations
                                                and guaranteeing proper serialization of the calls.
     */
    function Loki(filename, options) {
      this.filename = filename || 'loki.db';
      this.collections = [];

      // persist version of code which created the database to the database.
      // could use for upgrade scenarios
      this.databaseVersion = 1.5;
      this.engineVersion = 1.5;

      // autosave support (disabled by default)
      // pass autosave: true, autosaveInterval: 6000 in options to set 6 second autosave
      this.autosave = false;
      this.autosaveInterval = 5000;
      this.autosaveHandle = null;
      this.throttledSaves = true;

      this.options = {};

      // currently keeping persistenceMethod and persistenceAdapter as loki level properties that
      // will not or cannot be deserialized.  You are required to configure persistence every time
      // you instantiate a loki object (or use default environment detection) in order to load the database anyways.

      // persistenceMethod could be 'fs', 'localStorage', or 'adapter'
      // this is optional option param, otherwise environment detection will be used
      // if user passes their own adapter we will force this method to 'adapter' later, so no need to pass method option.
      this.persistenceMethod = null;

      // retain reference to optional (non-serializable) persistenceAdapter 'instance'
      this.persistenceAdapter = null;

      // flags used to throttle saves
      this.throttledSavePending = false;
      this.throttledCallbacks = [];

      // enable console output if verbose flag is set (disabled by default)
      this.verbose = options && options.hasOwnProperty('verbose') ? options.verbose : false;

      this.events = {
        'init': [],
        'loaded': [],
        'flushChanges': [],
        'close': [],
        'changes': [],
        'warning': []
      };

      var getENV = function () {
        if (typeof global !== 'undefined' && (global.android || global.NSObject)) {
          // If no adapter assume nativescript which needs adapter to be passed manually
          return 'NATIVESCRIPT'; //nativescript
        }

        if (typeof window === 'undefined') {
          return 'NODEJS';
        }

        if (typeof global !== 'undefined' && global.window && typeof process !== 'undefined') {
          return 'NODEJS'; //node-webkit
        }

        if (typeof document !== 'undefined') {
          if (document.URL.indexOf('http://') === -1 && document.URL.indexOf('https://') === -1) {
            return 'CORDOVA';
          }
          return 'BROWSER';
        }
        return 'CORDOVA';
      };

      // refactored environment detection due to invalid detection for browser environments.
      // if they do not specify an options.env we want to detect env rather than default to nodejs.
      // currently keeping two properties for similar thing (options.env and options.persistenceMethod)
      //   might want to review whether we can consolidate.
      if (options && options.hasOwnProperty('env')) {
        this.ENV = options.env;
      } else {
        this.ENV = getENV();
      }

      // not sure if this is necessary now that i have refactored the line above
      if (this.ENV === 'undefined') {
        this.ENV = 'NODEJS';
      }

      this.configureOptions(options, true);

      this.on('init', this.clearChanges);

    }

    // db class is an EventEmitter
    Loki.prototype = new LokiEventEmitter();
    Loki.prototype.constructor = Loki;

    // experimental support for browserify's abstract syntax scan to pick up dependency of indexed adapter.
    // Hopefully, once this hits npm a browserify require of lokijs should scan the main file and detect this indexed adapter reference.
    Loki.prototype.getIndexedAdapter = function () {
      var adapter;

      if (typeof require === 'function') {
        adapter = require("./loki-indexed-adapter.js");
      }

      return adapter;
    };


    /**
     * Allows reconfiguring database options
     *
     * @param {object} options - configuration options to apply to loki db object
     * @param {string} options.env - override environment detection as 'NODEJS', 'BROWSER', 'CORDOVA'
     * @param {boolean} options.verbose - enable console output (default is 'false')
     * @param {boolean} options.autosave - enables autosave
     * @param {int} options.autosaveInterval - time interval (in milliseconds) between saves (if dirty)
     * @param {boolean} options.autoload - enables autoload on loki instantiation
     * @param {function} options.autoloadCallback - user callback called after database load
     * @param {adapter} options.adapter - an instance of a loki persistence adapter
     * @param {string} options.serializationMethod - ['normal', 'pretty', 'destructured']
     * @param {string} options.destructureDelimiter - string delimiter used for destructured serialization
     * @param {boolean} initialConfig - (internal) true is passed when loki ctor is invoking
     * @memberof Loki
     */
    Loki.prototype.configureOptions = function (options, initialConfig) {
      var defaultPersistence = {
        'NODEJS': 'fs',
        'BROWSER': 'localStorage',
        'CORDOVA': 'localStorage',
        'MEMORY': 'memory'
      },
        persistenceMethods = {
          'fs': LokiFsAdapter,
          'localStorage': LokiLocalStorageAdapter,
          'memory': LokiMemoryAdapter
        };

      this.options = {};

      this.persistenceMethod = null;
      // retain reference to optional persistence adapter 'instance'
      // currently keeping outside options because it can't be serialized
      this.persistenceAdapter = null;

      // process the options
      if (typeof (options) !== 'undefined') {
        this.options = options;

        if (this.options.hasOwnProperty('persistenceMethod')) {
          // check if the specified persistence method is known
          if (typeof (persistenceMethods[options.persistenceMethod]) == 'function') {
            this.persistenceMethod = options.persistenceMethod;
            this.persistenceAdapter = new persistenceMethods[options.persistenceMethod]();
          }
          // should be throw an error here, or just fall back to defaults ??
        }

        // if user passes adapter, set persistence mode to adapter and retain persistence adapter instance
        if (this.options.hasOwnProperty('adapter')) {
          this.persistenceMethod = 'adapter';
          this.persistenceAdapter = options.adapter;
          this.options.adapter = null;

          // if true, will keep track of dirty ids
          this.isIncremental = this.persistenceAdapter.mode === 'incremental';
        }


        // if they want to load database on loki instantiation, now is a good time to load... after adapter set and before possible autosave initiation
        if (options.autoload && initialConfig) {
          // for autoload, let the constructor complete before firing callback
          var self = this;
          setTimeout(function () {
            self.loadDatabase(options, options.autoloadCallback);
          }, 1);
        }

        if (this.options.hasOwnProperty('autosaveInterval')) {
          this.autosaveDisable();
          this.autosaveInterval = parseInt(this.options.autosaveInterval, 10);
        }

        if (this.options.hasOwnProperty('autosave') && this.options.autosave) {
          this.autosaveDisable();
          this.autosave = true;

          if (this.options.hasOwnProperty('autosaveCallback')) {
            this.autosaveEnable(options, options.autosaveCallback);
          } else {
            this.autosaveEnable();
          }
        }

        if (this.options.hasOwnProperty('throttledSaves')) {
          this.throttledSaves = this.options.throttledSaves;
        }
      } // end of options processing

      // ensure defaults exists for options which were not set
      if (!this.options.hasOwnProperty('serializationMethod')) {
        this.options.serializationMethod = 'normal';
      }

      // ensure passed or default option exists
      if (!this.options.hasOwnProperty('destructureDelimiter')) {
        this.options.destructureDelimiter = '$<\n';
      }

      // if by now there is no adapter specified by user nor derived from persistenceMethod: use sensible defaults
      if (this.persistenceAdapter === null) {
        this.persistenceMethod = defaultPersistence[this.ENV];
        if (this.persistenceMethod) {
          this.persistenceAdapter = new persistenceMethods[this.persistenceMethod]();
        }
      }

    };

    /**
     * Copies 'this' database into a new Loki instance. Object references are shared to make lightweight.
     *
     * @param {object} options - apply or override collection level settings
     * @param {bool} options.removeNonSerializable - nulls properties not safe for serialization.
     * @memberof Loki
     */
    Loki.prototype.copy = function (options) {
      // in case running in an environment without accurate environment detection, pass 'NA'
      var databaseCopy = new Loki(this.filename, { env: "NA" });
      var clen, idx;

      options = options || {};

      // currently inverting and letting loadJSONObject do most of the work
      databaseCopy.loadJSONObject(this, { retainDirtyFlags: true });

      // since our JSON serializeReplacer is not invoked for reference database adapters, this will let us mimic
      if (options.hasOwnProperty("removeNonSerializable") && options.removeNonSerializable === true) {
        databaseCopy.autosaveHandle = null;
        databaseCopy.persistenceAdapter = null;

        clen = databaseCopy.collections.length;
        for (idx = 0; idx < clen; idx++) {
          databaseCopy.collections[idx].constraints = null;
          databaseCopy.collections[idx].ttl = null;
        }
      }

      return databaseCopy;
    };

    /**
     * Adds a collection to the database.
     * @param {string} name - name of collection to add
     * @param {object=} options - (optional) options to configure collection with.
     * @param {array=} [options.unique=[]] - array of property names to define unique constraints for
     * @param {array=} [options.exact=[]] - array of property names to define exact constraints for
     * @param {array=} [options.indices=[]] - array property names to define binary indexes for
     * @param {boolean} [options.asyncListeners=false] - whether listeners are called asynchronously
     * @param {boolean} [options.disableMeta=false] - set to true to disable meta property on documents
     * @param {boolean} [options.disableChangesApi=true] - set to false to enable Changes Api
     * @param {boolean} [options.disableDeltaChangesApi=true] - set to false to enable Delta Changes API (requires Changes API, forces cloning)
     * @param {boolean} [options.autoupdate=false] - use Object.observe to update objects automatically
     * @param {boolean} [options.clone=false] - specify whether inserts and queries clone to/from user
     * @param {string} [options.cloneMethod='parse-stringify'] - 'parse-stringify', 'jquery-extend-deep', 'shallow, 'shallow-assign'
     * @param {int=} options.ttl - age of document (in ms.) before document is considered aged/stale.
     * @param {int=} options.ttlInterval - time interval for clearing out 'aged' documents; not set by default.
     * @returns {Collection} a reference to the collection which was just added
     * @memberof Loki
     */
    Loki.prototype.addCollection = function (name, options) {
      var i,
        len = this.collections.length;

      if (options && options.disableMeta === true) {
        if (options.disableChangesApi === false) {
          throw new Error("disableMeta option cannot be passed as true when disableChangesApi is passed as false");
        }
        if (options.disableDeltaChangesApi === false) {
          throw new Error("disableMeta option cannot be passed as true when disableDeltaChangesApi is passed as false");
        }
        if (typeof options.ttl === "number" && options.ttl > 0) {
          throw new Error("disableMeta option cannot be passed as true when ttl is enabled");
        }
      }

      for (i = 0; i < len; i += 1) {
        if (this.collections[i].name === name) {
          return this.collections[i];
        }
      }

      var collection = new Collection(name, options);
      collection.isIncremental = this.isIncremental;
      this.collections.push(collection);

      if (this.verbose)
        collection.lokiConsoleWrapper = console;

      return collection;
    };

    Loki.prototype.loadCollection = function (collection) {
      if (!collection.name) {
        throw new Error('Collection must have a name property to be loaded');
      }
      this.collections.push(collection);
    };

    /**
     * Retrieves reference to a collection by name.
     * @param {string} collectionName - name of collection to look up
     * @returns {Collection} Reference to collection in database by that name, or null if not found
     * @memberof Loki
     */
    Loki.prototype.getCollection = function (collectionName) {
      var i,
        len = this.collections.length;

      for (i = 0; i < len; i += 1) {
        if (this.collections[i].name === collectionName) {
          return this.collections[i];
        }
      }

      // no such collection
      this.emit('warning', 'collection ' + collectionName + ' not found');
      return null;
    };

    /**
     * Renames an existing loki collection
     * @param {string} oldName - name of collection to rename
     * @param {string} newName - new name of collection
     * @returns {Collection} reference to the newly renamed collection
     * @memberof Loki
     */
    Loki.prototype.renameCollection = function (oldName, newName) {
      var c = this.getCollection(oldName);

      if (c) {
        c.name = newName;
      }

      return c;
    };

    /**
     * Returns a list of collections in the database.
     * @returns {object[]} array of objects containing 'name', 'type', and 'count' properties.
     * @memberof Loki
     */
    Loki.prototype.listCollections = function () {

      var i = this.collections.length,
        colls = [];

      while (i--) {
        colls.push({
          name: this.collections[i].name,
          type: this.collections[i].objType,
          count: this.collections[i].data.length
        });
      }
      return colls;
    };

    /**
     * Removes a collection from the database.
     * @param {string} collectionName - name of collection to remove
     * @memberof Loki
     */
    Loki.prototype.removeCollection = function (collectionName) {
      var i,
        len = this.collections.length;

      for (i = 0; i < len; i += 1) {
        if (this.collections[i].name === collectionName) {
          var tmpcol = new Collection(collectionName, {});
          var curcol = this.collections[i];
          for (var prop in curcol) {
            if (curcol.hasOwnProperty(prop) && tmpcol.hasOwnProperty(prop)) {
              curcol[prop] = tmpcol[prop];
            }
          }
          this.collections.splice(i, 1);
          return;
        }
      }
    };

    Loki.prototype.getName = function () {
      return this.name;
    };

    /**
     * serializeReplacer - used to prevent certain properties from being serialized
     *
     */
    Loki.prototype.serializeReplacer = function (key, value) {
      switch (key) {
        case 'autosaveHandle':
        case 'persistenceAdapter':
        case 'constraints':
        case 'ttl':
          return null;
        case 'throttledSavePending':
        case 'throttledCallbacks':
          return undefined;
        case 'lokiConsoleWrapper':
          return null;
        default:
          return value;
      }
    };

    /**
     * Serialize database to a string which can be loaded via {@link Loki#loadJSON}
     *
     * @returns {string} Stringified representation of the loki database.
     * @memberof Loki
     */
    Loki.prototype.serialize = function (options) {
      options = options || {};

      if (!options.hasOwnProperty("serializationMethod")) {
        options.serializationMethod = this.options.serializationMethod;
      }

      switch (options.serializationMethod) {
        case "normal": return JSON.stringify(this, this.serializeReplacer);
        case "pretty": return JSON.stringify(this, this.serializeReplacer, 2);
        case "destructured": return this.serializeDestructured(); // use default options
        default: return JSON.stringify(this, this.serializeReplacer);
      }
    };

    // alias of serialize
    Loki.prototype.toJson = Loki.prototype.serialize;

    /**
     * Database level destructured JSON serialization routine to allow alternate serialization methods.
     * Internally, Loki supports destructuring via loki "serializationMethod' option and
     * the optional LokiPartitioningAdapter class. It is also available if you wish to do
     * your own structured persistence or data exchange.
     *
     * @param {object=} options - output format options for use externally to loki
     * @param {bool=} options.partitioned - (default: false) whether db and each collection are separate
     * @param {int=} options.partition - can be used to only output an individual collection or db (-1)
     * @param {bool=} options.delimited - (default: true) whether subitems are delimited or subarrays
     * @param {string=} options.delimiter - override default delimiter
     *
     * @returns {string|array} A custom, restructured aggregation of independent serializations.
     * @memberof Loki
     */
    Loki.prototype.serializeDestructured = function (options) {
      var idx, sidx, result, resultlen;
      var reconstruct = [];
      var dbcopy;

      options = options || {};

      if (!options.hasOwnProperty("partitioned")) {
        options.partitioned = false;
      }

      if (!options.hasOwnProperty("delimited")) {
        options.delimited = true;
      }

      if (!options.hasOwnProperty("delimiter")) {
        options.delimiter = this.options.destructureDelimiter;
      }

      // 'partitioned' along with 'partition' of 0 or greater is a request for single collection serialization
      if (options.partitioned === true && options.hasOwnProperty("partition") && options.partition >= 0) {
        return this.serializeCollection({
          delimited: options.delimited,
          delimiter: options.delimiter,
          collectionIndex: options.partition
        });
      }

      // not just an individual collection, so we will need to serialize db container via shallow copy
      dbcopy = new Loki(this.filename);
      dbcopy.loadJSONObject(this);

      for (idx = 0; idx < dbcopy.collections.length; idx++) {
        dbcopy.collections[idx].data = [];
      }

      // if we -only- wanted the db container portion, return it now
      if (options.partitioned === true && options.partition === -1) {
        // since we are deconstructing, override serializationMethod to normal for here
        return dbcopy.serialize({
          serializationMethod: "normal"
        });
      }

      // at this point we must be deconstructing the entire database
      // start by pushing db serialization into first array element
      reconstruct.push(dbcopy.serialize({
        serializationMethod: "normal"
      }));

      dbcopy = null;

      // push collection data into subsequent elements
      for (idx = 0; idx < this.collections.length; idx++) {
        result = this.serializeCollection({
          delimited: options.delimited,
          delimiter: options.delimiter,
          collectionIndex: idx
        });

        // NDA : Non-Delimited Array : one iterable concatenated array with empty string collection partitions
        if (options.partitioned === false && options.delimited === false) {
          if (!Array.isArray(result)) {
            throw new Error("a nondelimited, non partitioned collection serialization did not return an expected array");
          }

          // Array.concat would probably duplicate memory overhead for copying strings.
          // Instead copy each individually, and clear old value after each copy.
          // Hopefully this will allow g.c. to reduce memory pressure, if needed.
          resultlen = result.length;

          for (sidx = 0; sidx < resultlen; sidx++) {
            reconstruct.push(result[sidx]);
            result[sidx] = null;
          }

          reconstruct.push("");
        }
        else {
          reconstruct.push(result);
        }
      }

      // Reconstruct / present results according to four combinations : D, DA, NDA, NDAA
      if (options.partitioned) {
        // DA : Delimited Array of strings [0] db [1] collection [n] collection { partitioned: true, delimited: true }
        // useful for simple future adaptations of existing persistence adapters to save collections separately
        if (options.delimited) {
          return reconstruct;
        }
        // NDAA : Non-Delimited Array with subArrays. db at [0] and collection subarrays at [n] { partitioned: true, delimited : false }
        // This format might be the most versatile for 'rolling your own' partitioned sync or save.
        // Memory overhead can be reduced by specifying a specific partition, but at this code path they did not, so its all.
        else {
          return reconstruct;
        }
      }
      else {
        // D : one big Delimited string { partitioned: false, delimited : true }
        // This is the method Loki will use internally if 'destructured'.
        // Little memory overhead improvements but does not require multiple asynchronous adapter call scheduling
        if (options.delimited) {
          // indicate no more collections
          reconstruct.push("");

          return reconstruct.join(options.delimiter);
        }
        // NDA : Non-Delimited Array : one iterable array with empty string collection partitions { partitioned: false, delimited: false }
        // This format might be best candidate for custom synchronous syncs or saves
        else {
          // indicate no more collections
          reconstruct.push("");

          return reconstruct;
        }
      }

      reconstruct.push("");

      return reconstruct.join(delim);
    };

    /**
     * Collection level utility method to serialize a collection in a 'destructured' format
     *
     * @param {object=} options - used to determine output of method
     * @param {int} options.delimited - whether to return single delimited string or an array
     * @param {string} options.delimiter - (optional) if delimited, this is delimiter to use
     * @param {int} options.collectionIndex -  specify which collection to serialize data for
     *
     * @returns {string|array} A custom, restructured aggregation of independent serializations for a single collection.
     * @memberof Loki
     */
    Loki.prototype.serializeCollection = function (options) {
      var doccount,
        docidx,
        resultlines = [];

      options = options || {};

      if (!options.hasOwnProperty("delimited")) {
        options.delimited = true;
      }

      if (!options.hasOwnProperty("collectionIndex")) {
        throw new Error("serializeCollection called without 'collectionIndex' option");
      }

      doccount = this.collections[options.collectionIndex].data.length;

      resultlines = [];

      for (docidx = 0; docidx < doccount; docidx++) {
        resultlines.push(JSON.stringify(this.collections[options.collectionIndex].data[docidx]));
      }

      // D and DA
      if (options.delimited) {
        // indicate no more documents in collection (via empty delimited string)
        resultlines.push("");

        return resultlines.join(options.delimiter);
      }
      else {
        // NDAA and NDA
        return resultlines;
      }
    };

    /**
     * Database level destructured JSON deserialization routine to minimize memory overhead.
     * Internally, Loki supports destructuring via loki "serializationMethod' option and
     * the optional LokiPartitioningAdapter class. It is also available if you wish to do
     * your own structured persistence or data exchange.
     *
     * @param {string|array} destructuredSource - destructured json or array to deserialize from
     * @param {object=} options - source format options
     * @param {bool=} [options.partitioned=false] - whether db and each collection are separate
     * @param {int=} options.partition - can be used to deserialize only a single partition
     * @param {bool=} [options.delimited=true] - whether subitems are delimited or subarrays
     * @param {string=} options.delimiter - override default delimiter
     *
     * @returns {object|array} An object representation of the deserialized database, not yet applied to 'this' db or document array
     * @memberof Loki
     */
    Loki.prototype.deserializeDestructured = function (destructuredSource, options) {
      var workarray = [];
      var len, cdb;
      var idx, collIndex = 0, collCount, lineIndex = 1, done = false;
      var currLine, currObject;

      options = options || {};

      if (!options.hasOwnProperty("partitioned")) {
        options.partitioned = false;
      }

      if (!options.hasOwnProperty("delimited")) {
        options.delimited = true;
      }

      if (!options.hasOwnProperty("delimiter")) {
        options.delimiter = this.options.destructureDelimiter;
      }

      // Partitioned
      // DA : Delimited Array of strings [0] db [1] collection [n] collection { partitioned: true, delimited: true }
      // NDAA : Non-Delimited Array with subArrays. db at [0] and collection subarrays at [n] { partitioned: true, delimited : false }
      // -or- single partition
      if (options.partitioned) {
        // handle single partition
        if (options.hasOwnProperty('partition')) {
          // db only
          if (options.partition === -1) {
            cdb = JSON.parse(destructuredSource[0]);

            return cdb;
          }

          // single collection, return doc array
          return this.deserializeCollection(destructuredSource[options.partition + 1], options);
        }

        // Otherwise we are restoring an entire partitioned db
        cdb = JSON.parse(destructuredSource[0]);
        collCount = cdb.collections.length;
        for (collIndex = 0; collIndex < collCount; collIndex++) {
          // attach each collection docarray to container collection data, add 1 to collection array index since db is at 0
          cdb.collections[collIndex].data = this.deserializeCollection(destructuredSource[collIndex + 1], options);
        }

        return cdb;
      }

      // Non-Partitioned
      // D : one big Delimited string { partitioned: false, delimited : true }
      // NDA : Non-Delimited Array : one iterable array with empty string collection partitions { partitioned: false, delimited: false }

      // D
      if (options.delimited) {
        workarray = destructuredSource.split(options.delimiter);
        destructuredSource = null; // lower memory pressure
        len = workarray.length;

        if (len === 0) {
          return null;
        }
      }
      // NDA
      else {
        workarray = destructuredSource;
      }

      // first line is database and collection shells
      cdb = JSON.parse(workarray[0]);
      collCount = cdb.collections.length;
      workarray[0] = null;

      while (!done) {
        currLine = workarray[lineIndex];

        // empty string indicates either end of collection or end of file
        if (workarray[lineIndex] === "") {
          // if no more collections to load into, we are done
          if (++collIndex > collCount) {
            done = true;
          }
        }
        else {
          currObject = JSON.parse(workarray[lineIndex]);
          cdb.collections[collIndex].data.push(currObject);
        }

        // lower memory pressure and advance iterator
        workarray[lineIndex++] = null;
      }

      return cdb;
    };

    /**
     * Collection level utility function to deserializes a destructured collection.
     *
     * @param {string|array} destructuredSource - destructured representation of collection to inflate
     * @param {object=} options - used to describe format of destructuredSource input
     * @param {int=} [options.delimited=false] - whether source is delimited string or an array
     * @param {string=} options.delimiter - if delimited, this is delimiter to use (if other than default)
     *
     * @returns {array} an array of documents to attach to collection.data.
     * @memberof Loki
     */
    Loki.prototype.deserializeCollection = function (destructuredSource, options) {
      var workarray = [];
      var idx, len;

      options = options || {};

      if (!options.hasOwnProperty("partitioned")) {
        options.partitioned = false;
      }

      if (!options.hasOwnProperty("delimited")) {
        options.delimited = true;
      }

      if (!options.hasOwnProperty("delimiter")) {
        options.delimiter = this.options.destructureDelimiter;
      }

      if (options.delimited) {
        workarray = destructuredSource.split(options.delimiter);
        workarray.pop();
      }
      else {
        workarray = destructuredSource;
      }

      len = workarray.length;
      for (idx = 0; idx < len; idx++) {
        workarray[idx] = JSON.parse(workarray[idx]);
      }

      return workarray;
    };

    /**
     * Inflates a loki database from a serialized JSON string
     *
     * @param {string} serializedDb - a serialized loki database string
     * @param {object=} options - apply or override collection level settings
     * @param {bool} options.retainDirtyFlags - whether collection dirty flags will be preserved
     * @memberof Loki
     */
    Loki.prototype.loadJSON = function (serializedDb, options) {
      var dbObject;
      if (serializedDb.length === 0) {
        dbObject = {};
      } else {

        // using option defined in instantiated db not what was in serialized db
        switch (this.options.serializationMethod) {
          case "normal":
          case "pretty": dbObject = JSON.parse(serializedDb); break;
          case "destructured": dbObject = this.deserializeDestructured(serializedDb); break;
          default: dbObject = JSON.parse(serializedDb); break;
        }
      }

      this.loadJSONObject(dbObject, options);
    };

    /**
     * Inflates a loki database from a JS object
     *
     * @param {object} dbObject - a serialized loki database string
     * @param {object=} options - apply or override collection level settings
     * @param {bool} options.retainDirtyFlags - whether collection dirty flags will be preserved
     * @memberof Loki
     */
    Loki.prototype.loadJSONObject = function (dbObject, options) {
      var i = 0,
        len = dbObject.collections ? dbObject.collections.length : 0,
        coll,
        copyColl,
        clen,
        j,
        loader,
        collObj;

      this.name = dbObject.name;

      // restore save throttled boolean only if not defined in options
      if (dbObject.hasOwnProperty('throttledSaves') && options && !options.hasOwnProperty('throttledSaves')) {
        this.throttledSaves = dbObject.throttledSaves;
      }

      this.collections = [];

      function makeLoader(coll) {
        var collOptions = options[coll.name];
        var inflater;

        if (collOptions.proto) {
          inflater = collOptions.inflate || Utils.copyProperties;

          return function (data) {
            var collObj = new (collOptions.proto)();
            inflater(data, collObj);
            return collObj;
          };
        }

        return collOptions.inflate;
      }

      for (i; i < len; i += 1) {
        coll = dbObject.collections[i];

        copyColl = this.addCollection(coll.name, {
          disableChangesApi: coll.disableChangesApi,
          disableDeltaChangesApi: coll.disableDeltaChangesApi,
          disableMeta: coll.disableMeta,
          disableFreeze: coll.hasOwnProperty('disableFreeze') ? coll.disableFreeze : true
        });

        copyColl.adaptiveBinaryIndices = coll.hasOwnProperty('adaptiveBinaryIndices') ? (coll.adaptiveBinaryIndices === true) : false;
        copyColl.transactional = coll.transactional;
        copyColl.asyncListeners = coll.asyncListeners;
        copyColl.cloneObjects = coll.cloneObjects;
        copyColl.cloneMethod = coll.cloneMethod || "parse-stringify";
        copyColl.autoupdate = coll.autoupdate;
        copyColl.changes = coll.changes;
        copyColl.dirtyIds = coll.dirtyIds || [];

        if (options && options.retainDirtyFlags === true) {
          copyColl.dirty = coll.dirty;
        }
        else {
          copyColl.dirty = false;
        }

        // load each element individually
        clen = coll.data.length;
        j = 0;
        if (options && options.hasOwnProperty(coll.name)) {
          loader = makeLoader(coll);

          for (j; j < clen; j++) {
            collObj = loader(coll.data[j]);
            copyColl.data[j] = collObj;
            copyColl.addAutoUpdateObserver(collObj);
            if (!copyColl.disableFreeze) {
              deepFreeze(copyColl.data[j]);
            }
          }
        } else {

          for (j; j < clen; j++) {
            copyColl.data[j] = coll.data[j];
            copyColl.addAutoUpdateObserver(copyColl.data[j]);
            if (!copyColl.disableFreeze) {
              deepFreeze(copyColl.data[j]);
            }
          }
        }

        copyColl.maxId = (typeof coll.maxId === 'undefined') ? 0 : coll.maxId;
        if (typeof (coll.binaryIndices) !== 'undefined') {
          copyColl.binaryIndices = coll.binaryIndices;
        }
        if (typeof coll.transforms !== 'undefined') {
          copyColl.transforms = coll.transforms;
        }

        // regenerate unique indexes
        copyColl.uniqueNames = [];
        if (coll.hasOwnProperty("uniqueNames")) {
          copyColl.uniqueNames = coll.uniqueNames;
        }

        // in case they are loading a database created before we added dynamic views, handle undefined
        if (typeof (coll.DynamicViews) === 'undefined') continue;

        // reinflate DynamicViews and attached Resultsets
        for (var idx = 0; idx < coll.DynamicViews.length; idx++) {
          var colldv = coll.DynamicViews[idx];

          var dv = copyColl.addDynamicView(colldv.name, colldv.options);
          dv.resultdata = colldv.resultdata;
          dv.resultsdirty = colldv.resultsdirty;
          dv.filterPipeline = colldv.filterPipeline;
          dv.sortCriteriaSimple = colldv.sortCriteriaSimple;
          dv.sortCriteria = colldv.sortCriteria;
          dv.sortFunction = null;
          dv.sortDirty = colldv.sortDirty;
          if (!copyColl.disableFreeze) {
            deepFreeze(dv.filterPipeline);
            if (dv.sortCriteriaSimple) {
              deepFreeze(dv.sortCriteriaSimple);
            } else if (dv.sortCriteria) {
              deepFreeze(dv.sortCriteria);
            }
          }
          dv.resultset.filteredrows = colldv.resultset.filteredrows;
          dv.resultset.filterInitialized = colldv.resultset.filterInitialized;

          dv.rematerialize({
            removeWhereFilters: true
          });
        }

        // Upgrade Logic for binary index refactoring at version 1.5
        if (dbObject.databaseVersion < 1.5) {
          // rebuild all indices
          copyColl.ensureAllIndexes(true);
          copyColl.dirty = true;
        }
      }
    };

    /**
     * Emits the close event. In autosave scenarios, if the database is dirty, this will save and disable timer.
     * Does not actually destroy the db.
     *
     * @param {function=} callback - (Optional) if supplied will be registered with close event before emitting.
     * @memberof Loki
     */
    Loki.prototype.close = function (callback) {
      // for autosave scenarios, we will let close perform final save (if dirty)
      // For web use, you might call from window.onbeforeunload to shutdown database, saving pending changes
      if (this.autosave) {
        this.autosaveDisable();
        if (this.autosaveDirty()) {
          this.saveDatabase(callback);
          callback = undefined;
        }
      }

      if (callback) {
        this.on('close', callback);
      }
      this.emit('close');
    };

    /**-------------------------+
    | Changes API               |
    +--------------------------*/

    /**
     * The Changes API enables the tracking the changes occurred in the collections since the beginning of the session,
     * so it's possible to create a differential dataset for synchronization purposes (possibly to a remote db)
     */

    /**
     * (Changes API) : takes all the changes stored in each
     * collection and creates a single array for the entire database. If an array of names
     * of collections is passed then only the included collections will be tracked.
     *
     * @param {array=} optional array of collection names. No arg means all collections are processed.
     * @returns {array} array of changes
     * @see private method createChange() in Collection
     * @memberof Loki
     */
    Loki.prototype.generateChangesNotification = function (arrayOfCollectionNames) {
      function getCollName(coll) {
        return coll.name;
      }
      var changes = [],
        selectedCollections = arrayOfCollectionNames || this.collections.map(getCollName);

      this.collections.forEach(function (coll) {
        if (selectedCollections.indexOf(getCollName(coll)) !== -1) {
          changes = changes.concat(coll.getChanges());
        }
      });
      return changes;
    };

    /**
     * (Changes API) - stringify changes for network transmission
     * @returns {string} string representation of the changes
     * @memberof Loki
     */
    Loki.prototype.serializeChanges = function (collectionNamesArray) {
      return JSON.stringify(this.generateChangesNotification(collectionNamesArray));
    };

    /**
     * (Changes API) : clears all the changes in all collections.
     * @memberof Loki
     */
    Loki.prototype.clearChanges = function () {
      this.collections.forEach(function (coll) {
        if (coll.flushChanges) {
          coll.flushChanges();
        }
      });
    };

    /*------------------+
    | PERSISTENCE       |
    -------------------*/

    /** there are two build in persistence adapters for internal use
     * fs             for use in Nodejs type environments
     * localStorage   for use in browser environment
     * defined as helper classes here so its easy and clean to use
     */

    /**
     * In in-memory persistence adapter for an in-memory database.
     * This simple 'key/value' adapter is intended for unit testing and diagnostics.
     *
     * @param {object=} options - memory adapter options
     * @param {boolean} [options.asyncResponses=false] - whether callbacks are invoked asynchronously
     * @param {int} [options.asyncTimeout=50] - timeout in ms to queue callbacks
     * @constructor LokiMemoryAdapter
     */
    function LokiMemoryAdapter(options) {
      this.hashStore = {};
      this.options = options || {};

      if (!this.options.hasOwnProperty('asyncResponses')) {
        this.options.asyncResponses = false;
      }

      if (!this.options.hasOwnProperty('asyncTimeout')) {
        this.options.asyncTimeout = 50; // 50 ms default
      }
    }

    /**
     * Loads a serialized database from its in-memory store.
     * (Loki persistence adapter interface function)
     *
     * @param {string} dbname - name of the database (filename/keyname)
     * @param {function} callback - adapter callback to return load result to caller
     * @memberof LokiMemoryAdapter
     */
    LokiMemoryAdapter.prototype.loadDatabase = function (dbname, callback) {
      var self = this;

      if (this.options.asyncResponses) {
        setTimeout(function () {
          if (self.hashStore.hasOwnProperty(dbname)) {
            callback(self.hashStore[dbname].value);
          }
          else {
            // database doesn't exist, return falsy
            callback(null);
          }
        }, this.options.asyncTimeout);
      }
      else {
        if (this.hashStore.hasOwnProperty(dbname)) {
          // database doesn't exist, return falsy
          callback(this.hashStore[dbname].value);
        }
        else {
          callback(null);
        }
      }
    };

    /**
     * Saves a serialized database to its in-memory store.
     * (Loki persistence adapter interface function)
     *
     * @param {string} dbname - name of the database (filename/keyname)
     * @param {function} callback - adapter callback to return load result to caller
     * @memberof LokiMemoryAdapter
     */
    LokiMemoryAdapter.prototype.saveDatabase = function (dbname, dbstring, callback) {
      var self = this;
      var saveCount;

      if (this.options.asyncResponses) {
        setTimeout(function () {
          saveCount = (self.hashStore.hasOwnProperty(dbname) ? self.hashStore[dbname].savecount : 0);

          self.hashStore[dbname] = {
            savecount: saveCount + 1,
            lastsave: new Date(),
            value: dbstring
          };

          callback();
        }, this.options.asyncTimeout);
      }
      else {
        saveCount = (this.hashStore.hasOwnProperty(dbname) ? this.hashStore[dbname].savecount : 0);

        this.hashStore[dbname] = {
          savecount: saveCount + 1,
          lastsave: new Date(),
          value: dbstring
        };

        callback();
      }
    };

    /**
     * Deletes a database from its in-memory store.
     *
     * @param {string} dbname - name of the database (filename/keyname)
     * @param {function} callback - function to call when done
     * @memberof LokiMemoryAdapter
     */
    LokiMemoryAdapter.prototype.deleteDatabase = function (dbname, callback) {
      if (this.hashStore.hasOwnProperty(dbname)) {
        delete this.hashStore[dbname];
      }

      if (typeof callback === "function") {
        callback();
      }
    };

    /**
     * An adapter for adapters.  Converts a non reference mode adapter into a reference mode adapter
     * which can perform destructuring and partioning.  Each collection will be stored in its own key/save and
     * only dirty collections will be saved.  If you  turn on paging with default page size of 25megs and save
     * a 75 meg collection it should use up roughly 3 save slots (key/value pairs sent to inner adapter).
     * A dirty collection that spans three pages will save all three pages again
     * Paging mode was added mainly because Chrome has issues saving 'too large' of a string within a
     * single indexeddb row.  If a single document update causes the collection to be flagged as dirty, all
     * of that collection's pages will be written on next save.
     *
     * @param {object} adapter - reference to a 'non-reference' mode loki adapter instance.
     * @param {object=} options - configuration options for partitioning and paging
     * @param {bool} options.paging - (default: false) set to true to enable paging collection data.
     * @param {int} options.pageSize - (default : 25MB) you can use this to limit size of strings passed to inner adapter.
     * @param {string} options.delimiter - allows you to override the default delimeter
     * @constructor LokiPartitioningAdapter
     */
    function LokiPartitioningAdapter(adapter, options) {
      this.mode = "reference";
      this.adapter = null;
      this.options = options || {};
      this.dbref = null;
      this.dbname = "";
      this.pageIterator = {};

      // verify user passed an appropriate adapter
      if (adapter) {
        if (adapter.mode === "reference") {
          throw new Error("LokiPartitioningAdapter cannot be instantiated with a reference mode adapter");
        }
        else {
          this.adapter = adapter;
        }
      }
      else {
        throw new Error("LokiPartitioningAdapter requires a (non-reference mode) adapter on construction");
      }

      // set collection paging defaults
      if (!this.options.hasOwnProperty("paging")) {
        this.options.paging = false;
      }

      // default to page size of 25 megs (can be up to your largest serialized object size larger than this)
      if (!this.options.hasOwnProperty("pageSize")) {
        this.options.pageSize = 25 * 1024 * 1024;
      }

      if (!this.options.hasOwnProperty("delimiter")) {
        this.options.delimiter = '$<\n';
      }
    }

    /**
     * Loads a database which was partitioned into several key/value saves.
     * (Loki persistence adapter interface function)
     *
     * @param {string} dbname - name of the database (filename/keyname)
     * @param {function} callback - adapter callback to return load result to caller
     * @memberof LokiPartitioningAdapter
     */
    LokiPartitioningAdapter.prototype.loadDatabase = function (dbname, callback) {
      var self = this;
      this.dbname = dbname;
      this.dbref = new Loki(dbname);

      // load the db container (without data)
      this.adapter.loadDatabase(dbname, function (result) {
        // empty database condition is for inner adapter return null/undefined/falsy
        if (!result) {
          // partition 0 not found so new database, no need to try to load other partitions.
          // return same falsy result to loadDatabase to signify no database exists (yet)
          callback(result);
          return;
        }

        if (typeof result !== "string") {
          callback(new Error("LokiPartitioningAdapter received an unexpected response from inner adapter loadDatabase()"));
        }

        // I will want to use loki destructuring helper methods so i will inflate into typed instance
        var db = JSON.parse(result);
        self.dbref.loadJSONObject(db);
        db = null;

        var clen = self.dbref.collections.length;

        if (self.dbref.collections.length === 0) {
          callback(self.dbref);
          return;
        }

        self.pageIterator = {
          collection: 0,
          pageIndex: 0
        };

        self.loadNextPartition(0, function () {
          callback(self.dbref);
        });
      });
    };

    /**
     * Used to sequentially load each collection partition, one at a time.
     *
     * @param {int} partition - ordinal collection position to load next
     * @param {function} callback - adapter callback to return load result to caller
     */
    LokiPartitioningAdapter.prototype.loadNextPartition = function (partition, callback) {
      var keyname = this.dbname + "." + partition;
      var self = this;

      if (this.options.paging === true) {
        this.pageIterator.pageIndex = 0;
        this.loadNextPage(callback);
        return;
      }

      this.adapter.loadDatabase(keyname, function (result) {
        var data = self.dbref.deserializeCollection(result, { delimited: true, collectionIndex: partition });
        self.dbref.collections[partition].data = data;

        if (++partition < self.dbref.collections.length) {
          self.loadNextPartition(partition, callback);
        }
        else {
          callback();
        }
      });
    };

    /**
     * Used to sequentially load the next page of collection partition, one at a time.
     *
     * @param {function} callback - adapter callback to return load result to caller
     */
    LokiPartitioningAdapter.prototype.loadNextPage = function (callback) {
      // calculate name for next saved page in sequence
      var keyname = this.dbname + "." + this.pageIterator.collection + "." + this.pageIterator.pageIndex;
      var self = this;

      // load whatever page is next in sequence
      this.adapter.loadDatabase(keyname, function (result) {
        var data = result.split(self.options.delimiter);
        result = ""; // free up memory now that we have split it into array
        var dlen = data.length;
        var idx;

        // detect if last page by presence of final empty string element and remove it if so
        var isLastPage = (data[dlen - 1] === "");
        if (isLastPage) {
          data.pop();
          dlen = data.length;
          // empty collections are just a delimiter meaning two blank items
          if (data[dlen - 1] === "" && dlen === 1) {
            data.pop();
            dlen = data.length;
          }
        }

        // convert stringified array elements to object instances and push to collection data
        for (idx = 0; idx < dlen; idx++) {
          self.dbref.collections[self.pageIterator.collection].data.push(JSON.parse(data[idx]));
          data[idx] = null;
        }
        data = [];

        // if last page, we are done with this partition
        if (isLastPage) {

          // if there are more partitions, kick off next partition load
          if (++self.pageIterator.collection < self.dbref.collections.length) {
            self.loadNextPartition(self.pageIterator.collection, callback);
          }
          else {
            callback();
          }
        }
        else {
          self.pageIterator.pageIndex++;
          self.loadNextPage(callback);
        }
      });
    };

    /**
     * Saves a database by partioning into separate key/value saves.
     * (Loki 'reference mode' persistence adapter interface function)
     *
     * @param {string} dbname - name of the database (filename/keyname)
     * @param {object} dbref - reference to database which we will partition and save.
     * @param {function} callback - adapter callback to return load result to caller
     *
     * @memberof LokiPartitioningAdapter
     */
    LokiPartitioningAdapter.prototype.exportDatabase = function (dbname, dbref, callback) {
      var self = this;
      var idx, clen = dbref.collections.length;

      this.dbref = dbref;
      this.dbname = dbname;

      // queue up dirty partitions to be saved
      this.dirtyPartitions = [-1];
      for (idx = 0; idx < clen; idx++) {
        if (dbref.collections[idx].dirty) {
          this.dirtyPartitions.push(idx);
        }
      }

      this.saveNextPartition(function (err) {
        callback(err);
      });
    };

    /**
     * Helper method used internally to save each dirty collection, one at a time.
     *
     * @param {function} callback - adapter callback to return load result to caller
     */
    LokiPartitioningAdapter.prototype.saveNextPartition = function (callback) {
      var self = this;
      var partition = this.dirtyPartitions.shift();
      var keyname = this.dbname + ((partition === -1) ? "" : ("." + partition));

      // if we are doing paging and this is collection partition
      if (this.options.paging && partition !== -1) {
        this.pageIterator = {
          collection: partition,
          docIndex: 0,
          pageIndex: 0
        };

        // since saveNextPage recursively calls itself until done, our callback means this whole paged partition is finished
        this.saveNextPage(function (err) {
          if (self.dirtyPartitions.length === 0) {
            callback(err);
          }
          else {
            self.saveNextPartition(callback);
          }
        });
        return;
      }

      // otherwise this is 'non-paged' partioning...
      var result = this.dbref.serializeDestructured({
        partitioned: true,
        delimited: true,
        partition: partition
      });

      this.adapter.saveDatabase(keyname, result, function (err) {
        if (err) {
          callback(err);
          return;
        }

        if (self.dirtyPartitions.length === 0) {
          callback(null);
        }
        else {
          self.saveNextPartition(callback);
        }
      });
    };

    /**
     * Helper method used internally to generate and save the next page of the current (dirty) partition.
     *
     * @param {function} callback - adapter callback to return load result to caller
     */
    LokiPartitioningAdapter.prototype.saveNextPage = function (callback) {
      var self = this;
      var coll = this.dbref.collections[this.pageIterator.collection];
      var keyname = this.dbname + "." + this.pageIterator.collection + "." + this.pageIterator.pageIndex;
      var pageLen = 0,
        cdlen = coll.data.length,
        delimlen = this.options.delimiter.length;
      var serializedObject = "",
        pageBuilder = "";
      var doneWithPartition = false,
        doneWithPage = false;

      var pageSaveCallback = function (err) {
        pageBuilder = "";

        if (err) {
          callback(err);
        }

        // update meta properties then continue process by invoking callback
        if (doneWithPartition) {
          callback(null);
        }
        else {
          self.pageIterator.pageIndex++;
          self.saveNextPage(callback);
        }
      };

      if (coll.data.length === 0) {
        doneWithPartition = true;
      }

      while (true) {
        if (!doneWithPartition) {
          // serialize object
          serializedObject = JSON.stringify(coll.data[this.pageIterator.docIndex]);
          pageBuilder += serializedObject;
          pageLen += serializedObject.length;

          // if no more documents in collection to add, we are done with partition
          if (++this.pageIterator.docIndex >= cdlen) doneWithPartition = true;
        }
        // if our current page is bigger than defined pageSize, we are done with page
        if (pageLen >= this.options.pageSize) doneWithPage = true;

        // if not done with current page, need delimiter before next item
        // if done with partition we also want a delmiter to indicate 'end of pages' final empty row
        if (!doneWithPage || doneWithPartition) {
          pageBuilder += this.options.delimiter;
          pageLen += delimlen;
        }

        // if we are done with page save it and pass off to next recursive call or callback
        if (doneWithPartition || doneWithPage) {
          this.adapter.saveDatabase(keyname, pageBuilder, pageSaveCallback);
          return;
        }
      }
    };

    /**
     * A loki persistence adapter which persists using node fs module
     * @constructor LokiFsAdapter
     */
    function LokiFsAdapter() {
      try {
        this.fs = require('fs');
      } catch (e) {
        this.fs = null;
      }
    }

    /**
     * loadDatabase() - Load data from file, will throw an error if the file does not exist
     * @param {string} dbname - the filename of the database to load
     * @param {function} callback - the callback to handle the result
     * @memberof LokiFsAdapter
     */
    LokiFsAdapter.prototype.loadDatabase = function loadDatabase(dbname, callback) {
      var self = this;

      this.fs.stat(dbname, function (err, stats) {
        if (!err && stats.isFile()) {
          self.fs.readFile(dbname, {
            encoding: 'utf8'
          }, function readFileCallback(err, data) {
            if (err) {
              callback(new Error(err));
            } else {
              callback(data);
            }
          });
        }
        else {
          callback(null);
        }
      });
    };

    /**
     * saveDatabase() - save data to file, will throw an error if the file can't be saved
     * might want to expand this to avoid dataloss on partial save
     * @param {string} dbname - the filename of the database to load
     * @param {function} callback - the callback to handle the result
     * @memberof LokiFsAdapter
     */
    LokiFsAdapter.prototype.saveDatabase = function saveDatabase(dbname, dbstring, callback) {
      var self = this;
      var tmpdbname = dbname + '~';
      this.fs.writeFile(tmpdbname, dbstring, function writeFileCallback(err) {
        if (err) {
          callback(new Error(err));
        } else {
          self.fs.rename(tmpdbname, dbname, callback);
        }
      });
    };

    /**
     * deleteDatabase() - delete the database file, will throw an error if the
     * file can't be deleted
     * @param {string} dbname - the filename of the database to delete
     * @param {function} callback - the callback to handle the result
     * @memberof LokiFsAdapter
     */
    LokiFsAdapter.prototype.deleteDatabase = function deleteDatabase(dbname, callback) {
      this.fs.unlink(dbname, function deleteDatabaseCallback(err) {
        if (err) {
          callback(new Error(err));
        } else {
          callback();
        }
      });
    };


    /**
     * A loki persistence adapter which persists to web browser's local storage object
     * @constructor LokiLocalStorageAdapter
     */
    function LokiLocalStorageAdapter() { }

    /**
     * loadDatabase() - Load data from localstorage
     * @param {string} dbname - the name of the database to load
     * @param {function} callback - the callback to handle the result
     * @memberof LokiLocalStorageAdapter
     */
    LokiLocalStorageAdapter.prototype.loadDatabase = function loadDatabase(dbname, callback) {
      if (localStorageAvailable()) {
        callback(localStorage.getItem(dbname));
      } else {
        callback(new Error('localStorage is not available'));
      }
    };

    /**
     * saveDatabase() - save data to localstorage, will throw an error if the file can't be saved
     * might want to expand this to avoid dataloss on partial save
     * @param {string} dbname - the filename of the database to load
     * @param {function} callback - the callback to handle the result
     * @memberof LokiLocalStorageAdapter
     */
    LokiLocalStorageAdapter.prototype.saveDatabase = function saveDatabase(dbname, dbstring, callback) {
      if (localStorageAvailable()) {
        localStorage.setItem(dbname, dbstring);
        callback(null);
      } else {
        callback(new Error('localStorage is not available'));
      }
    };

    /**
     * deleteDatabase() - delete the database from localstorage, will throw an error if it
     * can't be deleted
     * @param {string} dbname - the filename of the database to delete
     * @param {function} callback - the callback to handle the result
     * @memberof LokiLocalStorageAdapter
     */
    LokiLocalStorageAdapter.prototype.deleteDatabase = function deleteDatabase(dbname, callback) {
      if (localStorageAvailable()) {
        localStorage.removeItem(dbname);
        callback(null);
      } else {
        callback(new Error('localStorage is not available'));
      }
    };

    /**
     * Wait for throttledSaves to complete and invoke your callback when drained or duration is met.
     *
     * @param {function} callback - callback to fire when save queue is drained, it is passed a sucess parameter value
     * @param {object=} options - configuration options
     * @param {boolean} options.recursiveWait - (default: true) if after queue is drained, another save was kicked off, wait for it
     * @param {bool} options.recursiveWaitLimit - (default: false) limit our recursive waiting to a duration
     * @param {int} options.recursiveWaitLimitDelay - (default: 2000) cutoff in ms to stop recursively re-draining
     * @memberof Loki
     */
    Loki.prototype.throttledSaveDrain = function (callback, options) {
      var self = this;
      var now = (new Date()).getTime();

      if (!this.throttledSaves) {
        callback(true);
      }

      options = options || {};
      if (!options.hasOwnProperty('recursiveWait')) {
        options.recursiveWait = true;
      }
      if (!options.hasOwnProperty('recursiveWaitLimit')) {
        options.recursiveWaitLimit = false;
      }
      if (!options.hasOwnProperty('recursiveWaitLimitDuration')) {
        options.recursiveWaitLimitDuration = 2000;
      }
      if (!options.hasOwnProperty('started')) {
        options.started = (new Date()).getTime();
      }

      // if save is pending
      if (this.throttledSaves && this.throttledSavePending) {
        // if we want to wait until we are in a state where there are no pending saves at all
        if (options.recursiveWait) {
          // queue the following meta callback for when it completes
          this.throttledCallbacks.push(function () {
            // if there is now another save pending...
            if (self.throttledSavePending) {
              // if we wish to wait only so long and we have exceeded limit of our waiting, callback with false success value
              if (options.recursiveWaitLimit && (now - options.started > options.recursiveWaitLimitDuration)) {
                callback(false);
                return;
              }
              // it must be ok to wait on next queue drain
              self.throttledSaveDrain(callback, options);
              return;
            }
            // no pending saves so callback with true success
            else {
              callback(true);
              return;
            }
          });
        }
        // just notify when current queue is depleted
        else {
          this.throttledCallbacks.push(callback);
          return;
        }
      }
      // no save pending, just callback
      else {
        callback(true);
      }
    };

    /**
     * Internal load logic, decoupled from throttling/contention logic
     *
     * @param {object} options - not currently used (remove or allow overrides?)
     * @param {function=} callback - (Optional) user supplied async callback / error handler
     */
    Loki.prototype.loadDatabaseInternal = function (options, callback) {
      var cFun = callback || function (err, data) {
        if (err) {
          throw err;
        }
      },
        self = this;

      // the persistenceAdapter should be present if all is ok, but check to be sure.
      if (this.persistenceAdapter !== null) {

        this.persistenceAdapter.loadDatabase(this.filename, function loadDatabaseCallback(dbString) {
          if (typeof (dbString) === 'string') {
            var parseSuccess = false;
            try {
              self.loadJSON(dbString, options || {});
              parseSuccess = true;
            } catch (err) {
              cFun(err);
            }
            if (parseSuccess) {
              cFun(null);
              self.emit('loaded', 'database ' + self.filename + ' loaded');
            }
          } else {
            // falsy result means new database
            if (!dbString) {
              cFun(null);
              self.emit('loaded', 'empty database ' + self.filename + ' loaded');
              return;
            }

            // instanceof error means load faulted
            if (dbString instanceof Error) {
              cFun(dbString);
              return;
            }

            // if adapter has returned an js object (other than null or error) attempt to load from JSON object
            if (typeof (dbString) === "object") {
              self.loadJSONObject(dbString, options || {});
              cFun(null); // return null on success
              self.emit('loaded', 'database ' + self.filename + ' loaded');
              return;
            }

            cFun("unexpected adapter response : " + dbString);
          }
        });

      } else {
        cFun(new Error('persistenceAdapter not configured'));
      }
    };

    /**
     * Handles manually loading from file system, local storage, or adapter (such as indexeddb)
     *    This method utilizes loki configuration options (if provided) to determine which
     *    persistence method to use, or environment detection (if configuration was not provided).
     *    To avoid contention with any throttledSaves, we will drain the save queue first.
     *
     * If you are configured with autosave, you do not need to call this method yourself.
     *
     * @param {object} options - if throttling saves and loads, this controls how we drain save queue before loading
     * @param {boolean} options.recursiveWait - (default: true) wait recursively until no saves are queued
     * @param {bool} options.recursiveWaitLimit - (default: false) limit our recursive waiting to a duration
     * @param {int} options.recursiveWaitLimitDelay - (default: 2000) cutoff in ms to stop recursively re-draining
     * @param {function=} callback - (Optional) user supplied async callback / error handler
     * @memberof Loki
     * @example
     * db.loadDatabase({}, function(err) {
     *   if (err) {
     *     console.log("error : " + err);
     *   }
     *   else {
     *     console.log("database loaded.");
     *   }
     * });
     */
    Loki.prototype.loadDatabase = function (options, callback) {
      var self = this;

      // if throttling disabled, just call internal
      if (!this.throttledSaves) {
        this.loadDatabaseInternal(options, callback);
        return;
      }

      // try to drain any pending saves in the queue to lock it for loading
      this.throttledSaveDrain(function (success) {
        if (success) {
          // pause/throttle saving until loading is done
          self.throttledSavePending = true;

          self.loadDatabaseInternal(options, function (err) {
            // now that we are finished loading, if no saves were throttled, disable flag
            if (self.throttledCallbacks.length === 0) {
              self.throttledSavePending = false;
            }
            // if saves requests came in while loading, kick off new save to kick off resume saves
            else {
              self.saveDatabase();
            }

            if (typeof callback === 'function') {
              callback(err);
            }
          });
          return;
        }
        else {
          if (typeof callback === 'function') {
            callback(new Error("Unable to pause save throttling long enough to read database"));
          }
        }
      }, options);
    };

    /**
     * Internal save logic, decoupled from save throttling logic
     */
    Loki.prototype.saveDatabaseInternal = function (callback) {
      var cFun = callback || function (err) {
        if (err) {
          throw err;
        }
        return;
      };
      var self = this;

      // the persistenceAdapter should be present if all is ok, but check to be sure.
      if (!this.persistenceAdapter) {
        cFun(new Error('persistenceAdapter not configured'));
        return;
      }

      // run incremental, reference, or normal mode adapters, depending on what's available
      if (this.persistenceAdapter.mode === "incremental") {
        var cachedDirty;
        // ignore autosave until we copy loki (only then we can clear dirty flags,
        // but if we don't do it now, autosave will be triggered a lot unnecessarily)
        this.ignoreAutosave = true;
        this.persistenceAdapter.saveDatabase(
          this.filename,
          function getLokiCopy() {
            self.ignoreAutosave = false;
            if (cachedDirty) {
              cFun(new Error('adapter error - getLokiCopy called more than once'));
              return;
            }
            var lokiCopy = self.copy({ removeNonSerializable: true });

            // remember and clear dirty ids -- we must do it before the save so that if
            // and update occurs between here and callback, it will get saved later
            cachedDirty = self.collections.map(function (collection) {
              return [collection.dirty, collection.dirtyIds];
            });
            self.collections.forEach(function (col) {
              col.dirty = false;
              col.dirtyIds = [];
            });
            return lokiCopy;
          },
          function exportDatabaseCallback(err) {
            self.ignoreAutosave = false;
            if (err && cachedDirty) {
              // roll back dirty IDs to be saved later
              self.collections.forEach(function (col, i) {
                var cached = cachedDirty[i];
                col.dirty = col.dirty || cached[0];
                col.dirtyIds = col.dirtyIds.concat(cached[1]);
              });
            }
            cFun(err);
          });
      } else if (this.persistenceAdapter.mode === "reference" && typeof this.persistenceAdapter.exportDatabase === "function") {
        // TODO: dirty should be cleared here
        // filename may seem redundant but loadDatabase will need to expect this same filename
        this.persistenceAdapter.exportDatabase(this.filename, this.copy({ removeNonSerializable: true }), function exportDatabaseCallback(err) {
          self.autosaveClearFlags();
          cFun(err);
        });
      }
      // otherwise just pass the serialized database to adapter
      else {
        // persistenceAdapter might be asynchronous, so we must clear `dirty` immediately
        // or autosave won't work if an update occurs between here and the callback
        // TODO: This should be stored and rolled back in case of DB save failure
        this.autosaveClearFlags();
        this.persistenceAdapter.saveDatabase(this.filename, this.serialize(), function saveDatabasecallback(err) {
          cFun(err);
        });
      }
    };

    /**
     * Handles manually saving to file system, local storage, or adapter (such as indexeddb)
     *    This method utilizes loki configuration options (if provided) to determine which
     *    persistence method to use, or environment detection (if configuration was not provided).
     *
     * If you are configured with autosave, you do not need to call this method yourself.
     *
     * @param {function=} callback - (Optional) user supplied async callback / error handler
     * @memberof Loki
     * @example
     * db.saveDatabase(function(err) {
     *   if (err) {
     *     console.log("error : " + err);
     *   }
     *   else {
     *     console.log("database saved.");
     *   }
     * });
     */
    Loki.prototype.saveDatabase = function (callback) {
      if (!this.throttledSaves) {
        this.saveDatabaseInternal(callback);
        return;
      }

      if (this.throttledSavePending) {
        this.throttledCallbacks.push(callback);
        return;
      }

      var localCallbacks = this.throttledCallbacks;
      this.throttledCallbacks = [];
      localCallbacks.unshift(callback);
      this.throttledSavePending = true;

      var self = this;
      this.saveDatabaseInternal(function (err) {
        self.throttledSavePending = false;
        localCallbacks.forEach(function (pcb) {
          if (typeof pcb === 'function') {
            // Queue the callbacks so we first finish this method execution
            setTimeout(function () {
              pcb(err);
            }, 1);
          }
        });

        // since this is called async, future requests may have come in, if so.. kick off next save
        if (self.throttledCallbacks.length > 0) {
          self.saveDatabase();
        }
      });
    };

    // alias
    Loki.prototype.save = Loki.prototype.saveDatabase;

    /**
     * Handles deleting a database from file system, local
     *    storage, or adapter (indexeddb)
     *    This method utilizes loki configuration options (if provided) to determine which
     *    persistence method to use, or environment detection (if configuration was not provided).
     *
     * @param {function=} callback - (Optional) user supplied async callback / error handler
     * @memberof Loki
     */
    Loki.prototype.deleteDatabase = function (options, callback) {
      var cFun = callback || function (err, data) {
        if (err) {
          throw err;
        }
      };

      // we aren't even using options, so we will support syntax where
      // callback is passed as first and only argument
      if (typeof options === 'function' && !callback) {
        cFun = options;
      }

      // the persistenceAdapter should be present if all is ok, but check to be sure.
      if (this.persistenceAdapter !== null) {
        this.persistenceAdapter.deleteDatabase(this.filename, function deleteDatabaseCallback(err) {
          cFun(err);
        });
      } else {
        cFun(new Error('persistenceAdapter not configured'));
      }
    };

    /**
     * autosaveDirty - check whether any collections are 'dirty' meaning we need to save (entire) database
     *
     * @returns {boolean} - true if database has changed since last autosave, false if not.
     */
    Loki.prototype.autosaveDirty = function () {
      for (var idx = 0; idx < this.collections.length; idx++) {
        if (this.collections[idx].dirty) {
          return true;
        }
      }

      return false;
    };

    /**
     * autosaveClearFlags - resets dirty flags on all collections.
     *    Called from saveDatabase() after db is saved.
     *
     */
    Loki.prototype.autosaveClearFlags = function () {
      for (var idx = 0; idx < this.collections.length; idx++) {
        this.collections[idx].dirty = false;
      }
    };

    /**
     * autosaveEnable - begin a javascript interval to periodically save the database.
     *
     * @param {object} options - not currently used (remove or allow overrides?)
     * @param {function=} callback - (Optional) user supplied async callback
     */
    Loki.prototype.autosaveEnable = function (options, callback) {
      this.autosave = true;

      var delay = 5000,
        self = this;

      if (typeof (this.autosaveInterval) !== 'undefined' && this.autosaveInterval !== null) {
        delay = this.autosaveInterval;
      }

      this.autosaveHandle = setInterval(function autosaveHandleInterval() {
        // use of dirty flag will need to be hierarchical since mods are done at collection level with no visibility of 'db'
        // so next step will be to implement collection level dirty flags set on insert/update/remove
        // along with loki level isdirty() function which iterates all collections to see if any are dirty

        if (self.autosaveDirty() && !self.ignoreAutosave) {
          self.saveDatabase(callback);
        }
      }, delay);
    };

    /**
     * autosaveDisable - stop the autosave interval timer.
     *
     */
    Loki.prototype.autosaveDisable = function () {
      if (typeof (this.autosaveHandle) !== 'undefined' && this.autosaveHandle !== null) {
        clearInterval(this.autosaveHandle);
        this.autosaveHandle = null;
      }
    };


    /**
     * Resultset class allowing chainable queries.  Intended to be instanced internally.
     *    Collection.find(), Collection.where(), and Collection.chain() instantiate this.
     *
     * @example
     *    mycollection.chain()
     *      .find({ 'doors' : 4 })
     *      .where(function(obj) { return obj.name === 'Toyota' })
     *      .data();
     *
     * @constructor Resultset
     * @param {Collection} collection - The collection which this Resultset will query against.
     */
    function Resultset(collection, options) {
      options = options || {};

      // retain reference to collection we are querying against
      this.collection = collection;
      this.filteredrows = [];
      this.filterInitialized = false;

      return this;
    }

    /**
     * reset() - Reset the resultset to its initial state.
     *
     * @returns {Resultset} Reference to this resultset, for future chain operations.
     */
    Resultset.prototype.reset = function () {
      if (this.filteredrows.length > 0) {
        this.filteredrows = [];
      }
      this.filterInitialized = false;
      return this;
    };

    /**
     * toJSON() - Override of toJSON to avoid circular references
     *
     */
    Resultset.prototype.toJSON = function () {
      var copy = this.copy();
      copy.collection = null;
      return copy;
    };

    /**
     * Allows you to limit the number of documents passed to next chain operation.
     *    A resultset copy() is made to avoid altering original resultset.
     *
     * @param {int} qty - The number of documents to return.
     * @returns {Resultset} Returns a copy of the resultset, limited by qty, for subsequent chain ops.
     * @memberof Resultset
     * // find the two oldest users
     * var result = users.chain().simplesort("age", true).limit(2).data();
     */
    Resultset.prototype.limit = function (qty) {
      // if this has no filters applied, we need to populate filteredrows first
      if (!this.filterInitialized && this.filteredrows.length === 0) {
        this.filteredrows = this.collection.prepareFullDocIndex();
      }

      var rscopy = new Resultset(this.collection);
      rscopy.filteredrows = this.filteredrows.slice(0, qty);
      rscopy.filterInitialized = true;
      return rscopy;
    };

    /**
     * Used for skipping 'pos' number of documents in the resultset.
     *
     * @param {int} pos - Number of documents to skip; all preceding documents are filtered out.
     * @returns {Resultset} Returns a copy of the resultset, containing docs starting at 'pos' for subsequent chain ops.
     * @memberof Resultset
     * // find everyone but the two oldest users
     * var result = users.chain().simplesort("age", true).offset(2).data();
     */
    Resultset.prototype.offset = function (pos) {
      // if this has no filters applied, we need to populate filteredrows first
      if (!this.filterInitialized && this.filteredrows.length === 0) {
        this.filteredrows = this.collection.prepareFullDocIndex();
      }

      var rscopy = new Resultset(this.collection);
      rscopy.filteredrows = this.filteredrows.slice(pos);
      rscopy.filterInitialized = true;
      return rscopy;
    };

    /**
     * copy() - To support reuse of resultset in branched query situations.
     *
     * @returns {Resultset} Returns a copy of the resultset (set) but the underlying document references will be the same.
     * @memberof Resultset
     */
    Resultset.prototype.copy = function () {
      var result = new Resultset(this.collection);

      if (this.filteredrows.length > 0) {
        result.filteredrows = this.filteredrows.slice();
      }
      result.filterInitialized = this.filterInitialized;

      return result;
    };

    /**
     * Alias of copy()
     * @memberof Resultset
     */
    Resultset.prototype.branch = Resultset.prototype.copy;

    /**
     * transform() - executes a named collection transform or raw array of transform steps against the resultset.
     *
     * @param transform {(string|array)} - name of collection transform or raw transform array
     * @param parameters {object=} - (Optional) object property hash of parameters, if the transform requires them.
     * @returns {Resultset} either (this) resultset or a clone of of this resultset (depending on steps)
     * @memberof Resultset
     * @example
     * users.addTransform('CountryFilter', [
     *   {
     *     type: 'find',
     *     value: {
     *       'country': { $eq: '[%lktxp]Country' }
     *     }
     *   },
     *   {
     *     type: 'simplesort',
     *     property: 'age',
     *     options: { desc: false}
     *   }
     * ]);
     * var results = users.chain().transform("CountryFilter", { Country: 'fr' }).data();
     */
    Resultset.prototype.transform = function (transform, parameters) {
      var idx,
        step,
        rs = this;

      // if transform is name, then do lookup first
      if (typeof transform === 'string') {
        if (this.collection.transforms.hasOwnProperty(transform)) {
          transform = this.collection.transforms[transform];
        }
      }

      // either they passed in raw transform array or we looked it up, so process
      if (typeof transform !== 'object' || !Array.isArray(transform)) {
        throw new Error("Invalid transform");
      }

      if (typeof parameters !== 'undefined') {
        transform = Utils.resolveTransformParams(transform, parameters);
      }

      for (idx = 0; idx < transform.length; idx++) {
        step = transform[idx];

        switch (step.type) {
          case "find":
            rs.find(step.value);
            break;
          case "where":
            rs.where(step.value);
            break;
          case "simplesort":
            rs.simplesort(step.property, step.desc || step.options);
            break;
          case "compoundsort":
            rs.compoundsort(step.value);
            break;
          case "sort":
            rs.sort(step.value);
            break;
          case "limit":
            rs = rs.limit(step.value);
            break; // limit makes copy so update reference
          case "offset":
            rs = rs.offset(step.value);
            break; // offset makes copy so update reference
          case "map":
            rs = rs.map(step.value, step.dataOptions);
            break;
          case "eqJoin":
            rs = rs.eqJoin(step.joinData, step.leftJoinKey, step.rightJoinKey, step.mapFun, step.dataOptions);
            break;
          // following cases break chain by returning array data so make any of these last in transform steps
          case "mapReduce":
            rs = rs.mapReduce(step.mapFunction, step.reduceFunction);
            break;
          // following cases update documents in current filtered resultset (use carefully)
          case "update":
            rs.update(step.value);
            break;
          case "remove":
            rs.remove();
            break;
          default:
            break;
        }
      }

      return rs;
    };

    /**
     * User supplied compare function is provided two documents to compare. (chainable)
     * @example
     *    rslt.sort(function(obj1, obj2) {
     *      if (obj1.name === obj2.name) return 0;
     *      if (obj1.name > obj2.name) return 1;
     *      if (obj1.name < obj2.name) return -1;
     *    });
     *
     * @param {function} comparefun - A javascript compare function used for sorting.
     * @returns {Resultset} Reference to this resultset, sorted, for future chain operations.
     * @memberof Resultset
     */
    Resultset.prototype.sort = function (comparefun) {
      // if this has no filters applied, just we need to populate filteredrows first
      if (!this.filterInitialized && this.filteredrows.length === 0) {
        this.filteredrows = this.collection.prepareFullDocIndex();
      }

      var wrappedComparer =
        (function (userComparer, data) {
          return function (a, b) {
            return userComparer(data[a], data[b]);
          };
        })(comparefun, this.collection.data);

      this.filteredrows.sort(wrappedComparer);

      return this;
    };

    /**
     * Simpler, loose evaluation for user to sort based on a property name. (chainable).
     *    Sorting based on the same lt/gt helper functions used for binary indices.
     *
     * @param {string} propname - name of property to sort by.
     * @param {object|bool=} options - boolean to specify if isdescending, or options object
     * @param {boolean} [options.desc=false] - whether to sort descending
     * @param {boolean} [options.disableIndexIntersect=false] - whether we should explicity not use array intersection.
     * @param {boolean} [options.forceIndexIntersect=false] - force array intersection (if binary index exists).
     * @param {boolean} [options.useJavascriptSorting=false] - whether results are sorted via basic javascript sort.
     * @returns {Resultset} Reference to this resultset, sorted, for future chain operations.
     * @memberof Resultset
     * @example
     * var results = users.chain().simplesort('age').data();
     */
    Resultset.prototype.simplesort = function (propname, options) {
      var eff,
        targetEff = 10,
        dc = this.collection.data.length,
        frl = this.filteredrows.length,
        hasBinaryIndex = this.collection.binaryIndices.hasOwnProperty(propname);

      if (typeof (options) === 'undefined' || options === false) {
        options = { desc: false };
      }
      if (options === true) {
        options = { desc: true };
      }

      // if nothing in filtered rows array...
      if (frl === 0) {
        // if the filter is initialized to be empty resultset, do nothing
        if (this.filterInitialized) {
          return this;
        }

        // otherwise no filters applied implies all documents, so we need to populate filteredrows first

        // if we have a binary index, we can just use that instead of sorting (again)
        if (this.collection.binaryIndices.hasOwnProperty(propname)) {
          // make sure index is up-to-date
          this.collection.ensureIndex(propname);
          // copy index values into filteredrows
          this.filteredrows = this.collection.binaryIndices[propname].values.slice(0);

          if (options.desc) {
            this.filteredrows.reverse();
          }

          // we are done, return this (resultset) for further chain ops
          return this;
        }
        // otherwise initialize array for sort below
        else {
          // build full document index (to be sorted subsequently)
          this.filteredrows = this.collection.prepareFullDocIndex();
        }
      }
      // otherwise we had results to begin with, see if we qualify for index intercept optimization
      else {

        // If already filtered, but we want to leverage binary index on sort.
        // This will use custom array intection algorithm.
        if (!options.disableIndexIntersect && hasBinaryIndex) {

          // calculate filter efficiency
          eff = dc / frl;

          // when javascript sort fallback is enabled, you generally need more than ~17% of total docs in resultset
          // before array intersect is determined to be the faster algorithm, otherwise leave at 10% for loki sort.
          if (options.useJavascriptSorting) {
            targetEff = 6;
          }

          // anything more than ratio of 10:1 (total documents/current results) should use old sort code path
          // So we will only use array intersection if you have more than 10% of total docs in your current resultset.
          if (eff <= targetEff || options.forceIndexIntersect) {
            var idx, fr = this.filteredrows;
            var io = {};
            // set up hashobject for simple 'inclusion test' with existing (filtered) results
            for (idx = 0; idx < frl; idx++) {
              io[fr[idx]] = true;
            }
            // grab full sorted binary index array
            var pv = this.collection.binaryIndices[propname].values;

            // filter by existing results
            this.filteredrows = pv.filter(function (n) { return io[n]; });

            if (options.desc) {
              this.filteredrows.reverse();
            }

            return this;
          }
        }
      }

      // at this point, we will not be able to leverage binary index so we will have to do an array sort

      // if we have opted to use simplified javascript comparison function...
      if (options.useJavascriptSorting) {
        return this.sort(function (obj1, obj2) {
          if (obj1[propname] === obj2[propname]) return 0;
          if (obj1[propname] > obj2[propname]) return 1;
          if (obj1[propname] < obj2[propname]) return -1;
        });
      }

      // otherwise use loki sort which will return same results if column is indexed or not
      var wrappedComparer =
        (function (prop, desc, data) {
          var val1, val2, arr;
          return function (a, b) {
            if (~prop.indexOf('.')) {
              arr = prop.split('.');
              val1 = Utils.getIn(data[a], arr, true);
              val2 = Utils.getIn(data[b], arr, true);
            } else {
              val1 = data[a][prop];
              val2 = data[b][prop];
            }
            return sortHelper(val1, val2, desc);
          };
        })(propname, options.desc, this.collection.data);

      this.filteredrows.sort(wrappedComparer);

      return this;
    };

    /**
     * Allows sorting a resultset based on multiple columns.
     * @example
     * // to sort by age and then name (both ascending)
     * rs.compoundsort(['age', 'name']);
     * // to sort by age (ascending) and then by name (descending)
     * rs.compoundsort(['age', ['name', true]]);
     *
     * @param {array} properties - array of property names or subarray of [propertyname, isdesc] used evaluate sort order
     * @returns {Resultset} Reference to this resultset, sorted, for future chain operations.
     * @memberof Resultset
     */
    Resultset.prototype.compoundsort = function (properties) {
      if (properties.length === 0) {
        throw new Error("Invalid call to compoundsort, need at least one property");
      }

      var prop;
      if (properties.length === 1) {
        prop = properties[0];
        if (Array.isArray(prop)) {
          return this.simplesort(prop[0], prop[1]);
        }
        return this.simplesort(prop, false);
      }

      // unify the structure of 'properties' to avoid checking it repeatedly while sorting
      for (var i = 0, len = properties.length; i < len; i += 1) {
        prop = properties[i];
        if (!Array.isArray(prop)) {
          properties[i] = [prop, false];
        }
      }

      // if this has no filters applied, just we need to populate filteredrows first
      if (!this.filterInitialized && this.filteredrows.length === 0) {
        this.filteredrows = this.collection.prepareFullDocIndex();
      }

      var wrappedComparer =
        (function (props, data) {
          return function (a, b) {
            return compoundeval(props, data[a], data[b]);
          };
        })(properties, this.collection.data);

      this.filteredrows.sort(wrappedComparer);

      return this;
    };

    /**
     * findOr() - oversee the operation of OR'ed query expressions.
     *    OR'ed expression evaluation runs each expression individually against the full collection,
     *    and finally does a set OR on each expression's results.
     *    Each evaluation can utilize a binary index to prevent multiple linear array scans.
     *
     * @param {array} expressionArray - array of expressions
     * @returns {Resultset} this resultset for further chain ops.
     */
    Resultset.prototype.findOr = function (expressionArray) {
      var fr = null,
        fri = 0,
        frlen = 0,
        docset = [],
        idxset = [],
        idx = 0,
        origCount = this.count();

      // If filter is already initialized, then we query against only those items already in filter.
      // This means no index utilization for fields, so hopefully its filtered to a smallish filteredrows.
      for (var ei = 0, elen = expressionArray.length; ei < elen; ei++) {
        // we need to branch existing query to run each filter separately and combine results
        fr = this.branch().find(expressionArray[ei]).filteredrows;
        frlen = fr.length;

        // add any document 'hits'
        for (fri = 0; fri < frlen; fri++) {
          idx = fr[fri];
          if (idxset[idx] === undefined) {
            idxset[idx] = true;
            docset.push(idx);
          }
        }
      }

      this.filteredrows = docset;
      this.filterInitialized = true;

      return this;
    };
    Resultset.prototype.$or = Resultset.prototype.findOr;

    // precompile recursively
    function precompileQuery(operator, value) {
      // for regex ops, precompile
      if (operator === '$regex') {
        if (Array.isArray(value)) {
          value = new RegExp(value[0], value[1]);
        } else if (!(value instanceof RegExp)) {
          value = new RegExp(value);
        }
      }
      else if (typeof value === 'object') {
        for (var key in value) {
          if (key === '$regex' || typeof value[key] === 'object') {
            value[key] = precompileQuery(key, value[key]);
          }
        }
      }

      return value;
    }

    /**
     * findAnd() - oversee the operation of AND'ed query expressions.
     *    AND'ed expression evaluation runs each expression progressively against the full collection,
     *    internally utilizing existing chained resultset functionality.
     *    Only the first filter can utilize a binary index.
     *
     * @param {array} expressionArray - array of expressions
     * @returns {Resultset} this resultset for further chain ops.
     */
    Resultset.prototype.findAnd = function (expressionArray) {
      // we have already implementing method chaining in this (our Resultset class)
      // so lets just progressively apply user supplied and filters
      for (var i = 0, len = expressionArray.length; i < len; i++) {
        if (this.count() === 0) {
          return this;
        }
        this.find(expressionArray[i]);
      }
      return this;
    };
    Resultset.prototype.$and = Resultset.prototype.findAnd;

    /**
     * Used for querying via a mongo-style query object.
     *
     * @param {object} query - A mongo-style query object used for filtering current results.
     * @param {boolean=} firstOnly - (Optional) Used by collection.findOne()
     * @returns {Resultset} this resultset for further chain ops.
     * @memberof Resultset
     * @example
     * var over30 = users.chain().find({ age: { $gte: 30 } }).data();
     */
    Resultset.prototype.find = function (query, firstOnly) {
      if (this.collection.data.length === 0) {
        this.filteredrows = [];
        this.filterInitialized = true;
        return this;
      }

      var queryObject = query || 'getAll',
        p,
        property,
        queryObjectOp,
        obj,
        operator,
        value,
        key,
        searchByIndex = false,
        result = [],
        filters = [],
        index = null;

      // flag if this was invoked via findOne()
      firstOnly = firstOnly || false;

      if (typeof queryObject === 'object') {
        for (p in queryObject) {
          obj = {};
          obj[p] = queryObject[p];
          filters.push(obj);

          if (hasOwnProperty.call(queryObject, p)) {
            property = p;
            queryObjectOp = queryObject[p];
          }
        }
        // if more than one expression in single query object,
        // convert implicit $and to explicit $and
        if (filters.length > 1) {
          return this.find({ '$and': filters }, firstOnly);
        }
      }

      // apply no filters if they want all
      if (!property || queryObject === 'getAll') {
        if (firstOnly) {
          if (this.filterInitialized) {
            this.filteredrows = this.filteredrows.slice(0, 1);
          } else {
            this.filteredrows = (this.collection.data.length > 0) ? [0] : [];
            this.filterInitialized = true;
          }
        }

        return this;
      }

      // injecting $and and $or expression tree evaluation here.
      if (property === '$and' || property === '$or') {
        this[property](queryObjectOp);

        // for chained find with firstonly,
        if (firstOnly && this.filteredrows.length > 1) {
          this.filteredrows = this.filteredrows.slice(0, 1);
        }

        return this;
      }

      // see if query object is in shorthand mode (assuming eq operator)
      if (queryObjectOp === null || (typeof queryObjectOp !== 'object' || queryObjectOp instanceof Date)) {
        operator = '$eq';
        value = queryObjectOp;
      } else if (typeof queryObjectOp === 'object') {
        for (key in queryObjectOp) {
          if (hasOwnProperty.call(queryObjectOp, key)) {
            operator = key;
            value = queryObjectOp[key];
            break;
          }
        }
      } else {
        throw new Error('Do not know what you want to do.');
      }

      if (operator === '$regex' || typeof value === 'object') {
        value = precompileQuery(operator, value);
      }

      // if user is deep querying the object such as find('name.first': 'odin')
      var usingDotNotation = (property.indexOf('.') !== -1);

      // if an index exists for the property being queried against, use it
      // for now only enabling where it is the first filter applied and prop is indexed
      var doIndexCheck = !this.filterInitialized;

      if (doIndexCheck && this.collection.binaryIndices[property] && indexedOps[operator]) {
        // this is where our lazy index rebuilding will take place
        // basically we will leave all indexes dirty until we need them
        // so here we will rebuild only the index tied to this property
        // ensureIndex() will only rebuild if flagged as dirty since we are not passing force=true param
        if (this.collection.adaptiveBinaryIndices !== true) {
          this.collection.ensureIndex(property);
        }

        searchByIndex = true;
        index = this.collection.binaryIndices[property];
      }

      // opportunistically speed up $in searches from O(n*m) to O(n*log m)
      if (!searchByIndex && operator === '$in' && Array.isArray(value) && typeof Set !== 'undefined') {
        value = new Set(value);
        operator = '$inSet';
      }

      // the comparison function
      var fun = LokiOps[operator];

      // "shortcut" for collection data
      var t = this.collection.data;
      // filter data length
      var i = 0,
        len = 0;

      // Query executed differently depending on :
      //    - whether the property being queried has an index defined
      //    - if chained, we handle first pass differently for initial filteredrows[] population
      //
      // For performance reasons, each case has its own if block to minimize in-loop calculations

      var filter, rowIdx = 0, record;

      // If the filteredrows[] is already initialized, use it
      if (this.filterInitialized) {
        filter = this.filteredrows;
        len = filter.length;

        // currently supporting dot notation for non-indexed conditions only
        if (usingDotNotation) {
          property = property.split('.');
          for (i = 0; i < len; i++) {
            rowIdx = filter[i];
            record = t[rowIdx];
            if (dotSubScan(record, property, fun, value, record)) {
              result.push(rowIdx);
              if (firstOnly) {
                this.filteredrows = result;
                return this;
              }
            }
          }
        } else {
          for (i = 0; i < len; i++) {
            rowIdx = filter[i];
            record = t[rowIdx];
            if (fun(record[property], value, record)) {
              result.push(rowIdx);
              if (firstOnly) {
                this.filteredrows = result;
                return this;
              }
            }
          }
        }
      }
      // first chained query so work against data[] but put results in filteredrows
      else {
        // if not searching by index
        if (!searchByIndex) {
          len = t.length;

          if (usingDotNotation) {
            property = property.split('.');
            for (i = 0; i < len; i++) {
              record = t[i];
              if (dotSubScan(record, property, fun, value, record)) {
                result.push(i);
                if (firstOnly) {
                  this.filteredrows = result;
                  this.filterInitialized = true;
                  return this;
                }
              }
            }
          } else {
            for (i = 0; i < len; i++) {
              record = t[i];
              if (fun(record[property], value, record)) {
                result.push(i);
                if (firstOnly) {
                  this.filteredrows = result;
                  this.filterInitialized = true;
                  return this;
                }
              }
            }
          }
        } else {
          // search by index
          var segm = this.collection.calculateRange(operator, property, value);

          if (operator !== '$in') {
            for (i = segm[0]; i <= segm[1]; i++) {
              if (indexedOps[operator] !== true) {
                // must be a function, implying 2nd phase filtering of results from calculateRange
                if (indexedOps[operator](Utils.getIn(t[index.values[i]], property, usingDotNotation), value)) {
                  result.push(index.values[i]);
                  if (firstOnly) {
                    this.filteredrows = result;
                    this.filterInitialized = true;
                    return this;
                  }
                }
              }
              else {
                result.push(index.values[i]);
                if (firstOnly) {
                  this.filteredrows = result;
                  this.filterInitialized = true;
                  return this;
                }
              }
            }
          } else {
            for (i = 0, len = segm.length; i < len; i++) {
              result.push(index.values[segm[i]]);
              if (firstOnly) {
                this.filteredrows = result;
                this.filterInitialized = true;
                return this;
              }
            }
          }
        }

      }

      this.filteredrows = result;
      this.filterInitialized = true; // next time work against filteredrows[]
      return this;
    };


    /**
     * where() - Used for filtering via a javascript filter function.
     *
     * @param {function} fun - A javascript function used for filtering current results by.
     * @returns {Resultset} this resultset for further chain ops.
     * @memberof Resultset
     * @example
     * var over30 = users.chain().where(function(obj) { return obj.age >= 30; }.data();
     */
    Resultset.prototype.where = function (fun) {
      var viewFunction,
        result = [];

      if ('function' === typeof fun) {
        viewFunction = fun;
      } else {
        throw new TypeError('Argument is not a stored view or a function');
      }
      try {
        // If the filteredrows[] is already initialized, use it
        if (this.filterInitialized) {
          var j = this.filteredrows.length;

          while (j--) {
            if (viewFunction(this.collection.data[this.filteredrows[j]]) === true) {
              result.push(this.filteredrows[j]);
            }
          }

          this.filteredrows = result;

          return this;
        }
        // otherwise this is initial chained op, work against data, push into filteredrows[]
        else {
          var k = this.collection.data.length;

          while (k--) {
            if (viewFunction(this.collection.data[k]) === true) {
              result.push(k);
            }
          }

          this.filteredrows = result;
          this.filterInitialized = true;

          return this;
        }
      } catch (err) {
        throw err;
      }
    };

    /**
     * count() - returns the number of documents in the resultset.
     *
     * @returns {number} The number of documents in the resultset.
     * @memberof Resultset
     * @example
     * var over30Count = users.chain().find({ age: { $gte: 30 } }).count();
     */
    Resultset.prototype.count = function () {
      if (this.filterInitialized) {
        return this.filteredrows.length;
      }
      return this.collection.count();
    };

    /**
     * Terminates the chain and returns array of filtered documents
     *
     * @param {object=} options - allows specifying 'forceClones' and 'forceCloneMethod' options.
     * @param {boolean} options.forceClones - Allows forcing the return of cloned objects even when
     *        the collection is not configured for clone object.
     * @param {string} options.forceCloneMethod - Allows overriding the default or collection specified cloning method.
     *        Possible values include 'parse-stringify', 'jquery-extend-deep', 'shallow', 'shallow-assign'
     * @param {bool} options.removeMeta - Will force clones and strip $loki and meta properties from documents
     *
     * @returns {array} Array of documents in the resultset
     * @memberof Resultset
     * @example
     * var resutls = users.chain().find({ age: 34 }).data();
     */
    Resultset.prototype.data = function (options) {
      var result = [],
        data = this.collection.data,
        obj,
        len,
        i,
        method;

      options = options || {};

      // if user opts to strip meta, then force clones and use 'shallow' if 'force' options are not present
      if (options.removeMeta && !options.forceClones) {
        options.forceClones = true;
        options.forceCloneMethod = options.forceCloneMethod || 'shallow';
      }

      // if collection has delta changes active, then force clones and use 'parse-stringify' for effective change tracking of nested objects
      // if collection is immutable freeze and unFreeze takes care of cloning
      if (!this.collection.disableDeltaChangesApi && this.collection.disableFreeze) {
        options.forceClones = true;
        options.forceCloneMethod = 'parse-stringify';
      }

      // if this has no filters applied, just return collection.data
      if (!this.filterInitialized) {
        if (this.filteredrows.length === 0) {
          // determine whether we need to clone objects or not
          if (this.collection.cloneObjects || options.forceClones) {
            len = data.length;
            method = options.forceCloneMethod || this.collection.cloneMethod;
            for (i = 0; i < len; i++) {
              obj = clone(data[i], method);
              if (options.removeMeta) {
                delete obj.$loki;
                delete obj.meta;
              }
              result.push(obj);
            }
            return result;
          }
          // otherwise we are not cloning so return sliced array with same object references
          else {
            return data.slice();
          }
        } else {
          // filteredrows must have been set manually, so use it
          this.filterInitialized = true;
        }
      }

      var fr = this.filteredrows;
      len = fr.length;

      if (this.collection.cloneObjects || options.forceClones) {
        method = options.forceCloneMethod || this.collection.cloneMethod;
        for (i = 0; i < len; i++) {
          obj = clone(data[fr[i]], method);
          if (options.removeMeta) {
            delete obj.$loki;
            delete obj.meta;
          }
          result.push(obj);
        }
      } else {
        for (i = 0; i < len; i++) {
          result.push(data[fr[i]]);
        }
      }
      return result;
    };

    /**
     * Used to run an update operation on all documents currently in the resultset.
     *
     * @param {function} updateFunction - User supplied updateFunction(obj) will be executed for each document object.
     * @returns {Resultset} this resultset for further chain ops.
     * @memberof Resultset
     * @example
     * users.chain().find({ country: 'de' }).update(function(user) {
     *   user.phoneFormat = "+49 AAAA BBBBBB";
     * });
     */
    Resultset.prototype.update = function (updateFunction) {

      if (typeof (updateFunction) !== "function") {
        throw new TypeError('Argument is not a function');
      }

      // if this has no filters applied, we need to populate filteredrows first
      if (!this.filterInitialized && this.filteredrows.length === 0) {
        this.filteredrows = this.collection.prepareFullDocIndex();
      }

      var obj, len = this.filteredrows.length,
        rcd = this.collection.data;

      // pass in each document object currently in resultset to user supplied updateFunction
      for (var idx = 0; idx < len; idx++) {
        // if we have cloning option specified or are doing differential delta changes, clone object first
        if (!this.disableFreeze || this.collection.cloneObjects || !this.collection.disableDeltaChangesApi) {
          obj = clone(rcd[this.filteredrows[idx]], this.collection.cloneMethod);
          updateFunction(obj);
          this.collection.update(obj);
        }
        else {
          // no need to clone, so just perform update on collection data object instance
          updateFunction(rcd[this.filteredrows[idx]]);
          this.collection.update(rcd[this.filteredrows[idx]]);
        }
      }

      return this;
    };

    /**
     * Removes all document objects which are currently in resultset from collection (as well as resultset)
     *
     * @returns {Resultset} this (empty) resultset for further chain ops.
     * @memberof Resultset
     * @example
     * // remove users inactive since 1/1/2001
     * users.chain().find({ lastActive: { $lte: new Date("1/1/2001").getTime() } }).remove();
     */
    Resultset.prototype.remove = function () {

      // if this has no filters applied, we need to populate filteredrows first
      if (!this.filterInitialized && this.filteredrows.length === 0) {
        this.filteredrows = this.collection.prepareFullDocIndex();
      }

      this.collection.removeBatchByPositions(this.filteredrows);

      this.filteredrows = [];

      return this;
    };

    /**
     * data transformation via user supplied functions
     *
     * @param {function} mapFunction - this function accepts a single document for you to transform and return
     * @param {function} reduceFunction - this function accepts many (array of map outputs) and returns single value
     * @returns {value} The output of your reduceFunction
     * @memberof Resultset
     * @example
     * var db = new loki("order.db");
     * var orders = db.addCollection("orders");
     * orders.insert([{ qty: 4, unitCost: 100.00 }, { qty: 10, unitCost: 999.99 }, { qty: 2, unitCost: 49.99 }]);
     *
     * function mapfun (obj) { return obj.qty*obj.unitCost };
     * function reducefun(array) {
     *   var grandTotal=0;
     *   array.forEach(function(orderTotal) { grandTotal += orderTotal; });
     *   return grandTotal;
     * }
     * var grandOrderTotal = orders.chain().mapReduce(mapfun, reducefun);
     * console.log(grandOrderTotal);
     */
    Resultset.prototype.mapReduce = function (mapFunction, reduceFunction) {
      try {
        return reduceFunction(this.data().map(mapFunction));
      } catch (err) {
        throw err;
      }
    };

    /**
     * eqJoin() - Left joining two sets of data. Join keys can be defined or calculated properties
     * eqJoin expects the right join key values to be unique.  Otherwise left data will be joined on the last joinData object with that key
     * @param {Array|Resultset|Collection} joinData - Data array to join to.
     * @param {(string|function)} leftJoinKey - Property name in this result set to join on or a function to produce a value to join on
     * @param {(string|function)} rightJoinKey - Property name in the joinData to join on or a function to produce a value to join on
     * @param {function=} mapFun - (Optional) A function that receives each matching pair and maps them into output objects - function(left,right){return joinedObject}
     * @param {object=} dataOptions - options to data() before input to your map function
     * @param {bool} dataOptions.removeMeta - allows removing meta before calling mapFun
     * @param {boolean} dataOptions.forceClones - forcing the return of cloned objects to your map object
     * @param {string} dataOptions.forceCloneMethod - Allows overriding the default or collection specified cloning method.
     * @returns {Resultset} A resultset with data in the format [{left: leftObj, right: rightObj}]
     * @memberof Resultset
     * @example
     * var db = new loki('sandbox.db');
     *
     * var products = db.addCollection('products');
     * var orders = db.addCollection('orders');
     *
     * products.insert({ productId: "100234", name: "flywheel energy storage", unitCost: 19999.99 });
     * products.insert({ productId: "140491", name: "300F super capacitor", unitCost: 129.99 });
     * products.insert({ productId: "271941", name: "fuel cell", unitCost: 3999.99 });
     * products.insert({ productId: "174592", name: "390V 3AH lithium bank", unitCost: 4999.99 });
     *
     * orders.insert({ orderDate : new Date("12/1/2017").getTime(), prodId: "174592", qty: 2, customerId: 2 });
     * orders.insert({ orderDate : new Date("4/15/2016").getTime(), prodId: "271941", qty: 1, customerId: 1 });
     * orders.insert({ orderDate : new Date("3/12/2017").getTime(), prodId: "140491", qty: 4, customerId: 4 });
     * orders.insert({ orderDate : new Date("7/31/2017").getTime(), prodId: "100234", qty: 7, customerId: 3 });
     * orders.insert({ orderDate : new Date("8/3/2016").getTime(), prodId: "174592", qty: 3, customerId: 5 });
     *
     * var mapfun = function(left, right) {
     *   return {
     *     orderId: left.$loki,
     *     orderDate: new Date(left.orderDate) + '',
     *     customerId: left.customerId,
     *     qty: left.qty,
     *     productId: left.prodId,
     *     prodName: right.name,
     *     prodCost: right.unitCost,
     *     orderTotal: +((right.unitCost * left.qty).toFixed(2))
     *   };
     * };
     *
     * // join orders with relevant product info via eqJoin
     * var orderSummary = orders.chain().eqJoin(products, "prodId", "productId", mapfun).data();
     *
     * console.log(orderSummary);
     */
    Resultset.prototype.eqJoin = function (joinData, leftJoinKey, rightJoinKey, mapFun, dataOptions) {

      var leftData = [],
        leftDataLength,
        rightData = [],
        rightDataLength,
        key,
        result = [],
        leftKeyisFunction = typeof leftJoinKey === 'function',
        rightKeyisFunction = typeof rightJoinKey === 'function',
        joinMap = {};

      //get the left data
      leftData = this.data(dataOptions);
      leftDataLength = leftData.length;

      //get the right data
      if (joinData instanceof Collection) {
        rightData = joinData.chain().data(dataOptions);
      } else if (joinData instanceof Resultset) {
        rightData = joinData.data(dataOptions);
      } else if (Array.isArray(joinData)) {
        rightData = joinData;
      } else {
        throw new TypeError('joinData needs to be an array or result set');
      }
      rightDataLength = rightData.length;

      //construct a lookup table

      for (var i = 0; i < rightDataLength; i++) {
        key = rightKeyisFunction ? rightJoinKey(rightData[i]) : rightData[i][rightJoinKey];
        joinMap[key] = rightData[i];
      }

      if (!mapFun) {
        mapFun = function (left, right) {
          return {
            left: left,
            right: right
          };
        };
      }

      //Run map function over each object in the resultset
      for (var j = 0; j < leftDataLength; j++) {
        key = leftKeyisFunction ? leftJoinKey(leftData[j]) : leftData[j][leftJoinKey];
        result.push(mapFun(leftData[j], joinMap[key] || {}));
      }

      //return return a new resultset with no filters
      this.collection = new Collection('joinData');
      this.collection.insert(result);
      this.filteredrows = [];
      this.filterInitialized = false;

      return this;
    };

    /**
     * Applies a map function into a new collection for further chaining.
     * @param {function} mapFun - javascript map function
     * @param {object=} dataOptions - options to data() before input to your map function
     * @param {bool} dataOptions.removeMeta - allows removing meta before calling mapFun
     * @param {boolean} dataOptions.forceClones - forcing the return of cloned objects to your map object
     * @param {string} dataOptions.forceCloneMethod - Allows overriding the default or collection specified cloning method.
     * @memberof Resultset
     * @example
     * var orders.chain().find({ productId: 32 }).map(function(obj) {
     *   return {
     *     orderId: $loki,
     *     productId: productId,
     *     quantity: qty
     *   };
     * });
     */
    Resultset.prototype.map = function (mapFun, dataOptions) {
      var data = this.data(dataOptions).map(mapFun);
      //return return a new resultset with no filters
      this.collection = new Collection('mappedData');
      this.collection.insert(data);
      this.filteredrows = [];
      this.filterInitialized = false;

      return this;
    };

    /**
     * DynamicView class is a versatile 'live' view class which can have filters and sorts applied.
     *    Collection.addDynamicView(name) instantiates this DynamicView object and notifies it
     *    whenever documents are add/updated/removed so it can remain up-to-date. (chainable)
     *
     * @example
     * var mydv = mycollection.addDynamicView('test');  // default is non-persistent
     * mydv.applyFind({ 'doors' : 4 });
     * mydv.applyWhere(function(obj) { return obj.name === 'Toyota'; });
     * var results = mydv.data();
     *
     * @constructor DynamicView
     * @implements LokiEventEmitter
     * @param {Collection} collection - A reference to the collection to work against
     * @param {string} name - The name of this dynamic view
     * @param {object=} options - (Optional) Pass in object with 'persistent' and/or 'sortPriority' options.
     * @param {boolean} [options.persistent=false] - indicates if view is to main internal results array in 'resultdata'
     * @param {string} [options.sortPriority='passive'] - 'passive' (sorts performed on call to data) or 'active' (after updates)
     * @param {number} options.minRebuildInterval - minimum rebuild interval (need clarification to docs here)
     * @see {@link Collection#addDynamicView} to construct instances of DynamicView
     */
    function DynamicView(collection, name, options) {
      this.collection = collection;
      this.name = name;
      this.rebuildPending = false;
      this.options = options || {};

      if (!this.options.hasOwnProperty('persistent')) {
        this.options.persistent = false;
      }

      // 'persistentSortPriority':
      // 'passive' will defer the sort phase until they call data(). (most efficient overall)
      // 'active' will sort async whenever next idle. (prioritizes read speeds)
      if (!this.options.hasOwnProperty('sortPriority')) {
        this.options.sortPriority = 'passive';
      }

      if (!this.options.hasOwnProperty('minRebuildInterval')) {
        this.options.minRebuildInterval = 1;
      }

      this.resultset = new Resultset(collection);
      this.resultdata = [];
      this.resultsdirty = false;

      this.cachedresultset = null;

      // keep ordered filter pipeline
      this.filterPipeline = [];
      if (!this.collection.disableFreeze) {
        Object.freeze(this.filterPipeline);
      }

      // sorting member variables
      // we only support one active search, applied using applySort() or applySimpleSort()
      this.sortFunction = null;
      this.sortCriteria = null;
      this.sortCriteriaSimple = null;
      this.sortDirty = false;

      // for now just have 1 event for when we finally rebuilt lazy view
      // once we refactor transactions, i will tie in certain transactional events

      this.events = {
        'rebuild': [],
        'filter': [],
        'sort': []
      };
    }

    DynamicView.prototype = new LokiEventEmitter();
    DynamicView.prototype.constructor = DynamicView;

    /**
     * getSort() - used to get the current sort
     *
     * @returns function (sortFunction) or array (sortCriteria) or object (sortCriteriaSimple)
     */
    DynamicView.prototype.getSort = function () {
      return this.sortFunction || this.sortCriteria || this.sortCriteriaSimple;
    };

    /**
     * rematerialize() - internally used immediately after deserialization (loading)
     *    This will clear out and reapply filterPipeline ops, recreating the view.
     *    Since where filters do not persist correctly, this method allows
     *    restoring the view to state where user can re-apply those where filters.
     *
     * @param {Object=} options - (Optional) allows specification of 'removeWhereFilters' option
     * @returns {DynamicView} This dynamic view for further chained ops.
     * @memberof DynamicView
     * @fires DynamicView.rebuild
     */
    DynamicView.prototype.rematerialize = function (options) {
      var fpl,
        fpi,
        idx;

      options = options || {};

      this.resultdata = [];
      this.resultsdirty = true;
      this.resultset = new Resultset(this.collection);

      if (this.sortFunction || this.sortCriteria || this.sortCriteriaSimple) {
        this.sortDirty = true;
      }

      var wasFrozen = Object.isFrozen(this.filterPipeline);
      if (options.hasOwnProperty('removeWhereFilters')) {
        // for each view see if it had any where filters applied... since they don't
        // serialize those functions lets remove those invalid filters
        if (wasFrozen) {
          this.filterPipeline = this.filterPipeline.slice();
        }
        fpl = this.filterPipeline.length;
        fpi = fpl;
        while (fpi--) {
          if (this.filterPipeline[fpi].type === 'where') {
            if (fpi !== this.filterPipeline.length - 1) {
              this.filterPipeline[fpi] = this.filterPipeline[this.filterPipeline.length - 1];
            }
            this.filterPipeline.length--;
          }
        }
      }

      // back up old filter pipeline, clear filter pipeline, and reapply pipeline ops
      var ofp = this.filterPipeline;
      this.filterPipeline = [];

      // now re-apply 'find' filterPipeline ops
      fpl = ofp.length;
      for (idx = 0; idx < fpl; idx++) {
        this.applyFind(ofp[idx].val, ofp[idx].uid);
      }
      if (wasFrozen) {
        Object.freeze(this.filterPipeline);
      }

      // during creation of unit tests, i will remove this forced refresh and leave lazy
      this.data();

      // emit rebuild event in case user wants to be notified
      this.emit('rebuild', this);

      return this;
    };

    /**
     * branchResultset() - Makes a copy of the internal resultset for branched queries.
     *    Unlike this dynamic view, the branched resultset will not be 'live' updated,
     *    so your branched query should be immediately resolved and not held for future evaluation.
     *
     * @param {(string|array=)} transform - Optional name of collection transform, or an array of transform steps
     * @param {object=} parameters - optional parameters (if optional transform requires them)
     * @returns {Resultset} A copy of the internal resultset for branched queries.
     * @memberof DynamicView
     * @example
     * var db = new loki('test');
     * var coll = db.addCollection('mydocs');
     * var dv = coll.addDynamicView('myview');
     * var tx = [
     *   {
     *     type: 'offset',
     *     value: '[%lktxp]pageStart'
     *   },
     *   {
     *     type: 'limit',
     *     value: '[%lktxp]pageSize'
     *   }
     * ];
     * coll.addTransform('viewPaging', tx);
     *
     * // add some records
     *
     * var results = dv.branchResultset('viewPaging', { pageStart: 10, pageSize: 10 }).data();
     */
    DynamicView.prototype.branchResultset = function (transform, parameters) {
      var rs = this.resultset.branch();

      if (typeof transform === 'undefined') {
        return rs;
      }

      return rs.transform(transform, parameters);
    };

    /**
     * toJSON() - Override of toJSON to avoid circular references
     *
     */
    DynamicView.prototype.toJSON = function () {
      var copy = new DynamicView(this.collection, this.name, this.options);
      copy.resultset = this.resultset;
      copy.resultdata = []; // let's not save data (copy) to minimize size
      copy.resultsdirty = true;
      copy.filterPipeline = this.filterPipeline;
      copy.sortFunction = this.sortFunction;
      copy.sortCriteria = this.sortCriteria;
      copy.sortCriteriaSimple = this.sortCriteriaSimple || null;
      copy.sortDirty = this.sortDirty;

      // avoid circular reference, reapply in db.loadJSON()
      copy.collection = null;

      return copy;
    };

    /**
     * removeFilters() - Used to clear pipeline and reset dynamic view to initial state.
     *     Existing options should be retained.
     * @param {object=} options - configure removeFilter behavior
     * @param {boolean=} options.queueSortPhase - (default: false) if true we will async rebuild view (maybe set default to true in future?)
     * @memberof DynamicView
     */
    DynamicView.prototype.removeFilters = function (options) {
      options = options || {};

      this.rebuildPending = false;
      this.resultset.reset();
      this.resultdata = [];
      this.resultsdirty = true;

      this.cachedresultset = null;

      var wasFrozen = Object.isFrozen(this.filterPipeline);
      var filterChanged = this.filterPipeline.length > 0;
      // keep ordered filter pipeline
      this.filterPipeline = [];
      if (wasFrozen) {
        Object.freeze(this.filterPipeline);
      }

      // sorting member variables
      // we only support one active search, applied using applySort() or applySimpleSort()
      this.sortFunction = null;
      this.sortCriteria = null;
      this.sortCriteriaSimple = null;
      this.sortDirty = false;

      if (options.queueSortPhase === true) {
        this.queueSortPhase();
      }

      if (filterChanged) {
        this.emit('filter');
      }
    };

    /**
     * applySort() - Used to apply a sort to the dynamic view
     * @example
     * dv.applySort(function(obj1, obj2) {
     *   if (obj1.name === obj2.name) return 0;
     *   if (obj1.name > obj2.name) return 1;
     *   if (obj1.name < obj2.name) return -1;
     * });
     *
     * @param {function} comparefun - a javascript compare function used for sorting
     * @returns {DynamicView} this DynamicView object, for further chain ops.
     * @memberof DynamicView
     */
    DynamicView.prototype.applySort = function (comparefun) {
      this.sortFunction = comparefun;
      this.sortCriteria = null;
      this.sortCriteriaSimple = null;

      this.queueSortPhase();
      this.emit('sort');

      return this;
    };

    /**
     * applySimpleSort() - Used to specify a property used for view translation.
     * @example
     * dv.applySimpleSort("name");
     *
     * @param {string} propname - Name of property by which to sort.
     * @param {object|boolean=} options - boolean for sort descending or options object
     * @param {boolean} [options.desc=false] - whether we should sort descending.
     * @param {boolean} [options.disableIndexIntersect=false] - whether we should explicity not use array intersection.
     * @param {boolean} [options.forceIndexIntersect=false] - force array intersection (if binary index exists).
     * @param {boolean} [options.useJavascriptSorting=false] - whether results are sorted via basic javascript sort.
     * @returns {DynamicView} this DynamicView object, for further chain ops.
     * @memberof DynamicView
     */
    DynamicView.prototype.applySimpleSort = function (propname, options) {
      this.sortCriteriaSimple = { propname: propname, options: options || false };
      if (!this.collection.disableFreeze) {
        deepFreeze(this.sortCriteriaSimple);
      }
      this.sortCriteria = null;
      this.sortFunction = null;

      this.queueSortPhase();
      this.emit('sort');

      return this;
    };

    /**
     * applySortCriteria() - Allows sorting a resultset based on multiple columns.
     * @example
     * // to sort by age and then name (both ascending)
     * dv.applySortCriteria(['age', 'name']);
     * // to sort by age (ascending) and then by name (descending)
     * dv.applySortCriteria(['age', ['name', true]);
     * // to sort by age (descending) and then by name (descending)
     * dv.applySortCriteria(['age', true], ['name', true]);
     *
     * @param {array} properties - array of property names or subarray of [propertyname, isdesc] used evaluate sort order
     * @returns {DynamicView} Reference to this DynamicView, sorted, for future chain operations.
     * @memberof DynamicView
     */
    DynamicView.prototype.applySortCriteria = function (criteria) {
      this.sortCriteria = criteria;
      if (!this.collection.disableFreeze) {
        deepFreeze(this.sortCriteria);
      }
      this.sortCriteriaSimple = null;
      this.sortFunction = null;

      this.queueSortPhase();
      this.emit('sort');
      return this;
    };

    /**
     * startTransaction() - marks the beginning of a transaction.
     *
     * @returns {DynamicView} this DynamicView object, for further chain ops.
     */
    DynamicView.prototype.startTransaction = function () {
      this.cachedresultset = this.resultset.copy();

      return this;
    };

    /**
     * commit() - commits a transaction.
     *
     * @returns {DynamicView} this DynamicView object, for further chain ops.
     */
    DynamicView.prototype.commit = function () {
      this.cachedresultset = null;

      return this;
    };

    /**
     * rollback() - rolls back a transaction.
     *
     * @returns {DynamicView} this DynamicView object, for further chain ops.
     */
    DynamicView.prototype.rollback = function () {
      this.resultset = this.cachedresultset;

      if (this.options.persistent) {
        // for now just rebuild the persistent dynamic view data in this worst case scenario
        // (a persistent view utilizing transactions which get rolled back), we already know the filter so not too bad.
        this.resultdata = this.resultset.data();

        this.emit('rebuild', this);
      }

      return this;
    };


    /**
     * Implementation detail.
     * _indexOfFilterWithId() - Find the index of a filter in the pipeline, by that filter's ID.
     *
     * @param {(string|number)} uid - The unique ID of the filter.
     * @returns {number}: index of the referenced filter in the pipeline; -1 if not found.
     */
    DynamicView.prototype._indexOfFilterWithId = function (uid) {
      if (typeof uid === 'string' || typeof uid === 'number') {
        for (var idx = 0, len = this.filterPipeline.length; idx < len; idx += 1) {
          if (uid === this.filterPipeline[idx].uid) {
            return idx;
          }
        }
      }
      return -1;
    };

    /**
     * Implementation detail.
     * _addFilter() - Add the filter object to the end of view's filter pipeline and apply the filter to the resultset.
     *
     * @param {object} filter - The filter object. Refer to applyFilter() for extra details.
     */
    DynamicView.prototype._addFilter = function (filter) {
      var wasFrozen = Object.isFrozen(this.filterPipeline);
      if (wasFrozen) {
        this.filterPipeline = this.filterPipeline.slice();
      }
      if (!this.collection.disableFreeze) {
        deepFreeze(filter);
      }
      this.filterPipeline.push(filter);
      if (wasFrozen) {
        Object.freeze(this.filterPipeline);
      }
      this.resultset[filter.type](filter.val);
    };

    /**
     * reapplyFilters() - Reapply all the filters in the current pipeline.
     *
     * @returns {DynamicView} this DynamicView object, for further chain ops.
     */
    DynamicView.prototype.reapplyFilters = function () {
      this.resultset.reset();

      this.cachedresultset = null;
      if (this.options.persistent) {
        this.resultdata = [];
        this.resultsdirty = true;
      }

      var filters = this.filterPipeline;
      var wasFrozen = Object.isFrozen(filters);
      this.filterPipeline = [];

      for (var idx = 0, len = filters.length; idx < len; idx += 1) {
        this._addFilter(filters[idx]);
      }
      if (wasFrozen) {
        Object.freeze(this.filterPipeline);
      }

      if (this.sortFunction || this.sortCriteria || this.sortCriteriaSimple) {
        this.queueSortPhase();
      } else {
        this.queueRebuildEvent();
      }
      this.emit('filter');
      return this;
    };

    /**
     * applyFilter() - Adds or updates a filter in the DynamicView filter pipeline
     *
     * @param {object} filter - A filter object to add to the pipeline.
     *    The object is in the format { 'type': filter_type, 'val', filter_param, 'uid', optional_filter_id }
     * @returns {DynamicView} this DynamicView object, for further chain ops.
     * @memberof DynamicView
     */
    DynamicView.prototype.applyFilter = function (filter) {
      var idx = this._indexOfFilterWithId(filter.uid);
      if (idx >= 0) {
        var wasFrozen = Object.isFrozen(this.filterPipeline);
        if (wasFrozen) {
          this.filterPipeline = this.filterPipeline.slice();
        }
        this.filterPipeline[idx] = filter;
        if (wasFrozen) {
          freeze(filter);
          Object.freeze(this.filterPipeline);
        }
        return this.reapplyFilters();
      }

      this.cachedresultset = null;
      if (this.options.persistent) {
        this.resultdata = [];
        this.resultsdirty = true;
      }

      this._addFilter(filter);

      if (this.sortFunction || this.sortCriteria || this.sortCriteriaSimple) {
        this.queueSortPhase();
      } else {
        this.queueRebuildEvent();
      }

      this.emit('filter');
      return this;
    };

    /**
     * applyFind() - Adds or updates a mongo-style query option in the DynamicView filter pipeline
     *
     * @param {object} query - A mongo-style query object to apply to pipeline
     * @param {(string|number)=} uid - Optional: The unique ID of this filter, to reference it in the future.
     * @returns {DynamicView} this DynamicView object, for further chain ops.
     * @memberof DynamicView
     */
    DynamicView.prototype.applyFind = function (query, uid) {
      this.applyFilter({
        type: 'find',
        val: query,
        uid: uid
      });
      return this;
    };

    /**
     * applyWhere() - Adds or updates a javascript filter function in the DynamicView filter pipeline
     *
     * @param {function} fun - A javascript filter function to apply to pipeline
     * @param {(string|number)=} uid - Optional: The unique ID of this filter, to reference it in the future.
     * @returns {DynamicView} this DynamicView object, for further chain ops.
     * @memberof DynamicView
     */
    DynamicView.prototype.applyWhere = function (fun, uid) {
      this.applyFilter({
        type: 'where',
        val: fun,
        uid: uid
      });
      return this;
    };

    /**
     * removeFilter() - Remove the specified filter from the DynamicView filter pipeline
     *
     * @param {(string|number)} uid - The unique ID of the filter to be removed.
     * @returns {DynamicView} this DynamicView object, for further chain ops.
     * @memberof DynamicView
     */
    DynamicView.prototype.removeFilter = function (uid) {
      var idx = this._indexOfFilterWithId(uid);
      if (idx < 0) {
        throw new Error("Dynamic view does not contain a filter with ID: " + uid);
      }
      var wasFrozen = Object.isFrozen(this.filterPipeline);
      if (wasFrozen) {
        this.filterPipeline = this.filterPipeline.slice();
      }
      this.filterPipeline.splice(idx, 1);
      if (wasFrozen) {
        Object.freeze(this.filterPipeline);
      }
      this.reapplyFilters();
      return this;
    };

    /**
     * count() - returns the number of documents representing the current DynamicView contents.
     *
     * @returns {number} The number of documents representing the current DynamicView contents.
     * @memberof DynamicView
     */
    DynamicView.prototype.count = function () {
      // in order to be accurate we will pay the minimum cost (and not alter dv state management)
      // recurring resultset data resolutions should know internally its already up to date.
      // for persistent data this will not update resultdata nor fire rebuild event.
      if (this.resultsdirty) {
        this.resultdata = this.resultset.data();
      }

      return this.resultset.count();
    };

    /**
     * data() - resolves and pending filtering and sorting, then returns document array as result.
     *
     * @param {object=} options - optional parameters to pass to resultset.data() if non-persistent
     * @param {boolean} options.forceClones - Allows forcing the return of cloned objects even when
     *        the collection is not configured for clone object.
     * @param {string} options.forceCloneMethod - Allows overriding the default or collection specified cloning method.
     *        Possible values include 'parse-stringify', 'jquery-extend-deep', 'shallow', 'shallow-assign'
     * @param {bool} options.removeMeta - Will force clones and strip $loki and meta properties from documents
     * @returns {array} An array of documents representing the current DynamicView contents.
     * @memberof DynamicView
     */
    DynamicView.prototype.data = function (options) {
      // using final sort phase as 'catch all' for a few use cases which require full rebuild
      if (this.sortDirty || this.resultsdirty) {
        this.performSortPhase({
          suppressRebuildEvent: true
        });
      }
      return (this.options.persistent) ? (this.resultdata) : (this.resultset.data(options));
    };

    /**
     * queueRebuildEvent() - When the view is not sorted we may still wish to be notified of rebuild events.
     *     This event will throttle and queue a single rebuild event when batches of updates affect the view.
     */
    DynamicView.prototype.queueRebuildEvent = function () {
      if (this.rebuildPending) {
        return;
      }
      this.rebuildPending = true;

      var self = this;
      setTimeout(function () {
        if (self.rebuildPending) {
          self.rebuildPending = false;
          self.emit('rebuild', self);
        }
      }, this.options.minRebuildInterval);
    };

    /**
     * queueSortPhase : If the view is sorted we will throttle sorting to either :
     *    (1) passive - when the user calls data(), or
     *    (2) active - once they stop updating and yield js thread control
     */
    DynamicView.prototype.queueSortPhase = function () {
      // already queued? exit without queuing again
      if (this.sortDirty) {
        return;
      }
      this.sortDirty = true;

      var self = this;
      if (this.options.sortPriority === "active") {
        // active sorting... once they are done and yield js thread, run async performSortPhase()
        setTimeout(function () {
          self.performSortPhase();
        }, this.options.minRebuildInterval);
      } else {
        // must be passive sorting... since not calling performSortPhase (until data call), lets use queueRebuildEvent to
        // potentially notify user that data has changed.
        this.queueRebuildEvent();
      }
    };

    /**
     * performSortPhase() - invoked synchronously or asynchronously to perform final sort phase (if needed)
     *
     */
    DynamicView.prototype.performSortPhase = function (options) {
      // async call to this may have been pre-empted by synchronous call to data before async could fire
      if (!this.sortDirty && !this.resultsdirty) {
        return;
      }

      options = options || {};

      if (this.sortDirty) {
        if (this.sortFunction) {
          this.resultset.sort(this.sortFunction);
        } else if (this.sortCriteria) {
          this.resultset.compoundsort(this.sortCriteria);
        } else if (this.sortCriteriaSimple) {
          this.resultset.simplesort(this.sortCriteriaSimple.propname, this.sortCriteriaSimple.options);
        }

        this.sortDirty = false;
      }

      if (this.options.persistent) {
        // persistent view, rebuild local resultdata array
        this.resultdata = this.resultset.data();
        this.resultsdirty = false;
      }

      if (!options.suppressRebuildEvent) {
        this.emit('rebuild', this);
      }
    };

    /**
     * evaluateDocument() - internal method for (re)evaluating document inclusion.
     *    Called by : collection.insert() and collection.update().
     *
     * @param {int} objIndex - index of document to (re)run through filter pipeline.
     * @param {bool} isNew - true if the document was just added to the collection.
     */
    DynamicView.prototype.evaluateDocument = function (objIndex, isNew) {
      // if no filter applied yet, the result 'set' should remain 'everything'
      if (!this.resultset.filterInitialized) {
        if (this.options.persistent) {
          this.resultdata = this.resultset.data();
        }
        // need to re-sort to sort new document
        if (this.sortFunction || this.sortCriteria || this.sortCriteriaSimple) {
          this.queueSortPhase();
        } else {
          this.queueRebuildEvent();
        }
        return;
      }

      var ofr = this.resultset.filteredrows;
      var oldPos = (isNew) ? (-1) : (ofr.indexOf(+objIndex));
      var oldlen = ofr.length;

      // creating a 1-element resultset to run filter chain ops on to see if that doc passes filters;
      // mostly efficient algorithm, slight stack overhead price (this function is called on inserts and updates)
      var evalResultset = new Resultset(this.collection);
      evalResultset.filteredrows = [objIndex];
      evalResultset.filterInitialized = true;
      var filter;
      for (var idx = 0, len = this.filterPipeline.length; idx < len; idx++) {
        filter = this.filterPipeline[idx];
        evalResultset[filter.type](filter.val);
      }

      // not a true position, but -1 if not pass our filter(s), 0 if passed filter(s)
      var newPos = (evalResultset.filteredrows.length === 0) ? -1 : 0;

      // wasn't in old, shouldn't be now... do nothing
      if (oldPos === -1 && newPos === -1) return;

      // wasn't in resultset, should be now... add
      if (oldPos === -1 && newPos !== -1) {
        ofr.push(objIndex);

        if (this.options.persistent) {
          this.resultdata.push(this.collection.data[objIndex]);
        }

        // need to re-sort to sort new document
        if (this.sortFunction || this.sortCriteria || this.sortCriteriaSimple) {
          this.queueSortPhase();
        } else {
          this.queueRebuildEvent();
        }

        return;
      }

      // was in resultset, shouldn't be now... delete
      if (oldPos !== -1 && newPos === -1) {
        if (oldPos < oldlen - 1) {
          ofr.splice(oldPos, 1);

          if (this.options.persistent) {
            this.resultdata.splice(oldPos, 1);
          }
        } else {
          ofr.length = oldlen - 1;

          if (this.options.persistent) {
            this.resultdata.length = oldlen - 1;
          }
        }

        // in case changes to data altered a sort column
        if (this.sortFunction || this.sortCriteria || this.sortCriteriaSimple) {
          this.queueSortPhase();
        } else {
          this.queueRebuildEvent();
        }

        return;
      }

      // was in resultset, should still be now... (update persistent only?)
      if (oldPos !== -1 && newPos !== -1) {
        if (this.options.persistent) {
          // in case document changed, replace persistent view data with the latest collection.data document
          this.resultdata[oldPos] = this.collection.data[objIndex];
        }

        // in case changes to data altered a sort column
        if (this.sortFunction || this.sortCriteria || this.sortCriteriaSimple) {
          this.queueSortPhase();
        } else {
          this.queueRebuildEvent();
        }

        return;
      }
    };

    /**
     * removeDocument() - internal function called on collection.delete()
     * @param {number|number[]} objIndex - index of document to (re)run through filter pipeline.
     */
    DynamicView.prototype.removeDocument = function (objIndex) {
      var idx, rmidx, rmlen, rxo = {}, fxo = {};
      var adjels = [];
      var drs = this.resultset;
      var fr = this.resultset.filteredrows;
      var frlen = fr.length;

      // if no filter applied yet, the result 'set' should remain 'everything'
      if (!this.resultset.filterInitialized) {
        if (this.options.persistent) {
          this.resultdata = this.resultset.data();
        }
        // in case changes to data altered a sort column
        if (this.sortFunction || this.sortCriteria || this.sortCriteriaSimple) {
          this.queueSortPhase();
        } else {
          this.queueRebuildEvent();
        }
        return;
      }

      // if passed single index, wrap in array
      if (!Array.isArray(objIndex)) {
        objIndex = [objIndex];
      }

      rmlen = objIndex.length;
      // create intersection object of data indices to remove
      for (rmidx = 0; rmidx < rmlen; rmidx++) {
        rxo[objIndex[rmidx]] = true;
      }

      // pivot remove data indices into remove filteredrows indices and dump in hashobject
      for (idx = 0; idx < frlen; idx++) {
        if (rxo[fr[idx]]) fxo[idx] = true;
      }

      // if any of the removed items were in our filteredrows...
      if (Object.keys(fxo).length > 0) {
        // remove them from filtered rows
        this.resultset.filteredrows = this.resultset.filteredrows.filter(function (di, idx) { return !fxo[idx]; });
        // if persistent...
        if (this.options.persistent) {
          // remove from resultdata
          this.resultdata = this.resultdata.filter(function (obj, idx) { return !fxo[idx]; });
        }

        // and queue sorts
        if (this.sortFunction || this.sortCriteria || this.sortCriteriaSimple) {
          this.queueSortPhase();
        } else {
          this.queueRebuildEvent();
        }
      }

      // to remove holes, we need to 'shift down' indices, this filter function finds number of positions to shift
      var filt = function (idx) { return function (di) { return di < drs.filteredrows[idx]; }; };

      frlen = drs.filteredrows.length;
      for (idx = 0; idx < frlen; idx++) {
        // grab subset of removed elements where data index is less than current filtered row data index;
        // use this to determine how many positions iterated remaining data index needs to be 'shifted down'
        adjels = objIndex.filter(filt(idx));
        drs.filteredrows[idx] -= adjels.length;
      }
    };

    /**
     * mapReduce() - data transformation via user supplied functions
     *
     * @param {function} mapFunction - this function accepts a single document for you to transform and return
     * @param {function} reduceFunction - this function accepts many (array of map outputs) and returns single value
     * @returns The output of your reduceFunction
     * @memberof DynamicView
     */
    DynamicView.prototype.mapReduce = function (mapFunction, reduceFunction) {
      try {
        return reduceFunction(this.data().map(mapFunction));
      } catch (err) {
        throw err;
      }
    };


    /**
     * Collection class that handles documents of same type
     * @constructor Collection
     * @implements LokiEventEmitter
     * @param {string} name - collection name
     * @param {(array|object)=} options - (optional) array of property names to be indicized OR a configuration object
     * @param {array=} [options.unique=[]] - array of property names to define unique constraints for
     * @param {array=} [options.exact=[]] - array of property names to define exact constraints for
     * @param {array=} [options.indices=[]] - array property names to define binary indexes for
     * @param {boolean} [options.adaptiveBinaryIndices=true] - collection indices will be actively rebuilt rather than lazily
     * @param {boolean} [options.asyncListeners=false] - whether listeners are invoked asynchronously
     * @param {boolean} [options.disableMeta=false] - set to true to disable meta property on documents
     * @param {boolean} [options.disableChangesApi=true] - set to false to enable Changes API
     * @param {boolean} [options.disableDeltaChangesApi=true] - set to false to enable Delta Changes API (requires Changes API, forces cloning)
     * @param {boolean} [options.autoupdate=false] - use Object.observe to update objects automatically
     * @param {boolean} [options.clone=false] - specify whether inserts and queries clone to/from user
     * @param {boolean} [options.serializableIndices=true[]] - converts date values on binary indexed properties to epoch time
     * @param {boolean} [options.disableFreeze=true] - when false all docs are frozen
     * @param {string} [options.cloneMethod='parse-stringify'] - 'parse-stringify', 'jquery-extend-deep', 'shallow', 'shallow-assign'
     * @param {int=} options.ttl - age of document (in ms.) before document is considered aged/stale.
     * @param {int=} options.ttlInterval - time interval for clearing out 'aged' documents; not set by default.
     * @see {@link Loki#addCollection} for normal creation of collections
     */
    function Collection(name, options) {
      // the name of the collection

      this.name = name;
      // the data held by the collection
      this.data = [];
      this.idIndex = null; // position->$loki index (built lazily)
      this.binaryIndices = {}; // user defined indexes
      this.constraints = {
        unique: {},
        exact: {}
      };

      // unique contraints contain duplicate object references, so they are not persisted.
      // we will keep track of properties which have unique contraint applied here, and regenerate lazily
      this.uniqueNames = [];

      // transforms will be used to store frequently used query chains as a series of steps
      // which itself can be stored along with the database.
      this.transforms = {};

      // the object type of the collection
      this.objType = name;

      // in autosave scenarios we will use collection level dirty flags to determine whether save is needed.
      // currently, if any collection is dirty we will autosave the whole database if autosave is configured.
      // defaulting to true since this is called from addCollection and adding a collection should trigger save
      this.dirty = true;

      // private holders for cached data
      this.cachedIndex = null;
      this.cachedBinaryIndex = null;
      this.cachedData = null;
      var self = this;

      /* OPTIONS */
      options = options || {};

      // exact match and unique constraints
      if (options.hasOwnProperty('unique')) {
        if (!Array.isArray(options.unique)) {
          options.unique = [options.unique];
        }
        // save names; actual index is built lazily
        options.unique.forEach(function (prop) {
          self.uniqueNames.push(prop);
        });
      }

      if (options.hasOwnProperty('exact')) {
        options.exact.forEach(function (prop) {
          self.constraints.exact[prop] = new ExactIndex(prop);
        });
      }

      // if set to true we will optimally keep indices 'fresh' during insert/update/remove ops (never dirty/never needs rebuild)
      // if you frequently intersperse insert/update/remove ops between find ops this will likely be significantly faster option.
      this.adaptiveBinaryIndices = options.hasOwnProperty('adaptiveBinaryIndices') ? options.adaptiveBinaryIndices : true;

      // is collection transactional
      this.transactional = options.hasOwnProperty('transactional') ? options.transactional : false;

      // options to clone objects when inserting them
      this.cloneObjects = options.hasOwnProperty('clone') ? options.clone : false;

      // default clone method (if enabled) is parse-stringify
      this.cloneMethod = options.hasOwnProperty('cloneMethod') ? options.cloneMethod : "parse-stringify";

      // option to make event listeners async, default is sync
      this.asyncListeners = options.hasOwnProperty('asyncListeners') ? options.asyncListeners : false;

      // if set to true we will not maintain a meta property for a document
      this.disableMeta = options.hasOwnProperty('disableMeta') ? options.disableMeta : false;

      // disable track changes
      this.disableChangesApi = options.hasOwnProperty('disableChangesApi') ? options.disableChangesApi : true;

      // disable delta update object style on changes
      this.disableDeltaChangesApi = options.hasOwnProperty('disableDeltaChangesApi') ? options.disableDeltaChangesApi : true;
      if (this.disableChangesApi) { this.disableDeltaChangesApi = true; }

      // option to observe objects and update them automatically, ignored if Object.observe is not supported
      this.autoupdate = options.hasOwnProperty('autoupdate') ? options.autoupdate : false;

      // by default, if you insert a document into a collection with binary indices, if those indexed properties contain
      // a DateTime we will convert to epoch time format so that (across serializations) its value position will be the
      // same 'after' serialization as it was 'before'.
      this.serializableIndices = options.hasOwnProperty('serializableIndices') ? options.serializableIndices : true;

      // option to deep freeze all documents
      this.disableFreeze = options.hasOwnProperty('disableFreeze') ? options.disableFreeze : true;

      //option to activate a cleaner daemon - clears "aged" documents at set intervals.
      this.ttl = {
        age: null,
        ttlInterval: null,
        daemon: null
      };
      this.setTTL(options.ttl || -1, options.ttlInterval);

      // currentMaxId - change manually at your own peril!
      this.maxId = 0;

      this.DynamicViews = [];

      // events
      this.events = {
        'insert': [],
        'update': [],
        'pre-insert': [],
        'pre-update': [],
        'close': [],
        'flushbuffer': [],
        'error': [],
        'delete': [],
        'warning': []
      };

      // changes are tracked by collection and aggregated by the db
      this.changes = [];

      // lightweight changes tracking (loki IDs only) for optimized db saving
      this.dirtyIds = [];

      // initialize optional user-supplied indices array ['age', 'lname', 'zip']
      var indices = [];
      if (options && options.indices) {
        if (Object.prototype.toString.call(options.indices) === '[object Array]') {
          indices = options.indices;
        } else if (typeof options.indices === 'string') {
          indices = [options.indices];
        } else {
          throw new TypeError('Indices needs to be a string or an array of strings');
        }
      }

      for (var idx = 0; idx < indices.length; idx++) {
        this.ensureIndex(indices[idx]);
      }

      function observerCallback(changes) {

        var changedObjects = typeof Set === 'function' ? new Set() : [];

        if (!changedObjects.add)
          changedObjects.add = function (object) {
            if (this.indexOf(object) === -1)
              this.push(object);
            return this;
          };

        changes.forEach(function (change) {
          changedObjects.add(change.object);
        });

        changedObjects.forEach(function (object) {
          if (!hasOwnProperty.call(object, '$loki'))
            return self.removeAutoUpdateObserver(object);
          try {
            self.update(object);
          } catch (err) { }
        });
      }

      this.observerCallback = observerCallback;

      //Compare changed object (which is a forced clone) with existing object and return the delta
      function getChangeDelta(obj, old) {
        if (old) {
          return getObjectDelta(old, obj);
        }
        else {
          return JSON.parse(JSON.stringify(obj));
        }
      }

      this.getChangeDelta = getChangeDelta;

      function getObjectDelta(oldObject, newObject) {
        var propertyNames = newObject !== null && typeof newObject === 'object' ? Object.keys(newObject) : null;
        if (propertyNames && propertyNames.length && ['string', 'boolean', 'number'].indexOf(typeof (newObject)) < 0) {
          var delta = {};
          for (var i = 0; i < propertyNames.length; i++) {
            var propertyName = propertyNames[i];
            if (newObject.hasOwnProperty(propertyName)) {
              if (!oldObject.hasOwnProperty(propertyName) || self.uniqueNames.indexOf(propertyName) >= 0 || propertyName == '$loki' || propertyName == 'meta') {
                delta[propertyName] = newObject[propertyName];
              }
              else {
                var propertyDelta = getObjectDelta(oldObject[propertyName], newObject[propertyName]);
                if (typeof propertyDelta !== "undefined" && propertyDelta != {}) {
                  delta[propertyName] = propertyDelta;
                }
              }
            }
          }
          return Object.keys(delta).length === 0 ? undefined : delta;
        }
        else {
          return oldObject === newObject ? undefined : newObject;
        }
      }

      this.getObjectDelta = getObjectDelta;

      // clear all the changes
      function flushChanges() {
        self.changes = [];
      }

      this.getChanges = function () {
        return self.changes;
      };

      this.flushChanges = flushChanges;

      this.setChangesApi = function (enabled) {
        self.disableChangesApi = !enabled;
        if (!enabled) { self.disableDeltaChangesApi = false; }
      };

      this.on('delete', function deleteCallback(obj) {
        if (!self.disableChangesApi) {
          self.createChange(self.name, 'R', obj);
        }
      });

      this.on('warning', function (warning) {
        self.lokiConsoleWrapper.warn(warning);
      });
      // for de-serialization purposes
      flushChanges();
    }

    Collection.prototype = new LokiEventEmitter();
    Collection.prototype.contructor = Collection;

    /*
      * For ChangeAPI default to clone entire object, for delta changes create object with only differences (+ $loki and meta)
      */
    Collection.prototype.createChange = function (name, op, obj, old) {
      this.changes.push({
        name: name,
        operation: op,
        obj: op == 'U' && !this.disableDeltaChangesApi ? this.getChangeDelta(obj, old) : JSON.parse(JSON.stringify(obj))
      });
    };

    Collection.prototype.insertMeta = function (obj) {
      var len, idx;

      if (this.disableMeta || !obj) {
        return;
      }

      // if batch insert
      if (Array.isArray(obj)) {
        len = obj.length;

        for (idx = 0; idx < len; idx++) {
          if (!obj[idx].hasOwnProperty('meta')) {
            obj[idx].meta = {};
          }

          obj[idx].meta.created = (new Date()).getTime();
          obj[idx].meta.revision = 0;
        }

        return;
      }

      // single object
      if (!obj.meta) {
        obj.meta = {};
      }

      obj.meta.created = (new Date()).getTime();
      obj.meta.revision = 0;
    };

    Collection.prototype.updateMeta = function (obj) {
      if (this.disableMeta || !obj) {
        return obj;
      }
      if (!this.disableFreeze) {
        obj = unFreeze(obj);
        obj.meta = unFreeze(obj.meta);
      }
      obj.meta.updated = (new Date()).getTime();
      obj.meta.revision += 1;
      return obj;
    };

    Collection.prototype.createInsertChange = function (obj) {
      this.createChange(this.name, 'I', obj);
    };

    Collection.prototype.createUpdateChange = function (obj, old) {
      this.createChange(this.name, 'U', obj, old);
    };

    Collection.prototype.insertMetaWithChange = function (obj) {
      this.insertMeta(obj);
      this.createInsertChange(obj);
    };

    Collection.prototype.updateMetaWithChange = function (obj, old, objFrozen) {
      obj = this.updateMeta(obj, objFrozen);
      this.createUpdateChange(obj, old);
      return obj;
    };

    Collection.prototype.lokiConsoleWrapper = {
      log: function () { },
      warn: function () { },
      error: function () { },
    };

    Collection.prototype.addAutoUpdateObserver = function (object) {
      if (!this.autoupdate || typeof Object.observe !== 'function')
        return;

      Object.observe(object, this.observerCallback, ['add', 'update', 'delete', 'reconfigure', 'setPrototype']);
    };

    Collection.prototype.removeAutoUpdateObserver = function (object) {
      if (!this.autoupdate || typeof Object.observe !== 'function')
        return;

      Object.unobserve(object, this.observerCallback);
    };

    /**
     * Adds a named collection transform to the collection
     * @param {string} name - name to associate with transform
     * @param {array} transform - an array of transformation 'step' objects to save into the collection
     * @memberof Collection
     * @example
     * users.addTransform('progeny', [
     *   {
     *     type: 'find',
     *     value: {
     *       'age': {'$lte': 40}
     *     }
     *   }
     * ]);
     *
     * var results = users.chain('progeny').data();
     */
    Collection.prototype.addTransform = function (name, transform) {
      if (this.transforms.hasOwnProperty(name)) {
        throw new Error("a transform by that name already exists");
      }

      this.transforms[name] = transform;
    };

    /**
     * Retrieves a named transform from the collection.
     * @param {string} name - name of the transform to lookup.
     * @memberof Collection
     */
    Collection.prototype.getTransform = function (name) {
      return this.transforms[name];
    };

    /**
     * Updates a named collection transform to the collection
     * @param {string} name - name to associate with transform
     * @param {object} transform - a transformation object to save into collection
     * @memberof Collection
     */
    Collection.prototype.setTransform = function (name, transform) {
      this.transforms[name] = transform;
    };

    /**
     * Removes a named collection transform from the collection
     * @param {string} name - name of collection transform to remove
     * @memberof Collection
     */
    Collection.prototype.removeTransform = function (name) {
      delete this.transforms[name];
    };

    Collection.prototype.byExample = function (template) {
      var k, obj, query;
      query = [];
      for (k in template) {
        if (!template.hasOwnProperty(k)) continue;
        query.push((
          obj = {},
          obj[k] = template[k],
          obj
        ));
      }
      return {
        '$and': query
      };
    };

    Collection.prototype.findObject = function (template) {
      return this.findOne(this.byExample(template));
    };

    Collection.prototype.findObjects = function (template) {
      return this.find(this.byExample(template));
    };

    /*----------------------------+
    | TTL daemon                  |
    +----------------------------*/
    Collection.prototype.ttlDaemonFuncGen = function () {
      var collection = this;
      var age = this.ttl.age;
      return function ttlDaemon() {
        var now = Date.now();
        var toRemove = collection.chain().where(function daemonFilter(member) {
          var timestamp = member.meta.updated || member.meta.created;
          var diff = now - timestamp;
          return age < diff;
        });
        toRemove.remove();
      };
    };

    /**
     * Updates or applies collection TTL settings.
     * @param {int} age - age (in ms) to expire document from collection
     * @param {int} interval - time (in ms) to clear collection of aged documents.
     * @memberof Collection
     */
    Collection.prototype.setTTL = function (age, interval) {
      if (age < 0) {
        clearInterval(this.ttl.daemon);
      } else {
        this.ttl.age = age;
        this.ttl.ttlInterval = interval;
        this.ttl.daemon = setInterval(this.ttlDaemonFuncGen(), interval);
      }
    };

    /*----------------------------+
    | INDEXING                    |
    +----------------------------*/

    /**
     * create a row filter that covers all documents in the collection
     */
    Collection.prototype.prepareFullDocIndex = function () {
      var len = this.data.length;
      var indexes = new Array(len);
      for (var i = 0; i < len; i += 1) {
        indexes[i] = i;
      }
      return indexes;
    };

    /**
     * Will allow reconfiguring certain collection options.
     * @param {boolean} options.adaptiveBinaryIndices - collection indices will be actively rebuilt rather than lazily
     * @memberof Collection
     */
    Collection.prototype.configureOptions = function (options) {
      options = options || {};

      if (options.hasOwnProperty('adaptiveBinaryIndices')) {
        this.adaptiveBinaryIndices = options.adaptiveBinaryIndices;

        // if switching to adaptive binary indices, make sure none are 'dirty'
        if (this.adaptiveBinaryIndices) {
          this.ensureAllIndexes();
        }
      }
    };

    /**
     * Ensure binary index on a certain field
     * @param {string} property - name of property to create binary index on
     * @param {boolean=} force - (Optional) flag indicating whether to construct index immediately
     * @memberof Collection
     */
    Collection.prototype.ensureIndex = function (property, force) {
      // optional parameter to force rebuild whether flagged as dirty or not
      if (typeof (force) === 'undefined') {
        force = false;
      }

      if (property === null || property === undefined) {
        throw new Error('Attempting to set index without an associated property');
      }

      if (this.binaryIndices[property] && !force) {
        if (!this.binaryIndices[property].dirty) return;
      }

      // if the index is already defined and we are using adaptiveBinaryIndices and we are not forcing a rebuild, return.
      if (this.adaptiveBinaryIndices === true && this.binaryIndices.hasOwnProperty(property) && !force) {
        return;
      }

      var index = {
        'name': property,
        'dirty': true,
        'values': this.prepareFullDocIndex()
      };
      this.binaryIndices[property] = index;

      var wrappedComparer =
        (function (prop, data) {
          var val1, val2;
          var propPath = ~prop.indexOf('.') ? prop.split('.') : false;
          return function (a, b) {
            if (propPath) {
              val1 = Utils.getIn(data[a], propPath, true);
              val2 = Utils.getIn(data[b], propPath, true);
            } else {
              val1 = data[a][prop];
              val2 = data[b][prop];
            }

            if (val1 !== val2) {
              if (Comparators.lt(val1, val2, false)) return -1;
              if (Comparators.gt(val1, val2, false)) return 1;
            }
            return 0;
          };
        })(property, this.data);

      index.values.sort(wrappedComparer);
      index.dirty = false;

      this.dirty = true; // for autosave scenarios
    };

    /**
     * Perform checks to determine validity/consistency of all binary indices
     * @param {object=} options - optional configuration object
     * @param {boolean} [options.randomSampling=false] - whether (faster) random sampling should be used
     * @param {number} [options.randomSamplingFactor=0.10] - percentage of total rows to randomly sample
     * @param {boolean} [options.repair=false] - whether to fix problems if they are encountered
     * @returns {string[]} array of index names where problems were found.
     * @memberof Collection
     * @example
     * // check all indices on a collection, returns array of invalid index names
     * var result = coll.checkAllIndexes({ repair: true, randomSampling: true, randomSamplingFactor: 0.15 });
     * if (result.length > 0) {
     *   results.forEach(function(name) {
     *     console.log('problem encountered with index : ' + name);
     *   });
     * }
     */
    Collection.prototype.checkAllIndexes = function (options) {
      var key, bIndices = this.binaryIndices;
      var results = [], result;

      for (key in bIndices) {
        if (hasOwnProperty.call(bIndices, key)) {
          result = this.checkIndex(key, options);
          if (!result) {
            results.push(key);
          }
        }
      }

      return results;
    };

    /**
     * Perform checks to determine validity/consistency of a binary index
     * @param {string} property - name of the binary-indexed property to check
     * @param {object=} options - optional configuration object
     * @param {boolean} [options.randomSampling=false] - whether (faster) random sampling should be used
     * @param {number} [options.randomSamplingFactor=0.10] - percentage of total rows to randomly sample
     * @param {boolean} [options.repair=false] - whether to fix problems if they are encountered
     * @returns {boolean} whether the index was found to be valid (before optional correcting).
     * @memberof Collection
     * @example
     * // full test
     * var valid = coll.checkIndex('name');
     * // full test with repair (if issues found)
     * valid = coll.checkIndex('name', { repair: true });
     * // random sampling (default is 10% of total document count)
     * valid = coll.checkIndex('name', { randomSampling: true });
     * // random sampling (sample 20% of total document count)
     * valid = coll.checkIndex('name', { randomSampling: true, randomSamplingFactor: 0.20 });
     * // random sampling (implied boolean)
     * valid = coll.checkIndex('name', { randomSamplingFactor: 0.20 });
     * // random sampling with repair (if issues found)
     * valid = coll.checkIndex('name', { repair: true, randomSampling: true });
     */
    Collection.prototype.checkIndex = function (property, options) {
      options = options || {};
      // if 'randomSamplingFactor' specified but not 'randomSampling', assume true
      if (options.randomSamplingFactor && options.randomSampling !== false) {
        options.randomSampling = true;
      }
      options.randomSamplingFactor = options.randomSamplingFactor || 0.1;
      if (options.randomSamplingFactor < 0 || options.randomSamplingFactor > 1) {
        options.randomSamplingFactor = 0.1;
      }

      var valid = true, idx, iter, pos, len, biv;

      // make sure we are passed a valid binary index name
      if (!this.binaryIndices.hasOwnProperty(property)) {
        throw new Error("called checkIndex on property without an index: " + property);
      }

      // if lazy indexing, rebuild only if flagged as dirty
      if (!this.adaptiveBinaryIndices) {
        this.ensureIndex(property);
      }

      biv = this.binaryIndices[property].values;
      len = biv.length;

      // if the index has an incorrect number of values
      if (len !== this.data.length) {
        if (options.repair) {
          this.ensureIndex(property, true);
        }
        return false;
      }

      if (len === 0) {
        return true;
      }

      var usingDotNotation = (property.indexOf('.') !== -1);

      if (len === 1) {
        valid = (biv[0] === 0);
      }
      else {
        if (options.randomSampling) {
          // validate first and last
          if (!LokiOps.$lte(Utils.getIn(this.data[biv[0]], property, usingDotNotation),
            Utils.getIn(this.data[biv[1]], property, usingDotNotation))) {
            valid = false;
          }
          if (!LokiOps.$lte(Utils.getIn(this.data[biv[len - 2]], property, usingDotNotation),
            Utils.getIn(this.data[biv[len - 1]], property, usingDotNotation))) {
            valid = false;
          }

          // if first and last positions are sorted correctly with their nearest neighbor,
          // continue onto random sampling phase...
          if (valid) {
            // # random samplings = total count * sampling factor
            iter = Math.floor((len - 1) * options.randomSamplingFactor);

            // for each random sampling, validate that the binary index is sequenced properly
            // with next higher value.
            for (idx = 0; idx < iter - 1; idx++) {
              // calculate random position
              pos = Math.floor(Math.random() * (len - 1));
              if (!LokiOps.$lte(Utils.getIn(this.data[biv[pos]], property, usingDotNotation),
                Utils.getIn(this.data[biv[pos + 1]], property, usingDotNotation))) {
                valid = false;
                break;
              }
            }
          }
        }
        else {
          // validate that the binary index is sequenced properly
          for (idx = 0; idx < len - 1; idx++) {
            if (!LokiOps.$lte(Utils.getIn(this.data[biv[idx]], property, usingDotNotation),
              Utils.getIn(this.data[biv[idx + 1]], property, usingDotNotation))) {
              valid = false;
              break;
            }
          }
        }
      }

      // if incorrectly sequenced and we are to fix problems, rebuild index
      if (!valid && options.repair) {
        this.ensureIndex(property, true);
      }

      return valid;
    };

    Collection.prototype.getBinaryIndexValues = function (property) {
      var idx, idxvals = this.binaryIndices[property].values;
      var result = [];

      for (idx = 0; idx < idxvals.length; idx++) {
        result.push(Utils.getIn(this.data[idxvals[idx]], property, true));
      }

      return result;
    };

    /**
     * Returns a named unique index
     * @param {string} field - indexed field name
     * @param {boolean} force - if `true`, will rebuild index; otherwise, function may return null
     */
    Collection.prototype.getUniqueIndex = function (field, force) {
      var index = this.constraints.unique[field];
      if (!index && force) {
        return this.ensureUniqueIndex(field);
      }
      return index;
    };

    Collection.prototype.ensureUniqueIndex = function (field) {
      var index = this.constraints.unique[field];
      if (!index) {
        // keep track of new unique index for regenerate after database (re)load.
        if (this.uniqueNames.indexOf(field) == -1) {
          this.uniqueNames.push(field);
        }
      }

      // if index already existed, (re)loading it will likely cause collisions, rebuild always
      this.constraints.unique[field] = index = new UniqueIndex(field);
      this.data.forEach(function (obj) {
        index.set(obj);
      });
      return index;
    };

    /**
     * Ensure all binary indices
     * @param {boolean} force - whether to force rebuild of existing lazy binary indices
     * @memberof Collection
     */
    Collection.prototype.ensureAllIndexes = function (force) {
      var key, bIndices = this.binaryIndices;
      for (key in bIndices) {
        if (hasOwnProperty.call(bIndices, key)) {
          this.ensureIndex(key, force);
        }
      }
    };

    /**
     * Internal method used to flag all lazy index as dirty
     */
    Collection.prototype.flagBinaryIndexesDirty = function () {
      var key, bIndices = this.binaryIndices;
      for (key in bIndices) {
        if (hasOwnProperty.call(bIndices, key)) {
          bIndices[key].dirty = true;
        }
      }
    };

    /**
     * Internal method used to flag a lazy index as dirty
     */
    Collection.prototype.flagBinaryIndexDirty = function (index) {
      if (this.binaryIndices[index])
        this.binaryIndices[index].dirty = true;
    };

    /**
     * Quickly determine number of documents in collection (or query)
     * @param {object=} query - (optional) query object to count results of
     * @returns {number} number of documents in the collection
     * @memberof Collection
     */
    Collection.prototype.count = function (query) {
      if (!query) {
        return this.data.length;
      }

      return this.chain().find(query).filteredrows.length;
    };

    /**
     * Rebuild idIndex
     */
    Collection.prototype.ensureId = function () {
      if (this.idIndex) {
        return;
      }
      var data = this.data,
        i = 0;
      var len = data.length;
      var index = new Array(len);
      for (i; i < len; i++) {
        index[i] = data[i].$loki;
      }
      this.idIndex = index;
    };

    /**
     * Rebuild idIndex async with callback - useful for background syncing with a remote server
     */
    Collection.prototype.ensureIdAsync = function (callback) {
      this.async(function () {
        this.ensureId();
      }, callback);
    };

    /**
     * Add a dynamic view to the collection
     * @param {string} name - name of dynamic view to add
     * @param {object=} options - options to configure dynamic view with
     * @param {boolean} [options.persistent=false] - indicates if view is to main internal results array in 'resultdata'
     * @param {string} [options.sortPriority='passive'] - 'passive' (sorts performed on call to data) or 'active' (after updates)
     * @param {number} options.minRebuildInterval - minimum rebuild interval (need clarification to docs here)
     * @returns {DynamicView} reference to the dynamic view added
     * @memberof Collection
     * @example
     * var pview = users.addDynamicView('progeny');
     * pview.applyFind({'age': {'$lte': 40}});
     * pview.applySimpleSort('name');
     *
     * var results = pview.data();
     **/

    Collection.prototype.addDynamicView = function (name, options) {
      var dv = new DynamicView(this, name, options);
      this.DynamicViews.push(dv);

      return dv;
    };

    /**
     * Remove a dynamic view from the collection
     * @param {string} name - name of dynamic view to remove
     * @memberof Collection
     **/
    Collection.prototype.removeDynamicView = function (name) {
      this.DynamicViews =
        this.DynamicViews.filter(function (dv) { return dv.name !== name; });
    };

    /**
     * Look up dynamic view reference from within the collection
     * @param {string} name - name of dynamic view to retrieve reference of
     * @returns {DynamicView} A reference to the dynamic view with that name
     * @memberof Collection
     **/
    Collection.prototype.getDynamicView = function (name) {
      for (var idx = 0; idx < this.DynamicViews.length; idx++) {
        if (this.DynamicViews[idx].name === name) {
          return this.DynamicViews[idx];
        }
      }

      return null;
    };

    /**
     * Applies a 'mongo-like' find query object and passes all results to an update function.
     * For filter function querying you should migrate to [updateWhere()]{@link Collection#updateWhere}.
     *
     * @param {object|function} filterObject - 'mongo-like' query object (or deprecated filterFunction mode)
     * @param {function} updateFunction - update function to run against filtered documents
     * @memberof Collection
     */
    Collection.prototype.findAndUpdate = function (filterObject, updateFunction) {
      if (typeof (filterObject) === "function") {
        this.updateWhere(filterObject, updateFunction);
      }
      else {
        this.chain().find(filterObject).update(updateFunction);
      }
    };

    /**
     * Applies a 'mongo-like' find query object removes all documents which match that filter.
     *
     * @param {object} filterObject - 'mongo-like' query object
     * @memberof Collection
     */
    Collection.prototype.findAndRemove = function (filterObject) {
      this.chain().find(filterObject).remove();
    };

    /**
     * Adds object(s) to collection, ensure object(s) have meta properties, clone it if necessary, etc.
     * @param {(object|array)} doc - the document (or array of documents) to be inserted
     * @param {boolean=} overrideAdaptiveIndices - (optional) if `true`, adaptive indicies will be
     *   temporarily disabled and then fully rebuilt after batch. This will be faster for
     *   large inserts, but slower for small/medium inserts in large collections
     * @returns {(object|array)} document or documents inserted
     * @memberof Collection
     * @example
     * users.insert({
     *     name: 'Odin',
     *     age: 50,
     *     address: 'Asgard'
     * });
     *
     * // alternatively, insert array of documents
     * users.insert([{ name: 'Thor', age: 35}, { name: 'Loki', age: 30}]);
     */
    Collection.prototype.insert = function (doc, overrideAdaptiveIndices) {
      if (!Array.isArray(doc)) {
        return this.insertOne(doc);
      }

      // holder to the clone of the object inserted if collections is set to clone objects
      var obj;
      var results = [];

      // if not cloning, disable adaptive binary indices for the duration of the batch insert,
      // followed by lazy rebuild and re-enabling adaptive indices after batch insert.
      var adaptiveBatchOverride = overrideAdaptiveIndices && !this.cloneObjects &&
        this.adaptiveBinaryIndices && Object.keys(this.binaryIndices).length > 0;

      if (adaptiveBatchOverride) {
        this.adaptiveBinaryIndices = false;
      }

      try {
        this.emit('pre-insert', doc);
        for (var i = 0, len = doc.length; i < len; i++) {
          obj = this.insertOne(doc[i], true);
          if (!obj) {
            return undefined;
          }
          results.push(obj);
        }
      } finally {
        if (adaptiveBatchOverride) {
          this.ensureAllIndexes();
          this.adaptiveBinaryIndices = true;
        }
      }

      // at the 'batch' level, if clone option is true then emitted docs are clones
      this.emit('insert', results);

      // if clone option is set, clone return values
      results = this.cloneObjects ? clone(results, this.cloneMethod) : results;

      return results.length === 1 ? results[0] : results;
    };

    /**
     * Adds a single object, ensures it has meta properties, clone it if necessary, etc.
     * @param {object} doc - the document to be inserted
     * @param {boolean} bulkInsert - quiet pre-insert and insert event emits
     * @returns {object} document or 'undefined' if there was a problem inserting it
     */
    Collection.prototype.insertOne = function (doc, bulkInsert) {
      var err = null;
      var returnObj;

      if (typeof doc !== 'object') {
        err = new TypeError('Document needs to be an object');
      } else if (doc === null) {
        err = new TypeError('Object cannot be null');
      }

      if (err !== null) {
        this.emit('error', err);
        throw err;
      }

      // if configured to clone, do so now... otherwise just use same obj reference
      var obj = this.cloneObjects ? clone(doc, this.cloneMethod) : doc;
      if (!this.disableFreeze) {
        obj = unFreeze(obj);
      }

      if (!this.disableMeta) {
        if (typeof obj.meta === 'undefined') {
          obj.meta = {
            revision: 0,
            created: 0
          };
        } else if (!this.disableFreeze) {
          obj.meta = unFreeze(obj.meta);
        }
      }

      // both 'pre-insert' and 'insert' events are passed internal data reference even when cloning
      // insert needs internal reference because that is where loki itself listens to add meta
      if (!bulkInsert) {
        this.emit('pre-insert', obj);
      }
      if (!this.add(obj)) {
        return undefined;
      }

      // update meta and store changes if ChangesAPI is enabled
      // (moved from "insert" event listener to allow internal reference to be used)
      if (this.disableChangesApi) {
        this.insertMeta(obj);
      } else {
        this.insertMetaWithChange(obj);
      }

      if (!this.disableFreeze) {
        deepFreeze(obj);
      }

      // if cloning is enabled, emit insert event with clone of new object
      returnObj = this.cloneObjects ? clone(obj, this.cloneMethod) : obj;

      if (!bulkInsert) {
        this.emit('insert', returnObj);
      }

      this.addAutoUpdateObserver(returnObj);

      return returnObj;
    };

    /**
     * Empties the collection.
     * @param {object=} options - configure clear behavior
     * @param {bool=} [options.removeIndices=false] - whether to remove indices in addition to data
     * @memberof Collection
     */
    Collection.prototype.clear = function (options) {
      var self = this;

      options = options || {};

      this.data = [];
      this.idIndex = null;
      this.cachedIndex = null;
      this.cachedBinaryIndex = null;
      this.cachedData = null;
      this.maxId = 0;
      this.DynamicViews = [];
      this.dirty = true;
      this.constraints = {
        unique: {},
        exact: {}
      };

      // if removing indices entirely
      if (options.removeIndices === true) {
        this.binaryIndices = {};
        this.uniqueNames = [];
      }
      // clear indices but leave definitions in place
      else {
        // clear binary indices
        var keys = Object.keys(this.binaryIndices);
        keys.forEach(function (biname) {
          self.binaryIndices[biname].dirty = false;
          self.binaryIndices[biname].values = [];
        });
      }
    };

    /**
     * Updates an object and notifies collection that the document has changed.
     * @param {object} doc - document to update within the collection
     * @memberof Collection
     */
    Collection.prototype.update = function (doc) {
      var adaptiveBatchOverride, k, len;

      if (Array.isArray(doc)) {
        len = doc.length;

        // if not cloning, disable adaptive binary indices for the duration of the batch update,
        // followed by lazy rebuild and re-enabling adaptive indices after batch update.
        adaptiveBatchOverride = !this.cloneObjects &&
          this.adaptiveBinaryIndices && Object.keys(this.binaryIndices).length > 0;

        if (adaptiveBatchOverride) {
          this.adaptiveBinaryIndices = false;
        }

        try {
          for (k = 0; k < len; k += 1) {
            this.update(doc[k]);
          }
        }
        finally {
          if (adaptiveBatchOverride) {
            this.ensureAllIndexes();
            this.adaptiveBinaryIndices = true;
          }
        }

        return;
      }

      // verify object is a properly formed document
      if (!hasOwnProperty.call(doc, '$loki')) {
        throw new Error('Trying to update unsynced document. Please save the document first by using insert() or addMany()');
      }
      try {
        this.startTransaction();
        var arr = this.get(doc.$loki, true),
          oldInternal,   // ref to existing obj
          newInternal, // ref to new internal obj
          position,
          self = this;

        if (!arr) {
          throw new Error('Trying to update a document not in collection.');
        }

        oldInternal = arr[0]; // -internal- obj ref
        position = arr[1]; // position in data array

        // if configured to clone, do so now... otherwise just use same obj reference
        newInternal = this.cloneObjects || (!this.disableDeltaChangesApi && this.disableFreeze) ? clone(doc, this.cloneMethod) : doc;

        this.emit('pre-update', doc);

        this.uniqueNames.forEach(function (key) {
          self.getUniqueIndex(key, true).update(oldInternal, newInternal);
        });

        // operate the update
        this.data[position] = newInternal;

        if (newInternal !== doc) {
          this.addAutoUpdateObserver(doc);
        }

        // now that we can efficiently determine the data[] position of newly added document,
        // submit it for all registered DynamicViews to evaluate for inclusion/exclusion
        for (var idx = 0; idx < this.DynamicViews.length; idx++) {
          this.DynamicViews[idx].evaluateDocument(position, false);
        }

        var key;
        if (this.adaptiveBinaryIndices) {
          // for each binary index defined in collection, immediately update rather than flag for lazy rebuild
          var bIndices = this.binaryIndices;
          for (key in bIndices) {
            this.adaptiveBinaryIndexUpdate(position, key);
          }
        }
        else {
          this.flagBinaryIndexesDirty();
        }

        this.idIndex[position] = newInternal.$loki;
        //this.flagBinaryIndexesDirty();

        if (this.isIncremental) {
          this.dirtyIds.push(newInternal.$loki);
        }

        this.commit();
        this.dirty = true; // for autosave scenarios

        // update meta and store changes if ChangesAPI is enabled
        if (this.disableChangesApi) {
          newInternal = this.updateMeta(newInternal);
        } else {
          newInternal = this.updateMetaWithChange(newInternal, oldInternal);
        }

        if (!this.disableFreeze) {
          deepFreeze(newInternal);
        }

        var returnObj;

        // if cloning is enabled, emit 'update' event and return with clone of new object
        if (this.cloneObjects) {
          returnObj = clone(newInternal, this.cloneMethod);
        }
        else {
          returnObj = newInternal;
        }

        this.emit('update', returnObj, oldInternal);
        return returnObj;
      } catch (err) {
        this.rollback();
        this.lokiConsoleWrapper.error(err.message);
        this.emit('error', err);
        throw (err); // re-throw error so user does not think it succeeded
      }
    };

    /**
     * Add object to collection
     */
    Collection.prototype.add = function (obj) {
      // if parameter isn't object exit with throw
      if ('object' !== typeof obj) {
        throw new TypeError('Object being added needs to be an object');
      }
      // if object you are adding already has id column it is either already in the collection
      // or the object is carrying its own 'id' property.  If it also has a meta property,
      // then this is already in collection so throw error, otherwise rename to originalId and continue adding.
      if (typeof (obj.$loki) !== 'undefined') {
        throw new Error('Document is already in collection, please use update()');
      }

      /*
       * try adding object to collection
       */
      try {
        this.startTransaction();
        this.maxId++;

        if (isNaN(this.maxId)) {
          this.maxId = (this.data[this.data.length - 1].$loki + 1);
        }

        var newId = this.maxId;
        obj.$loki = newId;

        if (!this.disableMeta) {
          obj.meta.version = 0;
        }

        for (var i = 0, len = this.uniqueNames.length; i < len; i ++) {
          this.getUniqueIndex(this.uniqueNames[i], true).set(obj);
        }

        if (this.idIndex) {
          this.idIndex.push(newId);
        }

        if (this.isIncremental) {
          this.dirtyIds.push(newId);
        }

        // add the object
        this.data.push(obj);

        var addedPos = this.data.length - 1;

        // now that we can efficiently determine the data[] position of newly added document,
        // submit it for all registered DynamicViews to evaluate for inclusion/exclusion
        var dvlen = this.DynamicViews.length;
        for (i = 0; i < dvlen; i++) {
          this.DynamicViews[i].evaluateDocument(addedPos, true);
        }

        if (this.adaptiveBinaryIndices) {
          // for each binary index defined in collection, immediately update rather than flag for lazy rebuild
          var bIndices = this.binaryIndices;
          for (var key in bIndices) {
            this.adaptiveBinaryIndexInsert(addedPos, key);
          }
        }
        else {
          this.flagBinaryIndexesDirty();
        }

        this.commit();
        this.dirty = true; // for autosave scenarios

        return (this.cloneObjects) ? (clone(obj, this.cloneMethod)) : (obj);
      } catch (err) {
        this.rollback();
        this.lokiConsoleWrapper.error(err.message);
        this.emit('error', err);
        throw (err); // re-throw error so user does not think it succeeded
      }
    };

    /**
     * Applies a filter function and passes all results to an update function.
     *
     * @param {function} filterFunction - filter function whose results will execute update
     * @param {function} updateFunction - update function to run against filtered documents
     * @memberof Collection
     */
    Collection.prototype.updateWhere = function (filterFunction, updateFunction) {
      var results = this.where(filterFunction),
        i = 0,
        obj;
      try {
        for (i; i < results.length; i++) {
          obj = updateFunction(results[i]);
          this.update(obj);
        }

      } catch (err) {
        this.rollback();
        this.lokiConsoleWrapper.error(err.message);
      }
    };

    /**
     * Remove all documents matching supplied filter function.
     * For 'mongo-like' querying you should migrate to [findAndRemove()]{@link Collection#findAndRemove}.
     * @param {function|object} query - query object to filter on
     * @memberof Collection
     */
    Collection.prototype.removeWhere = function (query) {
      var list;
      if (typeof query === 'function') {
        list = this.data.filter(query);
        this.remove(list);
      } else {
        this.chain().find(query).remove();
      }
    };

    Collection.prototype.removeDataOnly = function () {
      this.remove(this.data.slice());
    };

    /**
     * Internal method to remove a batch of documents from the collection.
     * @param {number[]} positions - data/idIndex positions to remove
     */
    Collection.prototype.removeBatchByPositions = function (positions) {
      var len = positions.length;
      var xo = {};
      var dlen, didx, idx;
      var bic = Object.keys(this.binaryIndices).length;
      var uic = Object.keys(this.constraints.unique).length;
      var adaptiveOverride = this.adaptiveBinaryIndices && Object.keys(this.binaryIndices).length > 0;
      var doc, self = this;

      try {
        this.startTransaction();

        // create hashobject for positional removal inclusion tests...
        // all keys defined in this hashobject represent $loki ids of the documents to remove.
        this.ensureId();
        for (idx = 0; idx < len; idx++) {
          xo[this.idIndex[positions[idx]]] = true;
        }

        // if we will need to notify dynamic views and/or binary indices to update themselves...
        dlen = this.DynamicViews.length;
        if ((dlen > 0) || (bic > 0) || (uic > 0)) {
          if (dlen > 0) {
            // notify dynamic views to remove relevant documents at data positions
            for (didx = 0; didx < dlen; didx++) {
              // notify dv of remove (passing batch/array of positions)
              this.DynamicViews[didx].removeDocument(positions);
            }
          }

          // notify binary indices to update
          if (this.adaptiveBinaryIndices && !adaptiveOverride) {
            // for each binary index defined in collection, immediately update rather than flag for lazy rebuild
            var key, bIndices = this.binaryIndices;

            for (key in bIndices) {
              this.adaptiveBinaryIndexRemove(positions, key);
            }
          }
          else {
            this.flagBinaryIndexesDirty();
          }

          if (uic) {
            this.uniqueNames.forEach(function (key) {
              var index = self.getUniqueIndex(key);
              if (index) {
                for (idx = 0; idx < len; idx++) {
                  doc = self.data[positions[idx]];
                  if (doc[key] !== null && doc[key] !== undefined) {
                    index.remove(doc[key]);
                  }
                }
              }
            });
          }
        }

        // emit 'delete' events only of listeners are attached.
        // since data not removed yet, in future we can emit single delete event with array...
        // for now that might be breaking change to put in potential 1.6 or LokiDB (lokijs2) version
        if (!this.disableChangesApi || this.events.delete.length > 1) {
          for (idx = 0; idx < len; idx++) {
            this.emit('delete', this.data[positions[idx]]);
          }
        }

        // remove from data[] :
        // filter collection data for items not in inclusion hashobject
        this.data = this.data.filter(function (obj) {
          return !xo[obj.$loki];
        });

        if (this.isIncremental) {
          for(idx=0; idx < len; idx++) {
            this.dirtyIds.push(this.idIndex[positions[idx]]);
          }
        }

        // remove from idIndex[] :
        // filter idIndex for items not in inclusion hashobject
        this.idIndex = this.idIndex.filter(function (id) {
          return !xo[id];
        });

        if (this.adaptiveBinaryIndices && adaptiveOverride) {
          this.adaptiveBinaryIndices = false;
          this.ensureAllIndexes(true);
          this.adaptiveBinaryIndices = true;
        }

        this.commit();

        // flag collection as dirty for autosave
        this.dirty = true;
      }
      catch (err) {
        this.rollback();
        if (adaptiveOverride) {
          this.adaptiveBinaryIndices = true;
        }
        this.lokiConsoleWrapper.error(err.message);
        this.emit('error', err);
        return null;
      }
    };

    /**
     *  Internal method called by remove()
     * @param {object[]|number[]} batch - array of documents or $loki ids to remove
     */
    Collection.prototype.removeBatch = function (batch) {
      var len = batch.length,
        dlen = this.data.length,
        idx;
      var xlt = {};
      var posx = [];

      // create lookup hashobject to translate $loki id to position
      for (idx = 0; idx < dlen; idx++) {
        xlt[this.data[idx].$loki] = idx;
      }

      // iterate the batch
      for (idx = 0; idx < len; idx++) {
        if (typeof (batch[idx]) === 'object') {
          posx.push(xlt[batch[idx].$loki]);
        }
        else {
          posx.push(xlt[batch[idx]]);
        }
      }

      this.removeBatchByPositions(posx);
    };

    /**
     * Remove a document from the collection
     * @param {object} doc - document to remove from collection
     * @memberof Collection
     */
    Collection.prototype.remove = function (doc) {
      var frozen;

      if (typeof doc === 'number') {
        doc = this.get(doc);
      }

      if ('object' !== typeof doc) {
        throw new Error('Parameter is not an object');
      }
      if (Array.isArray(doc)) {
        this.removeBatch(doc);
        return;
      }

      if (!hasOwnProperty.call(doc, '$loki')) {
        throw new Error('Object is not a document stored in the collection');
      }

      try {
        this.startTransaction();
        var arr = this.get(doc.$loki, true),
          // obj = arr[0],
          position = arr[1];
        var self = this;
        this.uniqueNames.forEach(function (key) {
          if (doc[key] !== null && typeof doc[key] !== 'undefined') {
            var index = self.getUniqueIndex(key);
            if (index) {
              index.remove(doc[key]);
            }
          }
        });
        // now that we can efficiently determine the data[] position of newly added document,
        // submit it for all registered DynamicViews to remove
        for (var idx = 0; idx < this.DynamicViews.length; idx++) {
          this.DynamicViews[idx].removeDocument(position);
        }

        if (this.adaptiveBinaryIndices) {
          // for each binary index defined in collection, immediately update rather than flag for lazy rebuild
          var key, bIndices = this.binaryIndices;
          for (key in bIndices) {
            this.adaptiveBinaryIndexRemove(position, key);
          }
        }
        else {
          this.flagBinaryIndexesDirty();
        }

        this.data.splice(position, 1);
        this.removeAutoUpdateObserver(doc);

        // remove id from idIndex
        this.idIndex.splice(position, 1);

        if (this.isIncremental) {
          this.dirtyIds.push(doc.$loki);
        }

        this.commit();
        this.dirty = true; // for autosave scenarios
        this.emit('delete', arr[0]);

        if (!this.disableFreeze) {
          doc = unFreeze(doc);
        }
        delete doc.$loki;
        delete doc.meta;
        if (!this.disableFreeze) {
          freeze(doc);
        }
        return doc;

      } catch (err) {
        this.rollback();
        this.lokiConsoleWrapper.error(err.message);
        this.emit('error', err);
        return null;
      }
    };

    /*---------------------+
    | Finding methods     |
    +----------------------*/

    /**
     * Get by Id - faster than other methods because of the searching algorithm
     * @param {int} id - $loki id of document you want to retrieve
     * @param {boolean} returnPosition - if 'true' we will return [object, position]
     * @returns {(object|array|null)} Object reference if document was found, null if not,
     *     or an array if 'returnPosition' was passed.
     * @memberof Collection
     */
    Collection.prototype.get = function (id, returnPosition) {
      if (!this.idIndex) {
        this.ensureId();
      }

      var retpos = returnPosition || false,
        data = this.idIndex,
        max = data.length - 1,
        min = 0,
        mid = (min + max) >> 1;

      id = typeof id === 'number' ? id : parseInt(id, 10);

      if (isNaN(id)) {
        throw new TypeError('Passed id is not an integer');
      }

      while (data[min] < data[max]) {
        mid = (min + max) >> 1;

        if (data[mid] < id) {
          min = mid + 1;
        } else {
          max = mid;
        }
      }

      if (max === min && data[min] === id) {
        if (retpos) {
          return [this.data[min], min];
        }
        return this.data[min];
      }
      return null;

    };

    /**
     * Perform binary range lookup for the data[dataPosition][binaryIndexName] property value
     *    Since multiple documents may contain the same value (which the index is sorted on),
     *    we hone in on range and then linear scan range to find exact index array position.
     * @param {int} dataPosition : coll.data array index/position
     * @param {string} binaryIndexName : index to search for dataPosition in
     */
    Collection.prototype.getBinaryIndexPosition = function (dataPosition, binaryIndexName) {
      var val = Utils.getIn(this.data[dataPosition], binaryIndexName, true);
      var index = this.binaryIndices[binaryIndexName].values;

      // i think calculateRange can probably be moved to collection
      // as it doesn't seem to need resultset.  need to verify
      var range = this.calculateRange("$eq", binaryIndexName, val);

      if (range[0] === 0 && range[1] === -1) {
        // uhoh didn't find range
        return null;
      }

      var min = range[0];
      var max = range[1];

      // narrow down the sub-segment of index values
      // where the indexed property value exactly matches our
      // value and then linear scan to find exact -index- position
      for (var idx = min; idx <= max; idx++) {
        if (index[idx] === dataPosition) return idx;
      }

      // uhoh
      return null;
    };

    /**
     * Adaptively insert a selected item to the index.
     * @param {int} dataPosition : coll.data array index/position
     * @param {string} binaryIndexName : index to search for dataPosition in
     */
    Collection.prototype.adaptiveBinaryIndexInsert = function (dataPosition, binaryIndexName) {
      var usingDotNotation = (binaryIndexName.indexOf('.') !== -1);
      var index = this.binaryIndices[binaryIndexName].values;
      var val = Utils.getIn(this.data[dataPosition], binaryIndexName, usingDotNotation);

      // If you are inserting a javascript Date value into a binary index, convert to epoch time
      if (this.serializableIndices === true && val instanceof Date) {
        this.data[dataPosition][binaryIndexName] = val.getTime();
        val = Utils.getIn(this.data[dataPosition], binaryIndexName);
      }

      var idxPos = (index.length === 0) ? 0 : this.calculateRangeStart(binaryIndexName, val, true, usingDotNotation);

      // insert new data index into our binary index at the proper sorted location for relevant property calculated by idxPos.
      // doing this after adjusting dataPositions so no clash with previous item at that position.
      this.binaryIndices[binaryIndexName].values.splice(idxPos, 0, dataPosition);
    };

    /**
     * Adaptively update a selected item within an index.
     * @param {int} dataPosition : coll.data array index/position
     * @param {string} binaryIndexName : index to search for dataPosition in
     */
    Collection.prototype.adaptiveBinaryIndexUpdate = function (dataPosition, binaryIndexName) {
      // linear scan needed to find old position within index unless we optimize for clone scenarios later
      // within (my) node 5.6.0, the following for() loop with strict compare is -much- faster than indexOf()
      var idxPos,
        index = this.binaryIndices[binaryIndexName].values,
        len = index.length;

      for (idxPos = 0; idxPos < len; idxPos++) {
        if (index[idxPos] === dataPosition) break;
      }

      //var idxPos = this.binaryIndices[binaryIndexName].values.indexOf(dataPosition);
      this.binaryIndices[binaryIndexName].values.splice(idxPos, 1);

      //this.adaptiveBinaryIndexRemove(dataPosition, binaryIndexName, true);
      this.adaptiveBinaryIndexInsert(dataPosition, binaryIndexName);
    };

    /**
     * Adaptively remove a selected item from the index.
     * @param {number|number[]} dataPosition : coll.data array index/position
     * @param {string} binaryIndexName : index to search for dataPosition in
     */
    Collection.prototype.adaptiveBinaryIndexRemove = function (dataPosition, binaryIndexName, removedFromIndexOnly) {
      var bi = this.binaryIndices[binaryIndexName];
      var len, idx, rmidx, rmlen, rxo = {};
      var curr, shift, idxPos;

      if (Array.isArray(dataPosition)) {
        // when called from chained remove, and only one document in array,
        // it will be faster to use old algorithm
        rmlen = dataPosition.length;
        if (rmlen === 1) {
          dataPosition = dataPosition[0];
        }
        // we were passed an array (batch) of documents so use this 'batch optimized' algorithm
        else {
          for (rmidx = 0; rmidx < rmlen; rmidx++) {
            rxo[dataPosition[rmidx]] = true;
          }

          // remove document from index (with filter function)
          bi.values = bi.values.filter(function (di) { return !rxo[di]; });

          // if we passed this optional flag parameter, we are calling from adaptiveBinaryIndexUpdate,
          // in which case data positions stay the same.
          if (removedFromIndexOnly === true) {
            return;
          }

          var sortedPositions = dataPosition.slice();
          sortedPositions.sort(function (a, b) { return a - b; });

          // to remove holes, we need to 'shift down' the index's data array positions
          // we need to adjust array positions -1 for each index data positions greater than removed positions
          len = bi.values.length;
          for (idx = 0; idx < len; idx++) {
            curr = bi.values[idx];
            shift = 0;
            for (rmidx = 0; rmidx < rmlen && curr > sortedPositions[rmidx]; rmidx++) {
              shift++;
            }
            bi.values[idx] -= shift;
          }

          // batch processed, bail out
          return;
        }

        // not a batch so continue...
      }

      idxPos = this.getBinaryIndexPosition(dataPosition, binaryIndexName);

      if (idxPos === null) {
        // throw new Error('unable to determine binary index position');
        return null;
      }

      // remove document from index (with splice)
      bi.values.splice(idxPos, 1);

      // if we passed this optional flag parameter, we are calling from adaptiveBinaryIndexUpdate,
      // in which case data positions stay the same.
      if (removedFromIndexOnly === true) {
        return;
      }

      // since index stores data array positions, if we remove a document
      // we need to adjust array positions -1 for all document positions greater than removed position
      len = bi.values.length;
      for (idx = 0; idx < len; idx++) {
        if (bi.values[idx] > dataPosition) {
          bi.values[idx]--;
        }
      }
    };

    /**
     * Internal method used for index maintenance and indexed searching.
     * Calculates the beginning of an index range for a given value.
     * For index maintainance (adaptive:true), we will return a valid index position to insert to.
     * For querying (adaptive:false/undefined), we will :
     *    return lower bound/index of range of that value (if found)
     *    return next lower index position if not found (hole)
     * If index is empty it is assumed to be handled at higher level, so
     * this method assumes there is at least 1 document in index.
     *
     * @param {string} prop - name of property which has binary index
     * @param {any} val - value to find within index
     * @param {bool?} adaptive - if true, we will return insert position
     */
    Collection.prototype.calculateRangeStart = function (prop, val, adaptive, usingDotNotation) {
      var rcd = this.data;
      var index = this.binaryIndices[prop].values;
      var min = 0;
      var max = index.length - 1;
      var mid = 0;

      if (index.length === 0) {
        return -1;
      }

      var minVal = Utils.getIn(rcd[index[min]], prop, usingDotNotation);
      var maxVal = Utils.getIn(rcd[index[max]], prop, usingDotNotation);

      // hone in on start position of value
      while (min < max) {
        mid = (min + max) >> 1;

        if (Comparators.lt(Utils.getIn(rcd[index[mid]], prop, usingDotNotation), val, false)) {
          min = mid + 1;
        } else {
          max = mid;
        }
      }

      var lbound = min;

      // found it... return it
      if (Comparators.aeq(val, Utils.getIn(rcd[index[lbound]], prop, usingDotNotation))) {
        return lbound;
      }

      // if not in index and our value is less than the found one
      if (Comparators.lt(val, Utils.getIn(rcd[index[lbound]], prop, usingDotNotation), false)) {
        return adaptive ? lbound : lbound - 1;
      }

      // not in index and our value is greater than the found one
      return adaptive ? lbound + 1 : lbound;
    };

    /**
     * Internal method used for indexed $between.  Given a prop (index name), and a value
     * (which may or may not yet exist) this will find the final position of that upper range value.
     */
    Collection.prototype.calculateRangeEnd = function (prop, val, usingDotNotation) {
      var rcd = this.data;
      var index = this.binaryIndices[prop].values;
      var min = 0;
      var max = index.length - 1;
      var mid = 0;

      if (index.length === 0) {
        return -1;
      }

      var minVal = Utils.getIn(rcd[index[min]], prop, usingDotNotation);
      var maxVal = Utils.getIn(rcd[index[max]], prop, usingDotNotation);

      // hone in on start position of value
      while (min < max) {
        mid = (min + max) >> 1;

        if (Comparators.lt(val, Utils.getIn(rcd[index[mid]], prop, usingDotNotation), false)) {
          max = mid;
        } else {
          min = mid + 1;
        }
      }

      var ubound = max;

      // only eq if last element in array is our val
      if (Comparators.aeq(val, Utils.getIn(rcd[index[ubound]], prop, usingDotNotation))) {
        return ubound;
      }

      // if not in index and our value is less than the found one
      if (Comparators.gt(val, Utils.getIn(rcd[index[ubound]], prop, usingDotNotation), false)) {
        return ubound + 1;
      }

      // either hole or first nonmatch
      if (Comparators.aeq(val, Utils.getIn(rcd[index[ubound - 1]], prop, usingDotNotation))) {
        return ubound - 1;
      }

      // hole, so ubound if nearest gt than the val we were looking for
      return ubound;
    };

    /**
     * calculateRange() - Binary Search utility method to find range/segment of values matching criteria.
     *    this is used for collection.find() and first find filter of resultset/dynview
     *    slightly different than get() binary search in that get() hones in on 1 value,
     *    but we have to hone in on many (range)
     * @param {string} op - operation, such as $eq
     * @param {string} prop - name of property to calculate range for
     * @param {object} val - value to use for range calculation.
     * @returns {array} [start, end] index array positions
     */
    Collection.prototype.calculateRange = function (op, prop, val) {
      var rcd = this.data;
      var index = this.binaryIndices[prop].values;
      var min = 0;
      var max = index.length - 1;
      var mid = 0;
      var lbound, lval;
      var ubound, uval;

      // when no documents are in collection, return empty range condition
      if (rcd.length === 0) {
        return [0, -1];
      }

      var usingDotNotation = (prop.indexOf('.') !== -1);

      var minVal = Utils.getIn(rcd[index[min]], prop, usingDotNotation);
      var maxVal = Utils.getIn(rcd[index[max]], prop, usingDotNotation);

      // if value falls outside of our range return [0, -1] to designate no results
      switch (op) {
        case '$eq':
        case '$aeq':
          if (Comparators.lt(val, minVal, false) || Comparators.gt(val, maxVal, false)) {
            return [0, -1];
          }
          break;
        case '$dteq':
          if (Comparators.lt(val, minVal, false) || Comparators.gt(val, maxVal, false)) {
            return [0, -1];
          }
          break;
        case '$gt':
          // none are within range
          if (Comparators.gt(val, maxVal, true)) {
            return [0, -1];
          }
          // all are within range
          if (Comparators.gt(minVal, val, false)) {
            return [min, max];
          }
          break;
        case '$gte':
          // none are within range
          if (Comparators.gt(val, maxVal, false)) {
            return [0, -1];
          }
          // all are within range
          if (Comparators.gt(minVal, val, true)) {
            return [min, max];
          }
          break;
        case '$lt':
          // none are within range
          if (Comparators.lt(val, minVal, true)) {
            return [0, -1];
          }
          // all are within range
          if (Comparators.lt(maxVal, val, false)) {
            return [min, max];
          }
          break;
        case '$lte':
          // none are within range
          if (Comparators.lt(val, minVal, false)) {
            return [0, -1];
          }
          // all are within range
          if (Comparators.lt(maxVal, val, true)) {
            return [min, max];
          }
          break;
        case '$between':
          // none are within range (low range is greater)
          if (Comparators.gt(val[0], maxVal, false)) {
            return [0, -1];
          }
          // none are within range (high range lower)
          if (Comparators.lt(val[1], minVal, false)) {
            return [0, -1];
          }

          lbound = this.calculateRangeStart(prop, val[0], false, usingDotNotation);
          ubound = this.calculateRangeEnd(prop, val[1], usingDotNotation);

          if (lbound < 0) lbound++;
          if (ubound > max) ubound--;

          if (!Comparators.gt(Utils.getIn(rcd[index[lbound]], prop, usingDotNotation), val[0], true)) lbound++;
          if (!Comparators.lt(Utils.getIn(rcd[index[ubound]], prop, usingDotNotation), val[1], true)) ubound--;

          if (ubound < lbound) return [0, -1];

          return ([lbound, ubound]);
        case '$in':
          var idxset = [],
            segResult = [];
          // query each value '$eq' operator and merge the seqment results.
          for (var j = 0, len = val.length; j < len; j++) {
            var seg = this.calculateRange('$eq', prop, val[j]);

            for (var i = seg[0]; i <= seg[1]; i++) {
              if (idxset[i] === undefined) {
                idxset[i] = true;
                segResult.push(i);
              }
            }
          }
          return segResult;
      }

      // determine lbound where needed
      switch (op) {
        case '$eq':
        case '$aeq':
        case '$dteq':
        case '$gte':
        case '$lt':
          lbound = this.calculateRangeStart(prop, val, false, usingDotNotation);
          lval = Utils.getIn(rcd[index[lbound]], prop, usingDotNotation);
          break;
        default: break;
      }

      // determine ubound where needed
      switch (op) {
        case '$eq':
        case '$aeq':
        case '$dteq':
        case '$lte':
        case '$gt':
          ubound = this.calculateRangeEnd(prop, val, usingDotNotation);
          uval = Utils.getIn(rcd[index[ubound]], prop, usingDotNotation);
          break;
        default: break;
      }


      switch (op) {
        case '$eq':
        case '$aeq':
        case '$dteq':
          // if hole (not found)
          if (!Comparators.aeq(lval, val)) {
            return [0, -1];
          }

          return [lbound, ubound];

        case '$gt':
          // if hole (not found) ub position is already greater
          if (!Comparators.aeq(Utils.getIn(rcd[index[ubound]], prop, usingDotNotation), val)) {
            return [ubound, max];
          }
          // otherwise (found) so ubound is still equal, get next
          return [ubound + 1, max];

        case '$gte':
          // if hole (not found) lb position marks left outside of range
          if (!Comparators.aeq(Utils.getIn(rcd[index[lbound]], prop, usingDotNotation), val)) {
            return [lbound + 1, max];
          }
          // otherwise (found) so lb is first position where its equal
          return [lbound, max];

        case '$lt':
          // if hole (not found) position already is less than
          if (!Comparators.aeq(Utils.getIn(rcd[index[lbound]], prop, usingDotNotation), val)) {
            return [min, lbound];
          }
          // otherwise (found) so lb marks left inside of eq range, get previous
          return [min, lbound - 1];

        case '$lte':
          // if hole (not found) ub position marks right outside so get previous
          if (!Comparators.aeq(Utils.getIn(rcd[index[ubound]], prop, usingDotNotation), val)) {
            return [min, ubound - 1];
          }
          // otherwise (found) so ub is last position where its still equal
          return [min, ubound];

        default:
          return [0, rcd.length - 1];
      }
    };

    /**
     * Retrieve doc by Unique index
     * @param {string} field - name of uniquely indexed property to use when doing lookup
     * @param {value} value - unique value to search for
     * @returns {object} document matching the value passed
     * @memberof Collection
     */
    Collection.prototype.by = function (field, value) {
      var self;
      if (value === undefined) {
        self = this;
        return function (value) {
          return self.by(field, value);
        };
      }

      var result = this.getUniqueIndex(field, true).get(value);
      if (!this.cloneObjects) {
        return result;
      } else {
        return clone(result, this.cloneMethod);
      }
    };

    /**
     * Find one object by index property, by property equal to value
     * @param {object} query - query object used to perform search with
     * @returns {(object|null)} First matching document, or null if none
     * @memberof Collection
     */
    Collection.prototype.findOne = function (query) {
      query = query || {};

      // Instantiate Resultset and exec find op passing firstOnly = true param
      var result = this.chain().find(query, true).data();

      if (Array.isArray(result) && result.length === 0) {
        return null;
      } else {
        if (!this.cloneObjects) {
          return result[0];
        } else {
          return clone(result[0], this.cloneMethod);
        }
      }
    };

    /**
     * Chain method, used for beginning a series of chained find() and/or view() operations
     * on a collection.
     *
     * @param {string|array=} transform - named transform or array of transform steps
     * @param {object=} parameters - Object containing properties representing parameters to substitute
     * @returns {Resultset} (this) resultset, or data array if any map or join functions where called
     * @memberof Collection
     */
    Collection.prototype.chain = function (transform, parameters) {
      var rs = new Resultset(this);

      if (typeof transform === 'undefined') {
        return rs;
      }

      return rs.transform(transform, parameters);
    };

    /**
     * Find method, api is similar to mongodb.
     * for more complex queries use [chain()]{@link Collection#chain} or [where()]{@link Collection#where}.
     * @example {@tutorial Query Examples}
     * @param {object} query - 'mongo-like' query object
     * @returns {array} Array of matching documents
     * @memberof Collection
     */
    Collection.prototype.find = function (query) {
      return this.chain().find(query).data();
    };

    /**
     * Find object by unindexed field by property equal to value,
     * simply iterates and returns the first element matching the query
     */
    Collection.prototype.findOneUnindexed = function (prop, value) {
      var i = this.data.length,
        doc;
      while (i--) {
        if (Utils.getIn(this.data[i], prop, true) === value) {
          doc = this.data[i];
          return doc;
        }
      }
      return null;
    };

    /**
     * Transaction methods
     */

    /** start the transation */
    Collection.prototype.startTransaction = function () {
      if (this.transactional) {
        this.cachedData = clone(this.data, this.cloneMethod);
        this.cachedIndex = this.idIndex;
        this.cachedBinaryIndex = this.binaryIndices;
        this.cachedDirtyIds = this.dirtyIds;

        // propagate startTransaction to dynamic views
        for (var idx = 0; idx < this.DynamicViews.length; idx++) {
          this.DynamicViews[idx].startTransaction();
        }
      }
    };

    /** commit the transation */
    Collection.prototype.commit = function () {
      if (this.transactional) {
        this.cachedData = null;
        this.cachedIndex = null;
        this.cachedBinaryIndex = null;
        this.cachedDirtyIds = null;

        // propagate commit to dynamic views
        for (var idx = 0; idx < this.DynamicViews.length; idx++) {
          this.DynamicViews[idx].commit();
        }
      }
    };

    /** roll back the transation */
    Collection.prototype.rollback = function () {
      if (this.transactional) {
        if (this.cachedData !== null && this.cachedIndex !== null) {
          this.data = this.cachedData;
          this.idIndex = this.cachedIndex;
          this.binaryIndices = this.cachedBinaryIndex;
          this.dirtyIds = this.cachedDirtyIds;
        }

        // propagate rollback to dynamic views
        for (var idx = 0; idx < this.DynamicViews.length; idx++) {
          this.DynamicViews[idx].rollback();
        }
      }
    };

    // async executor. This is only to enable callbacks at the end of the execution.
    Collection.prototype.async = function (fun, callback) {
      setTimeout(function () {
        if (typeof fun === 'function') {
          fun();
          callback();
        } else {
          throw new TypeError('Argument passed for async execution is not a function');
        }
      }, 0);
    };

    /**
     * Query the collection by supplying a javascript filter function.
     * @example
     * var results = coll.where(function(obj) {
     *   return obj.legs === 8;
     * });
     *
     * @param {function} fun - filter function to run against all collection docs
     * @returns {array} all documents which pass your filter function
     * @memberof Collection
     */
    Collection.prototype.where = function (fun) {
      return this.chain().where(fun).data();
    };

    /**
     * Map Reduce operation
     *
     * @param {function} mapFunction - function to use as map function
     * @param {function} reduceFunction - function to use as reduce function
     * @returns {data} The result of your mapReduce operation
     * @memberof Collection
     */
    Collection.prototype.mapReduce = function (mapFunction, reduceFunction) {
      try {
        return reduceFunction(this.data.map(mapFunction));
      } catch (err) {
        throw err;
      }
    };

    /**
     * Join two collections on specified properties
     *
     * @param {array|Resultset|Collection} joinData - array of documents to 'join' to this collection
     * @param {string} leftJoinProp - property name in collection
     * @param {string} rightJoinProp - property name in joinData
     * @param {function=} mapFun - (Optional) map function to use
     * @param {object=} dataOptions - options to data() before input to your map function
     * @param {bool} dataOptions.removeMeta - allows removing meta before calling mapFun
     * @param {boolean} dataOptions.forceClones - forcing the return of cloned objects to your map object
     * @param {string} dataOptions.forceCloneMethod - Allows overriding the default or collection specified cloning method.
     * @returns {Resultset} Result of the mapping operation
     * @memberof Collection
     */
    Collection.prototype.eqJoin = function (joinData, leftJoinProp, rightJoinProp, mapFun, dataOptions) {
      // logic in Resultset class
      return new Resultset(this).eqJoin(joinData, leftJoinProp, rightJoinProp, mapFun, dataOptions);
    };

    /* ------ STAGING API -------- */
    /**
     * stages: a map of uniquely identified 'stages', which hold copies of objects to be
     * manipulated without affecting the data in the original collection
     */
    Collection.prototype.stages = {};

    /**
     * (Staging API) create a stage and/or retrieve it
     * @memberof Collection
     */
    Collection.prototype.getStage = function (name) {
      if (!this.stages[name]) {
        this.stages[name] = {};
      }
      return this.stages[name];
    };
    /**
     * a collection of objects recording the changes applied through a commmitStage
     */
    Collection.prototype.commitLog = [];

    /**
     * (Staging API) create a copy of an object and insert it into a stage
     * @memberof Collection
     */
    Collection.prototype.stage = function (stageName, obj) {
      var copy = JSON.parse(JSON.stringify(obj));
      this.getStage(stageName)[obj.$loki] = copy;
      return copy;
    };

    /**
     * (Staging API) re-attach all objects to the original collection, so indexes and views can be rebuilt
     * then create a message to be inserted in the commitlog
     * @param {string} stageName - name of stage
     * @param {string} message
     * @memberof Collection
     */
    Collection.prototype.commitStage = function (stageName, message) {
      var stage = this.getStage(stageName),
        prop,
        timestamp = new Date().getTime();

      for (prop in stage) {

        this.update(stage[prop]);
        this.commitLog.push({
          timestamp: timestamp,
          message: message,
          data: JSON.parse(JSON.stringify(stage[prop]))
        });
      }
      this.stages[stageName] = {};
    };

    Collection.prototype.no_op = function () {
      return;
    };

    /**
     * @memberof Collection
     */
    Collection.prototype.extract = function (field) {
      var i = 0,
        len = this.data.length,
        isDotNotation = isDeepProperty(field),
        result = [];
      for (i; i < len; i += 1) {
        result.push(deepProperty(this.data[i], field, isDotNotation));
      }
      return result;
    };

    /**
     * @memberof Collection
     */
    Collection.prototype.max = function (field) {
      return Math.max.apply(null, this.extract(field));
    };

    /**
     * @memberof Collection
     */
    Collection.prototype.min = function (field) {
      return Math.min.apply(null, this.extract(field));
    };

    /**
     * @memberof Collection
     */
    Collection.prototype.maxRecord = function (field) {
      var i = 0,
        len = this.data.length,
        deep = isDeepProperty(field),
        result = {
          index: 0,
          value: undefined
        },
        max;

      for (i; i < len; i += 1) {
        if (max !== undefined) {
          if (max < deepProperty(this.data[i], field, deep)) {
            max = deepProperty(this.data[i], field, deep);
            result.index = this.data[i].$loki;
          }
        } else {
          max = deepProperty(this.data[i], field, deep);
          result.index = this.data[i].$loki;
        }
      }
      result.value = max;
      return result;
    };

    /**
     * @memberof Collection
     */
    Collection.prototype.minRecord = function (field) {
      var i = 0,
        len = this.data.length,
        deep = isDeepProperty(field),
        result = {
          index: 0,
          value: undefined
        },
        min;

      for (i; i < len; i += 1) {
        if (min !== undefined) {
          if (min > deepProperty(this.data[i], field, deep)) {
            min = deepProperty(this.data[i], field, deep);
            result.index = this.data[i].$loki;
          }
        } else {
          min = deepProperty(this.data[i], field, deep);
          result.index = this.data[i].$loki;
        }
      }
      result.value = min;
      return result;
    };

    /**
     * @memberof Collection
     */
    Collection.prototype.extractNumerical = function (field) {
      return this.extract(field).map(parseBase10).filter(Number).filter(function (n) {
        return !(isNaN(n));
      });
    };

    /**
     * Calculates the average numerical value of a property
     *
     * @param {string} field - name of property in docs to average
     * @returns {number} average of property in all docs in the collection
     * @memberof Collection
     */
    Collection.prototype.avg = function (field) {
      return average(this.extractNumerical(field));
    };

    /**
     * Calculate standard deviation of a field
     * @memberof Collection
     * @param {string} field
     */
    Collection.prototype.stdDev = function (field) {
      return standardDeviation(this.extractNumerical(field));
    };

    /**
     * @memberof Collection
     * @param {string} field
     */
    Collection.prototype.mode = function (field) {
      var dict = {},
        data = this.extract(field);
      data.forEach(function (obj) {
        if (dict[obj]) {
          dict[obj] += 1;
        } else {
          dict[obj] = 1;
        }
      });
      var max,
        prop, mode;
      for (prop in dict) {
        if (max) {
          if (max < dict[prop]) {
            mode = prop;
          }
        } else {
          mode = prop;
          max = dict[prop];
        }
      }
      return mode;
    };

    /**
     * @memberof Collection
     * @param {string} field - property name
     */
    Collection.prototype.median = function (field) {
      var values = this.extractNumerical(field);
      values.sort(sub);

      var half = Math.floor(values.length / 2);

      if (values.length % 2) {
        return values[half];
      } else {
        return (values[half - 1] + values[half]) / 2.0;
      }
    };

    /**
     * General utils, including statistical functions
     */
    function isDeepProperty(field) {
      return field.indexOf('.') !== -1;
    }

    function parseBase10(num) {
      return parseFloat(num, 10);
    }

    function isNotUndefined(obj) {
      return obj !== undefined;
    }

    function add(a, b) {
      return a + b;
    }

    function sub(a, b) {
      return a - b;
    }

    function median(values) {
      values.sort(sub);
      var half = Math.floor(values.length / 2);
      return (values.length % 2) ? values[half] : ((values[half - 1] + values[half]) / 2.0);
    }

    function average(array) {
      return (array.reduce(add, 0)) / array.length;
    }

    function standardDeviation(values) {
      var avg = average(values);
      var squareDiffs = values.map(function (value) {
        var diff = value - avg;
        var sqrDiff = diff * diff;
        return sqrDiff;
      });

      var avgSquareDiff = average(squareDiffs);

      var stdDev = Math.sqrt(avgSquareDiff);
      return stdDev;
    }

    function deepProperty(obj, property, isDeep) {
      if (isDeep === false) {
        // pass without processing
        return obj[property];
      }
      var pieces = property.split('.'),
        root = obj;
      while (pieces.length > 0) {
        root = root[pieces.shift()];
      }
      return root;
    }

    function binarySearch(array, item, fun) {
      var lo = 0,
        hi = array.length,
        compared,
        mid;
      while (lo < hi) {
        mid = (lo + hi) >> 1;
        compared = fun.apply(null, [item, array[mid]]);
        if (compared === 0) {
          return {
            found: true,
            index: mid
          };
        } else if (compared < 0) {
          hi = mid;
        } else {
          lo = mid + 1;
        }
      }
      return {
        found: false,
        index: hi
      };
    }

    function BSonSort(fun) {
      return function (array, item) {
        return binarySearch(array, item, fun);
      };
    }

    function KeyValueStore() { }

    KeyValueStore.prototype = {
      keys: [],
      values: [],
      sort: function (a, b) {
        return (a < b) ? -1 : ((a > b) ? 1 : 0);
      },
      setSort: function (fun) {
        this.bs = new BSonSort(fun);
      },
      bs: function () {
        return new BSonSort(this.sort);
      },
      set: function (key, value) {
        var pos = this.bs(this.keys, key);
        if (pos.found) {
          this.values[pos.index] = value;
        } else {
          this.keys.splice(pos.index, 0, key);
          this.values.splice(pos.index, 0, value);
        }
      },
      get: function (key) {
        return this.values[binarySearch(this.keys, key, this.sort).index];
      }
    };

    function UniqueIndex(uniqueField) {
      this.field = uniqueField;
      this.keyMap = Object.create(null);
      this.lokiMap = Object.create(null);
    }
    UniqueIndex.prototype.keyMap = {};
    UniqueIndex.prototype.lokiMap = {};
    UniqueIndex.prototype.set = function (obj) {
      var fieldValue = obj[this.field];
      if (fieldValue !== null && typeof (fieldValue) !== 'undefined') {
        if (this.keyMap[fieldValue]) {
          throw new Error('Duplicate key for property ' + this.field + ': ' + fieldValue);
        } else {
          this.keyMap[fieldValue] = obj;
          this.lokiMap[obj.$loki] = fieldValue;
        }
      }
    };
    UniqueIndex.prototype.get = function (key) {
      return this.keyMap[key];
    };

    UniqueIndex.prototype.byId = function (id) {
      return this.keyMap[this.lokiMap[id]];
    };
    /**
     * Updates a document's unique index given an updated object.
     * @param  {Object} obj Original document object
     * @param  {Object} doc New document object (likely the same as obj)
     */
    UniqueIndex.prototype.update = function (obj, doc) {
      if (this.lokiMap[obj.$loki] !== doc[this.field]) {
        var old = this.lokiMap[obj.$loki];
        this.set(doc);
        // make the old key fail bool test, while avoiding the use of delete (mem-leak prone)
        this.keyMap[old] = undefined;
      } else {
        this.keyMap[obj[this.field]] = doc;
      }
    };
    UniqueIndex.prototype.remove = function (key) {
      var obj = this.keyMap[key];
      if (obj !== null && typeof obj !== 'undefined') {
        // avoid using `delete`
        this.keyMap[key] = undefined;
        this.lokiMap[obj.$loki] = undefined;
      } else {
        throw new Error('Key is not in unique index: ' + this.field);
      }
    };
    UniqueIndex.prototype.clear = function () {
      this.keyMap = Object.create(null);
      this.lokiMap = Object.create(null);
    };

    function ExactIndex(exactField) {
      this.index = Object.create(null);
      this.field = exactField;
    }

    // add the value you want returned to the key in the index
    ExactIndex.prototype = {
      set: function add(key, val) {
        if (this.index[key]) {
          this.index[key].push(val);
        } else {
          this.index[key] = [val];
        }
      },

      // remove the value from the index, if the value was the last one, remove the key
      remove: function remove(key, val) {
        var idxSet = this.index[key];
        for (var i in idxSet) {
          if (idxSet[i] == val) {
            idxSet.splice(i, 1);
          }
        }
        if (idxSet.length < 1) {
          this.index[key] = undefined;
        }
      },

      // get the values related to the key, could be more than one
      get: function get(key) {
        return this.index[key];
      },

      // clear will zap the index
      clear: function clear(key) {
        this.index = {};
      }
    };

    function SortedIndex(sortedField) {
      this.field = sortedField;
    }

    SortedIndex.prototype = {
      keys: [],
      values: [],
      // set the default sort
      sort: function (a, b) {
        return (a < b) ? -1 : ((a > b) ? 1 : 0);
      },
      bs: function () {
        return new BSonSort(this.sort);
      },
      // and allow override of the default sort
      setSort: function (fun) {
        this.bs = new BSonSort(fun);
      },
      // add the value you want returned  to the key in the index
      set: function (key, value) {
        var pos = binarySearch(this.keys, key, this.sort);
        if (pos.found) {
          this.values[pos.index].push(value);
        } else {
          this.keys.splice(pos.index, 0, key);
          this.values.splice(pos.index, 0, [value]);
        }
      },
      // get all values which have a key == the given key
      get: function (key) {
        var bsr = binarySearch(this.keys, key, this.sort);
        if (bsr.found) {
          return this.values[bsr.index];
        } else {
          return [];
        }
      },
      // get all values which have a key < the given key
      getLt: function (key) {
        var bsr = binarySearch(this.keys, key, this.sort);
        var pos = bsr.index;
        if (bsr.found) pos--;
        return this.getAll(key, 0, pos);
      },
      // get all values which have a key > the given key
      getGt: function (key) {
        var bsr = binarySearch(this.keys, key, this.sort);
        var pos = bsr.index;
        if (bsr.found) pos++;
        return this.getAll(key, pos, this.keys.length);
      },

      // get all vals from start to end
      getAll: function (key, start, end) {
        var results = [];
        for (var i = start; i < end; i++) {
          results = results.concat(this.values[i]);
        }
        return results;
      },
      // just in case someone wants to do something smart with ranges
      getPos: function (key) {
        return binarySearch(this.keys, key, this.sort);
      },
      // remove the value from the index, if the value was the last one, remove the key
      remove: function (key, value) {
        var pos = binarySearch(this.keys, key, this.sort).index;
        var idxSet = this.values[pos];
        for (var i in idxSet) {
          if (idxSet[i] == value) idxSet.splice(i, 1);
        }
        if (idxSet.length < 1) {
          this.keys.splice(pos, 1);
          this.values.splice(pos, 1);
        }
      },
      // clear will zap the index
      clear: function () {
        this.keys = [];
        this.values = [];
      }
    };

    Loki.deepFreeze = deepFreeze;
    Loki.freeze = freeze;
    Loki.unFreeze = unFreeze;
    Loki.LokiOps = LokiOps;
    Loki.Collection = Collection;
    Loki.DynamicView = DynamicView;
    Loki.Resultset = Resultset;
    Loki.KeyValueStore = KeyValueStore;
    Loki.LokiMemoryAdapter = LokiMemoryAdapter;
    Loki.LokiPartitioningAdapter = LokiPartitioningAdapter;
    Loki.LokiLocalStorageAdapter = LokiLocalStorageAdapter;
    Loki.LokiFsAdapter = LokiFsAdapter;
    Loki.persistenceAdapters = {
      fs: LokiFsAdapter,
      localStorage: LokiLocalStorageAdapter
    };
    Loki.aeq = aeqHelper;
    Loki.lt = ltHelper;
    Loki.gt = gtHelper;
    Loki.Comparators = Comparators;
    return Loki;
  }());

}));

}).call(this)}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./loki-indexed-adapter.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/loki-enclave-facade/lib/lokijs/src/loki-indexed-adapter.js","fs":false}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/node-fd-slicer/modules/node-pend/index.js":[function(require,module,exports){
module.exports = Pend;

function Pend() {
  this.pending = 0;
  this.max = Infinity;
  this.listeners = [];
  this.waiting = [];
  this.error = null;
}

Pend.prototype.go = function(fn) {
  if (this.pending < this.max) {
    pendGo(this, fn);
  } else {
    this.waiting.push(fn);
  }
};

Pend.prototype.wait = function(cb) {
  if (this.pending === 0) {
    cb(this.error);
  } else {
    this.listeners.push(cb);
  }
};

Pend.prototype.hold = function() {
  return pendHold(this);
};

function pendHold(self) {
  self.pending += 1;
  var called = false;
  return onCb;
  function onCb(err) {
    if (called) throw new Error("callback called twice");
    called = true;
    self.error = self.error || err;
    self.pending -= 1;
    if (self.waiting.length > 0 && self.pending < self.max) {
      pendGo(self, self.waiting.shift());
    } else if (self.pending === 0) {
      var listeners = self.listeners;
      self.listeners = [];
      listeners.forEach(cbListener);
    }
  }
  function cbListener(listener) {
    listener(self.error);
  }
}

function pendGo(self, fn) {
  fn(pendHold(self));
}

},{}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/anchoring/RemotePersistence.js":[function(require,module,exports){
const {SmartUrl} = require("../utils");

function RemotePersistence() {
    const openDSU = require("opendsu");
    const keySSISpace = openDSU.loadAPI("keyssi");
    const promiseRunner = require("../utils/promise-runner");

    const getAnchoringServices = (dlDomain, callback) => {
        const bdns = openDSU.loadAPI("bdns");
        bdns.getAnchoringServices(dlDomain, (err, anchoringServicesArray) => {
            if (err) {
                return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to get anchoring services from bdns`, err));
            }

            if (!anchoringServicesArray.length) {
                return callback('No anchoring service provided');
            }

            callback(undefined, anchoringServicesArray);
        });
    }

    const updateAnchor = (anchorSSI, anchorValue, anchorAction, callback) => {
        if (typeof anchorSSI === "string") {
            try {
                anchorSSI = keySSISpace.parse(anchorSSI);
            } catch (e) {
                return callback(e);
            }
        }

        if (typeof anchorValue === "string") {
            try {
                anchorValue = keySSISpace.parse(anchorValue);
            } catch (e) {
                return callback(e);
            }
        }

        const dlDomain = anchorSSI.getDLDomain();
        anchorSSI.getAnchorId((err, anchorId) => {
            if (err) {
                return callback(err);
            }

            getAnchoringServices(dlDomain, (err, anchoringServicesArray) => {
                if (err) {
                    return callback(err);
                }

                const anchorHandler = getAnchorHandler(anchorId, anchorValue.getIdentifier(), dlDomain, anchorAction);
                promiseRunner.runOneSuccessful(anchoringServicesArray, anchorHandler, callback, new Error(`Failed during execution of ${anchorAction}`));
            })
        })
    }

    const getAnchorHandler = (anchorId, anchorValue, dlDomain, anchorAction) => {
        return function (service) {
            return new Promise((resolve, reject) => {
                let smartUrl = new SmartUrl(service);
                smartUrl = smartUrl.concatWith(`/anchor/${dlDomain}/${anchorAction}/${anchorId}/${anchorValue}`);

                const putResult = smartUrl.doPut("", (err, data) => {
                    if (err) {
                        return reject({
                            statusCode: err.statusCode,
                            message: err.statusCode === 428 ? 'Unable to add alias: versions out of sync' : err.message || 'Error'
                        });
                    }
                    resolve(data);
                });
                if (putResult) {
                    putResult.then(resolve).catch(reject);
                }
            })
        }
    };

    this.createAnchor = (capableOfSigningKeySSI, anchorValue, callback) => {
        updateAnchor(capableOfSigningKeySSI, anchorValue, "create-anchor", callback);
    }

    this.appendAnchor = (capableOfSigningKeySSI, anchorValue, callback) => {
        updateAnchor(capableOfSigningKeySSI, anchorValue, "append-to-anchor", callback);
    }

    const getFetchAnchor = (anchorId, dlDomain, actionName) => {
        return function (service) {
            return new Promise((resolve, reject) => {

                let smartUrl = new SmartUrl(service);
                smartUrl = smartUrl.concatWith(`/anchor/${dlDomain}/${actionName}/${anchorId}`);

                smartUrl.doGet((err, data) => {
                    if (err) {
                        if(err.rootCause === require("./../moduleConstants").ERROR_ROOT_CAUSE.MISSING_DATA_ERROR){
                            return resolve();
                        }
                        return reject(err);
                    }

                    if(actionName === "get-all-versions"){
                        if(data === ""){
                            return resolve();
                        }
                    }

                    try {
                        data = JSON.parse(data);
                    } catch (e) {
                        return reject(e);
                    }

                    if (actionName === "get-last-version") {
                        data = data.message;
                    }
                    return resolve(data);
                });
            })
        }
    }

    const getAnchorValues = (keySSI, actionName, callback) => {
        if (typeof keySSI === "string") {
            try {
                keySSI = keySSISpace.parse(keySSI);
            } catch (e) {
                return callback(e);
            }
        }

        const dlDomain = keySSI.getDLDomain();
        keySSI.getAnchorId((err, anchorId) => {
            if (err) {
                return callback(err);
            }
            getAnchoringServices(dlDomain, (err, anchoringServicesArray) => {
                if (err) {
                    return callback(err);
                }

                const fetchAnchor = getFetchAnchor(anchorId, dlDomain, actionName, callback);
                promiseRunner.runOneSuccessful(anchoringServicesArray, fetchAnchor, callback, new Error("get Anchoring Service"));
            })
        });
    }

    this.getAllVersions = (keySSI, callback) => {
        getAnchorValues(keySSI, "get-all-versions", callback);
    }

    this.getLastVersion = (keySSI, callback) => {
        getAnchorValues(keySSI, "get-last-version", callback);
    }

    this.createOrUpdateMultipleAnchors = (anchors, callback) => {
        let smartUrl = new SmartUrl();
        smartUrl = smartUrl.concatWith(`/anchor/create-or-update-multiple-anchors`);

        smartUrl.doPut(JSON.stringify(anchors), (err, data) => {
            if (err) {
                return callback(err);
            }

            return callback(undefined, data);
        });
    }
}

module.exports = RemotePersistence;

},{"../utils":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/utils/index.js","../utils/promise-runner":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/utils/promise-runner.js","./../moduleConstants":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/moduleConstants.js","opendsu":"opendsu"}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/anchoring/anchoringAbstractBehaviour.js":[function(require,module,exports){
const {createOpenDSUErrorWrapper} = require("../error");
const fakeHistory = {};
const fakeLastVersion = {};

function AnchoringAbstractBehaviour(persistenceStrategy) {
    const self = this;
    const keySSISpace = require("opendsu").loadAPI("keyssi");

    self.createAnchor = function (anchorId, anchorValueSSI, callback) {
        if (typeof anchorId === 'undefined' || typeof anchorValueSSI === 'undefined' || anchorId === null || anchorValueSSI === null) {
            return callback(Error(`Invalid call for create anchor ${anchorId}:${anchorValueSSI}`));
        }
        //convert to keySSI
        let anchorIdKeySSI = anchorId;
        if (typeof anchorId === "string") {
            anchorIdKeySSI = keySSISpace.parse(anchorId);
        }
        let anchorValueSSIKeySSI = anchorValueSSI;
        if (typeof anchorValueSSI === "string") {
            anchorValueSSIKeySSI = keySSISpace.parse(anchorValueSSI);
        }

        anchorIdKeySSI.getAnchorId((err, _anchorId) => {
            if (err) {
                return callback(err);
            }

            let fakeLastVersionForAnchorId = fakeLastVersion[_anchorId];
            if(fakeLastVersionForAnchorId){
                unmarkAnchorForRecovery(_anchorId);
                return callback(undefined);
            }

            if (!anchorIdKeySSI.canAppend()) {
                return persistenceStrategy.createAnchor(_anchorId, anchorValueSSIKeySSI.getIdentifier(), callback);
            }

            const signer = determineSigner(anchorIdKeySSI, []);
            const signature = anchorValueSSIKeySSI.getSignature();
            const dataToVerify = anchorValueSSIKeySSI.getDataToSign(anchorIdKeySSI, null);
            if (!signer.verify(dataToVerify, signature)) {
                return callback(Error("Failed to verify signature"));
            }
            persistenceStrategy.createAnchor(_anchorId, anchorValueSSIKeySSI.getIdentifier(), callback);
        });
    }

    self.appendAnchor = function (anchorId, anchorValueSSI, callback) {
        const __appendAnchor = () => {
            if (typeof anchorId === 'undefined' || typeof anchorValueSSI === 'undefined' || anchorId === null || anchorValueSSI === null) {
                return callback(Error(`Invalid call for append anchor ${anchorId}:${anchorValueSSI}`));
            }
            //convert to keySSI
            let anchorIdKeySSI = anchorId;
            if (typeof anchorId === "string") {
                anchorIdKeySSI = keySSISpace.parse(anchorId);
            }
            let anchorValueSSIKeySSI = anchorValueSSI;
            if (typeof anchorValueSSI === "string") {
                anchorValueSSIKeySSI = keySSISpace.parse(anchorValueSSI);
            }

            if (!anchorIdKeySSI.canAppend()) {
                return callback(Error(`Cannot append anchor for ${anchorId} because of the keySSI type`));
            }

            anchorIdKeySSI.getAnchorId((err, _anchorId) => {
                if (err) {
                    return callback(err);
                }

                let verifySignaturesAndAppend = (err, data) => {
                    // throw Error("Get all versions callback");
                    if (err) {
                        return callback(err);
                    }
                    if (typeof data === 'undefined' || data === null) {
                        data = [];
                    }

                    if(!self.testIfRecoveryActiveFor(_anchorId)){
                        const historyOfKeySSI = data.map(el => keySSISpace.parse(el));
                        const signer = determineSigner(anchorIdKeySSI, historyOfKeySSI);
                        const signature = anchorValueSSIKeySSI.getSignature();
                        if (typeof data[data.length - 1] === 'undefined') {
                            return callback(`Cannot update non existing anchor ${anchorId}`);
                        }
                        const lastSignedHashLinkKeySSI = keySSISpace.parse(data[data.length - 1]);
                        if (parseInt(anchorValueSSIKeySSI.getTimestamp()) < parseInt(lastSignedHashLinkKeySSI.getTimestamp())) {
                            return callback({
                                statusCode: 409,
                                code: 409,
                                message: "Anchor value timestamp is older than the last signed hashlink timestamp"
                            });
                        }
                        const dataToVerify = anchorValueSSIKeySSI.getDataToSign(anchorIdKeySSI, lastSignedHashLinkKeySSI);
                        if (!signer.verify(dataToVerify, signature)) {
                            return callback({statusCode: 428, code: 428, message: "Versions out of sync"});
                        }
                    }

                    persistenceStrategy.appendAnchor(_anchorId, anchorValueSSIKeySSI.getIdentifier(), (err, res)=>{
                        unmarkAnchorForRecovery(_anchorId);
                        callback(err, res);
                    });
                }

                let fakeHistoryAvailable = fakeHistory[_anchorId];
                if(fakeHistoryAvailable){
                    return verifySignaturesAndAppend(undefined, fakeHistoryAvailable);
                }

                persistenceStrategy.getAllVersions(anchorId, verifySignaturesAndAppend)
            });
        }

        if (typeof persistenceStrategy.prepareAnchoring === "function") {
            persistenceStrategy.prepareAnchoring(anchorId, err => {
                if (err) {
                    return callback(err);
                }
                __appendAnchor();
            });
        } else {
            __appendAnchor();
        }
    }

    self.getAllVersions = function (anchorId, options, callback) {
        if(typeof options === "function"){
            callback = options;
            options = undefined;
        }

        if(!options){
            options = {};
        }

        let anchorIdKeySSI = anchorId;
        if (typeof anchorId === "string") {
            anchorIdKeySSI = keySSISpace.parse(anchorId);
        }

        anchorIdKeySSI.getAnchorId((err, anchorId) => {
            if (err) {
                return callback(err);
            }


            if(!options.realHistory){
                let fakeHistoryAvailable = fakeHistory[anchorId];
                if(fakeHistoryAvailable){
                    return callback(undefined, fakeHistoryAvailable);
                }
            }

            persistenceStrategy.getAllVersions(anchorId, (err, data) => {
                if (err) {
                    return callback(err);
                }
                if (typeof data === 'undefined' || data.length === 0) {
                    return callback(undefined, []);
                }
                if (!anchorIdKeySSI.canAppend()) {
                    //skip validation for non signing SSI
                    let anchorValues;
                    try {
                        anchorValues = data.map(el => keySSISpace.parse(el));
                    } catch (e) {
                        return callback(e);
                    }
                    return callback(undefined, anchorValues);
                }
                const historyOfKeySSI = data.map(el => keySSISpace.parse(el));
                const config = require("opendsu").loadApi("config");
                const trustLevel = config.get("trustLevel");
                if(trustLevel === 0){
                    const progressiveHistoryOfKeySSI = [];
                    let previousSignedHashLinkKeySSI = null;
                    for (let i = 0; i <= historyOfKeySSI.length - 1; i++) {
                        const anchorValueSSIKeySSI = historyOfKeySSI[i];
                        const signer = determineSigner(anchorIdKeySSI, progressiveHistoryOfKeySSI);
                        const signature = anchorValueSSIKeySSI.getSignature();
                        const dataToVerify = anchorValueSSIKeySSI.getDataToSign(anchorIdKeySSI, previousSignedHashLinkKeySSI);
                        if (!signer.verify(dataToVerify, signature)) {
                            return callback(Error("Failed to verify signature"));
                        }
                        //build history
                        progressiveHistoryOfKeySSI.push(anchorValueSSIKeySSI);
                        previousSignedHashLinkKeySSI = anchorValueSSIKeySSI;
                    }
                }

                //all history was validated
                return callback(undefined, historyOfKeySSI);
            });
        });
    }

    self.getLastVersion = function (anchorId, callback) {
        let anchorIdKeySSI = anchorId;
        if (typeof anchorId === "string") {
            anchorIdKeySSI = keySSISpace.parse(anchorId);
        }

        anchorIdKeySSI.getAnchorId((err, anchorId) => {
            if (err) {
                return callback(err);
            }

            let fakeLastVersionForAnchorId = fakeLastVersion[anchorId];
            if(fakeLastVersionForAnchorId){
                return callback(undefined, fakeLastVersionForAnchorId);
            }

            persistenceStrategy.getLastVersion(anchorId, (err, data) => {
                if (err) {
                    return callback(err);
                }
                if (typeof data === 'undefined' || data === null || data === "") {
                    return callback();
                }

                let anchorValueSSI;
                try {
                    anchorValueSSI = keySSISpace.parse(data);
                } catch (e) {
                    return callback(createOpenDSUErrorWrapper("Failed to parse anchor value", e));
                }
                callback(undefined, anchorValueSSI);
            });
        });
    }

    self.markAnchorForRecovery = function(anchorId, anchorFakeHistory, anchorFakeLastVersion){
        fakeHistory[anchorId] = anchorFakeHistory;
        fakeLastVersion[anchorId] = anchorFakeLastVersion;
    }

    let unmarkAnchorForRecovery = function(anchorId){
        fakeHistory[anchorId] = undefined;
        delete fakeHistory[anchorId];
        fakeLastVersion[anchorId] = undefined;
        delete fakeLastVersion[anchorId];
    }

    self.testIfRecoveryActiveFor = function(anchorId){
        return !!fakeHistory[anchorId];
    }

    function determineSigner(anchorIdKeySSI, historyOfKeySSIValues) {
        const {wasTransferred, signer} = wasHashLinkTransferred(historyOfKeySSIValues);
        if (wasTransferred) {
            return signer;
        }
        return anchorIdKeySSI;
    }

    function wasHashLinkTransferred(historyOfKeySSIValues) {
        if (!Array.isArray(historyOfKeySSIValues)) {
            throw `hashLinks is not Array. Received ${historyOfKeySSIValues}`;
        }
        for (let i = historyOfKeySSIValues.length - 1; i >= 0; i--) {
            let hashLinkSSI = historyOfKeySSIValues[i];
            if (hashLinkSSI.isTransfer()) {
                return {
                    wasTransferred: true, signVerifier: hashLinkSSI
                };
            }
        }
        return {
            wasTransferred: false, signVerifier: undefined
        }
    }
}


module.exports = {
    AnchoringAbstractBehaviour
}

},{"../error":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/error/index.js","opendsu":"opendsu"}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/anchoring/index.js":[function(require,module,exports){
const openDSU = require("opendsu")
const utils = openDSU.loadAPI("utils");
const SmartUrl = utils.SmartUrl;
const constants = openDSU.constants;
const promiseRunner = utils.promiseRunner;

const getAnchoringBehaviour = (persistenceStrategy) => {
    const Aab = require('./anchoringAbstractBehaviour').AnchoringAbstractBehaviour;
    return new Aab(persistenceStrategy);
};

/**
 * Add new version
 * @param {keySSI} SSICapableOfSigning
 * @param {hashLinkSSI} newSSI
 * @param {hashLinkSSI} lastSSI
 * @param {string} zkpValue
 * @param {string} digitalProof
 * @param {function} callback
 */
const addVersion = (SSICapableOfSigning, newSSI, lastSSI, zkpValue, callback) => {
    if (typeof newSSI === "function") {
        callback = newSSI;
        newSSI = undefined;
        lastSSI = undefined;
        zkpValue = '';
    }

    if (typeof lastSSI === "function") {
        callback = lastSSI;
        lastSSI = undefined;
        zkpValue = '';
    }

    if (typeof zkpValue === "function") {
        callback = zkpValue;
        zkpValue = '';
    }

    const dlDomain = SSICapableOfSigning.getDLDomain();
    SSICapableOfSigning.getAnchorId((err, anchorId) => {
        if (err) {
            return callback(err);
        }

        // if (dlDomain === constants.DOMAINS.VAULT && isValidVaultCache()) {
        //     return cachedAnchoring.addVersion(anchorId, newSSI ? newSSI.getIdentifier() : undefined, callback);
        // }

        const bdns = require("../bdns");
        bdns.getAnchoringServices(dlDomain, (err, anchoringServicesArray) => {
            if (err) {
                return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to get anchoring services from bdns`, err));
            }

            if (!anchoringServicesArray.length) {
                return callback('No anchoring service provided');
            }

            const hashLinkIds = {
                last: lastSSI ? lastSSI.getIdentifier() : null,
                new: newSSI ? newSSI.getIdentifier() : null
            };

            createDigitalProof(SSICapableOfSigning, hashLinkIds.new, hashLinkIds.last, zkpValue, (err, digitalProof) => {
                const body = {
                    hashLinkIds,
                    digitalProof,
                    zkp: zkpValue
                };

                const anchorAction = newSSI ? "append-to-anchor" : "create-anchor";

                const addAnchor = (service) => {
                    return new Promise((resolve, reject) => {

                        let smartUrl = new SmartUrl(service);
                        smartUrl = smartUrl.concatWith(`/anchor/${dlDomain}/${anchorAction}/${anchorId}`);

                        const putResult = smartUrl.doPut(JSON.stringify(body), (err, data) => {
                            if (err) {
                                return reject({
                                    statusCode: err.statusCode,
                                    message: err.statusCode === 428 ? 'Unable to add alias: versions out of sync' : err.message || 'Error'
                                });
                            }

                            require("opendsu").loadApi("resolver").invalidateDSUCache(SSICapableOfSigning, err=>{
                                if (err) {
                                    return reject(err);
                                }
                                return resolve(data);
                            });
                        });
                        if (putResult) {
                            putResult.then(resolve).catch(reject);
                        }
                    })
                };

                promiseRunner.runOneSuccessful(anchoringServicesArray, addAnchor, callback, new Error(`Failed during execution of ${anchorAction}`));
            });
        });
    });
};

function createDigitalProof(SSICapableOfSigning, newSSIIdentifier, lastSSIIdentifier, zkp, callback) {
    // when the anchor is first created, no version is created yet
    if (!newSSIIdentifier) {
        newSSIIdentifier = "";
    }

    SSICapableOfSigning.getAnchorId((err, anchorId) => {
        if (err) {
            return callback(err);
        }
        let dataToSign = anchorId + newSSIIdentifier + zkp;
        if (lastSSIIdentifier) {
            dataToSign += lastSSIIdentifier;
        }

        if (SSICapableOfSigning.getTypeName() === constants.KEY_SSIS.CONST_SSI || SSICapableOfSigning.getTypeName() === constants.KEY_SSIS.ARRAY_SSI || SSICapableOfSigning.getTypeName() === constants.KEY_SSIS.WALLET_SSI) {
            return callback(undefined, {signature: "", publicKey: ""});
        }

        return SSICapableOfSigning.sign(dataToSign, callback);
    });
}

const callContractMethod = (domain, method, ...args) => {
    const callback = args.pop();
    const contracts = require("opendsu").loadApi("contracts");
    contracts.callContractMethod(domain, "anchoring", method, args, callback);
}

const createNFT = (nftKeySSI, callback) => {
    addVersion(nftKeySSI, callback)
}

const transferTokenOwnership = (nftKeySSI, ownershipSSI, callback) => {
    // TODO: to be implemented
    callContractMethod(domain, "transferTokenOwnership", ...args);
}

const getLatestVersion = (domain, ...args) => {
    // TODO: to be implemented
    callContractMethod(domain, "getLatestVersion", ...args);
}


function getAnchoringX(){
    //todo: See below
    //return anchoring behaviour using the persistence as apihub calls
    //execute the integration testing using the extended FS implementation (fsx)
    const RemotePersistence = require("./RemotePersistence");
    return getAnchoringBehaviour(new RemotePersistence());
}

async function getNextVersionNumberAsync(keySSI){
    const keySSISpace = require("opendsu").loadApi("keyssi");
    if(typeof keySSI === "string"){
        keySSI = keySSISpace.parse(keySSI);
    }
    const anchoringX = getAnchoringX();
    let nextVersion = 0;
    let anchorId = await $$.promisify(keySSI.getAnchorId)();
    try{
        let versions = await $$.promisify(anchoringX.getAllVersions)(anchorId, {realHistory: true});
        if(versions){
            nextVersion = versions.length;
        }else{
            //if !versions we know that is our first version
        }
    }catch(err){
        throw err;
    }

    return nextVersion+1;
}

module.exports = {
/*    createAnchor,*/
    createNFT,
/*    appendToAnchor,*/
    transferTokenOwnership,
    /*getAllVersions,
    getLastVersion,
    getLatestVersion,*/
    getAnchoringBehaviour,
    getAnchoringX,
    getAnchoringImplementation:getAnchoringX,
    getNextVersionNumberAsync
}

},{"../bdns":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/bdns/index.js","./RemotePersistence":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/anchoring/RemotePersistence.js","./anchoringAbstractBehaviour":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/anchoring/anchoringAbstractBehaviour.js","opendsu":"opendsu"}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/apiKey/APIKeysClient.js":[function(require,module,exports){
function APIKeysClient(baseUrl) {
    const openDSU = require("opendsu");
    const systemAPI = openDSU.loadAPI("system");
    const BASE_URL = baseUrl || systemAPI.getBaseURL();

    const _sendRequest = async (endpoint, method, data, headers) => {
        if (typeof data === "object") {
            data = JSON.stringify(data);
        }

        const options = {
            method,
            headers,
            body: data
        }

        if (method === "GET" || method === "DELETE") {
            delete options.body;
        }

        const response = await fetch(`${BASE_URL}${endpoint}`, options);
        if(!response.ok){
            throw new Error(`Failed to fetch ${endpoint} with status ${response.status}`);
        }
        return response.text();
    }

    this.becomeSysAdmin = async (apiKey, headers) => {
        return await _sendRequest(`/becomeSysAdmin`, "PUT", apiKey, headers);
    }

    this.makeSysAdmin = async (userId, apiKey, headers) => {
        return await _sendRequest(`/makeSysAdmin/${encodeURIComponent(userId)}`, "PUT", apiKey, headers);
    }

    this.deleteAdmin = async (userId, headers) => {
        return await _sendRequest(`/deleteAdmin/${encodeURIComponent(userId)}`, "DELETE", undefined, headers);
    }

    this.associateAPIKey = async (appName, name, userId, apiKey, headers) => {
        return await _sendRequest(`/associateAPIKey/${encodeURIComponent(appName)}/${encodeURIComponent(name)}/${encodeURIComponent(userId)}`, "PUT", apiKey, headers);
    }

    this.deleteAPIKey = async (appName, name, userId, headers) => {
        return await _sendRequest(`/deleteAPIKey/${encodeURIComponent(appName)}/${encodeURIComponent(name)}/${encodeURIComponent(userId)}`, "DELETE", undefined, headers);
    }

    this.getAPIKey = async (appName, name, userId, headers) => {
        return await _sendRequest(`/getAPIKey/${encodeURIComponent(appName)}/${encodeURIComponent(name)}/${encodeURIComponent(userId)}`, "GET", undefined, headers);
    }
}

module.exports = APIKeysClient;
},{"opendsu":"opendsu"}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/apiKey/index.js":[function(require,module,exports){
const getAPIKeysClient = (url) => {
    const APIKeyClient = require("./APIKeysClient");
    return new APIKeyClient(url);
}

module.exports = {
    getAPIKeysClient
}
},{"./APIKeysClient":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/apiKey/APIKeysClient.js"}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/bdns/index.js":[function(require,module,exports){
const PendingCallMixin = require("../utils/PendingCallMixin");
const getBaseURL = require("../utils/getBaseURL");

function BDNS() {
    PendingCallMixin(this);
    let bdnsCache;
    const http = require("opendsu").loadApi("http");
    let isInitialized = false;

    let retrieveHosts = () => {
        const url = `${getBaseURL()}/bdns#x-blockchain-domain-request`;
        http.fetch(url)
            .then((response) => {
                return response.json()
            }).then((bdnsHosts) => {
            bdnsHosts = JSON.stringify(bdnsHosts);
            bdnsHosts = bdnsHosts.replace(/\$ORIGIN/g, getBaseURL());
            bdnsCache = JSON.parse(bdnsHosts);
            isInitialized = true;
            this.executePendingCalls();
        }).catch((err) => {
            console.error("Failed to retrieve BDNS hosts", err);
            throw err;
        })
    };

    retrieveHosts();

    const getSection = (dlDomain, section, callback) => {
        function load_or_default() {
            if (typeof dlDomain === "undefined") {
                return callback(Error(`The provided domain is undefined`));
            }

            if(typeof bdnsCache[dlDomain] === "undefined"){
                return callback(Error(`BDNS: The provided domain <${dlDomain}> is not configured. Check if the domain name is correct and if BDNS contains info for this specific domain.`));
            }

            const config = bdnsCache[dlDomain][section] ? bdnsCache[dlDomain][section] : [getBaseURL()];
            callback(undefined, config);
        }

        if (!isInitialized) {
            return this.addPendingCall(() => {
                if (dlDomain === undefined) {
                    return callback(new Error("The domain is not defined"));
                }
                return load_or_default();
            })
        }
        if (dlDomain === undefined) {
            return callback(new Error("The domain is not defined"));
        }
        load_or_default();
    }

    this.getRawInfo = (dlDomain, callback) => {

        if(dlDomain && typeof dlDomain === "function"){
            callback = dlDomain;
            dlDomain = null;
        }

        if (!isInitialized) {
            return this.addPendingCall(() => {
                callback(undefined, dlDomain ? bdnsCache[dlDomain] : bdnsCache);
            })
        }
        callback(undefined, dlDomain ? bdnsCache[dlDomain] : bdnsCache);
    };

    this.getBrickStorages = (dlDomain, callback) => {
        getSection(dlDomain, "brickStorages", callback);
    };

    this.getAnchoringServices = (dlDomain, callback) => {
        getSection(dlDomain, "anchoringServices", callback);
    };

    this.getContractServices = (dlDomain, callback) => {
        getSection(dlDomain, "contractServices", callback);
    };

    this.getReplicas = (dlDomain, callback) => {
        getSection(dlDomain, "replicas", callback);
    };

    this.getNotificationEndpoints = (dlDomain, callback) => {
        getSection(dlDomain, "notifications", callback);
    }

    this.getMQEndpoints = (dlDomain, callback) => {
        getSection(dlDomain, "mqEndpoints", callback);
    }

    this.setBDNSHosts = (bdnsHosts) => {
        isInitialized = true;
        bdnsCache = bdnsHosts;
    }


    this.getOrigin = () => {
        return getBaseURL();
    };

    // returns the origin placeholder (value that will be used to define the generic origin)
    this.getOriginPlaceholder = () => {
        return "ORIGIN";
    };
    this.getOriginUrl = getBaseURL;
}


module.exports = new BDNS();

},{"../utils/PendingCallMixin":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/utils/PendingCallMixin.js","../utils/getBaseURL":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/utils/getBaseURL.js","opendsu":"opendsu"}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/boot/BootEngine.js":[function(require,module,exports){
(function (global){(function (){
function BootEngine(getKeySSI) {
    if (typeof getKeySSI !== "function") {
        throw new Error("getSeed missing or not a function");
    }
    getKeySSI = promisify(getKeySSI);

    const openDSU = require("opendsu");
    const { constants } = openDSU;
    const resolver = openDSU.loadApi("resolver");
    const pskPath = require("swarmutils").path;

    const evalBundles = async (bundles, ignore) => {
        const listFiles = promisify(this.rawDossier.listFiles);
        const readFile = promisify(this.rawDossier.readFile);

        let fileList = await listFiles(constants.CONSTITUTION_FOLDER);
        fileList = bundles
            .filter((bundle) => fileList.includes(bundle) || fileList.includes(`/${bundle}`))
            .map((bundle) => pskPath.join(constants.CONSTITUTION_FOLDER, bundle));

        if (fileList.length !== bundles.length) {
            const message = `Some bundles missing. Expected to have ${JSON.stringify(
                bundles
            )} but got only ${JSON.stringify(fileList)}`;
            if (!ignore) {
                throw new Error(message);
            } else {
                console.log(message);
            }
        }

        for (let i = 0; i < fileList.length; i++) {
            var fileContent = await readFile(fileList[i]);
            try {
                eval(fileContent.toString());
            } catch (e) {
                console.log("Failed to eval file", fileList[i], e);
            }
        }
    };

    this.boot = function (callback) {
        const __boot = async () => {
            const keySSI = await getKeySSI();
            const loadRawDossier = promisify(resolver.loadDSU);
            try {
                this.rawDossier = await loadRawDossier(keySSI);
                global.rawDossier = this.rawDossier;
            } catch (err) {
                console.log(err);
                return callback(err);
            }

            const listFiles = promisify(this.rawDossier.listFiles);
            const readFile = promisify(this.rawDossier.readFile);

            let isBootFilePresent;
            let bootConfig;
            try {
                let allFiles = await listFiles(constants.CODE_FOLDER);
                console.log("allFiles", allFiles);
                isBootFilePresent = allFiles.some((file) => file === constants.BOOT_CONFIG_FILE);
                if (isBootFilePresent) {
                    const bootConfigFile = `${constants.CODE_FOLDER}/${constants.BOOT_CONFIG_FILE}`;
                    let bootConfigfileContent = await readFile(bootConfigFile);
                    bootConfig = JSON.parse(bootConfigfileContent.toString());
                }
            } catch (error) {
                console.error("Cannot check boot config file", error);
                return callback(error);
            }

            if (!isBootFilePresent || !bootConfig) {
                return;
            }

            const { runtimeBundles, constitutionBundles } = bootConfig;

            if (typeof runtimeBundles !== "undefined" && !Array.isArray(runtimeBundles)) {
                return callback(new Error("runtimeBundles is not array"));
            }

            if (typeof constitutionBundles !== "undefined" && !Array.isArray(constitutionBundles)) {
                return callback(new Error("constitutionBundles is not array"));
            }

            try {
                await evalBundles(runtimeBundles);
            } catch (err) {
                if (err.type !== "PSKIgnorableError") {
                    console.log(err);
                    return callback(err);
                }
            }

            if (typeof constitutionBundles !== "undefined") {
                try {
                    await evalBundles(constitutionBundles, true);
                } catch (err) {
                    console.log(err);
                    return callback(err);
                }
            }
        };

        __boot()
            .then(() => callback(undefined, this.rawDossier))
            .catch(callback);
    };
}

function promisify(fn) {
    return function (...args) {
        return new Promise((resolve, reject) => {
            fn(...args, (err, ...res) => {
                if (err) {
                    console.log(err);
                    reject(err);
                } else {
                    resolve(...res);
                }
            });
        });
    };
}

module.exports = BootEngine;

}).call(this)}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"opendsu":"opendsu","swarmutils":"swarmutils"}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/boot/NodeBootScript.js":[function(require,module,exports){
function boot(keySSI) {
    $$.LEGACY_BEHAVIOUR_ENABLED = true;
    const worker_threads = "worker_threads";
    const { parentPort } = require(worker_threads);
    const { handleMessage } = require("./boot-utils.js");

    parentPort.on("message", (message) => {
        handleMessage(message, (error, result) => {
            parentPort.postMessage({ error, result });
        });
    });

    process.on("uncaughtException", (err) => {
        console.error("[worker] unchaughtException inside worker", err);
        setTimeout(() => {
            process.exit(1);
        }, 100);
    });

    function getKeySSI(callback) {
        callback(null, keySSI);
    }

    const BootEngine = require("./BootEngine.js");

    console.log(`[worker] booting DSU for keySSI ${keySSI}...`);

    const booter = new BootEngine(getKeySSI);

    booter.boot((error) => {
        if (error) {
            parentPort.postMessage({ error });
            throw error;
        }

        console.log("[worker] ready");
        parentPort.postMessage("ready");
    });
}

module.exports = boot;

},{"./BootEngine.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/boot/BootEngine.js","./boot-utils.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/boot/boot-utils.js"}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/boot/WorkerBootScript.js":[function(require,module,exports){
function boot(keySSI) {
    $$.LEGACY_BEHAVIOUR_ENABLED = true;
    const { handleMessage } = require("./boot-utils.js");

    onmessage = (message) => {
        handleMessage(message.data, (error, result) => {
            postMessage({ error, result });
        });
    };

    function getKeySSI(callback) {
        callback(null, keySSI);
    }

    const BootEngine = require("./BootEngine.js");

    console.log(`[worker] booting DSU for keySSI ${keySSI}...`);

    const booter = new BootEngine(getKeySSI);

    booter.boot((error) => {
        if (error) {
            postMessage({ error });
            throw error;
        }

        console.log("[worker] ready");
        postMessage("ready");
    });
}

module.exports = boot;

},{"./BootEngine.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/boot/BootEngine.js","./boot-utils.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/boot/boot-utils.js"}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/boot/boot-utils.js":[function(require,module,exports){
function handleMessage(message, onHandleMessage) {
    // console.log("[worker] Received message", message);

    const { fn, api, args } = message;
    const callback = (error, result) => {
        console.log(`[worker] finished work ${message}`, error, result);

         // in order to ensure result serializability we JSON.stringify it if isn't a Buffer
         if (!$$.Buffer.isBuffer(result)) {
            result = JSON.stringify(result);
        }

        onHandleMessage(error, result);
    };
    try {
        const dsuArgs = [...args, callback];

        if (api) {
            // need to call the DSU's api.js method
            this.rawDossier.call(api, ...dsuArgs);
            return;
        }

        if (fn) {
            this.rawDossier[fn].apply(this.rawDossier, dsuArgs);
            return;
        }

        callback(new Error(`Received unknown task: ${JSON.stringify(message)}`));
    } catch (error) {
        onHandleMessage(error);
    }
}

module.exports = {
    handleMessage,
};

},{}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/boot/index.js":[function(require,module,exports){
let { ENVIRONMENT_TYPES } = require("../moduleConstants.js");

function getBootScript() {
    switch ($$.environmentType) {
        case ENVIRONMENT_TYPES.WEB_WORKER_ENVIRONMENT_TYPE:
            return require("./WorkerBootScript");
        case ENVIRONMENT_TYPES.NODEJS_ENVIRONMENT_TYPE:
            return require("./NodeBootScript");
        default:
            throw new Error(`Current environment ${$$.environmentType} doesn't support opendsu boot script!`);
    }
}

module.exports = getBootScript();

},{"../moduleConstants.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/moduleConstants.js","./NodeBootScript":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/boot/NodeBootScript.js","./WorkerBootScript":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/boot/WorkerBootScript.js"}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/bricking/index.js":[function(require,module,exports){
const openDSU = require("opendsu");
const constants = require("../moduleConstants");
const cache = require("../cache/").getCacheForVault(constants.CACHE.ENCRYPTED_BRICKS_CACHE);
const promiseRunner = require("../utils/promise-runner");
const {SmartUrl} = require("../utils");

const isValidBrickHash = (hashLinkSSI, brickData) => {
    const ensureIsBuffer = require("swarmutils").ensureIsBuffer;
    const crypto = openDSU.loadAPI("crypto");
    const hashFn = crypto.getCryptoFunctionForKeySSI(hashLinkSSI, "hash");
    const actualHash = hashFn(ensureIsBuffer(brickData));
    const expectedHash = hashLinkSSI.getHash();
    return actualHash === expectedHash;
}

const brickExistsOnServer = (hashLinkSSI, callback) => {
    const dlDomain = hashLinkSSI.getDLDomain();
    const brickHash = hashLinkSSI.getHash();
    const bdns = openDSU.loadApi("bdns");
    bdns.getBrickStorages(dlDomain, (err, brickStorageArray) => {
        if (err) {
            return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to get brick storage services from bdns`, err));
        }

        if (!brickStorageArray.length) {
            return callback('No storage provided');
        }

        const fetchBrick = (storage) => {
            let smartUrl = new SmartUrl(storage);
            smartUrl = smartUrl.concatWith(`/bricking/${dlDomain}/brick-exists/${brickHash}`);
            return smartUrl.fetch().then(async (response) => {
                if(response.status === 404){
                    return false;
                }
                if (response.status !== 200) {
                    throw Error(`Failed to contact server. Status code: ${response.status}`);
                }

                const exists = await response.text();
                if (exists === "true") {
                    return true;
                }

                if(exists === "false"){
                    return false;
                }

                throw Error(`Failed to parse response from server. Expected "true" or "false" but got ${exists}`);
            }).catch(e => {
                throw Error(`Failed to check brick <${brickHash}>: e.message`);
            })
        };

        const runnerCallback = (error, result) => {
            if (error) {
                return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to get brick <${brickHash}> from brick storage`, error));
            }

            callback(null, result);
        }

        promiseRunner.runOneSuccessful(brickStorageArray, fetchBrick, runnerCallback, "get brick");
    });
}
/**
 * Get brick
 * @param {hashLinkSSI} hashLinkSSI
 * @param {string} authToken
 * @param {function} callback
 * @returns {any}
 */
const getBrick = (hashLinkSSI, authToken, callback) => {
    const dlDomain = hashLinkSSI.getDLDomain();
    const brickHash = hashLinkSSI.getHash();
    if (typeof authToken === 'function') {
        callback = authToken;
        authToken = undefined;
    }

    if (typeof cache === "undefined") {
        __getBrickFromEndpoint();
    } else {
        cache.get(brickHash, (err, brick) => {
            if (err || typeof brick === "undefined" || !isValidBrickHash(hashLinkSSI, brick)) {
                __getBrickFromEndpoint();
            } else {
                callback(undefined, brick);
            }
        });
    }

    function __getBrickFromEndpoint() {
        const bdns = openDSU.loadApi("bdns");
        bdns.getBrickStorages(dlDomain, (err, brickStorageArray) => {
            if (err) {
                return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to get brick storage services from bdns`, err));
            }

            if (!brickStorageArray.length) {
                return callback('No storage provided');
            }

            const fetchBrick = (storage) => {
                let smartUrl = new SmartUrl(storage);
                smartUrl = smartUrl.concatWith(`/bricking/${dlDomain}/get-brick/${brickHash}`);

                return smartUrl.fetch().then(async (response) => {
                    let brickData = await response.arrayBuffer();
                    brickData = $$.Buffer.from(brickData);
                    if (isValidBrickHash(hashLinkSSI, brickData)) {
                        if (typeof cache !== "undefined") {
                            cache.put(brickHash, brickData);
                        }
                        return brickData;
                    }
                    throw Error(`Failed to validate brick <${brickHash}>`);
                });
            };

            const runnerCallback = (error, result) => {
                if (error) {
                    return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to get brick <${brickHash}> from brick storage`, error));
                }

                callback(null, result);
            }

            promiseRunner.runOneSuccessful(brickStorageArray, fetchBrick, runnerCallback, "get brick");
        });
    }

};

/**
 * Get multiple bricks
 * @param {hashLinkSSIList} hashLinkSSIList
 * @param {string} authToken
 * @param {function} callback
 */

const getMultipleBricks = (hashLinkSSIList, authToken, callback) => {
    if (typeof authToken === 'function') {
        callback = authToken;
        authToken = undefined;
    }
    const resultsArr = new Array(hashLinkSSIList.length);
    let currentPointer = -1;

    function getTask(taskNumber) {
        const hashLink = hashLinkSSIList[taskNumber];
        getBrick(hashLink, authToken, (err, brickData) => {
            if (err) {
                return callback(err);
            }

            resultsArr[taskNumber] = brickData;
            setTimeout(() => {
                attemptCallback();
            })
        });
    }

    function attemptCallback() {
        while (resultsArr[currentPointer + 1]) {
            currentPointer++;
            callback(undefined, resultsArr[currentPointer]);
        }
    }

    // The bricks need to be returned in the same order they were requested
    for (let i = 0; i < hashLinkSSIList.length; i++) {
        getTask(i);
    }
};


/**
 * Put brick
 * @param {keySSI} keySSI
 * @param {ReadableStream} brick
 * @param {string} authToken
 * @param {function} callback
 * @returns {string} brickhash
 */
const putBrick = (domain, brick, authToken, callback) => {
    if (typeof authToken === 'function') {
        callback = authToken;
        authToken = undefined;
    }

    const bdns = openDSU.loadApi("bdns");
    bdns.getBrickStorages(domain, (err, brickStorageArray) => {
        if (err) {
            return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to get brick storage services from bdns`, err));
        }
        const setBrickInStorage = (storage) => {
            return new Promise((resolve, reject) => {
                let smartUrl = new SmartUrl(storage);
                smartUrl = smartUrl.concatWith(`/bricking/${domain}/put-brick`);

                const putResult = smartUrl.doPut(brick, (err, data) => {
                    if (err) {
                        return reject(err);
                    }

                    return resolve(data);
                });
                if (putResult) {
                    putResult.then(resolve).catch(reject);
                }
            })
        };

        promiseRunner.runEnoughForMajority(brickStorageArray, setBrickInStorage, null, null, (err, results) => {
            if (err) {
                return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper("Failed to create bricks", err));
            }

            const foundBrick = results[0];
            const brickHash = JSON.parse(foundBrick).message;
            if (typeof cache === "undefined") {
                return callback(undefined, brickHash)
            }

            cache.put(brickHash, brick, (err) => {
                if (err) {
                    return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to put brick <${brickHash}> in cache`, err));
                }
                callback(undefined, brickHash);
            })

        }, "Storing a brick");
    });
};

const constructBricksFromData = (keySSI, data, options, callback) => {
    const MAX_BRICK_SIZE = 1024 * 1024; // 1MB
    const defaultOpts = {encrypt: true, maxBrickSize: MAX_BRICK_SIZE};

    if (typeof options === "function") {
        callback = options;
        options = {
            maxBrickSize: MAX_BRICK_SIZE
        };
    }

    options = Object.assign({}, defaultOpts, options);

    const bar = require("bar");
    const archiveConfigurator = bar.createArchiveConfigurator();
    archiveConfigurator.setBufferSize(options.maxBrickSize);
    archiveConfigurator.setKeySSI(keySSI);

    const envTypes = require("overwrite-require").constants;
    if ($$.environmentType !== envTypes.BROWSER_ENVIRONMENT_TYPE &&
        $$.environmentType !== envTypes.SERVICE_WORKER_ENVIRONMENT_TYPE &&
        $$.environmentType !== envTypes.WEB_WORKER_ENVIRONMENT_TYPE) {
        const fsAdapter = require('bar-fs-adapter');
        const ArchiveConfigurator = require("bar").ArchiveConfigurator;
        ArchiveConfigurator.prototype.registerFsAdapter("FsAdapter", fsAdapter.createFsAdapter);
        archiveConfigurator.setFsAdapter("FsAdapter");
    }

    const brickStorageService = bar.createBrickStorageService(archiveConfigurator, keySSI);

    brickStorageService.ingestData(data, options, (err, result) => {
        if (err) {
            return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper("Failed to ingest data into brick storage service", err));
        }

        callback(undefined, result);
    });
}

module.exports = {
    getBrick,
    putBrick,
    getMultipleBricks,
    constructBricksFromData,
    brickExistsOnServer
};

},{"../cache/":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/cache/index.js","../moduleConstants":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/moduleConstants.js","../utils":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/utils/index.js","../utils/promise-runner":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/utils/promise-runner.js","bar":"bar","bar-fs-adapter":"bar-fs-adapter","opendsu":"opendsu","overwrite-require":"overwrite-require","swarmutils":"swarmutils"}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/cache/FSCache.js":[function(require,module,exports){
const config = require("opendsu").loadApi("config");
const CacheMixin = require("../utils/PendingCallMixin");
const constants = require("../moduleConstants");

function FSCache(folderName) {
    const self = this;
    CacheMixin(self);
    const fsName = "fs"; //do not tempt browserify
    const fs = require(fsName);
    let baseFolder = config.get(constants.CACHE.BASE_FOLDER_CONFIG_PROPERTY);
    if (typeof baseFolder === "undefined") {
        baseFolder = process.cwd();
    }
    const path = require("swarmutils").path;
    const folderPath = path.join(baseFolder, folderName);
    let storageFolderIsCreated = false;
    fs.mkdir(folderPath, {recursive: true}, (err) => {
        if (err) {
            throw err;
        }

        storageFolderIsCreated = true;
    });

    self.get = function (key, callback) {
        if (!storageFolderIsCreated) {
            self.addPendingCall(() => {
                self.get(key, callback);
            })
        } else {
            const filePath =path.join(folderPath, key)
            fs.readFile(filePath, (err, data) => {
                if (err) {
                    return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to read file <${filePath}>`, err));
                }

                let content = data;
                try {
                    if(content != undefined && content != "undefined"){
                        content = JSON.parse(content.toString())
                    } else {
                        callback(undefined, undefined);
                    }
                } catch (e) {
                    console.log(e, content);
                    if(callback){
                        return callback(e);
                    }
                    return undefined;
                }
                callback(undefined, content);
            });
        }
    };

    self.put = function (key, value, callback) {
        if (Array.isArray(value)) {
            value = JSON.stringify(value);
        }
        if (!storageFolderIsCreated) {
            self.addPendingCall(() => {
                self.put(key, value, callback);
            });
        } else {
            if (!callback) {
                callback = () => {
                };
            }
            fs.writeFile(path.join(folderPath, key), value, callback);
        }
    }

    self.set = self.put;

    self.clear = function(callback){
        fs.readdir(folderPath, function (err, files) {
            if (err) {
                return callback(err);
            }

            function deleteFile(){
                if(!files.length){
                    return callback(undefined);
                }
                let file = files.pop();
                fs.unlink(file, function(err){
                    if(err){
                        return callback(err);
                    }
                    deleteFile();
                });
            }

            deleteFile();
        });
    }
}



module.exports.FSCache = FSCache;
},{"../moduleConstants":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/moduleConstants.js","../utils/PendingCallMixin":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/utils/PendingCallMixin.js","opendsu":"opendsu","swarmutils":"swarmutils"}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/cache/IndexeDBCache.js":[function(require,module,exports){
const CacheMixin = require("../utils/PendingCallMixin");

function IndexedDBCache(storeName, lifetime) {
    const self = this;
    CacheMixin(self);

    let db;
    let openRequest = indexedDB.open(storeName);
    openRequest.onsuccess = () => {
        db = openRequest.result;
        self.executePendingCalls();
        self.executeSerialPendingCalls();
    };

    openRequest.onupgradeneeded = () => {
        db = openRequest.result;
        db.createObjectStore(storeName);
    };

    self.get = (key, callback) => {
        if (typeof db === "undefined") {
            self.addPendingCall(() => {
                self.get(key, callback);
            });
        } else {
            let transaction = db.transaction(storeName, "readonly");
            const store = transaction.objectStore(storeName);
            let req = store.get(key);
            transaction.oncomplete = () => {
                if (typeof lifetime !== "undefined") {
                    const currentTime = Date.now();
                    const timestampedData = req.result;
                    if (typeof timestampedData === "undefined") {
                        return callback();
                    }
                    if (currentTime - timestampedData.timestamp > lifetime) {
                        self.delete(key);
                        return callback();
                    }
                    callback(undefined, timestampedData.value)
                } else {
                    callback(undefined, req.result);
                }
            }
        }
    };

    self.put = (key, value, callback) => {
        self.addSerialPendingCall((next) => {
            let transaction;
            let store
            try {
                transaction = db.transaction(storeName, "readwrite");
                store = transaction.objectStore(storeName);
            }catch (e) {
                callback(e);
                return next();
            }
            let data;
            if (typeof lifetime !== "undefined") {
                data = {
                    value: value,
                    timestamp: Date.now()
                }
            } else {
                data = value;
            }
            let req = store.put(data, key);
            transaction.oncomplete = () => {
                if (typeof callback === "function") {
                    callback(undefined, key);
                }
                next();
            }
            transaction.onabort = function() {
                console.log("Error", transaction.error);
            };
            req.onerror = function (){
                next();
            }
        });
    };


    self.set = self.put;

    self.delete = (key, callback) => {
            self.addSerialPendingCall((next) => {
                let transaction;
                let store;
                try {
                    transaction = db.transaction(storeName, "readwrite");
                    store = transaction.objectStore(storeName);
                }catch (e) {
                    callback(e);
                    next();
                    return;
                }
                let req = store.delete(key);
                transaction.oncomplete = () => {
                    if (typeof callback === "function") {
                        callback(undefined, key);
                    }
                    next();
                }
                transaction.onabort = function() {
                    console.log("Error", transaction.error);
                };
                req.onerror = function (){
                    next();
                }
            });
    }

    self.clear = (callback)=>{
        self.addSerialPendingCall((next) => {
            let transaction;
            let store;
            try {
                transaction = db.transaction(storeName, "readwrite");
                store = transaction.objectStore(storeName);
            }catch (e) {
                callback(e);
                next();
                return;
            }
            let req = store.clear();
            transaction.oncomplete = () => {
                if (typeof callback === "function") {
                    callback(undefined);
                }
                next();
            }
            transaction.onabort = function() {
                console.log("Error", transaction.error);
            };
            req.onerror = function (){
                next();
            }
        });
    }
}


module.exports.IndexedDBCache  = IndexedDBCache;
},{"../utils/PendingCallMixin":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/utils/PendingCallMixin.js"}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/cache/MemoryCache.js":[function(require,module,exports){
function MemoryCache(useWeakRef) {
    let storage = {};
    const self = this;

    self.get = function (key, callback) {
        if(typeof key !== "string"){
            throw new Error("Keys should be strings");
        }

        let value = storage[key];
        if(value && useWeakRef){
            value = value.deref();
        }
        if(callback){
            callback(undefined, value);
        }
        return value;
    };

    self.put = function (key, value, callback) {
        if(typeof key !== "string"){
            throw new Error("Keys should be strings");
        }
        if(useWeakRef){
            value = value ? new WeakRef(value) : value;
        }
        storage[key] = value;
        if(callback){
            callback(undefined, true)
        }
    }

    self.set = self.put;

    self.clear = function(callback){
        storage = {};
        callback(undefined);
    }
}


module.exports.MemoryCache = MemoryCache;
},{}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/cache/index.js":[function(require,module,exports){
let stores = {};
const config = require("opendsu").loadApi("config");
const constants = require("../moduleConstants");

const IndexedDBCache = require("./IndexeDBCache").IndexedDBCache;
const FSCache        = require("./FSCache").FSCache;
const MemoryCache    = require("./MemoryCache").MemoryCache;

let memoryCache = true;
if($$){
    $$.enableClassicVaultCache = function(){
        memoryCache = false;
    }
}

function getCacheForVault(storeName, lifetime) {
    if (typeof stores[storeName] === "undefined") {
        switch (config.get(constants.CACHE.VAULT_TYPE)) {
            case constants.CACHE.INDEXED_DB:
                stores[storeName] = new IndexedDBCache(storeName, lifetime);
                break;
            case constants.CACHE.FS:
                stores[storeName] = new FSCache(storeName, lifetime);
                break;
            case constants.CACHE.MEMORY:
                stores[storeName] = new MemoryCache(true);
                break;
            case constants.CACHE.NO_CACHE:
                break;
            default:
                throw Error("Invalid cache type");
        }
    }

    return stores[storeName];
}

function getMemoryCache(storeName){
    return stores[storeName] = new MemoryCache();
}

function getWeakRefMemoryCache(storeName){
    let cache = stores[storeName];
    if(!cache){
        cache = new MemoryCache(true);
        stores[storeName] = cache;
    }
    return cache;
}

module.exports = {
    getCacheForVault,
    getMemoryCache,
    getWeakRefMemoryCache
}
},{"../moduleConstants":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/moduleConstants.js","./FSCache":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/cache/FSCache.js","./IndexeDBCache":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/cache/IndexeDBCache.js","./MemoryCache":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/cache/MemoryCache.js","opendsu":"opendsu"}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/config/autoConfig.js":[function(require,module,exports){
const config = require("./index");
const constants = require("../moduleConstants");
const system = require("../system");
const getBaseURL = require("../utils/getBaseURL");
const errorModule = require("../error");

system.setEnvironmentVariable(constants.BDNS_ROOT_HOSTS, `${getBaseURL()}/bdns#x-blockchain-domain-request`);
switch ($$.environmentType) {
    case constants.ENVIRONMENT_TYPES.SERVICE_WORKER_ENVIRONMENT_TYPE:
    case constants.ENVIRONMENT_TYPES.WEB_WORKER_ENVIRONMENT_TYPE:
        config.set(constants.CACHE.VAULT_TYPE, constants.CACHE.INDEXED_DB);
        break;
    case constants.ENVIRONMENT_TYPES.BROWSER_ENVIRONMENT_TYPE:
        config.set(constants.CACHE.VAULT_TYPE, constants.CACHE.INDEXED_DB);
        break;
    case constants.ENVIRONMENT_TYPES.NODEJS_ENVIRONMENT_TYPE:
        config.set(constants.CACHE.VAULT_TYPE, constants.CACHE.NO_CACHE);
        break;

    default:
}

config.set(constants.CACHE.BASE_FOLDER_CONFIG_PROPERTY, constants.CACHE.BASE_FOLDER);

setGlobalVariable("createOpenDSUErrorWrapper", errorModule.createOpenDSUErrorWrapper);
setGlobalVariable("OpenDSUSafeCallback", errorModule.OpenDSUSafeCallback);
setGlobalVariable("reportUserRelevantWarning", errorModule.reportUserRelevantWarning);
setGlobalVariable("reportUserRelevantInfo", errorModule.reportUserRelevantInfo);
setGlobalVariable("reportDevRelevantInfo", errorModule.reportDevRelevantInfo);
setGlobalVariable("reportUserRelevantError", errorModule.reportUserRelevantError);
setGlobalVariable("registerMandatoryCallback", errorModule.registerMandatoryCallback);
setGlobalVariable("printOpenDSUError", errorModule.printOpenDSUError);




},{"../error":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/error/index.js","../moduleConstants":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/moduleConstants.js","../system":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/system/index.js","../utils/getBaseURL":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/utils/getBaseURL.js","./index":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/config/index.js"}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/config/autoConfigFromEnvironment.js":[function(require,module,exports){

module.exports = function(environment){
        const config = require("./index.js");
        const constants = require("../moduleConstants");
        //const systemEnvirnoment = require("../system");

        if(environment[constants.LOADER_ENVIRONMENT_JSON.VAULT] === constants.LOADER_ENVIRONMENT_JSON.SERVER){
            config.set(constants.CACHE.VAULT_TYPE, constants.CACHE.NO_CACHE);
        }

        if(environment[constants.LOADER_ENVIRONMENT_JSON.AGENT] === constants.LOADER_ENVIRONMENT_JSON.MOBILE){
            config.set(constants.CACHE.VAULT_TYPE, constants.CACHE.NO_CACHE);
            //systemEnvirnoment.setEnvironmentVariable(constants.BDNS_ROOT_HOSTS,
        }
        console.log("Environment for vault", environment.appName,  config.get(constants.CACHE.VAULT_TYPE))
}
},{"../moduleConstants":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/moduleConstants.js","./index.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/config/index.js"}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/config/index.js":[function(require,module,exports){
const constants = require("../moduleConstants");
const config = {trustLevel: 1};

function set(key, value) {
    config[key] = value;
}

function get(key) {
    return config[key];
}

function readEnvFile(callback) {
    const sc = require("opendsu").loadAPI("sc");
    sc.getMainDSU((err, mainDSU) => {
        if (err) {
            return callback(createOpenDSUErrorWrapper(`Failed to get main DSU`, err));
        }

        mainDSU.readFile(constants.ENVIRONMENT_PATH, (err, env) => {
            if (err) {
                return callback(createOpenDSUErrorWrapper(`Failed to get main DSU`, err));
            }

            try {
                env = JSON.parse(env.toString());
            } catch (e) {
                return callback(createOpenDSUErrorWrapper(`Failed parse env file`, e));
            }

            callback(undefined, env);
        });
    });
}

function setEnv(key, value, callback) {
    //update environment.json
    readEnvFile((err, env) => {
        if (err) {
            return callback(createOpenDSUErrorWrapper(`Failed to read env file`, err));
        }
        const scAPI = require("opendsu").loadAPI("sc");
        if(env[key] !== value){
            env[key] = value;
            scAPI.configEnvironment(env, callback);
            return;
        }
        callback(undefined, scAPI.getSecurityContext());
    });
}

function getEnv(key, callback) {
    readEnvFile((err, env) => {
        if (err) {
            return callback(createOpenDSUErrorWrapper(`Failed to read env file`, err));
        }

        callback(undefined, env[key]);
    });
}

const autoconfigFromEnvironment = require("./autoConfigFromEnvironment");

function disableLocalVault() {
    set(constants.CACHE.VAULT_TYPE, constants.CACHE.NO_CACHE);
}

module.exports = {
    set,
    get,
    setEnv,
    getEnv,
    autoconfigFromEnvironment,
    disableLocalVault,
    readEnvFile
};


},{"../moduleConstants":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/moduleConstants.js","./autoConfigFromEnvironment":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/config/autoConfigFromEnvironment.js","opendsu":"opendsu"}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/contracts/index.js":[function(require,module,exports){
const getBaseURL = require("../utils/getBaseURL");

const {
    DomainNotSupportedError,
    getSafeCommandBody,
    getNoncedCommandBody,
    getContractEndpointUrl,
    callContractEndpoint,
    callContractEndpointUsingBdns,
} = require("./utils");

class CommandSender {
    constructor(baseUrl, fallbackToUrlFromBDNS) {
        this.baseUrl = baseUrl;
        this.fallbackToUrlFromBDNS = fallbackToUrlFromBDNS;
    }

    async sendCommand(method, contractEndpointPrefix, domain, commandBody, callback) {
        if (typeof commandBody === "function") {
            callback = commandBody;
            commandBody = null;
        }

        callback = $$.makeSaneCallback(callback);

        try {
            try {
                // try to send the command to the current apihub endpoint
                const currentApihubUrl = getContractEndpointUrl(this.baseUrl, domain, contractEndpointPrefix);
                const response = await callContractEndpoint(currentApihubUrl, method, domain, commandBody);
                callback(null, response);
            } catch (error) {
                // if the current apihub endpoint doesn't handle the current domain, then send the command using BDNS
                if (this.fallbackToUrlFromBDNS && error instanceof DomainNotSupportedError) {
                    callContractEndpointUsingBdns(method, contractEndpointPrefix, domain, commandBody, callback);
                    return;
                }
                throw error;
            }
        } catch (error) {
            OpenDSUSafeCallback(callback)(
                createOpenDSUErrorWrapper(`Failed to execute domain contract method: ${JSON.stringify(commandBody)}`, error)
            );
        }
    }

    generateSafeCommand(domain, contractName, methodName, params, callback) {
        if (typeof params === "function") {
            callback = params;
            params = null;
        }

        try {
            const commandBody = getSafeCommandBody(domain, contractName, methodName, params);
            this.sendCommand("POST", "safe-command", domain, commandBody, callback);
        } catch (error) {
            callback(error);
        }
    }

    async generateNoncedCommand(signerDID, domain, contractName, methodName, params, timestamp, callback) {
        if (typeof timestamp === "function") {
            callback = timestamp;

            // check if the param before provided callback is either the timestamp or the params, since both are optional
            if (typeof params === "number") {
                timestamp = params;
                params = null;
            } else {
                timestamp = null;
            }
        }

        if (typeof params === "function") {
            callback = params;
            params = null;
            timestamp = null;
        }
        if (!signerDID) {
            return callback("signerDID not provided");
        }

        if (!timestamp) {
            timestamp = Date.now();
        }

        try {
            if (typeof signerDID === "string") {
                // signerDID contains the identifier, so we need to load the DID
                const w3cDID = require("opendsu").loadAPI("w3cdid");
                signerDID = await $$.promisify(w3cDID.resolveDID)(signerDID);
            }

            const latestBlockInfo = await $$.promisify(this.sendCommand.bind(this))("GET", "latest-block-info", domain);
            const { number: blockNumber } = latestBlockInfo;

            const commandBody = await getNoncedCommandBody(domain, contractName, methodName, params, blockNumber, timestamp, signerDID);
            this.sendCommand("POST", "nonced-command", domain, commandBody, callback);
        } catch (error) {
            callback(error);
        }
    }
}

function generateSafeCommand(domain, contractName, methodName, params, callback) {
    const commandSender = new CommandSender(getBaseURL(), true);
    commandSender.generateSafeCommand(domain, contractName, methodName, params, callback);
}

async function generateNoncedCommand(signerDID, domain, contractName, methodName, params, timestamp, callback) {
    const commandSender = new CommandSender(getBaseURL(), true);
    commandSender.generateNoncedCommand(signerDID, domain, contractName, methodName, params, timestamp, callback);
}

function generateSafeCommandForSpecificServer(serverUrl, domain, contractName, methodName, params, callback) {
    if (!serverUrl || typeof serverUrl !== "string") {
        throw new Error(`Invalid serverUrl specified`);
    }
    const commandSender = new CommandSender(serverUrl);
    commandSender.generateSafeCommand(domain, contractName, methodName, params, callback);
}

function generateNoncedCommandForSpecificServer(
    serverUrl,
    signerDID,
    domain,
    contractName,
    methodName,
    params,
    timestamp,
    callback
) {
    if (!serverUrl || typeof serverUrl !== "string") {
        throw new Error(`Invalid serverUrl specified`);
    }
    const commandSender = new CommandSender(serverUrl);
    commandSender.generateNoncedCommand(signerDID, domain, contractName, methodName, params, timestamp, callback);
}

module.exports = {
    generateSafeCommand,
    generateNoncedCommand,
    generateSafeCommandForSpecificServer,
    generateNoncedCommandForSpecificServer,
};

},{"../utils/getBaseURL":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/utils/getBaseURL.js","./utils":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/contracts/utils.js","opendsu":"opendsu"}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/contracts/utils.js":[function(require,module,exports){
(function (Buffer){(function (){
const { fetch, doPost } = require("../http");
const promiseRunner = require("../utils/promise-runner");

class DomainNotSupportedError extends Error {
    constructor(domain, url) {
        super(`Domain '${domain}' not supported for calling URL ${url}`);
        this.name = "DomainNotSupportedError";
    }
}

function getCommandHash(command) {
    const { domain, contractName, methodName, params, type, blockNumber, timestamp } = command;

    const objectToHash = {
        domain,
        contractName,
        methodName,
        params,
    };

    if (type === "nonced") {
        objectToHash.blockNumber = blockNumber;
        objectToHash.timestamp = timestamp;
    }

    const crypto = require("opendsu").loadApi("crypto");
    const hash = crypto.sha256(objectToHash);

    return hash;
}

function getSafeCommandBody(domain, contractName, methodName, params) {
    if (!domain || typeof domain !== "string") {
        throw `Invalid domain specified: ${domain}!`;
    }
    if (!contractName || typeof contractName !== "string") {
        throw `Invalid contractName specified: ${contractName}!`;
    }
    if (!methodName || typeof methodName !== "string") {
        throw `Invalid methodName specified: ${methodName}!`;
    }

    if (params) {
        if (!Array.isArray(params)) {
            throw `Invalid params specified (must be a list): ${params}!`;
        }
    }

    return {
        domain,
        contractName,
        methodName,
        params,
        type: "safe",
    };
}

async function getNoncedCommandBody(domain, contract, method, params, blockNumber, timestamp, signerDID) {
    if (!signerDID) {
        // params field is optional
        signerDID = timestamp;
        timestamp = blockNumber;
        blockNumber = params;
        params = null;
    }

    const commandBody = getSafeCommandBody(domain, contract, method, params);
    commandBody.type = "nonced";
    commandBody.blockNumber = blockNumber;
    commandBody.timestamp = timestamp;
    commandBody.signerDID = signerDID.getIdentifier();

    const hash = getCommandHash(commandBody);
    let signature = await $$.promisify(signerDID.sign)(hash);
    
    if (Buffer.isBuffer(signature)) {
        signature = signature.toString('hex')
    }

    commandBody.requesterSignature = signature;

    return commandBody;
}

function getContractEndpointUrl(baseUrl, domain, contractEndpointPrefix) {
    return `${baseUrl}/contracts/${domain}/${contractEndpointPrefix}`;
}

async function callContractEndpoint(url, method, domain, body) {
    let response;
    if (method === "GET") {
        response = await fetch(url);
        if (response.statusCode === 404) {
            throw new DomainNotSupportedError(domain, url);
        }

        response = await response.json();
    } else {
        try {
            response = await $$.promisify(doPost)(url, body);
        } catch (error) {
            if (error.statusCode === 404) {
                throw new DomainNotSupportedError(domain, url);
            }
            throw error;
        }
    }

    if (response) {
        try {
            response = JSON.parse(response);
        } catch (error) {
            // the response isn't a JSON so we keep it as it is
        }

        if (response.optimisticResult) {
            try {
                response.optimisticResult = JSON.parse(response.optimisticResult);
            } catch (error) {
                // the response isn't a JSON so we keep it as it is
            }
        }
    }

    return response;
}

async function callContractEndpointUsingBdns(method, contractEndpointPrefix, domain, commandBody, callback) {
    let contractServicesArray = [];
    try {
        const bdns = require("opendsu").loadApi("bdns");
        contractServicesArray = await $$.promisify(bdns.getContractServices)(domain);
    } catch (error) {
        return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to get contract services from bdns'`, error));
    }

    if (!contractServicesArray.length) {
        return callback("No contract service provided");
    }
    const runContractMethod = async (service) => {
        const url = getContractEndpointUrl(service, domain, contractEndpointPrefix);
        const response = await callContractEndpoint(url, method, domain, commandBody);
        return response;
    };

    promiseRunner.runOneSuccessful(contractServicesArray, runContractMethod, callback, new Error("get Contract Service"));
}

module.exports = {
    DomainNotSupportedError,
    getSafeCommandBody,
    getNoncedCommandBody,
    getContractEndpointUrl,
    callContractEndpoint,
    callContractEndpointUsingBdns,
};

}).call(this)}).call(this,{"isBuffer":require("../../../node_modules/is-buffer/index.js")})

},{"../../../node_modules/is-buffer/index.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/node_modules/is-buffer/index.js","../http":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/http/index.js","../utils/promise-runner":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/utils/promise-runner.js","opendsu":"opendsu"}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/credentials/InstanceReadyMixin.js":[function(require,module,exports){
function InstanceReadyMixin(target) {

	target.isInstanceReady = false;
	target.instanceReadyCallback = null;

	target.onInstanceReady = (callback) => {
		if (target.isInstanceReady) {
			callback(...target.args);
			target.args = null;
			return;
		}

		target.instanceReadyCallback = callback;
	};

	target.notifyInstanceReady = (...args) => {
		target.isInstanceReady = true;
		if (typeof target.instanceReadyCallback === 'function') {
			target.instanceReadyCallback(...args);
			target.isInstanceReady = false;
			target.instanceReadyCallback = null;
		} else {
			target.args = [...args];
		}
	};
}

module.exports = InstanceReadyMixin;
},{}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/credentials/constants.js":[function(require,module,exports){
const JWT_ERRORS = {
	EMPTY_JWT_PROVIDED: 'EMPTY_JWT_PROVIDED',
	INVALID_JWT_FORMAT: 'INVALID_JWT_FORMAT',
	INVALID_JWT_HEADER: 'INVALID_JWT_HEADER',
	INVALID_JWT_HEADER_TYPE: 'INVALID_JWT_HEADER_TYPE',
	INVALID_JWT_PAYLOAD: 'INVALID_JWT_PAYLOAD',
	INVALID_JWT_SIGNATURE: 'INVALID_JWT_SIGNATURE',
	INVALID_ISSUER_FORMAT: 'INVALID_ISSUER_FORMAT',
	INVALID_SUBJECT_FORMAT: 'INVALID_SUBJECT_FORMAT',
	INVALID_EXPIRATION_DATE: 'INVALID_EXPIRATION_DATE',
	INVALID_PUBLIC_CLAIM: 'INVALID_PUBLIC_CLAIM',
	INVALID_SUBJECT_CLAIM: 'INVALID_SUBJECT_CLAIM',
	IMMUTABLE_PUBLIC_CLAIM: 'IMMUTABLE_PUBLIC_CLAIM',
	INVALID_CONTEXT_URI: 'INVALID_CONTEXT_URI',
	INVALID_CONTEXT_TYPE: 'INVALID_CONTEXT_TYPE',
	IMMUTABLE_SUBJECT_CLAIM: 'IMMUTABLE_SUBJECT_CLAIM',
	INVALID_SUBJECT_ID: 'INVALID_SUBJECT_ID',
	PROVIDED_SUBJECT_ID_NOT_PRESENT: 'PROVIDED_SUBJECT_ID_NOT_PRESENT',
	JWT_TOKEN_EXPIRED: 'JWT_TOKEN_EXPIRED',
	JWT_TOKEN_NOT_ACTIVE: 'JWT_TOKEN_NOT_ACTIVE',
	ROOT_OF_TRUST_NOT_VALID: 'ROOT_OF_TRUST_NOT_VALID',
	AUDIENCE_OF_PRESENTATION_NOT_DEFINED: 'AUDIENCE_OF_PRESENTATION_NOT_DEFINED',
	HOLDER_AND_VERIFIER_MUST_BE_DID: 'HOLDER_AND_VERIFIER_MUST_BE_DID'
};


const JWT_DEFAULTS = {
	ALG: 'ES256',
	TYP: 'JWT',
	VC_VP_CONTEXT_CREDENTIALS: 'https://www.w3.org/2018/credentials/v1',
	VC_TYPE: 'VerifiableCredential',
	VP_TYPE: 'VerifiablePresentation',
	EXP: (365 * 24 * 60 * 60), // 1 year default,
	EMPTY_VC_VP: {
		context: [], type: []
	}
};

const LABELS = {
	ISSUER_DID: 'issuerDID',
	ISSUER_SSI: 'issuerSSI',
	SUBJECT_DID: 'subjectDID',
	SUBJECT_SSI: 'subjectSSI'
};

function getDefaultJWTOptions() {
	const now = Date.now();
	return {
		iat: now, nbf: now, exp: now + JWT_DEFAULTS.EXP
	};
}

const IMMUTABLE_PUBLIC_CLAIMS = ['vc', 'vp', 'iss', 'sub', 'iat', 'verifiableCredential', 'holder'];

const VALIDATION_STRATEGIES = {
	DEFAULT: "DEFAULT",
	ROOTS_OF_TRUST: "ROOTS_OF_TRUST",
	INVALID_VALIDATION_STRATEGY: "INVALID_VALIDATION_STRATEGY"
};

module.exports = {
	JWT_DEFAULTS,
	JWT_ERRORS,
	LABELS,
	IMMUTABLE_PUBLIC_CLAIMS,
	getDefaultJWTOptions: getDefaultJWTOptions,
	VALIDATION_STRATEGIES
};
},{}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/credentials/index.js":[function(require,module,exports){
const {createJWTVc, loadJWTVc} = require('./vc/jwtVc');
const {createJWTVp, loadJWTVp} = require('./vp/jwtVp');
const validationStrategies = require('./validationStrategies');
const {parseJWTSegments} = require('./utils');

function createJWTVerifiableCredential(issuer, subject, options, callback) {
    if (typeof options === 'function') {
        callback = options;
        options = {};
    }

    const jwtInstance = createJWTVc(issuer, subject, options);
    jwtInstance.onInstanceReady((err) => {
        if (err) {
            return callback(err);
        }

        callback(undefined, jwtInstance);
    });
}

async function createJWTVerifiableCredentialAsync(issuer, subject, options) {
    return $$.promisify(createJWTVerifiableCredential)(issuer, subject, options);
}

function loadJWTVerifiableCredential(encodedJWTVc, callback) {
    const jwtInstance = loadJWTVc(encodedJWTVc);
    jwtInstance.onInstanceReady((err) => {
        if (err) {
            return callback(err);
        }

        callback(undefined, jwtInstance);
    });
}

async function loadJWTVerifiableCredentialAsync(encodedJWTVc) {
    return $$.promisify(loadJWTVerifiableCredential)(encodedJWTVc);
}

function createJWTVerifiablePresentation(issuer, options, callback) {
    if (typeof options === 'function') {
        callback = options;
        options = {};
    }

    const jwtInstance = createJWTVp(issuer, options);
    jwtInstance.onInstanceReady((err) => {
        if (err) {
            return callback(err);
        }

        callback(undefined, jwtInstance);
    });
}

async function createJWTVerifiablePresentationAsync(issuer, options) {
    return $$.promisify(createJWTVerifiablePresentation)(issuer, options);
}

function loadJWTVerifiablePresentation(encodedJWTVp, callback) {
    const jwtInstance = loadJWTVp(encodedJWTVp);
    jwtInstance.onInstanceReady((err) => {
        if (err) {
            return callback(err);
        }

        callback(undefined, jwtInstance);
    });
}

async function loadJWTVerifiablePresentationAsync(encodedJWTVp) {
    return $$.promisify(loadJWTVerifiablePresentation)(encodedJWTVp);
}

module.exports = {
    createJWTVerifiableCredential,
    createJWTVerifiableCredentialAsync,
    createJWTVerifiablePresentation,
    createJWTVerifiablePresentationAsync,
    loadJWTVerifiableCredential,
    loadJWTVerifiableCredentialAsync,
    loadJWTVerifiablePresentation,
    loadJWTVerifiablePresentationAsync,
    validationStrategies,
    parseJWTSegments,
    JWT_ERRORS: require('./constants').JWT_ERRORS
};
},{"./constants":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/credentials/constants.js","./utils":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/credentials/utils.js","./validationStrategies":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/credentials/validationStrategies/index.js","./vc/jwtVc":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/credentials/vc/jwtVc.js","./vp/jwtVp":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/credentials/vp/jwtVp.js"}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/credentials/jwt/index.js":[function(require,module,exports){
const { JWT_ERRORS, IMMUTABLE_PUBLIC_CLAIMS } = require('../constants');
const { base64UrlEncode } = require('../utils');
const { signJWT } = require('./sign');
const instanceReadyMixin = require('../InstanceReadyMixin');

class JWT {

	constructor() {
		this.jwtHeader = null;
		this.jwtPayload = null;
		instanceReadyMixin(this);
	}

	getEncodedJWT(callback) {
		signJWT(this.jwtHeader, this.jwtPayload, (err, jwtSignature) => {
			if (err) {
				return callback(err);
			}

			const encodedJWT = [base64UrlEncode(JSON.stringify(this.jwtHeader)), base64UrlEncode(JSON.stringify(this.jwtPayload)), jwtSignature].join('.');
			callback(undefined, encodedJWT);
		});
	}

	async getEncodedJWTAsync() {
		return this.asyncMyFunction(this.getEncodedJWT, [...arguments]);
	}

	/**
	 * This method embeds one or more public claims about the JWT. These claims are not reflected within VC body
	 * @param claimName {string} - The name of the public claim. Reserved public claims: "vc", "vp", "iss", "sub", "iat"
	 * @param claimValue - The value of the public claim
	 * @param callback
	 */
	embedClaim(claimName, claimValue, callback) {
		if (typeof claimName !== 'string') {
			return callback(JWT_ERRORS.INVALID_PUBLIC_CLAIM);
		}

		if (IMMUTABLE_PUBLIC_CLAIMS.findIndex(cl => cl === claimName) !== -1) {
			return callback(JWT_ERRORS.IMMUTABLE_PUBLIC_CLAIM);
		}

		this.jwtPayload[claimName] = claimValue;
		callback(undefined, true);
	}

	async embedClaimAsync(claimName, claimValue) {
		return this.asyncMyFunction(this.embedClaim, [...arguments]);
	}

	/**
	 * This method is used to extend the expiration date of a JWT
	 * @param timeInSeconds {Number}
	 * @param callback
	 */
	extendExpirationDate(timeInSeconds, callback) {
		if (typeof timeInSeconds !== 'number' || timeInSeconds <= 0) {
			return callback(JWT_ERRORS.INVALID_EXPIRATION_DATE);
		}

		this.jwtPayload.exp = this.jwtPayload.exp + timeInSeconds * 1000;
		callback(undefined, true);
	}

	async extendExpirationDateAsync(timeInSeconds) {
		return this.asyncMyFunction(this.extendExpirationDate, [...arguments]);
	}

	asyncMyFunction = (func, params) => {
		func = func.bind(this);
		return new Promise((resolve, reject) => {
			func(...params, (err, data) => {
				if (err) {
					return reject(err);
				}
				resolve(data);
			});
		});
	};
}

module.exports = JWT;
},{"../InstanceReadyMixin":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/credentials/InstanceReadyMixin.js","../constants":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/credentials/constants.js","../utils":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/credentials/utils.js","./sign":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/credentials/jwt/sign.js"}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/credentials/jwt/model.js":[function(require,module,exports){
const { JWT_DEFAULTS, JWT_ERRORS, getDefaultJWTOptions } = require('../constants');
const utils = require('../utils');

/**
 * This method creates the header of a JWT according to the W3c Standard
 * @param options
 * @returns {{typ: string, alg: string}}
 */
function getRequiredJWTHeader(options) {
	const { alg, typ, kid } = options; // can be extended with other attributes

	return {
		alg: alg || JWT_DEFAULTS.ALG,
		typ: typ || JWT_DEFAULTS.TYP,
		// Used in case of asymmetric encryption of the signature.
		// Kid is actually the did of the verifier who can validate the signature.
		// This is part of signatureValidationStrategy proposal
		kid: kid
	};
}

/**
 * This method creates the payload of a JWT according to the W3c Standard
 * @param options {Object}
 * @returns {{sub, nbf, iss, exp, iat, aud, nonce}}
 */
function getRequiredJWTPayloadModel(options) {
	let { sub, iss, nbf, exp, iat, aud, jti, nonce } = options; // can be extended with other attributes

	// jti: Unique identifier; can be used to prevent the JWT from being replayed (allows a token to be used only once)
	return {
		sub, iss, nbf, exp, iat, aud, jti, nonce
	};
}

/**
 * This method creates the first signed JWT during a JWT instance initialisation
 * @param issuer
 * @param options
 * @param callback
 */
function defaultJWTBuilder(issuer, options, callback) {
	options = Object.assign({}, getDefaultJWTOptions(), options);

	issuer = utils.getReadableIdentity(issuer);
	if (!issuer) return callback(JWT_ERRORS.INVALID_ISSUER_FORMAT);

	const issuerFormat = utils.getIssuerFormat(issuer);
	if (!issuerFormat) return callback(JWT_ERRORS.INVALID_ISSUER_FORMAT);

	options.iss = issuer;
	const jwtHeader = getRequiredJWTHeader(options);
	const jwtPayload = getRequiredJWTPayloadModel(options);

	callback(undefined, { jwtHeader, jwtPayload, options });
}

/**
 *
 * @param encodedJWT {string}
 * @param callback {Function}
 */
function defaultJWTParser(encodedJWT, callback) {
	utils.parseJWTSegments(encodedJWT, (err, result) => {
		if (err) {
			return callback(err);
		}

		const { jwtHeader, jwtPayload } = result;
		if (!jwtHeader.typ || !jwtHeader.alg) return callback(JWT_ERRORS.INVALID_JWT_HEADER);
		if (!jwtPayload.iss) return callback(JWT_ERRORS.INVALID_JWT_ISSUER);

		callback(undefined, result);
	});
}

module.exports = {
	defaultJWTBuilder, defaultJWTParser
};
},{"../constants":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/credentials/constants.js","../utils":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/credentials/utils.js"}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/credentials/jwt/sign.js":[function(require,module,exports){
const openDSU = require('opendsu');
const w3cDID = openDSU.loadAPI('w3cdid');
const crypto = openDSU.loadAPI('crypto');
const keySSISpace = openDSU.loadApi('keyssi');
const keySSIResolver = require('key-ssi-resolver');
const cryptoRegistry = keySSIResolver.CryptoAlgorithmsRegistry;

const {LABELS, JWT_ERRORS} = require('../constants');
const {base64UrlEncode, getIssuerFormat, asymmetricalEncryption} = require('../utils');

/**
 * This method is signing the encoded header and payload of a JWT and returns the full signed JWT (header.payload.signature)
 * The JWT will be signed according to the type of the issuer (KeySSI, DID)
 * @param jwtHeader
 * @param jwtPayload
 * @param callback {Function}
 */
function signJWT(jwtHeader, jwtPayload, callback) {
    // TODO: If kid attribute is present inside jwtHeader and is a readable DID, the JWT will be asymmetrically signed using kid's value.
    //  This type of signing can be validated only by a verifier that is using Signature Validation Strategy. Also, create verify method for signature validation

    const issuer = jwtPayload.iss;
    const issuerType = getIssuerFormat(issuer);
    let dataToSign = [base64UrlEncode(JSON.stringify(jwtHeader)), base64UrlEncode(JSON.stringify(jwtPayload))].join('.');
    const kidType = getIssuerFormat(jwtHeader.kid);
    if (kidType === LABELS.ISSUER_DID) {
        dataToSign = base64UrlEncode(JSON.stringify({iss: issuer, kid: jwtHeader.kid}));
        return asymmetricalEncryption(issuer, jwtHeader.kid, dataToSign, callback);
    }

    switch (issuerType) {
        case LABELS.ISSUER_SSI: {
            return signUsingSSI(issuer, dataToSign, callback);
        }

        case LABELS.ISSUER_DID: {
            return signUsingDID(issuer, dataToSign, callback);
        }

        default: {
            return callback(JWT_ERRORS.INVALID_ISSUER_FORMAT);
        }
    }
}

/**
 * This method is signing a JWT using KeySSI
 * @param issuer
 * @param dataToSign
 * @param callback {Function}
 */
function signUsingSSI(issuer, dataToSign, callback) {
    try {
        const issuerKeySSI = keySSISpace.parse(issuer);
        const sign = cryptoRegistry.getSignFunction(issuerKeySSI);
        if (typeof sign !== 'function') {
            return callback(new Error('Signing not available for ' + issuerKeySSI.getIdentifier(true)));
        }

        const hashFn = cryptoRegistry.getCryptoFunction(issuerKeySSI, 'hash');
        const hashResult = hashFn(dataToSign);
        const signResult = sign(hashResult, issuerKeySSI.getPrivateKey());
        const encodedSignResult = base64UrlEncode(signResult);
        callback(undefined, encodedSignResult);
    } catch (e) {
        return callback(e);
    }
}

/**
 * This method is signing a JWT using DID
 * @param issuer
 * @param dataToSign
 * @param callback {Function}
 */
function signUsingDID(issuer, dataToSign, callback) {
    w3cDID.resolveDID(issuer, (err, didDocument) => {
        if (err) {
            return callback(`Failed to resolve did ${issuer}`);
        }

        const hashResult = crypto.sha256(dataToSign);
        didDocument.sign(hashResult, (signError, signResult) => {
            if (signError || !signResult) return callback(signError);
            const encodedSignResult = base64UrlEncode(signResult);
            callback(undefined, encodedSignResult);
        });
    });
}

module.exports = {
    signJWT
};
},{"../constants":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/credentials/constants.js","../utils":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/credentials/utils.js","key-ssi-resolver":"key-ssi-resolver","opendsu":"opendsu"}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/credentials/jwt/verify.js":[function(require,module,exports){
const opendsu = require('opendsu');
const w3cDID = opendsu.loadAPI('w3cdid');
const crypto = opendsu.loadAPI('crypto');
const keySSISpace = opendsu.loadApi('keyssi');
const keySSIResolver = require('key-ssi-resolver');
const cryptoRegistry = keySSIResolver.CryptoAlgorithmsRegistry;

const {JWT_ERRORS, LABELS} = require("../constants");
const {parseJWTSegments, asymmetricalDecryption, getIssuerFormat} = require("../utils");

/**
 * This method verifies the encrypted credentials using the private key of the audience. <br />
 * Only the intended audience can decrypt the encrypted credential to validate it.
 * @param jwtPayload
 * @param callback
 */
function verifyEncryptedCredential(jwtPayload, callback) {
    const verifyResult = { verifyResult: true, verifiableCredential: [] };
    const encryptedCredentials = jwtPayload.vp.verifiableCredential;
    const audience = jwtPayload.aud;
    if (!audience) {
        verifyResult.verifyResult = false;
        verifyResult.verifiableCredential.push({
            errorMessage: JWT_ERRORS.AUDIENCE_OF_PRESENTATION_NOT_DEFINED
        });

        return callback(undefined, verifyResult);
    }

    const chain = (index) => {
        if (index === encryptedCredentials.length) {
            return callback(undefined, verifyResult);
        }

        const encryptedCredential = encryptedCredentials[index];
        asymmetricalDecryption(audience, encryptedCredential, (err, decryptedJWTVc) => {
            if (err) {
                verifyResult.verifyResult = false;
                verifyResult.verifiableCredential.push({
                    jwtVc: encryptedCredential,
                    errorMessage: err
                });

                return chain(++index);
            }

            parseJWTSegments(decryptedJWTVc, (err, result) => {
                if (err) {
                    verifyResult.verifyResult = false;
                    verifyResult.verifiableCredential.push({
                        jwtVc: encryptedCredential,
                        errorMessage: err
                    });

                    return chain(++index);
                }

                verifyResult.verifiableCredential.push(result.jwtPayload);
                chain(++index);
            });
        });
    };

    chain(0);
}

/**
 * This method verifies if the roots of trust are the actual issuers of the verifiable credentials
 * @param jwtPayload
 * @param rootsOfTrust
 * @param callback
 */
function verifyRootsOfTrust(jwtPayload, rootsOfTrust, callback) {
    const jwtVcList = jwtPayload.vp.verifiableCredential;
    let verifyResult = { verifyResult: true, verifiableCredential: [] };

    const chain = (index) => {
        if (index === jwtVcList.length) {
            return callback(undefined, verifyResult);
        }

        const jwtVc = jwtVcList[index];
        parseJWTSegments(jwtVc, (err, result) => {
            if (err) {
                verifyResult.verifyResult = false;
                verifyResult.verifiableCredential.push({
                    jwtVc: jwtVc,
                    errorMessage: err
                });
                return chain(++index);
            }

            let jwtPayload = result.jwtPayload;
            const rootOfTrust = rootsOfTrust.find(r => r === jwtPayload.iss);
            if (!rootOfTrust) {
                verifyResult.verifyResult = false;
                verifyResult.verifiableCredential.push({
                    jwtVc: jwtVc,
                    errorMessage: JWT_ERRORS.ROOT_OF_TRUST_NOT_VALID
                });
                return chain(++index);
            }

            verifyResult.verifiableCredential.push(result.jwtPayload);
            chain(++index);
        });
    };

    chain(0);
}

/**
 * This method is verifying the encoded JWT from the current instance according to the issuerType
 * @param issuer
 * @param signature
 * @param signedData
 * @param options
 * @param callback {Function}
 */
function verifyJWT(issuer, signature, signedData, options, callback) {
    if (options.kid) {
        return asymmetricalDecryption(options.kid, signature, callback);
    }

    const issuerType = getIssuerFormat(issuer);
    switch (issuerType) {
        case LABELS.ISSUER_SSI: {
            return verifyUsingSSI(issuer, signature, signedData, callback);
        }

        case LABELS.ISSUER_DID: {
            return verifyUsingDID(issuer, signature, signedData, callback);
        }

        default: {
            callback(JWT_ERRORS.INVALID_ISSUER_FORMAT);
        }
    }
}

/**
 * This method is verifying an SSI signed JWT
 * @param issuer
 * @param signature
 * @param signedData
 * @param callback {Function}
 */
function verifyUsingSSI(issuer, signature, signedData, callback) {
    try {
        const issuerKeySSI = keySSISpace.parse(issuer);
        const publicKey = issuerKeySSI.getPublicKey();
        const hashFn = cryptoRegistry.getCryptoFunction(issuerKeySSI, 'hash');
        const hashResult = hashFn(signedData);

        const verify = cryptoRegistry.getVerifyFunction(issuerKeySSI);
        const verifyResult = verify(hashResult, publicKey, signature);
        callback(undefined, verifyResult);
    } catch (e) {
        return callback(e);
    }
}

/**
 * This method is verifying a DID signed JWT
 * @param issuer
 * @param signature
 * @param signedData
 * @param callback {Function}
 */
function verifyUsingDID(issuer, signature, signedData, callback) {
    w3cDID.resolveDID(issuer, (err, didDocument) => {
        if (err) {
            return callback(`Failed to resolve did ${issuer}`);
        }

        const hashResult = crypto.sha256(signedData);
        didDocument.verify(hashResult, signature, (verifyError, verifyResult) => {
            if (verifyError) {
                return callback(verifyError);
            }

            callback(null, verifyResult);
        });
    });
}

module.exports = {
    verifyJWT,
    verifyRootsOfTrust,
    verifyEncryptedCredential
};
},{"../constants":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/credentials/constants.js","../utils":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/credentials/utils.js","key-ssi-resolver":"key-ssi-resolver","opendsu":"opendsu"}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/credentials/utils.js":[function(require,module,exports){
const opendsu = require('opendsu');
const w3cDID = opendsu.loadAPI('w3cdid');
const scAPI = opendsu.loadAPI('sc');
const keySSIResolver = require('key-ssi-resolver');
const cryptoRegistry = keySSIResolver.CryptoAlgorithmsRegistry;
const SSITypes = keySSIResolver.SSITypes;
const keySSIFactory = keySSIResolver.KeySSIFactory;
const templateSeedSSI = keySSIFactory.createType(SSITypes.SEED_SSI);
templateSeedSSI.load(SSITypes.SEED_SSI, 'default');

const {LABELS, JWT_ERRORS} = require('./constants');

function base58Decode(data, keepBuffer) {
    const decodedValue = cryptoRegistry.getDecodingFunction(templateSeedSSI).call(this, data);
    if (keepBuffer) {
        return decodedValue;
    }
    return decodedValue ? decodedValue.toString() : null;
}

function base64UrlEncode(source) {
    const buffer = $$.Buffer.from(source, 'utf-8');
    return buffer.toString('base64')
        .replace(/=/g, '')
        .replace(/\+/g, '-')
        .replace(/\//g, '_');
}

function base64UrlDecode(source, keepAsBuffer = false) {
    const buffer = $$.Buffer.from(source, 'base64');
    if (keepAsBuffer) {
        return buffer;
    }

    return buffer.toString('utf-8');
}

function dateTimeFormatter(timestamp) {
    if (!timestamp) {
        return null;
    }

    return new Date(timestamp).toISOString().split('.')[0] + 'Z';
}

function isValidURL(str) {
    const pattern = new RegExp('https?:\\/\\/(www\\.)?[-a-zA-Z0-9@:%._\\+~#=]{1,256}\\.[a-zA-Z0-9()]{1,6}\\b([-a-zA-Z0-9()@:%_\\+.~#?&//=]*)', 'i');
    return !!pattern.test(str);
}

/**
 * This method returns the readable format of an SSI or a DID
 * @param identity {string | Object} - The KeySSI instance | readable SSI string | DIDInstance | readable DID string
 */
function getReadableIdentity(identity) {
    if (!identity) return null;

    if (typeof identity === 'string' && (identity.indexOf('ssi') === 0 || identity.indexOf('did') === 0)) {
        // ssi/did is actually the readable ssi/did
        return identity;
    }

    identity = identity.hasOwnProperty('getIdentifier') ? identity.getIdentifier() : identity;
    if (identity.indexOf('did') === 0) {
        return identity;
    }

    let readableSSI = base58Decode(identity);
    if (!readableSSI) {
        // invalid base58 string
        return null;
    }
    if (readableSSI.indexOf('ssi') !== 0) {
        // invalid ssi format
        return null;
    }

    return readableSSI;
}

/**
 * This method is decoding a JSON string and returns the JSON object
 * @param data {string}
 * @param keepBuffer {boolean}
 * @returns {Object|Error}
 */
function safeParseEncodedJson(data, keepBuffer = false) {
    try {
        return JSON.parse(base64UrlDecode(data, keepBuffer));
    } catch (e) {
        return e;
    }
}

/**
 * This method decodes the JWT and returns the segments
 * @param jwt {string}
 * @param callback
 */
function parseJWTSegments(jwt, callback) {
    if (!jwt) return callback(JWT_ERRORS.EMPTY_JWT_PROVIDED);
    if (typeof jwt !== 'string') return callback(JWT_ERRORS.INVALID_JWT_FORMAT);

    const segments = jwt.split('.');
    if (segments.length !== 3) return callback(JWT_ERRORS.INVALID_JWT_FORMAT);

    const jwtHeader = safeParseEncodedJson(segments[0]);
    if (jwtHeader instanceof Error || !jwtHeader) return callback(JWT_ERRORS.INVALID_JWT_HEADER);

    const jwtPayload = safeParseEncodedJson(segments[1]);
    if (jwtPayload instanceof Error || !jwtPayload) return callback(JWT_ERRORS.INVALID_JWT_PAYLOAD);

    const encodedJWTHeaderAndBody = `${segments[0]}.${segments[1]}`;
    const jwtSignature = base64UrlDecode(segments[2], true);
    if (!jwtSignature) {
        return callback(JWT_ERRORS.INVALID_JWT_SIGNATURE);
    }

    callback(undefined, {jwtHeader, jwtPayload, jwtSignature, encodedJWTHeaderAndBody});
}

/**
 * This method provides the format of the issuer in order to be processed accordingly.
 * Allowed formats:
 * DID Identifier format
 * SSI format
 * @param issuer {string}
 * @returns {null | string}
 */
function getIssuerFormat(issuer) {
    if (!issuer) return null;

    if (issuer.indexOf('did') === 0) {
        return LABELS.ISSUER_DID;
    }

    if (issuer.indexOf('ssi') === 0) {
        return LABELS.ISSUER_SSI;
    }

    return null;
}

/**
 * This method provides the format of the subject in order to be processed accordingly.
 * Allowed formats:
 * DID Identifier format
 * sReadSSI format
 * @param subject {string}
 * @returns {null | string}
 */
function getSubjectFormat(subject) {
    if (!subject) return null;

    if (subject.indexOf('did') === 0) {
        return LABELS.SUBJECT_DID;
    }

    if (subject.indexOf('ssi') === 0) {
        return LABELS.SUBJECT_SSI;
    }

    return null;
}

/**
 * This method checks if a JWT is expired
 * @param payload {Object}
 * @param atDate
 * @returns {boolean}
 */
function isJWTExpired(payload, atDate) {
    const atDateTime = new Date(atDate).getTime(),
        expTime = new Date(payload.exp).getTime();
    let isExpired = expTime < atDateTime;
    if (payload.vc) {
        const expirationDateTime = new Date(payload.vc.expirationDate).getTime();
        if (expTime !== expirationDateTime) return false;
    }

    return isExpired;
}

/**
 * This method checks if a JWT is active
 * @param payload {Object}
 * @param atDate
 * @returns {boolean}
 */
function isJWTNotActive(payload, atDate) {
    const atDateTime = new Date(atDate).getTime(),
        nbfTime = new Date(payload.nbf).getTime();
    let isNotActive = nbfTime >= atDateTime;
    if (payload.vc) {
        const issuanceDateTime = new Date(payload.vc.issuanceDate).getTime();
        if (nbfTime !== issuanceDateTime) return false;
    }

    return isNotActive;
}

/**
 * This method is encrypting a string using asymmetric encryption, so only the pair of the DIDs can decrypt the message.
 * @param holder
 * @param verifier
 * @param dataToSign
 * @param callback
 */
function asymmetricalEncryption(holder, verifier, dataToSign, callback) {
    const issuerFormat = getIssuerFormat(holder);
    const audienceFormat = getSubjectFormat(verifier);
    if (issuerFormat !== LABELS.ISSUER_DID || audienceFormat !== LABELS.SUBJECT_DID) {
        return callback(JWT_ERRORS.HOLDER_AND_VERIFIER_MUST_BE_DID);
    }

    const securityContext = scAPI.getSecurityContext();
    const resolveDids = async () => {
        try {
            const holderDidDocument = await $$.promisify(w3cDID.resolveDID)(holder);
            const verifierDidDocument = await $$.promisify(w3cDID.resolveDID)(verifier);

            holderDidDocument.encryptMessage(verifierDidDocument, dataToSign, (err, encryptedData) => {
                if (err) {
                    return callback(err);
                }

                callback(undefined, base64UrlEncode(JSON.stringify(encryptedData)));
            });
        } catch (e) {
            return callback(e);
        }
    };

    if (securityContext.isInitialised()) {
        resolveDids();
    } else {
        securityContext.on('initialised', resolveDids);
    }
}

/**
 * Thi9s method is decrypting a JWT VC which was previously encrypted using asymmetric encryption.
 * @param verifier
 * @param encryptedData
 * @param callback
 */
function asymmetricalDecryption(verifier, encryptedData, callback) {
    const audienceFormat = getSubjectFormat(verifier);
    if (audienceFormat !== LABELS.SUBJECT_DID) {
        return callback(JWT_ERRORS.HOLDER_AND_VERIFIER_MUST_BE_DID);
    }

    const encryptedDataJSON = JSON.parse(base64UrlDecode(encryptedData));
    const securityContext = scAPI.getSecurityContext();
    const resolveDid = async () => {
        try {
            const verifierDidDocument = await $$.promisify(w3cDID.resolveDID)(verifier);
            verifierDidDocument.decryptMessage(encryptedDataJSON, (err, decryptedData) => {
                if (err) {
                    return callback(err);
                }

                callback(undefined, decryptedData);
            });
        } catch (e) {
            return callback(e);
        }
    };

    if (securityContext.isInitialised()) {
        resolveDid();
    } else {
        securityContext.on('initialised', resolveDid);
    }
}

/**
 * This method is validating recursively if the provided environmentDataClaims JSON object is part of jwtClaims JSON object
 * @param environmentDataClaims {Object} The object that must be part of jwtClaims object
 * @param jwtClaims {Object} The object that must contain all the properties from environmentDataClaims object
 * @returns {boolean}
 */
function validateClaims(environmentDataClaims, jwtClaims) {
    if(!environmentDataClaims) return true;

    const envDataClaimsKeys = Object.keys(environmentDataClaims);
    for (let index = 0; index < envDataClaimsKeys.length; ++index) {
        const key = envDataClaimsKeys[index],
            currentClaim = environmentDataClaims[key],
            currentJwtClaim = jwtClaims[key];
        if (typeof currentClaim === "object" && typeof currentJwtClaim === "object") {
            const areCurrentValidClaims = validateClaims(currentClaim, currentJwtClaim);
            if (!areCurrentValidClaims) {
                return false;
            }
        } else if (typeof currentClaim === "object" || typeof currentJwtClaim === "object") {
            return false;
        } else if (currentClaim !== currentJwtClaim) {
            return false;
        }
    }

    return true;
}

module.exports = {
    base64UrlEncode,
    dateTimeFormatter,
    isValidURL,

    getIssuerFormat,
    getSubjectFormat,
    isJWTExpired,
    isJWTNotActive,
    getReadableIdentity,
    parseJWTSegments,
    validateClaims,

    asymmetricalEncryption,
    asymmetricalDecryption
};
},{"./constants":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/credentials/constants.js","key-ssi-resolver":"key-ssi-resolver","opendsu":"opendsu"}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/credentials/validationStrategies/defaultValidationStrategy.js":[function(require,module,exports){
const {JWT_ERRORS} = require("../constants");
const utils = require("../utils");

class DefaultValidationStrategy {

    /**
     * @param verifiableCredential {string|Object} - Either an encoded JWTVc, or decoded JWTVc as result of the verification
     * @param environmentData {Object} object with arbitrary data required for validation
     * @param callback {Function}
     */
    validateCredential(verifiableCredential, environmentData, callback) {
        if (typeof verifiableCredential === "string") {
            return utils.parseJWTSegments(verifiableCredential, (err, result) => {
                if (err) return callback(err, false);
                this.validateCredential(result.jwtPayload, environmentData, callback);
            });
        }

        const {atDate, credentialPublicClaims, subjectClaims} = environmentData;
        const arePublicClaimsValid = utils.validateClaims(credentialPublicClaims, verifiableCredential);
        if (!arePublicClaimsValid) return callback(undefined, false);
        const areSubjectClaimsValid = utils.validateClaims(subjectClaims, verifiableCredential.vc.credentialSubject);
        if (!areSubjectClaimsValid) return callback(undefined, false);

        if (utils.isJWTExpired(verifiableCredential, atDate)) return callback(JWT_ERRORS.JWT_TOKEN_EXPIRED, false);
        if (utils.isJWTNotActive(verifiableCredential, atDate)) return callback(JWT_ERRORS.JWT_TOKEN_NOT_ACTIVE, false);

        callback(undefined, true);
    }

    /**
     * @param verifiablePresentation {string|Object} - Either an encoded JWTVp, or decoded JWTVp as result of the verification
     * @param environmentData {Object} object with arbitrary data required for validation
     * @param callback {Function}
     */
    validatePresentation(verifiablePresentation, environmentData, callback) {
        if (typeof verifiablePresentation === "string") {
            return utils.parseJWTSegments(verifiablePresentation, (err, result) => {
                if (err) return callback(err, false);
                this.validatePresentation(result.jwtPayload, environmentData, callback);
            });
        }

        const {atDate, presentationPublicClaims} = environmentData;
        const arePublicClaimsValid = utils.validateClaims(presentationPublicClaims, verifiablePresentation);
        if (!arePublicClaimsValid) return callback(undefined, false);

        if (utils.isJWTExpired(verifiablePresentation, atDate)) return callback(JWT_ERRORS.JWT_TOKEN_EXPIRED, false);
        if (utils.isJWTNotActive(verifiablePresentation, atDate)) return callback(JWT_ERRORS.JWT_TOKEN_NOT_ACTIVE, false);

        const credentialValidatorChain = (jwtVcList) => {
            if (jwtVcList.length === 0) {
                return callback(undefined, true);
            }

            const jwtVc = jwtVcList.shift();
            this.validateCredential(jwtVc, environmentData, (err, isValidCredential) => {
                if (err) return callback(err);
                if (!isValidCredential) return callback(undefined, false);

                credentialValidatorChain(jwtVcList);
            });
        };
        credentialValidatorChain(verifiablePresentation.vp.verifiableCredential);
    }
}

module.exports = DefaultValidationStrategy;
},{"../constants":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/credentials/constants.js","../utils":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/credentials/utils.js"}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/credentials/validationStrategies/index.js":[function(require,module,exports){
const VALIDATION_STRATEGIES = require('../constants').VALIDATION_STRATEGIES;
const DefaultValidationStrategy = require("./defaultValidationStrategy");
const RootOfTrustValidationStrategy = require("./rootOfTrustValidationStrategy");

const validationStrategies = {};

/**
 * @param validationStrategyName {string} The name of the validation strategy that will be registered
 * @param implementation The implementation of the strategy. Check validationStrategy.interface.js for reference
 */
function registerValidationStrategy(validationStrategyName, implementation) {
    validationStrategies[validationStrategyName] = implementation;
}

/**
 * @param validationStrategyName {string} The name of the validation strategy to be returned
 * @returns {Object} The implementation of the validation strategy
 */
function getValidationStrategy(validationStrategyName) {
    if (!validationStrategies[validationStrategyName]) {
        throw Error(VALIDATION_STRATEGIES.INVALID_VALIDATION_STRATEGY);
    }

    return validationStrategies[validationStrategyName];
}

/**
 * @param validationStrategyName {string} The name of the validation strategy that will be used to validate the credential
 * @param environmentData {string} object with arbitrary data required for validation
 * @param credentialSerialization {string} JWT Verifiable Credential
 * @param callback {Function}
 */
function validateCredential(validationStrategyName, environmentData, credentialSerialization, callback) {
    if (!validationStrategies[validationStrategyName]) {
        return callback(VALIDATION_STRATEGIES.INVALID_VALIDATION_STRATEGY);
    }

    validationStrategies[validationStrategyName].validateCredential(credentialSerialization, environmentData, callback);
}

/**
 * Promisified version of validateCredential method
 * @param validationStrategyName {string} The name of the validation strategy that will be used to validate the credential
 * @param environmentData {string} object with arbitrary data required for validation
 * @param credentialSerialization {string} JWT Verifiable Credential
 * @returns {Promise<*>}
 */
async function validateCredentialAsync(validationStrategyName, environmentData, credentialSerialization) {
    return await $$.promisify(validateCredential)(validationStrategyName, environmentData, credentialSerialization);
}

/**
 * @param validationStrategyNamesArray {string|string[]} array of names of validationStrategies that are allowed to validate. If is a string then only that strategy can do it.
 * @param environmentData {Object} object with arbitrary data required for validation
 * @param presentationSerialization {string} JWT Verifiable Presentation
 * @param callback {Function}
 */
function validatePresentation(validationStrategyNamesArray, environmentData, presentationSerialization, callback) {
    if (typeof validationStrategyNamesArray === "string") {
        validationStrategyNamesArray = [validationStrategyNamesArray];
    }

    const validationStrategyChain = (validationStrategyNamesList) => {
        if (validationStrategyNamesList.length === 0) {
            return callback(undefined, true);
        }

        const validationStrategyName = validationStrategyNamesList.shift();
        if (!validationStrategies[validationStrategyName]) {
            return callback(VALIDATION_STRATEGIES.INVALID_VALIDATION_STRATEGY);
        }

        const jwtVp = JSON.parse(JSON.stringify(presentationSerialization));
        validationStrategies[validationStrategyName].validatePresentation(jwtVp, environmentData, (err, isValidPresentation) => {
            if (err) return callback(err);
            if (!isValidPresentation) return callback(undefined, false);

            validationStrategyChain(validationStrategyNamesList);
        });
    };
    validationStrategyChain(validationStrategyNamesArray);
}

/**
 * Promisified version of validatePresentation method
 * @param validationStrategyNamesArray {string|string[]} array of names of validationStrategies that are allowed to validate. If is a string then only that strategy can do it.
 * @param environmentData {Object} object with arbitrary data required for validation
 * @param presentationSerialization {string} JWT Verifiable Presentation
 * @returns {Promise<*>}
 */
async function validatePresentationAsync(validationStrategyNamesArray, environmentData, presentationSerialization) {
    return await $$.promisify(validatePresentation)(validationStrategyNamesArray, environmentData, presentationSerialization);
}

registerValidationStrategy(VALIDATION_STRATEGIES.DEFAULT, new DefaultValidationStrategy());
registerValidationStrategy(VALIDATION_STRATEGIES.ROOTS_OF_TRUST, new RootOfTrustValidationStrategy());

module.exports = {
    getValidationStrategy,
    registerValidationStrategy,

    validateCredential,
    validateCredentialAsync,
    validatePresentation,
    validatePresentationAsync,

    VALIDATION_STRATEGIES
};
},{"../constants":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/credentials/constants.js","./defaultValidationStrategy":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/credentials/validationStrategies/defaultValidationStrategy.js","./rootOfTrustValidationStrategy":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/credentials/validationStrategies/rootOfTrustValidationStrategy.js"}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/credentials/validationStrategies/rootOfTrustValidationStrategy.js":[function(require,module,exports){
const {JWT_ERRORS, LABELS} = require("../constants");
const utils = require("../utils");

class RootOfTrustValidationStrategy {

    /**
     * @param verifiableCredential {string|Object} - Either an encoded JWTVc, or decoded JWTVc as result of the verification
     * @param environmentData {Object} object with arbitrary data required for validation
     * @param callback {Function}
     */
    validateCredential(verifiableCredential, environmentData, callback) {
        if (typeof verifiableCredential === "string") {
            return utils.parseJWTSegments(verifiableCredential, (err, result) => {
                if (err) return callback(err, false);
                this.validateCredential(result.jwtPayload, environmentData, callback);
            });
        }

        const iss = verifiableCredential.iss;
        const issuerFormat = utils.getIssuerFormat(iss);
        const {rootsOfTrust, credentialPublicClaims, subjectClaims} = environmentData;

        const arePublicClaimsValid = utils.validateClaims(credentialPublicClaims, verifiableCredential);
        if (!arePublicClaimsValid) return callback(undefined, false);
        const areSubjectClaimsValid = utils.validateClaims(subjectClaims, verifiableCredential.vc.credentialSubject);
        if (!areSubjectClaimsValid) return callback(undefined, false);

        if (rootsOfTrust.length === 0) return callback(JWT_ERRORS.ROOT_OF_TRUST_NOT_VALID, false);
        if (!iss || issuerFormat !== LABELS.ISSUER_DID) return callback(JWT_ERRORS.INVALID_ISSUER_FORMAT, false);
        if (rootsOfTrust.findIndex(rootOfTrust => rootOfTrust === iss) === -1) return callback(JWT_ERRORS.ROOT_OF_TRUST_NOT_VALID, false);

        callback(undefined, true);
    }

    /**
     * @param verifiablePresentation {string|Object} - Either an encoded JWTVp, or decoded JWTVp as result of the verification
     * @param environmentData {Object} object with arbitrary data required for validation
     * @param callback {Function}
     */
    validatePresentation(verifiablePresentation, environmentData, callback) {
        if (typeof verifiablePresentation === "string") {
            return utils.parseJWTSegments(verifiablePresentation, (err, result) => {
                if (err) return callback(err, false);
                this.validatePresentation(result.jwtPayload, environmentData, callback);
            });
        }

        const {presentationPublicClaims} = environmentData;
        const arePublicClaimsValid = utils.validateClaims(presentationPublicClaims, verifiablePresentation);
        if (!arePublicClaimsValid) return callback(undefined, false);

        const credentialValidatorChain = (jwtVcList) => {
            if (jwtVcList.length === 0) {
                return callback(undefined, true);
            }

            const jwtVc = jwtVcList.shift();
            this.validateCredential(jwtVc, environmentData, (err, isValidCredential) => {
                if (err) return callback(err);
                if (!isValidCredential) return callback(undefined, isValidCredential);

                credentialValidatorChain(jwtVcList);
            });
        };
        credentialValidatorChain(verifiablePresentation.vp.verifiableCredential);
    }
}

module.exports = RootOfTrustValidationStrategy;
},{"../constants":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/credentials/constants.js","../utils":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/credentials/utils.js"}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/credentials/vc/jwtVc.js":[function(require,module,exports){
const JWT = require('../jwt');
const JWT_ERRORS = require('../constants').JWT_ERRORS;
const { dateTimeFormatter, isValidURL } = require('../utils');
const { jwtVcBuilder, jwtVcParser, jwtVcVerifier } = require('./model');

class JwtVC extends JWT {
	constructor(issuer, subject, options, isInitialisation = false) {
		super();

		if (isInitialisation === true) {
			jwtVcBuilder(issuer, subject, options, (err, result) => {
				if (err) {
					return this.notifyInstanceReady(err);
				}

				this.jwtHeader = result.jwtHeader;
				this.jwtPayload = result.jwtPayload;
				this.notifyInstanceReady();
			});
		}
	}

	/**
	 * This method embeds one or more public claims about the JWT. These claims are not reflected within VC body
	 * @param claimName {string} - The name of the public claim. Reserved public claims: "vc", "vp", "iss", "sub", "iat"
	 * @param claimValue - The value of the public claim
	 * @param callback
	 */
	embedClaim(claimName, claimValue, callback) {
		super.embedClaim(claimName, claimValue, (err) => {
			if (err) {
				return callback(err);
			}

			if (claimName === 'nbf') {
				this.jwtPayload.vc.issuanceDate = dateTimeFormatter(claimValue);
			}
			if (claimName === 'exp') {
				this.jwtPayload.vc.expirationDate = dateTimeFormatter(claimValue);
			}

			callback(undefined, true);
		});
	}

	/**
	 * This method is used to extend the expiration date of a JWT
	 * @param timeInSeconds {Number}
	 * @param callback
	 */
	extendExpirationDate(timeInSeconds, callback) {
		super.extendExpirationDate(timeInSeconds, (err) => {
			if (err) {
				return callback(err);
			}

			const newExpirationDate = this.jwtPayload.exp + timeInSeconds * 1000;
			this.jwtPayload.vc.expirationDate = dateTimeFormatter(newExpirationDate);

			callback(undefined, true);
		});
	}

	/**
	 * This method embeds a new claim about the subject(s) of the JWT.
	 * Subject is mandatory if credentialSubject is an array of subjects. (To be extended tp crete JWT based on multiple subjects)
	 * @param context {string} - URI - https://www.w3.org/TR/vc-data-model/#contexts
	 * @param type {string} - Any other custom VC Types must be reflected within @context (a URI with a schema must be added)
	 * @param subjectClaims {Object} - Any claims related to the subject
	 * @param subject {string | Function} - It is mandatory if the credentialSubjects are more than one.
	 * @param callback
	 */
	embedSubjectClaim(context, type, subjectClaims, subject, callback) {
		if (typeof subject === 'function') {
			callback = subject;
			subject = null;
		}

		if (!context || typeof context !== 'string' || !isValidURL(context)) return callback(JWT_ERRORS.INVALID_CONTEXT_URI);
		if (!type || typeof type !== 'string') return callback(JWT_ERRORS.INVALID_CONTEXT_TYPE);
		if (!subjectClaims || typeof subjectClaims !== 'object') return callback(JWT_ERRORS.INVALID_SUBJECT_CLAIM);
		if (subjectClaims.id) return callback(JWT_ERRORS.IMMUTABLE_SUBJECT_CLAIM);

		const vc = this.jwtPayload.vc;
		if (Array.isArray(vc.credentialSubject)) {
			if (!subject || typeof subject !== 'string') {
				return callback(JWT_ERRORS.INVALID_SUBJECT_ID);
			}

			const targetSubjectIndex = vc.credentialSubject.findIndex(subject => subject.id === subject);
			if (targetSubjectIndex === -1) {
				return callback(JWT_ERRORS.PROVIDED_SUBJECT_ID_NOT_PRESENT);
			}

			Object.assign(vc.credentialSubject[targetSubjectIndex], subjectClaims);
		} else {
			Object.assign(vc.credentialSubject, subjectClaims);
		}

		vc['@context'].push(context);
		vc.type.push(type);
		this.jwtPayload.vc = JSON.parse(JSON.stringify(vc));

		callback(undefined, true);
	}

	async embedSubjectClaimAsync(context, type, subjectClaims, subject) {
		return this.asyncMyFunction(this.embedSubjectClaim, [...arguments]);
	}

	loadEncodedJWTVc(encodedJWT) {
		jwtVcParser(encodedJWT, (err, result) => {
			if (err) {
				return this.notifyInstanceReady(err);
			}

			this.jwtHeader = result.jwtHeader;
			this.jwtPayload = result.jwtPayload;
			this.jwtSignature = result.jwtSignature;
			this.notifyInstanceReady();
		});
	}

	verifyJWT(rootsOfTrust, callback) {
		if (typeof rootsOfTrust === 'function') {
			callback = rootsOfTrust;
			rootsOfTrust = [];
		}

		const decodedJWT = { jwtHeader: this.jwtHeader, jwtPayload: this.jwtPayload, jwtSignature: this.jwtSignature };
		jwtVcVerifier(decodedJWT, rootsOfTrust, (err, result) => {
			if (err) {
				return callback(undefined, { verifyResult: false, errorMessage: err });
			}

			callback(undefined, { verifyResult: result, ...JSON.parse(JSON.stringify(this.jwtPayload)) });
		});
	}

	verifyJWTAsync(rootsOfTrust) {
		return this.asyncMyFunction(this.verifyJWT, [...arguments]);
	}
}

/**
 * This method prepares the initial JWT options object based on the inputs. <br />
 * Points to the specific create JWT method according to the subject type
 * @param issuer
 * @param subject
 * @param options {Object}
 */
function createJWTVc(issuer, subject, options = {}) {
	return new JwtVC(issuer, subject, options, true);
}

/**
 * This method is parsing an encoded verifiable credential according to the requested type and returns the instance of the verifiable credential. <br />
 * @param encodedJWTVc {string}
 */
function loadJWTVc(encodedJWTVc) {
	const jwtInstance = new JwtVC();
	jwtInstance.loadEncodedJWTVc(encodedJWTVc);

	return jwtInstance;
}

module.exports = {
	createJWTVc, loadJWTVc
};
},{"../constants":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/credentials/constants.js","../jwt":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/credentials/jwt/index.js","../utils":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/credentials/utils.js","./model":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/credentials/vc/model.js"}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/credentials/vc/model.js":[function(require,module,exports){
const {JWT_DEFAULTS, JWT_ERRORS} = require('../constants');
const {defaultJWTParser, defaultJWTBuilder} = require('../jwt/model');
const utils = require('../utils');
const {verifyJWT} = require("../jwt/verify");

/**
 * This method creates "vc" object from the payload of a JWT according to the W3c Standard
 * @param jwtPayload
 * @param options {Object}
 * @returns {{credentialSubject: {id}, issuanceDate: string, type: *[], "@context": *[], issuer, expirationDate: string}}
 */
function getRequiredJWTVCModel(jwtPayload, options) {
    options = Object.assign({}, options, jwtPayload);
    let {vc, sub, iss, nbf, exp} = options; // can be extended with other attributes
    if (!vc) {
        vc = Object.assign({}, JWT_DEFAULTS.EMPTY_VC_VP);
    }

    return {
        // id: jti reflected - not mandatory
        '@context': [JWT_DEFAULTS.VC_VP_CONTEXT_CREDENTIALS, ...vc.context], // Mandatory and this must be the first URI from the list reference: https://www.w3.org/TR/vc-data-model/#contexts
        type: [JWT_DEFAULTS.VC_TYPE, ...vc.type], // Any other custom VC Types must be reflected within @context (a URI with a schema must be added)
        // Inside "credentialSubject" object are defined all the claims about the subject
        credentialSubject: {
            id: sub
        }, // Either single object, or an array of objects - id is mandatory and is reflected from "sub" attribute,
        issuer: iss, // reflected from "iss" attribute
        issuanceDate: utils.dateTimeFormatter(nbf), // reflected from "nbf" attribute displayed using date-time format https://www.w3.org/TR/xmlschema11-2/#dateTime
        expirationDate: utils.dateTimeFormatter(exp) // reflected from "exp" attribute displayed using date-time format https://www.w3.org/TR/xmlschema11-2/#dateTime
    };
}

function jwtVcBuilder(issuer, subject, options, callback) {
    defaultJWTBuilder(issuer, options, (err, result) => {
        if (err) {
            return callback(err);
        }

        const {jwtHeader, jwtPayload} = result;
        subject = utils.getReadableIdentity(subject);
        if (!subject) return callback(JWT_ERRORS.INVALID_SUBJECT_FORMAT);

        const subjectFormat = utils.getSubjectFormat(subject);
        if (!subjectFormat) return callback(JWT_ERRORS.INVALID_SUBJECT_FORMAT);

        jwtPayload.sub = subject;
        options.sub = subject;
        jwtPayload.vc = getRequiredJWTVCModel(jwtPayload, options);

        callback(undefined, {jwtHeader, jwtPayload});
    });
}

function jwtVcParser(encodedJWTVc, callback) {
    defaultJWTParser(encodedJWTVc, (err, decodedJWT) => {
        if (err) {
            return callback(err);
        }

        if (!decodedJWT.jwtPayload.vc) return callback(JWT_ERRORS.INVALID_JWT_PAYLOAD);
        callback(undefined, decodedJWT);
    });
}

function jwtVcVerifier(decodedJWT, rootsOfTrust, callback) {
    const {jwtHeader, jwtPayload, jwtSignature} = decodedJWT;
    const dataToSign = [utils.base64UrlEncode(JSON.stringify(jwtHeader)), utils.base64UrlEncode(JSON.stringify(jwtPayload))].join('.');

    verifyJWT(jwtPayload.iss, jwtSignature, dataToSign, {kid: jwtHeader.kid}, (err, verifyResult) => {
        if (err) return callback(err);
        if (!verifyResult) return callback(JWT_ERRORS.INVALID_JWT_SIGNATURE);

        callback(undefined, true);
    });
}

module.exports = {
    jwtVcBuilder, jwtVcParser, jwtVcVerifier
};
},{"../constants":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/credentials/constants.js","../jwt/model":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/credentials/jwt/model.js","../jwt/verify":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/credentials/jwt/verify.js","../utils":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/credentials/utils.js"}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/credentials/vp/jwtVp.js":[function(require,module,exports){
const JWT = require('../jwt');
const JWT_ERRORS = require('../constants').JWT_ERRORS;
const { jwtVpBuilder, jwtVpParser, jwtVpVerifier } = require('./model');
const { asymmetricalEncryption } = require('../utils');

class JwtVP extends JWT {
	constructor(issuer, options, isInitialisation = false) {
		super();

		if (isInitialisation === true) {
			jwtVpBuilder(issuer, options, (err, result) => {
				if (err) {
					return this.notifyInstanceReady(err);
				}

				this.jwtHeader = result.jwtHeader;
				this.jwtPayload = result.jwtPayload;
				this.notifyInstanceReady();
			});
		}
	}

	addVerifiableCredential = (encodedJWTVc, callback) => {
		if (!encodedJWTVc) {
			return callback(JWT_ERRORS.INVALID_JWT_FORMAT);
		}

		this.jwtPayload.vp.verifiableCredential.push(encodedJWTVc);
		callback(undefined, true);
	};

	async addVerifiableCredentialAsync(encodedJWTVc) {
		return this.asyncMyFunction(this.addVerifiableCredential, [...arguments]);
	}

	addEncryptedCredential = (encodedJwtVc, callback) => {
		if (!encodedJwtVc) return callback(JWT_ERRORS.INVALID_JWT_FORMAT);
		if (!this.jwtPayload.aud) return callback(JWT_ERRORS.AUDIENCE_OF_PRESENTATION_NOT_DEFINED);

		const { iss, aud } = this.jwtPayload;
		asymmetricalEncryption(iss, aud, encodedJwtVc, (err, encryptedCredential) => {
			if (err) {
				return callback(err);
			}

			this.jwtPayload.vp.verifiableCredential.push(encryptedCredential);
			callback(undefined, true);
		});
	};

	async addEncryptedCredentialAsync(encodedJwtVc) {
		return this.asyncMyFunction(this.addEncryptedCredential, [...arguments]);
	}

	loadEncodedJWTVp(encodedJWTVp) {
		jwtVpParser(encodedJWTVp, (err, result) => {
			if (err) {
				return this.notifyInstanceReady(err);
			}

			this.jwtHeader = result.jwtHeader;
			this.jwtPayload = result.jwtPayload;
			this.jwtSignature = result.jwtSignature;
			this.notifyInstanceReady();
		});
	}

	verifyJWT(rootsOfTrust, callback) {
		if (typeof rootsOfTrust === 'function') {
			callback = rootsOfTrust;
			rootsOfTrust = [];
		}

		const decodedJWT = { jwtHeader: this.jwtHeader, jwtPayload: this.jwtPayload, jwtSignature: this.jwtSignature };
		jwtVpVerifier(decodedJWT, rootsOfTrust, (err, result) => {
			if (err) {
				return callback(undefined, { verifyResult: false, errorMessage: err });
			}

			const verifyResultObj = { verifyResult: true };
			const decodedClaims = JSON.parse(JSON.stringify(this.jwtPayload));
			if (result.verifiableCredential) {
				decodedClaims.vp.verifiableCredential = result.verifiableCredential;
				if (result.verifyResult === false) {
					verifyResultObj.verifyResult = false;
					verifyResultObj.errorMessage = result.verifiableCredential.find(vc => typeof vc.errorMessage === 'string').errorMessage;
				}
			}

			const verifyResult = { ...verifyResultObj, ...decodedClaims };
			callback(undefined, verifyResult);
		});
	}

	async verifyJWTAsync(rootsOfTrust) {
		return this.asyncMyFunction(this.verifyJWT, [...arguments]);
	}
}

/**
 * This method prepares the initial JWT options object based on the inputs. <br />
 * Points to the specific create JWT method according to the subject type
 * @param issuer
 * @param options {Object}
 */
function createJWTVp(issuer, options = {}) {
	return new JwtVP(issuer, options, true);
}

/**
 * This method is parsing an encoded verifiable credential according to the requested type and returns the instance of the verifiable credential. <br />
 * @param encodedJWTVp {string}
 */
function loadJWTVp(encodedJWTVp) {
	const jwtInstance = new JwtVP();
	jwtInstance.loadEncodedJWTVp(encodedJWTVp);

	return jwtInstance;
}

module.exports = {
	createJWTVp, loadJWTVp
};
},{"../constants":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/credentials/constants.js","../jwt":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/credentials/jwt/index.js","../utils":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/credentials/utils.js","./model":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/credentials/vp/model.js"}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/credentials/vp/model.js":[function(require,module,exports){
const {JWT_DEFAULTS, JWT_ERRORS} = require('../constants');
const {defaultJWTParser, defaultJWTBuilder} = require('../jwt/model');
const utils = require('../utils');
const {verifyEncryptedCredential, verifyRootsOfTrust, verifyJWT} = require("../jwt/verify");

/**
 * This method creates "vp" object from the payload of a JWT according to the W3c Standard
 * @param jwtPayload
 * @param options {Object}
 */
function getRequiredJWTVPModel(jwtPayload, options) {
    options = Object.assign({}, options, jwtPayload);
    let {vp, iss, id} = options; // can be extended with other attributes
    if (!vp) {
        vp = Object.assign({}, JWT_DEFAULTS.EMPTY_VC_VP);
    }

    return {
        '@context': [JWT_DEFAULTS.VC_VP_CONTEXT_CREDENTIALS, ...vp.context],
        type: [JWT_DEFAULTS.VP_TYPE, ...vp.type],
        id: id, // uuid of the presentation (optional)
        verifiableCredential: options.credentialsToPresent || [],
        holder: iss // reflected from "iss" attribute
    };
}

function jwtVpBuilder(issuer, options, callback) {
    defaultJWTBuilder(issuer, options, (err, result) => {
        if (err) {
            return callback(err);
        }

        const {jwtHeader, jwtPayload} = result;
        jwtPayload.vp = getRequiredJWTVPModel(jwtPayload, options);

        callback(undefined, {jwtHeader, jwtPayload});
    });
}

function jwtVpParser(encodedJWTVp, callback) {
    defaultJWTParser(encodedJWTVp, (err, decodedJWT) => {
        if (err) {
            return callback(err);
        }

        if (!decodedJWT.jwtPayload.vp) return callback(JWT_ERRORS.INVALID_JWT_PAYLOAD);
        callback(undefined, decodedJWT);
    });
}

function jwtVpVerifier(decodedJWT, rootsOfTrust, callback) {
    const {jwtHeader, jwtPayload, jwtSignature} = decodedJWT;
    const dataToSign = [utils.base64UrlEncode(JSON.stringify(jwtHeader)), utils.base64UrlEncode(JSON.stringify(jwtPayload))].join('.');

    if (jwtPayload.aud) {
        return verifyEncryptedCredential(jwtPayload, callback);
    }

    if (rootsOfTrust.length > 0) {
        return verifyRootsOfTrust(jwtPayload, rootsOfTrust, callback);
    }

    verifyJWT(jwtPayload.iss, jwtSignature, dataToSign, {kid: jwtHeader.kid}, (err, verifyResult) => {
        if (err) return callback(err);
        if (!verifyResult) return callback(JWT_ERRORS.INVALID_JWT_SIGNATURE);

        callback(undefined, true);
    });
}

module.exports = {
    jwtVpBuilder, jwtVpParser, jwtVpVerifier
};
},{"../constants":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/credentials/constants.js","../jwt/model":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/credentials/jwt/model.js","../jwt/verify":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/credentials/jwt/verify.js","../utils":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/credentials/utils.js"}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/crypto/index.js":[function(require,module,exports){
const keySSIResolver = require("key-ssi-resolver");
const crypto = require("pskcrypto");
const cryptoRegistry = keySSIResolver.CryptoAlgorithmsRegistry;
const keySSIFactory = keySSIResolver.KeySSIFactory;
const SSITypes = keySSIResolver.SSITypes;
const CryptoFunctionTypes = keySSIResolver.CryptoFunctionTypes;
const jwtUtils = require("./jwt");
const {Mnemonic} = require("./mnemonic");

const templateSeedSSI = keySSIFactory.createType(SSITypes.SEED_SSI);
templateSeedSSI.load(SSITypes.SEED_SSI, "default");

const {JWT_ERRORS} = jwtUtils;

const getCryptoFunctionForKeySSI = (keySSI, cryptoFunctionType) => {
    return cryptoRegistry.getCryptoFunction(keySSI, cryptoFunctionType);
}
const hash = (keySSI, data, callback) => {
    console.log("This function is obsolete");
    callback(undefined, hashSync(keySSI, data));
};

const getRandomSecret = (length) => {
    const bytes = crypto.randomBytes(length);
    return bytes.toString("hex");
}

const hashSync = (keySSI, data) => {
    console.log("This function is obsolete");
    if (typeof data === "object" && !$$.Buffer.isBuffer(data)) {
        data = JSON.stringify(data);
    }
    const hash = cryptoRegistry.getHashFunction(keySSI);
    return hash(data);
}

const encrypt = (data, encryptionKey) => {
    const logger = $$.getLogger("encrypt", "opendsu/crypto");
    logger.info(0x900, "DSUs are encrypted using AES-GCM 256bit");
    const pskEncryption = crypto.createPskEncryption("aes-256-gcm");
    return pskEncryption.encrypt(data, encryptionKey);
};

const decrypt = (data, encryptionKey) => {
    const pskEncryption = crypto.createPskEncryption("aes-256-gcm");
    return pskEncryption.decrypt(data, encryptionKey);
};

const ecies_encrypt_ds = (senderKeySSI, receiverKeySSI, data) => {
    const ecies_encrypt_ds = getCryptoFunctionForKeySSI(senderKeySSI, CryptoFunctionTypes.ECIES_ENCRYPTION_DS);
    return ecies_encrypt_ds(senderKeySSI.getKeyPair(), receiverKeySSI.getPublicKey("raw"), data);
};

const ecies_decrypt_ds = (receiverKeySSI, data) => {
    const ecies_decrypt_ds = getCryptoFunctionForKeySSI(receiverKeySSI, CryptoFunctionTypes.ECIES_DECRYPTION_DS);
    return ecies_decrypt_ds(receiverKeySSI.getPrivateKey(), data);
};

const deriveEncryptionKey = (password) => {
    return crypto.deriveKey(password);
}

const convertDerSignatureToASN1 = (derSignature) => {
    return require('pskcrypto').decodeDerToASN1ETH(derSignature);
};

const sign = (keySSI, data, callback) => {
    const sign = cryptoRegistry.getSignFunction(keySSI);
    if (typeof sign !== "function") {
        throw Error("Signing not available for " + keySSI.getIdentifier(true));
    } else {
        callback(undefined, sign(data, keySSI.getPrivateKey()));
    }
};

const verifySignature = (keySSI, data, signature, publicKey, callback) => {
    if (typeof publicKey === "function") {
        callback = publicKey;
        publicKey = keySSI.getPublicKey();
    }
    const verify = cryptoRegistry.getVerifyFunction(keySSI);
    callback(undefined, verify(data, publicKey, signature));
};

const generateEncryptionKey = (keySSI, callback) => {
    const generateEncryptionKey = cryptoRegistry.getEncryptionKeyGenerationFunction(keySSI);
    callback(undefined, generateEncryptionKey());
};

const encode = (keySSI, data) => {
    console.log("This function is obsolete");
    const encode = cryptoRegistry.getEncodingFunction(keySSI);
    return encode(data);
};

const decode = (keySSI, data) => {
    console.log("This function is obsolete");
    const decode = cryptoRegistry.getDecodingFunction(keySSI);
    return decode(data);
};

const sha256 = (dataObj) => {
    const pskcrypto = require("pskcrypto");
    const hashBuffer = pskcrypto.objectHash("sha256", dataObj);
    return pskcrypto.pskBase58Encode(hashBuffer);
};

const generateRandom = (length) => {
    const pskcrypto = require("pskcrypto");
    const randomBuffer = pskcrypto.randomBytes(length);
    return randomBuffer;
}

const encodeBase58 = (data) => {
    const encodeFn = getCryptoFunctionForKeySSI(templateSeedSSI, "encoding");
    return encodeFn(data);
};

const decodeBase58 = (data) => {
    const decodeFn = getCryptoFunctionForKeySSI(templateSeedSSI, "decoding");
    return decodeFn(data);
};

const generateKeyPair = () => {
    const ecGenerator = crypto.createKeyPairGenerator();
    return ecGenerator.generateKeyPair();
}

/**
 *
 * @param rawPublicKey
 * @param outputFormat - pem or der
 */
const convertPublicKey = (rawPublicKey, outputFormat, curveName) => {
    const ecGenerator = crypto.createKeyPairGenerator();
    return ecGenerator.convertPublicKey(rawPublicKey, {outputFormat, namedCurve: curveName});
};

/**
 *
 * @param rawPrivateKey
 * @param outputFormat - pem or der
 */
const convertPrivateKey = (rawPrivateKey, outputFormat) => {
    const ecGenerator = crypto.createKeyPairGenerator();
    const rawPublicKey = ecGenerator.getPublicKey(rawPrivateKey);
    return ecGenerator.getPemKeys(rawPrivateKey, rawPublicKey, {outputFormat}).privateKey;
}

const getPublicKeyFromPrivateKey = (rawPrivateKey, outputFormat = "raw") => {
    const ecGenerator = crypto.createKeyPairGenerator();
    const rawPublicKey = ecGenerator.getPublicKey(rawPrivateKey);
    return convertPublicKey(rawPublicKey, outputFormat);
};

const createJWT = (seedSSI, scope, credentials, options, callback) => {
    jwtUtils.createJWT(
        {
            seedSSI,
            scope,
            credentials,
            options,
            sign,
        },
        callback
    );
};

const createJWTForDID = (did, scope, credentials, options, callback) => {
    jwtUtils.createJWTForDID(
        {
            did,
            scope,
            credentials,
            options
        },
        callback
    );
};

const verifyJWT = (jwt, rootOfTrustVerificationStrategy, callback) => {
    jwtUtils.verifyJWT(
        {
            jwt,
            rootOfTrustVerificationStrategy,
            verifySignature,
        },
        callback
    );
};

const verifyDID_JWT = (jwt, rootOfTrustVerificationStrategy, callback) => {
    jwtUtils.verifyDID_JWT(
        {
            jwt,
            rootOfTrustVerificationStrategy
        },
        callback
    );
};

const createCredential = (issuerSeedSSI, credentialSubjectSReadSSI, callback) => {
    createJWT(issuerSeedSSI, "", null, {subject: credentialSubjectSReadSSI}, callback);
};

const createCredentialForDID = (did, credentialSubjectDID, callback) => {
    createJWTForDID(did, "", null, {subject: credentialSubjectDID}, callback);
};

const createAuthToken = (holderSeedSSI, scope, credential, callback) => {
    createJWT(holderSeedSSI, scope, credential, null, callback);
};

const createAuthTokenForDID = (holderDID, scope, credential, callback) => {
    createJWTForDID(holderDID, scope, credential, null, callback);
};

const createPresentationToken = (holderSeedSSI, scope, credential, callback) => {
    createJWT(holderSeedSSI, scope, credential, null, callback);
};

function verifyToken(jwt, listOfIssuers, verifyJWTFn, callback) {
    if (!listOfIssuers || !listOfIssuers.length) return callback(JWT_ERRORS.EMPTY_LIST_OF_ISSUERS_PROVIDED);

    // checks every credentials from the JWT's body to see if it has at least one JWT issues by one of listOfIssuers for the current subject
    const rootOfTrustVerificationStrategy = ({body}, verificationCallback) => {
        const {sub: subject, credentials} = body;
        // the JWT doesn't have credentials specified so we cannot check for valid authorizarion
        if (!credentials) return verificationCallback(null, false);

        const currentSubject = jwtUtils.getReadableIdentity(subject);

        const credentialVerifiers = credentials.map((credential) => {
            return new Promise((resolve) => {
                verifyJWTFn(
                    credential,
                    ({body}, credentialVerificationCallback) => {
                        // check if credential was issued for the JWT that we are verifying the authorization for
                        const credentialSubject = jwtUtils.getReadableIdentity(body.sub);
                        const isCredentialIssuedForSubject = !!credentialSubject && credentialSubject === currentSubject;
                        if (!isCredentialIssuedForSubject) return credentialVerificationCallback(null, false);

                        const credentialIssuer = jwtUtils.getReadableIdentity(body.iss);

                        // console.log(`Checking for credentialIssuer ${credentialIssuer} inside `, listOfIssuers);
                        // listOfIssuers.forEach(issuer => {
                        //     console.log(`Valid issuer ${issuer}: ${jwtUtils.getReadableSSI(issuer)}`);
                        // })

                        const isValidIssuer = listOfIssuers.some((issuer) => !!credentialIssuer
                            && jwtUtils.getReadableIdentity(issuer) === credentialIssuer);
                        credentialVerificationCallback(null, isValidIssuer);
                    },
                    (credentialVerifyError, isCredentialValid) => {
                        if (credentialVerifyError) return resolve(false);
                        resolve(isCredentialValid);
                    }
                );
            }).catch(() => {
                // is something went wrong, we deny the JWT
                return false;
            });
        });

        Promise.all(credentialVerifiers)
            .then((credentialVerifierResults) => {
                const hasAtLeastOneValidIssuer = credentialVerifierResults.some((result) => result);
                if (!hasAtLeastOneValidIssuer) return verificationCallback(null, false);
                verificationCallback(null, true);
            })
            .catch(() => {
                // is something went wrong, we deny the JWT
                verificationCallback(null, false);
            });
    };

    verifyJWTFn(jwt, rootOfTrustVerificationStrategy, callback);
}

const verifyAuthToken = (jwt, listOfIssuers, callback) => {
    verifyToken(jwt, listOfIssuers, verifyJWT, callback);
};

const verifyDIDAuthToken = (jwt, listOfIssuers, callback) => {
    verifyToken(jwt, listOfIssuers, verifyDID_JWT, callback);
};

function createBloomFilter(options) {
    const BloomFilter = require("psk-dbf");
    return new BloomFilter(options);
}

const sha256JOSE = (data, encoding) => {
    const pskCrypto = require("pskcrypto");
    return pskCrypto.hash("sha256", data, encoding);
}

const base64UrlEncodeJOSE = (data) => {
    if (typeof data === "string") {
        data = $$.Buffer.from(data);
    }
    return data.toString("base64").replaceAll('+', '-').replaceAll('/', '_').replaceAll('=', '');
}

const base64UrlDecodeJOSE = (data) => {
    if ($$.Buffer.isBuffer(data)) {
        data = data.toString();
    }
    data = data.replaceAll('-', '+').replaceAll('_', '/');
    const padding = data.length % 4;
    if (padding) {
        data += '='.repeat(4 - padding);
    }

    return $$.Buffer.from(data, "base64");
}

const convertKeySSIObjectToMnemonic = (keySSIObject) => {

    const mnemonic = new Mnemonic("english");
    const randomBase64 = keySSIObject.getSpecificString();
    const randomBytes = $$.Buffer.from(randomBase64, "base64");
    return mnemonic.toMnemonic(randomBytes, sha256JOSE);
}

const convertMnemonicToKeySSIIdentifier = (phrase, typeName, domain, vn) => {
    const mnemonic = new Mnemonic("english");
    const specificStringHex = mnemonic.toRawEntropyHex(phrase);
    const specificStringBase64 = $$.Buffer.from(specificStringHex, "hex").toString("base64");
    return `ssi:${typeName}:${domain}:${specificStringBase64}::${vn}`
}

module.exports = {
    getCryptoFunctionForKeySSI,
    hash,
    hashSync,
    generateRandom,
    encrypt,
    decrypt,
    sign,
    convertDerSignatureToASN1,
    verifySignature,
    generateEncryptionKey,
    encode,
    decode,
    encodeBase58,
    decodeBase58,
    sha256,
    createJWT,
    verifyJWT,
    createCredential,
    createAuthToken,
    verifyAuthToken,
    createPresentationToken,
    getReadableSSI: jwtUtils.getReadableIdentity,
    parseJWTSegments: jwtUtils.parseJWTSegments,
    createBloomFilter,
    JWT_ERRORS,
    deriveEncryptionKey,
    generateKeyPair,
    convertPrivateKey,
    convertPublicKey,
    getPublicKeyFromPrivateKey,
    ecies_encrypt_ds,
    ecies_decrypt_ds,
    createJWTForDID,
    verifyDID_JWT,
    verifyDIDAuthToken,
    createAuthTokenForDID,
    createCredentialForDID,
    base64UrlEncodeJOSE,
    base64UrlDecodeJOSE,
    base64URLEncode: base64UrlEncodeJOSE,
    base64URLDecode: base64UrlDecodeJOSE,
    sha256JOSE,
    joseAPI: require("./jose"),
    jsonWebTokenAPI: crypto.jsonWebTokenAPI,
    convertKeySSIObjectToMnemonic,
    convertMnemonicToKeySSIIdentifier,
    getRandomSecret
};

},{"./jose":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/crypto/jose.js","./jwt":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/crypto/jwt.js","./mnemonic":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/crypto/mnemonic.js","key-ssi-resolver":"key-ssi-resolver","psk-dbf":false,"pskcrypto":"pskcrypto"}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/crypto/jose.js":[function(require,module,exports){
/**
 * This module provides functions for creating and verifying HMAC JWTs.
 * @module jose
 */

const pskcrypto = require("pskcrypto");


/**
 * Creates a signed HMAC JWT with the provided payload and secret key.
 * @param {Object} payload - The payload to be included in the JWT.
 * @param {string} secretKey - The secret key to sign the JWT with.
 * @returns {Promise} A promise that resolves with the signed JWT.
 */
const createSignedHmacJWT = (payload, secretKey) => {
    if(typeof secretKey === "string"){
        secretKey = $$.Buffer.from(secretKey);
    }
    return new pskcrypto.joseAPI.SignJWT(payload)
        .setProtectedHeader({alg: 'HS256'})
        .sign(secretKey);
}

/**
 * Creates a new HMAC key.
 * @returns {Promise} A promise that resolves with the generated secret key.
 */
const createHmacKey = async () => {
    return await pskcrypto.joseAPI.generateSecret('HS256');
}

/**
 * Verifies and retrieves the payload of an HMAC JWT.
 * @param {string} jwt - The JWT to verify.
 * @param {string} secretKey - The secret key to verify the JWT with.
 */
const verifyAndRetrievePayloadHmacJWT = async (jwt, secretKey) => {
    if(typeof secretKey === "string"){
        secretKey = $$.Buffer.from(secretKey);
    }
    return await pskcrypto.joseAPI.jwtVerify(jwt, secretKey);
}

module.exports = {
    createSignedHmacJWT,
    createHmacKey,
    verifyAndRetrievePayloadHmacJWT
}
},{"pskcrypto":"pskcrypto"}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/crypto/jwt.js":[function(require,module,exports){
const keySSIResolver = require("key-ssi-resolver");
const cryptoRegistry = keySSIResolver.CryptoAlgorithmsRegistry;
const SSITypes = keySSIResolver.SSITypes;
const keySSIFactory = keySSIResolver.KeySSIFactory;

const SEED_SSI_HEADER_TYPE = "SeedSSIJWT";
const DID_HEADER_TYPE = "DID_JWT";
const JWT_VALABILITY_SECONDS = 5 * 365 * 24 * 60 * 60; // 5 years default

const JWT_ERRORS = {
    EMPTY_JWT_PROVIDED: "EMPTY_JWT_PROVIDED",
    INVALID_JWT_FORMAT: "INVALID_JWT_FORMAT",
    INVALID_JWT_PRESENTATION: "INVALID_JWT_PRESENTATION",
    INVALID_JWT_HEADER: "INVALID_JWT_HEADER",
    INVALID_JWT_BODY: "INVALID_JWT_BODY",
    INVALID_JWT_HEADER_TYPE: "INVALID_JWT_HEADER_TYPE",
    INVALID_JWT_ISSUER: "INVALID_JWT_ISSUER",
    INVALID_CREDENTIALS_FORMAT: "INVALID_CREDENTIALS_FORMAT",
    JWT_TOKEN_EXPIRED: "JWT_TOKEN_EXPIRED",
    JWT_TOKEN_NOT_ACTIVE: "JWT_TOKEN_NOT_ACTIVE",
    INVALID_JWT_SIGNATURE: "INVALID_JWT_SIGNATURE",
    ROOT_OF_TRUST_VERIFICATION_FAILED: "ROOT_OF_TRUST_VERIFICATION_FAILED",
    EMPTY_LIST_OF_ISSUERS_PROVIDED: "EMPTY_LIST_OF_ISSUERS_PROVIDED",
    INVALID_SSI_PROVIDED: "INVALID_SSI_PROVIDED"
};

const templateSeedSSI = keySSIFactory.createType(SSITypes.SEED_SSI);
templateSeedSSI.load(SSITypes.SEED_SSI, "default");

function encodeBase58(data) {
    return cryptoRegistry.getEncodingFunction(templateSeedSSI)(data).toString();
}

function decodeBase58(data, keepBuffer) {
    const decodedValue = cryptoRegistry.getDecodingFunction(templateSeedSSI)(data);
    if (keepBuffer) {
        return decodedValue;
    }
    return decodedValue ? decodedValue.toString() : null;
}

function nowEpochSeconds() {
    return Math.floor(new Date().getTime() / 1000);
}

function getReadableIdentity(identity) {
    if (typeof identity === "string" && (identity.indexOf('ssi') === 0 || identity.indexOf('did') === 0)) {
        // ssi is actually the readable ssi
        return identity;
    }

    identity = identity.getIdentifier ? identity.getIdentifier() : identity;
    let readableSSI = decodeBase58(identity);
    if (!readableSSI) {
        // invalid base58 string
        return null;
    }
    if (readableSSI.indexOf('ssi') !== 0) {
        // invalid ssi format
        return null;
    }

    return readableSSI;
}

function createJWT({seedSSI, scope, credentials, options, sign}, callback) {
    if (typeof seedSSI === "string") {
        const keyssiSpace = require('opendsu').loadApi("keyssi");
        try {
            seedSSI = keyssiSpace.parse(seedSSI);
        } catch (e) {
            return callback(e);
        }
    }
    seedSSI.derive((err, sReadSSI) => {
        if (err) {
            return callback(err);
        }
        let {subject, valability, ...optionsRest} = options || {};
        valability = valability || JWT_VALABILITY_SECONDS;

        if (subject) {
            subject = getReadableIdentity(subject);
        } else {
            subject = sReadSSI.getIdentifier(true);
        }
        if (!subject) {
            return callback(JWT_ERRORS.INVALID_SSI_PROVIDED);
        }

        const issuer = sReadSSI.getIdentifier(true);
        if (!issuer) {
            return callback(JWT_ERRORS.INVALID_SSI_PROVIDED);
        }

        if (credentials) {
            credentials = Array.isArray(credentials) ? credentials : [credentials];
        }

        const header = {
            typ: SEED_SSI_HEADER_TYPE,
        };

        const now = nowEpochSeconds();
        const body = {
            sub: subject,
            // aud: encodeBase58(scope),
            scope,
            iss: issuer,
            publicKey: seedSSI.getPublicKey(),
            iat: now,
            nbf: now,
            exp: now + valability,
            credentials,
            options: optionsRest,
        };

        const segments = [encodeBase58(JSON.stringify(header)), encodeBase58(JSON.stringify(body))];

        const jwtToSign = segments.join(".");
        const hashFn = require("../crypto").getCryptoFunctionForKeySSI(seedSSI, "hash");
        const hashResult = hashFn(jwtToSign);
        sign(seedSSI, hashResult, (signError, signResult) => {
            if (signError || !signResult) return callback(signError);
            const encodedSignResult = encodeBase58(signResult);

            const jwt = `${jwtToSign}.${encodedSignResult}`;
            callback(null, jwt);
        });
    });
}

function createJWTForDID({did, scope, credentials, options}, callback) {
    let {subject, valability, ...optionsRest} = options || {};
    valability = valability || JWT_VALABILITY_SECONDS;
    const w3cDID = require("opendsu").loadAPI("w3cdid");

    let didDocument;
    if (typeof did === "object") {
        try {
            didDocument = did;
            did = did.getIdentifier();
        } catch (e) {
            return callback(e);
        }
    }

    if (!subject) {
        subject = did;
    }

    if (!subject) {
        return callback(JWT_ERRORS.INVALID_SSI_PROVIDED);
    }

    const issuer = did;

    if (!issuer) {
        return callback(JWT_ERRORS.INVALID_SSI_PROVIDED);
    }

    if (credentials) {
        credentials = Array.isArray(credentials) ? credentials : [credentials];
    }

    const header = {
        typ: DID_HEADER_TYPE,
    };

    const now = nowEpochSeconds();
    const __createAndSignJWT = (didDocument) => {
        didDocument.getPublicKey("pem", (err, publicKey) => {
            if (err) {
                return callback(createOpenDSUErrorWrapper(`Failed to get public key for did ${did}`, err));
            }

            const body = {
                sub: subject,
                // aud: encodeBase58(scope),
                scope,
                iss: issuer,
                publicKey,
                iat: now,
                nbf: now,
                exp: now + valability,
                credentials,
                options: optionsRest,
            };

            const segments = [encodeBase58(JSON.stringify(header)), encodeBase58(JSON.stringify(body))];
            const jwtToSign = segments.join(".");
            const crypto = require("opendsu").loadAPI("crypto");
            const hashResult = crypto.sha256(jwtToSign);

            didDocument.sign(hashResult, (signError, signResult) => {
                if (signError || !signResult) return callback(signError);
                const encodedSignResult = encodeBase58(signResult);

                const jwt = `${jwtToSign}.${encodedSignResult}`;
                callback(null, jwt);
            });
        });
    }
    if (didDocument) {
        __createAndSignJWT(didDocument);
    } else {
        w3cDID.resolveDID(did, (err, didDocument) => {
            if (err) {
                return callback(createOpenDSUErrorWrapper(`Failed to resolve did ${did}`, err));
            }

            __createAndSignJWT(didDocument);
        });
    }
}

function safeParseEncodedJson(data, keepBuffer) {
    try {
        const result = JSON.parse(decodeBase58(data, keepBuffer));
        return result;
    } catch (e) {
        return e;
    }
}

function parseJWTSegments(jwt, callback) {
    if (!jwt) return callback(JWT_ERRORS.EMPTY_JWT_PROVIDED);
    if (typeof jwt !== "string") return callback(JWT_ERRORS.INVALID_JWT_FORMAT);

    const segments = jwt.split(".");
    if (segments.length !== 3) return callback(JWT_ERRORS.INVALID_JWT_FORMAT);

    const header = safeParseEncodedJson(segments[0]);
    if (header instanceof Error || !header) return callback(JWT_ERRORS.INVALID_JWT_HEADER);

    const body = safeParseEncodedJson(segments[1]);
    if (body instanceof Error || !body) return callback(JWT_ERRORS.INVALID_JWT_BODY);

    const signatureInput = `${segments[0]}.${segments[1]}`;
    const signature = decodeBase58(segments[2], true);
    if (!signature) {
        // the signature couldn't be decoded due to an invalid signature
        return callback(JWT_ERRORS.INVALID_JWT_SIGNATURE);
    }

    return callback(null, {header, body, signature, signatureInput});
}

function isJwtExpired(body) {
    return new Date(body.exp * 1000) < new Date();
}

function isJwtNotActive(body) {
    return new Date(body.nbf * 1000) >= new Date();
}

function verifyJWTContent(jwtContent, callback) {
    const {header, body} = jwtContent;

    if (header.typ !== SEED_SSI_HEADER_TYPE && header.typ !== DID_HEADER_TYPE) return callback(JWT_ERRORS.INVALID_JWT_HEADER_TYPE);
    if (!body.iss) return callback(JWT_ERRORS.INVALID_JWT_ISSUER);
    if (isJwtExpired(body)) return callback(JWT_ERRORS.JWT_TOKEN_EXPIRED);
    if (isJwtNotActive(body)) return callback(JWT_ERRORS.JWT_TOKEN_NOT_ACTIVE);

    if (body.credentials && !Array.isArray(body.credentials)) return callback(JWT_ERRORS.INVALID_CREDENTIALS_FORMAT);

    callback(null);
}

const verifyJWT = ({jwt, rootOfTrustVerificationStrategy, verifySignature}, callback) => {
    parseJWTSegments(jwt, (parseError, jwtContent) => {
        if (parseError) return callback(parseError);

        verifyJWTContent(jwtContent, (verifyError) => {
            if (verifyError) return callback(verifyError);

            const {header, body, signatureInput, signature} = jwtContent;
            const {iss: sReadSSIString, publicKey} = body;

            const sReadSSI = keySSIFactory.create(sReadSSIString);
            const hashFn = require("../crypto").getCryptoFunctionForKeySSI(sReadSSI, "hash");
            const hash = hashFn(signatureInput);
            verifySignature(sReadSSI, hash, signature, publicKey, (verifyError, verifyResult) => {
                if (verifyError || !verifyResult) return callback(JWT_ERRORS.INVALID_JWT_SIGNATURE);

                if (typeof rootOfTrustVerificationStrategy === "function") {
                    rootOfTrustVerificationStrategy({header, body}, (verificationError, verificationResult) => {
                        if (verificationError || !verificationResult) {
                            return callback(JWT_ERRORS.ROOT_OF_TRUST_VERIFICATION_FAILED);
                        }
                        callback(null, true);
                    });
                    return;
                }

                callback(null, true);
            });
        });
    });
};

const verifyDID_JWT = ({jwt, rootOfTrustVerificationStrategy, verifySignature}, callback) => {
    parseJWTSegments(jwt, (parseError, jwtContent) => {
        if (parseError) return callback(parseError);

        verifyJWTContent(jwtContent, (verifyError) => {
            if (verifyError) return callback(verifyError);

            const {header, body, signatureInput, signature} = jwtContent;
            const {iss: did} = body;

            const openDSU = require("opendsu");
            const crypto = openDSU.loadAPI("crypto");
            const hash = crypto.sha256(signatureInput);

            const w3cDID = openDSU.loadAPI("w3cdid");
            w3cDID.resolveDID(did, (err, didDocument) => {
                if (err) {
                    return callback(createOpenDSUErrorWrapper(`Failed to resolve did ${did}`, err));
                }

                didDocument.verify(hash, signature, (verifyError, verifyResult) => {
                    if (verifyError || !verifyResult) return callback(JWT_ERRORS.INVALID_JWT_SIGNATURE);

                    if (typeof rootOfTrustVerificationStrategy === "function") {
                        rootOfTrustVerificationStrategy({header, body}, (verificationError, verificationResult) => {
                            if (verificationError || !verificationResult) {
                                return callback(JWT_ERRORS.ROOT_OF_TRUST_VERIFICATION_FAILED);
                            }
                            callback(null, true);
                        });
                        return;
                    }

                    callback(null, true);
                });
            });
        });
    });
};

module.exports = {
    createJWT,
    verifyJWT,
    getReadableIdentity,
    parseJWTSegments,
    JWT_ERRORS,
    createJWTForDID,
    verifyDID_JWT
};

},{"../crypto":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/crypto/index.js","key-ssi-resolver":"key-ssi-resolver","opendsu":"opendsu"}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/crypto/mnemonic.js":[function(require,module,exports){
let WORDLISTS = {};
WORDLISTS["english"] = [
    "abandon", "ability", "able", "about", "above", "absent", "absorb", "abstract", "absurd", "abuse",
    "access", "accident", "account", "accuse", "achieve", "acid", "acoustic", "acquire", "across", "act",
    "action", "actor", "actress", "actual", "adapt", "add", "addict", "address", "adjust", "admit",
    "adult", "advance", "advice", "aerobic", "affair", "afford", "afraid", "again", "age", "agent",
    "agree", "ahead", "aim", "air", "airport", "aisle", "alarm", "album", "alcohol", "alert",
    "alien", "all", "alley", "allow", "almost", "alone", "alpha", "already", "also", "alter",
    "always", "amateur", "amazing", "among", "amount", "amused", "analyst", "anchor", "ancient", "anger",
    "angle", "angry", "animal", "ankle", "announce", "annual", "another", "answer", "antenna", "antique",
    "anxiety", "any", "apart", "apology", "appear", "apple", "approve", "april", "arch", "arctic",
    "area", "arena", "argue", "arm", "armed", "armor", "army", "around", "arrange", "arrest",
    "arrive", "arrow", "art", "artefact", "artist", "artwork", "ask", "aspect", "assault", "asset",
    "assist", "assume", "asthma", "athlete", "atom", "attack", "attend", "attitude", "attract", "auction",
    "audit", "august", "aunt", "author", "auto", "autumn", "average", "avocado", "avoid", "awake",
    "aware", "away", "awesome", "awful", "awkward", "axis", "baby", "bachelor", "bacon", "badge",
    "bag", "balance", "balcony", "ball", "bamboo", "banana", "banner", "bar", "barely", "bargain",
    "barrel", "base", "basic", "basket", "battle", "beach", "bean", "beauty", "because", "become",
    "beef", "before", "begin", "behave", "behind", "believe", "below", "belt", "bench", "benefit",
    "best", "betray", "better", "between", "beyond", "bicycle", "bid", "bike", "bind", "biology",
    "bird", "birth", "bitter", "black", "blade", "blame", "blanket", "blast", "bleak", "bless",
    "blind", "blood", "blossom", "blouse", "blue", "blur", "blush", "board", "boat", "body",
    "boil", "bomb", "bone", "bonus", "book", "boost", "border", "boring", "borrow", "boss",
    "bottom", "bounce", "box", "boy", "bracket", "brain", "brand", "brass", "brave", "bread",
    "breeze", "brick", "bridge", "brief", "bright", "bring", "brisk", "broccoli", "broken", "bronze",
    "broom", "brother", "brown", "brush", "bubble", "buddy", "budget", "buffalo", "build", "bulb",
    "bulk", "bullet", "bundle", "bunker", "burden", "burger", "burst", "bus", "business", "busy",
    "butter", "buyer", "buzz", "cabbage", "cabin", "cable", "cactus", "cage", "cake", "call",
    "calm", "camera", "camp", "can", "canal", "cancel", "candy", "cannon", "canoe", "canvas",
    "canyon", "capable", "capital", "captain", "car", "carbon", "card", "cargo", "carpet", "carry",
    "cart", "case", "cash", "casino", "castle", "casual", "cat", "catalog", "catch", "category",
    "cattle", "caught", "cause", "caution", "cave", "ceiling", "celery", "cement", "census", "century",
    "cereal", "certain", "chair", "chalk", "champion", "change", "chaos", "chapter", "charge", "chase",
    "chat", "cheap", "check", "cheese", "chef", "cherry", "chest", "chicken", "chief", "child",
    "chimney", "choice", "choose", "chronic", "chuckle", "chunk", "churn", "cigar", "cinnamon", "circle",
    "citizen", "city", "civil", "claim", "clap", "clarify", "claw", "clay", "clean", "clerk",
    "clever", "click", "client", "cliff", "climb", "clinic", "clip", "clock", "clog", "close",
    "cloth", "cloud", "clown", "club", "clump", "cluster", "clutch", "coach", "coast", "coconut",
    "code", "coffee", "coil", "coin", "collect", "color", "column", "combine", "come", "comfort",
    "comic", "common", "company", "concert", "conduct", "confirm", "congress", "connect", "consider", "control",
    "convince", "cook", "cool", "copper", "copy", "coral", "core", "corn", "correct", "cost",
    "cotton", "couch", "country", "couple", "course", "cousin", "cover", "coyote", "crack", "cradle",
    "craft", "cram", "crane", "crash", "crater", "crawl", "crazy", "cream", "credit", "creek",
    "crew", "cricket", "crime", "crisp", "critic", "crop", "cross", "crouch", "crowd", "crucial",
    "cruel", "cruise", "crumble", "crunch", "crush", "cry", "crystal", "cube", "culture", "cup",
    "cupboard", "curious", "current", "curtain", "curve", "cushion", "custom", "cute", "cycle", "dad",
    "damage", "damp", "dance", "danger", "daring", "dash", "daughter", "dawn", "day", "deal",
    "debate", "debris", "decade", "december", "decide", "decline", "decorate", "decrease", "deer", "defense",
    "define", "defy", "degree", "delay", "deliver", "demand", "demise", "denial", "dentist", "deny",
    "depart", "depend", "deposit", "depth", "deputy", "derive", "describe", "desert", "design", "desk",
    "despair", "destroy", "detail", "detect", "develop", "device", "devote", "diagram", "dial", "diamond",
    "diary", "dice", "diesel", "diet", "differ", "digital", "dignity", "dilemma", "dinner", "dinosaur",
    "direct", "dirt", "disagree", "discover", "disease", "dish", "dismiss", "disorder", "display", "distance",
    "divert", "divide", "divorce", "dizzy", "doctor", "document", "dog", "doll", "dolphin", "domain",
    "donate", "donkey", "donor", "door", "dose", "double", "dove", "draft", "dragon", "drama",
    "drastic", "draw", "dream", "dress", "drift", "drill", "drink", "drip", "drive", "drop",
    "drum", "dry", "duck", "dumb", "dune", "during", "dust", "dutch", "duty", "dwarf",
    "dynamic", "eager", "eagle", "early", "earn", "earth", "easily", "east", "easy", "echo",
    "ecology", "economy", "edge", "edit", "educate", "effort", "egg", "eight", "either", "elbow",
    "elder", "electric", "elegant", "element", "elephant", "elevator", "elite", "else", "embark", "embody",
    "embrace", "emerge", "emotion", "employ", "empower", "empty", "enable", "enact", "end", "endless",
    "endorse", "enemy", "energy", "enforce", "engage", "engine", "enhance", "enjoy", "enlist", "enough",
    "enrich", "enroll", "ensure", "enter", "entire", "entry", "envelope", "episode", "equal", "equip",
    "era", "erase", "erode", "erosion", "error", "erupt", "escape", "essay", "essence", "estate",
    "eternal", "ethics", "evidence", "evil", "evoke", "evolve", "exact", "example", "excess", "exchange",
    "excite", "exclude", "excuse", "execute", "exercise", "exhaust", "exhibit", "exile", "exist", "exit",
    "exotic", "expand", "expect", "expire", "explain", "expose", "express", "extend", "extra", "eye",
    "eyebrow", "fabric", "face", "faculty", "fade", "faint", "faith", "fall", "false", "fame",
    "family", "famous", "fan", "fancy", "fantasy", "farm", "fashion", "fat", "fatal", "father",
    "fatigue", "fault", "favorite", "feature", "february", "federal", "fee", "feed", "feel", "female",
    "fence", "festival", "fetch", "fever", "few", "fiber", "fiction", "field", "figure", "file",
    "film", "filter", "final", "find", "fine", "finger", "finish", "fire", "firm", "first",
    "fiscal", "fish", "fit", "fitness", "fix", "flag", "flame", "flash", "flat", "flavor",
    "flee", "flight", "flip", "float", "flock", "floor", "flower", "fluid", "flush", "fly",
    "foam", "focus", "fog", "foil", "fold", "follow", "food", "foot", "force", "forest",
    "forget", "fork", "fortune", "forum", "forward", "fossil", "foster", "found", "fox", "fragile",
    "frame", "frequent", "fresh", "friend", "fringe", "frog", "front", "frost", "frown", "frozen",
    "fruit", "fuel", "fun", "funny", "furnace", "fury", "future", "gadget", "gain", "galaxy",
    "gallery", "game", "gap", "garage", "garbage", "garden", "garlic", "garment", "gas", "gasp",
    "gate", "gather", "gauge", "gaze", "general", "genius", "genre", "gentle", "genuine", "gesture",
    "ghost", "giant", "gift", "giggle", "ginger", "giraffe", "girl", "give", "glad", "glance",
    "glare", "glass", "glide", "glimpse", "globe", "gloom", "glory", "glove", "glow", "glue",
    "goat", "goddess", "gold", "good", "goose", "gorilla", "gospel", "gossip", "govern", "gown",
    "grab", "grace", "grain", "grant", "grape", "grass", "gravity", "great", "green", "grid",
    "grief", "grit", "grocery", "group", "grow", "grunt", "guard", "guess", "guide", "guilt",
    "guitar", "gun", "gym", "habit", "hair", "half", "hammer", "hamster", "hand", "happy",
    "harbor", "hard", "harsh", "harvest", "hat", "have", "hawk", "hazard", "head", "health",
    "heart", "heavy", "hedgehog", "height", "hello", "helmet", "help", "hen", "hero", "hidden",
    "high", "hill", "hint", "hip", "hire", "history", "hobby", "hockey", "hold", "hole",
    "holiday", "hollow", "home", "honey", "hood", "hope", "horn", "horror", "horse", "hospital",
    "host", "hotel", "hour", "hover", "hub", "huge", "human", "humble", "humor", "hundred",
    "hungry", "hunt", "hurdle", "hurry", "hurt", "husband", "hybrid", "ice", "icon", "idea",
    "identify", "idle", "ignore", "ill", "illegal", "illness", "image", "imitate", "immense", "immune",
    "impact", "impose", "improve", "impulse", "inch", "include", "income", "increase", "index", "indicate",
    "indoor", "industry", "infant", "inflict", "inform", "inhale", "inherit", "initial", "inject", "injury",
    "inmate", "inner", "innocent", "input", "inquiry", "insane", "insect", "inside", "inspire", "install",
    "intact", "interest", "into", "invest", "invite", "involve", "iron", "island", "isolate", "issue",
    "item", "ivory", "jacket", "jaguar", "jar", "jazz", "jealous", "jeans", "jelly", "jewel",
    "job", "join", "joke", "journey", "joy", "judge", "juice", "jump", "jungle", "junior",
    "junk", "just", "kangaroo", "keen", "keep", "ketchup", "key", "kick", "kid", "kidney",
    "kind", "kingdom", "kiss", "kit", "kitchen", "kite", "kitten", "kiwi", "knee", "knife",
    "knock", "know", "lab", "label", "labor", "ladder", "lady", "lake", "lamp", "language",
    "laptop", "large", "later", "latin", "laugh", "laundry", "lava", "law", "lawn", "lawsuit",
    "layer", "lazy", "leader", "leaf", "learn", "leave", "lecture", "left", "leg", "legal",
    "legend", "leisure", "lemon", "lend", "length", "lens", "leopard", "lesson", "letter", "level",
    "liar", "liberty", "library", "license", "life", "lift", "light", "like", "limb", "limit",
    "link", "lion", "liquid", "list", "little", "live", "lizard", "load", "loan", "lobster",
    "local", "lock", "logic", "lonely", "long", "loop", "lottery", "loud", "lounge", "love",
    "loyal", "lucky", "luggage", "lumber", "lunar", "lunch", "luxury", "lyrics", "machine", "mad",
    "magic", "magnet", "maid", "mail", "main", "major", "make", "mammal", "man", "manage",
    "mandate", "mango", "mansion", "manual", "maple", "marble", "march", "margin", "marine", "market",
    "marriage", "mask", "mass", "master", "match", "material", "math", "matrix", "matter", "maximum",
    "maze", "meadow", "mean", "measure", "meat", "mechanic", "medal", "media", "melody", "melt",
    "member", "memory", "mention", "menu", "mercy", "merge", "merit", "merry", "mesh", "message",
    "metal", "method", "middle", "midnight", "milk", "million", "mimic", "mind", "minimum", "minor",
    "minute", "miracle", "mirror", "misery", "miss", "mistake", "mix", "mixed", "mixture", "mobile",
    "model", "modify", "mom", "moment", "monitor", "monkey", "monster", "month", "moon", "moral",
    "more", "morning", "mosquito", "mother", "motion", "motor", "mountain", "mouse", "move", "movie",
    "much", "muffin", "mule", "multiply", "muscle", "museum", "mushroom", "music", "must", "mutual",
    "myself", "mystery", "myth", "naive", "name", "napkin", "narrow", "nasty", "nation", "nature",
    "near", "neck", "need", "negative", "neglect", "neither", "nephew", "nerve", "nest", "net",
    "network", "neutral", "never", "news", "next", "nice", "night", "noble", "noise", "nominee",
    "noodle", "normal", "north", "nose", "notable", "note", "nothing", "notice", "novel", "now",
    "nuclear", "number", "nurse", "nut", "oak", "obey", "object", "oblige", "obscure", "observe",
    "obtain", "obvious", "occur", "ocean", "october", "odor", "off", "offer", "office", "often",
    "oil", "okay", "old", "olive", "olympic", "omit", "once", "one", "onion", "online",
    "only", "open", "opera", "opinion", "oppose", "option", "orange", "orbit", "orchard", "order",
    "ordinary", "organ", "orient", "original", "orphan", "ostrich", "other", "outdoor", "outer", "output",
    "outside", "oval", "oven", "over", "own", "owner", "oxygen", "oyster", "ozone", "pact",
    "paddle", "page", "pair", "palace", "palm", "panda", "panel", "panic", "panther", "paper",
    "parade", "parent", "park", "parrot", "party", "pass", "patch", "path", "patient", "patrol",
    "pattern", "pause", "pave", "payment", "peace", "peanut", "pear", "peasant", "pelican", "pen",
    "penalty", "pencil", "people", "pepper", "perfect", "permit", "person", "pet", "phone", "photo",
    "phrase", "physical", "piano", "picnic", "picture", "piece", "pig", "pigeon", "pill", "pilot",
    "pink", "pioneer", "pipe", "pistol", "pitch", "pizza", "place", "planet", "plastic", "plate",
    "play", "please", "pledge", "pluck", "plug", "plunge", "poem", "poet", "point", "polar",
    "pole", "police", "pond", "pony", "pool", "popular", "portion", "position", "possible", "post",
    "potato", "pottery", "poverty", "powder", "power", "practice", "praise", "predict", "prefer", "prepare",
    "present", "pretty", "prevent", "price", "pride", "primary", "print", "priority", "prison", "private",
    "prize", "problem", "process", "produce", "profit", "program", "project", "promote", "proof", "property",
    "prosper", "protect", "proud", "provide", "public", "pudding", "pull", "pulp", "pulse", "pumpkin",
    "punch", "pupil", "puppy", "purchase", "purity", "purpose", "purse", "push", "put", "puzzle",
    "pyramid", "quality", "quantum", "quarter", "question", "quick", "quit", "quiz", "quote", "rabbit",
    "raccoon", "race", "rack", "radar", "radio", "rail", "rain", "raise", "rally", "ramp",
    "ranch", "random", "range", "rapid", "rare", "rate", "rather", "raven", "raw", "razor",
    "ready", "real", "reason", "rebel", "rebuild", "recall", "receive", "recipe", "record", "recycle",
    "reduce", "reflect", "reform", "refuse", "region", "regret", "regular", "reject", "relax", "release",
    "relief", "rely", "remain", "remember", "remind", "remove", "render", "renew", "rent", "reopen",
    "repair", "repeat", "replace", "report", "require", "rescue", "resemble", "resist", "resource", "response",
    "result", "retire", "retreat", "return", "reunion", "reveal", "review", "reward", "rhythm", "rib",
    "ribbon", "rice", "rich", "ride", "ridge", "rifle", "right", "rigid", "ring", "riot",
    "ripple", "risk", "ritual", "rival", "river", "road", "roast", "robot", "robust", "rocket",
    "romance", "roof", "rookie", "room", "rose", "rotate", "rough", "round", "route", "royal",
    "rubber", "rude", "rug", "rule", "run", "runway", "rural", "sad", "saddle", "sadness",
    "safe", "sail", "salad", "salmon", "salon", "salt", "salute", "same", "sample", "sand",
    "satisfy", "satoshi", "sauce", "sausage", "save", "say", "scale", "scan", "scare", "scatter",
    "scene", "scheme", "school", "science", "scissors", "scorpion", "scout", "scrap", "screen", "script",
    "scrub", "sea", "search", "season", "seat", "second", "secret", "section", "security", "seed",
    "seek", "segment", "select", "sell", "seminar", "senior", "sense", "sentence", "series", "service",
    "session", "settle", "setup", "seven", "shadow", "shaft", "shallow", "share", "shed", "shell",
    "sheriff", "shield", "shift", "shine", "ship", "shiver", "shock", "shoe", "shoot", "shop",
    "short", "shoulder", "shove", "shrimp", "shrug", "shuffle", "shy", "sibling", "sick", "side",
    "siege", "sight", "sign", "silent", "silk", "silly", "silver", "similar", "simple", "since",
    "sing", "siren", "sister", "situate", "six", "size", "skate", "sketch", "ski", "skill",
    "skin", "skirt", "skull", "slab", "slam", "sleep", "slender", "slice", "slide", "slight",
    "slim", "slogan", "slot", "slow", "slush", "small", "smart", "smile", "smoke", "smooth",
    "snack", "snake", "snap", "sniff", "snow", "soap", "soccer", "social", "sock", "soda",
    "soft", "solar", "soldier", "solid", "solution", "solve", "someone", "song", "soon", "sorry",
    "sort", "soul", "sound", "soup", "source", "south", "space", "spare", "spatial", "spawn",
    "speak", "special", "speed", "spell", "spend", "sphere", "spice", "spider", "spike", "spin",
    "spirit", "split", "spoil", "sponsor", "spoon", "sport", "spot", "spray", "spread", "spring",
    "spy", "square", "squeeze", "squirrel", "stable", "stadium", "staff", "stage", "stairs", "stamp",
    "stand", "start", "state", "stay", "steak", "steel", "stem", "step", "stereo", "stick",
    "still", "sting", "stock", "stomach", "stone", "stool", "story", "stove", "strategy", "street",
    "strike", "strong", "struggle", "student", "stuff", "stumble", "style", "subject", "submit", "subway",
    "success", "such", "sudden", "suffer", "sugar", "suggest", "suit", "summer", "sun", "sunny",
    "sunset", "super", "supply", "supreme", "sure", "surface", "surge", "surprise", "surround", "survey",
    "suspect", "sustain", "swallow", "swamp", "swap", "swarm", "swear", "sweet", "swift", "swim",
    "swing", "switch", "sword", "symbol", "symptom", "syrup", "system", "table", "tackle", "tag",
    "tail", "talent", "talk", "tank", "tape", "target", "task", "taste", "tattoo", "taxi",
    "teach", "team", "tell", "ten", "tenant", "tennis", "tent", "term", "test", "text",
    "thank", "that", "theme", "then", "theory", "there", "they", "thing", "this", "thought",
    "three", "thrive", "throw", "thumb", "thunder", "ticket", "tide", "tiger", "tilt", "timber",
    "time", "tiny", "tip", "tired", "tissue", "title", "toast", "tobacco", "today", "toddler",
    "toe", "together", "toilet", "token", "tomato", "tomorrow", "tone", "tongue", "tonight", "tool",
    "tooth", "top", "topic", "topple", "torch", "tornado", "tortoise", "toss", "total", "tourist",
    "toward", "tower", "town", "toy", "track", "trade", "traffic", "tragic", "train", "transfer",
    "trap", "trash", "travel", "tray", "treat", "tree", "trend", "trial", "tribe", "trick",
    "trigger", "trim", "trip", "trophy", "trouble", "truck", "true", "truly", "trumpet", "trust",
    "truth", "try", "tube", "tuition", "tumble", "tuna", "tunnel", "turkey", "turn", "turtle",
    "twelve", "twenty", "twice", "twin", "twist", "two", "type", "typical", "ugly", "umbrella",
    "unable", "unaware", "uncle", "uncover", "under", "undo", "unfair", "unfold", "unhappy", "uniform",
    "unique", "unit", "universe", "unknown", "unlock", "until", "unusual", "unveil", "update", "upgrade",
    "uphold", "upon", "upper", "upset", "urban", "urge", "usage", "use", "used", "useful",
    "useless", "usual", "utility", "vacant", "vacuum", "vague", "valid", "valley", "valve", "van",
    "vanish", "vapor", "various", "vast", "vault", "vehicle", "velvet", "vendor", "venture", "venue",
    "verb", "verify", "version", "very", "vessel", "veteran", "viable", "vibrant", "vicious", "victory",
    "video", "view", "village", "vintage", "violin", "virtual", "virus", "visa", "visit", "visual",
    "vital", "vivid", "vocal", "voice", "void", "volcano", "volume", "vote", "voyage", "wage",
    "wagon", "wait", "walk", "wall", "walnut", "want", "warfare", "warm", "warrior", "wash",
    "wasp", "waste", "water", "wave", "way", "wealth", "weapon", "wear", "weasel", "weather",
    "web", "wedding", "weekend", "weird", "welcome", "west", "wet", "whale", "what", "wheat",
    "wheel", "when", "where", "whip", "whisper", "wide", "width", "wife", "wild", "will",
    "win", "window", "wine", "wing", "wink", "winner", "winter", "wire", "wisdom", "wise",
    "wish", "witness", "wolf", "woman", "wonder", "wood", "wool", "word", "work", "world",
    "worry", "worth", "wrap", "wreck", "wrestle", "wrist", "write", "wrong", "yard", "year",
    "yellow", "you", "young", "youth", "zebra", "zero", "zone", "zoo"];

const Mnemonic = function (language) {

    const RADIX = 2048;

    const self = this;
    let wordlist = [];

    function init() {
        wordlist = WORDLISTS[language];
        if (wordlist.length != RADIX) {
            throw Error('Wordlist should contain ' + RADIX + ' words, but it contains ' + wordlist.length + ' words.');
        }
    }

    self.toMnemonic = function (byteArray, hashFunction) {
        if (byteArray.length % 4 > 0) {
            throw 'Data length in bits should be divisible by 32, but it is not (' + byteArray.length + ' bytes = ' + byteArray.length * 8 + ' bits).'
        }

        const data = byteArrayToWordArray(byteArray);
        const hash = byteArrayToWordArray(hashFunction(data));

        const h = fromBits(hash);
        const a = byteArrayToBinaryString(byteArray);
        const c = zfill(hexStringToBinaryString(h), 256);
        const d = c.substring(0, byteArray.length * 8 / 32);

        const b = a + d;

        let result = [];
        const blen = b.length / 11;
        for (let i = 0; i < blen; i++) {
            const idx = parseInt(b.substring(i * 11, (i + 1) * 11), 2);
            result.push(wordlist[idx]);
        }
        return self.joinWords(result);
    }


    self.toRawEntropyHex = function (mnemonic) {
        const b = mnemonicToBinaryString(mnemonic);
        if (b === null)
            return null;
        const d = b.substring(0, b.length / 33 * 32);
        const nd = binaryStringToWordArray(d);

        let h = "";
        for (let i = 0; i < nd.length; i++) {
            h += ('0000000' + nd[i].toString(16)).slice(-8);
        }
        return h;
    }

    self.splitWords = function (mnemonic) {
        return mnemonic.split(/\s/g).filter(function (x) { return x.length; });
    }

    self.joinWords = function (words) {
        // Set space correctly depending on the language
        // see https://github.com/bitcoin/bips/blob/master/bip-0039/bip-0039-wordlists.md#japanese
        let space = " ";
        if (language == "japanese") {
            space = "\u3000"; // ideographic space
        }
        return words.join(space);
    }

    self.normalizeString = function (str) {
        return str.normalize("NFKD");
    }

    function byteArrayToWordArray(data) {
        let a = [];
        for (let i = 0; i < data.length / 4; i++) {
            let v = 0;
            v += data[i * 4 + 0] << 8 * 3;
            v += data[i * 4 + 1] << 8 * 2;
            v += data[i * 4 + 2] << 8 * 1;
            v += data[i * 4 + 3] << 8 * 0;
            a.push(v);
        }
        return a;
    }

    function byteArrayToBinaryString(data) {
        let bin = "";
        for (let i = 0; i < data.length; i++) {
            bin += zfill(data[i].toString(2), 8);
        }
        return bin;
    }

    function hexStringToBinaryString(hexString) {
        let binaryString = "";
        for (let i = 0; i < hexString.length; i++) {
            binaryString += zfill(parseInt(hexString[i], 16).toString(2), 4);
        }
        return binaryString;
    }

    function binaryStringToWordArray(binary) {
        const aLen = binary.length / 32;
        let a = [];
        for (let i = 0; i < aLen; i++) {
            const valueStr = binary.substring(0, 32);
            const value = parseInt(valueStr, 2);
            a.push(value);
            binary = binary.slice(32);
        }
        return a;
    }

    function mnemonicToBinaryString(mnemonicString) {
        const mnemonic = self.splitWords(mnemonicString);
        if (mnemonic.length == 0 || mnemonic.length % 3 > 0) {
            return null;
        }
       
        let idx = [];
        for (let i = 0; i < mnemonic.length; i++) {
            const word = mnemonic[i];
            const wordIndex = wordlist.indexOf(word);
            if (wordIndex == -1) {
                return null;
            }
            const binaryIndex = zfill(wordIndex.toString(2), 11);
            idx.push(binaryIndex);
        }
        return idx.join('');
    }

    // Pad a numeric string on the left with zero digits until the given width
    // is reached.
    // Note this differs to the python implementation because it does not
    // handle numbers starting with a sign.
    function zfill(source, length) {
        source = source.toString();
        while (source.length < length) {
            source = '0' + source;
        }
        return source;
    }

    function bitLength(a){
        let l = a.length, x;
        if (l === 0) { return 0; }
        x = a[l - 1];
        return (l - 1) * 32 + getPartial(x);
    }

    function getPartial(x) {
        return Math.round(x / 0x10000000000) || 32;
    }

    /** Convert from a bitArray to a UTF-8 string. */
    function fromBits(arr) {
        let out = "", i;
        for (i = 0; i < arr.length; i++) {
            out += ((arr[i] | 0) + 0xF00000000000).toString(16).substr(4);
        }
        return out.substr(0, bitLength(arr) / 4);
    }

    init();
}

module.exports = {
    Mnemonic
};

},{}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/db/conflictSolvingStrategies/timestampMergingStrategy.js":[function(require,module,exports){
module.exports.TimestampMergingStrategy = function(){

}
},{}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/db/impl/BasicDB.js":[function(require,module,exports){
/*
    An OpenDSU  BasicDB is a simple noSQL database
    The DB is used with a concept of "table" and rows (records) that have multiple versions
    The support for multiple versions is offered by getVersions function and by automatically managing 2 fields in the records:
         - the "__version" field representing the height of the graph
         - the "__previousRecord" field pointing to the previous version of the record
         - the "__changeId" is unique id, is used to quickly determine the unique id of parent node/s for future conflict solving
         - the "__timestamp" is a timestamp, number of milliseconds elapsed since January 1, 1970 00:00:00 UTC.

    As you can see, nothing is ever really updated, even the deletion is done by marking the record with the field "deleted"
 */

const ObservableMixin = require("../../utils/ObservableMixin");
let bindAutoPendingFunctions = require("../../utils/BindAutoPendingFunctions").bindAutoPendingFunctions;

/*
const crypto = require("crypto"); TODO: if required use from pskcrypto to have a single and portable point in all code

function uid(bytes = 32) {
    // node
    if (process) {
        return crypto.randomBytes(bytes).toString('base64')
    }
    // browser
    else {
        if (!crypto || !crypto.getRandomValues) {
            throw new Error('crypto.getRandomValues not supported by the browser.')
        }
        return btoa(String.fromCharCode(...crypto.getRandomValues(new Uint8Array(bytes))))
    }
}  */


function BasicDB(storageStrategy, conflictSolvingStrategy, options) {
    let self = this;
    options = options || {events: false};
    ObservableMixin(this);

    const errorAPI = require("opendsu").loadAPI("error");

    storageStrategy.on("initialised", () => {
        this.finishInitialisation();
        this.dispatchEvent("initialised");
    });

    this.refresh = (callback) => {
        storageStrategy.refresh(callback);
    }

    this.getUniqueIdAsync = async () => {
        return await storageStrategy.getUniqueIdAsync();
    }

    this.getAllRecords = (tableName, callback) => {
        storageStrategy.getAllRecords(tableName, callback);
    }

    this.addIndex = function (tableName, fieldName, forceReindex, callback) {
        if (typeof tableName === "undefined" || tableName === "undefined") {
            return callback(Error(`Table name "undefined" is not allowed`));
        }

        if (typeof forceReindex === "function") {
            callback = forceReindex;
            forceReindex = false;
        }

        if (typeof forceReindex === "undefined") {
            forceReindex = false;
        }

        storageStrategy.addIndex(tableName, fieldName, forceReindex, callback);
    }
    /*
        Get the whole content of the table and asynchronously return an array with all the  records satisfying the condition tested by the filterFunction
     */
    this.filter = function (tableName, query, sort, limit, callback) {
        storageStrategy.filter(tableName, query, sort, limit, callback);
    };

    this.query = this.filter;

    this.getAllTableNames = function (callback) {
        storageStrategy.getAllTableNames(callback);
    }

    function getDefaultCallback(message, tableName, key) {
        return function (err) {
            if (err) {
                reportUserRelevantError(message + ` with errors in table ${tableName} for key ${key}`, err);
            } else {
                console.log(message, `in table ${tableName} for key ${key}`);
            }
        }
    }

    /*
      Insert a record, return an error if an record with thew same key already exists
    */
    this.insertRecord = function (tableName, key, record, callback) {
        callback = callback ? callback : getDefaultCallback("Inserting a record", tableName, key);
        if (typeof key === "undefined" || key === "undefined") {
            return callback(Error(`Primary key "undefined" is not allowed`));
        }
        if (typeof tableName === "undefined" || tableName === "undefined") {
            return callback(Error(`Table name "undefined" is not allowed`));
        }

        self.getRecord(tableName, key, function (err, res) {
            if (!err || res) {
                //newRecord = Object.assign(newRecord, {__version:-1});
                return callback(createOpenDSUErrorWrapper("Failed to insert over an existing record", new Error(errorAPI.DB_INSERT_EXISTING_RECORD_ERROR)));
            }
            const sharedDSUMetadata = {}
            sharedDSUMetadata.__version = record.__version || 0;
            sharedDSUMetadata.pk = key;
            //sharedDSUMetadata.__changeId = uid();
            sharedDSUMetadata.__timestamp = record.__timestamp || Date.now();
            storageStrategy.insertRecord(tableName, key, Object.assign(sharedDSUMetadata, record), (err, res) => {
                if (err) {
                    return callback(createOpenDSUErrorWrapper(`Failed to insert record with key ${key} in table ${tableName} `, err));
                }

                if (options.events) {
                    self.dispatchEvent("change", JSON.stringify({table: tableName, pk: key}));
                }
                callback(undefined, res);
            });
        });
    };


    /*
        Update a record, return an error if does not exists (does not do an insert)
     */
    this.updateRecord = function (tableName, key, newRecord, callback) {
        callback = callback ? callback : getDefaultCallback("Updating a record", tableName, key);
        if (typeof key === "undefined" || key === "undefined") {
            return callback(Error(`Primary key "undefined" is not allowed`));
        }
        if (typeof tableName === "undefined" || tableName === "undefined") {
            return callback(Error(`Table name "undefined" is not allowed`));
        }

        let currentRecord;

        function doVersionIncAndUpdate(currentRecord, callback) {
            newRecord.__version++;
            newRecord.__timestamp = Date.now();
            //newRecord.__changeId = uid();

            if (newRecord.__version == 0) {
                storageStrategy.insertRecord(tableName, key, newRecord, callback);
            } else {
                storageStrategy.updateRecord(tableName, key, currentRecord, newRecord, callback);
            }
        }

        self.getRecord(tableName, key, function (err, res) {
            if (err || !res) {
                //newRecord = Object.assign(newRecord, {__version:-1});
                return callback(createOpenDSUErrorWrapper("Failed to update a record that does not exist", err));
            }
            if (res) {
                currentRecord = res;
                newRecord.__version = currentRecord.__version;
                newRecord.pk = key;
            }
            doVersionIncAndUpdate(currentRecord, (err) => {
                if (err) {
                    return callback(createOpenDSUErrorWrapper(`Failed to update record with key ${key} in table ${tableName} `, err));
                }

                if (options.events) {
                    self.dispatchEvent("change", JSON.stringify({table: tableName, pk: key}));
                }
                callback(undefined, newRecord);
            });
        });
    }

    /*
        Get a single row from a table
     */
    this.getRecord = function (tableName, key, callback) {
        storageStrategy.getRecord(tableName, key, function (err, res) {
            if (err || res.__deleted) {
                return callback(createOpenDSUErrorWrapper(`Missing record in table ${tableName} and key ${key}`, err));
            }
            callback(undefined, res);
        });
    };

    /*
      Get the history of a record, including the deleted versions
   */
    this.getHistory = function (tableName, key, callback) {
        storageStrategy.getRecord(tableName, key, function (err, res) {
            if (err) {
                return callback(createOpenDSUErrorWrapper(`No history for table ${tableName} and key ${key}`, err));
            }
            callback(undefined, self.getRecordVersions(res));
        });
    };

    /*
      Delete a record
     */
    this.deleteRecord = function (tableName, key, callback) {
        self.getRecord(tableName, key, function (err, oldRecord) {
            if (err) {
                return callback(createOpenDSUErrorWrapper(`Could not retrieve record with key ${key} does not exist ${tableName} `, err));
            }

            const newRecord = JSON.parse(JSON.stringify(oldRecord));
            newRecord.__version++;
            newRecord.__timestamp = Date.now();
            newRecord.__deleted = true;
            storageStrategy.updateRecord(tableName, key, oldRecord, newRecord, (err) => {
                if (err) {
                    return callback(createOpenDSUErrorWrapper(`Failed to update with key ${key} in table ${tableName} `, err));
                }

                if (options.events) {
                    self.dispatchEvent("change", JSON.stringify({table: tableName, pk: key}));
                }
                callback();
            });
        })
    };

    this.getRecordVersions = function (record) {
        let arrRes = []
        while (record) {
            arrRes.unshift(record);
            record = record.__previousRecord;
        }
        return arrRes;
    }

    this.getIndexedFields = function (tableName, callback) {
        storageStrategy.getIndexedFields(tableName, callback);
    }

    this.writeKey = function (key, value, callback) {
        storageStrategy.writeKey(key, value, callback);
    };

    this.readKey = function (key, callback) {
        storageStrategy.readKey(key, callback);
    }
    this.beginBatch = () => {
        storageStrategy.beginBatch()
    }

    this.safeBeginBatch = (...args) => {
        storageStrategy.safeBeginBatch(...args);
    }

    this.safeBeginBatchAsync = async (...args) => {
        return await storageStrategy.safeBeginBatchAsync(...args);
    }

    this.startOrAttachBatch = (...args) => {
        storageStrategy.startOrAttachBatch(...args);
    }

    this.startOrAttachBatchAsync = async (...args) => {
        return await storageStrategy.startOrAttachBatchAsync(...args);
    }

    this.cancelBatch = (...args) => {
        storageStrategy.cancelBatch(...args);
    }

    this.cancelBatchAsync = async (...args) => {
        return await storageStrategy.cancelBatchAsync(...args);
    }

    this.commitBatch = (...args) => {
        storageStrategy.commitBatch(...args);
    }

    this.commitBatchAsync = async (...args) => {
        return await storageStrategy.commitBatchAsync(...args);
    }

    this.onCommitBatch = (...args) => {
        storageStrategy.onCommitBatch(...args);
    }

    this.batchInProgress = () => {
        return storageStrategy.batchInProgress();
    }

    bindAutoPendingFunctions(this, ["on", "off", "dispatchEvent", "batchInProgress"]);
    //============================================================
    // To not add others property on this object below this call =
    //============================================================
}

module.exports = BasicDB;

},{"../../utils/BindAutoPendingFunctions":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/utils/BindAutoPendingFunctions.js","../../utils/ObservableMixin":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/utils/ObservableMixin.js","opendsu":"opendsu"}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/db/impl/DSUDBUtil.js":[function(require,module,exports){
module.exports = {
    ensure_WalletDB_DSU_Initialisation: function (keySSI, dbName, callback) {
        let resolver = require("../../resolver");
        let keySSIApis = require("../../keyssi");
        let constants = require("../../moduleConstants");

        let doStorageDSUInitialisation = registerMandatoryCallback(
            function (dsu, sharableSSI) {
                callback(undefined, dsu, sharableSSI);
            }, 10000);

        if (typeof keySSI === "string") {
            try {
                keySSI = keySSIApis.parse(keySSI);
            } catch (e) {
                return callback(createOpenDSUErrorWrapper(`Failed to parse keySSI ${keySSI}`, e));
            }
        }
        resolver.loadDSU(keySSI, (err, dsuInstance) => {
            if ((err || !dsuInstance) && keySSI.getTypeName() === constants.KEY_SSIS.SEED_SSI) {
                return createSeedDSU();
            }

            waitForWritableSSI(dsuInstance);
        });

        function createSeedDSU() {
            let writableDSU;

            function createWritableDSU() {
                let writableSSI = keySSIApis.createTemplateKeySSI(constants.KEY_SSIS.SEED_SSI, keySSI.getDLDomain());
                resolver.createDSU(writableSSI, function (err, res) {
                    if (err) {
                        return callback(createOpenDSUErrorWrapper("Failed to create writable DSU while initialising shared database " + dbName, err));
                    }
                    writableDSU = res;
                    createWrapperDSU();
                });
            }

            function createWrapperDSU() {
                resolver.createDSUForExistingSSI(keySSI, function (err, res) {
                    if (err) {
                        return callback(createOpenDSUErrorWrapper("Failed to create wrapper DSU while initialising shared database " + dbName, err));
                    }
                    res.safeBeginBatch(err => {
                        if (err) {
                            return callback(createOpenDSUErrorWrapper("Failed to begin batch", err));
                        }
                        res.mount("/data", writableDSU.getCreationSSI(), function (err, resSSI) {
                            if (err) {
                                const mountError = createOpenDSUErrorWrapper("Failed to mount writable DSU in wrapper DSU while initialising shared database " + dbName, err)
                                res.cancelBatch(error => {
                                    if (error) {
                                        return callback(createOpenDSUErrorWrapper(`Failed to cancel batch`, error, mountError));
                                    }

                                    return callback(mountError);
                                })
                            }
                            res.commitBatch((err) => {
                                if (err) {
                                    return callback(createOpenDSUErrorWrapper("Failed to anchor batch", err));
                                }
                                doStorageDSUInitialisation(writableDSU, keySSI);
                            });
                        });
                    });
                });
            }

            reportUserRelevantWarning("Creating a new shared database");
            createWritableDSU();
        }

        function waitForWritableSSI(dsuInstance) {
            dsuInstance.getArchiveForPath("/data/dsu-metadata-log", (err, result) => {
                if (err) {
                    return callback(createOpenDSUErrorWrapper("Failed to load writable DSU " + dbName, err));
                }

                const keyssiAPI = require("opendsu").loadAPI("keyssi");
                const writableSSI = keyssiAPI.parse(result.archive.getCreationSSI());
                if (writableSSI.getTypeName() === "sread") {
                    console.log("Delaying the loading of DSU based on the fact that current stare not reflecting a DB dsu type structure");
                    return setTimeout(() => {
                        dsuInstance.load(waitForWritableSSI);
                    }, 1000);
                }

                doStorageDSUInitialisation(result.archive, keySSI);
                reportUserRelevantWarning("Loading a shared database");
            });
        }

    },
    initialiseWalletDB: function (dbName, keySSI, callback) {
        if (typeof keySSI === "function") {
            callback = keySSI;
            keySSI = undefined;
        }
        const openDSU = require("opendsu");
        let resolver = openDSU.loadAPI("resolver");
        let scAPI = openDSU.loadAPI("sc");
        let keySSISpace = openDSU.loadAPI("keyssi");
        let storageDSU;
        const DB_KEY_SSI_PATH = `/db/${dbName}`;
        scAPI.getMainDSU(async (err, mainDSU) => {
            if (err) {
                return callback(err);
            }

            if (!keySSI) {
                try {
                    keySSI = await $$.promisify(mainDSU.readFile)(DB_KEY_SSI_PATH);
                    keySSI = keySSI.toString();

                } catch (e) {
                    let vaultDomain;
                    try {
                        vaultDomain = await $$.promisify(scAPI.getVaultDomain)();
                    } catch (e) {
                        return callback(createOpenDSUErrorWrapper(`Failed to get vault domain`, e));
                    }
                    try {
                        storageDSU = await $$.promisify(resolver.createSeedDSU)(vaultDomain);
                    } catch (e) {
                        return callback(createOpenDSUErrorWrapper(`Failed to create Seed DSU`, e));
                    }

                    try {
                        keySSI = await $$.promisify(storageDSU.getKeySSIAsObject)();
                    } catch (e) {
                        return callback(createOpenDSUErrorWrapper(`Failed to get storageDSU's keySSI`, e));
                    }

                    let mainDSUKeySSI;
                    try {
                        mainDSUKeySSI = await $$promisify(mainDSU.readFile)(DB_KEY_SSI_PATH);
                    } catch (e) {
                        mainDSUKeySSI = undefined;
                    }

                    if (mainDSUKeySSI && mainDSUKeySSI.toString() !== keySSI.getIdentifier()) {
                        try {
                            await mainDSU.safeBeginBatchAsync();
                        } catch (e) {
                            return callback(createOpenDSUErrorWrapper(`Failed to begin batch`, e));
                        }

                        try {
                            await $$.promisify(mainDSU.writeFile)(DB_KEY_SSI_PATH, keySSI.getIdentifier());
                            await mainDSU.commitBatchAsync();
                        } catch (e) {
                            const writeFileError = createOpenDSUErrorWrapper(`Failed to store key SSI in mainDSU for db <${dbName}>`, e);
                            try {
                                await mainDSU.cancelBatchAsync();
                            } catch (error) {
                                return callback(createOpenDSUErrorWrapper(`Failed to cancel batch`, error, writeFileError));
                            }
                            return callback(writeFileError);
                        }

                    }
                    return callback(undefined, storageDSU, keySSI);
                }
            }

            try {
                storageDSU = await $$.promisify(resolver.loadDSU)(keySSI)
            } catch (e) {
                return callback(createOpenDSUErrorWrapper(`Failed to load storage DSU for db <${dbName}>`, e));
            }

            if (typeof keySSI === "string") {
                try {
                    keySSI = keySSISpace.parse(keySSI);
                } catch (e) {
                    return callback(createOpenDSUErrorWrapper(`Failed to parse keySSI <${keySSI}>`, e));
                }
            }

            let mainDSUKeySSI;
            try {
                mainDSUKeySSI = await $$promisify(mainDSU.readFile)(DB_KEY_SSI_PATH);
            } catch (e) {
                mainDSUKeySSI = undefined;
            }

            if (mainDSUKeySSI && mainDSUKeySSI.toString() !== keySSI.getIdentifier()) {
                try {
                    await mainDSU.safeBeginBatchAsync();
                } catch (e) {
                    return callback(createOpenDSUErrorWrapper(`Failed to begin batch`, e));
                }

                try {
                    await $$.promisify(mainDSU.writeFile)(DB_KEY_SSI_PATH, keySSI.getIdentifier());
                    await mainDSU.commitBatchAsync();
                } catch (e) {
                    const writeFileError = createOpenDSUErrorWrapper(`Failed to store key SSI in mainDSU for db <${dbName}>`, e);
                    try {
                        await mainDSU.cancelBatchAsync();
                    } catch (error) {
                        return callback(createOpenDSUErrorWrapper(`Failed to cancel batch`, error, writeFileError));
                    }
                    return callback(writeFileError);
                }
            }

            return callback(undefined, storageDSU, keySSI);
        })
    },
    ensure_MultiUserDB_DSU_Initialisation: function (keySSI, dbName, userId, callback) {
    },
    initialiseVersionlessDB: function (dbName, keySSI, callback) {
        $$.LEGACY_BEHAVIOUR_ENABLED = true;
        if (typeof keySSI === "function") {
            callback = keySSI;
            keySSI = undefined;
        }
        const openDSU = require("opendsu");
        let resolver = openDSU.loadAPI("resolver");
        let scAPI = openDSU.loadAPI("sc");
        let keySSISpace = openDSU.loadAPI("keyssi");
        let storageDSU;
        const DB_KEY_SSI_PATH = `/db/${dbName}`;
        scAPI.getMainDSU(async (err, mainDSU) => {
            if (err) {
                return callback(err);
            }

            if (!keySSI) {
                try {
                    keySSI = await $$.promisify(mainDSU.readFile)(DB_KEY_SSI_PATH);
                    keySSI = keySSI.toString();

                } catch (e) {
                    try {
                        storageDSU = await $$.promisify(resolver.createVersionlessDSU)();
                    } catch (e) {
                        return callback(createOpenDSUErrorWrapper(`Failed to create Seed DSU`, e));
                    }

                    try {
                        keySSI = await $$.promisify(storageDSU.getKeySSIAsObject)();
                    } catch (e) {
                        return callback(createOpenDSUErrorWrapper(`Failed to get storageDSU's keySSI`, e));
                    }

                    try {
                        await $$.promisify(mainDSU.writeFile)(DB_KEY_SSI_PATH, keySSI.getIdentifier());
                    } catch (e) {
                        const writeFileError = createOpenDSUErrorWrapper(`Failed to store key SSI in mainDSU for db <${dbName}>`, e);
                        return callback(writeFileError);
                    }

                    return callback(undefined, storageDSU, keySSI);
                }
            }

            try {
                storageDSU = await $$.promisify(resolver.loadDSU)(keySSI)
            } catch (e) {
                return callback(createOpenDSUErrorWrapper(`Failed to load storage DSU for db <${dbName}>`, e));
            }

            if (typeof keySSI === "string") {
                try {
                    keySSI = keySSISpace.parse(keySSI);
                } catch (e) {
                    return callback(createOpenDSUErrorWrapper(`Failed to parse keySSI <${keySSI}>`, e));
                }
            }

            try {
                await $$.promisify(mainDSU.writeFile)(DB_KEY_SSI_PATH, keySSI.getIdentifier());
            } catch (e) {
                const writeFileError = createOpenDSUErrorWrapper(`Failed to store key SSI in mainDSU for db <${dbName}>`, e);
                return callback(writeFileError);
            }

            return callback(undefined, storageDSU, keySSI);
        })
    }
}

},{"../../keyssi":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/keyssi/index.js","../../moduleConstants":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/moduleConstants.js","../../resolver":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/resolver/index.js","opendsu":"opendsu"}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/db/index.js":[function(require,module,exports){
let util = require("./impl/DSUDBUtil")
const logger = $$.getLogger("opendsu", "db");
function getBasicDB(storageStrategy, conflictSolvingStrategy, options) {
    let BasicDB = require("./impl/BasicDB");
    return new BasicDB(storageStrategy, conflictSolvingStrategy, options);
}

function getMultiUserDB(keySSI, dbName) {
    throw "Not implemented yet";
}

let getSharedDB = function (keySSI, dbName, options) {
    let SingleDSUStorageStrategy = require("./storageStrategies/SingleDSUStorageStrategy").SingleDSUStorageStrategy;
    let storageStrategy = new SingleDSUStorageStrategy();
    let ConflictStrategy = require("./conflictSolvingStrategies/timestampMergingStrategy").TimestampMergingStrategy;
    let db = getBasicDB(storageStrategy, new ConflictStrategy(), options);

    util.ensure_WalletDB_DSU_Initialisation(keySSI, dbName, function (err, _storageDSU, sharableSSI) {
        if (err) {
            return OpenDSUSafeCallback()(createOpenDSUErrorWrapper("Failed to initialise WalletDB_DSU " + dbName, err));
        }
        storageStrategy.initialise(_storageDSU, dbName);

        db.getShareableSSI = function () {
            return sharableSSI;
        };
    })

    return db;
};

let getSimpleWalletDB = (dbName, options) => {
    options = options || {};
    let SingleDSUStorageStrategy = require("./storageStrategies/SingleDSUStorageStrategy").SingleDSUStorageStrategy;
    let storageStrategy = new SingleDSUStorageStrategy();
    let ConflictStrategy = require("./conflictSolvingStrategies/timestampMergingStrategy").TimestampMergingStrategy;
    let db = getBasicDB(storageStrategy, new ConflictStrategy(), options);

    util.initialiseWalletDB(dbName, options.keySSI, (err, _storageDSU, keySSI) => {
        if (err) {
            const code = 0x401;
            logger.error(code, "Failed to initialise WalletDB_DSU " + dbName, err);
            return db.dispatchEvent("error", createOpenDSUErrorWrapper("Failed to initialise WalletDB_DSU " + dbName, err));
        }

        db.getShareableSSI = function () {
            return keySSI;
        };

        db.getStorageDSU = function () {
            return _storageDSU;
        }

        db.onCommitBatch = function(callback, once){
            db.getStorageDSU().onCommitBatch(callback, once);
        }

        storageStrategy.initialise(_storageDSU, dbName);
    })

    return db;
};

const getInMemoryDB = () => {
    const MemoryStorageStrategy = require("./storageStrategies/MemoryStorageStrategy");
    const storageStrategy = new MemoryStorageStrategy();
    return getBasicDB(storageStrategy);
}

const getEnclaveDB = () => {
    throw Error("Not implemented");
};

const mainEnclaveIsInitialised = () => {
    require("opendsu").loadAPI("sc").mainEnclaveIsInitialised();
};

const getMainEnclaveDB = (callback) => {
    require("opendsu").loadAPI("sc").getMainEnclave(callback);
}

const getSharedEnclaveDB = (callback) => {
    require("opendsu").loadAPI("sc").getSharedEnclave(callback);
}

const getVersionlessDB = (dbName, options) => {
    options = options || {};
    let VersionlessStorageStrategy = require("./storageStrategies/VersionlessStorageStrategy").VersionlessStorageStrategy;
    let storageStrategy = new VersionlessStorageStrategy();
    let ConflictStrategy = require("./conflictSolvingStrategies/timestampMergingStrategy").TimestampMergingStrategy;
    let db = getBasicDB(storageStrategy, new ConflictStrategy(), options);

    util.initialiseVersionlessDB(dbName, options.keySSI, (err, _storageDSU, keySSI) => {
        if (err) {
            console.error("Failed to initialise WalletDB_DSU " + dbName, err);
            return db.dispatchEvent("error", createOpenDSUErrorWrapper("Failed to initialise WalletDB_DSU " + dbName, err));
        }

        db.getShareableSSI = function () {
            return keySSI;
        };

        db.getStorageDSU = function () {
            return _storageDSU;
        }

        storageStrategy.initialise(_storageDSU, dbName);
    })

    return db;
}

module.exports = {
    getBasicDB,
    getWalletDB(keySSI, dbName) {
        console.warn(`The function "getWalletDB is obsolete. Use getSimpleWalletDB instead`);
        return getSharedDB(keySSI, dbName);
    },
    getSimpleWalletDB,
    getMultiUserDB,
    getSharedDB,
    getInMemoryDB,
    getEnclaveDB,
    getMainEnclaveDB,
    getMainEnclave: getMainEnclaveDB,
    mainEnclaveIsInitialised,
    getSharedEnclave: getSharedEnclaveDB,
    getSharedEnclaveDB,
    getVersionlessDB
}

},{"./conflictSolvingStrategies/timestampMergingStrategy":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/db/conflictSolvingStrategies/timestampMergingStrategy.js","./impl/BasicDB":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/db/impl/BasicDB.js","./impl/DSUDBUtil":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/db/impl/DSUDBUtil.js","./storageStrategies/MemoryStorageStrategy":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/db/storageStrategies/MemoryStorageStrategy.js","./storageStrategies/SingleDSUStorageStrategy":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/db/storageStrategies/SingleDSUStorageStrategy.js","./storageStrategies/VersionlessStorageStrategy":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/db/storageStrategies/VersionlessStorageStrategy.js","opendsu":"opendsu"}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/db/storageStrategies/MemoryStorageStrategy.js":[function(require,module,exports){
(function (Buffer){(function (){
function MemoryStorageStrategy() {
    const ObservableMixin = require("../../utils/ObservableMixin");
    const operators = require("./operators");
    let volatileMemory = {}
    let self = this
    ObservableMixin(this);

    function getTable(tableName) {
        let table = volatileMemory[tableName];
        if (!table) {
            table = volatileMemory[tableName] = {};
        }
        return table;
    }

    /*
       Get the whole content of the table and asynchronously returns an array with all the  records satisfying the condition tested by the filterFunction
    */
    this.filterTable = function (tableName, filterFunction, callback) {
        let tbl = getTable(tableName);
        let result = [];
        for (let n in tbl) {
            let item = tbl[n];
            if (filterFunction(item)) {
                item.__key = n;
                result.push(item);
            }
        }
        callback(undefined, result);
    };

    this.filter = function (tableName, conditionsArray, sort, limit, callback) {
        if (typeof conditionsArray === "function") {
            callback = conditionsArray;
            conditionsArray = undefined;
            sort = undefined;
            limit = undefined;
        }

        if (typeof conditionsArray === "undefined") {
            conditionsArray = "__timestamp > 0";
        }

        if (typeof conditionsArray === "string") {
            conditionsArray = [conditionsArray];
        } else if (!Array.isArray(conditionsArray)) {
            return callback(Error(`Condition argument of filter function need to be string or array of strings`));
        }

        if (typeof sort === "function") {
            callback = sort;
            sort = undefined;
            limit = undefined;
        }

        if (typeof limit === "function") {
            callback = limit;
            limit = undefined;
        }

        if (typeof limit === "undefined") {
            limit = Infinity;
        }

        if (typeof sort === "undefined") {
            sort = "asc";
        }

        const tbl = getTable(tableName);
        const records = Object.values(tbl);
        const filteredRecords = [];
        let Query = require("./Query");
        let query = new Query(conditionsArray);
        const conditions = query.getConditions();
        records.forEach(record => {
            let shouldBeAdded = true;
            for (let i = 0; i < conditions.length; i++) {
                if (!operators[conditions[i][1]](record[conditions[i][0]], conditions[i][2])) {
                    shouldBeAdded = false;
                }
            }
            if (shouldBeAdded && filteredRecords.length < limit) {
                filteredRecords.push(record);
            }
        })
        query.sortValues(filteredRecords, sort);
        callback(undefined, filteredRecords);
    }

    this.getAllRecords = (tableName, callback) => {
        const table = getTable(tableName);
        let values = Object.values(table);
        if(values.length === 0){
            return callback(undefined, []);
        }

        values = values.filter((record) => {
            if (!record.__deleted) {
                return record;
            }
        });

        callback(undefined, values);
    }
    /*
      Insert a record, return error if already exists
    */
    this.insertRecord = function (tableName, key, record, callback, reInsert = false) {
        let currentParent = getTable(tableName)

        function _insertRecord(currentParent, currentKey) {
            if (!reInsert && currentParent[currentKey] != undefined) {
                return callback(new Error("Can't insert a new record for currentKey " + currentKey))
            }

            currentParent[currentKey] = record;
            callback(undefined, record);
        }

        if (typeof key === 'string') {
            _insertRecord(currentParent, key)
        } else {
            let currentKey = key[0];
            for (let i = 1; i <= key.length; i++) {
                if (currentParent[currentKey] == undefined) {
                    currentParent[currentKey] = i === key.length ? undefined : {}
                }

                if (i === key.length) {
                    break
                } else {
                    currentParent = currentParent[currentKey]
                    currentKey = key[i];
                }
            }

            _insertRecord(currentParent, currentKey)
        }
    };

    /*
        Update a record, return error if does not exists
     */
    this.updateRecord = function (tableName, key, oldRecord, newRecord, callback) {
        function _updateRecord(record, previousRecord, callback) {
            if (!previousRecord) {
                return callback(new Error("Can't update a record for key " + key))
            }

            record.__previousRecord = previousRecord;
            self.insertRecord(tableName, key, record, callback, true);
        }

        if (typeof callback !== 'function') {
            throw Error(`Incorrect function call. Callback must be provided!`)
        } else {
            _updateRecord(newRecord, oldRecord, callback)
        }
    };

    /*
        Get a single row from a table
     */
    this.getRecord = function (tableName, key, callback) {
        let tbl = getTable(tableName);
        let record;
        if (typeof key === 'string') {
            record = tbl[key];
            if (record == undefined) {
                return callback(new Error("Can't retrieve a record for key " + key))
            }
            callback(undefined, record);
        } else {
            record = tbl[key[0]]
            for (let i = 1; i <= key.length; i++) {
                if (record == undefined) {
                    return callback(new Error("Can't retrieve a record for key " + key.concat(".")))
                }

                if (i === key.length) {
                    break
                } else {
                    record = record[key[i]];
                }
            }

            callback(undefined, record);
        }
    };

    this.beginBatch = () => {
    }

    this.safeBeginBatch = (wait, callback) => {
        if(typeof wait === "function") {
            callback = wait;
            wait = false;
        }
        callback(undefined);
    }

    this.safeBeginBatchAsync = async () => {

    }

    this.startOrAttachBatch = (callback) => {
        callback(undefined);
    }

    this.startOrAttachBatchAsync = () =>{

    }

    this.commitBatch = (onConflict, callback) => {
        if(typeof callback === "undefined"){
            callback = onConflict;
            onConflict = undefined;
        }
        callback(undefined);
    }

    this.commitBatchAsync = async () => {

    }

    this.cancelBatch = (batchId, callback) => {
        if(typeof callback === "undefined"){
            callback = batchId;
            batchId = undefined;
        }
        callback(undefined);
    }

    this.cancelBatchAsync = async () => {

    }

    this.getUniqueIdAsync = async () => {

    }

    const READ_WRITE_KEY_TABLE = "KeyValueTable";
    this.writeKey = (key, value, callback) => {
        let valueObject = {
            type: typeof value,
            value: value
        };

        if (typeof value === "object") {
            if (Buffer.isBuffer(value)) {
                valueObject = {
                    type: "buffer",
                    value: value.toString()
                }
            } else {
                valueObject = {
                    type: "object",
                    value: JSON.stringify(value)
                }
            }
        }

        this.getRecord(READ_WRITE_KEY_TABLE, key, (err, existingValue) => {
            if (err || !existingValue) {
                this.insertRecord(READ_WRITE_KEY_TABLE, key, valueObject, callback);
            } else {
                this.updateRecord(READ_WRITE_KEY_TABLE, key, valueObject, existingValue, callback);
            }
        })
    };

    this.readKey = (key, callback) => {
        this.getRecord(READ_WRITE_KEY_TABLE, key, (err, record) => {
            if (err) {
                return callback(createOpenDSUErrorWrapper(`Failed to read key ${key}`, err));
            }

            let value;
            switch (record.type) {
                case "buffer":
                    value = Buffer.from(record.value);
                    break;
                case "object":
                    value = JSON.parse(record.value);
                    break;
                default:
                    value = record.value;
            }

            callback(undefined, value);
        });
    }

    setTimeout(() => {
        this.dispatchEvent("initialised");
    })
}

module.exports = MemoryStorageStrategy;
}).call(this)}).call(this,require("buffer").Buffer)

},{"../../utils/ObservableMixin":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/utils/ObservableMixin.js","./Query":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/db/storageStrategies/Query.js","./operators":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/db/storageStrategies/operators.js","buffer":false}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/db/storageStrategies/Query.js":[function(require,module,exports){
function Query(queryArray) {
    let conditions = [];
    const operators = require("./operators");
    const {getCompareFunction} = require("./utils");

    function queryParser(query) {
        query.forEach(fieldQuery => {
            const splitQuery = fieldQuery.split(" ");
            if (splitQuery.length < 3) {
                throw Error(`Invalid query format. A query's format is <field> <operator> <value>`);
            }
            const operatorKeys = Object.keys(operators);
            const operatorIndex = splitQuery.findIndex(operator => {
                return operatorKeys.findIndex(el => el === operator) !== -1;
            });

            if (operatorIndex === -1) {
                throw Error(`The provided query does not contain a valid operator.`);
            }

            const field = splitQuery.slice(0, operatorIndex).join(" ");
            const operator = splitQuery[operatorIndex];
            const value = splitQuery.slice(operatorIndex + 1).join(" ");

            conditions.push([field, operator, value]);
        });

    }

    this.filterValuesForIndex = (valueArray) => {
        let conds = conditions.filter(cond => cond[0] === this.getIndexName());
        return valueArray.filter(val => {
            for (let i = 0; i < conds.length; i++) {
                if (!operators[conds[i][1]](val, conds[i][2])) {
                    return false;
                }
            }

            return true;
        });
    }

    this.filter = (sortedValues, getNextRecordForValue, limit, callback) => {
        let conds = conditions.filter(cond => cond[0] !== this.getIndexName());
        let filteredRecords = [];

        function getNextRecord(currentIndex) {
            if (currentIndex === sortedValues.length) {
                return callback(undefined, filteredRecords);
            }
            getNextRecordForValue(sortedValues[currentIndex], (err, record) => {
                if (record === null || err) {
                    if(err){
                        console.log("We caught an error during record retrieval and we are skipping to the next from the list.", err);
                    }
                    getNextRecord(currentIndex + 1);
                } else {
                    processRecord(record);
                    if (currentIndex === sortedValues.length || filteredRecords.length === limit) {
                        return callback(undefined, filteredRecords);
                    }
                    getNextRecord(currentIndex);
                }
            });
        }

        function processRecord(record) {
            for (let i = 0; i < conds.length; i++) {
                if (!operators[conds[i][1]](record[conds[i][0]], conds[i][2])) {
                    return;
                }
            }
            if (record && !record.__deleted) {
                filteredRecords.push(record);
            }
        }

        getNextRecord(0);
    };

    this.sortValues = (values, sortType) => {
        let compareFn;
        try {
            compareFn = getCompareFunction(sortType);
        } catch (e) {
            throw createOpenDSUErrorWrapper(`Failed to get compare function`, e);
        }

        values.sort(compareFn);
    };

    this.getIndexName = () => {
        return conditions[0][0];
    };

    this.getConditions = () => {
        return conditions;
    }

    queryParser(queryArray);
}

module.exports = Query;
},{"./operators":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/db/storageStrategies/operators.js","./utils":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/db/storageStrategies/utils.js"}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/db/storageStrategies/SingleDSURecordStorageStrategy.js":[function(require,module,exports){
function SingleDSURecordStorageStrategy(storageDSU) {
    this.storeRecord = (recordPath, newRecord, oldRecord, callback) => {
        storageDSU.writeFile(recordPath, JSON.stringify(newRecord), callback);
    }

    this.getRecord = (recordPath, callback) => {
        storageDSU.readFile(recordPath, function (err, res) {
            let record;
            let retErr = undefined;
            if (err) {
                retErr = createOpenDSUErrorWrapper(`Failed to read record in ${recordPath}`, err);
            } else {
                try {
                    record = JSON.parse(res);
                } catch (newErr) {
                    retErr = createOpenDSUErrorWrapper(`Failed to parse record in ${recordPath}: ${res}`, retErr);
                    //let's try to check if the res contains the record twice... at some point there was a bug on this topic
                    let serializedRecord = res;
                    if (ArrayBuffer.isView(serializedRecord) || serializedRecord.buffer) {
                        serializedRecord = new TextDecoder().decode(serializedRecord);
                    }
                    let halfOfRes = serializedRecord.slice(0, serializedRecord.length / 2);
                    let isDuplicated = (serializedRecord === halfOfRes + halfOfRes);
                    if (isDuplicated) {
                        try {
                            record = JSON.parse(halfOfRes);
                            console.log("We caught an error during record retrieval process and fix it. (duplicate content)");
                            //we ignore the original error because we were able to fix it.
                            retErr = undefined;
                        } catch (err) {
                            console.log("We caught an error during record retrieval process and we failed to fix it!");
                        }
                    } else {
                        console.log(retErr);
                    }
                }
            }
            callback(retErr, record);
        });
    }
}

module.exports = SingleDSURecordStorageStrategy;
},{}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/db/storageStrategies/SingleDSUStorageStrategy.js":[function(require,module,exports){
(function (Buffer){(function (){
const ObservableMixin = require("../../utils/ObservableMixin");
const SingleDSURecordStorageStrategy = require("./SingleDSURecordStorageStrategy");
function SingleDSUStorageStrategy(recordStorageStrategy) {
    let self = this
    let storageDSU;
    let dbName;

    ObservableMixin(this);

    this.initialise = function (_storageDSU, _dbName) {
        storageDSU = _storageDSU;
        dbName = _dbName;
        if(!recordStorageStrategy){
            recordStorageStrategy = new SingleDSURecordStorageStrategy(storageDSU);
        }
        this.dispatchEvent("initialised");
    }

    this.refresh = (callback) => {
        storageDSU.refresh(callback);
    }

    this.beginBatch = () => {
        if (!storageDSU.batchInProgress()) {
            storageDSU.beginBatch();
        }
    }

    this.safeBeginBatch = (...args) => {
        storageDSU.safeBeginBatch(...args);
    }

    this.safeBeginBatchAsync = async (...args) => {
        return await storageDSU.safeBeginBatchAsync(...args);
    }

    this.startOrAttachBatch = (...args) => {
        storageDSU.startOrAttachBatch(...args);
    }

    this.startOrAttachBatchAsync = async (...args) => {
        return await storageDSU.startOrAttachBatchAsync(...args);
    }

    this.cancelBatch = (...args) => {
        storageDSU.cancelBatch(...args);
    }

    this.cancelBatchAsync = async (...args) => {
        return await storageDSU.cancelBatchAsync(...args);
    }

    this.commitBatch = (...args) => {
        storageDSU.commitBatch(...args);
    }

    this.commitBatchAsync = async (...args) => {
        return await storageDSU.commitBatchAsync(...args);
    }

    this.onCommitBatch = (...args)=>{
        storageDSU.onCommitBatch(...args);
    }

    this.batchInProgress = (...args) => {
        return storageDSU.batchInProgress(...args);
    }

    this.getAllRecords = (tableName, callback) => {
        this.filter(tableName, "__timestamp > 0", callback);
    }

    function readTheWholeTable(tableName, callback) {
        getPrimaryKeys(tableName, (err, recordKeys) => {
            if (err) {
                return callback(createOpenDSUErrorWrapper(`Failed to read the records in table ${tableName}`, err));
            }
            const table = {};
            if (recordKeys.length === 0) {
                return callback(undefined, table);
            }

            const TaskCounter = require("swarmutils").TaskCounter;
            const tc = new TaskCounter(() => {
                return callback(undefined, table);
            });
            tc.increment(recordKeys.length);
            recordKeys.forEach(recordKey => {
                self.getRecord(tableName, recordKey, (err, record) => {
                    if (err) {
                        return callback(createOpenDSUErrorWrapper(`Failed to get record ${recordKey} in table ${tableName}`, err));
                    }

                    table[recordKey] = record;
                    tc.decrement();
                });
            })
        });
    }


    /*
       Get the whole content of the table and asynchronously returns an array with all the  records satisfying the condition tested by the filterFunction
    */
    const filterTable = function (tableName, conditionsArray, sort, limit, callback) {
        readTheWholeTable(tableName, (err, tbl) => {
            if (err) {
                return callback(createOpenDSUErrorWrapper(`Failed to read table ${tableName}`, err));
            }

            const operators = require("./operators");
            const filteredRecords = [];
            const records = Object.values(tbl);
            for (let i = 0; i < records.length; i++) {
                const record = records[i];
                if (record.__deleted) {
                    continue;
                }
                let recordIsValid = true;
                for (let i = 0; i < conditionsArray.length; i++) {
                    const condition = conditionsArray[i];
                    const [field, operator, value] = condition.split(" ");
                    if (!operators[operator](record[field], value)) {
                        recordIsValid = false;
                        break;
                    }
                }

                if (recordIsValid) {
                    filteredRecords.push(record);
                }
            }

            const {getCompareFunctionForObjects} = require("./utils");
            filteredRecords.sort(getCompareFunctionForObjects(sort, conditionsArray[0].split(" ")[0]))
            callback(undefined, filteredRecords.slice(0, limit));
        });
    };

    function checkFieldIsIndexed(tableName, fieldName, callback) {
        const path = getIndexPath(tableName, fieldName);
        storageDSU.stat(path, (err, stat) => {
            if (err || typeof stat.type === "undefined") {
                return callback(undefined, false);
            }
            callback(undefined, true);
        });
    }

    this.getAllTableNames = (callback) => {
        storageDSU.listFolders(dbName, {recursive: false}, (err, tableNames) => {
            if (err) {
                return callback(createOpenDSUErrorWrapper(`Failed to list tables`, err));
            }

            console.log("tableNames", tableNames)
            callback(undefined, tableNames);
        })
    }

    this.filter = function (tableName, conditionsArray, sort, limit, callback) {
        if (typeof conditionsArray === "function") {
            callback = conditionsArray;
            conditionsArray = undefined;
            sort = undefined;
            limit = undefined;
        }

        if (typeof conditionsArray === "undefined") {
            conditionsArray = "__timestamp > 0";
        }

        if (typeof conditionsArray === "string") {
            conditionsArray = [conditionsArray];
        } else if (!Array.isArray(conditionsArray)) {
            return callback(Error(`Condition argument of filter function need to be string or array of strings`));
        }
        let Query = require("./Query");
        let query = new Query(conditionsArray);

        if (typeof sort === "function") {
            callback = sort;
            sort = undefined;
            limit = undefined;
        }

        if (typeof limit === "function") {
            callback = limit;
            limit = undefined;
        }

        if (typeof limit === "undefined") {
            limit = Infinity;
        }

        if (typeof sort === "undefined") {
            sort = "asc";
        }

        const indexName = query.getIndexName();

        checkFieldIsIndexed(tableName, indexName, (err, status) => {
            if (err) {
                return callback(createOpenDSUErrorWrapper(`Failed to add index for fields ${indexName} in table ${tableName}`, err));
            }

            const __filterIndexedTable = () => {
                storageDSU.listFiles(getIndexPath(tableName, indexName), async (err, values) => {
                    if (err) {
                        return callback(createOpenDSUErrorWrapper(`Failed read values for field ${indexName}`, err));
                    }

                    const pks = [];
                    const uniqueIndexedValues = [];

                    for (let i = 0; i < values.length; i++) {
                        const value = values[i];
                        const splitValue = value.split("/");
                        const indexOfPk = pks.indexOf(splitValue[1]);
                        if (indexOfPk === -1) {
                            pks.push(splitValue[1]);
                            uniqueIndexedValues.push(splitValue[0]);
                        } else {
                            const pk = pks[indexOfPk];
                            const record = await $$.promisify(this.getRecord, this)(tableName, pk)
                            if (record.__deleted) {
                                pks.splice(indexOfPk, 1);
                                uniqueIndexedValues.splice(indexOfPk, 1);
                            } else {
                                uniqueIndexedValues[indexOfPk] = record;
                            }
                            console.warn(`Record with pk ${splitValue[1]} already indexed on field ${indexName}`);
                        }

                    }
                    let filteredValues = query.filterValuesForIndex(uniqueIndexedValues);
                    query.sortValues(filteredValues, sort);
                    const getNextRecordForValue = getNextRecordFunction(tableName, indexName)
                    query.filter(filteredValues, getNextRecordForValue, limit, callback);
                });
            }


            if (status) {
                return __filterIndexedTable();
            }

            console.log(`Warning - You tried filtering the table <${tableName}> on field <${conditionsArray[0].split(' ')[0]}> which is not indexed. This operation can be slow. Try calling addIndex on field <${conditionsArray[0].split(' ')[0]}> first.`);
            filterTable(tableName, conditionsArray, sort, limit, callback);
        });
    }


    function getNextRecordFunction(tableName, fieldName) {
        let currentValue;
        let pksArray;
        let currentPosition;

        function getNext(callback) {
            if (currentPosition >= pksArray.length) {
                return callback(undefined, null);
            }

            self.getRecord(tableName, pksArray[currentPosition++], callback);
        }

        return function (value, callback) {
            if (value !== currentValue) {
                storageDSU.listFiles(getIndexPath(tableName, fieldName, value), (err, pks) => {
                    if (err) {
                        return callback(createOpenDSUErrorWrapper(`No primary key found for value ${value}`, err));
                    }

                    pksArray = pks;
                    currentPosition = 0;
                    currentValue = value

                    getNext(callback);
                });
            } else {
                getNext(callback);
            }
        }

    }

    this.addIndex = function (tableName, fieldName, forceReindex, callback) {
        if (typeof forceReindex === "function") {
            callback = forceReindex;
            forceReindex = false;
        }

        if (typeof forceReindex === "undefined") {
            forceReindex = false;
        }

        if (forceReindex === false) {
            checkFieldIsIndexed(tableName, fieldName, (err, status) => {
                if (err) {
                    return callback(createOpenDSUErrorWrapper(`Failed to check if field ${fieldName} in table ${tableName} is indexed`, err));
                }

                if (status === true) {
                    return callback();
                }

                createIndex(tableName, fieldName, callback);
            });
        } else {
            createIndex(tableName, fieldName, callback);
        }
    }

    this.getIndexedFields = function (tableName, callback) {
        getIndexedFieldsList(tableName, callback);
    };

    let createIndex = (tableName, fieldName, callback) => {
        getPrimaryKeys(tableName, async (err, primaryKeys) => {
            if (err) {
                return callback(createOpenDSUErrorWrapper(`Failed to get primary keys for table ${tableName}`, err));
            }

            const TaskCounter = require("swarmutils").TaskCounter;

            let batchId;
            try{
                batchId = await this.startOrAttachBatchAsync();
            }catch(err){
                return callback(err);
            }

            const taskCounter = new TaskCounter(() => {
               this.commitBatch(batchId, callback);
            });

            if (primaryKeys.length === 0) {
                return storageDSU.createFolder(getIndexPath(tableName, fieldName), (err) => {
                    if (err) {
                        return callback(createOpenDSUErrorWrapper(`Failed to create empty index for field ${fieldName} in table ${tableName}`, err));
                    }

                    this.commitBatch(batchId, callback);
                });
            }

            taskCounter.increment(primaryKeys.length);
            primaryKeys.forEach(pk => {
                self.getRecord(tableName, pk, (err, record) => {
                    if (err) {
                        return callback(createOpenDSUErrorWrapper(`Failed to get record ${pk} from table ${tableName}`));
                    }

                    storageDSU.writeFile(getIndexPath(tableName, fieldName, record[fieldName], pk), undefined, (err) => {
                        if (err) {
                            return callback(createOpenDSUErrorWrapper(`Failed to create index for field ${fieldName} in table ${tableName}`, err));
                        }

                        taskCounter.decrement();
                    });
                });
            });
        });
    }

    function createIndexForValue(tableName, fieldName, pk, value, callback) {
        const indexValuePath = getIndexPath(tableName, fieldName, value, pk);
        storageDSU.stat(indexValuePath, (err, stats) => {
            if (err) {
                return callback(err);
            }

            if (typeof stats.type === "undefined") {
                return storageDSU.writeFile(indexValuePath, (err) => {
                    let retErr = undefined;
                    if (err) {
                        retErr = createOpenDSUErrorWrapper(`Failed to create file ${indexValuePath}`, err);
                    }

                    callback(retErr)
                });
            }

            callback();
        });
    }

    function updateIndexesForRecord(tableName, pk, newRecord, callback) {
        if (newRecord.__deleted) {
            //deleted records don't need to be into indexes
            return callback();
        }
        const fields = Object.keys(newRecord);
        getIndexedFieldsList(tableName, (err, indexedFields) => {
            if (err) {
                return callback(createOpenDSUErrorWrapper(`Failed to get indexed fields list for table ${tableName}`, err));
            }

            if (indexedFields.length === 0) {
                return callback();
            }

            const TaskCounter = require("swarmutils").TaskCounter;
            const taskCounter = new TaskCounter(() => {
                return callback();
            })

            taskCounter.increment(fields.length);
            fields.forEach(field => {
                if (indexedFields.findIndex(indexedField => indexedField === field) !== -1) {
                    createIndexForValue(tableName, field, pk, newRecord[field], (err) => {
                        if (err) {
                            return callback(createOpenDSUErrorWrapper(`Failed to update index for field ${field} in table ${tableName}`, err));
                        }

                        taskCounter.decrement();
                    });
                } else {
                    taskCounter.decrement();
                }
            })
        });
    }

    // pk and value can be undefined and you get only the path to index of fieldName
    function getIndexPath(tableName, fieldName, value, pk) {
        let path = `/${dbName}/${tableName}/indexes/${fieldName}`;
        if (typeof value !== "undefined") {
            path = `${path}/${value}`;
        }

        if (typeof pk !== "undefined") {
            path = `${path}/${pk}`;
        }
        return path;
    }

    function getRecordPath(tableName, pk) {
        return `/${dbName}/${tableName}/records/${pk}`;
    }

    function deleteValueForIndex(tableName, fieldName, pk, oldValue, newValue, callback) {
        if (oldValue === newValue) {
            return callback();
        }
        storageDSU.delete(getIndexPath(tableName, fieldName, oldValue, pk), callback);
    }

    function deleteIndexesForRecord(tableName, pk, oldRecord, newRecord, callback) {
        const fields = Object.keys(oldRecord);
        getIndexedFieldsList(tableName, (err, indexedFields) => {
            if (err) {
                return callback(createOpenDSUErrorWrapper(`Failed to get indexed fields list for table ${tableName}`, err));
            }

            if (indexedFields.length === 0) {
                return callback();
            }

            const TaskCounter = require("swarmutils").TaskCounter;
            const taskCounter = new TaskCounter(() => {
                return callback();
            })

            taskCounter.increment(fields.length);
            fields.forEach(field => {
                if (indexedFields.findIndex(indexedField => indexedField === field) !== -1) {
                    deleteValueForIndex(tableName, field, pk, oldRecord[field], newRecord[field], (err) => {
                        if (err) {
                            return callback(createOpenDSUErrorWrapper(`Failed to delete index for field ${field} in table ${tableName}`, err));
                        }

                        taskCounter.decrement();
                    });
                } else {
                    taskCounter.decrement();
                }
            })
        });
    }


    function getIndexedFieldsList(tableName, callback) {
        const indexesFilePath = `/${dbName}/${tableName}/indexes`;
        storageDSU.listFolders(indexesFilePath, (err, indexes) => {
            if (err) {
                return callback(undefined, []);
            }

            callback(undefined, indexes);
        });
    }

    /*
      Insert a record
    */
    this.insertRecord = function (tableName, key, record, callback) {
        this.updateRecord(tableName, key, undefined, record, callback);
    };

    function getPrimaryKeys(tableName, callback) {
        storageDSU.listFiles(`/${dbName}/${tableName}/records`, (err, primaryKeys) => {
            if (err) {
                return storageDSU.createFolder(`/${dbName}/${tableName}/records`, (err) => {
                    if (err) {
                        return callback(createOpenDSUErrorWrapper(`Failed to retrieve primary keys list in table ${tableName}`, err));
                    }
                    callback(undefined, []);
                });
            }

            callback(undefined, primaryKeys);
        });
    }

    /*
        Update a record
     */
    this.updateRecord = function (tableName, key, oldRecord, newRecord, callback) {
        if (typeof newRecord !== "object") {
            return callback(Error(`Invalid record type. Expected "object"`))
        }

        if (Buffer.isBuffer(newRecord)) {
            return callback(Error(`"Buffer" is not a valid record type. Expected "object".`))
        }

        if (Array.isArray(newRecord)) {
            return callback(Error(`"Array" is not a valid record type. Expected "object".`))
        }

        const recordPath = getRecordPath(tableName, key);
        recordStorageStrategy.storeRecord(recordPath, newRecord, oldRecord, function (err, res) {
            if (err) {
                return callback(createOpenDSUErrorWrapper(`Failed to update record in ${recordPath}`, err));
            }

            if (typeof oldRecord !== "undefined") {
                return deleteIndexesForRecord(tableName, key, oldRecord, newRecord, (err) => {
                    if (err) {
                        return callback(createOpenDSUErrorWrapper(`Failed to delete index files for record ${JSON.stringify(newRecord)}`, err));
                    }

                    return updateIndexesForRecord(tableName, key, newRecord, (err) => {
                        if (err) {
                            return callback(createOpenDSUErrorWrapper(`Failed to update indexes for record ${newRecord}`, err));
                        }

                        callback(err, newRecord);
                    });
                });
            }

            updateIndexesForRecord(tableName, key, newRecord, (err) => {
                if (err) {
                    return callback(createOpenDSUErrorWrapper(`Failed to update indexes for record ${newRecord}`, err));
                }

                callback(err, newRecord)
            });
        });
    };

    /*
        Get a single row from a table
     */
    this.getRecord = function (tableName, key, callback) {
        const recordPath = getRecordPath(tableName, key);
        recordStorageStrategy.getRecord(recordPath, callback);
    };

    const READ_WRITE_KEY_TABLE = "KeyValueTable";
    this.writeKey = async (key, value, callback)=> {
        let batchId;
        try{
            batchId = await this.startOrAttachBatchAsync();
        }catch(err){
            return callback(err);
        }

        let valueObject = {
            type: typeof value,
            value: value
        };

        if (typeof value === "object") {
            if (Buffer.isBuffer(value)) {
                valueObject = {
                    type: "buffer",
                    value: value.toString()
                }
            } else {
                valueObject = {
                    type: "object",
                    value: JSON.stringify(value)
                }
            }
        }

        const recordPath = getRecordPath(READ_WRITE_KEY_TABLE, key);
        storageDSU.writeFile(recordPath, JSON.stringify(valueObject), async (err) => {
            if (err) {
                try{
                    await this.cancelBatch(batchId);
                }catch(e){
                    console.log(e);
                }
                return callback(err);
            }
            this.commitBatch(batchId, callback);
        });
    };

    this.readKey = function (key, callback) {
        this.getRecord(READ_WRITE_KEY_TABLE, key, (err, record) => {
            if (err) {
                return callback(createOpenDSUErrorWrapper(`Failed to read key ${key}`, err));
            }

            let value;
            switch (record.type) {
                case "buffer":
                    value = Buffer.from(record.value);
                    break;
                case "object":
                    value = JSON.parse(record.value);
                    break;
                default:
                    value = record.value;
            }

            callback(undefined, value);
        });
    }
}

module.exports.SingleDSUStorageStrategy = SingleDSUStorageStrategy;
}).call(this)}).call(this,require("buffer").Buffer)

},{"../../utils/ObservableMixin":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/utils/ObservableMixin.js","./Query":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/db/storageStrategies/Query.js","./SingleDSURecordStorageStrategy":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/db/storageStrategies/SingleDSURecordStorageStrategy.js","./operators":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/db/storageStrategies/operators.js","./utils":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/db/storageStrategies/utils.js","buffer":false,"swarmutils":"swarmutils"}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/db/storageStrategies/VersionlessRecordStorageStrategy.js":[function(require,module,exports){
function VersionlessRecordStorageStrategy(rootDSU) {
    const openDSU = require("opendsu");
    const resolver = openDSU.loadAPI("resolver");


    this.storeRecord = (recordPath, newRecord, oldRecord, callback) => {
        resolver.createVersionlessDSU(recordPath, (err, versionlessDSU) => {
            if (err) {
                return callback(err);
            }
            const filename = recordPath.split("/").pop();
            versionlessDSU.writeFile(filename, JSON.stringify(newRecord), async (err) => {
                if (err) {
                    return callback(err);
                }

                if(!oldRecord){
                    let versionlessSSI;
                    [err, versionlessSSI] = await $$.call(versionlessDSU.getKeySSIAsString);
                    if(err) {
                        return callback(err);
                    }

                    [err, res] = await $$.call(rootDSU.writeFile, recordPath, versionlessSSI);

                    if(err) {
                        return callback(err);
                    }
                }

                callback(undefined, newRecord);
            });
        });
    }

    this.getRecord = (recordPath, callback) => {
        rootDSU.readFile(recordPath, async (err, versionlessDSUSSI) => {
            if (err) {
                return callback(err);
            }

            versionlessDSUSSI = versionlessDSUSSI.toString();
            let versionlessDSU;
            [err, versionlessDSU] = await $$.call(resolver.loadDSU, versionlessDSUSSI);
            if(err) {
                return callback(err);
            }

            const filename = recordPath.split("/").pop();
            let record;
            [err, record] = await $$.call(versionlessDSU.readFile, filename);
            if(err) {
                return callback(err);
            }

            callback(undefined, JSON.parse(record));
        });
    }
}

module.exports = VersionlessRecordStorageStrategy;
},{"opendsu":"opendsu"}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/db/storageStrategies/VersionlessStorageStrategy.js":[function(require,module,exports){
const VersionlessRecordStorageStrategy = require("./VersionlessRecordStorageStrategy");
const ObservableMixin = require("../../utils/ObservableMixin");
const SingleDSUStorageStrategy = require("./SingleDSUStorageStrategy").SingleDSUStorageStrategy;
function VersionlessStorageStrategy(recordStorageStrategy) {
    let storageDSU;
    let dbName;

    ObservableMixin(this);
    this.initialise = function (_storageDSU, _dbName) {
        storageDSU = _storageDSU;
        dbName = _dbName;
        if(!recordStorageStrategy){
            recordStorageStrategy = new VersionlessRecordStorageStrategy(storageDSU);
            const singleDSUStorageStrategy = new SingleDSUStorageStrategy(recordStorageStrategy);
            singleDSUStorageStrategy.initialise(storageDSU, dbName);
            this.dispatchEvent("initialised");
            Object.assign(this, singleDSUStorageStrategy);
        }
    }
}

module.exports.VersionlessStorageStrategy = VersionlessStorageStrategy;
},{"../../utils/ObservableMixin":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/utils/ObservableMixin.js","./SingleDSUStorageStrategy":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/db/storageStrategies/SingleDSUStorageStrategy.js","./VersionlessRecordStorageStrategy":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/db/storageStrategies/VersionlessRecordStorageStrategy.js"}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/db/storageStrategies/operators.js":[function(require,module,exports){
module.exports = {
    "<": function (x, y) {
        return x < y
    },
    "<=": function (x, y) {
        return x <= y
    },
    ">": function (x, y) {
        return x > y
    },
    ">=": function (x, y) {
        return x >= y
    },
    "==": function (x, y) {
        return x == y
    },
    "!=": function (x, y) {
        if (y === "undefined") {
            y = undefined;
        }
        return x != y;
    },
    "like": function (str, regex) {
        if (typeof regex === "string") {
            let splitRegex = regex.split("/");
            if (splitRegex[0] === '') {
                splitRegex = splitRegex.slice(1);
            }
            let flag = undefined;
            if (splitRegex.length > 1) {
                flag = splitRegex.pop();
            }
            if (flag === '') {
                flag = undefined;
            }
            regex = new RegExp(splitRegex.join('/'), flag);
        }
        // return regex.test(str);
        return str.match(regex);
    }
};

},{}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/db/storageStrategies/utils.js":[function(require,module,exports){
function getCompareFunction(sortOrder) {
    if (sortOrder === "asc" || sortOrder === "ascending") {
        return function (a, b) {
            if (a < b) {
                return -1;
            }

            if (a === b) {
                return 0
            }

            if (a > b) {
                return 1;
            }
        }
    } else if (sortOrder === "dsc" || sortOrder === "descending") {
        return function (a, b) {
            if (a > b) {
                return -1;
            }

            if (a === b) {
                return 0
            }

            if (a < b) {
                return 1;
            }
        }
    } else {
        throw Error(`Invalid sort order provided <${sortOrder}>`);
    }
}

function getCompareFunctionForObjects(sortOrder, fieldName) {
    return function (firstObj, secondObj) {
        const compareFn = getCompareFunction(sortOrder);
        return compareFn(firstObj[fieldName], secondObj[fieldName]);
    }
}
module.exports = {
    getCompareFunction,
    getCompareFunctionForObjects
}
},{}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/dc/index.js":[function(require,module,exports){
/*
html API space
*/
},{}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/dt/AppBuilderService.js":[function(require,module,exports){
/**
 * @module dt
 */

/**
 *
 */
const FileService = require("./FileService");

const DSU_SPECIFIC_FILES = ["dsu-metadata.log", "manifest"]
const {_getResolver, _getKeySSISpace} = require('./commands/utils');

/**
 * Default Options set for the {@link AppBuilderService}
 * <pre>
 *     {
            anchoring: "default",
            publicSecretsKey: '-$Identity-',
            environmentKey: "-$Environment-",
            basePath: "",
            stripBasePathOnInstall: false,
            walletPath: "",
            hosts: "",
            hint: undefined,
            vault: "vault",
            seedFileName: "seed",
            appsFolderName: "apps",
            appFolderName: "app",
            codeFolderName: "code",
            initFile: "init.file",
            environment: {},
            slots:{
                primary: "wallet-patch",
                secondary: "apps-patch"
            }
        }
 * </pre>
 */
const OPTIONS = {
    anchoring: process.env.VAULT_DOMAIN || "vault",
    publicSecretsKey: '-$Identity-',
    environmentKey: "-$Environment-",
    basePath: "",
    stripBasePathOnInstall: false,
    walletPath: "",
    hosts: "",
    hint: undefined,
    vault: "vault",
    seedFileName: "seed",
    appsFolderName: "apps",
    appFolderName: "app",
    codeFolderName: "code",
    initFile: "init.file",
    environment: {},
    slots:{
        primary: "wallet-patch",
        secondary: "apps-patch"
    }
}

/**
 * Convert the Environment object into the Options object
 */
const envToOptions = function(env, opts){
    let options = Object.assign({}, OPTIONS, opts);
    options.environment = env;
    options.vault = env.vault;
    options.anchoring = env.domain;
    options.basePath = env.basePath;
    options.walletPath = env.basePath.split('/').reduce((sum, s) => sum === '' && s !== '/' ? s : sum, '');
    const opendsu = require('opendsu');
    options.hosts = $$.environmentType === 'browser'
        ? `${opendsu.loadApi('system').getEnvironmentVariable(opendsu.constants.BDNS_ROOT_HOSTS)}`
        : `localhost:8080`;
    return options;
}

/**
 *
 * @param {object} environment typically comes from an environment.js file is the ssapps. Overrides some options
 * @param {object} [opts] options object mimicking {@link OPTIONS}
 */
function AppBuilderService(environment, opts) {
    const options = envToOptions(environment, opts);
    const dossierBuilder = new (require("./DossierBuilder"))();

    const fileService = new FileService(options);

    /**
     * Lists a DSUs content
     * @param {KeySSI} keySSI
     * @param {function(err, files, mounts)} callback
     * @private
     */
    const getDSUContent = function (keySSI, callback) {
        _getResolver().loadDSU(keySSI, (err, dsu) => {
            if (err)
                return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Could not load DSU with SSI ${keySSI}`, err));
            dsu.listFiles("/", {ignoreMounts: true}, (err, files) => {
                if (err)
                    return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Could not retrieve DSU content`, err));
                dsu.listMountedDSUs("/", (err, mounts) => {
                    if (err)
                        return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Could not retrieve DSU mounts`, err));
                    callback(undefined, files.filter(f => {
                        return DSU_SPECIFIC_FILES.indexOf(f) === -1;
                    }), mounts, dsu);
                });
            });
        });
    }

    /**
     * Creates an Arrays SSI off a secret list
     *
     * Adds options.hint to hit if available
     * @param {string[]} secrets
     * @param {function(err, ArraySSI)} callback
     * @private
     */
    const createArraySSI = function(secrets, callback){
        const key = _getKeySSISpace().createArraySSI(options.anchoring, secrets, 'v0', options.hint ? JSON.stringify(options.hint) : undefined);
        callback(undefined, key);
    }

    /**
     * Creates a Wallet SSI off a secret list
     *
     * Adds options.hint to hit if available
     * @param {string[]} secrets
     * @param {function(err, ArraySSI)} callback
     */
    const createWalletSSI = function(secrets, callback){
        const key = _getKeySSISpace().createTemplateWalletSSI(options.anchoring, secrets, 'v0', options.hint ? JSON.stringify(options.hint) : undefined);
        callback(undefined, key);
    }

    /**
     * Creates an Arrays SSI off a secret list
     *
     * Adds options.hint to hit if available
     * @param {string} specificString
     * @param {function(err, TemplateSeedSSI)} callback
     */
    const createSSI = function(specificString, callback){
        const key = _getKeySSISpace().createTemplateSeedSSI(options.anchoring, specificString, undefined, 'v0', options.hint ? JSON.stringify(options.hint) : undefined);
        callback(undefined, key);
    }

    /**
     * Creates a DSU of an ArraySSI
     * @param {string[]} secrets
     * @param {object} opts DSU Creation Options
     * @param {function(err, Archive)} callback
     */
    const createWalletDSU = function(secrets, opts, callback){
        createWalletSSI(secrets, (err, keySSI) => {
            _getResolver().createDSUForExistingSSI(keySSI, opts, (err, dsu) => {
                if (err)
                    return callback(`Could not create const DSU ${err}`);
                callback(undefined, dsu);
            });
        });
    }

    /**
     * Creates a DSU of an ArraySSI
     * @param {string} specific String for Seed SSI
     * @param {object} opts DSU Creation Options
     * @param {function(err, Archive)} callback
     */
    const createDSU = function(specific, opts, callback){
        createSSI(specific, (err, keySSI) => {
            _getResolver().createDSU(keySSI, opts, (err, dsu) => {
                if (err)
                    return callback(`Could not create const DSU ${err}`);
                callback(undefined, dsu);
            });
        });
    }

    /**
     * Creates a DSU of an ArraySSI
     * @param {string[]} secrets
     * @param {object} opts DSU Creation Options
     * @param {function(err, Archive)} callback
     */
    const createConstDSU = function(secrets,opts , callback){
        createArraySSI(secrets, (err, keySSI) => {
            _getResolver().createDSUForExistingSSI(keySSI, opts, (err, dsu) => {
                if (err)
                    return callback(`Could not create const DSU ${err}`);
                callback(undefined, dsu);
            });
        });
    }

    const getDSUFactory = function(isConst, isWallet){
        return isConst ? (isWallet ? createWalletDSU : createConstDSU) : createDSU;
    }

    /**
     * Creates a new DSU (Const or not) and clones the content another DSU into it
     * @param {object|string} arg can be a secrets object or a string depending on if it's a const DSU or not. A secrets object is like:
     * <pre>
     *     {
     *         secretName: {
     *             secret: "...",
     *             public: (defaults to false. If true will be made available to the created DSU for use of initialization Scripts)
     *         },
     *         (...)
     *     }
     * </pre>
     * @param {KeySSI} keyForDSUToClone
     * @param {boolean} [isConst] decides if the Created DSU is Const or not. defaults to true
     * @param {function(err, KeySSI)} callback
     */
    this.clone = function (arg, keyForDSUToClone, isConst, callback) {
        if (typeof isConst === 'function'){
            callback = isConst;
            isConst = true;
        }
        parseSecrets(true, arg, (err, keyGenArgs, publicSecrets) => {
            if (err)
                return callback(err);
            getDSUContent(keyForDSUToClone, (err, files, mounts, dsuToClone) => {
                if (err)
                    return callback(err);
                console.log(`Loaded Template DSU with key ${keyForDSUToClone}:\nmounts: ${mounts}`);
                getDSUFactory(isConst)(keyGenArgs, (err, destinationDSU) => {
                    if (err)
                        return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper( err));
                    doClone(dsuToClone, destinationDSU, files, mounts,  publicSecrets,(err, keySSI) => {
                        if (err)
                            return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper( err));
                        console.log(`DSU ${keySSI} as a clone of ${keyForDSUToClone} was created`);
                        // if (publicSecrets)
                        //     return writeToCfg(destinationDSU, publicSecrets, err => callback(err, keySSI));
                        callback(undefined, keySSI);
                    });
                });
            });
        });
    }

    const _getPatchContent = function(appName, callback){
        fileService.getFolderContentAsJSON(appName, (err, content) => {
           if (err)
               return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Could not retrieve patch content for ${appName}`, err));
           try {
               content = JSON.parse(content);
           } catch (e) {
               return callback(`Could not parse content`);
           }
            content['/'][options.seedFileName] = undefined;
            delete content['/'][options.seedFileName];

           callback(undefined, content);
        });
    }

    const filesToCommands = (content) => {
        let commands = [];
        for (let directory in content)
            if (content.hasOwnProperty(directory)){
                let directoryFiles = content[directory];
                for (let fileName in directoryFiles)
                    if (directoryFiles.hasOwnProperty(fileName))
                        commands.push(`createfile ${directory}/${fileName} ${directoryFiles[fileName]}`);
            }
        return commands;
    }

    /**
     * Copies the patch files from the path folder onto the DSU
     * @param {Archive} dsu
     * @param {string} slotPath should be '{@link OPTIONS.slots}[/appName]' when appName is required
     * @param {function(err, Archive, KeySSI)} callback
     */
    const patch = function(dsu, slotPath, callback) {
        // Copy any files found in the RESPECTIVE PATCH FOLDER on the local file system
        // into the app's folder
        _getPatchContent(slotPath, (err, files) => {
            if (err)
                return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper( err));
            let commands = filesToCommands(files);
            if (commands.length === 0){
                console.log(`Application ${slotPath} does not require patching`);
                return callback(undefined, dsu);
            }

            dossierBuilder.buildDossier(dsu, commands, (err, keySSI) => {
                if (err)
                    return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper( err));
                console.log(`Application ${slotPath} successfully patched`);
                callback(undefined, dsu, keySSI);
            });
        });
    }

    /**
     * When writing the env to an SSApp, because she'll run in an iFrame,
     * its basePath will always be '/' unlike the loader, we have the option to strip the base path id that's desirable
     * @param {object} env
     */
    const resetBasePath = function(env){
        if (!env.stripBasePathOnInstall)
            return env;
        return Object.assign({}, env, {basePath: '/'});
    }

    /**
     * Reads from {@link OPTIONS.initFile} and executes the commands founds there via {@link DossierBuilder#buildDossier}
     * @param {Archive} instance
     * @param {object} publicSecrets what elements of the registration elements should be passed onto the SSApp
     * @param {function(err, Archive)} callback
     */
    const initializeInstance = function(instance, publicSecrets, callback){
        instance.readFile(`${options.codeFolderName}/${options.initFile}`, (err, data) => {
            if (err) {
                console.log(`No init file found. Initialization complete`);
                return callback(undefined, instance);
            }

            // embed the environment and identity into in the initializations commands
            let commands = data.toString().replace(options.environmentKey, JSON.stringify(resetBasePath(options.environment)));
            commands = (publicSecrets
                    ? commands.replace(options.publicSecretsKey, JSON.stringify(publicSecrets))
                    : commands)
                .split(/\r?\n/).map(cmd => cmd.trim()).filter(cmd => !!cmd && !cmd.startsWith('##'));

            dossierBuilder.buildDossier(instance, commands, (err, keySSI) => {
                if (err)
                   return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Could not initialize SSApp instance`, err));
                console.log(`Instance successfully initialized: ${keySSI}`);
                callback(undefined, instance);
            });
        });
    }

    /**
     * Parser the secrets object according to if its a wallet or not
     * @param {boolean} isWallet
     * @param {object|string} secrets can be a secrets object or a string depending on if it's a wallet or not. A secrets object is like:
     * <pre>
     *     {
     *         secretName: {
     *             secret: "...",
     *             public: (defaults to false. If true will be made available to the created DSU for use of initialization Scripts)
     *         },
     *         (...)
     *     }
     * </pre>
     * @param {function(err, string|string[], publicSecrets)} callback
     */
    const parseSecrets = function(isWallet, secrets, callback){
        let specificArg = secrets;
        let publicSecrets = undefined;
        if (isWallet && typeof secrets === 'object'){
            specificArg = [];
            publicSecrets = {};
            Object.entries(secrets).forEach(e => {
                if (e[1].public)
                    publicSecrets[e[0]] = e[1].secret;
                specificArg.push(e[1].secret);
            });
        }
        callback(undefined, specificArg, publicSecrets);
    }

    this.parseSecrets = parseSecrets;

    /**
     * Builds an SSApp
     * @param {boolean} isWallet
     * @param {object|string} secrets according to {@link parseSecrets}
     * @param {string} seed
     * @param {string} [name]
     * @param {function(err, KeySSI, Archive)} callback
     */
    const buildApp = function(isWallet, secrets, seed, name, callback){
        if (typeof name === 'function'){
            if (!isWallet)
                return callback(`No SSApp name provided`);
            callback = name;
            name = undefined;
        }

        const patchAndInitialize = function(instance, publicSecrets, callback){
            const patchPath = isWallet ? `${options.slots.primary}` : `${options.slots.secondary}/${name}`;
            patch(instance, patchPath, (err) => {
                if (err)
                    return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Error patching SSApp ${name}`, err));
                initializeInstance(instance, publicSecrets, (err) => {
                    if (err)
                        return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper( err));
                    instance.getKeySSIAsString((err, keySSI) => {
                        if (err)
                            return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper( err));
                        callback(undefined, keySSI);
                    });
                });
            });
        }

        parseSecrets(isWallet, secrets, (err, keyArgs, publicSecrets) => {
            if (err)
                return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper( err));
            getDSUFactory(isWallet, isWallet)(keyArgs, isWallet ? {dsuTypeSSI: seed} : undefined, (err, wallet) => {
                if (err)
                    return callback(`Could not create instance`);

                const instance = isWallet ? wallet.getWritableDSU() : wallet;

                if (isWallet)
                    return patchAndInitialize(instance, publicSecrets, (err, key) => callback(err, key, wallet));

                instance.mount(`${options.codeFolderName}`, seed, (err) => {
                    if (err)
                        return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Could not mount Application code in instance`, err));
                    patchAndInitialize(instance, publicSecrets, (err, key) => callback(err, key, wallet));
                });
            });
        });
    }

    /**
     * Retrieves the list of Applications to be installed
     * @param {function(err, object)} callback
     */
    const getListOfAppsForInstallation = (callback) => {
        fileService.getFolderContentAsJSON(options.slots.secondary, function (err, data) {
            if (err){
                console.log(`No Apps found`)
                return callback(undefined, {});
            }

            let apps;

            try {
                apps = JSON.parse(data);
            } catch (e) {
                return callback(`Could not parse App list`);
            }

            callback(undefined, apps);
        });
    };

    /**
     * Installs all aps in the apps folder in the wallet
     * @param {Archive} wallet
     * @param {function(err, object)} callback returns the apps details
     */
    const installApps = function(wallet, callback){
        const performInstallation = function(wallet, apps, appList, callback){
            if (!appList.length)
                return callback();
            let appName = appList.pop();
            const appInfo = apps[appName];

            if (appName[0] === '/')
                appName = appName.replace('/', '');

            const mountApp = (newAppSeed) => {
                wallet.mount(`/${options.appsFolderName}/${appName}`, newAppSeed, (err) => {
                    if (err)
                        return callback("Failed to mount in folder" + `/apps/${appName}: ${err}`);

                    performInstallation(wallet, apps, appList, callback);
                });
            };

            // If new instance is not demanded just mount (leftover code from privatesky.. when is it not a new instance?)
            if (appInfo.newInstance === false)
                return mountApp(appInfo.seed);

            buildApp(false, undefined, appInfo.seed, appName, (err, keySSI) => {
                if (err)
                    return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to build app ${appName}`, err));
                mountApp(keySSI);
            });
        }

        getListOfAppsForInstallation((err, apps) => {
            if (err)
                return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper( err));
            apps = apps || {};
            let appList = Object.keys(apps).filter(n => n !== '/');
            if(!appList.length)
                return callback(undefined, appList);
            let tempList = [...appList]
            performInstallation(wallet, apps, tempList, (err) => {
                if (err)
                    return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Could not complete installations`, err));
                callback(undefined, appList);
            });
        });
    }

    /**
     * Builds a new SSApp from the provided secrets
     * @param {KeySSI} seed the SSApp's keySSI
     * @param {string} name the SSApp's name
     * @param {function(err, KeySSI, Archive)} callback
     */
    this.buildSSApp = function(seed, name, callback){
        return buildApp(false, seed, name, callback);
    }

    /**
     * Builds a new Wallet from the provided secrets
     * @param {object|string} secrets according to {@link parseSecrets}
     * @param {function(err, KeySSI, Archive)} callback
     */
    this.buildWallet = function(secrets, callback){
        fileService.getWalletSeed((err, seed) => {
            if (err)
                return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper("Could not retrieve template wallet SSI.", err));
            buildApp(true, secrets, seed, (err, keySSI, wallet) => {
                if (err)
                    return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Could not build wallet`, err));
                console.log(`Wallet built with SSI ${keySSI}`);
                installApps(wallet, (err, appList) => {
                    if (err)
                        return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Could not Install Applications ${JSON.stringify(appList)}`, err));
                    if (appList.length)
                        console.log(`Applications installed successfully`);
                    callback(undefined, keySSI, wallet);
                })
            });
        });
    }

    this.loadWallet = function(secrets, callback){
        parseSecrets(true, secrets, (err, keyGenArgs) => {
            if (err)
                return callback(err);
            createWalletSSI(keyGenArgs, (err, keySSI) => {
                if (err)
                    return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Could not create wallet with ssi ${{keySSI}}`, err));
                console.log(`Loading wallet with ssi ${keySSI.getIdentifier()}`);
                _getResolver().loadDSU(keySSI, (err, wallet) => {
                    if (err)
                        return callback(`Could not load wallet DSU ${err}`);
                    wallet = wallet.getWritableDSU();
                    console.log(`wallet Loaded`);
                    wallet.getKeySSIAsString(callback);
                });
            });
        });
    }
}
module.exports = AppBuilderService;
},{"./DossierBuilder":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/dt/DossierBuilder.js","./FileService":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/dt/FileService.js","./commands/utils":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/dt/commands/utils.js","opendsu":"opendsu"}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/dt/BuildWallet.js":[function(require,module,exports){
const openDSU = require("opendsu");
const resolver = openDSU.loadAPI("resolver");
const keySSISpace = openDSU.loadAPI("keyssi");
const scAPI = openDSU.loadAPI("sc");
const enclaveAPI = openDSU.loadAPI("enclave");

function BuildWallet() {
    const secret = process.env.BUILD_SECRET_KEY || "nosecretfordevelopers";
    const vaultDomain = process.env.VAULT_DOMAIN || "vault";

    let writableDSU;

    const __ensureEnvIsInitialised = (writableDSU, callback) => {
        writableDSU.readFile("/environment.json", async (err) => {
            //TODO: check if env is a valid JSON
            if (err) {
                try {
                    await writableDSU.safeBeginBatchAsync();
                } catch (e) {
                    return callback(createOpenDSUErrorWrapper(`Failed to begin batch`, e));
                }

                try {
                    await $$.promisify(writableDSU.writeFile)("/environment.json", JSON.stringify({
                        vaultDomain: vaultDomain,
                        didDomain: vaultDomain
                    }))
                    await writableDSU.commitBatchAsync();
                } catch (e) {
                    const writeFileError = createOpenDSUErrorWrapper(`Failed to store environment.json`, e);
                    try {
                        await writableDSU.cancelBatchAsync();
                    } catch (error) {
                        return callback(createOpenDSUErrorWrapper(`Failed to cancel batch`, error, writeFileError));
                    }
                    return callback(writeFileError);
                }
            }

            callback();
        });
    }

    this.initialise = (callback) => {
        const walletSSI = keySSISpace.createTemplateWalletSSI(vaultDomain, secret);
        resolver.loadDSU(walletSSI, async (err, wallet) => {
            if (err) {
                let seedSSI;
                try {
                    seedSSI = await $$.promisify(keySSISpace.createSeedSSI)(vaultDomain)
                } catch (e) {
                    return callback(e);
                }
                try {
                    wallet = await $$.promisify(resolver.createDSUForExistingSSI)(walletSSI, {dsuTypeSSI: seedSSI});
                } catch (e) {
                    return callback(e);
                }
            }

            writableDSU = wallet.getWritableDSU();
            for (let prop in writableDSU) {
                this[prop] = writableDSU[prop];
            }

            __ensureEnvIsInitialised(writableDSU, callback);
        })
    }

    const ensureEnclaveExists = (enclaveType, callback) => {
        writableDSU.readFile("/environment.json", async (err, env) => {
            if (err) {
                return callback(err);
            }

            try {
                env = JSON.parse(env.toString());
            } catch (e) {
                return callback(e);
            }

            if (typeof env[openDSU.constants[enclaveType].KEY_SSI] === "undefined") {
                let seedDSU;
                try {
                    seedDSU = await $$.promisify(resolver.createSeedDSU)(vaultDomain);
                } catch (e) {
                    return callback(e);
                }

                let keySSI;
                try {
                    keySSI = await $$.promisify(seedDSU.getKeySSIAsString)();
                } catch (e) {
                    return callback(e);
                }
                const enclave = enclaveAPI.initialiseWalletDBEnclave(keySSI);
                enclave.on("initialised", async () => {
                    try {
                        await $$.promisify(scAPI.setEnclave)(enclave, enclaveType);
                        callback();
                    } catch (e) {
                        return callback(createOpenDSUErrorWrapper("Failed to set shared enclave", e));
                    }
                })

                enclave.on("error", (err) => {
                    return callback(createOpenDSUErrorWrapper("Failed to set shared enclave", err));
                })
            } else {
                callback();
            }
        });
    }

    this.ensureMainEnclaveExists = (callback) => {
        ensureEnclaveExists("MAIN_ENCLAVE", callback);
    }
    this.ensureSharedEnclaveExists = (callback) => {
        ensureEnclaveExists("SHARED_ENCLAVE", callback);
    }

    this.writeFile = (path, data, callback) => {
        writableDSU.writeFile(path, data, callback);
    }

    this.readFile = (path, callback) => {
        writableDSU.readFile(path, callback);
    }
}

const initialiseWallet = (callback) => {
    const scAPI = require("opendsu").loadAPI("sc");
    const buildWallet = new BuildWallet();
    buildWallet.initialise(err => {
        if (err) {
            return callback(err);
        }

        scAPI.setMainDSU(buildWallet);
        const _ensureEnclavesExist = () => {
            buildWallet.ensureMainEnclaveExists(err => {
                if (err) {
                    return callback(err);
                }
                buildWallet.ensureSharedEnclaveExists(callback);
            })
        }
        const sc = scAPI.getSecurityContext();
        if (sc.isInitialised()) {
            _ensureEnclavesExist()
        } else {
            sc.on("initialised", () => {
                _ensureEnclavesExist();
            });

            sc.on("error", (err) => {
                return callback(err);
            });
        }
    });
}

module.exports = {
    initialiseWallet
};
},{"opendsu":"opendsu"}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/dt/DossierBuilder.js":[function(require,module,exports){
/**
 * @module dt
 */

const {_getByName} = require('./commands');
const {_getSharedEnclave, _getKeySSISpace} = require('./commands/utils');

/**
 * Automates the Dossier Building process
 * Call via
 * <pre>
 *     builder.buildDossier(config, commands, callback)
 * </pre>
 * where the config is as follows (this config is generated by the buildDossier script in octopus given the proper commands):
 * <pre>
 *     {
 *          "seed": "./seed",
 *          "domain": "default",
 *     }
 * </pre>
 *
 * For a Simple SSApp (with only mounting of cardinal/themes and creation of code folder) the commands would be like:
 * <pre>
 *     delete /
 *     addfolder code
 *     mount ../cardinal/seed /cardinal
 *     mount ../themes/'*'/seed /themes/'*'
 * </pre>
 * @param {Archive} [sourceDSU] if provided will perform all OPERATIONS from the sourceDSU as source and not the fs
 * @param {VarStore} [varStore]
 */
const DossierBuilder = function (sourceDSU, varStore) {

    const _varStore = varStore || new (require('./commands/VarStore'))();

    let createDossier = function (conf, commands, callback) {
        console.log("creating a new dossier...")
        _getSharedEnclave((err, sharedEnclave) => {
            if (err) {
                return callback(err);
            }
            sharedEnclave.createDSU(_getKeySSISpace().createTemplateSeedSSI(conf.domain), (err, bar) => {
                if (err)
                    return callback(err);
                updateDossier(bar, conf, commands, callback);
            });
        })
    };

    /**
     * Writes to a file on the filesystem
     * @param filePath
     * @param data
     * @param callback
     */
    const writeFile = function (filePath, data, callback) {
        new (_getByName('createfile'))(_varStore).execute([filePath, data], (err) => err
            ? callback(err)
            : callback(undefined, data));
    }

    /**
     * Reads a file from the filesystem
     * @param filePath
     * @param callback
     */
    const readFile = function (filePath, callback) {
        new (_getByName('readfile'))(_varStore).execute(filePath, callback);
    }

    /**
     * Stores the keySSI to the SEED file when no sourceDSU is provided
     * @param {string} seed_path the path to store in
     * @param {string} keySSI
     * @param {function(err, KeySSI)} callback
     */
    let storeKeySSI = function (seed_path, keySSI, callback) {
        writeFile(seed_path, keySSI, callback);
    };

    /**
     * Runs an operation
     * @param {Archive} bar
     * @param {string|string[]} command
     * @param {string[]} next the remaining commands to be executed
     * @param {function(err, Archive)} callback
     */
    let runCommand = function (bar, command, next, callback) {
        let args = command.split(/\s+/);
        const cmdName = args.shift();
        const cmd = _getByName(cmdName);
        return cmd
            ? new (cmd)(_varStore, this.source).execute(args, bar, next, callback)
            : callback(`Command not recognized: ${cmdName}`);
    };

    /**
     * Retrieves the KeysSSi after save (when applicable)
     * @param {Archive} bar
     * @param {object} cfg is no sourceDSU is provided must contain a seed field
     * @param {function(err, KeySSI)} callback
     */
    let saveDSU = function (bar, cfg, callback) {
        bar.getKeySSIAsString((err, barKeySSI) => {
            if (err)
                return callback(err);
            const scAPI = require("opendsu").loadAPI("sc");
            scAPI.getSharedEnclave((err, sharedEnclave) => {
                if (err) {
                    return callback(err);
                }

                sharedEnclave.getReadForKeySSI(barKeySSI, (err, readSSI) => {
                    if (err) {
                        return callback(err);
                    }

                    if (sourceDSU || cfg.skipFsWrite)
                        return callback(undefined, readSSI);
                    storeKeySSI(cfg.seed, readSSI, callback);
                })
            })
        });
    };

    /**
     * Run a sequence of {@link Command}s on the DSU
     * @param {Archive} bar
     * @param {object} cfg
     * @param {string[]} commands
     * @param {function(err, KeySSI)} callback
     */
    let updateDossier = function (bar, cfg, commands, callback) {
        if (commands.length === 0) {
            return bar.commitBatch((err) => {
                if (err) {
                    return callback(err);
                }

                saveDSU(bar, cfg, callback);
            })
        }

        if (!bar.batchInProgress()) {
            try {
                bar.beginBatch();
            } catch (e) {
                return callback(e);
            }
        }

        let cmd = commands.shift();
        runCommand(bar, cmd, commands, (err, updated_bar) => {
            if (err) {
                return callback(err);
            }
            updateDossier(updated_bar, cfg, commands, callback);
        });
    };

    /**
     * Builds s DSU according to it's building instructions
     * @param {object|Archive} configOrDSU: can be a config file form octopus or the destination DSU when cloning.
     *
     *
     * Example of config file:
     * <pre>
     *     {
     *         seed: path to SEED file in fs
     *     }
     * </pre>
     * @param {string[]|object[]} [commands]
     * @param {function(err, KeySSI)} callback
     */
    this.buildDossier = function (configOrDSU, commands, callback) {
        if (typeof commands === 'function') {
            callback = commands;
            commands = [];
        }

        let builder = function (keySSI) {
            try {
                keySSI = _getKeySSISpace().parse(keySSI);
            } catch (err) {
                console.log("Invalid keySSI");
                return createDossier(configOrDSU, commands, callback);
            }

            if (keySSI.getDLDomain() && keySSI.getDLDomain() !== configOrDSU.domain) {
                console.log("Domain change detected.");
                return createDossier(configOrDSU, commands, callback);
            }

            _getSharedEnclave((err, sharedEnclave) => {
                if (err) {
                    return callback(err);
                }
                sharedEnclave.loadDSU(keySSI, (err, bar) => {
                    configOrDSU.skipFsWrite = true;
                    if (err) {
                        console.log("DSU not available. Creating a new DSU for", keySSI.getIdentifier());

                        return sharedEnclave.createDSU(keySSI, {useSSIAsIdentifier: true}, (err, bar) => {
                            if (err)
                                return callback(err);
                            updateDossier(bar, configOrDSU, commands, callback);
                        });
                    }
                    console.log("Dossier updating...");
                    updateDossier(bar, configOrDSU, commands, callback);
                });
            });
        }

        require("./index").initialiseBuildWallet(err => {
            if (err) {
                return callback(err);
            }
            if (configOrDSU.constructor && configOrDSU.constructor.name === 'Archive')
                return updateDossier(configOrDSU, {skipFsWrite: true}, commands, callback);

            readFile(configOrDSU.seed, (err, content) => {
                if (err || content.length === 0)
                    return createDossier(configOrDSU, commands, callback);
                builder(content.toString());
            });
        });
    };
};

module.exports = DossierBuilder;

},{"./commands":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/dt/commands/index.js","./commands/VarStore":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/dt/commands/VarStore.js","./commands/utils":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/dt/commands/utils.js","./index":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/dt/index.js","opendsu":"opendsu"}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/dt/FileService.js":[function(require,module,exports){
/**
 * @module dt
 */

/**
 * Forked from PrivateSky
 * Provides an environment independent file service to the {@link AppBuilderService}
 */
function FileService(options) {
    const isBrowser = $$.environmentType === 'browser';

    function constructUrlBase(prefix){
        let url, protocol, host;
        prefix = prefix || "";
        let appName = '';
        if (isBrowser){
            let location = window.location;
            const paths = location.pathname.split("/");
            while (paths.length > 0) {
                if (paths[0] === "") {
                    paths.shift();
                } else {
                    break;
                }
            }
            appName = paths[0];
            protocol = location.protocol;
            host = location.host;
            url = `${protocol}//${host}/${prefix}${appName}`;
            return url;
        } else {
            return `http://${options.hosts}/${prefix}${options.walletPath}`;
        }
    }

    this.getWalletSeed = function(callback){
        this.getAppSeed(options.slots.primary, callback);
    }

    this.getAppSeed = function(appName, callback){
        this.getFile(appName, options.seedFileName, (err, data) => {
            if (err)
                return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(err));
           Utf8ArrayToStr(data, callback);
        });
    }

    function doGet(url, options, callback){
        if (typeof options === "function") {
            callback = options;
            options = {};
        }

        const http = require("opendsu").loadApi("http");
        http.fetch(url, {
            method: 'GET'
        }).then((response) => {
            return response.arrayBuffer().then((data) => {
                if (!response.ok)
                    return callback("array data failed")
                callback(undefined, data);
            }).catch(e => callback(e));
        }).catch(err => callback(err));
    }

    /**
     * Returns the content of a file as a uintArray
     * @param {string} appName
     * @param {string} fileName
     * @param {function(err, U8intArray)} callback
     */
    this.getFile = function(appName, fileName, callback){
        const suffix = `${appName}/${fileName}`;
        const base = constructUrlBase();
        const joiner = suffix !== '/' && base[base.length - 1] !== '/' && suffix[0] !== '/'
            ? '/'
            : '';

        let url = base + joiner + suffix;
        doGet(url, callback);
    };


    /**
     *
     * @param innerFolder
     * @param callback
     */
    this.getFolderContentAsJSON = function(innerFolder, callback){
        if (typeof innerFolder === 'function'){
            callback = innerFolder;
            innerFolder = undefined;
        }
        let url = constructUrlBase("directory-summary/") + (innerFolder ? `/${innerFolder}` : '') ;
        doGet(url, (err, data) => {
            if (err)
                return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(err));
            Utf8ArrayToStr(data, callback);
        });
    }

    /**
     * Util method to convert Utf8Arrays to Strings in the browser
     * (simpler methods fail for big content jsons)
     * @param {U8intArray} array
     * @param {function(err, string)} callback
     */
    function Utf8ArrayToStr(array, callback) {
        if (!isBrowser)
            return callback(undefined, array.toString());
        var bb = new Blob([array]);
        var f = new FileReader();
        f.onload = function(e) {
            callback(undefined, e.target.result);
        };
        f.readAsText(bb);
    }
}

module.exports = FileService;
},{"opendsu":"opendsu"}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/dt/commands/Command.js":[function(require,module,exports){
/**
 * @module Commands
 * @memberOf dt
 */
const { _err } = require('./utils');

/**
 * **Every Command must be registered under the index.js file in the commands folder**
 * @param {VarStore} varStore
 * @param {Archive|fs} [source]
 * @param {boolean} [canRunIteratively] defines if the command can expect multiple arguments and run multiple times. defaults to false
 * @class Command
 * @abstract
 */
class Command {
    constructor(varStore, source, canRunIteratively) {
        if (typeof source === 'boolean'){
            canRunIteratively = source;
            source = undefined;
        }
        if (!varStore.checkVariables)
            throw new Error('Cant happen')

        this.varStore = varStore;
        this.source = source;
        this.canRunIteratively = !!canRunIteratively;
    }

    /**
     * Parses the command text and executes the command onto the provided DSU
     * @param {string[]|string} args the arguments of the command split into words
     * @param {Archive|KeySSI} [bar] the destinationDSU or the keySSI
     * @param {string[]} [next] the remaining commands
     * @param {object} [options]
     * @param {function(err, Archive|KeySSI|string|boolean)} callback
     */
    execute(args,bar, next, options, callback){
        if (typeof options === 'function'){
            callback = options;
            options = undefined;
        }
        if (typeof next === 'function'){
            callback = next;
            options = undefined;
            next = undefined;
        }
        if (callback === undefined){
            callback = bar;
            bar = undefined;
        }
        let self = this;
        this._parseCommand(args, next, (err, parsedArgs) => {
            if (err)
                return _err(`Could not parse command ${args}`, err, callback);

            // Tests against variables
            if (self.varStore)
                parsedArgs = self.varStore.checkVariables(parsedArgs);

            if (!self.canRunIteratively || !(parsedArgs instanceof Array))
                return self._runCommand(parsedArgs, bar, options, callback);

            const iterator = function(args, callback){
                let arg = parsedArgs.shift();
                if (!arg)
                    return callback(undefined, bar);
                return self._runCommand(arg, bar, options, (err) => err
                    ? _err(`Could iterate over Command ${self.constructor.name} with args ${JSON.stringify(arg)}`, err, callback)
                    : iterator(args, callback));
            }

            iterator(args, callback);
        });
    }

    /**
     * Should be overridden by child classes if any argument parsing is required
     *
     * @param {string[]|string|boolean} command the command split into words
     * @param {string[]} next the following Commands
     * @param {function(err, string|string[]|object)} callback
     * @protected
     */
    _parseCommand(command, next, callback){
        if (!callback){
            callback = next;
            next = undefined;
        }
        callback(undefined, command);
    }

    /**
     * @param {string|object} arg the command argument
     * @param {Archive} [bar]
     * @param {object} options
     * @param {function(err, Archive|KeySSI|string)} callback
     * @protected
     */
    _runCommand(arg, bar, options, callback){
        throw new Error("Child classes must implement this");
    }
}

module.exports = Command;
},{"./utils":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/dt/commands/utils.js"}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/dt/commands/Registry.js":[function(require,module,exports){
/**
 * List of all available commands to the Dossier Builder
 * Without being here, they can't be used
 */
const _availableCommands = {
    addfile: require('./addFile'),
    addfolder: require('./addFolder'),
    createdsu: require('./createDSU'),
    createfile: require('./createFile'),
    define: require('./define'),
    delete: require('./delete'),
    derive: require('./derive'),
    endwith: require('./endWith'),
    genkey: require('./genKey'),
    getidentifier: require('./getIndentifier'),
    mount: require('./mount'),
    objtoarray: require('./objToArray'),
    readfile: require('./readFile'),
    with: require('./with')
};

/**
 * return the Command class by its name
 * @param cmdName
 * @return {Command} the command calls to be instanced
 */
const _getByName = function(cmdName){
    if (cmdName in _availableCommands)
        return _availableCommands[cmdName];
    return undefined;
}

module.exports = _getByName;
},{"./addFile":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/dt/commands/addFile.js","./addFolder":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/dt/commands/addFolder.js","./createDSU":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/dt/commands/createDSU.js","./createFile":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/dt/commands/createFile.js","./define":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/dt/commands/define.js","./delete":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/dt/commands/delete.js","./derive":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/dt/commands/derive.js","./endWith":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/dt/commands/endWith.js","./genKey":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/dt/commands/genKey.js","./getIndentifier":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/dt/commands/getIndentifier.js","./mount":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/dt/commands/mount.js","./objToArray":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/dt/commands/objToArray.js","./readFile":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/dt/commands/readFile.js","./with":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/dt/commands/with.js"}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/dt/commands/VarStore.js":[function(require,module,exports){
/**
 * @module commands
 * A simple variable store
 */


const VarStore = function(){
    const _memory = {};
    let _hasVars = false;
    const self = this;

    this.define = function(name, value){
        _memory[name] = value;
        _hasVars = true;
        console.log(`Variable ${name} defined as ${value}`)
    }

    const tryReplace = function(value){
        for (let name in _memory)
            if (value.includes(name)) {
                value = value.replace(name, _memory[name]);
                console.log(`Replaced variable ${name}`)
            }
        return value;
    }

    this.checkVariables = function(args){
        if (!_hasVars)
            return args;
        if (typeof args === 'string')
            return tryReplace(args);
        if (args instanceof Array)
            return args.map(a => self.checkVariables(a));
        if (typeof args !== 'object')
            return args;
        const result = {};
        Object.keys(args).forEach(k => {
            result[k] = self.checkVariables(args[k]);
        });
        return result;
    }
}

module.exports = VarStore;
},{}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/dt/commands/addFile.js":[function(require,module,exports){
/**
 * @module Commands
 * @memberOf dt
 */

/**
 */
const Command = require('./Command');
const { _err } = require('./utils');

/**
 * Copies a File from disk or from a source DSU when provided
 *
 * supports sourceDSU, defaults to fs
 *
 * Can run iteratively
 *
 * @class AddFileCommand
 */
class AddFileCommand extends Command{
    constructor(varStore, source) {
        super(varStore, source, true);
    }

    /**
     * @param {string[]|string} command the command split into words
     * @param {string[]} next discarded
     * @param {function(err, string|object)} [callback] discarded
     * @return {string|object} the command argument
     * <pre>
     *     {
     *         from: (...),
     *         to: (..)
     *     }
     * </pre>
     * @protected
     */
    _parseCommand(command, next, callback){
        if (!callback){
            callback = next;
            next = undefined;
        }
        callback(undefined, {
            "from": command[0],
            "to": command[1]
        });
    }

    /**
     * Copies a file, from disk or another DSU
     * @param {object} arg
     * <pre>
     *     {
     *         from: (...),
     *         to: (..)
     *     }
     * </pre>
     * @param {Archive} bar
     * @param {object} options
     * @param {function(err, Archive)} callback
     * @protected
     */
    _runCommand(arg, bar, options, callback) {
        if (!callback) {
            callback = options;
            options = undefined;
        }

        options = options || {encrypt: true, ignoreMounts: false}
        console.log("Copying file " + arg.from + (this.source ? " from sourceDSU" : "") + " to " + arg.to);

        if (!this.source)
            return bar.addFile(arg.from, arg.to, options, err => err
                ? _err(`Could not read from ${arg.from}`, err, callback)
                : callback(undefined, bar));

        this.source.readFile(arg.from, (err, data) => {
            if (err)
                return _err(`Could not read from ${arg.from}`, err, callback);
            bar.writeFile(arg.to, data, err => err
                ? _err(`Could not write to ${arg.to}`, err, callback)
                : callback(undefined, bar));
        });
    }
}

module.exports = AddFileCommand;
},{"./Command":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/dt/commands/Command.js","./utils":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/dt/commands/utils.js"}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/dt/commands/addFolder.js":[function(require,module,exports){
/**
 * @module Commands
 * @memberOf dt
 */

/**
 */
const Command = require('./Command');
const { _err } = require('./utils');

/**
 * This command copies an entire folder from the filesystem onto the destination DSU
 * (as a single brick for efficiency if I'm not mistaken)
 *
 * Does not Support sourceDSU (yet)
 *
 * Can run iteratively
 *
 * @class AddFolderCommand
 */
class AddFolderCommand extends Command {
    constructor(varStore, source) {
        super(varStore, source, false);
    }

    /**
     * @param {string[]|string} command the command split into words
     * @param {string[]} next the following Commands
     * @param {function(err, string|object)} [callback] for async versatility
     * @return {string|object} the command argument
     * @protected
     */
    _parseCommand(command, next, callback){
        if (!callback){
            callback = next;
            next = undefined;
        }
        callback(undefined, command);
    }

    /**
     * @param {string|object} arg the command argument
     * @param {Archive} bar
     * @param {object} [options]
     * @param {function(err, Archive)} callback
     * @protected
     */
    _runCommand(arg, bar, options, callback){
        if (this.source){
            console.log("The addFolder Method is not supported when reading from a sourceDSU");
            callback(undefined, bar);
        }
        if (!callback) {
            callback = options;
            options = undefined;
        }

        options = options || {batch: false, encrypt: false};
        let src = arg[0];
        let dst = arg[1] || "/";
        let commandLog = "Adding Folder " + src + " to " + dst;
        console.log(commandLog);

        bar.addFolder(src, dst, options, err => err
            ? _err(`Failed to: `+commandLog, err, callback)
            : callback(undefined, bar));
    }
}

module.exports = AddFolderCommand;
},{"./Command":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/dt/commands/Command.js","./utils":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/dt/commands/utils.js"}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/dt/commands/createDSU.js":[function(require,module,exports){
/**
 * @module Commands
 * @memberOf dt
 */

/**
 */
const Command = require('./Command');
const { _err, _getResolver, DSU_TYPE, KEY_TYPE } = require('./utils');
const genKey = require('./genKey');

/**
 * @param {DSU_TYPE} dsuType
 * @return {KEY_TYPE}
 */
const _getKeyType = function(dsuType){
    switch (dsuType){
        case DSU_TYPE.CONST:
            return KEY_TYPE.ARRAY;
        case DSU_TYPE.WALLET:
            return KEY_TYPE.WALLET;
        case DSU_TYPE.SEED:
            return KEY_TYPE.SEED;
        default:
            throw new Error(`Unsupported DSU Type`);
    }
}


/**
 * Creates an Arrays SSI off a secret list
 *
 * Adds options.hint to hit if available
 * @param {string[]} arg
 * @param {function(err, KeySSI)} callback
 */
const _createSSI = function(varStore, arg, callback){
    const argToArray = (arg) => {
        return `${arg.type} ${arg.domain} ${typeof arg.args === 'string' ? arg.args : JSON.stringify(arg.hint ? {
            hint: arg.hint,
            args: arg.args
        } : arg.args)}`.split(/\s+/);
    }
    new genKey(varStore).execute(argToArray(arg), callback);
}


/**
 * Creates a DSU of an ArraySSI
 * @param {string[]} arg
 * @param {object} opts DSU Creation Options
 * @param {function(err, Archive)} callback
 */
const _createWalletDSU = function(varStore, arg, opts, callback){
    _createSSI(varStore, arg, (err, keySSI) => {
        _getResolver().createDSUForExistingSSI(keySSI, opts, (err, dsu) => {
            if (err)
                return _err(`Could not create wallet DSU`, err, callback);
            callback(undefined, dsu);
        });
    });
}

/**
 * Creates a DSU of an ArraySSI
 * @param {string[]} arg String for Seed SSI
 * @param {object} opts DSU Creation Options
 * @param {function(err, Archive)} callback
 */
const _createDSU = function(varStore, arg, opts, callback){
    _createSSI(varStore, arg, (err, keySSI) => {
        _getResolver().createDSU(keySSI, opts, (err, dsu) => {
            if (err)
                return _err(`Could not create DSU`, err, callback);
            callback(undefined, dsu);
        });
    });
}

/**
 * Creates a DSU of an ArraySSI
 * @param {string[]} arg
 * @param {object} opts DSU Creation Options
 * @param {function(err, Archive)} callback
 */
const _createConstDSU = function(varStore, arg,opts , callback){
    _createSSI(varStore, arg, (err, keySSI) => {
        _getResolver().createDSUForExistingSSI(keySSI, opts, (err, dsu) => {
            if (err)
                return _err(`Could not create const DSU`, err, callback);
            callback(undefined, dsu);
        });
    });
}


/**
 * creates a new DSU of the provided type and with the provided key gen arguments
 *
 * @class CreateDSUCommand
 */
class CreateDSUCommand extends Command{
    constructor(varStore, source) {
        super(varStore, source, false);
    }

    /**
     * @param {string[]|string} command the command split into words
     * @param {string[]} next discarded
     * @param {function(err, string|object)} [callback] discarded
     * @return {string|object} the command argument
     * <pre>
     *     {
     *         type: (...),
     *         domain: (..)
     *         args: {string[]|object},
     *     }
     * </pre>
     * @protected
     */
    _parseCommand(command, next, callback){
        if (!callback){
            callback = next;
            next = undefined;
        }
        try {
            let arg = {
                dsuType: command.shift(),
                domain: command.shift(),
                args: command.length === 1 ? command[0] : JSON.parse(command.join(' '))
            }
            arg.type = _getKeyType(arg.dsuType);
            if (typeof arg.args === 'object' && arg.args.args){
                arg.hint = arg.args.hint;
                arg.args = arg.args.args;
            }
            callback(undefined, arg)
        } catch (e){
            _err(`could not parse json ${command}`, e, callback);
        }
    }

    /**
     * Copies a file, from disk or another DSU
     * @param {object} arg
     * <pre>
     *     {
     *         from: (...),
     *         to: (..)
     *     }
     * </pre>
     * @param {Archive} bar
     * @param {object} options
     * @param {function(err, Archive)} callback
     * @protected
     */
    _runCommand(arg, bar, options, callback) {
        if(!callback){
            callback = options;
            options = bar;
            bar = undefined;
        }
        if (typeof options === 'function'){
            callback = options;
            options = undefined;
        }
        const cb = function(err, dsu){
            if (err)
                return _err(`Could not create DSU with ${JSON.stringify(arg)}`, err, callback);
            console.log(`${arg.dsuType} DSU created`);
            callback(undefined, dsu);
        }

        switch (arg.dsuType){
            case DSU_TYPE.SEED:
                return _createDSU(this.varStore, arg, cb)
            case DSU_TYPE.CONST:
                return _createConstDSU(this.varStore, arg, cb);
            case DSU_TYPE.WALLET:
                return _createWalletDSU(this.varStore, arg, cb);
            default:
                callback(`Unsupported key type`);
        }
    }
}

module.exports = CreateDSUCommand;
},{"./Command":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/dt/commands/Command.js","./genKey":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/dt/commands/genKey.js","./utils":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/dt/commands/utils.js"}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/dt/commands/createFile.js":[function(require,module,exports){
/**
 * @module Commands
 * @memberOf dt
 */

/**
 */
const Command = require('./Command');
const {_getFS, _err} = require('./utils');

/**
 * Creates a file with the provided content on the destination DSU
 * (similar to a touch command with added content)
 *
 * @class CreateFileCommand
 */
class CreateFileCommand extends Command{
    constructor(varStore) {
        super(varStore);
    }

    /**
     * @param {string[]|string} command the command split into words
     * @param {string[]} next the following Commands
     * @param {function(err, string|object)} [callback] for async versatility
     * @return {string|object} the command argument
     * @protected
     */
    _parseCommand(command, next, callback){
        command = typeof command === 'string' ? command.split(' ') : command;
        callback(undefined,  {
            path: command.shift(),
            content: command.join(' ')
        });
    }

    /**
     * Writes a file
     * @param {object} arg the command argument
     * <pre>
     *     {
     *         path: (...),
     *         content: (..)
     *     }
     * </pre>
     * @param {Archive|fs} bar
     * @param {object} options
     * @param {function(err, string)} callback
     * @protected
     */
    _runCommand(arg, bar, options, callback){
        if (typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        if (!bar)
            bar = _getFS();
        options = options || {encrypt: true, ignoreMounts: false};
        bar.writeFile(arg.path, arg.content, options, (err) => err
            ? _err(`Could not create file at ${arg.path}`, err, callback)
            : callback(undefined, bar));
    }
}

module.exports = CreateFileCommand;
},{"./Command":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/dt/commands/Command.js","./utils":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/dt/commands/utils.js"}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/dt/commands/define.js":[function(require,module,exports){
/**
 * @module Commands
 * @memberOf dt
 */

/**
 */
const Command = require('./Command');
const { _err } = require('./utils');

/**
 * Defines a variable that can later be used in the script
 *
 * @class DefineCommand
 */
class DefineCommand extends Command {
    constructor(varStore) {
        super(varStore);
    }

    /**
     * @param {string[]|string} command the command split into words
     * @param {string[]} next the following Commands
     * @param {function(err, string|object)} [callback] for async versatility
     * @return {string|object} the command argument
     * @protected
     */
    _parseCommand(command, next, callback) {
        if (!callback){
            callback = next;
            next = undefined;
        }

        callback(undefined, {
            varName: command.shift(),
            command: command
        });
    }

    /**
     * @param {string[]|object} arg the command argument
     * @param {Archive} bar
     * @param {object} options
     * @param {function(err, Archive)} callback
     * @protected
     */
    _runCommand(arg, bar, options, callback) {
        if (typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let self = this;
        const _getByName = require('./Registry');

        if (!_getByName(arg.command[0])){
            this.varStore.define(arg.varName, arg.command);
            console.log(`Define executed: ${arg.command}`);
            return callback(undefined, bar);
        }

        const parseCommand = function(command, callback){
            const cmdName = command.shift();
            const actualCmd = _getByName(cmdName);
            if (!actualCmd)
                return callback(`Could not find command`);
            callback(undefined, cmdName, actualCmd, command);
        }

        return parseCommand(arg.command, (err, cmdName, command, args) => err
            ? _err(`Could not parse Command`, err, callback)
            : new (command)(self.varStore, self.source).execute(args, bar, (err, result) => {
                if (err)
                    return _err(`Could not obtain result`, err, callback);
                this.varStore.define(arg.varName, result);
                console.log(`Define executed: ${result}`);
                callback(undefined, bar);
            }));
    }
}

module.exports = DefineCommand;
},{"./Command":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/dt/commands/Command.js","./Registry":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/dt/commands/Registry.js","./utils":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/dt/commands/utils.js"}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/dt/commands/delete.js":[function(require,module,exports){
/**
 * @module Commands
 * @memberOf dt
 */


/**
 */
const Command = require('./Command');
const { _err } = require('./utils');

/**
 * Deletes everything in the specified path of the DSU
 *
 * @class DeleteCommand
 */
class DeleteCommand extends Command {
    constructor(varStore) {
        super(varStore,undefined, false);
    }

    /**
     * @param {string[]|string} command the command split into words
     * @param {string[]} next the following Commands
     * @param {function(err, string|object)} [callback] for async versatility
     * @return {string|object} the command argument
     * @protected
     */
    _parseCommand(command, next, callback){
        callback(undefined, command[0]);
    }

    /**
     * @param {string} arg
     * @param {Archive} bar
     * @param {object} [options]
     * @param {function(err, Archive)} callback
     * @protected
     */
    _runCommand(arg, bar, options, callback){
        if (typeof options === 'function'){
            callback = options;
            options = undefined
        }
        options = options || {ignoreMounts: false, ignoreError: true};
        console.log("Deleting " + arg);
        bar.delete(arg, options, err => err
            ? _err(`Could not delete path '${arg}'`, err, callback)
            : callback(undefined, bar));
    }
}

module.exports = DeleteCommand;

},{"./Command":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/dt/commands/Command.js","./utils":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/dt/commands/utils.js"}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/dt/commands/derive.js":[function(require,module,exports){
/**
 * @module Commands
 * @memberOf dt
 */

/**
 */
const Command = require('./Command');
const { _getKeySSISpace, _err } = require('./utils');

/**
 * Derives the provided keySSI
 *
 * @class DeriveCommand
 */
class DeriveCommand extends Command{
    constructor(varStore) {
        super(varStore);
    }

    _parseCommand(command, next, callback) {
        if (!callback){
            callback = next;
            next = undefined;
        }
        callback(undefined, command
            ? !(command === 'false' || command[0] === 'false')
            : true);
    }

    /**
     * derives the provided keySSI (in the source object)
     * @param {object} arg unused
     * @param {KeySSI} bar
     * @param {object} options unsused
     * @param {function(err, KeySSI)} callback
     * @protected
     */
    _runCommand(arg, bar, options, callback) {
        if (!callback) {
            callback = options;
            options = undefined;
        }

        try{
            const keySSI = _getKeySSISpace().parse(bar);
            keySSI.derive((err, derivedKeySSI) => {
                if (err) {
                    return _err(`Could not derive Key ${JSON.stringify(bar)}`, err, callback)
                }

                callback(undefined, arg ? derivedKeySSI.getIdentifier() : derivedKeySSI);
            });
        } catch (e) {
            _err(`Could not parse Key ${JSON.stringify(bar)}`, e, callback)
        }
    }
}

module.exports = DeriveCommand;
},{"./Command":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/dt/commands/Command.js","./utils":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/dt/commands/utils.js"}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/dt/commands/endWith.js":[function(require,module,exports){
/**
 * @module Commands
 * @memberOf dt
 */

/**
 */
const Command = require('./Command');

/**
 * Allows for more complex logic by allowing you to control the output/input for commands
 * while keeping the commands readable
 *
 * basically sets whatever the result of the with operation into the source portion until it finds the endwith command
 *
 * @class EndWithCommand
 */
class EndWithCommand extends Command{
    constructor(varStore) {
        super(varStore);
    }

    /**
     * Returns the source object
     * @param {string[]|object} arg unused
     * @param {Archive} bar unused
     * @param {object} options unused
     * @param {function(err, Archive|KeySSI)} callback
     * @protected
     */
    _runCommand(arg, bar, options, callback){
        if (!callback) {
            callback = options;
            options = undefined;
        }
        if (!callback){
            callback = bar;
            bar = arg;
            arg = undefined;
        }

        // return whatever the object was
        if (!bar)
            return callback(`Nothing to return. should not be possible`);

        console.log(`Ending With command. Returning to ${JSON.stringify(bar)}`);
        callback(undefined, bar);
    }
}

module.exports = EndWithCommand;
},{"./Command":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/dt/commands/Command.js"}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/dt/commands/genKey.js":[function(require,module,exports){
/**
 * @module Commands
 * @memberOf dt
 */

/**
 */
const Command = require('./Command');
const { _err, _getKeySSISpace, KEY_TYPE } = require('./utils');

/**
 * Generates a KeySSI
 *
 * @class GenKeyCommand
 */
class GenKeyCommand extends Command {
    constructor(varStore) {
        super(varStore,undefined, false);
    }

    /**
     * @param {string[]|string} command the command split into words
     * @param {string[]} next the following Commands
     * @param {function(err, string|object)} [callback] for async versatility
     * @return {string|object} the command argument
     * @protected
     */
    _parseCommand(command, next, callback){
        if (!callback){
            callback = next;
            next = undefined;
        }

        const tryParseJson = function(text){
            try {
                let parsedArgs = JSON.parse(text);
                if (parsedArgs && typeof parsedArgs === 'object')
                    return parsedArgs;
                return text;
            } catch (e) {
                // The argument is just a string. leave it be
                return text;
            }
        }

        try {
            let arg = {
                type: command.shift(),
                domain: command.shift(),
                args: tryParseJson(command.shift())
            }

            if (typeof arg.args === 'object' && arg.args.args){
                arg.hint = arg.args.hint;
                arg.args = tryParseJson(arg.args.args);
            }
            callback(undefined, arg);
        } catch (e){
            _err(`could not parse json ${command}`, e, callback);
        }
    }

    /**
     * Creates an Arrays SSI off a secret list
     *
     * Adds options.hint to hit if available
     * @param {object} args
     * @param {function(err, ArraySSI)} callback
     * @private
     */
    _createArraySSI = function(args, callback){
        const key = _getKeySSISpace().createArraySSI(args.domain, args.args, 'v0', args.hint ? JSON.stringify(args.hint) : undefined);
        callback(undefined, key);
    }

    /**
     * Creates a Wallet SSI off a secret list
     *
     * Adds options.hint to hit if available
     * @param {object} args
     * @param {function(err, ArraySSI)} callback
     */
    _createWalletSSI = function(args, callback){
        const key = _getKeySSISpace().createTemplateWalletSSI(args.domain, args.args, 'v0', args.hint ? JSON.stringify(args.hint) : undefined);
        callback(undefined, key);
    }

    /**
     * Creates an Arrays SSI off a secret list
     *
     * Adds options.hint to hit if available
     * @param {object} args
     * @param {function(err, TemplateSeedSSI)} callback
     */
    _createSSI = function(args, callback){
        const key = _getKeySSISpace().createTemplateSeedSSI(args.domain, args.args, undefined, 'v0', args.hint ? JSON.stringify(args.hint) : undefined);
        callback(undefined, key);
    }

    /**
     * Copies a file, from disk or another DSU
     * @param {object} arg
     * <pre>
     *     {
     *         type: (...),
     *         domain: (..),
     *         args: []| {
     *                  hint: (..)
     *                  args: []
     *         }
     *     }
     * </pre>
     * @param {Archive} bar unused
     * @param {object} options unused
     * @param {function(err, KeySSI)} callback
     * @protected
     */
    _runCommand(arg, bar, options, callback) {
        if(!callback){
            callback = options;
            options = bar;
            bar = undefined;
        }
        if (typeof options === 'function'){
            callback = options;
            options = undefined;
        }
        const cb = function(err, keySSI){
            if (err)
                return _err(`Could not create keySSI with ${JSON.stringify(arg)}`, err, callback);
            console.log(`${arg.type} KeySSI created with SSI ${keySSI.getIdentifier()}`)
            callback(undefined, keySSI);
        }

        switch (arg.type){
            case KEY_TYPE.SEED:
                return this._createSSI(arg, cb)
            case KEY_TYPE.ARRAY:
                return this._createArraySSI(arg, cb);
            case KEY_TYPE.WALLET:
                return this._createWalletSSI(arg, cb);
            default:
                callback(`Unsupported key type`);
        }
    }
}

module.exports = GenKeyCommand;
},{"./Command":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/dt/commands/Command.js","./utils":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/dt/commands/utils.js"}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/dt/commands/getIndentifier.js":[function(require,module,exports){
/**
 * @module Commands
 * @memberOf dt
 */

/**
 */
const Command = require('./Command');
const { _err } = require('./utils');

/**
 * Returns the identifier for the current source object
 *
 * @class GetIdentifierCommand
 */
class GetIdentifierCommand extends Command{
    constructor(varStore) {
        super(varStore);
    }

    /**
     * @param {string[]|string} command the command split into words
     * @param {string[]} next discarded
     * @param {function(err, boolean)} callback
     * @protected
     */
    _parseCommand(command, next, callback){
        if (!callback){
            callback = next;
            next = undefined;
        }
        callback(undefined, command
            ? !(command === 'false' || command[0] === 'false')
            : true);
    }

    /**
     * derives the provided keySSI
     * @param {boolean} arg identifier as string (defaults to false)
     * @param {Archive|KeySSI} bar
     * @param {object} options unused
     * @param {function(err, string|KeySSI)} callback
     * @protected
     */
    _runCommand(arg, bar, options, callback) {
        if (!callback) {
            callback = options;
            options = undefined;
        }
        if (!bar.getIdentifier && !bar.getKeySSIAsString)
            return callback(`The object cannot be derived. It is a KeySSI or a DSU?`);

        // if its a dsu
        if (bar.constructor && bar.constructor.name === 'Archive')
            return (arg ? bar.getKeySSIAsString : bar.getKeySSIAsObject)((err, identifier) => err
                ? _err(`Could not get identifier`, err, callback)
                : callback(undefined, identifier));

        // if its a KeySSI
        try{
            let identifier = arg ? bar.getIdentifier() : bar;
            if (!identifier)
                return callback(`Could not get identifier`);
            callback(undefined, identifier);
        } catch (e){
            _err(`Could not get identifier`, e, callback);
        }
    }
}

module.exports = GetIdentifierCommand;
},{"./Command":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/dt/commands/Command.js","./utils":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/dt/commands/utils.js"}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/dt/commands/index.js":[function(require,module,exports){
/**
 * @module Commands
 * @memberOf dt
 */

module.exports = {
    AddFileCommand: require('./addFile'),
    AddFolderCommand: require('./addFolder'),
    CreateDSUCommand: require('./createDSU'),
    CreateFileCommand: require('./createFile'),
    DefineCommand: require('./define'),
    DeleteCommand: require('./delete'),
    DeriveCommand: require('./derive'),
    EndWithCommand: require('./endWith'),
    GenKeyCommand: require('./genKey'),
    GetIdentifierCommand: require('./getIndentifier'),
    MountCommand: require('./mount'),
    ObjToArrayCommand: require('./objToArray'),
    ReadFileCommand: require('./readFile'),
    WithCommand: require('./with'),
    _getByName: require('./Registry')
}
},{"./Registry":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/dt/commands/Registry.js","./addFile":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/dt/commands/addFile.js","./addFolder":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/dt/commands/addFolder.js","./createDSU":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/dt/commands/createDSU.js","./createFile":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/dt/commands/createFile.js","./define":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/dt/commands/define.js","./delete":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/dt/commands/delete.js","./derive":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/dt/commands/derive.js","./endWith":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/dt/commands/endWith.js","./genKey":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/dt/commands/genKey.js","./getIndentifier":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/dt/commands/getIndentifier.js","./mount":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/dt/commands/mount.js","./objToArray":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/dt/commands/objToArray.js","./readFile":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/dt/commands/readFile.js","./with":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/dt/commands/with.js"}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/dt/commands/mount.js":[function(require,module,exports){
/**
 * @module Commands
 * @memberOf dt
 */

/**
 */
const Command = require('./Command');
const ReadFileCommand = require('./readFile');
const {_err, _getFS, _getKeySSISpace} = require('./utils');

/**
 * Mounts a DSU onto the provided path
 *
 * @class MountCommand
 */
class MountCommand extends Command {
    constructor(varStore, source) {
        super(varStore, source, true);
        if (!source)
            this._getFS = require('./utils');
    }

    /**
     * Lists all the mounts in the provided pattern, either via fs or source dsu
     * @param {object} arg
     * @param {function(err, string[])} callback
     * @private
     */
    _listMounts(arg, callback) {
        let self = this;
        let basePath = arg.seed_path.split("*");
        const listMethod = this.source ? this.source.listMountedDSUs : _getFS().readdir;
        listMethod(basePath[0], (err, args) => err
            ? _err(`Could not list mounts`, err, callback)
            : callback(undefined, self._transform_mount_arguments(arg, args)));
    }

    /**
     * handles the difference between the mount arguments in the 2 cases (with/without sourceDSU)
     * @param arg
     * @param args
     * @return {*}
     * @private
     */
    _transform_mount_arguments(arg, args) {
        return this.source
            ? args.map(m => {
                return {
                    "seed_path": m.identifier,
                    "mount_point": m.path
                }
            })
            : args.map(n => {
                return {
                    "seed_path": arg.seed_path.replace("*", n),
                    "mount_point": arg.mount_point.replace("*", n)
                };
            });
    }

    /**
     * @param {string[]|string} command the command split into words
     * @param {string[]} next the following Commands
     * @param {function(err, string|string[]|object)} callback
     * @protected
     */
    _parseCommand(command, next, callback) {
        let arg = {
            "seed_path": command[0],
            "mount_point": command[1]
        };

        if (!arg.seed_path.match(/[\\/]\*[\\/]/))
            return callback(undefined, arg);   // single mount
        // multiple mount
        this._listMounts(arg, callback);
    }

    /**
     * Mounts a DSu onto a path
     * @param {object} arg
     * <pre>
     *     {
     *         seed_path: (...),
     *         mount_point: (..)
     *     }
     * </pre>
     * @param {Archive} [bar]
     * @param {object} options
     * @param {function(err, Archive)} callback
     * @protected
     */
    _runCommand(arg, bar, options, callback) {
        if (typeof options === 'function') {
            callback = options;
            options = undefined;
        }

        const doMount = function (seed, callback) {
            const scAPI = require("opendsu").loadAPI("sc");
            scAPI.getSharedEnclave((err, sharedEnclave) => {
                if (err) {
                    return callback(err);
                }

                sharedEnclave.getReadForKeySSI(seed, (err, readSSI) => {
                    if (err) {
                        return callback(err);
                    }

                    console.log("Mounting sread " + readSSI + " to " + arg.mount_point);
                    bar.mount(arg.mount_point, readSSI, err => err
                        ? _err(`Could not perform mount of ${readSSI} at ${arg.seed_path}`, err, callback)
                        : callback(undefined, bar));
                })
            })

        };
        try {
            if (_getKeySSISpace().parse(arg.seed_path))
                return doMount(arg.seed_path, callback);
        } catch (e) {
            new ReadFileCommand(this.varStore, this.source).execute(arg.seed_path, (err, seed) => {
                if (err)
                    return _err(`Could not read seed from ${arg.seed_path}`, err, callback);
                seed = seed.toString();
                doMount(seed, callback);
            });
        }
    }
}

module.exports = MountCommand;
},{"./Command":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/dt/commands/Command.js","./readFile":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/dt/commands/readFile.js","./utils":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/dt/commands/utils.js","opendsu":"opendsu"}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/dt/commands/objToArray.js":[function(require,module,exports){
/**
 * @module Commands
 * @memberOf dt
 */

/**
 */
const Command = require('./Command');
const { _err } = require('./utils');

/**
 * Util Command to convert objects to and array with their values
 * @class ObjToArrayCommand
 */
class ObjToArrayCommand extends Command{
    constructor(varStore, source) {
        super(varStore, source, false);
    }

    _parseCommand(command, next, callback){
        if (!callback){
            callback = next;
            next = undefined;
        }
        callback(undefined, typeof command === 'string' ? command : command.shift());
    }

    /**
     * Outputs all args to console
     * @param {object} arg
     * @param {Archive} bar
     * @param {object} options
     * @param {function(err, Archive)} callback
     * @protected
     */
    _runCommand(arg, bar, options, callback) {
        if (!callback) {
            callback = options;
            options = undefined;
        }
        try{
            const obj = JSON.parse(arg);
            if (typeof obj !== 'object')
                return callback(`Provided argument is not an object`);
            if (Array.isArray(obj)){
                console.log(`Object was already an array ${arg}`);
                callback(undefined, obj);
            }
            callback(undefined, JSON.stringify(Object.values(obj)));
        } catch (e) {
            _err(`Could not parse object. Was it a valid json?`, e, callback);
        }
    }
}

module.exports = ObjToArrayCommand;
},{"./Command":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/dt/commands/Command.js","./utils":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/dt/commands/utils.js"}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/dt/commands/readFile.js":[function(require,module,exports){
/**
 * @module Commands
 * @memberOf dt
 */

/**
 */
const Command = require('./Command');
const { _getFS, _err } = require('./utils')

/**
 * Reads The contents of a file from disk or from a sourceDSU
 *
 * supports sourceDSU
 *
 * @class ReadFileCommand
 */
class ReadFileCommand extends Command{
    constructor(varStore, source) {
        super(varStore, source ? source : _getFS());
        this.dataToString = !source;
    }

    /**
     * @param {string[]|string} command the command split into words
     * @param {string[]} next the following Commands
     * @param {function(err, string)} callback
     * @protected
     */
    _parseCommand(command, next, callback){
        if (!callback){
            callback = next;
            next = undefined;
        }
        callback(undefined, command);
    }

    /**
     * @param {Archive} bar unused in this method
     * @param {string} arg the command argument
     * @param {object} options
     * @param {function(err, Archive)} callback
     * @protected
     */
    _runCommand(arg, bar, options, callback){
        if (typeof options === 'function'){
            callback = options;
            options = undefined;
        }
        if (!callback) {
            callback = bar;
            bar = undefined
        }

        this.source.readFile(arg, (err, data) => err
            ? _err(`Could not read file at ${arg}`, err, callback)
            : callback(undefined, this.dataToString ? data : data.toString()));
    }
}

module.exports = ReadFileCommand;
},{"./Command":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/dt/commands/Command.js","./utils":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/dt/commands/utils.js"}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/dt/commands/utils.js":[function(require,module,exports){
/**
 * @module Commands
 */

/**
 * cache of node's fs object
 */

let _fileSystem = undefined;

/**
 * Caches and returns node's fs object if the environment is right
 * @return {fs}
 */
const _getFS = function () {
    if ($$.environmentType !== 'nodejs')
        throw new Error("Wrong environment for this function. Please make sure you know what you are doing...");
    if (!_fileSystem)
        _fileSystem = require('fs');
    return _fileSystem;
}

/**
 * Provides Util functions and Methods as well as caching for the open DSU resolver and {@Link DSUBuilder}
 */

let resolver, keyssi, sharedEnclave;

/**
 * Wrapper around
 * <pre>
 *     OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(msg, err));
 * </pre>
 * @param msg
 * @param err
 * @param callback
 * @protected
 */
const _err = function (msg, err, callback) {
    return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(msg, err));
}

/**
 * for singleton use
 * @returns {function} resolver api
 */
const _getResolver = function (callback) {
    if (!resolver) {
        const scAPI = require("opendsu").loadAPI("sc");
        if (!scAPI.sharedEnclaveExists()) {
            resolver = require('opendsu').loadApi('resolver');
            return callback(undefined, resolver);
        }
        _getSharedEnclave(callback);
        return;
    }
    callback(undefined, resolver);
}

/**
 * for singleton use
 * @returns {function} keyssi api
 */
const _getKeySSISpace = function () {
    if (!keyssi)
        keyssi = require('opendsu').loadApi('keyssi');
    return keyssi;
}

/**
 * for singleton use
 * @returns {function} sc api
 */
const _getSharedEnclave = function (callback) {
    if (!sharedEnclave) {
        const scAPI = require('opendsu').loadApi('sc');
        scAPI.getSharedEnclave((err, _sharedEnclave) => {
            if (err) {
                return callback(err);
            }

            sharedEnclave = _sharedEnclave;
            callback(undefined, sharedEnclave);
        })
        return;
    }
    callback(undefined, sharedEnclave);
}

const KEY_TYPE = {
    ARRAY: "array",
    SEED: "seed",
    WALLET: 'wallet'
}

const DSU_TYPE = {
    CONST: "const",
    WALLET: "wallet",
    SEED: "seed"
}

module.exports = {
    _getFS,
    _getResolver,
    _getKeySSISpace,
    _getSharedEnclave,
    _err,
    KEY_TYPE,
    DSU_TYPE
};
},{"fs":false,"opendsu":"opendsu"}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/dt/commands/with.js":[function(require,module,exports){
/**
 * @module Commands
 * @memberOf dt
 */

/**
 */
const Command = require('./Command');
const { _err } = require('./utils');
const endCommand = 'endwith';
const startCommand = 'with';



/**
 * Allows for more complex logic by allowing you to control the output/input for commands
 * while keeping the commands readable
 *
 * basically sets whatever the result of the with operation into the source portion until it finds the endwith command
 *
 * @class WithCommand
 */
class WithCommand extends Command {
    constructor(varStore, source) {
        super(varStore, source);
    }

    /**
     * @param {string[]|string} command the command split into words
     * @param {string[]} next the following Commands
     * @param {function(err, string|object)} [callback] for async versatility
     * @return {string|object} the command argument
     * @protected
     */
    _parseCommand(command, next, callback) {
        if (!next)
            throw new Error("No next defined");
        const commandsToConsider = [command];
        let cmd;
        let count = 0;
        while (!this._isEndCommand((cmd = next.shift())) && count === 0){
            let c = cmd.split(/\s+/);
            commandsToConsider.push(c);
            if (this._isStartCommand(c[0]))
                count++;
            if (this._isEndCommand(c[0]))
                count--;
        }

        commandsToConsider.push(cmd.split(/\s+/));
        callback(undefined, commandsToConsider);
    }

    _isStartCommand(cmd){
        return cmd.indexOf(startCommand) === 0;
    }

    _isEndCommand(cmd) {
        return cmd.indexOf(endCommand) === 0;
    }

    /**
     * @param {string[]} arg the command argument
     * @param {Archive} bar
     * @param {object} options
     * @param {function(err, Archive)} callback
     * @protected
     */
    _runCommand(arg, bar, options, callback) {
        let self = this;
        if (typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        if (!callback){
            callback = bar;
            bar = undefined;
        }
        const _getByName = require('./Registry');

        const parseCommand = function(command, callback){
            const cmdName = command.shift();
            const actualCmd = _getByName(cmdName);
            if (!actualCmd)
                return callback(`Could not find command`);
            callback(undefined, cmdName, actualCmd, command);
        }

        const performWith = function(newSource, commands, callback){
            const cmd = commands.shift();
            if (!cmd)
                return callback(`No endWith command found. this should not be possible`);
            parseCommand(cmd, (err, cmdName, command, args) => {
                if (err)
                    return _err(`Could not parse the command ${cmd}`, err, callback);
                if (cmdName === endCommand)
                    return new command(self.varStore, self.source).execute(undefined, bar, callback);
                new command(self.varStore, self.source).execute(args, newSource, (err, result) => {
                    if (err)
                        return _err(`Could not execute command ${cmdName}`, err, callback);
                    console.log(`Command ${cmdName} executed with output ${JSON.stringify(result)}`);
                    performWith(newSource, commands, callback);
                });
            });
        }

        const cmdOrVar = arg[0][0];
        const cmd = _getByName(cmdOrVar);

        if (!cmd){
            console.log(`With VARIABLE executed: ${arg[0]}`);
            return performWith(arg.shift().shift(), arg, callback);
        }

        parseCommand(arg.shift(), (err, cmdName, command, args) => err
            ? _err(`Could not parse Command`, err, callback)
            : new (command)(self.varStore, self.source).execute(args, (err, result) => {
                if (err)
                    return _err(`Could not obtain result`, err, callback);
                console.log(`With COMMAND executed: ${JSON.stringify(result)}`);
                performWith(result, arg, callback);
            }));
    }
}

module.exports = WithCommand;
},{"./Command":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/dt/commands/Command.js","./Registry":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/dt/commands/Registry.js","./utils":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/dt/commands/utils.js"}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/dt/index.js":[function(require,module,exports){
/**
 * @module dt
 */


/**
 * Provides a Environment Independent and Versatile Dossier Building API.
 *
 * Meant to be integrated into OpenDSU
 */

/**
 * Returns a DossierBuilder Instance
 * @param {Archive} [sourceDSU] should only be provided when cloning a DSU
 * @param callback
 * @return {DossierBuilder}
 */

const getDossierBuilder = (sourceDSU) => {
    return new (require("./DossierBuilder"))(sourceDSU);
}

const initialiseBuildWallet = (callback) => {
    const BuildWallet = require("./BuildWallet");
    BuildWallet.initialiseWallet(callback);
}

module.exports = {
    getDossierBuilder,
    initialiseBuildWallet,
    Commands: require('./commands'),
    AppBuilderService: require('./AppBuilderService')
}

},{"./AppBuilderService":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/dt/AppBuilderService.js","./BuildWallet":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/dt/BuildWallet.js","./DossierBuilder":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/dt/DossierBuilder.js","./commands":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/dt/commands/index.js"}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/enclave/KeySSIMappings/PathKeySSIMapping/PathKeyMapping.js":[function(require,module,exports){
function PathKeyMapping(enclaveHandler) {
    const utils = require("../../utils/utils");
    const openDSU = require("opendsu");
    const utilsAPI = openDSU.loadAPI("utils");
    utilsAPI.ObservableMixin(this);
    const keySSISpace = openDSU.loadAPI("keyssi");
    let pathKeysMapping = {};
    let initialised = false;
    const init = async () => {
        let paths = await $$.promisify(enclaveHandler.loadPaths)();
        pathKeysMapping = await $$.promisify(utils.getKeySSIsMappingFromPathKeys)(paths);

        this.finishInitialisation();
        this.dispatchEvent("initialised");
    };

    this.isInitialised = () => {
        return initialised;
    };

    this.storePathKeySSI = (pathKeySSI, callback) => {
        if (typeof pathKeySSI === "string") {
            try {
                pathKeySSI = keySSISpace.parse(pathKeySSI);
            } catch (e) {
                return callback(e);
            }
        }
        pathKeySSI = pathKeySSI.getIdentifier();

        const storePathKeySSI = () => {
            enclaveHandler.storePathKeySSI(pathKeySSI, async err => {
                if (err) {
                    return callback(err);
                }
                try {
                    const derivedKeySSIs = await $$.promisify(utils.getKeySSIMapping)(pathKeySSI);
                    pathKeysMapping = utils.mergeMappings(pathKeysMapping, derivedKeySSIs);
                    callback();
                } catch (e) {
                    callback(e);
                }
            });
        }
        storePathKeySSI();
    };

    this.getCapableOfSigningKeySSI = (keySSI, callback) => {
        if (typeof keySSI === "string") {
            try {
                keySSI = keySSISpace.parse(keySSI);
            } catch (e) {
                return callback(e);
            }
        }
        keySSI = keySSI.getIdentifier();
        let capableOfSigningKeySSI
        try {
            capableOfSigningKeySSI = pathKeysMapping[openDSU.constants.KEY_SSIS.SEED_SSI][keySSI];
        } catch (e) {
            return callback(e);
        }

        if (typeof capableOfSigningKeySSI === "undefined") {
            return callback(Error("The provided key SSI does not have write privileges."));
        }

        try {
            capableOfSigningKeySSI = keySSISpace.parse(capableOfSigningKeySSI);
        } catch (e) {
            return callback(e);
        }
        callback(undefined, capableOfSigningKeySSI);
    };

    this.getReadForKeySSI = (keySSI, callback) => {
        if (typeof keySSI === "string") {
            try {
                keySSI = keySSISpace.parse(keySSI);
            } catch (e) {
                return callback(e);
            }
        }
        keySSI = keySSI.getIdentifier();
        let readKeySSI
        try {
            readKeySSI = pathKeysMapping[openDSU.constants.KEY_SSIS.SREAD_SSI][keySSI];
        } catch (e) {
            return callback(e);
        }

        if (typeof readKeySSI === "undefined") {
            return callback(Error("The provided key SSI does not have read privileges."));
        }

        try {
            readKeySSI = keySSISpace.parse(readKeySSI);
        } catch (e) {
            return callback(e);
        }

        callback(undefined, readKeySSI);
    }

    this._getMapping = (callback) => {
        callback(undefined, pathKeysMapping);
    };

    utilsAPI.bindAutoPendingFunctions(this, ["on", "off", "dispatchEvent"]);
    init();
}

module.exports = PathKeyMapping;
},{"../../utils/utils":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/enclave/utils/utils.js","opendsu":"opendsu"}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/enclave/KeySSIMappings/PathKeySSIMapping/WalletDBEnclaveHandler.js":[function(require,module,exports){
const pathModule = require("path");
const constants = require("../../constants/constants");

function WalletDBEnclaveHandler(walletDBEnclaveDSU, config) {
    const defaultConfig = {
        maxNoScatteredKeys: 5000
    }
    Object.assign(defaultConfig, config);
    config = defaultConfig;
    const openDSU = require("opendsu");
    const utilsAPI = openDSU.loadAPI("utils");
    const keySSISpace = openDSU.loadAPI("keyssi");
    utilsAPI.ObservableMixin(this);
    let initialised = false;

    this.isInitialised = () => {
        return initialised;
    };

    this.storePathKeySSI = (pathKeySSI, callback) => {
        if (typeof pathKeySSI === "string") {
            try {
                pathKeySSI = keySSISpace.parse(pathKeySSI);
            } catch (e) {
                return callback(e);
            }
        }
        const __storePathKeySSI = () => {
            const filePath = pathModule.join(constants.PATHS.SCATTERED_PATH_KEYS, pathKeySSI.getSpecificString(), pathKeySSI.getIdentifier());
            walletDBEnclaveDSU.startOrAttachBatch((err, batchId) => {
                if (err) {
                    return callback(err);
                }

                walletDBEnclaveDSU.writeFile(filePath, async err => {
                    if (err) {
                        const writeFileError = createOpenDSUErrorWrapper(`Failed to store path key SSI <${pathKeySSI.getIdentifier()}>`, err);
                        try {
                            await walletDBEnclaveDSU.cancelBatchAsync(batchId);
                        } catch (e) {
                            return callback(createOpenDSUErrorWrapper(`Failed to cancel batch`, e, writeFileError));
                        }
                        return callback(writeFileError);
                    }

                    try {
                        const files = await $$.promisify(walletDBEnclaveDSU.listFiles)(constants.PATHS.SCATTERED_PATH_KEYS);
                        if (files.length === config.maxNoScatteredKeys) {
                            try {
                                await compactPathKeys();
                            } catch (e) {
                                const compactPathKeysError = createOpenDSUErrorWrapper(`Failed to compact path keys`, e);
                                try {
                                    await walletDBEnclaveDSU.cancelBatchAsync();
                                } catch (error) {
                                    return callback(createOpenDSUErrorWrapper(`Failed to cancel batch`, error, compactPathKeysError));
                                }
                                return callback(compactPathKeysError);
                            }
                        }
                    } catch (e) {
                        const listFilesError = createOpenDSUErrorWrapper(`Failed to list files`, e);
                        try {
                            await walletDBEnclaveDSU.cancelBatchAsync(batchId);
                        } catch (error) {
                            return callback(createOpenDSUErrorWrapper(`Failed to cancel batch`, error, listFilesError));
                        }
                        return callback(listFilesError);
                    }

                    walletDBEnclaveDSU.commitBatch(batchId, callback);
                })
            })
        };

        __storePathKeySSI();
    };

    const compactPathKeys = async () => {
        let compactedContent = "";
        const crypto = require("opendsu").loadAPI("crypto");
        const files = await $$.promisify(walletDBEnclaveDSU.listFiles)(constants.PATHS.SCATTERED_PATH_KEYS);

        for (let i = 0; i < files.length; i++) {
            const {key, value} = getKeyValueFromPath(files[i]);
            compactedContent = `${compactedContent}${key} ${value}\n`;
        }

        compactedContent = compactedContent.slice(0, compactedContent.length - 1);
        const fileName = crypto.encodeBase58(crypto.generateRandom(16));
        await $$.promisify(walletDBEnclaveDSU.writeFile)(pathModule.join(constants.PATHS.COMPACTED_PATH_KEYS, fileName), compactedContent);

        for (let i = 0; i < files.length; i++) {
            const filePath = pathModule.join(constants.PATHS.SCATTERED_PATH_KEYS, files[i]);
            await $$.promisify(walletDBEnclaveDSU.delete)(filePath);
        }
    }

    const getKeyValueFromPath = (pth) => {
        const lastSegmentIndex = pth.lastIndexOf("/");
        const key = pth.slice(0, lastSegmentIndex);
        const value = pth.slice(lastSegmentIndex + 1);
        return {
            key, value
        }
    }

    this.loadPaths = (callback) => {
        const __loadPaths = () => {
            loadCompactedPathKeys((err, compactedKeys) => {
                if (err) {
                    return callback(err);
                }

                loadScatteredPathKeys(async (err, scatteredKeys) => {
                    if (err) {
                        return callback(err);
                    }


                    callback(undefined, {...compactedKeys, ...scatteredKeys});
                })
            });
        }
        __loadPaths();
    }

    const loadScatteredPathKeys = (callback) => {
        const pathKeyMap = {};
        walletDBEnclaveDSU.listFiles(constants.PATHS.SCATTERED_PATH_KEYS, async (err, files) => {
            if (err) {
                return callback(err);
            }

            for (let i = 0; i < files.length; i++) {
                const {key, value} = getKeyValueFromPath(files[i]);
                pathKeyMap[key] = value;
            }

            callback(undefined, pathKeyMap);
        });
    }

    const loadCompactedPathKeys = (callback) => {
        let pathKeyMap = {};
        const compactedValuesLocation = constants.PATHS.COMPACTED_PATH_KEYS;
        walletDBEnclaveDSU.listFiles(compactedValuesLocation, async (err, files) => {
            if (err) {
                return callback(err);
            }

            try {
                for (let i = 0; i < files.length; i++) {
                    const filePath = pathModule.join(compactedValuesLocation, files[i]);
                    let compactedFileContent = await $$.promisify(walletDBEnclaveDSU.readFile)(filePath);
                    compactedFileContent = compactedFileContent.toString();
                    const partialKeyMap = mapFileContent(compactedFileContent);
                    pathKeyMap = {...pathKeyMap, ...partialKeyMap};
                }
            } catch (e) {
                return callback(e);
            }


            callback(undefined, pathKeyMap);
        });
    }

    const mapFileContent = (fileContent) => {
        const pathKeyMap = {};
        const fileLines = fileContent.split("\n");
        for (let i = 0; i < fileLines.length; i++) {
            const splitLine = fileLines[i].split(" ");
            pathKeyMap[splitLine[0]] = splitLine[1];
        }

        return pathKeyMap;
    }
}

module.exports = WalletDBEnclaveHandler;
},{"../../constants/constants":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/enclave/constants/constants.js","opendsu":"opendsu","path":false}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/enclave/KeySSIMappings/SeedSSIMapping/LightDBStorageStrategy.js":[function(require,module,exports){
function LightDBStorageStrategy(lightDBEnclave) {
    this.insertRecord = (table, pk, record, callback) => {
        lightDBEnclave.insertRecord($$.SYSTEM_IDENTIFIER, table, pk, record, callback);
    }

    this.updateRecord = (table, pk, plainRecord, encryptedRecord, callback) => {
        lightDBEnclave.updateRecord($$.SYSTEM_IDENTIFIER, table, pk, plainRecord, encryptedRecord, callback);
    }

    this.getRecord = (table, pk, callback) => {
        lightDBEnclave.getRecord($$.SYSTEM_IDENTIFIER, table, pk, callback);
    }
}

module.exports = LightDBStorageStrategy;
},{}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/enclave/KeySSIMappings/SeedSSIMapping/SeedSSIMapping.js":[function(require,module,exports){
function SeedSSIMapping(storageStrategy) {
    const utils = require("../../utils/utils");
    const openDSU = require("opendsu");
    const keySSISpace = openDSU.loadAPI("keyssi");
    this.storeKeySSI = (keySSI, callback) => {
        if (typeof keySSI === "string") {
            try {
                keySSI = keySSISpace.parse(keySSI);
            } catch (e) {
                return callback(e);
            }
        }
        utils.getKeySSIMapping(keySSI, async (err, keySSIMapping) => {
            if (err) {
                return callback(err);
            }

            for (let keySSIType in keySSIMapping) {
                for (let ssi in keySSIMapping[keySSIType]) {
                    let record;
                    try {
                        record = await $$.promisify(storageStrategy.getRecord)(keySSIType, ssi);
                    } catch (e) {
                        // ignore error
                    }

                    if (!record) {
                        try {
                            await $$.promisify(storageStrategy.insertRecord)(keySSIType, ssi, {keySSI: keySSIMapping[keySSIType][ssi]});
                        } catch (e) {
                            return callback(e);
                        }
                    }
                }
            }
            callback();
        });
    }

    this.getReadKeySSI = (keySSI, callback) => {
        if (typeof keySSI === "string") {
            try {
                keySSI = keySSISpace.parse(keySSI);
            } catch (e) {
                return callback(e);
            }
        }
        storageStrategy.getRecord(openDSU.constants.KEY_SSIS.SREAD_SSI, keySSI.getIdentifier(), (err, sReadSSIRecord) => {
            if (err) {
                return callback(err);
            }
            if (!sReadSSIRecord) {
                return callback(Error(`No read key SSI found for keySSI <${keySSI.getIdentifier()}>`));
            }

            callback(undefined, sReadSSIRecord.keySSI);
        })
    }

    this.getWriteKeySSI = (keySSI, callback) => {
        if (typeof keySSI === "string") {
            try {
                keySSI = keySSISpace.parse(keySSI);
            } catch (e) {
                return callback(e);
            }
        }
        storageStrategy.getRecord(openDSU.constants.KEY_SSIS.SEED_SSI, keySSI.getIdentifier(), (err, sWriteSSIRecord) => {
            if (err) {
                return callback(err);
            }
            if (!sWriteSSIRecord) {
                return callback(Error(`No write key SSI found for keySSI <${keySSI.getIdentifier()}>`));
            }

            callback(undefined, sWriteSSIRecord.keySSI);
        });
    }
}

const getSeedSSIMapping = (storageStrategy) => {
    return new SeedSSIMapping(storageStrategy);
}

module.exports = {
    getSeedSSIMapping
};
},{"../../utils/utils":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/enclave/utils/utils.js","opendsu":"opendsu"}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/enclave/constants/commandsNames.js":[function(require,module,exports){
module.exports = {
    GRANT_WRITE_ACCESS: "grantWriteAccess",
    GRANT_READ_ACCESS: "grantReadAccess",
    GRANT_ADMIN_ACCESS: "grantAdminAccess",
    REVOKE_WRITE_ACCESS: "revokeWriteAccess",
    REVOKE_READ_ACCESS: "revokeReadAccess",
    REVOKE_ADMIN_ACCESS: "revokeAdminAccess",
    HAS_WRITE_ACCESS: "hasWriteAccess",
    HAS_READ_ACCESS: "hasReadAccess",
    HAS_ADMIN_ACCESS: "hasAdminAccess",
    INSERT_RECORD: "insertRecord",
    UPDATE_RECORD: "updateRecord",
    GET_RECORD: "getRecord",
    DELETE_RECORD: "deleteRecord",
    FILTER_RECORDS: "filter",
    GET_ALL_RECORDS: "getAllRecords",
    BEGIN_BATCH: "beginBatch",
    COMMIT_BATCH: "commitBatch",
    CANCEL_BATCH: "cancelBatch",
    READ_KEY: "readKey",
    WRITE_KEY: "writeKey",
    ADD_IN_QUEUE: "addInQueue",
    QUEUE_SIZE: "queueSize",
    LIST_QUEUE: "listQueue",
    GET_OBJECT_FROM_QUEUE: "getObjectFromQueue",
    DELETE_OBJECT_FROM_QUEUE: "deleteObjectFromQueue",
    STORE_SEED_SSI: "storeSeedSSI",
    SIGN_FOR_KEY_SSI: "signForKeySSI",
    STORE_DID: "storeDID",
    ADD_PRIVATE_KEY_FOR_DID: "addPrivateKeyForDID",
    SIGN_FOR_DID: "signForDID",
    VERIFY_FOR_DID: "verifyForDID",
    ENCRYPT_MESSAGE: "encryptMessage",
    DECRYPT_MESSAGE: "decryptMessage",
    GET_PRIVATE_INFO_FOR_DID:"getPrivateInfoForDID",
    GET_COLLECTIONS: "getCollections",
    SAVE_DATABASE: "saveDatabase"
}
},{}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/enclave/constants/constants.js":[function(require,module,exports){
module.exports = {
    TABLE_NAMES: {
        KEY_SSIS: "keyssis",
        SREAD_SSIS: "sreadssis",
        SEED_SSIS: "seedssis",
        DIDS_PRIVATE_KEYS: "dids_private",
        PATH_KEY_SSI_PRIVATE_KEYS: "path-keyssi-private-keys",
        PRIVATE_KEYS: "private-keys",
        SECRET_KEYS: "secret-keys"
    },
    PATHS: {
        SCATTERED_PATH_KEYS: "/paths/scatteredPathKeys",
        COMPACTED_PATH_KEYS: "/paths/compactedPathKeys"
    },
    DB_NAMES: {
        WALLET_DB_ENCLAVE: "walletdb_enclave"
    }
};
},{}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/enclave/impl/CloudEnclaveClient.js":[function(require,module,exports){
const {createCommandObject} = require("../utils/createCommandObject");
const commandNames = require("../constants/commandsNames");

function CloudEnclaveClient(clientDID, remoteDID, requestTimeout) {
    let initialised = false;
    const DEFAULT_TIMEOUT = 10000;

    this.commandsMap = new Map();
    requestTimeout = requestTimeout ?? DEFAULT_TIMEOUT;

    const ProxyMixin = require("../mixins/ProxyMixin");
    ProxyMixin(this);

    const init = async () => {
        try {
            const w3cDID = require("opendsu").loadAPI("w3cdid");
            this.clientDIDDocument = await $$.promisify(w3cDID.resolveDID)(clientDID);
            this.remoteDIDDocument = await $$.promisify(w3cDID.resolveDID)(remoteDID);
        } catch (err) {
            console.log(err);
        }
        this.initialised = true;
        this.finishInitialisation();
        this.dispatchEvent("initialised");
        subscribe();
    }

    this.isInitialised = () => {
        return initialised;
    }

    this.getDID = (callback) => {
        callback(undefined, clientDID);
    }

    this.grantReadAccess = (forDID, resource, callback) => {
        this.__putCommandObject(commandNames.GRANT_READ_ACCESS, forDID, resource, callback);
    }

    this.grantWriteAccess = (forDID, resource, callback) => {
        this.__putCommandObject(commandNames.GRANT_WRITE_ACCESS, forDID, resource, callback);
    }

    this.grantAdminAccess = (forDID, resource, callback) => {
        this.__putCommandObject(commandNames.GRANT_ADMIN_ACCESS, forDID, resource, callback);
    }

    this.callLambda = (lambdaName, ...args) => {
        if (typeof args[args.length - 1] !== "function") {
            throw new Error("Last argument must be a callback function");
        }
        this.__putCommandObject(lambdaName, ...args);
    }

    this.__putCommandObject = (commandName, ...args) => {
        const callback = args.pop();
        args.push(clientDID);

        const command = JSON.stringify(createCommandObject(commandName, ...args));
        const commandID = JSON.parse(command).commandID;
        this.commandsMap.set(commandID, {"callback": callback, "time": Date.now()});

        const timeout = setTimeout(() => {
            if (this.commandsMap.has(commandID)) {
                this.commandsMap.get(commandID).callback(new Error(`Response for command ${commandID} not received within ${requestTimeout}ms`));
                this.commandsMap.delete(commandID);
            }
        }, requestTimeout);

        this.commandsMap.get(commandID).timeout = timeout;

        this.clientDIDDocument.sendMessage(command, this.remoteDIDDocument, (err) => {
            console.log("Sent command with id " + commandID);
            if (err) {
                console.log(err);
                clearTimeout(timeout);
            }
        });
    };

    const subscribe = () => {
        this.clientDIDDocument.subscribe((err, res) => {
            if (err) {
                console.log(err);
                return;
            }

            try {
                const resObj = JSON.parse(res);
                const commandID = resObj.commandID;

                if (this.commandsMap.has(commandID)) {
                    clearTimeout(this.commandsMap.get(commandID).timeout);
                    const callback = this.commandsMap.get(commandID).callback;
                    this.commandsMap.delete(commandID);
                    console.log("Deleted resolved command with id " + commandID);

                    if (resObj.error) {
                        callback(Error(resObj.commandResult.debug_message));
                    } else {
                        callback(undefined, resObj.commandResult);
                    }
                }
            } catch (err) {
                console.log(err);
            }
        });
    };

    const bindAutoPendingFunctions = require("../../utils/BindAutoPendingFunctions").bindAutoPendingFunctions;
    bindAutoPendingFunctions(this, ["on", "off", "dispatchEvent", "beginBatch", "isInitialised", "getEnclaveType"]);

    init();
}

module.exports = CloudEnclaveClient;

},{"../../utils/BindAutoPendingFunctions":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/utils/BindAutoPendingFunctions.js","../constants/commandsNames":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/enclave/constants/commandsNames.js","../mixins/ProxyMixin":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/enclave/mixins/ProxyMixin.js","../utils/createCommandObject":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/enclave/utils/createCommandObject.js","opendsu":"opendsu"}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/enclave/impl/LightDBEnclave.js":[function(require,module,exports){
function LightDBEnclave(dbName, slots) {
    const {createCommandObject} = require("../utils/createCommandObject");
    const openDSU = require("opendsu");
    const http = openDSU.loadAPI("http");
    const system = openDSU.loadAPI("system");
    let serverAddress = process.env.LIGHT_DB_SERVER_ADDRESS || `${system.getBaseURL()}/lightDB`;
    let initialised = false;
    const ProxyMixin = require("../mixins/ProxyMixin");
    ProxyMixin(this);

    this.isInitialised = () => {
        return initialised;
    }

    this.getName = () => {
        return dbName;
    }

    this.__putCommandObject = (commandName, ...args) => {
        const callback = args.pop();
        const url = `${serverAddress}/executeCommand/${dbName}`;
        let command = createCommandObject(commandName, ...args);
        let didDocument = args[0];
        if (didDocument === $$.SYSTEM_IDENTIFIER) {
            didDocument = $$.SYSTEM_DID_DOCUMENT;
        }

        command = JSON.stringify(command);
        didDocument.sign(command, (err, signature) => {
            if (err) {
                return callback(err);
            }

            let signedCommand = {};
            signedCommand.command = command;
            signedCommand.signature = signature.toString("base64");
            http.doPut(url, JSON.stringify(signedCommand), (err, response) => {
                if (err) {
                    return callback(err);
                }

                try {
                    response = JSON.parse(response);
                } catch (e) {
                    console.debug(`Failed to execute command: ${JSON.stringify(signedCommand)}, ${response} got as response`);
                    return callback(e);
                }

                callback(undefined, response);
            });
        })
    }

    this.createDatabase = (dbName, callback) => {
        const url = `${serverAddress}/createDatabase/${dbName}`;
        http.doPut(url, "", callback);
    }

    const originalInsert = this.insertRecord;
    this.insertRecord = (forDID, table, pk, encryptedRecord, callback) => {
        this.hasWriteAccess(forDID, (err, hasAccess) => {
            if (err) {
                return callback(err);
            }

            if (!hasAccess) {
                return callback(Error("No write access"));
            }

            originalInsert(forDID, table, pk, encryptedRecord, callback);
        });
    }

    const originalUpdate = this.updateRecord;
    this.updateRecord = (forDID, table, pk, plainRecord, encryptedRecord, callback) => {
        this.hasWriteAccess(forDID, (err, hasAccess) => {
            if (err) {
                return callback(err);
            }

            if (!hasAccess) {
                return callback(Error("No write access"));
            }

            originalUpdate(forDID, table, pk, plainRecord, encryptedRecord, callback);
        });
    }

    const originalDelete = this.deleteRecord;
    this.deleteRecord = (forDID, table, pk, callback) => {
        this.hasWriteAccess(forDID, (err, hasAccess) => {
            if (err) {
                return callback(err);
            }

            if (!hasAccess) {
                return callback(Error("No write access"));
            }

            originalDelete(forDID, table, pk, callback);
        });
    }

    const originalGet = this.getRecord;
    this.getRecord = (forDID, table, pk, callback) => {
        this.hasReadAccess(forDID, (err, hasAccess) => {
            if (err) {
                return callback(err);
            }

            if (!hasAccess) {
                return callback(Error("No read access"));
            }

            originalGet(forDID, table, pk, callback);
        });
    }

    const originalAddInQueue = this.addInQueue;
    this.addInQueue = (forDID, queueName, encryptedObject, ensureUniqueness, callback) => {
        this.hasWriteAccess(forDID, (err, hasAccess) => {
            if (err) {
                return callback(err);
            }

            if (!hasAccess) {
                return callback(Error("No write access"));
            }

            originalAddInQueue(forDID, queueName, encryptedObject, ensureUniqueness, callback);
        });
    }

    const originalGetObjectFromQueue = this.getObjectFromQueue;
    this.getObjectFromQueue = (forDID, queueName, hash, callback) => {
        this.hasReadAccess(forDID, (err, hasAccess) => {
            if (err) {
                return callback(err);
            }

            if (!hasAccess) {
                return callback(Error("No read access"));
            }

            originalGetObjectFromQueue(forDID, queueName, hash, callback);
        });
    }

    const originalDeleteObjectFromQueue = this.deleteObjectFromQueue;
    this.deleteObjectFromQueue = (forDID, queueName, hash, callback) => {
        this.hasWriteAccess(forDID, (err, hasAccess) => {
            if (err) {
                return callback(err);
            }

            if (!hasAccess) {
                return callback(Error("No write access"));
            }

            originalDeleteObjectFromQueue(forDID, queueName, hash, callback);
        });
    }


    const LightDBStorageStrategy = require("../KeySSIMappings/SeedSSIMapping/LightDBStorageStrategy");
    const lightDBStorageStrategy = new LightDBStorageStrategy(this);
    const SeedSSIMapping = require("../KeySSIMappings/SeedSSIMapping/SeedSSIMapping");
    const seedSSIMapping = SeedSSIMapping.getSeedSSIMapping(lightDBStorageStrategy);
    const resolverAPI = openDSU.loadAPI("resolver");
    const keySSISpace = openDSU.loadAPI("keyssi");

    this.storeKeySSI = (forDID, keySSI, callback) => {
        if(typeof keySSI === "function"){
            callback = keySSI;
            keySSI = forDID;
            forDID = undefined;
        }

        keySSI = parseKeySSI(keySSI, callback);
        if (!keySSI) {
            return;
        }
        if (isConstSSIFamily(keySSI)) {
            return callback();
        }
        seedSSIMapping.storeKeySSI(keySSI, callback);
    }

    this.getReadForKeySSI = (forDID, keySSI, callback) => {
        if(typeof keySSI === "function"){
            callback = keySSI;
            keySSI = forDID;
            forDID = undefined;
        }

        keySSI = parseKeySSI(keySSI, callback);
        if (!keySSI) {
            return;
        }
        if (isConstSSIFamily(keySSI)) {
            return callback(undefined, keySSI);
        }
        seedSSIMapping.getReadKeySSI(keySSI, callback);
    }

    this.getWriteKeySSI = (forDID, keySSI, callback) => {
        if(typeof keySSI === "function"){
            callback = keySSI;
            keySSI = forDID;
            forDID = undefined;
        }
        keySSI = parseKeySSI(keySSI, callback);
        if (!keySSI) {
            return;
        }
        if (isConstSSIFamily(keySSI)) {
            return callback(undefined, keySSI);
        }
        seedSSIMapping.getWriteKeySSI(keySSI, callback);
    }

    function parseKeySSI(keySSI, callback) {
        if (typeof keySSI === "string") {
            try {
                return keySSISpace.parse(keySSI);
            } catch (e) {
                callback(e);
            }
        }
        return keySSI;
    }

    function isConstSSIFamily(keySSI) {
        return keySSI.getFamilyName() === openDSU.constants.KEY_SSI_FAMILIES.CONST_SSI_FAMILY;
    }

    this.getPrivateKeyForSlot = (forDID, slot, callback) => {
        if (typeof slot === "function") {
            callback = slot;
            slot = forDID;
            forDID = undefined;
        }
        if (typeof slot === "string") {
            slot = parseInt(slot);
        }
        return callback(undefined, $$.Buffer.from(slots[slot], "base64"));
    }

    this.derivePathSSI = (forDID, pathSSI, callback) => {
        const specificString = pathSSI.getSpecificString();
        const index = specificString.indexOf("/");
        const slot = specificString.slice(0, index);
        const path = specificString.slice(index + 1);
        let privateKey = slots[slot];
        privateKey = pathSSI.hash(`${path}${privateKey}`);
        privateKey = pathSSI.decode(privateKey);
        const seedSpecificString = pathSSI.encodeBase64(privateKey);
        const seedSSI = this.createSeedSSI(pathSSI.getDLDomain(), seedSpecificString, pathSSI.getVn(), pathSSI.getHint());
        callback(undefined, seedSSI);
    }

    this.createDSU = (forDID, keySSI, options, callback) => {
        // if (typeof forDID === "string") {
        //     try {
        //         forDID = keySSISpace.parse(forDID);
        //         options = keySSI;
        //         keySSI = forDID;
        //     } catch (e) {
        //         //do nothing
        //     }
        // }

        if (typeof keySSI === "string") {
            try {
                keySSI = keySSISpace.parse(keySSI);
            } catch (e) {
                return callback(e);
            }
        }

        if (typeof options === "function") {
            callback = options;
            options = undefined;
        }

        if (keySSI.withoutCryptoData()) {
            this.createSeedSSI(undefined, keySSI.getDLDomain(), (err, seedSSI) => {
                if (err) {
                    return callback(err);
                }

                resolverAPI.createDSUForExistingSSI(seedSSI, callback);
            })
        } else {
            this.storeKeySSI(undefined, keySSI, (err) => {
                if (err) {
                    return callback(err);
                }

                resolverAPI.createDSU(keySSI, options, callback);
            })
        }
    }

    this.createDSUForExistingSSI = (forDID, keySSI, options, callback) => {
        if (typeof keySSI === "function") {
            callback = keySSI;
            keySSI = forDID;
            options = {};
            forDID = $$.SYSTEM_IDENTIFIER
        }
        if (typeof options === "function") {
            callback = options;
            options = keySSI;
            keySSI = forDID;
            forDID = $$.SYSTEM_IDENTIFIER
        }
        if (!options) {
            options = {};
        }
        options.useSSIAsIdentifier = true;
        resolverAPI.createDSUForExistingSSI(keySSI, options, callback);
    }
}

module.exports = LightDBEnclave;
},{"../KeySSIMappings/SeedSSIMapping/LightDBStorageStrategy":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/enclave/KeySSIMappings/SeedSSIMapping/LightDBStorageStrategy.js","../KeySSIMappings/SeedSSIMapping/SeedSSIMapping":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/enclave/KeySSIMappings/SeedSSIMapping/SeedSSIMapping.js","../mixins/ProxyMixin":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/enclave/mixins/ProxyMixin.js","../utils/createCommandObject":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/enclave/utils/createCommandObject.js","opendsu":"opendsu"}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/enclave/impl/MemoryEnclave.js":[function(require,module,exports){
function MemoryEnclave() {
    const EnclaveMixin = require("../mixins/Enclave_Mixin");
    EnclaveMixin(this);
    const openDSU = require("opendsu");
    const db = openDSU.loadAPI("db");
    let initialised = false;
    const init = () => {
        this.storageDB = db.getInMemoryDB();
        setTimeout(async () => {
            initialised = true;
            this.dispatchEvent("initialised");
        })
    }

    this.getEnclaveType = () => {
        return openDSU.constants.ENCLAVE_TYPES.MEMORY_ENCLAVE;
    };

    this.getKeySSI = (callback) => {
        callback(undefined, "ssi::::")
    }
    this.isInitialised = () => {
        return initialised
    }

    init();
}

module.exports = MemoryEnclave;
},{"../mixins/Enclave_Mixin":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/enclave/mixins/Enclave_Mixin.js","opendsu":"opendsu"}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/enclave/impl/VersionlessDSUEnclave.js":[function(require,module,exports){
function VersionlessDSUEnclave(keySSI, did) {
    const openDSU = require("opendsu");
    const constants = require("../constants/constants");
    const db = openDSU.loadAPI("db");
    const resolver = openDSU.loadAPI("resolver");
    const keySSISpace = openDSU.loadAPI("keyssi");
    const DB_NAME = constants.DB_NAMES.WALLET_DB_ENCLAVE;
    const EnclaveMixin = require("../mixins/Enclave_Mixin");

    EnclaveMixin(this, did, keySSI);

    let versionlessDSU;
    let initialised = false;
    const init = async () => {
        if (!keySSI) {
            try {
                versionlessDSU = await $$.promisify(resolver.createVersionlessDSU)();
            } catch (e) {
                throw createOpenDSUErrorWrapper(`Failed to create versionless DSU`, e);
            }

            try {
                keySSI = await $$.promisify(versionlessDSU.getKeySSIAsString)();
            } catch (e) {
                throw createOpenDSUErrorWrapper(`Failed to get enclave DSU KeySSI`, e);
            }
        }

        await $$.promisify(resolver.invalidateDSUCache)(keySSI);

        this.storageDB = db.getVersionlessDB(DB_NAME, {keySSI});
        this.storageDB.on("error", (err) => {
            this.dispatchEvent("error", err);
        });
        this.storageDB.on("initialised", async () => {
            if (typeof keySSI === "string") {
                keySSI = keySSISpace.parse(keySSI);
            }
            let privateKey;
            try {
                privateKey = await $$.promisify(this.storageDB.getRecord)(constants.TABLE_NAMES.PATH_KEY_SSI_PRIVATE_KEYS, 0);
            } catch (e) {
            }
            if (!privateKey) {
                await $$.promisify(this.storageDB.insertRecord)(constants.TABLE_NAMES.PATH_KEY_SSI_PRIVATE_KEYS, 0, {
                    privateKey: keySSI.getEncryptionKey(),
                });
            }

            initialised = true;
            this.finishInitialisation();
            this.dispatchEvent("initialised");
        });
    };

    this.getKeySSI = (forDID, callback) => {
        if (typeof forDID === "function") {
            callback = forDID;
            forDID = undefined;
        }
        callback(undefined, keySSI);
    };

    this.getEnclaveType = () => {
        return openDSU.constants.ENCLAVE_TYPES.VERSIONLESS_DSU_ENCLAVE;
    };

    this.isInitialised = () => {
        return initialised;
    };

    const bindAutoPendingFunctions = require("../../utils/BindAutoPendingFunctions").bindAutoPendingFunctions;
    bindAutoPendingFunctions(this, ["on", "off", "dispatchEvent", "beginBatch", "isInitialised", "getEnclaveType"]);

    init();
}

module.exports = VersionlessDSUEnclave;

},{"../../utils/BindAutoPendingFunctions":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/utils/BindAutoPendingFunctions.js","../constants/constants":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/enclave/constants/constants.js","../mixins/Enclave_Mixin":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/enclave/mixins/Enclave_Mixin.js","opendsu":"opendsu"}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/enclave/impl/WalletDBEnclave.js":[function(require,module,exports){
const {createOpenDSUErrorWrapper} = require("../../error");

function WalletDBEnclave(keySSI, did) {
    const openDSU = require("opendsu");
    const constants = require("../constants/constants");
    const db = openDSU.loadAPI("db")
    const scAPI = openDSU.loadAPI("sc");
    const resolver = openDSU.loadAPI("resolver");
    const config = openDSU.loadAPI("config");
    const keySSISpace = openDSU.loadAPI("keyssi");
    const DB_NAME = constants.DB_NAMES.WALLET_DB_ENCLAVE;
    const EnclaveMixin = require("../mixins/Enclave_Mixin");
    EnclaveMixin(this, did, keySSI);
    let enclaveDSU;
    let initialised = false;
    const init = async () => {
        if (!keySSI) {
            try {
                keySSI = await $$.promisify(config.getEnv)(openDSU.constants.MAIN_ENCLAVE.KEY_SSI);
            } catch (e) {
                console.log("Not able to retrieve the keyssi of the enclave. A new one will be created.");
            }

            if (!keySSI) {
                let vaultDomain;
                try {
                    vaultDomain = await $$.promisify(scAPI.getVaultDomain)();
                } catch (e) {
                    throw createOpenDSUErrorWrapper(`Failed to get vault domain`, e);
                }

                try {
                    enclaveDSU = await $$.promisify(resolver.createSeedDSU)(vaultDomain);
                } catch (e) {
                    throw createOpenDSUErrorWrapper(`Failed to create Seed DSU`, e);
                }

                try {
                    keySSI = await $$.promisify(enclaveDSU.getKeySSIAsString)();
                } catch (e) {
                    throw createOpenDSUErrorWrapper(`Failed to get enclave DSU KeySSI`, e);
                }
                try {
                    await $$.promisify(config.setEnv)(openDSU.constants.MAIN_ENCLAVE.KEY_SSI, keySSI);
                } catch (e) {
                    throw createOpenDSUErrorWrapper(`Failed to store enclave DSU KeySSI`, e);
                }
            }
        }

        try {
            await $$.promisify(resolver.invalidateDSUCache)(keySSI);
            this.storageDB = db.getSimpleWalletDB(DB_NAME, {keySSI});
        } catch (e) {
            this.dispatchEvent("error", e)
        }
        this.storageDB.on("error", err => {
            this.dispatchEvent("error", err)
        });
        this.storageDB.on("initialised", async () => {
            if (typeof keySSI === "string") {
                keySSI = keySSISpace.parse(keySSI);
            }
            enclaveDSU = this.storageDB.getStorageDSU();
            let privateKey;
            try {
                privateKey = await $$.promisify(this.storageDB.getRecord)(constants.TABLE_NAMES.PATH_KEY_SSI_PRIVATE_KEYS, 0);
            } catch (e) {
            }
            if (!privateKey) {
                let batchId;
                try{
                    batchId = await this.storageDB.startOrAttachBatchAsync();
                } catch (e) {
                    this.dispatchEvent("error", e);
                }

                try {
                    await $$.promisify(this.storageDB.insertRecord)(constants.TABLE_NAMES.PATH_KEY_SSI_PRIVATE_KEYS, 0, {privateKey: keySSI.getPrivateKey()});
                    await this.storageDB.commitBatchAsync(batchId);
                } catch (e) {
                    const insertError = createOpenDSUErrorWrapper(`Failed to insert private key`, e);
                    try {
                        await this.storageDB.cancelBatchAsync(batchId);
                    } catch (error) {
                        //not relevant...
                        console.log(error);
                    }
                    this.dispatchEvent("error", insertError);
                    return
                }
            }

            initialised = true;
            this.finishInitialisation();
            this.dispatchEvent("initialised");
        })
    };

    this.getKeySSI = (forDID, callback) => {
        if (typeof forDID === "function") {
            callback = forDID;
            forDID = undefined;
        }
        callback(undefined, keySSI);
    }

    this.getDSU = (forDID, callback) => {
        if (typeof forDID === "function") {
            callback = forDID;
            forDID = undefined;
        }
        callback(undefined, enclaveDSU);
    }

    this.getUniqueIdAsync = async () => {
        let keySSI = await $$.promisify(this.getKeySSI)();
        return await keySSI.getAnchorIdAsync();
    }

    this.getEnclaveType = () => {
        return openDSU.constants.ENCLAVE_TYPES.WALLET_DB_ENCLAVE;
    };

    this.isInitialised = () => {
        return initialised;
    };

    this.onCommitBatch = (forDID, callback, once)=>{
        this.storageDB.onCommitBatch(callback, once);
    }

    const bindAutoPendingFunctions = require("../../utils/BindAutoPendingFunctions").bindAutoPendingFunctions;
    bindAutoPendingFunctions(this, ["on", "off", "dispatchEvent", "beginBatch", "isInitialised", "getEnclaveType", "getDID", "getUniqueIdAsync"]);

    init();
}

module.exports = WalletDBEnclave;
},{"../../error":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/error/index.js","../../utils/BindAutoPendingFunctions":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/utils/BindAutoPendingFunctions.js","../constants/constants":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/enclave/constants/constants.js","../mixins/Enclave_Mixin":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/enclave/mixins/Enclave_Mixin.js","opendsu":"opendsu"}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/enclave/index.js":[function(require,module,exports){
const constants = require("../moduleConstants");

function initialiseWalletDBEnclave(keySSI) {
    const WalletDBEnclave = require("./impl/WalletDBEnclave");
    return new WalletDBEnclave(keySSI);
}

function initialiseMemoryEnclave() {
    const MemoryEnclave = require("./impl/MemoryEnclave");
    return new MemoryEnclave();
}

function initialiseLightDBEnclave(dbName, slots) {
    const LightDBEnclave = require("./impl/LightDBEnclave");
    return new LightDBEnclave(dbName, slots);
}

function initialiseRemoteEnclave(clientDID, remoteDID) {
    console.warn("initialiseRemoteEnclave is deprecated. Use initialiseCloudEnclaveClient instead");
    const CloudEnclave = require("./impl/CloudEnclaveClient");
    return new CloudEnclave(clientDID, remoteDID);
}

function initialiseCloudEnclaveClient(clientDID, remoteDID) {
    const CloudEnclave = require("./impl/CloudEnclaveClient");
    return new CloudEnclave(clientDID, remoteDID);
}

function initialiseVersionlessDSUEnclave(versionlessSSI) {
    const VersionlessDSUEnclave = require("./impl/VersionlessDSUEnclave");
    return new VersionlessDSUEnclave(versionlessSSI);
}

function connectEnclave(forDID, enclaveDID, ...args) {
    throw Error("Not implemented");
}

const enclaveConstructors = {};

function createEnclave(enclaveType, ...args) {
    if (typeof enclaveConstructors[enclaveType] !== "function") {
        throw Error(`No constructor function registered for enclave type ${enclaveType}`);
    }

    return enclaveConstructors[enclaveType](...args);
}

function registerEnclave(enclaveType, enclaveConstructor) {
    if (typeof enclaveConstructors[enclaveType] !== "undefined") {
        throw Error(`A constructor function already registered for enclave type ${enclaveType}`);
    }
    enclaveConstructors[enclaveType] = enclaveConstructor;
}

function convertWalletDBEnclaveToVersionlessEnclave(walletDBEnclave, callback) {
    const openDSU = require("opendsu");
    const resolver = openDSU.loadAPI("resolver");
    walletDBEnclave.getAllTableNames(undefined, async (err, tableNames) => {
        if (err) {
            return callback(err);
        }

        let error;
        let versionlessDSU;
        [error, versionlessDSU] = await $$.call(resolver.createVersionlessDSU);
        if (error) {
            return callback(error);
        }

        let versionlessSSI;
        [error, versionlessSSI] = await $$.call(versionlessDSU.getKeySSIAsObject);
        if (error) {
            return callback(error);
        }

        let versionlessEnclave = initialiseVersionlessDSUEnclave(versionlessSSI);

        versionlessEnclave.on("initialised", async () => {
            for (let i = 0; i < tableNames.length; i++) {
                let records;
                [error, records] = await $$.call(walletDBEnclave.getAllRecords, undefined, tableNames[i]);
                if (error) {
                    return callback(error);
                }

                for (let j = 0; j < records.length; j++) {
                    [error, res] = await $$.call(versionlessEnclave.insertRecord, undefined, tableNames[i], records[j].pk, records[j]);
                    if (error) {
                        [error, res] = await $$.call(versionlessEnclave.updateRecord, undefined, tableNames[i], records[j].pk, records[j], records[j]);
                        if (error) {
                            return callback(error);
                        }
                    }
                }

            }
            callback(undefined, versionlessEnclave);
        })
    })
}

function convertWalletDBEnclaveToCloudEnclave(walletDBEnclave, cloudEnclaveServerDIO, callback) {
    const openDSU = require("opendsu");
    const w3cDidAPI = openDSU.loadAPI("w3cdid");
    const keySSIApi = openDSU.loadAPI("keyssi");
    walletDBEnclave.getAllTableNames(undefined, async (err, tableNames) => {
        if (err) {
            return callback(err);
        }

        let error;
        let keySSI;

        [error, keySSI] = await $$.call(walletDBEnclave.getKeySSI);
        if (error) {
            return callback(error);
        }

        if (typeof keySSI === "string") {
            try {
                keySSI = keySSIApi.parse(keySSI);
            } catch (err) {
                return callback(err);
            }
        }

        const domain = keySSI.getDLDomain();

        const CLOUD_ENCLAVE_NAME = "cloudEnclave";
        let cloudEnclaveDIDDocument;
        [error, cloudEnclaveDIDDocument] = await $$.call(w3cDidAPI.createIdentity, "ssi:name", domain, CLOUD_ENCLAVE_NAME);
        if (error) {
            return callback(error);
        }
        const cloudEnclaveDID = cloudEnclaveDIDDocument.getIdentifier();
        let cloudEnclave = initialiseCloudEnclaveClient(cloudEnclaveDID, cloudEnclaveServerDIO);

        cloudEnclave.on("initialised", async () => {
            for (let i = 0; i < tableNames.length; i++) {
                let records;
                [error, records] = await $$.call(walletDBEnclave.getAllRecords, undefined, tableNames[i]);
                if (error) {
                    return callback(error);
                }

                [error, res] = await $$.call(cloudEnclave.grantWriteAccess, cloudEnclaveDID, tableNames[i]);
                if (error) {
                    return callback(error);
                }

                for (let j = 0; j < records.length; j++) {
                    [error, res] = await $$.call(cloudEnclave.insertRecord, cloudEnclaveDID, tableNames[i], records[j].pk, records[j]);
                    if (error) {
                        [error, res] = await $$.call(cloudEnclave.updateRecord, cloudEnclaveDID, tableNames[i], records[j].pk, records[j], records[j]);
                        if (error) {
                            return callback(error);
                        }
                    }
                }

            }
            callback(undefined, cloudEnclave);
        })
    })
}

registerEnclave(constants.ENCLAVE_TYPES.MEMORY_ENCLAVE, initialiseMemoryEnclave);
registerEnclave(constants.ENCLAVE_TYPES.WALLET_DB_ENCLAVE, initialiseWalletDBEnclave);
registerEnclave(constants.ENCLAVE_TYPES.LIGHT_DB_ENCLAVE, initialiseLightDBEnclave);
registerEnclave(constants.ENCLAVE_TYPES.CLOUD_ENCLAVE, initialiseCloudEnclaveClient)
registerEnclave(constants.ENCLAVE_TYPES.VERSIONLESS_DSU_ENCLAVE, initialiseVersionlessDSUEnclave);

module.exports = {
    initialiseWalletDBEnclave,
    initialiseMemoryEnclave,
    initialiseLightDBEnclave,
    initialiseRemoteEnclave,
    initialiseCloudEnclaveClient,
    initialiseVersionlessDSUEnclave,
    connectEnclave,
    createEnclave,
    registerEnclave,
    EnclaveMixin: require("./mixins/Enclave_Mixin"),
    ProxyMixin: require("./mixins/ProxyMixin"),
    convertWalletDBEnclaveToVersionlessEnclave,
    convertWalletDBEnclaveToCloudEnclave
}

},{"../moduleConstants":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/moduleConstants.js","./impl/CloudEnclaveClient":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/enclave/impl/CloudEnclaveClient.js","./impl/LightDBEnclave":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/enclave/impl/LightDBEnclave.js","./impl/MemoryEnclave":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/enclave/impl/MemoryEnclave.js","./impl/VersionlessDSUEnclave":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/enclave/impl/VersionlessDSUEnclave.js","./impl/WalletDBEnclave":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/enclave/impl/WalletDBEnclave.js","./mixins/Enclave_Mixin":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/enclave/mixins/Enclave_Mixin.js","./mixins/ProxyMixin":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/enclave/mixins/ProxyMixin.js","opendsu":"opendsu"}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/enclave/mixins/Enclave_Mixin.js":[function(require,module,exports){
const constants = require("../constants/constants");
const {createOpenDSUErrorWrapper} = require("../../error");

function Enclave_Mixin(target, did) {
    const openDSU = require("opendsu");
    const keySSISpace = openDSU.loadAPI("keyssi")
    const w3cDID = openDSU.loadAPI("w3cdid")
    const errorAPI = openDSU.loadAPI("error");

    const ObservableMixin = require("../../utils/ObservableMixin");
    ObservableMixin(target);
    const CryptoSkills = w3cDID.CryptographicSkills;

    let pathKeyMapping;

    const getPrivateInfoForDID = (did, callback) => {
        target.storageDB.getRecord(constants.TABLE_NAMES.DIDS_PRIVATE_KEYS, did, (err, record) => {
            if (err) {
                return callback(err);
            }

            let privateKeysAsBuffArr = record.privateKeys.map(privateKey => {
                if (privateKey) {
                    return $$.Buffer.from(privateKey)
                }

                return privateKey;
            });
            privateKeysAsBuffArr = privateKeysAsBuffArr.filter(privateKey => privateKey);
            if (privateKeysAsBuffArr.length === 0) {
                return callback(Error(`No private keys found for DID ${did}`));
            }

            callback(undefined, privateKeysAsBuffArr);
        });
    };

    const getCapableOfSigningKeySSI = (keySSI, callback) => {
        if (typeof keySSI === "undefined") {
            return callback(Error(`A SeedSSI should be specified.`));
        }

        if (typeof keySSI === "string") {
            try {
                keySSI = keySSISpace.parse(keySSI);
            } catch (e) {
                return callback(createOpenDSUErrorWrapper(`Failed to parse keySSI ${keySSI}`, e))
            }
        }

        target.storageDB.getRecord(constants.TABLE_NAMES.KEY_SSIS, keySSI.getIdentifier(), (err, record) => {
            if (err) {
                return callback(createOpenDSUErrorWrapper(`No capable of signing keySSI found for keySSI ${keySSI.getIdentifier()}`, err));
            }

            let capableOfSigningKeySSI;
            try {
                capableOfSigningKeySSI = keySSISpace.parse(record.capableOfSigningKeySSI);
            } catch (e) {
                return callback(createOpenDSUErrorWrapper(`Failed to parse keySSI ${record.capableOfSigningKeySSI}`, e))
            }

            callback(undefined, capableOfSigningKeySSI);
        });
    };

    const getPathKeyMapping = (callback) => {
        if (pathKeyMapping) {
            return callback(undefined, pathKeyMapping);
        }

        const EnclaveHandler = require("../KeySSIMappings/PathKeySSIMapping/WalletDBEnclaveHandler");
        const PathKeyMapping = require("../KeySSIMappings/PathKeySSIMapping/PathKeyMapping");

        try {
            target.getDSU((err, dsuInstance) => {
                if (err) {
                    return callback(err);
                }

                const enclaveHandler = new EnclaveHandler(dsuInstance);
                pathKeyMapping = new PathKeyMapping(enclaveHandler);
                pathKeyMapping.on("initialised", () => {
                    callback(undefined, pathKeyMapping);
                })
            })
        } catch (e) {
            return callback(e);
        }
    }

    target.getDID = (callback) => {
        if (!did) {
            did = CryptoSkills.applySkill("key", CryptoSkills.NAMES.CREATE_DID_DOCUMENT);
            did.on("error", callback);

            did.on("initialised", () => {
                did = did.getIdentifier();
                callback(undefined, did);
            })
        } else {
            callback(undefined, did);
        }
    }

    target.refresh = (forDID, callback) => {
        if (typeof forDID === "function") {
            callback = forDID;
            forDID = undefined;
        }

        target.storageDB.refresh(callback);
    }

    target.getPrivateKeyForSlot = (forDID, slot, callback) => {
        if (typeof slot === "function") {
            callback = slot;
            slot = forDID;
            forDID = undefined;
        }
        target.storageDB.getRecord(constants.TABLE_NAMES.PATH_KEY_SSI_PRIVATE_KEYS, slot, (err, privateKeyRecord) => {
            if (err) {
                return callback(err);
            }
            let privateKey;
            try {
                privateKey = $$.Buffer.from(privateKeyRecord.privateKey);
            } catch (e) {
                return callback(e);
            }

            callback(undefined, privateKey);
        });
    };

    target.addIndex = (forDID, table, field, forceReindex, callback) => {
        if (typeof forceReindex === "function") {
            callback = forceReindex;
            forceReindex = false;
        }
        target.storageDB.addIndex(table, field, forceReindex, callback);
    }

    target.getIndexedFields = (forDID, table, callback) => {
        target.storageDB.getIndexedFields(table, callback);
    }

    target.insertRecord = (forDID, table, pk, plainRecord, encryptedRecord, callback) => {
        if (typeof encryptedRecord === "function") {
            callback = encryptedRecord;
            encryptedRecord = plainRecord;
        }
        if (!encryptedRecord) {
            encryptedRecord = plainRecord;
        }
        target.storageDB.insertRecord(table, pk, encryptedRecord, callback);
    }

    target._insertRecord = (table, pk, plainRecord, encryptedRecord, callback) => {
        if (typeof encryptedRecord === "function") {
            callback = encryptedRecord;
            encryptedRecord = plainRecord;
        }
        target.storageDB.insertRecord(table, pk, encryptedRecord, callback);
    }

    target.updateRecord = (forDID, table, pk, plainRecord, encryptedRecord, callback) => {
        if (typeof encryptedRecord === "function") {
            callback = encryptedRecord;
            encryptedRecord = plainRecord;
        }
        target.storageDB.updateRecord(table, pk, encryptedRecord, callback);
    }

    target._updateRecord = (table, pk, plainRecord, encryptedRecord, callback) => {
        if (typeof encryptedRecord === "function") {
            callback = encryptedRecord;
            encryptedRecord = plainRecord;
        }
        target.storageDB.updateRecord(table, pk, encryptedRecord, callback);
    }

    target.getRecord = (forDID, table, pk, callback) => {
        target.storageDB.getRecord(table, pk, callback);
    };

    target._getRecord = (table, pk, callback) => {
        target.storageDB.getRecord(table, pk, callback);
    }

    target.getAllTableNames = (forDID, callback) => {
        target.storageDB.getAllTableNames(callback);
    }

    target.filter = (forDID, table, filter, sort, limit, callback) => {
        target.storageDB.filter(table, filter, sort, limit, callback);
    }

    target._filter = (table, filter, sort, limit, callback) => {
        target.storageDB.filter(table, filter, sort, limit, callback);
    }

    target.deleteRecord = (forDID, table, pk, callback) => {
        target.storageDB.deleteRecord(table, pk, callback);
    }

    target._deleteRecord = (table, pk, callback) => {
        target.storageDB.deleteRecord(table, pk, callback);
    }

    target.beginBatch = (forDID) => {
        target.storageDB.beginBatch();
    }

    target.safeBeginBatch = (forDID, ...args) => {
        target.storageDB.safeBeginBatch(...args);
    }

    target.safeBeginBatchAsync = async (forDID, ...args) => {
        return await target.storageDB.safeBeginBatchAsync(...args);
    }

    target.startOrAttachBatch = (forDID, ...args) => {
        target.storageDB.startOrAttachBatch(...args);
    }

    target.startOrAttachBatchAsync = async (forDID, ...args) => {
        return await target.storageDB.startOrAttachBatchAsync(...args);
    }

    target.commitBatch = (forDID, ...args) => {
        target.storageDB.commitBatch(...args);
    }

    target.commitBatchAsync = async (forDID, ...args) => {
        return await target.storageDB.commitBatchAsync(...args);
    }

    target.cancelBatch = (forDID, ...args) => {
        target.storageDB.cancelBatch(...args);
    }

    target.cancelBatchAsync = async (forDID, ...args) => {
        return await target.storageDB.cancelBatchAsync(...args);
    }

    target.batchInProgress = (forDID) => {
        return target.storageDB.batchInProgress();
    }

    target.readKey = (forDID, key, callback) => {
        target.storageDB.readKey(key, callback);
    }

    target.writeKey = (forDID, key, value, callback) => {
        target.storageDB.writeKey(key, value, callback);
    }

    target.getAllRecords = (forDID, tableName, callback) => {
        target.storageDB.getAllRecords(tableName, callback);
    }

    target._getAllRecords = (tableName, callback) => {
        target.storageDB.getAllRecords(tableName, callback);
    }

    target.storeSeedSSI = (forDID, seedSSI, alias, callback) => {
        if (typeof seedSSI === "string") {
            try {
                seedSSI = keySSISpace.parse(seedSSI);
            } catch (e) {
                return callback(createOpenDSUErrorWrapper(`Failed to parse keySSI ${seedSSI}`, e))
            }
        }

        if (typeof alias === "function") {
            callback = alias;
            alias = undefined;
        }

        if (typeof alias === "undefined") {
            const generateUid = require("swarmutils").generateUid;
            alias = generateUid(10).toString("hex");
        }

        const keySSIIdentifier = seedSSI.getIdentifier();
        const isExistingKeyError = (error) => error.originalMessage === errorAPI.DB_INSERT_EXISTING_RECORD_ERROR;

        function registerDerivedKeySSIs(derivedKeySSI, sReadSSIIdentifier, cb) {
            target.storageDB.insertRecord(constants.TABLE_NAMES.KEY_SSIS, derivedKeySSI.getIdentifier(), {capableOfSigningKeySSI: keySSIIdentifier}, (err) => {
                if (err && !isExistingKeyError(err)) {
                    // ignore if KeySSI is already present
                    return cb(err);
                }
                target.storageDB.insertRecord(constants.TABLE_NAMES.SREAD_SSIS, derivedKeySSI.getIdentifier(), {sReadSSI: sReadSSIIdentifier}, (err) => {
                    if (err && !isExistingKeyError(err)) {
                        // ignore if sReadSSI is already present
                        return cb(err);
                    }

                    if (typeof derivedKeySSI.derive !== "function") {
                        return cb();
                    }

                    derivedKeySSI.derive((err, _derivedKeySSI) => {
                        if (err) {
                            return cb(err);
                        }

                        registerDerivedKeySSIs(_derivedKeySSI, sReadSSIIdentifier, cb);
                    })

                });
            });
        }

        seedSSI.derive((err, sReadSSI) => {
            if (err) {
                return callback(err);
            }

            const sReadSSIIdentifier = sReadSSI.getIdentifier();
            target.storageDB.startOrAttachBatch((err, batchId) => {
                if (err) {
                    return callback(err);
                }
                return registerDerivedKeySSIs(seedSSI, sReadSSIIdentifier, (err) => {
                    if (err) {
                        return target.storageDB.cancelBatch(batchId, (error) => {
                            console.log("Failed to cancel batch after fail of registering derived key.", error);
                            callback(err);
                        });
                    }

                    target.storageDB.commitBatch(batchId, callback);
                });
            });
        })
    }

    target.storeKeySSI = (forDID, keySSI, callback) => {
        if (typeof keySSI === "function") {
            callback = keySSI;
            keySSI = forDID;
            forDID = undefined;
        }

        if (typeof keySSI === "string") {
            try {
                keySSI = keySSISpace.parse(keySSI);
            } catch (e) {
                return callback(createOpenDSUErrorWrapper(`Failed to parse keySSI ${keySSI}`, e))
            }
        }

        if (keySSI.getTypeName() === openDSU.constants.KEY_SSIS.PATH_SSI) {
            return getPathKeyMapping((err, pathKeyMapping) => {
                if (err) {
                    return callback(err);
                }

                pathKeyMapping.storePathKeySSI(keySSI, callback);
            })
        }

        if (keySSI.getTypeName() === openDSU.constants.KEY_SSIS.SEED_SSI) {
            return target.storeSeedSSI(forDID, keySSI, undefined, callback);
        }

        if (keySSI.getFamilyName() === openDSU.constants.KEY_SSI_FAMILIES.SEED_SSI_FAMILY) {
            const keySSIIdentifier = keySSI.getIdentifier();
            target.storageDB.startOrAttachBatch((err, batchId) => {
                if (err) {
                    return callback(err);
                }
                target.storageDB.insertRecord(constants.TABLE_NAMES.KEY_SSIS, keySSIIdentifier, {keySSI: keySSIIdentifier}, (err) => {
                    if (err) {
                        return target.storageDB.cancelBatch(batchId, (err) => {
                            if (err) {
                                return callback(err);
                            }
                            callback(err);
                        });
                    }

                    target.storageDB.commitBatch(batchId, callback);
                });
            })
        } else {
            callback();
        }
    }

    target.storeReadForAliasSSI = (forDID, sReadSSI, aliasSSI, callback) => {
        if (typeof sReadSSI === "string") {
            try {
                sReadSSI = keySSISpace.parse(sReadSSI);
            } catch (e) {
                return callback(createOpenDSUErrorWrapper(`Failed to parse SReadSSI ${sReadSSI}`, e))
            }
        }

        if (typeof aliasSSI === "string") {
            try {
                aliasSSI = keySSISpace.parse(aliasSSI);
            } catch (e) {
                return callback(createOpenDSUErrorWrapper(`Failed to parse SReadSSI ${aliasSSI}`, e))
            }
        }
        const keySSIIdentifier = sReadSSI.getIdentifier();
        target.storageDB.startOrAttachBatch((err, batchId) => {
            if (err) {
                return callback(err);
            }
            target.storageDB.insertRecord(constants.TABLE_NAMES.SREAD_SSIS, aliasSSI.getIdentifier(), {sReadSSI: keySSIIdentifier}, (err) => {
                if (err) {
                    return target.storageDB.cancelBatch(batchId, (error) => {
                        console.log("Failed to cancel batch after fail to store sread.", error);
                        callback(err);
                    });
                }

                target.storageDB.commitBatch(batchId, callback);
            });
        })
    }

    target.getReadForKeySSI = (forDID, keySSI, callback) => {
        if (typeof keySSI === "function") {
            callback = keySSI;
            keySSI = forDID;
            forDID = undefined;
        }

        if (typeof keySSI === "string") {
            try {
                keySSI = keySSISpace.parse(keySSI);
            } catch (e) {
                return callback(createOpenDSUErrorWrapper(`Failed to parse keySSI ${keySSI}`, e))
            }
        }

        getPathKeyMapping((err, pathKeyMapping) => {
            if (err) {
                return target.storageDB.getRecord(constants.TABLE_NAMES.SREAD_SSIS, keySSI.getIdentifier(), (err, record) => {
                    if (err) {
                        return callback(err);
                    }

                    callback(undefined, record.sReadSSI);
                });
            }

            pathKeyMapping.getReadForKeySSI(keySSI, (err, readKeySSI) => {
                if (err) {
                    return target.storageDB.getRecord(constants.TABLE_NAMES.SREAD_SSIS, keySSI.getIdentifier(), (err, record) => {
                        if (err) {
                            return callback(err);
                        }

                        callback(undefined, record.sReadSSI);
                    });
                }

                callback(undefined, readKeySSI);
            })
        })
    }

    target.storeDID = (forDID, storedDID, privateKeys, callback) => {
        if (typeof privateKeys === "function") {
            callback = privateKeys;
            privateKeys = storedDID;
            storedDID = forDID;
        }
        if (!Array.isArray(privateKeys)) {
            return callback(Error("Private keys should be an array"));
        }
        // if array contains null or undefined, throw error
        if (privateKeys.some(key => !key)) {
            return callback(Error("Private key cannot be null or undefined"));
        }

        target.storageDB.getRecord(constants.TABLE_NAMES.DIDS_PRIVATE_KEYS, storedDID.getIdentifier(), (err, res) => {
            if (err || !res) {
                return target.storageDB.startOrAttachBatch((err, batchId) => {
                    if (err) {
                        return callback(err);
                    }
                    target.storageDB.insertRecord(constants.TABLE_NAMES.DIDS_PRIVATE_KEYS, storedDID.getIdentifier(), {privateKeys: privateKeys}, (err, rec) => {
                        if (err) {
                            return target.storageDB.cancelBatch(batchId, (err) => {
                                if (err) {
                                    return callback(err);
                                }
                                callback(err);
                            });
                        }

                        target.storageDB.commitBatch(batchId, err => callback(err, rec));
                    });
                })
            }

            // if array contains null or undefined, remove them
            privateKeys.forEach(privateKey => {
                res.privateKeys.push(privateKey);
            })
            res.privateKeys = res.privateKeys.filter(key => key);
            target.storageDB.startOrAttachBatch((err, batchId) => {
                if (err) {
                    return callback(err);
                }
                target.storageDB.updateRecord(constants.TABLE_NAMES.DIDS_PRIVATE_KEYS, storedDID.getIdentifier(), res, (err) => {
                    if (err) {
                        return target.storageDB.cancelBatch(batchId, (err) => {
                            if (err) {
                                return callback(err);
                            }
                            callback(err);
                        });
                    }

                    target.storageDB.commitBatch(batchId, callback);
                });
            })
        });
    }

    target.addPrivateKeyForDID = (forDid, didDocument, privateKey, callback) => {
        if (!privateKey) {
            return callback(Error("No private key provided"));
        }
        const privateKeyObj = {privateKeys: [privateKey]};
        target.storageDB.getRecord(constants.TABLE_NAMES.DIDS_PRIVATE_KEYS, didDocument.getIdentifier(), (err, res) => {
            if (err || !res) {
                return target.storageDB.startOrAttachBatch((err, batchId) => {
                    if (err) {
                        return callback(err);
                    }
                    return target.storageDB.insertRecord(constants.TABLE_NAMES.DIDS_PRIVATE_KEYS, didDocument.getIdentifier(), privateKeyObj, (err) => {
                        if (err) {
                            return target.storageDB.cancelBatch(batchId, (error) => {
                                console.log("Failed to cancel batch after failed insert of private key", error);
                                callback(err);
                            });
                        }

                        target.storageDB.commitBatch(batchId, callback);
                    });
                })
            }

            // remove null or undefined from the array
            res.privateKeys.push(privateKey);
            res.privateKeys = res.privateKeys.filter(key => key);
            target.storageDB.startOrAttachBatch((err, batchId) => {
                if (err) {
                    return callback(err);
                }
                target.storageDB.updateRecord(constants.TABLE_NAMES.DIDS_PRIVATE_KEYS, didDocument.getIdentifier(), res, (err) => {
                    if (err) {
                        return target.storageDB.cancelBatch(batchId, (e) => {
                            if (e) {
                                //this error is not that relevant... the updateRecord is more important...
                                console.log(e);
                            }
                            callback(err);
                        });
                    }

                    target.storageDB.commitBatch(batchId, callback);
                });
            })
        });
    }

    target.generateDID = (forDID, didMethod, ...args) => {
        args.unshift(target, didMethod);
        w3cDID.we_createIdentity(...args);
    }

    target.storePrivateKey = (forDID, privateKey, type, alias, callback) => {
        if (typeof alias == "function") {
            callback = alias;
            alias = undefined;
        }

        if (typeof alias === "undefined") {
            const generateUid = require("swarmutils").generateUid;
            alias = generateUid(10).toString("hex");
        }

        target.storageDB.startOrAttachBatch((err, batchId) => {
            if (err) {
                return callback(err);
            }
            target.storageDB.insertRecord(constants.TABLE_NAMES.PRIVATE_KEYS, alias, {
                privateKey: privateKey,
                type: type
            }, (err, rec) => {
                if (err) {
                    return target.storageDB.cancelBatch(batchId, (e) => {
                        if (e) {
                            //this e error is not that relevant... insert record err is important
                            console.log(e);
                        }
                        callback(err);
                    });
                }

                target.storageDB.commitBatch(batchId, (err) => callback(err, rec));
            });
        });
    }

    target.storeSecretKey = (forDID, secretKey, alias, callback) => {
        if (typeof alias == "function") {
            callback = alias;
            alias = undefined;
        }

        if (typeof alias === "undefined") {
            const generateUid = require("swarmutils").generateUid;
            alias = generateUid(10).toString("hex");
        }

        target.storageDB.startOrAttachBatch((err, batchId) => {
            if (err) {
                return callback(err);
            }
            target.storageDB.insertRecord(constants.TABLE_NAMES.SECRET_KEYS, alias, {secretKey: secretKey}, (err, res) => {
                if (err) {
                    return target.storageDB.cancelBatch(batchId, (e) => {
                        if (e) {
                            //this error is not that relevant
                            console.log(e);
                        }
                        callback(err);
                    });
                }

                target.storageDB.commitBatch(batchId, (err) => callback(err, res));
            })
        })
    };

    target.generateSecretKey = (forDID, secretKeyAlias, callback) => {
        if (typeof secretKeyAlias == "function") {
            callback = secretKeyAlias;
            secretKeyAlias = undefined;
        }

        if (typeof secretKeyAlias === "undefined") {
            const generateUid = require("swarmutils").generateUid;
            secretKeyAlias = generateUid(10).toString("hex");
        }

        const crypto = openDSU.loadAPI("crypto");
        const key = crypto.generateRandom(32);

        target.storeSecretKey(forDID, key, secretKeyAlias, callback);
    }

    target.signForDID = (forDID, didThatIsSigning, hash, callback) => {
        if (typeof hash === "function") {
            callback = hash;
            hash = didThatIsSigning;
            didThatIsSigning = forDID;
        }
        if (!didThatIsSigning || typeof didThatIsSigning === "string") {
            return callback(Error(`Invalid DID provided: ${didThatIsSigning}`));
        }

        let privateKeys;
        try {
            privateKeys = didThatIsSigning.getPrivateKeys();
            if(!Array.isArray(privateKeys) || !privateKeys.length){
                privateKeys = undefined;
            }
        } catch (e) {
            // ignored and handled below
        }

        if (!privateKeys) {
            return getPrivateInfoForDID(didThatIsSigning.getIdentifier(), async (err, privateKeys) => {
                if (err) {
                    return callback(createOpenDSUErrorWrapper(`Failed to get private info for did ${didThatIsSigning.getIdentifier()}`, err));
                }

                let signature;
                try {
                    signature = CryptoSkills.applySkill(didThatIsSigning.getMethodName(), CryptoSkills.NAMES.SIGN, hash, privateKeys[privateKeys.length - 1]);
                } catch (err) {
                    return callback(err);
                }
                callback(undefined, signature);
            });
        }

        let signature;
        try {
            signature = CryptoSkills.applySkill(didThatIsSigning.getMethodName(), CryptoSkills.NAMES.SIGN, hash, privateKeys[privateKeys.length - 1]);
        } catch (err) {
            return callback(err);
        }
        callback(undefined, signature);
    }

    target.verifyForDID = (forDID, didThatIsVerifying, hash, signature, callback) => {
        if (typeof hash === "function") {
            callback = signature;
            signature = hash;
            hash = didThatIsVerifying;
            didThatIsVerifying = forDID;
        }
        didThatIsVerifying.getPublicKey("pem", (err, publicKey) => {
            if (err) {
                return callback(createOpenDSUErrorWrapper(`Failed to read public key for did ${target.getIdentifier()}`, err));
            }

            const verificationResult = CryptoSkills.applySkill(didThatIsVerifying.getMethodName(), CryptoSkills.NAMES.VERIFY, hash, publicKey, signature);
            callback(undefined, verificationResult);
        });
    };

    target.signForKeySSI = (forDID, keySSI, hash, callback) => {
        const __signHashForKeySSI = (keySSI, hash) => {
            getCapableOfSigningKeySSI(keySSI, (err, capableOfSigningKeySSI) => {
                if (err) {
                    return callback(err);
                }
                if (typeof capableOfSigningKeySSI === "undefined") {
                    return callback(Error(`The provided SSI does not grant writing rights`));
                }

                capableOfSigningKeySSI.sign(hash, callback);
            });
        }
        getPathKeyMapping((err, pathKeyMapping) => {
            if (err) {
                return __signHashForKeySSI(keySSI, hash);
            }

            pathKeyMapping.getCapableOfSigningKeySSI(keySSI, (err, capableOfSigningKeySSI) => {
                if (err) {
                    return __signHashForKeySSI(keySSI, hash);
                }

                capableOfSigningKeySSI.sign(hash, callback);
            })
        })
    };

    target.encryptAES = (forDID, secretKeyAlias, message, AESParams, callback) => {

        if (typeof AESParams == "function") {
            callback = AESParams;
            AESParams = undefined;
        }

        target.storageDB.getRecord(constants.TABLE_NAMES.SECRET_KEYS, secretKeyAlias, (err, keyRecord) => {
            if (err !== undefined) {
                callback(err, undefined);
                return;
            }
            const crypto = require("pskcrypto"); // opendsu crypto does not receive aes options
            const pskEncryption = crypto.createPskEncryption('aes-256-gcm');

            const encryptedMessage = pskEncryption.encrypt(message, keyRecord.secretKey, AESParams);
            callback(undefined, encryptedMessage);
        })
    };

    target.decryptAES = (forDID, secretKeyAlias, encryptedMessage, AESParams, callback) => {
        if (typeof AESParams == "function") {
            callback = AESParams;
            AESParams = undefined;
        }

        target.storageDB.getRecord(constants.TABLE_NAMES.SECRET_KEYS, secretKeyAlias, (err, keyRecord) => {
            if (err !== undefined) {
                callback(err, undefined);
                return;
            }
            const crypto = require("pskcrypto"); // opendsu crypto does not receive aes options
            const pskEncryption = crypto.createPskEncryption('aes-256-gcm');

            const decryptedMessage = pskEncryption.decrypt(encryptedMessage, keyRecord.secretKey, 0, AESParams);
            callback(undefined, decryptedMessage);
        })

    };

    target.encryptMessage = (forDID, didFrom, didTo, message, callback) => {
        if (typeof message === "function") {
            callback = message;
            message = didTo;
            didTo = didFrom;
            didFrom = forDID;
        }
        let privateKeys;
        try{
            privateKeys = didFrom.getPrivateKeys();
        }catch (e) {
            // ignored and handled below
        }
        if (!privateKeys) {
            getPrivateInfoForDID(didFrom.getIdentifier(), (err, privateKeys) => {
                if (err) {
                    return callback(createOpenDSUErrorWrapper(`Failed to get private info for did ${didFrom.getIdentifier()}`, err));
                }

                CryptoSkills.applySkill(didFrom.getMethodName(), CryptoSkills.NAMES.ENCRYPT_MESSAGE, privateKeys, didFrom, didTo, message, callback);
            });
        } else {
            CryptoSkills.applySkill(didFrom.getMethodName(), CryptoSkills.NAMES.ENCRYPT_MESSAGE, privateKeys, didFrom, didTo, message, callback);
        }
    };

    target.decryptMessage = (forDID, didTo, encryptedMessage, callback) => {
        if (typeof encryptedMessage === "function") {
            callback = encryptedMessage;
            encryptedMessage = didTo;
            didTo = forDID;
        }

        let privateKeys;
        try{
            privateKeys = didTo.getPrivateKeys();
        }catch (e) {
            // ignored and handled below
        }
        if (!privateKeys) {
            getPrivateInfoForDID(didTo.getIdentifier(), (err, privateKeys) => {
                if (err) {
                    return callback(createOpenDSUErrorWrapper(`Failed to get private info for did ${didTo.getIdentifier()}`, err));
                }

                CryptoSkills.applySkill(didTo.getMethodName(), CryptoSkills.NAMES.DECRYPT_MESSAGE, privateKeys, didTo, encryptedMessage, callback);
            });
        } else {
            CryptoSkills.applySkill(didTo.getMethodName(), CryptoSkills.NAMES.DECRYPT_MESSAGE, privateKeys, didTo, encryptedMessage, callback);
        }
    };


    // expose keyssi APIs
    Object.keys(keySSISpace).forEach(fnName => {
        if (fnName.startsWith("we_")) {
            const trimmedFnName = fnName.slice(3);
            target[trimmedFnName] = (...args) => {
                args.shift();
                args.unshift(target);
                return keySSISpace[fnName](...args);
            }
        } else if (fnName.startsWith("createTemplate")) {
            target[fnName] = (...args) => {
                args.shift();
                return keySSISpace[fnName](...args);
            }
        }
    });

    // expose w3cdid APIs
    Object.keys(w3cDID).forEach(fnName => {
        if (fnName.startsWith("we_")) {
            const trimmedFnName = fnName.slice(3);
            target[trimmedFnName] = (...args) => {
                args.shift();
                args.unshift(target);
                w3cDID[fnName](...args);
            }
        }
    });

    const resolverAPI = openDSU.loadAPI("resolver");

    target.createDSU = (forDID, keySSI, options, callback) => {
        if (typeof options === "function") {
            callback = options;
            options = undefined;
        }
        if (typeof keySSI === "string") {
            try {
                keySSI = keySSISpace.parse(keySSI);
            } catch (e) {
                return callback(e);
            }
        }

        if (keySSI.isAlias()) {
            const scAPI = require("opendsu").loadAPI("sc");
            scAPI.getVaultDomain(async (err, vaultDomain) => {
                if (err) {
                    return callback(err);
                }

                let seedSSI;
                try {
                    seedSSI = await $$.promisify(target.createSeedSSI)(target, vaultDomain);
                    const sReadSSI = await $$.promisify(seedSSI.derive)();
                    await $$.promisify(target.storeReadForAliasSSI)(undefined, sReadSSI, keySSI);
                } catch (e) {
                    return callback(e);
                }

                resolverAPI.createDSUForExistingSSI(seedSSI, callback);
            })
            return
        }

        if (keySSI.withoutCryptoData()) {
            target.createSeedSSI(undefined, keySSI.getDLDomain(), (err, seedSSI) => {
                if (err) {
                    return callback(err);
                }

                resolverAPI.createDSUForExistingSSI(seedSSI, callback);
            })
        } else {
            target.storeKeySSI(undefined, keySSI, (err) => {
                if (err) {
                    return callback(err);
                }

                resolverAPI.createDSU(keySSI, options, callback);
            })
        }
    };

    target.loadDSU = (forDID, keySSI, options, callback) => {
        if (typeof options === "function") {
            callback = options;
            options = undefined;
        }
        if (typeof keySSI === "string") {
            try {
                keySSI = keySSISpace.parse(keySSI);
            } catch (e) {
                return callback(e);
            }
        }

        resolverAPI.loadDSU(keySSI, options, (err, dsu) => {
            if (err) {
                target.getReadForKeySSI(undefined, keySSI.getIdentifier(), (e, sReadSSI) => {
                    if (e) {
                        return callback(err);
                    }
                    resolverAPI.loadDSU(sReadSSI, options, callback);
                });

                return;
            }

            callback(undefined, dsu);
        })
    };

    target.loadDSUVersionBasedOnVersionNumber = (forDID, keySSI, versionNumber, callback) => {
        if (typeof versionNumber === "function") {
            callback = versionNumber;
            versionNumber = keySSI;
            keySSI = forDID;
            forDID = undefined;
        }
        resolverAPI.getDSUVersionHashlink(keySSI, versionNumber, (err, versionHashLink) => {
            if (err) {
                return callback(err);
            }

            target.loadDSUVersion(forDID, keySSI, versionHashLink, callback);
        })
    };

    target.loadDSUVersion = (forDID, keySSI, versionHashlink, options, callback) => {
        if (typeof versionHashlink === "function") {
            callback = versionHashlink;
            versionHashlink = keySSI;
            keySSI = forDID;
            forDID = undefined;
            options = {};
        }
        if (typeof options === "function") {
            callback = options;
            options = {};
        }

        if (typeof keySSI === "string") {
            try {
                keySSI = keySSISpace.parse(keySSI);
            } catch (e) {
                return callback(createOpenDSUErrorWrapper(`Failed to parse keySSI ${keySSI}`, e));
            }
        }

        options.versionHashlink = versionHashlink;
        target.loadDSU(forDID, keySSI, options, callback);
    };

    target.loadDSURecoveryMode = (forDID, ssi, contentRecoveryFnc, callback) => {
        const defaultOptions = {recoveryMode: true};
        let options = {contentRecoveryFnc, recoveryMode: true};
        if (typeof contentRecoveryFnc === "object") {
            options = contentRecoveryFnc;
        }

        options = Object.assign(defaultOptions, options);
        target.loadDSU(forDID, ssi, options, callback);
    };
}

module.exports = Enclave_Mixin;

},{"../../error":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/error/index.js","../../utils/ObservableMixin":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/utils/ObservableMixin.js","../KeySSIMappings/PathKeySSIMapping/PathKeyMapping":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/enclave/KeySSIMappings/PathKeySSIMapping/PathKeyMapping.js","../KeySSIMappings/PathKeySSIMapping/WalletDBEnclaveHandler":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/enclave/KeySSIMappings/PathKeySSIMapping/WalletDBEnclaveHandler.js","../constants/constants":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/enclave/constants/constants.js","opendsu":"opendsu","pskcrypto":"pskcrypto","swarmutils":"swarmutils"}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/enclave/mixins/ProxyMixin.js":[function(require,module,exports){
(function (Buffer){(function (){
const {createOpenDSUErrorWrapper} = require("../../error");

function ProxyMixin(target) {
    const commandNames = require("../constants/commandsNames");
    const ObservableMixin = require("../../utils/ObservableMixin");
    ObservableMixin(target);
    const EnclaveMixin = require("./Enclave_Mixin");
    EnclaveMixin(target);

    target.grantWriteAccess = (forDID, callback) => {
        target.__putCommandObject(commandNames.GRANT_WRITE_ACCESS, forDID, callback);
    }

    target.grantReadAccess = (forDID, callback) => {
        target.__putCommandObject(commandNames.GRANT_READ_ACCESS, forDID, callback);
    }

    target.revokeReadAccess = (forDID, callback) => {
        target.__putCommandObject(commandNames.REVOKE_READ_ACCESS, forDID, callback);
    }

    target.revokeExecutionAccess = (forDID, callback) => {
        target.__putCommandObject(commandNames.REVOKE_EXECUTION_ACCESS, forDID, callback);
    }

    target.hasWriteAccess = (forDID, callback) => {
        target.__putCommandObject(commandNames.HAS_WRITE_ACCESS, forDID, callback);
    }

    target.hasReadAccess = (forDID, callback) => {
        target.__putCommandObject(commandNames.HAS_READ_ACCESS, forDID, callback);
    }

    target.hasExecutionAccess = (forDID, callback) => {
        target.__putCommandObject(commandNames.HAS_EXECUTION_ACCESS, forDID, callback);
    }

    target.getCollections = (forDID, callback) => {
        target.__putCommandObject(commandNames.GET_COLLECTIONS, forDID, callback);
    }

    target.saveDatabase = (forDID, callback) => {
        target.__putCommandObject(commandNames.SAVE_DATABASE, forDID, callback);
    }

    target.insertRecord = (forDID, table, pk, plainRecord, encryptedRecord, callback) => {
        if (typeof encryptedRecord === "function") {
            callback = encryptedRecord;
            encryptedRecord = undefined;
        }

        if(!encryptedRecord){
            encryptedRecord = plainRecord;
        }
        target.__putCommandObject(commandNames.INSERT_RECORD, forDID, table, pk, encryptedRecord, callback);
    };

    target.updateRecord = (forDID, table, pk, plainRecord, encryptedRecord, callback) => {
        if (typeof encryptedRecord === "function") {
            callback = encryptedRecord;
            encryptedRecord = plainRecord;
        }

        if(!encryptedRecord){
            encryptedRecord = plainRecord;
        }
        target.__putCommandObject(commandNames.UPDATE_RECORD, forDID, table, pk, encryptedRecord, callback);
    }

    target.getRecord = (forDID, table, pk, callback) => {
        target.__putCommandObject(commandNames.GET_RECORD, forDID, table, pk, callback);
    };

    target.filter = (forDID, table, filter, sort, limit, callback) => {
        if (typeof filter === "function") {
            callback = filter;
            filter = undefined;
            sort = undefined;
            limit = undefined;
        }

        if (typeof sort === "function") {
            callback = sort;
            sort = undefined;
            limit = undefined;
        }

        if (typeof limit === "function") {
            callback = limit;
            limit = undefined;
        }
        target.__putCommandObject(commandNames.FILTER_RECORDS, forDID, table, filter, sort, limit, (err, records) => {
            if (err) {
                return callback(createOpenDSUErrorWrapper(`Failed to filter records in table ${table}`, err));
            }

            if(typeof records === "string") {
                try {
                    records = JSON.parse(records);
                } catch (e) {
                    return callback(createOpenDSUErrorWrapper(`Failed to parse record `, e));
                }
            }

            callback(undefined, records);
        });
    }

    target.getAllRecords = (forDID, table, callback) => {
        target.__putCommandObject(commandNames.GET_ALL_RECORDS, forDID, table, callback);
    }

    target.deleteRecord = (forDID, table, pk, callback) => {
        target.__putCommandObject(commandNames.DELETE_RECORD, forDID, table, pk, callback);
    }

    target.addInQueue = (forDID, queueName, encryptedObject, ensureUniqueness, callback) => {
        if (typeof ensureUniqueness === "function") {
            callback = ensureUniqueness;
            ensureUniqueness = false;
        }
        target.__putCommandObject(commandNames.ADD_IN_QUEUE, forDID, queueName, encryptedObject, ensureUniqueness, callback);
    };

    target.queueSize = (forDID, queueName, callback) => {
        target.__putCommandObject(commandNames.QUEUE_SIZE, forDID, queueName, callback);
    }

    target.listQueue = (forDID, queueName, sortAfterInsertTime, onlyFirstN, callback) => {
        if (typeof sortAfterInsertTime === "function") {
            callback = sortAfterInsertTime;
            sortAfterInsertTime = "asc";
            onlyFirstN = undefined
        }
        if (typeof onlyFirstN === "function") {
            callback = onlyFirstN;
            onlyFirstN = undefined;
        }
        target.__putCommandObject(commandNames.LIST_QUEUE, forDID, queueName, sortAfterInsertTime, onlyFirstN, callback);
    };

    target.getObjectFromQueue = (forDID, queueName, hash, callback) => {
        target.__putCommandObject(commandNames.GET_OBJECT_FROM_QUEUE, forDID, queueName, hash, callback);
    }

    target.deleteObjectFromQueue = (forDID, queueName, hash, callback) => {
        target.__putCommandObject(commandNames.DELETE_OBJECT_FROM_QUEUE, forDID, queueName, hash, callback);
    }

    target.beginBatch = (forDID, callback) => {
        callback(undefined);
    }

    target.cancelBatch = (forDID, callback) => {
        callback(undefined);
    }

    target.commitBatch = (forDID, callback) => {
        callback(undefined);
    }

    target.readKey = (forDID, key, callback) => {
        target.__putCommandObject(commandNames.READ_KEY, forDID, key, (err, serializedValue) => {
            if (err) {
                return callback(err);
            }
            let value;
            try {
                serializedValue = JSON.parse(serializedValue);
            } catch (e) {
                return callback(createOpenDSUErrorWrapper(`Failed to parse value`, e));
            }
            switch (serializedValue.type) {
                case "buffer":
                    value = Buffer.from(serializedValue.value);
                    break;
                case "object":
                    value = JSON.parse(serializedValue.value);
                    break;
                default:
                    value = serializedValue.value;
            }
            callback(undefined, value);
        });
    }

    target.writeKey = (forDID, key, value, callback) => {
        target.__putCommandObject(commandNames.WRITE_KEY, forDID, key, value, callback);
    }

    target.storeSeedSSI = (forDID, seedSSI, alias, callback) => {
        target.__putCommandObject(commandNames.STORE_SEED_SSI, forDID, seedSSI.getIdentifier(), alias, callback);
    }

    target.storeDID = (forDID, storedDID, privateKeys, callback) => {
        target.__putCommandObject(commandNames.STORE_DID, forDID.getIdentifier(), storedDID.getIdentifier(), privateKeys, callback);
    }

    target.signForDID = (forDID, didThatIsSigning, hash, callback) => {
        target.__putCommandObject(commandNames.SIGN_FOR_DID, forDID.getIdentifier(), didThatIsSigning.getIdentifier(), hash, (err, signature) => {
            if (err) {
                return callback(err);
            }

            callback(undefined, $$.Buffer.from(JSON.parse(signature)));
        });
    }

    target.verifyForDID = (forDID, didThatIsVerifying, hash, signature, callback) => {
        target.__putCommandObject(commandNames.VERIFY_FOR_DID, forDID.getIdentifier(), didThatIsVerifying.getIdentifier(), hash, signature, (err, verificationResult) => {
            if (err) {
                return callback(err);
            }

            callback(undefined, verificationResult);
        });
    }

    target.signForKeySSI = (forDID, keySSI, hash, callback) => {
        target.__putCommandObject(commandNames.SIGN_FOR_KEY_SSI, forDID.getIdentifier(), keySSI.getIdentifier(), hash, callback);
    }

    target.encryptMessage = (forDID, didFrom, didTo, message, callback) => {
        target.__putCommandObject(commandNames.ENCRYPT_MESSAGE, forDID.getIdentifier(), didFrom.getIdentifier(), didTo.getIdentifier(), message, callback);
    }

    target.decryptMessage = (forDID, didTo, encryptedMessage, callback) => {
        target.__putCommandObject(commandNames.DECRYPT_MESSAGE, forDID.getIdentifier(), didTo.getIdentifier(), encryptedMessage, (err, decryptedMessage) => {
            if (err) {
                return callback(err);
            }

            try {
                decryptedMessage = JSON.parse(decryptedMessage);
            } catch (e) {
                return callback(createOpenDSUErrorWrapper(`Failed to parse decrypted message`, e));
            }
            callback(undefined, decryptedMessage.message);
        });
    }
}

module.exports = ProxyMixin;
}).call(this)}).call(this,require("buffer").Buffer)

},{"../../error":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/error/index.js","../../utils/ObservableMixin":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/utils/ObservableMixin.js","../constants/commandsNames":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/enclave/constants/commandsNames.js","./Enclave_Mixin":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/enclave/mixins/Enclave_Mixin.js","buffer":false}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/enclave/utils/createCommandObject.js":[function(require,module,exports){
const createCommandObject = (commandName, ...args) => {
    const commandID = require('crypto').randomBytes(32).toString("base64")

    return {
        commandName,
        commandID,
        params: [
            ...args
        ]
    };
}

module.exports = {
    createCommandObject
}
},{"crypto":false}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/enclave/utils/utils.js":[function(require,module,exports){
const openDSU = require("opendsu");
const keySSISpace = openDSU.loadAPI("keyssi");

const mergeMappings = (dest, source) => {
    for (let ssiType in source) {
        if (typeof dest[ssiType] === "undefined") {
            dest[ssiType] = source[ssiType];
        }else{
            dest[ssiType] = {...dest[ssiType], ...source[ssiType]};
        }
    }

    return dest;
}

const getKeySSIsMappingFromPathKeys = (pathKeyMap, callback) => {
    let keySSIMap = {};
    const paths = Object.keys(pathKeyMap);
    if (paths.length === 0) {
        return callback(undefined, keySSIMap);
    }
    const TaskCounter = require("swarmutils").TaskCounter;
    const taskCounter = new TaskCounter(()=>{
        return callback(undefined, keySSIMap);
    })
    taskCounter.increment(paths.length);
    paths.forEach(pth => {
        const pathSSIIdentifier = pathKeyMap[pth];
        let keySSI;
        try {
            keySSI = keySSISpace.parse(pathSSIIdentifier);
        } catch (e) {
            return callback(e);
        }

        getKeySSIMapping(keySSI, (err, derivedKeySSIs) => {
            if (err) {
                return callback(err);
            }

            keySSIMap = mergeMappings(keySSIMap, derivedKeySSIs);
            taskCounter.decrement();
        })
    })
}

const getDerivedKeySSIs = (keySSI, callback) => {
    if (typeof keySSI === "string") {
        try {
            keySSI = keySSISpace.parse(keySSI);
        } catch (e) {
            return callback(e);
        }
    }

    const derivedKeySSIs = {};
    const __getDerivedKeySSIsRecursively = (currentKeySSI, callback) => {
        derivedKeySSIs[currentKeySSI.getTypeName()] = currentKeySSI.getIdentifier();
        try {
            currentKeySSI.derive((err, derivedKeySSI) => {
                if (err) {
                    return callback(err);
                }

                currentKeySSI = derivedKeySSI;
                __getDerivedKeySSIsRecursively(currentKeySSI, callback);
            });
        } catch (e) {
            return callback(undefined, derivedKeySSIs);
        }
    }

    __getDerivedKeySSIsRecursively(keySSI, callback);
}
const getKeySSIMapping = (keySSI, callback) => {
    if (typeof keySSI === "string") {
        try {
            keySSI = keySSISpace.parse(keySSI);
        } catch (e) {
            return callback(e);
        }
    }
    const keySSIsMap = {};

    getDerivedKeySSIs(keySSI, (err, _derivedKeySSIsObj)=>{
        if (err) {
            return callback(err);
        }

        for (let ssiType in _derivedKeySSIsObj) {
            keySSIsMap[ssiType] = {};
            const derivedKeySSIsList = Object.values(_derivedKeySSIsObj);
            for (let i = 0; i < derivedKeySSIsList.length; i++) {
                keySSIsMap[ssiType][derivedKeySSIsList[i]] = _derivedKeySSIsObj[ssiType];
            }
        }

        callback(undefined, keySSIsMap);
    })
}

module.exports = {
    getKeySSIsMappingFromPathKeys,
    getKeySSIMapping,
    getDerivedKeySSIs,
    mergeMappings
}
},{"opendsu":"opendsu","swarmutils":"swarmutils"}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/error/index.js":[function(require,module,exports){
const constants = require("../moduleConstants");

function detectRootCauseType(arr, priorityList){
    for(let errorType of priorityList){
        const index = arr.findIndex(e => {
            return e.rootCause && e.rootCause !== errorType
        });
        if (index !== -1) {
            return arr[index].rootCause;
        }
    }

    return constants.ERROR_ROOT_CAUSE.UNKNOWN_ERROR;
}

function ErrorWrapper(message, err, otherErrors, rootCause) {
    if (typeof rootCause === "undefined" && typeof otherErrors === "string") {
        rootCause = otherErrors;
        otherErrors = undefined;
    }
    let newErr = {};
    err = err || {rootCause: constants.ERROR_ROOT_CAUSE.UNKNOWN_ERROR};
    if (!err.rootCause) {
        err.rootCause = constants.ERROR_ROOT_CAUSE.UNKNOWN_ERROR;
    }

    if (!rootCause && otherErrors) {
        const errorTypes = constants.ERROR_ROOT_CAUSE;
        rootCause = detectRootCauseType(otherErrors, [errorTypes.DATA_INPUT_ERROR, errorTypes.MISSING_DATA_ERROR, errorTypes.BUSINESS_ERROR, errorTypes.THROTTLER_ERROR, errorTypes.NETWORK_ERROR]);
    }

    if (err.message || otherErrors) {
        if (err.originalMessage) {
            newErr.originalMessage = err.originalMessage;
        } else {
            newErr.originalMessage = err.message;
            if (otherErrors) {
                if (typeof otherErrors === "string") {
                    newErr.originalMessage += otherErrors;
                }

                if (Array.isArray(otherErrors)) {
                    otherErrors.forEach(e => newErr.originalMessage += `[${e.message}]`);
                }
            }
            if (typeof newErr.originalMessage === "string") {
                newErr.originalMessage = newErr.originalMessage.replace(/\n/g, " ");
            }
        }

    }

    try {
        if (err.originalMessage) {
            newErr = new Error(message + `(${err.originalMessage})`);
            newErr.originalMessage = err.originalMessage;
        } else {
            newErr = new Error(newErr.originalMessage);
            newErr.originalMessage = newErr.message;
        }
        throw newErr;
    } catch (e) {
        newErr = e;
    }
    newErr.previousError = err;
    newErr.debug_message = message;
    if (err.rootCause) {
        newErr.rootCause = err.rootCause;
    }
    if (rootCause) {
        newErr.rootCause = rootCause;
    }
    if (err.stack) {
        newErr.debug_stack = err.stack;
    }
    if (otherErrors) {
        newErr.otherErrors = otherErrors;
    }

    function dumpErrorWrapper(ew, showIntermediateErrors) {
        let level = 0;
        let str = `Top level error: ${ew.debug_message} ${ew.debug_stack}`
        let firstError;
        ew = ew.previousError;
        while (ew) {
            if (showIntermediateErrors && ew.previousError) {
                str += `\nError at layer ${level}: ${ew.debug_message} ${ew.debug_stack}`;
            }
            level++;
            firstError = ew;
            ew = ew.previousError;
        }
        str += `\n\tFirst error in the ErrorWrapper at level ${level} :${firstError}\n`;
        return str
    }

    newErr.toString = function () {
        return dumpErrorWrapper(newErr, true);
    };

    return newErr;
}

function createOpenDSUErrorWrapper(message, err, otherErrors, rootCause) {
    if (typeof message !== "string") {
        if (typeof err != "undefined") {
            err = message;
            message = "Wrong usage of createErrorWrapper";
        } else {
            message = "Wrong usage of createErrorWrapper";
        }
    }
    if(otherErrors && !Array.isArray(otherErrors) && typeof otherErrors !== "string"){
        otherErrors = [otherErrors];
    }
    return ErrorWrapper(message, err, otherErrors, rootCause);
}

function registerMandatoryCallback(callback, timeout) {
    if (timeout == undefined) {
        timeout = 5000; //5 seconds
    }
    let callStackErr = false;
    try {
        throw new Error("Callback should be called");
    } catch (err) {
        callStackErr = err;
    }
    const timeoutId = setTimeout(function () {
        reportUserRelevantError("Expected callback not called after " + timeout + " seconds. The calling stack is here: ", callStackErr);
    }, timeout);

    return function (...args) {
        clearTimeout(timeoutId);
        callback(...args);
    };
}

function OpenDSUSafeCallback(callback) {
    if (callback && typeof callback === 'function') {
        return callback;
    } else return function (err, res) {
        if (err) {
            reportUserRelevantError("Unexpected error happened without proper handling:", err);
        } else {
            reportUserRelevantWarning("Ignored result. Please add a proper callback when using this function! " + res)
        }
    }
}

let observable = require("./../utils/observable").createObservable();

function reportUserRelevantError(message, err) {
  genericDispatchEvent(constants.NOTIFICATION_TYPES.ERROR, message, err);
}

function reportUserRelevantWarning(message, err) {
  genericDispatchEvent(constants.NOTIFICATION_TYPES.WARN, message, err);
}


function reportUserRelevantInfo(message, err) {
  genericDispatchEvent(constants.NOTIFICATION_TYPES.INFO, message, err);
}

function reportDevRelevantInfo(message, err) {
    genericDispatchEvent(constants.NOTIFICATION_TYPES.DEV, message, err);
}

function genericDispatchEvent(type, message, err) {
    observable.dispatchEvent(type, {message, err});
    console.log(message, err ? err : "");
    if (err && typeof err.debug_message != "undefined") {
      printErrorWrapper(err, false);
    }
}


function unobserveUserRelevantMessages(type, callback) {
    switch (type) {
        case constants.NOTIFICATION_TYPES.ERROR:
            observable.off(type, callback);
            break;
        case constants.NOTIFICATION_TYPES.INFO:
            observable.off(type, callback);
            break;
        case constants.NOTIFICATION_TYPES.WARN:
            observable.off(type, callback);
            break;
        case constants.NOTIFICATION_TYPES.DEV:
            observable.off(type, callback);
            break;
        default:
            observable.off(constants.NOTIFICATION_TYPES.DEV, callback);
    }
}

function observeUserRelevantMessages(type, callback) {
    switch (type) {
        case constants.NOTIFICATION_TYPES.ERROR:
            observable.on(type, callback);
            break;
        case constants.NOTIFICATION_TYPES.INFO:
            observable.on(type, callback);
            break;
        case constants.NOTIFICATION_TYPES.WARN:
            observable.on(type, callback);
            break;
        case constants.NOTIFICATION_TYPES.DEV:
            observable.on(type, callback);
            break;
        case "unhandled":
            observable.on(type, callback);
            break;
        default:
            observable.on(constants.NOTIFICATION_TYPES.DEV, callback);
            break;
    }
}

if (typeof window !== "undefined") {
    window.onerror = (msg, url, line, call, err)=>{
        observable.dispatchEvent("unhandled", err);
        console.log(msg, url, line, call);
    }

    window.addEventListener("error", window.onerror)
}
function printErrorWrapper(ew, showIntermediateErrors) {
    let level = 0;
    console.log("Top level error:", ew.debug_message, ew.debug_stack);
    let firstError;
    ew = ew.previousError;
    while (ew) {
        if (showIntermediateErrors && ew.previousError) {
            console.log("Error at layer ", level, " :", ew.debug_message, ew.debug_stack);
        }
        level++;
        firstError = ew;
        ew = ew.previousError;
    }
    console.log("\tFirst error in the ErrorWrapper at level ", level, " :", firstError);
}

function printOpenDSUError(...args) {
    for (let elem of args) {
        if (typeof elem.previousError != "undefined") {
            printErrorWrapper(elem);
        } else {
            console.log(elem);
        }
    }
}

function httpToRootCauseErrorCode(httpRes) {
    if (!httpRes) {
        return constants.ERROR_ROOT_CAUSE.UNKNOWN_ERROR;
    }

    if (!httpRes.statusCode) {
        return constants.ERROR_ROOT_CAUSE.NETWORK_ERROR;
    }

    if (httpRes.statusCode === 429) {
        return constants.ERROR_ROOT_CAUSE.THROTTLER_ERROR;
    }

    if (httpRes.statusCode === 404) {
        return constants.ERROR_ROOT_CAUSE.MISSING_DATA_ERROR;
    }

    if (httpRes.statusCode < 500) {
        return constants.ERROR_ROOT_CAUSE.BUSINESS_ERROR;
    }

    return constants.ERROR_ROOT_CAUSE.UNKNOWN_ERROR;
}

const DB_INSERT_EXISTING_RECORD_ERROR = "Trying to insert into existing record";

module.exports = {
    createOpenDSUErrorWrapper,
    reportUserRelevantError,
    reportUserRelevantWarning,
    reportUserRelevantInfo,
    reportDevRelevantInfo,
    observeUserRelevantMessages,
    unobserveUserRelevantMessages,
    OpenDSUSafeCallback,
    registerMandatoryCallback,
    printOpenDSUError,
    DB_INSERT_EXISTING_RECORD_ERROR,
    httpToRootCauseErrorCode
}

},{"../moduleConstants":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/moduleConstants.js","./../utils/observable":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/utils/observable.js"}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/http/browser/index.js":[function(require,module,exports){
const {createOpenDSUErrorWrapper, httpToRootCauseErrorCode} = require("../../error");

function callGlobalHandler(res){
	if($$.httpUnknownResponseGlobalHandler){
		$$.httpUnknownResponseGlobalHandler(res);
	}
}

function generateMethodForRequestWithData(httpMethod) {
	return function (url, data, options, callback) {
		if(typeof options === "function"){
			callback = options;
			options = {};
		}

		const xhr = new XMLHttpRequest();

		xhr.onload = function () {
			if (xhr.readyState === 4 && (xhr.status >= 200 && xhr.status < 300)) {
				const data = xhr.response;
				callback(undefined, data);
			} else {
				if(xhr.status >= 400){
					const error = new Error("An error occured. StatusCode: " + xhr.status);
					callback({error: error, statusCode: xhr.status});
				} else {
					if(xhr.status >= 300 && xhr.status < 400){
						callGlobalHandler(xhr);
					}else{
						console.log(`Status code ${xhr.status} received, response is ignored.`);
					}
				}
			}
		};

		xhr.onerror = function () {
			callback(new Error("A network error occurred"));
		};

		xhr.open(httpMethod, url, true);
		//xhr.setRequestHeader("Content-Type", "application/json;charset=UTF-8");
		if(typeof options.headers !== "undefined"){
			for(let name in options.headers){
				xhr.setRequestHeader(name, options.headers[name]);
			}
		}

		if(data && data.pipe && typeof data.pipe === "function"){
			const buffers = [];
			data.on("data", function(data) {
				buffers.push(data);
			});
			data.on("end", function() {
				const actualContents = $$.Buffer.concat(buffers);
				xhr.send(actualContents);
			});
		}
		else {
			if(ArrayBuffer.isView(data) || data instanceof ArrayBuffer) {
				xhr.setRequestHeader('Content-Type', 'application/octet-stream');

				/**
				 * Content-Length is an unsafe header and we cannot set it.
				 * When browser is making a request that is intercepted by a service worker,
				 * the Content-Length header is not set implicitly.
				 */
				xhr.setRequestHeader('X-Content-Length', data.byteLength);
			}
			xhr.send(data);
		}
	};
}

function customFetch(...args){
	return fetch(...args).then(res=>{
		if(res.status >= 300 && res.status < 400){
			callGlobalHandler(res);
		}
		if(res.status === 404){
			let error = new Error(`Request Failed.\n Status Code: ${res.status}\n`);
			error.statusCode = res.status;
			error = createOpenDSUErrorWrapper("HTTP request failed", error, httpToRootCauseErrorCode(error));
			throw error;
		}
		return res;
	}).catch(err=>{
		const constants = require("../../moduleConstants");
		if(err.rootCause) {
			throw err;
		}
        err = createOpenDSUErrorWrapper(err.message, err, constants.ERROR_ROOT_CAUSE.NETWORK_ERROR);
		callGlobalHandler({err});
		throw err;
	});
}

function doGet(url, options, callback){
	if (typeof options === "function") {
		callback = options;
		options = {};
	}

	if(!options){
		options = {};
	}

	if (!options.credential) {
		options.credential = "include";
	}

    customFetch(url, options)
	.then(response => response.text())
	.then(data => callback(undefined, data))
	.catch(err => callback(err));
}

module.exports = {
	fetch: customFetch,
	doPost: generateMethodForRequestWithData('POST'),
	doPut: generateMethodForRequestWithData('PUT'),
	doGet
}
},{"../../error":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/error/index.js","../../moduleConstants":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/moduleConstants.js"}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/http/index.js":[function(require,module,exports){
/**
 * http API space
 */
const or = require('overwrite-require');

switch ($$.environmentType) {
    case or.constants.BROWSER_ENVIRONMENT_TYPE:
        module.exports = require("./browser");
        break;
    case or.constants.WEB_WORKER_ENVIRONMENT_TYPE:
    case or.constants.SERVICE_WORKER_ENVIRONMENT_TYPE:
        module.exports = require("./serviceWorker");
        break;
    default:
        module.exports = require("./node");
        const interceptor = (data, callback) => {
            let {url, headers} = data;
            if (!process.env.SSO_SECRETS_ENCRYPTION_KEY) {
                return callback(undefined, {url, headers});
            }
            if (!headers) {
                headers = {};
            }

            if (!headers["x-api-key"]) {
                headers["x-api-key"] = process.env.SSO_SECRETS_ENCRYPTION_KEY;
            }
            callback(undefined, {url, headers});
        }
        require("./utils/interceptors").enable(module.exports);
        module.exports.registerInterceptor(interceptor);
}

//enable support for http interceptors.
require("./utils/interceptors").enable(module.exports);

const PollRequestManager = require("./utils/PollRequestManager");
const rm = new PollRequestManager(module.exports.fetch);

module.exports.poll = function (url, options, connectionTimeout, delayStart) {
    connectionTimeout = connectionTimeout || 10000;
    rm.setConnectionTimeout(connectionTimeout);
    const request = rm.createRequest(url, options, delayStart);
    return request;
};

module.exports.unpoll = function (request) {
    rm.cancelRequest(request);
}

},{"./browser":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/http/browser/index.js","./node":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/http/node/index.js","./serviceWorker":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/http/serviceWorker/index.js","./utils/PollRequestManager":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/http/utils/PollRequestManager.js","./utils/interceptors":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/http/utils/interceptors.js","overwrite-require":"overwrite-require"}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/http/node/common.js":[function(require,module,exports){
const userAgent = 'PSK NodeAgent/0.0.1';
const signatureHeaderName = process.env.vmq_signature_header_name || "x-signature";

function getNetworkForOptions(options) {
	const httpModuleName = "http";
	const http = require(httpModuleName);
	const https = require(httpModuleName + "s");

	let network;
	switch (options.protocol) {
		case "http:":
			network = http;
			break;
		case "https:":
			network = https;
			break;
		default:
			throw new Error(`Can't handle protocol ${options.protocol}`);
	}

	return network;
}

function buildOptions(url, method, opts){
	const urlModuleName = "url";
	const URL = require(urlModuleName);
	const innerUrl = URL.parse(url);

	const options = {
		hostname: innerUrl.hostname,
		path: innerUrl.pathname,
		protocol: innerUrl.protocol,
		port: parseInt(innerUrl.port),
		headers: {
			'User-Agent': userAgent,
			[signatureHeaderName]: 'replaceThisPlaceholderSignature'
		},
		method
	};

	//if no port is specified we need to set the default ones
	if(!options.port){
		options.port = innerUrl.protocol === "http:" ? 80 : 443
	}

	if(opts){
		if(opts.useProxy){
			let proxy = URL.parse(opts.useProxy);
			//setting proxy hostname
			options.hostname = proxy.hostname;

			//setting proxy port
			if(Number.isNaN(proxy.port)){
				options.port = proxy.protocol === "http:" ? 80 : 443;
			}else{
				options.port = proxy.port;
			}

			//updating the path
			options.path = url;
		}

		for(let name in opts.headers){
			options.headers[name] = opts.headers[name];
		}
	}

	return options;
}

function setContentTypeByData(options, data){
	if(typeof data === "undefined"){
		return;
	}
	if (ArrayBuffer.isView(data) || $$.Buffer.isBuffer(data) || data instanceof ArrayBuffer) {
		if (!$$.Buffer.isBuffer(data)) {
			data = $$.Buffer.from(data);
		}

		options.headers['Content-Type'] = 'application/octet-stream';
		options.headers['Content-Length'] = data.length;
	}
}

module.exports = {
	setContentTypeByData,
	buildOptions,
	getNetworkForOptions
}
},{}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/http/node/index.js":[function(require,module,exports){

const {setContentTypeByData,buildOptions,getNetworkForOptions} = require("./common.js");
const {httpToRootCauseErrorCode, createOpenDSUErrorWrapper} = require("../../error");
const constants = require("opendsu").constants;
function generateMethodForRequestWithData(httpMethod) {
	return function (url, data, reqOptions, callback) {
		if(typeof reqOptions === "function"){
			callback = reqOptions;
			reqOptions = {};
		}

		const options = buildOptions(url, httpMethod, reqOptions);
		const network = getNetworkForOptions(options);

		setContentTypeByData(options, data);

		const req = network.request(options, (res) => {
			const {statusCode} = res;

			let error;
			if (statusCode >= 400) {
				error = new Error('Request Failed.\n' +
					`Status Code: ${statusCode}\n` +
					`URL: ${options.hostname}:${options.port}${options.path}`);

				error = createOpenDSUErrorWrapper("HTTP request failed", error, httpToRootCauseErrorCode(res));
			}

			let rawData = '';
			res.on('data', (chunk) => {
				rawData += chunk;
			});
			res.on('end', () => {
                if (error) {
					error = createOpenDSUErrorWrapper(rawData, error, httpToRootCauseErrorCode(res));
					error.statusCode = statusCode;
					callback(error);
                    return;
                }

                callback(undefined, rawData, res.headers);
                //trying to prevent getting ECONNRESET error after getting our response
                // req.abort();
			});
		}).on("error", (error) => {
			const errorWrapper = createOpenDSUErrorWrapper(`Network error`, error, constants.ERROR_ROOT_CAUSE.NETWORK_ERROR);
			console.log(`[${httpMethod}] ${url}`, errorWrapper);
			callback(errorWrapper);
		})

		if (data && data.pipe && typeof data.pipe === "function") {
			data.pipe(req);
			return;
		}

		if (typeof data !== 'string' && !$$.Buffer.isBuffer(data) && !ArrayBuffer.isView(data)) {
			data = JSON.stringify(data);
		}

		if(data){
			req.write(data);
		}
		req.end();
	};
}

function doGet(url, options, callback) {
	let fnc = generateMethodForRequestWithData('GET');
	return fnc(url, undefined, options, callback);
}
module.exports = {
	fetch,
	doGet,
	doPost: generateMethodForRequestWithData('POST'),
	doPut: generateMethodForRequestWithData('PUT')
}

},{"../../error":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/error/index.js","./common.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/http/node/common.js","opendsu":"opendsu"}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/http/serviceWorker/index.js":[function(require,module,exports){
function generateMethodForRequestWithData(httpMethod) {
	return function (url, data, options, callback) {
		if(typeof options === "function"){
			callback = options;
			options = {};
		}
		const headers = options.headers || {};
		if(ArrayBuffer.isView(data) || data instanceof ArrayBuffer) {
			headers['Content-Type'] = 'application/octet-stream';

			/**
			 * Content-Length is an unsafe header and we cannot set it.
			 * When browser is making a request that is intercepted by a service worker,
			 * the Content-Length header is not set implicitly.
			 */
			headers['X-Content-Length'] = data.byteLength;
		}

		fetch(url, {
			method: httpMethod,
			mode: 'cors',
			headers,
			body: data
		}).then(function (response) {
			if (response.status >= 400) {
				throw new Error(`An error occurred ${response.statusText}`);
			}
			return response.text().catch(() => {
				// This happens when the response is empty
				let emptyResponse = {message: ""}
				return JSON.stringify(emptyResponse);
			});
		}).then(function (data) {
			callback(null, data)
		}).catch(error => {
			callback(error);
		});
	};
}

module.exports = {
	fetch: fetch,
	doPost: generateMethodForRequestWithData('POST'),
	doPut: generateMethodForRequestWithData('PUT'),
	doGet: require("./../browser").doGet
}

},{"./../browser":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/http/browser/index.js"}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/http/utils/PollRequestManager.js":[function(require,module,exports){
function PollRequestManager(fetchFunction,  connectionTimeout = 10000, pollingTimeout = 1000){

	const requests = new Map();

	function Request(url, options, delay = 0) {
		let promiseHandlers = {};
		let currentState = undefined;
		let timeout;
		this.url = url;
		let abortController;
		let previousAbortController;

		this.execute = function() {
			if (typeof AbortController !== "undefined") {
				if (typeof abortController === "undefined") {
					previousAbortController = new AbortController()
				} else {
                    previousAbortController = abortController;
                }
				abortController = new AbortController();
				options.signal = previousAbortController.signal;
			}
			if (!currentState && delay) {
				currentState = new Promise((resolve, reject) => {
					timeout = setTimeout(() => {
						fetchFunction(url, options).then((response) => {
							resolve(response);
						}).catch((err) => {
							reject(err);
						})
					}, delay);
				});
			} else {
				currentState = fetchFunction(url, options);
			}
			return currentState;
		}

		this.cancelExecution = function() {
			clearTimeout(timeout);
			timeout = undefined;
			if(typeof currentState !== "undefined"){
				currentState = undefined;
			}
			promiseHandlers.resolve = (...args) => {console.log("(not important) Resolve called after cancel execution with the following args", ...args)};
			promiseHandlers.reject = (...args) => {console.log("(not important) Reject called after cancel execution with the following args", ...args)};
		}

		this.setExecutor = function(resolve, reject) {
			if(promiseHandlers.resolve){
				return reject(new Error("Request already in progress"));
			}
			promiseHandlers.resolve = resolve;
			promiseHandlers.reject = reject;
		}

		this.resolve = function(...args) {
			promiseHandlers.resolve(...args);
			this.destroy();
			promiseHandlers = {};
		}

		this.reject = function(...args) {
			if(promiseHandlers.reject){
				promiseHandlers.reject(...args);
			}
			this.destroy();
			promiseHandlers = {};
		}

		this.destroy = function(removeFromPool = true) {
			this.cancelExecution();

			if (!removeFromPool) {
				return;
			}

			// Find our identifier
			const requestsEntries = requests.entries()
			let identifier;
			for (const [key, value] of requestsEntries) {
				if (value === this) {
					identifier = key;
					break;
				}
			}

			if (identifier) {
				requests.delete(identifier);
			}
		}

		this.abort = () => {
            if (typeof previousAbortController !== "undefined") {
				previousAbortController.abort();
            }
		}
	}

	this.createRequest = function (url, options, delayedStart = 0) {
		const request = new Request(url, options, delayedStart);

		const promise = new Promise((resolve, reject) => {
			request.setExecutor(resolve, reject);
			createPollingTask(request);
		});
		promise.abort = () => {
			this.cancelRequest(promise);
		};

		requests.set(promise, request);
		return promise;
	};

	this.cancelRequest = function(promiseOfRequest){
		if(typeof promiseOfRequest === "undefined"){
			console.log("No active request found.");
			return;
		}

		const request = requests.get(promiseOfRequest);
		if (request) {
			request.destroy(false);
			requests.delete(promiseOfRequest);
		}
	}

	this.setConnectionTimeout = (_connectionTimeout)=>{
		connectionTimeout = _connectionTimeout;
	}

	/* *************************** polling zone ****************************/
	function createPollingTask(request) {
		let safePeriodTimeoutHandler;
		let serverResponded = false;
		/**
		 * default connection timeout in api-hub is @connectionTimeout
		 * we wait double the time before aborting the request
		 */
		function beginSafePeriod() {
			safePeriodTimeoutHandler = setTimeout(() => {
				if (!serverResponded) {
					request.abort();
				}
				serverResponded = false;
				beginSafePeriod()
			}, connectionTimeout * 2);
			reArm();
		}

		function endSafePeriod(serverHasResponded) {
			serverResponded = serverHasResponded;

			clearTimeout(safePeriodTimeoutHandler);
		}

		function reArm() {
			request.execute().then( (response) => {
				if (!response.ok) {
					endSafePeriod(true);

					//todo check for http errors like 404
					if (response.status === 403) {
						request.reject(Error("Token expired"));
						return
					}

					if (response.status === 503){
						let err = Error(response.statusText || "Service unavailable");
						err.code = 503;
						throw err;
					}

					return beginSafePeriod();
				}

				if (response.status === 204) {
					endSafePeriod(true);
					beginSafePeriod();
					return;
				}

				if (safePeriodTimeoutHandler) {
					clearTimeout(safePeriodTimeoutHandler);
				}

				request.resolve(response);
			}).catch( (err) => {
				switch (err.code) {
					case "ETIMEDOUT":
					case "ECONNREFUSED":
						endSafePeriod(true);
						beginSafePeriod();
						break;
					case 20:
					case "ERR_NETWORK_IO_SUSPENDED":
					//reproduced when user is idle on ios (chrome).
					case "ERR_INTERNET_DISCONNECTED":
						//indicates a general network failure.
						break;
					default:
						console.log("abnormal error: ", err);
						endSafePeriod(true);
						request.reject(err);
				}
			});

		}

		beginSafePeriod();
	}

}

module.exports = PollRequestManager;

},{}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/http/utils/interceptors.js":[function(require,module,exports){
let interceptors = [];

function registerInterceptor(interceptor){
    if(typeof interceptor !== "function"){
        throw new Error('interceptor argument should be a function');
    }
    //check if the interceptor is already registered
    if(interceptors.indexOf(interceptor) === -1) {
        interceptors.push(interceptor);
    }
}

function unregisterInterceptor(interceptor){
    let index = interceptors.indexOf(interceptor);
    if(index !== -1){
        interceptors.splice(index, 1);
    }
}

function callInterceptors(target, callback){
    let index = -1;
    function executeInterceptor(result){
        index++;
        if(index >= interceptors.length){
            return callback(undefined, result);
        }
        let interceptor = interceptors[index];
        interceptor(target, (err, result)=>{
            if(err){
                return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to execute interceptor`, err));
            }
            return executeInterceptor(result);
        });
    }
    executeInterceptor(target);
}

function setupInterceptors(handler){
    const interceptMethods = [{name: "doPost", position: 2}, {name:"doPut", position: 2}, {name:"doGet", position: 1}];
    interceptMethods.forEach(function(target){
        let method = handler[target.name];
        handler[target.name] = function(...args){
            let headers = {};
            let optionsAvailable = false;
            if(args.length > target.position+1 && ["function", "undefined"].indexOf(typeof args[target.position]) === -1){
                headers = args[target.position]["headers"];
                optionsAvailable = true;
            }

            let data = {url: args[0], headers};
            callInterceptors(data, function(err, result){
                if(optionsAvailable){
                    args[target.position]["headers"] = result.headers;
                }else{
                    args.splice(target.position, 0, {headers: result.headers});
                }

                return method(...args);
            });
        }
    });

    const promisedBasedInterceptors = [{name: "fetch", position: 1}];
    promisedBasedInterceptors.forEach(function(target){
        let method = handler[target.name];
        handler[target.name] = function(...args){
            return new Promise((resolve, reject) => {
                if (args.length === 1) {
                    args.push({headers: {}});
                }

                if (args.length === 2 && typeof args[1] === "undefined") {
                    args[1] = {};
                }

                if(typeof args[1].headers === "undefined"){
                    args[1].headers = {};
                }
                let headers = args[1].headers;

                let data = {url: args[0], headers};
                callInterceptors(data, function(err, result) {

                    let options = args[target.position];
                    options.headers = result.headers;

                    method(...args)
                        .then((...args) => {
                            resolve(...args);
                        })
                        .catch((...args) => {
                            reject(...args);
                        });
                });
            });
        };
    });
}

function enable(handler){
    //exposing working methods
    handler.registerInterceptor = registerInterceptor;
    handler.unregisterInterceptor = unregisterInterceptor;
    //setting up the interception mechanism
    setupInterceptors(handler);
}

module.exports = {enable};
},{}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/keyssi/index.js":[function(require,module,exports){
const keySSIResolver = require("key-ssi-resolver");
const keySSIFactory = keySSIResolver.KeySSIFactory;
const SSITypes = keySSIResolver.SSITypes;
const openDSU = require("opendsu");
const parse = (ssiString, options) => {
    return keySSIFactory.create(ssiString, options);
};

const createSeedSSI = (domain, privateKey, vn, hint, callback) => {
    return we_createSeedSSI(openDSU.loadAPI("sc").getMainEnclave(), domain, privateKey, vn, hint, callback);
};

const isJson = (obj) => {
    if (typeof obj === "object") {
        return true;
    }

    try {
        JSON.parse(obj);
    } catch (e) {
        return false;
    }
    return true;
}

const we_createSeedSSI = (enclave, domain, privateKey, vn, hint, callback) => {
    if (typeof privateKey === "function") {
        callback = privateKey;
        privateKey = undefined;
    }

    if (typeof vn == "function") {
        callback = vn;
        vn = undefined;
    }

    if (typeof hint == "function") {
        callback = hint;
        hint = undefined;
    }

    if (isJson(privateKey)) {
        hint = privateKey;
        privateKey = undefined;
    }

    if (isJson(vn)) {
        hint = vn;
        vn = undefined;
    }

    let seedSSI = keySSIFactory.createType(SSITypes.SEED_SSI);

    if (typeof callback === "function") {
        seedSSI.initialize(domain, privateKey, undefined, vn, hint, (err => {
            if (err) {
                return callback(err);
            }

            if (enclave) {
                enclave.storeKeySSI(seedSSI, (err) => callback(err, seedSSI));
            } else {
                callback(undefined, seedSSI);
            }
        }));
    } else {
        seedSSI.initialize(domain, privateKey, undefined, vn, hint);
    }
    return seedSSI;
};

const buildSeedSSI = function () {
    throw new Error("Obsoleted, use buildTemplateSeedSSI");
}

const buildTemplateSeedSSI = (domain, specificString, control, vn, hint, callback) => {
    console.log("This function is obsolete. Use createTemplateSeedSSI instead.");
    return createTemplateKeySSI(SSITypes.SEED_SSI, domain, specificString, control, vn, hint, callback);
};

const createTemplateSeedSSI = (domain, specificString, control, vn, hint, callback) => {
    return createTemplateKeySSI(SSITypes.SEED_SSI, domain, specificString, control, vn, hint, callback);
};

const we_createPathKeySSI = (enclave, domain, path, vn, hint, callback) => {
    if (typeof vn == "function") {
        callback = vn;
        vn = undefined;
    }

    if (typeof hint == "function") {
        callback = hint;
        hint = undefined;
    }

    let pathKeySSI = keySSIFactory.createType(SSITypes.PATH_SSI, enclave);
    pathKeySSI.load(SSITypes.PATH_SSI, domain, path, '', vn, hint);
    if (typeof callback === "function") {
        return enclave.storeKeySSI(pathKeySSI, err => {
            if (err) {
                return callback(err);
            }

            callback(undefined, pathKeySSI);
        });
    }
    return pathKeySSI;
}

const createPathKeySSI = (domain, path, vn, hint) => {
    return we_createPathKeySSI(openDSU.loadAPI("sc").getMainEnclave(), domain, path, vn, hint);
};

const createHashLinkSSI = (domain, hash, vn, hint) => {
    const hashLinkSSI = keySSIFactory.createType(SSITypes.HASH_LINK_SSI)
    hashLinkSSI.initialize(domain, hash, vn, hint);
    return hashLinkSSI;
};

const createTemplateKeySSI = (ssiType, domain, specificString, control, vn, hint, callback) => {
    //only ssiType and domain are mandatory arguments
    if (typeof specificString === "function") {
        callback = specificString;
        specificString = undefined;
    }
    if (typeof control === "function") {
        callback = control;
        control = undefined;
    }
    if (typeof vn === "function") {
        callback = vn;
        specificString = undefined;
    }
    if (typeof hint === "function") {
        callback = hint;
        hint = undefined;
    }
    const keySSI = keySSIFactory.createType(ssiType);
    keySSI.load(ssiType, domain, specificString, control, vn, hint);
    if (typeof callback === "function") {
        callback(undefined, keySSI);
    }
    return keySSI;
};

const buildTemplateWalletSSI = (domain, arrayWIthCredentials, hint) => {
    console.log("This function is obsolete. Use createTemplateWalletSSI instead.");
    try {
        let ssi = createArraySSI(domain, arrayWIthCredentials, undefined, hint);
        ssi.cast(SSITypes.WALLET_SSI);
        return parse(ssi.getIdentifier());
    } catch (err) {
        console.log("Failing to build WalletSSI");
    }
};

const createTemplateWalletSSI = (domain, arrayWIthCredentials, hint) => {
    if (!Array.isArray(arrayWIthCredentials)) {
        arrayWIthCredentials = [arrayWIthCredentials];
    }
    try {
        let ssi = createArraySSI(domain, arrayWIthCredentials, undefined, hint);
        ssi.cast(SSITypes.WALLET_SSI);
        return parse(ssi.getIdentifier());
    } catch (err) {
        console.log("Failing to build WalletSSI");
    }
};

const createConstSSI = (domain, constString, vn, hint) => {
    return we_createConstSSI(openDSU.loadAPI("sc").getMainEnclave(), domain, constString, vn, hint)
};

const we_createConstSSI = (enclave, domain, constString, vn, hint, callback) => {
    const constSSI = keySSIFactory.createType(SSITypes.CONST_SSI);
    constSSI.initialize(domain, constString, vn, hint);
    if (typeof callback === "function") {
        callback(undefined, constSSI);
    }
    return constSSI;
};

const createArraySSI = (domain, arr, vn, hint, callback) => {
    return we_createArraySSI(openDSU.loadAPI("sc").getMainEnclave(), domain, arr, vn, hint, callback);
}

const we_createArraySSI = (enclave, domain, arr, vn, hint, callback) => {
    const arraySSI = keySSIFactory.createType(SSITypes.ARRAY_SSI);
    arraySSI.initialize(domain, arr, vn, hint);
    if (typeof callback === "function") {
        callback(undefined, arraySSI);
    }
    return arraySSI;
};

const buildSymmetricalEncryptionSSI = (domain, encryptionKey, control, vn, hint, callback) => {
    console.log("This function is obsolete. Use createTemplateSymmetricalEncryptionSSI instead.");
    return createTemplateKeySSI(SSITypes.SYMMETRICAL_ENCRYPTION_SSI, domain, encryptionKey, control, vn, hint, callback);
};

const createTemplateSymmetricalEncryptionSSI = (domain, encryptionKey, control, vn, hint, callback) => {
    return createTemplateKeySSI(SSITypes.SYMMETRICAL_ENCRYPTION_SSI, domain, encryptionKey, control, vn, hint, callback);
};

const createToken = (domain, amountOrSerialNumber, vn, hint, callback) => {
    if (typeof vn === "function") {
        callback = vn;
        vn = undefined;
        hint = undefined
    }

    if (typeof hint === "function") {
        callback = hint;
        hint = undefined
    }
    // the tokenSSI is closely linked with an ownershipSSI
    // the tokenSSI must have the ownershipSSI's public key hash
    // the ownershipSSI must have the tokenSSI's base58 ssi
    const ownershipSSI = keySSIFactory.createType(SSITypes.OWNERSHIP_SSI);
    ownershipSSI.initialize(domain, undefined, undefined, vn, hint, () => {

        const ownershipPublicKeyHash = ownershipSSI.getPublicKeyHash();
        const ownershipPrivateKey = ownershipSSI.getPrivateKey();

        const tokenSSI = keySSIFactory.createType(SSITypes.TOKEN_SSI);
        tokenSSI.initialize(domain, amountOrSerialNumber, ownershipPublicKeyHash, vn, hint);

        // update ownershipSSI to set level and token
        const ownershipLevelAndToken = `0/${tokenSSI.getIdentifier()}`;
        ownershipSSI.load(SSITypes.OWNERSHIP_SSI, domain, ownershipPrivateKey, ownershipLevelAndToken, vn, hint);

        // create a TRANSFER_SSI, since the token's ownership is first transfered to the owner itself
        const transferTimestamp = new Date().getTime();

        // get signature by sign(lastEntryInAnchor, transferTimestamp, ownershipPublicKeyHash)
        const transferDataToSign = `${transferTimestamp}${ownershipPublicKeyHash}`;
        ownershipSSI.sign(transferDataToSign, (err, signature) => {
            if (err) {
                return callback(createOpenDSUErrorWrapper("Failed to signed transfer data", err));
            }

            let transferSSI = createTransferSSI(domain, ownershipPublicKeyHash, transferTimestamp, signature);
            const {createAnchor, appendToAnchor} = require("../anchoring");
            createAnchor(ownershipSSI, (err) => {
                if (err) {
                    return callback(createOpenDSUErrorWrapper("Failed to anchor ownershipSSI", err));
                }

                appendToAnchor(ownershipSSI, transferSSI, (err) => {
                    if (err) {
                        return callback(createOpenDSUErrorWrapper("Failed to anchor transferSSI", err));
                    }

                    const result = {
                        tokenSSI: tokenSSI,
                        ownershipSSI: ownershipSSI,
                        transferSSI: transferSSI
                    }

                    callback(undefined, result);
                });
            });
        });
    });
};

const createOwnershipSSI = (domain, levelAndToken, vn, hint, callback) => {
    let ownershipSSI = keySSIFactory.createType(SSITypes.OWNERSHIP_SSI);
    ownershipSSI.initialize(domain, undefined, levelAndToken, vn, hint, callback);
    return ownershipSSI;
};

const createTransferSSI = (domain, hashNewPublicKey, timestamp, signatureCurrentOwner, vn, hint, callback) => {
    let transferSSI = keySSIFactory.createType(SSITypes.TRANSFER_SSI);
    transferSSI.initialize(domain, hashNewPublicKey, timestamp, signatureCurrentOwner, vn, hint, callback);
    return transferSSI;
};

const createTemplateTransferSSI = (domain, hashNewPublicKey, vn, hint) => {
    let transferSSI = keySSIFactory.createType(SSITypes.TRANSFER_SSI);
    transferSSI.load(domain, hashNewPublicKey, undefined, vn, hint);
    return transferSSI;
};

const createSignedHashLinkSSI = (domain, hashLink, timestamp, signature, vn, hint) => {
    let signedHashLink = keySSIFactory.createType(SSITypes.SIGNED_HASH_LINK_SSI);
    signedHashLink.initialize(domain, hashLink, timestamp, signature, vn, hint);
    return signedHashLink;
};

const createPublicKeySSI = (compatibleFamilyName, publicKey, vn) => {
    let publicKeySSI = keySSIFactory.createType(SSITypes.PUBLIC_KEY_SSI);
    publicKeySSI.initialize(compatibleFamilyName, publicKey, vn);
    return publicKeySSI;
};

const createAliasSSI = (domain, alias, callback) => {
    const aliasSSI = keySSIFactory.createType(SSITypes.ALIAS_SSI);
    aliasSSI.initialize(domain, alias, callback);
    return aliasSSI;
}

const createSizeSSI = (domain, totalSize, bufferSize) => {
    const sizeSSI = keySSIFactory.createType(SSITypes.SIZE_SSI);
    sizeSSI.initialize(domain, totalSize, bufferSize);
    return sizeSSI;
}

const createEmbedSSI = (domain, data) => {
    const embedSSI = keySSIFactory.createType(SSITypes.EMBED_SSI);
    embedSSI.initialize(domain, data);
    return embedSSI;
}

const createVersionlessSSI = (domain, path, encryptionKey, vn, hint) => {
    const versionlessSSI = keySSIFactory.createType(SSITypes.VERSIONLESS_SSI);
    versionlessSSI.initialize(domain, path, encryptionKey, vn, hint);
    return versionlessSSI;
};

module.exports = {
    parse,
    createSeedSSI,
    buildSeedSSI,
    buildTemplateSeedSSI,
    buildTemplateWalletSSI,
    createTemplateSeedSSI,
    createTemplateSymmetricalEncryptionSSI,
    createTemplateWalletSSI,
    createTemplateKeySSI,
    createHashLinkSSI,
    createConstSSI,
    createArraySSI,
    buildSymmetricalEncryptionSSI,
    createToken,
    createOwnershipSSI,
    createTransferSSI,
    createTemplateTransferSSI,
    createSignedHashLinkSSI,
    createPublicKeySSI,
    we_createSeedSSI,
    we_createConstSSI,
    we_createArraySSI,
    createAliasSSI,
    createSizeSSI,
    createPathKeySSI,
    we_createPathKeySSI,
    createEmbedSSI,
    createVersionlessSSI
};

},{"../anchoring":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/anchoring/index.js","key-ssi-resolver":"key-ssi-resolver","opendsu":"opendsu"}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/lock/index.js":[function(require,module,exports){
const constants = require("../moduleConstants").ERROR_ROOT_CAUSE;

function handlePromise(promise, message) {
   return promise.then(res => {
        let rootCause;
        switch (res.status) {
            case 200 :
                return true;
            case 409 :
                return false;
            case 500 :
                rootCause = constants.NETWORK_ERROR;
                break;
            case 404 :
                rootCause = constants.MISSING_DATA_ERROR;
                break;
            case 400 :
                rootCause = constants.BUSINESS_ERROR;
                break;
            default:
                rootCause = constants.UNKNOWN_ERROR;
        }
       let err = new Error(message);
       err.code = res.status;
       err = createOpenDSUErrorWrapper(message, err, rootCause);
       throw err;
    }).catch(err => {
        if (err.rootCause) {
            throw err;
        }
        throw createOpenDSUErrorWrapper(message, err, constants.NETWORK_ERROR);
    });
}

function lockAsync(id, secret, period) {
    const originUrl = require("../bdns").getOriginUrl();
    const http = require("../http");

    return handlePromise(http.fetch(`${originUrl}/lock?id=${id}&secret=${secret}&period=${period}`), "Failed to acquire lock");
}

function unlockAsync(id, secret) {
    const originUrl = require("../bdns").getOriginUrl();
    const http = require("../http");
    return handlePromise(http.fetch(`${originUrl}/unlock?id=${id}&secret=${secret}`), "Failed to unlock");
}

let exposed = {lockAsync, unlockAsync};
exposed.lock = function (id, secret, period, callback) {
    callback = $$.makeSaneCallback(callback);
    lockAsync(id, secret, period).then(callback).catch(callback);
};

exposed.unlock = function (id, secret, callback) {
    callback = $$.makeSaneCallback(callback);
    unlockAsync(id, secret).then(callback).catch(callback);
};
module.exports = exposed;

},{"../bdns":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/bdns/index.js","../http":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/http/index.js","../moduleConstants":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/moduleConstants.js"}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/m2dsu/apisRegistry.js":[function(require,module,exports){
const apis = {};
function defineApi(name, implementation){
	if(typeof implementation !== "function"){
		throw Error("second argument of the defineApi should be a function that will represent the implementation for that api");
	}
	apis[name] = implementation;
}

function getApis(){
	return apis;
}

module.exports = {defineApi, getApis}
},{}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/m2dsu/defaultApis/index.js":[function(require,module,exports){
const registry = require("../apisRegistry");

/*
* based on jsonIndications Object {attributeName1: "DSU_file_path", attributeName2: "DSU_file_path"}
* the this of the mapping will be populated with the data extracted from the DSU
* */
registry.defineApi("loadJSONS", async function (dsu, jsonIndications) {
    for (let prop in jsonIndications) {
        try {
            let data;
            data = await dsu.readFile(jsonIndications[prop]);
            this[prop] = JSON.parse(data);
        } catch (e) {
            console.log("Failed to load JSON due to ", e.message);
        }
    }
});

/*
* based on jsonIndications Object {attributeName1: "DSU_file_path", attributeName2: "DSU_file_path"}
* the data from the this of the mapping will be saved into the DSU
* */
registry.defineApi("saveJSONS", async function (dsu, jsonIndications) {
    for (let prop in jsonIndications) {
        let data = JSON.stringify(this[prop]);
        await dsu.writeFile(jsonIndications[prop], data);
    }
});

function promisifyDSUAPIs(dsu) {
    //this API method list will be promisify on the fly with the help of the registerDSU method and a Proxy over DSU instance
    const promisifyAPIs = [
        "addFile",
        "addFiles",
        "addFolder",
        "appendToFile",
        "batch",
        "beginBatch",
        "cancelBatch",
        "cloneFolder",
        "createFolder",
        "delete",
        "dsuLog",
        "extractFile",
        "extractFolder",
        "getKeySSI",
        "getKeySSIAsObject",
        "getKeySSIAsString",
        "getSSIForMount",
        "init",
        "listFiles",
        "listFolders",
        "listMountedDossiers",
        "load",
        "mount",
        "readDir",
        "readFile",
        "rename",
        "stat",
        "unmount",
        "writeFile",
        "listMountedDSUs",
        "refresh"
    ];

    const promisifyHandler = {
        get: function (target, prop) {
            if (promisifyAPIs.indexOf(prop) !== -1) {
                return $$.promisify(target[prop]);
            }
            return target[prop];
        }
    };

    //we create a proxy over the normal DSU / Archive instance
    //in order to promisify on the fly the public API to be easier to work with in the mapping functions
    return new Proxy(dsu, promisifyHandler);
}

//all DSUs that are created with different exposed APIs need to be registered
// in order to control the batch operations and promisify the API on them
async function registerDSU(mappingInstance, dsu) {
    if (typeof dsu === "undefined" || typeof dsu.beginBatch !== "function") {
        throw Error("registerDSU needs a DSU instance");
    }
    if (typeof mappingInstance.registeredDSUs === "undefined") {
        mappingInstance.registeredDSUs = [];
    }

    if(dsu.batchInProgress()){
        $$.debug.logDSUEvent(dsu, `Already in batch mode in active mapping execution`);
        return promisifyDSUAPIs(dsu);
    }
    let batchId;
    const keySSI = await dsu.getKeySSIAsObjectAsync();
    const openDSU = require("opendsu");
    const SSITypes = openDSU.constants.KEY_SSI_FAMILIES;
    const resolver = openDSU.loadAPI("resolver");
    if(keySSI.getFamilyName() === SSITypes.CONST_SSI_FAMILY){
        $$.debug.logDSUEvent(dsu, `Const DSU in active mapping execution`);
        const dsuExists = await $$.promisify(resolver.dsuExists)(keySSI);
        if(dsuExists){
            $$.debug.logDSUEvent(dsu, `Const DSU already exists in active mapping execution`);
            return promisifyDSUAPIs(dsu);
        }
        batchId = await dsu.startOrAttachBatchAsync();
        dsu.secretBatchId = batchId;
        mappingInstance.registeredDSUs.push(dsu);
        return promisifyDSUAPIs(dsu);
    }
    batchId = await dsu.startOrAttachBatchAsync();
    dsu.secretBatchId = batchId;
    mappingInstance.registeredDSUs.push(dsu);
    return promisifyDSUAPIs(dsu);
}

registry.defineApi("testIfDSUExists", async function(keySSI, callback){
    const keySSISpace = require("opendsu").loadApi("keyssi");
    const anchoringX = require("opendsu").loadApi("anchoring").getAnchoringX();
    if(typeof keySSI !== "object"){
        keySSI = keySSISpace.parse(keySSI);
    }
    let anchorId = await $$.promisify(keySSI.getAnchorId)();
    let alreadyExists = false;
    let error;
    try{
        let versions = await $$.promisify(anchoringX.getAllVersions)(anchorId);
        if(versions && versions.length > 0){
            alreadyExists = true;
        }
    }catch(err){
        error = err;
    }
    return callback(error, alreadyExists);
});

registry.defineApi("loadConstSSIDSU", async function (constSSI, options) {

    let dsu = await $$.weakDSUCache.get(constSSI);
    const resolver = await this.getResolver();
    if(!dsu){
        let exists = await $$.promisify(this.testIfDSUExists)(constSSI);
        try {
            dsu = await resolver.loadDSU(constSSI);
        } catch (e) {
            if(exists){
                throw createOpenDSUErrorWrapper("Failed to load Const DSU that exists", e);
            }
        }
    }

    if (dsu) {
        //take note that this.registerDSU returns a Proxy Object over the DSU and this Proxy we need to return also
        return {dsu: await registerDSU(this, dsu), alreadyExists: true};
    }

    dsu = await resolver.createDSUForExistingSSI(constSSI, options);

    //take note that this.registerDSU returns a Proxy Object over the DSU and this Proxy we need to return also
    return {dsu: await registerDSU(this, dsu), alreadyExists: false};
});

registry.defineApi("loadArraySSIDSU", async function (domain, arr) {
    const opendsu = require("opendsu");
    const resolver = await this.getResolver();
    const keySSISpace = opendsu.loadApi("keyssi");

    const keySSI = keySSISpace.createArraySSI(domain, arr);

    let dsu = await $$.weakDSUCache.get(keySSI);
    let exists = await $$.promisify(this.testIfDSUExists)(keySSI);

    if(dsu){
        return {dsu: await registerDSU(this, dsu), alreadyExists: exists};
    }

    try {
        dsu = await resolver.loadDSU(keySSI);
    } catch (e) {
        if (exists) {
            throw createOpenDSUErrorWrapper("Failed to load ConstDSU that exists", e);
        }
    }

    if (dsu) {
        //take note that this.registerDSU returns a Proxy Object over the DSU and this Proxy we need to return also
        return {dsu: await registerDSU(this, dsu), alreadyExists: true};
    }

    dsu = await resolver.createArrayDSU(domain, arr);
    //take note that this.registerDSU returns a Proxy Object over the DSU and this Proxy we need to return also
    return {dsu: await registerDSU(this, dsu), alreadyExists: false};
});

registry.defineApi("createDSU", async function (domain, ssiType, options) {
    const template = require("opendsu").loadApi("keyssi").createTemplateKeySSI(ssiType, domain);
    let resolver = await this.getResolver();
    if(!options){
        options = {};
    }
    options.addLog = false;
    let dsu = await resolver.createDSU(template, options);
    //take note that this.registerDSU returns a Proxy Object over the DSU and this Proxy we need to return also
    return await registerDSU(this, dsu);
});

registry.defineApi("createPathSSI", async function (domain, path) {
    const scAPI = require("opendsu").loadAPI("sc");
    let enclave;
    try{
        enclave = await $$.promisify(scAPI.getSharedEnclave)();
    }catch (e) {
        enclave = await $$.promisify(scAPI.getMainEnclave)();
    }
    const pathKeySSI = await $$.promisify(enclave.createPathKeySSI)(domain, path);
    const seedSSI = await $$.promisify(pathKeySSI.derive)();

    return seedSSI;
});

registry.defineApi("createPathSSIDSU", async function (domain, path, options) {
    const seedSSI = await this.createPathSSI(domain, path, options);

    let resolver = await this.getResolver();
    if(await $$.promisify(this.testIfDSUExists)(seedSSI)){
        throw createOpenDSUErrorWrapper("PathSSIDSU already exists");
    }
    if(!options){
        options = {};
    }
    options.addLog = false;
    let dsu = await resolver.createDSUForExistingSSI(seedSSI, options);
    //take note that this.registerDSU returns a Proxy Object over the DSU and this Proxy we need to return also
    return await registerDSU(this, dsu);
});

registry.defineApi("loadDSU", async function (keySSI, options) {
    let dsu = await $$.weakDSUCache.get(keySSI);
    if(!dsu){
        let resolver = await this.getResolver();
        dsu = await resolver.loadDSU(keySSI, options);
        if (!dsu) {
            throw new Error("No DSU found for " + keySSI);
        }
    }

    //take note that this.registerDSU returns a Proxy Object over the DSU and this Proxy we need to return also
    return await registerDSU(this, dsu);
});


//an api that returns an OpenDSU Resolver instance that has promisified methods
// to be used in mappings easier
registry.defineApi("getResolver", function (domain, ssiType, options) {
    return new Promise((resolve, reject) => {

        const resolverInherited = ["createDSUx",
            "createSeedDSU",
            "createArrayDSU",
            "createDSUForExistingSSI"];

        const promisify = ["createDSU", "loadDSU"];

        const scApi = require("opendsu").loadApi("sc");
        scApi.getSharedEnclave((err, sharedEnclave) => {
            const defaultResolver = require("opendsu").loadApi("resolver");
            let resolver = defaultResolver;
            if (err) {
                console.log("SharedEnclave not available. Fallback to standard resolver.");
            } else {
                resolver = sharedEnclave;
            }

            const instance = {};
            instance.__proto__ = resolver;

            for (let i = 0; i < promisify.length; i++) {
                let methodName = promisify[i];
                if(methodName==="loadDSU"){
                    instance[methodName] = async function(keySSI, ...args){
                        let instance = await $$.weakDSUCache.get(keySSI);
                        if(instance){
                            return instance;
                        }
                        return await $$.promisify(resolver[methodName])(keySSI, ...args);
                    }
                }else{
                    instance[methodName] = $$.promisify(resolver[methodName]);
                }
            }

            for (let i = 0; i < resolverInherited.length; i++) {
                let methodName = resolverInherited[i];
                instance[methodName] = $$.promisify(defaultResolver[methodName]);
            }


            resolve(instance);
        });
    });

});


registry.defineApi("recoverDSU", function (ssi, recoveryFnc, callback) {
    if(!this.storageService.loadDSURecoveryMode){
        return callback(new Error("Not able to run recovery mode due to misconfiguration of mapping engine."));
    }

    this.storageService.loadDSURecoveryMode(ssi, async (dsu, callback)=>{
        //because in the recoveryFnc the content get "recovered" we need to control the batch for those operations
        let batchId = await dsu.startOrAttachBatchAsync();
        recoveryFnc(dsu, async(err, dsu)=>{
            if(err) {
                return callback(err);
            }
            dsu.commitBatch(batchId, (err)=>{
                if(err){
                    return callback(err);
                }
                return callback(err, dsu);
            });
        });
    }, async (err, dsu)=>{
        if(err){
            return callback(err);
        }

        let registeredDSU = await registerDSU(this, dsu);
        setTimeout(()=>{
            callback(undefined, registeredDSU);
        }, 3000);
        return;
    });
});


},{"../apisRegistry":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/m2dsu/apisRegistry.js","opendsu":"opendsu"}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/m2dsu/defaultMappings/index.js":[function(require,module,exports){
const mappingRegistry = require("./../mappingRegistry.js");

async function validateMessage(message){
	return !!(message.messageType === "standard");
}

async function digestMessage(message){
	throw Error("Not implemented yet!");
}

mappingRegistry.defineMapping(validateMessage, digestMessage);
},{"./../mappingRegistry.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/m2dsu/mappingRegistry.js"}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/m2dsu/errorsMap.js":[function(require,module,exports){
const errorTypes = {
  "UNKNOWN": {
    errorCode: 0,
    message: "Unknown error",
    getDetails: function (data) {
      return [{
        errorType: this.errorCode,
        errorMessage: this.message,
        errorDetails: data,
        errorField: data.errorField || "unknown"
      }]
    }
  },
  "INVALID_MESSAGE_FORMAT": {
    errorCode: 1,
    message: "Invalid message format",
    getDetails: function (data) {
      return data.map(item => {
        return {
          errorType: this.errorCode,
          errorMessage: this.message,
          errorDetails: `${item.field} - ${item.message}`,
          errorField: item.field
        }
      })
    }
  },
  "DB_OPERATION_FAIL": {
    errorCode: 2,
    message: "Database operation failed",
    getDetails: function (data) {
      return [
        {
          errorType: this.errorCode,
          errorMessage: this.message,
          errorDetails: "Missing from the wallet database or database is corrupted",
          errorField: data
        }
      ]
    }
  },
  "MESSAGE_IS_NOT_AN_OBJECT": {
    errorCode: 3,
    message: "Message is not an Object",
    getDetails: function (data) {
      return data.map(item => {
        return {
          errorType: this.errorCode,
          errorMessage: this.message,
          errorDetails: item.errorDetails,
          errorField: data.errorField || "unknown"
        }
      })
    }
  },
  "DIGESTING_MESSAGES": {
    errorCode: 4,
    message: "Mapping Engine is digesting messages for the moment",
    getDetails: function (data) {
      return [{
        errorType: this.errorCode,
        errorMessage: this.message,
        errorDetails: data.errorDetails || "",
        errorField: data.errorField || "unknown"
      }]
    }
  },
  "MISSING_MAPPING": {
    errorCode: 5,
    message: "Not able to digest message due to missing mapping",
    getDetails: function (data) {
      return data.map(item => {
        return {
          errorType: this.errorCode,
          errorMessage: this.message,
          errorDetails: item.errorDetails,
          errorField: data.errorField || "messageType"
        }
      })
    }
  },
  "MAPPING_ERROR": {
    errorCode: 6,
    message: "Caught error during mapping",
    getDetails: function (data) {
      return [{
        errorType: this.errorCode,
        errorMessage: this.message,
        errorDetails: data.errorDetails || "",
        errorField: data.errorField || "unknown"
      }]
    }
  }
}

function getErrorCodes() {
  let errCodes = Object.values(errorTypes).map(item => {
    return item.errorCode
  });
  return errCodes;
}

function getErrorKeyByCode(errCode) {
  try {
    let errObj = Object.values(errorTypes).find(item => item.errorCode === errCode)
    if (errObj) {
      return errObj;
    }
  } catch (e) {

  }

  return errorTypes.UNKNOWN
}

function getErrorKeyByMessage(errMessage) {
  try {
    let errObj = Object.values(errorTypes).find(item => item.message === errMessage);
    if (errObj) {
      return errObj
    }
  } catch (e) {
    console.log('Could not find mapping for ', errMessage);
  }

  return errorTypes.UNKNOWN.getDetails(errMessage)
}

function newCustomError(errorObj, detailsObj) {
  let details = errorObj.getDetails(detailsObj);
  let reason = "Check error logs";
  try{
    reason = JSON.stringify(details);
  }catch(err){

  }
  return {
    originalMessage: errorObj.message,
    message: errorObj.message,
    reason: reason,
    otherErrors: {
      code: errorObj.errorCode,
      details
    }
  };
}

function addNewErrorType(key, code, message, detailsFn) {
  errorTypes[key] = {
    errorCode: code,
    message: message,
    getDetails: detailsFn || function (data) {
      return [{
        errorType: this.errorCode,
        errorMessage: this.message,
        errorDetails: "",
        errorField: data || "unknown"
      }]
    }
  }

}

function setErrorMessage(key, message) {
  errorTypes[key].message = message;
}

module.exports = {
  errorTypes,
  newCustomError,
  getErrorKeyByCode,
  getErrorKeyByMessage,
  setErrorMessage,
  addNewErrorType,
  getErrorCodes
}

},{}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/m2dsu/index.js":[function(require,module,exports){
const mappingRegistry = require("./mappingRegistry.js");
const apisRegistry = require("./apisRegistry.js");
const errMap = require("./errorsMap.js")

//loading defaultApis
require("./defaultApis");

//loading defaultMappings
require("./defaultMappings");

function MappingEngine(storageService, options) {
  if (typeof storageService === "undefined"
    || typeof storageService.beginBatch !== "function"
    || typeof storageService.commitBatch !== "function"
    || typeof storageService.cancelBatch !== "function"
    || typeof storageService.getUniqueIdAsync !== "function"
    || typeof storageService.refresh !== "function"
    || typeof storageService.batchInProgress !== "function") {
    throw Error("The MappingEngine requires a storage service that exposes beginBatch, commitBatch, cancelBatch, getUniqueIdAsync, refresh apis!");
  }

  const errorHandler = require("opendsu").loadApi("error");

  //the purpose of the method is to create a "this" instance to be used during a message mapping process
  function buildMappingInstance() {
    let instance = {storageService, options};

    let recoveryMode = false;
    instance.setRecovery = function(value){
      recoveryMode = !!value;
    }

    instance.isRecoveryActive = function(){
      return recoveryMode;
    }

    const apis = apisRegistry.getApis();

    //we inject all the registered apis on the instance that will become the "this" for a mapping
    for (let prop in apis) {
      if (typeof instance[prop] !== "undefined") {
        console.log(`Take note that an overwriting processing is in place for the api named ${prop}.`);
      }
      instance[prop] = (...args) => {
        return apis[prop].call(instance, ...args);
      }
    }

    return instance;
  }

  async function getMappingFunction(message) {
    const knownMappings = mappingRegistry.getMappings();

    for (let i = 0; i < knownMappings.length; i++) {
      let mapping = knownMappings[i];
      let {matchFunction, mappingFunction} = mapping;
      let applyMapping = await matchFunction(message);

      if (applyMapping) {
        return mappingFunction;
      }
    }
  }

  function commitMapping(mappingInstance) {
    let touchedDSUs = mappingInstance.registeredDSUs;
    $$.debug.log(`Start commit mapping....`);
    return new Promise((resolve, reject) => {
      if (!touchedDSUs || touchedDSUs.length === 0) {
        return resolve(true);
      }
      //if all good until this point, we need to commit any registeredDSU during the message mapping
      const commitPromises = [];
      // const conflictResolutionFn = function (...args) {
      //   console.log("merge conflicts", ...args);
      // }
      for(let i= touchedDSUs.length-1; i>=0; i--){
        const commitBatch = $$.promisify(touchedDSUs[i].commitBatch);
        commitPromises.push(commitBatch(touchedDSUs[i].secretBatchID));
      }

      Promise.all(commitPromises)
        .then(async results => {
          $$.debug.log(`Commit was done, evaluating each commit status....`);
            for (let i = 0; i < results.length; i++) {
              let result = results[i];
              if (result && result.status === "rejected") {
                await $$.promisify(touchedDSUs[i].cancelBatch)(touchedDSUs[i].secretBatchID);
                let getDSUIdentifier = $$.promisify(touchedDSUs[i].getKeySSIAsString);
                return reject(errorHandler.createOpenDSUErrorWrapper(`Cancel batch on dsu identified with ${await getDSUIdentifier()}`));
              }
            }

            touchedDSUs = [];
            resolve(true);
          }
        ).catch(err => {
          touchedDSUs = [];
         return reject(errorHandler.createOpenDSUErrorWrapper(`Caught error during commit batch on registered DSUs`, err));
      });
    });
  }

  function executeMappingFor(message, groupInstance) {
    return new Promise(async (resolve, reject) => {

      const mappingFnc = await getMappingFunction(message);
      if (mappingFnc) {
        const instance = buildMappingInstance();
        instance.groupInstance = groupInstance;
        try {
          instance.setRecovery(message.force);
          await mappingFnc.call(instance, message);
        } catch (err) {
          //we need to return the list of touched DSUs for partial rollback procedure
          err.mappingInstance = {registeredDSUs: instance.registeredDSUs};
          return reject(err);
        }
        return resolve({registeredDSUs: instance.registeredDSUs});
      } else {
        let messageString = JSON.stringify(message);
        const maxDisplayLength = 1024;
        console.log(`Unable to find a suitable mapping to handle the following message: ${messageString.length < maxDisplayLength ? messageString : messageString.slice(0, maxDisplayLength) + "..."}`);
        return reject(errMap.newCustomError(errMap.errorTypes.MISSING_MAPPING, [{
          errorField: "messageType",
          errorDetails: `Couldn't find any mapping for ${message.messageType}`
        }]));
      }
    });
  }

  async function acquireLock(period, attempts, timeout){
    let identifier = await storageService.getUniqueIdAsync();

    const opendsu = require("opendsu");
    const utils = opendsu.loadApi("utils");
    const lockApi = opendsu.loadApi("lock");
    const crypto = opendsu.loadApi("crypto");
    let secret = crypto.encodeBase58(crypto.generateRandom(32));

    let lockAcquired;
    let noAttempts = attempts;
    while(noAttempts>0){
        noAttempts--;
        console.log("Preparing to Enclave acquire lock on", identifier, "attempt number", noAttempts);
        lockAcquired = await lockApi.lockAsync(identifier, secret, period);
        console.log("Enclave Lock acquiring status", lockAcquired);
        if(!lockAcquired){
          console.log("sleep for", timeout);
          await utils.sleepAsync(timeout);
        }else{
          console.log("Enclave Lock acquired... continue");
          break;
        }
      if(noAttempts === 0){
        if (window && window.confirm("Other user is editing right now. Do you want to wait for him to finish?")) {
          noAttempts = attempts;
        }
      }
    }
    if (!lockAcquired) {
      secret = undefined;
    }

    if(secret){
      $$.debug.log('Acquiring Lock on Shared Enclave');
    }
    return secret;
  }

  async function releaseLock(secret){
    let identifier = await storageService.getUniqueIdAsync();

    const opendsu = require("opendsu");
    const lockApi = opendsu.loadApi("lock");
    try{
      await lockApi.unlockAsync(identifier, secret);
      console.log("Enclave lock released");
      $$.debug.log('Releasing Lock on Shared Enclave');
    }catch(err){
      console.error("Failed Enclave to release lock", err);
    }
  }

  let inProgress = false;
  this.digestMessages = (messages) => {
    if (!Array.isArray(messages)) {
      messages = [messages];
    }

    async function rollback() {
      const cancelBatch = $$.promisify(storageService.cancelBatch);
      try {
        await cancelBatch();
      } catch (e) {
        console.log("Not able to cancel batch", e)
      }
    }

    async function finish(lockSecret) {
      if(!storageService.batchInProgress()){
        return;
      }

      const commitBatch = $$.promisify(storageService.commitBatch);
      storageService.onCommitBatch(async ()=>{
        if (lockSecret) {
          await releaseLock(lockSecret);
        }
      });
      await commitBatch(messages.safeBatchId);
      //we clean after our self
      messages.safeBatchId = undefined;
      delete messages.safeBatchId;
    }

    return new Promise(async (resolve, reject) => {
          if (inProgress) {
            throw errMap.newCustomError(errMap.errorTypes.DIGESTING_MESSAGES);
          }
          const initialResolve = resolve;
          const initialReject = reject;


          inProgress = true;

          let lockSecret = await acquireLock(messages.length * 60000, 100, 500);

          resolve = async function (...args) {
            inProgress = false;
            initialResolve(...args);
          }

          reject = async function (...args) {
            inProgress = false;
            initialReject(...args);
          }

          if (!lockSecret) {
            return reject(Error(`Failed to acquire lock`));
          }

          //we store, on purpose, tbe batchId on the messages array instance which is currently digested
          messages.safeBatchId = await storageService.safeBeginBatchAsync();

          //commitPromisses will contain promises for each of message
          let commitPromisses = [];
          let mappingsInstances = [];
          //we will use this array to keep all the failed mapping instance in order to cancel batch operations on touched DSUs
          let failedMappingInstances = [];

          let failedMessages = [];

          function handleErrorsDuringPromiseResolving(err) {
            reject(err);
          }

          let groupInstance = {};
          for (let i = 0; i < messages.length; i++) {
            let message = messages[i];
            if (typeof message !== "object") {
              let err = errMap.newCustomError(errMap.errorTypes.MESSAGE_IS_NOT_AN_OBJECT, [{errorDetails: `Found type: ${typeof message} expected type object`}]);
              failedMessages.push({
                message: message,
                reason: err.message,
                error: err
              });

              //wrong message type... so we log, and then we continue the execution with the rest of the messages
              continue;
            }

            try {
              let mappingInstance = await executeMappingFor(message, groupInstance);
              mappingsInstances.push(mappingInstance);
            } catch (err) {
              //this .mappingInstance prop is artificial injected from the executeMappingFor function in case of an error during mapping execution
              //isn't too nice, but it does the job
              if (err.mappingInstance) {
                failedMappingInstances.push(err.mappingInstance);
              }

              errorHandler.reportUserRelevantError("Caught error during message digest", err);
              failedMessages.push({
                message: message,
                reason: err.message,
                error: err
              });
            }
          }

          function digestConfirmation(results) {

            for (let index = 0; index < results.length; index++) {
              let result = results[index];
              switch (result.status) {
                case "fulfilled" :
                  if (result.value === false) {
                    // message digest failed
                    failedMessages.push({
                      message: messages[index],
                      reason: `Not able to digest message due to missing suitable mapping`,
                      error: errMap.errorTypes.MISSING_MAPPING
                    });
                  }
                  break;
                case "rejected" :
                  failedMessages.push({
                    message: messages[index],
                    reason: result.reason,
                    error: result.reason
                  });
                  break;
              }
            }

            finish(lockSecret).then(async () => {
              //in case that we have failed messages we need to reset touched DSUs of that mapping;
              //the reason being that a DSU can be kept in a local cache and later on this fact that the DSU is in a "batch" state creates a strange situation
              for (let j = 0; j < failedMappingInstances.length; j++) {
                let mapInstance = failedMappingInstances[j];
                if (mapInstance.registeredDSUs) {
                  for (let i = 0; i < mapInstance.registeredDSUs.length; i++) {
                    let touchedDSU = mapInstance.registeredDSUs[i];
                    try {
                      await $$.promisify(touchedDSU.cancelBatch, touchedDSU)(touchedDSU.secretBatchID);
                    } catch (err) {
                      console.log("Failed to cancel batch on registered DSU");
                    }
                  }
                }
              }

              //now that we finished with the partial rollback we can return the failed messages
              if(failedMessages.length){
                $$.debug.log(`Mapping Engine execution finished, but a no. ${failedMessages.length} failed`);
              }
              resolve(failedMessages);
            }).catch(async (err) => {
              await rollback();
              reject(err);
            });
          }

          for (let i = 0; i < mappingsInstances.length; i++) {
            commitPromisses.push(commitMapping(mappingsInstances[i]));
            //deleting the root of the execution cache dsu
            mappingsInstances[i].groupInstance = undefined;
          }

          Promise.allSettled(commitPromisses)
              .then(digestConfirmation)
              .catch(handleErrorsDuringPromiseResolving);
        }
    );
  }

  return this;
}

module.exports = {
  getMappingEngine: function (persistenceDSU, options) {
    return new MappingEngine(persistenceDSU, options);
  },
  getMessagesPipe: function () {
    return require("./messagesPipe");
  },
  getErrorsMap: function () {
    return errMap;
  },
  defineMapping: mappingRegistry.defineMapping,
  defineApi: apisRegistry.defineApi
}

},{"./apisRegistry.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/m2dsu/apisRegistry.js","./defaultApis":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/m2dsu/defaultApis/index.js","./defaultMappings":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/m2dsu/defaultMappings/index.js","./errorsMap.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/m2dsu/errorsMap.js","./mappingRegistry.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/m2dsu/mappingRegistry.js","./messagesPipe":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/m2dsu/messagesPipe/index.js","opendsu":"opendsu"}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/m2dsu/mappingRegistry.js":[function(require,module,exports){
const mappingRegistry = [];
function defineMapping(matchFunction, mappingFunction){
	mappingRegistry.push({matchFunction, mappingFunction});
}

function getMappings(){
	return mappingRegistry;
}

module.exports = {
	defineMapping,
	getMappings
}
},{}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/m2dsu/messagesPipe/index.js":[function(require,module,exports){
module.exports = function (maxGroupSize, maxQueuingTime, groupingFunction) {

    this.queue = [];
    let newGroupCallback;
    let pipeIsWaiting = false;
    let waitingIntervalId;

    let startWaitingMessages = () => {
        if(pipeIsWaiting === false){
            pipeIsWaiting = true;
            waitingIntervalId = setInterval(async()=>{
                if (this.queue.length > 0) {
                    await checkPipeMessages(true);
                }
            }, maxQueuingTime);
        }
    }

    let stopWaitingMessages = () =>{
        pipeIsWaiting = false;
        if(waitingIntervalId){
            clearInterval(waitingIntervalId);
        }
    }

    this.addInQueue =  async (messages) => {

        if (!Array.isArray(messages)) {
            messages = [messages]
        }

        for (let i = 0; i < messages.length; i++) {
            this.queue.push(messages[i]);
        }

        await checkPipeMessages();

    }

    this.onNewGroup = (__newGroupCallback) => {
         newGroupCallback = __newGroupCallback;
    };

    let checkPipeMessages = async (forceFlush) =>{

        let messageGroup = await $$.promisify(groupingFunction)(this.queue);

        if (messageGroup.length < this.queue.length || maxGroupSize <= this.queue.length || forceFlush) {
            messageGroup = [...messageGroup];
            //TODO we are loosing messages that are not properly digested
            this.queue.splice(0,messageGroup.length);
            stopWaitingMessages();
            await newGroupCallback(messageGroup);
        }
        startWaitingMessages();
    }

    startWaitingMessages();

}
},{}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/moduleConstants.js":[function(require,module,exports){
const ENVIRONMENT_TYPES = require("../overwrite-require/src/moduleConstants");

let cachedKeySSIResolver = undefined;


module.exports = {
    ENVIRONMENT_TYPES,
    CODE_FOLDER: "/code",
    CONSTITUTION_FOLDER: '/code/constitution',
    BLOCKCHAIN_FOLDER: '/blockchain',
    APP_FOLDER: '/app',
    DOMAIN_IDENTITY_FILE: '/domain_identity',
    ASSETS_FOLDER: "/assets",
    TRANSACTIONS_FOLDER: "/transactions",
    APPS_FOLDER: "/apps",
    DATA_FOLDER: "/data",
    MANIFEST_FILE: "/manifest",
    BDNS_ROOT_HOSTS: "BDNS_ROOT_HOSTS",
    ENVIRONMENT_PATH: "/environment.json",
    SECURITY_CONTEXT_KEY_SSI: "scKeySSI",
    VAULT_DOMAIN: "vaultDomain",
    DOMAIN: "domain",
    DID_DOMAIN: "didDomain",
    MAIN_APP_DID: "mainAppDID",
    NOTIFICATION_TYPES: {
        ERROR: "error",
        WARN: "warn",
        INFO: "info",
        DEV: "dev"
    },
    MAIN_ENCLAVE: {
        TYPE: "enclaveType",
        DID: "enclaveDID",
        KEY_SSI: "enclaveKeySSI"
    },
    SHARED_ENCLAVE: {
        TYPE: "sharedEnclaveType",
        DID: "sharedEnclaveDID",
        KEY_SSI: "sharedEnclaveKeySSI",
    },
    ENCLAVE_TYPES: {
        WALLET_DB_ENCLAVE: "WalletDBEnclave",
        MEMORY_ENCLAVE: "MemoryEnclave",
        VERSIONLESS_DSU_ENCLAVE: "VersionlessDSUEnclave",
        CLOUD_ENCLAVE: "CloudEnclave",
        LIGHT_DB_ENCLAVE: "LightDBEnclave",
    },
    CACHE: {
        FS: "fs",
        MEMORY: "memory",
        INDEXED_DB: "cache.indexedDB",
        VAULT_TYPE: "cache.vaultType",
        BASE_FOLDER: "internal-volume/cache",
        BASE_FOLDER_CONFIG_PROPERTY: "fsCache.baseFolder",
        ENCRYPTED_BRICKS_CACHE: "encrypted-bricks-cache",
        ANCHORING_CACHE: "anchoring-cache",
        NO_CACHE: "no-cache"
    },
    DOMAINS: {
        VAULT: "vault"
    },
    VAULT: {
        BRICKS_STORE: "bricks",
        ANCHORS_STORE: "anchors"
    },
    BRICKS_DOMAIN_KEY: "bricksDomain",
    LOADER_ENVIRONMENT_JSON: {
        AGENT: "agent",
        SERVER: "server",
        VAULT: "vault",
        MOBILE: "mobile",
    },
    BOOT_CONFIG_FILE: 'boot-cfg.json',
    ERROR_ROOT_CAUSE: {
        UNKNOWN_ERROR: "unknown",
        NETWORK_ERROR: "network",
        THROTTLER_ERROR: "throttler",
        BUSINESS_ERROR: "business",
        DATA_INPUT_ERROR: "dataInput",
        MISSING_DATA_ERROR: "missingData",
        DSU_INVALID_OPERATION: "dsuInvalidOperation",
        SECURITY_ERROR: "security",
        RESOURCE_ERROR: "resource"
    },
    get KEY_SSIS() {
        if (cachedKeySSIResolver === undefined) {
            cachedKeySSIResolver = require("key-ssi-resolver");
        }
        return cachedKeySSIResolver.SSITypes;
    },
    get DSUTypes() {
        if (cachedKeySSIResolver === undefined) {
            cachedKeySSIResolver = require("key-ssi-resolver");
        }
        return cachedKeySSIResolver.DSUTypes;
    },
    get KEY_SSI_FAMILIES() {
        if (cachedKeySSIResolver === undefined) {
            cachedKeySSIResolver = require("key-ssi-resolver");
        }
        return cachedKeySSIResolver.SSIFamilies;
    },
    get CRYPTO_FUNCTION_TYPES() {
        if (cachedKeySSIResolver === undefined) {
            cachedKeySSIResolver = require("key-ssi-resolver");
        }
        return cachedKeySSIResolver.CryptoFunctionTypes;
    }
}




},{"../overwrite-require/src/moduleConstants":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/overwrite-require/src/moduleConstants.js","key-ssi-resolver":"key-ssi-resolver"}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/mq/mqClient.js":[function(require,module,exports){
/*
Message Queues API space
*/

let http = require("../http");
let bdns = require("../bdns")

function send(keySSI, message, callback) {
    console.log("Send method from OpenDSU.loadApi('mq') is absolute. Adapt your code to use the new getMQHandlerForDID");
    bdns.getAnchoringServices(keySSI, (err, endpoints) => {
        if (err) {
            return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to get anchoring services from bdns`, err));
        }
        let url = endpoints[0] + `/mq/send-message/${keySSI}`;
        let options = { body: message };

        let request = http.poll(url, options);

        request.then((response) => {
            callback(undefined, response);
        }).catch((err) => {
            return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to send message`, err));
        });
    });
}

let requests = {};

function getHandler(keySSI, timeout, callback) {
    console.log("getHandler method from OpenDSU.loadApi('mq') is absolute. Adapt your code to use the new getMQHandlerForDID");
    let obs = require("../utils/observable").createObservable();
    bdns.getMQEndpoints(keySSI, (err, endpoints) => {
        if (err || endpoints.length === 0) {
            return callback(new Error("Not available!"));
        }

        let createChannelUrl = endpoints[0] + `/mq/create-channel/${keySSI}`;
        http.doPost(createChannelUrl, undefined, (err) => {
            if (err) {
                if (err.statusCode === 409) {
                    //channels already exists. no problem :D
                } else {
                    obs.dispatch("error", err);
                    return;
                }
            }

            function makeRequest() {
                let url = endpoints[0] + `/mq/receive-message/${keySSI}`;
                let options = {};

                let request = http.poll(url, options, timeout);

                request.then((response) => {
                    obs.dispatch("message", response);
                    makeRequest();
                }).catch((err) => {
                    obs.dispatch("error", err);
                });

                requests[obs] = request;
            }

            makeRequest();

        });
    });

    return obs;
}

function unsubscribe(keySSI, observable) {
    console.log("unsubscribe method from OpenDSU.loadApi('mq') is obsolete. Adapt your code to use the new getMQHandlerForDID");
    http.unpoll(requests[observable]);
}

function MQHandler(didDocument, domain, pollingTimeout) {
    let connectionTimeout;
    let timeout = pollingTimeout || 1000;
    let token;
    let expiryTime;
    let queueName = didDocument.getHash();
    let self = this;

    function getURL(queueName, action, signature, messageID, callback) {
        let url
        if (typeof signature === "function") {
            callback = signature;
            signature = undefined;
            messageID = undefined;
        }

        if (typeof messageID === "function") {
            callback = messageID;
            messageID = undefined;
        }

        domain = didDocument.getDomain();

        if (!domain) {
            const sc = require("opendsu").loadAPI("sc");
            sc.getDIDDomain((err, didDomain) => {
                if (err) {
                    return callback(err);
                }

                domain = didDomain;
                __createURL();
            })
        } else {
            __createURL();
        }

        function __createURL() {
            bdns.getMQEndpoints(domain, (err, mqEndpoints) => {
                if (err) {
                    return callback(err);
                }

                url = `${mqEndpoints[0]}/mq/${domain}`
                switch (action) {
                    case "token":
                        url = `${url}/${queueName}/token`;
                        break;
                    case "get":
                        url = `${url}/get/${queueName}/${signature}`;
                        break;
                    case "put":
                        url = `${url}/put/${queueName}`;
                        break;
                    case "take":
                        url = `${url}/take/${queueName}/${signature}`;
                        break;
                    case "delete":
                        url = `${url}/delete/${queueName}/${messageID}/${signature}`;
                        break;
                    default:
                        throw Error(`Invalid action received ${action}`);
                }

                callback(undefined, url);
            })
        }
    }

    function ensureAuth(callback) {
        getURL(queueName, "token", (err, url) => {
            if (err) {
                return callback(err);
            }

            if (!token || (expiryTime && Date.now() + 2000 > expiryTime)) {
                callback = $$.makeSaneCallback(callback);
                return http.fetch(url)
                    .then(response => {
                        connectionTimeout = parseInt(response.headers.get("connection-timeout"));
                        return response.json()
                    })
                    .then(data => {
                        token = data.token;
                        expiryTime = data.expires;
                        callback(undefined, token);
                    })
                    .catch(err => callback(err));
            }

            callback(undefined, token);
        });
    }

    this.writeMessage = (message, callback) => {
        ensureAuth((err, token) => {
            if (err) {
                return callback(err);
            }

            getURL(queueName, "put", (err, url) => {
                if (err) {
                    return callback(err);
                }

                http.doPut(url, message, { headers: { "x-mq-authorization": token } }, callback);
            });
        })

    }

    function consumeMessage(action, waitForMore, callback) {
        if (typeof waitForMore === "function") {
            callback = waitForMore;
            waitForMore = false;
        }
        callback.__requestInProgress = true;
        ensureAuth((err, token) => {
            if (err) {
                return callback(err);
            }
            //somebody called abort before the ensureAuth resolved
            if (!callback.__requestInProgress) {
                return;
            }
            didDocument.sign(token, (err, signature) => {
                if (err) {
                    return callback(createOpenDSUErrorWrapper(`Failed to sign token`, err));
                }

                getURL(queueName, action, signature.toString("hex"), (err, url) => {
                    if (err) {
                        return callback(err);
                    }
                    let originalCb = callback;
                    //callback = $$.makeSaneCallback(callback);

                    let options = { headers: { "x-mq-authorization": token } };

                    function makeRequest() {
                        let request = http.poll(url, options, connectionTimeout, timeout);
                        originalCb.__requestInProgress = request;

                        request.then(response => response.json())
                            .then((response) => {
                                if(self.stopReceivingMessages){
                                    return callback(new Error("Message rejected by client"));
                                }
                                //the return value of the listing callback helps to stop the polling mechanism in case that
                                //we need to stop to listen for more messages
                                let stop = callback(undefined, response);
                                if (waitForMore && !stop) {
                                    makeRequest();
                                }
                            })
                            .catch((err) => {
                                if(err.rootCause != "network"){
                                    callback(err);
                                }else{
                                    makeRequest();
                                }
                            });
                    }

                    //somebody called abort before we arrived here
                    if (!originalCb.__requestInProgress) {
                        return;
                    }
                    makeRequest();
                })
            })
        })
    }

    this.waitForMessages = (callback) => {
        this.readAndWaitForMore(()=>{
            return typeof this.stopReceivingMessages === "undefined" || this.stopReceivingMessages === false;
        }, callback);
    }

    this.previewMessage = (callback) => {
        consumeMessage("get", callback);
    };


    function getSafeMessageRead(callback){
        return function(err, message){
            if(err){
                return callback(err);
            }
            if(message){
                callback(undefined, message, ()=>{
                    console.log("notification callback called");
                    self.deleteMessage(message.messageId, (err)=>{
                        if(err){
                            console.log("Unable to delete message from mq");
                        }
                    });
                });
            }
        }
    }

    this.readMessage = (callback) => {
        consumeMessage("get", getSafeMessageRead(callback));
    };

    this.readAndWaitForMessages = (callback) => {
        consumeMessage("take", true, getSafeMessageRead(callback));
    };

    this.readAndWaitForMore = (waitForMore, callback) => {
        if(typeof waitForMore === "function" && typeof callback === "undefined"){
            callback = waitForMore;
            waitForMore = undefined;
        }
        consumeMessage("get", waitForMore ? waitForMore() : true, getSafeMessageRead(callback));
    };

    this.subscribe = this.readAndWaitForMore;

    this.abort = (callback) => {
        let request = callback.__requestInProgress;
        //if we have an object it means that a http.poll request is in progress
        if (typeof request === "object") {
            request.abort();
            callback.__requestInProgress = undefined;
            delete callback.__requestInProgress;
            console.log("A request was aborted programmatically");
        } else {
            //if we have true value it means that an ensureAuth is in progress
            if (request) {
                callback.__requestInProgress = false;
                console.log("A request was aborted programmatically");
            }
        }
    }

    this.deleteMessage = (messageID, callback) => {
        ensureAuth((err, token) => {
            if (err) {
                return callback(err);
            }
            didDocument.sign(token, (err, signature) => {
                if (err) {
                    return callback(createOpenDSUErrorWrapper(`Failed to sign token`, err));
                }

                getURL(queueName, "delete", signature.toString("hex"), messageID, (err, url) => {
                    if (err) {
                        return callback(err);
                    }

                    http.fetch(url, {
                        method: "DELETE",
                        headers: { "x-mq-authorization": token }
                    })
                        .then(() => callback())
                        .catch(e => callback(e));
                });
            });
        });
    };
}

let handlers = {};
function getMQHandlerForDID(didDocument, domain, timeout) {
    let identifier = typeof didDocument === "object" ? didDocument.getIdentifier() : didDocument;
    if(!handlers[identifier]){
        handlers[identifier] = new MQHandler(didDocument, domain, timeout);
    }
    return handlers[identifier];
}

module.exports = {
    send,
    getHandler,
    unsubscribe,
    getMQHandlerForDID
}

},{"../bdns":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/bdns/index.js","../http":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/http/index.js","../utils/observable":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/utils/observable.js","opendsu":"opendsu"}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/notifications/index.js":[function(require,module,exports){
/*
KeySSI Notification API space
*/

let http = require("../http");
let bdns = require("../bdns");

function publish(keySSI, message, timeout, callback) {
    if (typeof timeout === 'function') {
        callback = timeout;
        timeout = 0;
    }
    bdns.getNotificationEndpoints(keySSI.getDLDomain(), (err, endpoints) => {
        if (err) {
            throw new Error(err);
        }

        if (!endpoints.length) {
            throw new Error("No notification endpoints are available!");
        }
        keySSI.getAnchorId((err, anchorId) => {
            if (err) {
                return callback(err);
            }
            let url = endpoints[0] + `/notifications/publish/${anchorId}`;

            if (typeof message !== 'string' && !$$.Buffer.isBuffer(message) && !ArrayBuffer.isView(message)) {
                message = JSON.stringify(message);
            }

            let options = {body: message, method: 'PUT'};

            let request = http.poll(url, options, undefined, timeout);

            request.then((response) => {
                callback(undefined, response);
            }).catch((err) => {
                return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to publish message`, err));
            });
        });
    });
}

let requests = new Map();

function getObservableHandler(keySSI, timeout, callback) {
    timeout = timeout || 0;
    let obs = require("../utils/observable").createObservable();

    bdns.getNotificationEndpoints(keySSI.getDLDomain(), (err, endpoints) => {
        if (err) {
            throw new Error(err);
        }

        if (!endpoints.length) {
            throw new Error("No notification endpoints are available!");
        }

        keySSI.getAnchorId((err, anchorId) => {
            if (err) {
                return callback(err);
            }

            function makeRequest() {
                let url = endpoints[0] + `/notifications/subscribe/${anchorId}`;
                let options = {
                    method: 'POST'
                };
                let request = http.poll(url, options, undefined, timeout);

                request.then((response) => {
                    obs.dispatchEvent("message", response);

                    // If a subscription still exists, continue polling for messages
                    if (requests.has(obs)) {
                        makeRequest();
                    }
                }).catch((err) => {
                    obs.dispatchEvent("error", err);
                });

                requests.set(obs, request);
            }

            makeRequest();
        })
    })

    return obs;
}

function unsubscribe(observable) {
    const request = requests.get(observable);
    if (!request) {
        return;
    }
    http.unpoll(request);
    requests.delete(observable);
}

function isSubscribed(observable) {
    return requests.has(observable);
}

module.exports = {
    publish,
    getObservableHandler,
    unsubscribe,
    isSubscribed
}

},{"../bdns":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/bdns/index.js","../http":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/http/index.js","../utils/observable":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/utils/observable.js"}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/oauth/index.js":[function(require,module,exports){
const createOIDC = (options) => {
    const OIDC = require("./src/oidc/OIDC");
    return new OIDC(options);
}

module.exports = {
    createOIDC,
    getStorage: require("./src/util/Storage").getStorage,
    constants: require("./src/oidc/constants"),

}
},{"./src/oidc/OIDC":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/oauth/src/oidc/OIDC.js","./src/oidc/constants":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/oauth/src/oidc/constants.js","./src/util/Storage":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/oauth/src/util/Storage.js"}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/oauth/src/oidc/Client.js":[function(require,module,exports){
class Client {
    constructor(options) {
        this.options = options;
    }


    get clientId() {
        return this.options['clientId'] || this.options['client_id'];
    }


    get redirectPath() {
        return this.options['redirectPath'] || this.options['redirect_path'];
    }


    get redirectUri() {
        return location.protocol + '//' + location.host + this.redirectPath;
    }


    get scope() {
        return this.options['scope'];
    }
}


module.exports = Client;
},{}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/oauth/src/oidc/Issuer.js":[function(require,module,exports){
class Issuer {
    constructor(options) {
        this.options = options;
    }


    get issuer() {
        return this.options['issuer'];
    }


    get authorizationEndpoint() {
        return this.options['authorizationEndpoint'] || this.options['authorization_endpoint'];
    }


    get tokenEndpoint() {
        return this.options['tokenEndpoint'] || this.options['token_endpoint'];
    }
}


module.exports = Issuer;
},{}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/oauth/src/oidc/OIDC.js":[function(require,module,exports){
const RedirectInteraction = require('./interactions/Redirect');
const IFrameInteraction = require('./interactions/IFrame');
const PopupInteraction = require('./interactions/Popup');
const AuthorizationCodeGrant = require('./grants/AuthorizationCode');
const RefreshTokenGrant = require('./grants/RefreshToken');

const Browser = require('../util/Browser');
const Crypto = require('../util/Crypto');
const Storage = require('../util/Storage');
const Issuer = require('./Issuer');
const Client = require('./Client');


const ID_TOKEN = 'session.idToken';
const ACCESS_TOKEN = 'session.accessToken';
const REFRESH_TOKEN = 'session.refreshToken';
const EXPIRATION_TIMESTAMP = 'session.expirationTimestamp';
const AUTHORIZATION_CODE_VERIFIER = 'session.codeVerifier';
const AUTHORIZATION_STATE = 'session.state';
const INTERACTION = 'session.interaction';
const INTERACTION_IFRAME = 'iframe';
const INTERACTION_POPUP = 'popup';
const INTERACTION_REDIRECT = 'redirect';
const INTERACTION_REFRESH = 'refresh';
const BROWSER_LOCATION = 'browser.current.location';


const TOKEN_CHECK_INTERVAL = 1000 * 30;
const TOKEN_EXPIRATION_THRESHOLD = 1000 * 60;


class OIDC {
    issuer;
    client;
    storage;


    constructor(options) {
        this.storage = options.storage || Storage.getStorage();
        this.issuer = new Issuer(options.issuer);
        this.client = new Client(options.client);
        this.options = options;
        this.setPeriodicRefreshTimeout();
    }


    setPeriodicRefreshTimeout() {
        setTimeout(() => this.periodicRefresh(), this.options.tokenCheckInterval || TOKEN_CHECK_INTERVAL);
    }


    async periodicRefresh() {
        if (!this.isTokenSetExpiring(TOKEN_EXPIRATION_THRESHOLD)) {
            return this.setPeriodicRefreshTimeout();
        }

        //todo: dispatch error: event, register handler
        try {
            await this.refreshTokenSet();
        } catch (err) {
            console.log('periodicRefresh.tokenSetError', err);
        } finally {
            this.setPeriodicRefreshTimeout();
        }
    }


    async reconcile() {
        if (this.isCallbackPhaseActive()) {
            console.log('callbackPhaseActive');
            return this.resumeAuthentication()
                .catch((err) => this.resetAuthentication(err));
        }

        if (this.isAccessTokenInStorage()) {
            if (this.isTokenSetExpiring(TOKEN_EXPIRATION_THRESHOLD)) {
                try {
                    await this.refreshTokenSet();
                } catch (err) {
                    console.log('refreshTokenSetError', err);
                    return this.beginAuthentication();
                }
            }
        } else {
            return this.beginAuthentication();
        }
    }


    getToken(decoded) {
        const token = this.storage.get(ACCESS_TOKEN);
        return decoded ? this.decodeToken(token) : token;
    }


    getIdToken(decoded) {
        const token = this.storage.get(ID_TOKEN);
        return decoded ? this.decodeToken(token) : token;
    }


    isAccessTokenInStorage() {
        return !!this.storage.get(ACCESS_TOKEN);
    }


    isTokenSetExpiring(threshold = 0) {
        const expirationTimestamp = parseInt(this.storage.get(EXPIRATION_TIMESTAMP)) || 0;
        return Date.now() + threshold >= expirationTimestamp;
    }


    isCallbackPhaseActive() {
        return !!location.toString().includes(this.client.redirectPath) || !!location.toString().includes("/#code=");
    }


    refreshTokenSet() {
        console.log('refreshSession');
        return this.refreshWithRefreshToken()
            .catch(() => this.refreshWithIFrame())
            .catch((err) => {
                //todo: improve error detection
                const loginRequired = err.message.includes('login_required');
                return this.refreshWithPopup(loginRequired ? 'login' : 'none')
            })
            .finally(() => this.storage.remove(INTERACTION));
    }


    refreshWithRefreshToken() {
        console.log('refresh.refreshToken');
        if (!this.storage.get(REFRESH_TOKEN)) {
            return Promise.reject(Error('Refresh token not found'));
        }
        const options = {
            refreshToken: this.storage.get(REFRESH_TOKEN)
        }

        this.storage.set(INTERACTION, INTERACTION_REFRESH);
        return RefreshTokenGrant.refreshToken(this.issuer, this.client, options)
            .then((response) => this.handleOAuthHttpResponse(response))
            .then((tokenSet) => this.updateStorageWithTokenSet(tokenSet));
    }


    refreshWithIFrame() {
        console.log('refresh.iframe');
        const authorizationContext = AuthorizationCodeGrant.getAuthorizationUrl(this.issuer, this.client, {prompt: 'none'});
        const context = {
            state: authorizationContext.state,
            codeVerifier: authorizationContext.codeVerifier,
        }

        this.storage.set(INTERACTION, INTERACTION_IFRAME);
        return this.getInteraction(INTERACTION_IFRAME)
            .run(authorizationContext.url)
            .then((response) => this.handleOAuthHttpResponse(response))
            .then((authorizationResponse) => this.handleAuthorizationResponse(context, authorizationResponse))
            .finally(() => this.storage.remove(INTERACTION));
    }


    refreshWithPopup(prompt) {
        console.log('refresh.popup');
        const authorizationContext = AuthorizationCodeGrant.getAuthorizationUrl(this.issuer, this.client, {prompt});
        const context = {
            state: authorizationContext.state,
            codeVerifier: authorizationContext.codeVerifier,
        }

        this.storage.set(INTERACTION, INTERACTION_POPUP);
        return this.getInteraction(INTERACTION_POPUP)
            .run(authorizationContext.url)
            .then((response) => this.handleOAuthHttpResponse(response))
            .then((authorizationResponse) => this.handleAuthorizationResponse(context, authorizationResponse))
            .finally(() => this.storage.remove(INTERACTION));
    }


    isRedirectInProgress() {
        return this.storage.get(INTERACTION) === INTERACTION_REDIRECT
    }


    beginAuthentication() {
        console.log('beginAuthentication');
        this.cleanUpAuthorizationStorage();
        this.cleanUpTokenStorage();

        this.storage.set(BROWSER_LOCATION, Browser.getCurrentLocation());

        const authorizationContext = AuthorizationCodeGrant.getAuthorizationUrl(this.issuer, this.client);
        this.storage.set(AUTHORIZATION_CODE_VERIFIER, authorizationContext.codeVerifier);
        this.storage.set(AUTHORIZATION_STATE, authorizationContext.state);

        this.storage.set(INTERACTION, INTERACTION_REDIRECT);
        return this.getInteraction(INTERACTION_REDIRECT).run(authorizationContext.url);
    }


    async resumeAuthentication() {
        const interactionType = this.storage.get(INTERACTION);
        const interaction = this.getInteraction(interactionType);
        console.log('resumeAuthentication', interactionType);
        if (!interaction) {
            throw new Error('Interaction not found');
        }
        const authorizationResponse = await interaction.resume();

        if (!interaction.allowResumeAuthentication) {
            return console.log('interaction will be handled at source');
        }

        const context = {
            state: this.storage.get(AUTHORIZATION_STATE),
            codeVerifier: this.storage.get(AUTHORIZATION_CODE_VERIFIER),
            redirect: this.storage.get(BROWSER_LOCATION)
        }

        // clear storage to prevent replay attacks
        this.cleanUpAuthorizationStorage();

        return this.handleOAuthHttpResponse(authorizationResponse)
            .then(() => this.handleAuthorizationResponse(context, authorizationResponse));
    }


    handleAuthorizationResponse(context, authorizationResponse) {
        if (context.state !== authorizationResponse.state) {
            console.log('invalidStateError', context.state, authorizationResponse.state);
            return Promise.reject(new Error('Invalid state'));
        }

        const options = {
            code: authorizationResponse.code,
            codeVerifier: context.codeVerifier
        };
        return AuthorizationCodeGrant.getToken(this.issuer, this.client, options)
            .then((response) => this.handleOAuthHttpResponse(response))
            .then((tokenSet) => this.updateStorageWithTokenSet(tokenSet))
            .then(() => this.cleanUpAuthorizationStorage())
            .then(() => {
                if (context.redirect) {
                    location.assign(context.redirect);
                }
            });
    }


    getInteraction(type) {
        let interaction;
        switch (type) {
            case INTERACTION_IFRAME:
                interaction = new IFrameInteraction();
                break;
            case INTERACTION_POPUP:
                interaction = new PopupInteraction();
                break;
            case INTERACTION_REDIRECT:
                interaction = new RedirectInteraction();
                break;
        }
        return interaction;
    }


    handleOAuthHttpResponse(response) {
        if (response['error']) {
            console.log('oauthError', response['error'], response['error_description'])
            return Promise.reject(Error(`OAuth Error[${response['error']}]: ${response['error_description']}`));
        }

        return Promise.resolve(response);
    }


    updateStorageWithTokenSet(tokenSet) {
        this.storage.set(EXPIRATION_TIMESTAMP, Date.now() + (tokenSet['expires_in'] * 1000));
        this.storage.set(ACCESS_TOKEN, tokenSet['access_token']);
        this.storage.set(REFRESH_TOKEN, tokenSet['refresh_token']);
        if (tokenSet['id_token']) {
            this.storage.set(ID_TOKEN, tokenSet['id_token']);
        }
    }


    decodeToken(token) {
        if (!token) {
            return null;
        }
        const [header, payload, signature] = token.split('.');
        return {
            header: JSON.parse(Crypto.decodeBase64EncodedData(header)),
            payload: JSON.parse(Crypto.decodeBase64EncodedData(payload)),
            signature
        }
    }


    cleanUpAuthorizationStorage() {
        this.storage.remove(INTERACTION);
        this.storage.remove(AUTHORIZATION_STATE);
        this.storage.remove(AUTHORIZATION_CODE_VERIFIER);
        this.storage.remove(BROWSER_LOCATION);
    }


    cleanUpTokenStorage() {
        this.storage.remove(ACCESS_TOKEN);
        this.storage.remove(ID_TOKEN);
        this.storage.remove(REFRESH_TOKEN);
        this.storage.remove(EXPIRATION_TIMESTAMP);
    }


    resetAuthentication(err) {
        console.log('resetAuthentication', err);
        this.cleanUpAuthorizationStorage();
        this.cleanUpTokenStorage();
        history.replaceState(null, null, ' ');
        if (err) {
            throw err;
        }
    }
}


OIDC.utils = {Browser};
module.exports = OIDC;
},{"../util/Browser":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/oauth/src/util/Browser.js","../util/Crypto":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/oauth/src/util/Crypto.js","../util/Storage":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/oauth/src/util/Storage.js","./Client":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/oauth/src/oidc/Client.js","./Issuer":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/oauth/src/oidc/Issuer.js","./grants/AuthorizationCode":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/oauth/src/oidc/grants/AuthorizationCode.js","./grants/RefreshToken":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/oauth/src/oidc/grants/RefreshToken.js","./interactions/IFrame":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/oauth/src/oidc/interactions/IFrame.js","./interactions/Popup":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/oauth/src/oidc/interactions/Popup.js","./interactions/Redirect":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/oauth/src/oidc/interactions/Redirect.js"}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/oauth/src/oidc/constants.js":[function(require,module,exports){
module.exports = {
    ID_TOKEN: 'session.idToken',
    ACCESS_TOKEN: 'session.accessToken',
    REFRESH_TOKEN: 'session.refreshToken',
    EXPIRATION_TIMESTAMP: 'session.expirationTimestamp',
    AUTHORIZATION_CODE_VERIFIER: 'session.codeVerifier',
    AUTHORIZATION_STATE: 'session.state',
    INTERACTION: 'session.interaction',
    INTERACTION_IFRAME: 'iframe',
    INTERACTION_POPUP: 'popup',
    INTERACTION_REDIRECT: 'redirect',
    INTERACTION_REFRESH: 'refresh',
    BROWSER_LOCATION: 'browser.current.location',
    TOKEN_CHECK_INTERVAL: 1000 * 30,
    TOKEN_EXPIRATION_THRESHOLD: 1000 * 60,
}
},{}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/oauth/src/oidc/grants/AuthorizationCode.js":[function(require,module,exports){
const Crypto = require('../../util/Crypto');


class AuthorizationCode {
    static getAuthorizationUrl(issuer, client, options = {}) {
        const codeVerifier = Crypto.generateCodeVerifier();
        const codeChallenge = Crypto.generateCodeChallenge(codeVerifier);
        const state = Crypto.generateState();

        const authorizationUrl = new URL(issuer.authorizationEndpoint);
        const query = authorizationUrl.searchParams;

        query.set('client_id', client.clientId);
        query.set('scope', client.scope);
        query.set('redirect_uri', client.redirectUri);
        query.set('response_type', 'code');
        query.set('response_mode', 'fragment');
        query.set('code_challenge_method', 'S256');
        query.set('code_challenge', codeChallenge);
        query.set('state', state);

        if (options.prompt) {
            query.set('prompt', options.prompt);
        }

        authorizationUrl.search = query.toString();
        return {state, codeVerifier, url: authorizationUrl.toString()};
    }


    static getToken(issuer, client, options) {
        const params = new URLSearchParams();
        params.append('grant_type', 'authorization_code');
        params.append('client_id', client.clientId);
        params.append('redirect_uri', client.redirectUri);
        params.append('code', options.code);
        params.append('code_verifier', options.codeVerifier);

        const payload = {
            method: 'POST',
            headers: {'Content-Type': 'application/x-www-form-urlencoded'},
            body: params
        }

        return fetch(issuer.tokenEndpoint, payload).then((response) => response.json())
    }
}


module.exports = AuthorizationCode;
},{"../../util/Crypto":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/oauth/src/util/Crypto.js"}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/oauth/src/oidc/grants/RefreshToken.js":[function(require,module,exports){
class RefreshToken {
    static refreshToken(issuer, client, options) {
        const params = new URLSearchParams();
        params.append('grant_type', 'refresh_token');
        params.append('client_id', client.clientId);
        params.append('redirect_uri', client.redirectUri);
        params.append('refresh_token', options.refreshToken);

        const payload = {
            method: 'POST',
            headers: {'Content-Type': 'application/x-www-form-urlencoded'},
            body: params
        }

        return fetch(issuer.tokenEndpoint, payload).then((response) => response.json())
    }
}


module.exports = RefreshToken;
},{}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/oauth/src/oidc/interactions/IFrame.js":[function(require,module,exports){
const Promises = require('../../util/Promises');
const Interaction = require('./Interaction');


const IFRAME_ID = 'oidc-sso-iframe';
const IFRAME_STYLE = 'visibility: hidden;';


class IFrame extends Interaction {
    createIFrame(url) {
        const iframe = document.createElement('iframe');
        iframe.setAttribute('id', IFRAME_ID);
        iframe.setAttribute('src', url);
        iframe.setAttribute('style', IFRAME_STYLE);
        iframe.addEventListener('load', () => {
            this.extractParamsFromContext(iframe.contentWindow.location,
                (params) => this.completed(params),
                (err) => this.failed(err));
        });

        document.getElementsByTagName('body')[0].appendChild(iframe);

        setTimeout(() => {
            this.failed(new Error('Loading IFrame timed out'));
        }, 5000);
    }


    cleanUp() {
        const element = document.getElementById(IFRAME_ID);
        element.parentNode.removeChild(element);
    }


    failed(err) {
        if (!this.isCompleted) {
            if (this.reject && typeof this.reject === 'function') {
                this.reject(err);
            }
            this.isCompleted = true;
            this.cleanUp();
        }
    }


    completed(response) {
        if (!this.isCompleted) {
            if (this.resolve && typeof this.resolve === 'function') {
                this.resolve(response);
            }
            this.isCompleted = true;
            this.cleanUp();
        }
    }


    resume() {
    }


    run(url) {
        const {promise, resolve, reject} = Promises.flatPromise();
        this.resolve = resolve;
        this.reject = reject;

        this.createIFrame(url);

        return promise;
    }
}


module.exports = IFrame;
},{"../../util/Promises":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/oauth/src/util/Promises.js","./Interaction":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/oauth/src/oidc/interactions/Interaction.js"}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/oauth/src/oidc/interactions/Interaction.js":[function(require,module,exports){
const Browser = require('../../util/Browser');


class Interaction {
    constructor(allowResumeAuthentication = false) {
        this.allowResumeAuthentication = allowResumeAuthentication;
    }


    extractParamsFromContext(context, resolve, reject) {
        let params = null;
        try {
            if (context.hash) {
                params = Browser.parseUrlHash(context.hash);
            } else if (context.search) {
                params = Browser.parseUrlQuery(context.search);
            }

            if (params !== null) {
                resolve(params);
            } else {
                reject(new Error(`Failed to extract params value from context[${this.constructor.name}]`))
            }
        } catch (err) {
            reject(err);
        }
    }
}


module.exports = Interaction;
},{"../../util/Browser":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/oauth/src/util/Browser.js"}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/oauth/src/oidc/interactions/Popup.js":[function(require,module,exports){
const Interaction = require('./Interaction');
const Promises = require('../../util/Promises');


const POPUP_NAME = 'oidc-sso-popup';
const POPUP_FEATURES = 'height=600,width=800';


class Popup extends Interaction {
    run(url) {
        const {promise, resolve, reject} = Promises.flatPromise();

        window.popupCompleted = () => {
            popupWindow.completed = true;
            this.extractParamsFromContext(popupWindow.location, resolve, reject);
        }

        const popupWindow = window.open(url, POPUP_NAME, POPUP_FEATURES);
        if (popupWindow === null) {
            throw new Error('Error loading authentication popup window');
        }

        const popupInterval = setInterval(() => {
            if (popupWindow.closed && !popupWindow.completed) {
                clearInterval(popupInterval);
                reject(new Error('Authentication popup window closed'));
            }
        });

        if (window.focus) {
            popupWindow.focus()
        }

        return promise;
    }


    cleanUp() {
        window.opener.popupCompleted();
        window.close();
    }


    resume() {
        if (window.opener) {
            this.cleanUp();
        } else {
            window.onload = () => this.cleanUp();
        }
    }
}


module.exports = Popup;
},{"../../util/Promises":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/oauth/src/util/Promises.js","./Interaction":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/oauth/src/oidc/interactions/Interaction.js"}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/oauth/src/oidc/interactions/Redirect.js":[function(require,module,exports){
const Interaction = require('./Interaction');
const Promises = require('../../util/Promises');


class Redirect extends Interaction {
    constructor() {
        super(true);
    }


    run(url) {
        window.location = url;
    }


    resume() {
        const {promise, resolve, reject} = Promises.flatPromise();
        this.extractParamsFromContext(location, resolve, reject);
        return promise;
    }
}


module.exports = Redirect;
},{"../../util/Promises":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/oauth/src/util/Promises.js","./Interaction":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/oauth/src/oidc/interactions/Interaction.js"}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/oauth/src/util/Browser.js":[function(require,module,exports){
function parseUrlHash(hash) {
    return parseUrlParams(hash.substring(1));
}


function parseUrlQuery(query) {
    return parseUrlParams(query.substring(1));
}


function parseUrlParams(value) {
    const params = {};
    const searchParams = new URLSearchParams(value);
    for (let [key, value] of searchParams.entries()) {
        params[key] = value;
    }
    return params;
}


function getCurrentLocation() {
    return location.href.substring(location.origin.length)
}


function isItMe() {
    if (window.opener) {
        return false;
    } else if (window.top !== window.self) {
        return false
    } else {
        return true;
    }
}


module.exports = {
    parseUrlHash,
    parseUrlQuery,
    getCurrentLocation,
    isItMe
};
},{}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/oauth/src/util/Crypto.js":[function(require,module,exports){
const openDSU = require("opendsu");
const crypto = openDSU.loadAPI("crypto");

function getRandomValues(len) {
    const buff = crypto.generateRandom(len);
    const str = crypto.base64UrlEncodeJOSE(buff);
    return str.substring(0, len);
}

function generateState() {
    return getRandomValues(32);
}

function generateCodeVerifier() {
    return getRandomValues(64);
}

function generateCodeChallenge(verifier) {
    return crypto.base64UrlEncodeJOSE(crypto.sha256JOSE(verifier));
}

function decodeBase64EncodedData(data) {
   return $$.Buffer.from(data, "base64").toString();
}

module.exports = {
    generateState,
    generateCodeVerifier,
    generateCodeChallenge,
    decodeBase64EncodedData
}
},{"opendsu":"opendsu"}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/oauth/src/util/Promises.js":[function(require,module,exports){
function flatPromise() {
    let resolve, reject;
    let promise = new Promise((_resolve, _reject) => {
        resolve = _resolve;
        reject = _reject;
    });

    return {promise, resolve, reject};
}


module.exports = {
    flatPromise
}
},{}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/oauth/src/util/Storage.js":[function(require,module,exports){
class Storage {
    get(key) {
        return localStorage.getItem(key);
    }


    getJSON(key) {
        return JSON.parse(this.get(key));
    }


    set(key, value) {
        localStorage.setItem(key, value);
    }


    setJSON(key, value) {
        this.set(key, JSON.stringify(value));
    }


    remove(key) {
        localStorage.removeItem(key);
    }
}

const getStorage = () => {
    if (!$$.storage) {
        $$.storage = new Storage();
    }

    return $$.storage;
}

module.exports = {
    getStorage
};
},{}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/resolver/index.js":[function(require,module,exports){
(function (Buffer){(function (){
const KeySSIResolver = require("key-ssi-resolver");
const openDSU = require("opendsu");
const keySSISpace = openDSU.loadAPI("keyssi");
const crypto = openDSU.loadAPI("crypto");
const constants = require("../moduleConstants");

let {ENVIRONMENT_TYPES} = require("../moduleConstants.js");
const {getWebWorkerBootScript, getNodeWorkerBootScript} = require("./resolver-utils");
const cache = require("../cache");
const {createOpenDSUErrorWrapper} = require("../error");
let dsuCache = cache.getWeakRefMemoryCache("mainDSUsCache");

const getResolver = () => {
    if (typeof $$.keySSIResolver === "undefined") {
        $$.keySSIResolver = KeySSIResolver.initialize();
    }
    return $$.keySSIResolver;
};

const registerDSUFactory = (type, factory) => {
    KeySSIResolver.DSUFactory.prototype.registerDSUType(type, factory);
};

const createDSU = (templateKeySSI, options, callback) => {
    if (typeof options === "function") {
        callback = options;
        options = {addLog: true};
    }

    if (typeof options === "undefined") {
        options = {};
    }

    if (typeof options.addLog === "undefined") {
        options.addLog = true;
    }

    if (typeof templateKeySSI === "string") {
        try {
            templateKeySSI = keySSISpace.parse(templateKeySSI);
        } catch (e) {
            return callback(createOpenDSUErrorWrapper(`Failed to parse keySSI ${templateKeySSI}`, e));
        }
    }

    const keySSIResolver = getResolver(options);
    keySSIResolver.createDSU(templateKeySSI, options, (err, dsuInstance) => {
        if (err) {
            return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to create DSU instance`, err));
        }

        addDSUInstanceInCache(dsuInstance, callback);
    });
};

const createDSUx = (domain, ssiType, options, callback) => {
    const templateKeySSI = keySSISpace.createTemplateKeySSI(ssiType, domain);
    createDSU(templateKeySSI, options, callback);
}

const createSeedDSU = (domain, options, callback) => {
    const seedSSI = keySSISpace.createTemplateSeedSSI(domain);
    createDSU(seedSSI, options, callback);
}

const createArrayDSU = (domain, arr, options, callback) => {
    const arraySSI = keySSISpace.createArraySSI(domain, arr);
    createDSUForExistingSSI(arraySSI, options, callback);
}

const createConstDSU = (domain, constString, options, callback) => {
    const constSSI = keySSISpace.createConstSSI(domain, constString);
    createDSUForExistingSSI(constSSI, options, callback);
}

const createDSUForExistingSSI = (ssi, options, callback) => {
    if (typeof options === "function") {
        callback = options;
        options = {};
    }
    if (!options) {
        options = {};
    }
    options.useSSIAsIdentifier = true;
    createDSU(ssi, options, callback);
};

const createVersionlessDSU = (filePath, encryptionKey, domain, callback) => {
    const bdnsSpace = require("opendsu").loadApi("bdns");

    if (typeof domain === "function") {
        callback = domain;
        domain = bdnsSpace.getOriginPlaceholder();
    }
    if (typeof encryptionKey === "function") {
        callback = encryptionKey;
        domain = bdnsSpace.getOriginPlaceholder();
        encryptionKey = undefined;
    }

    if(typeof filePath === "function") {
        callback = filePath;
        filePath = crypto.generateRandom(32).toString("hex");
        domain = bdnsSpace.getOriginPlaceholder();
        encryptionKey = undefined;
    }

    if(typeof encryptionKey === "string" && encryptionKey) {
        // specific string must have 32 characters required for versionlessDSU encrypt
        if(encryptionKey.length !== 32) {
            throw new Error(`encryptionKey must have exactly 32 characters (${encryptionKey.length} provided)`)
        }
    }

    const versionlessSSI = keySSISpace.createVersionlessSSI(domain, filePath, encryptionKey);
    createDSU(versionlessSSI, callback);
}

/**
 * Check if the DSU is up to date by comparing its
 * current anchored HashLink with the latest anchored version.
 * If a new anchor is detected refresh the DSU
 */
const getLatestDSUVersion = (dsu, callback) => {
    if(dsu.batchInProgress()){
        return callback(undefined, dsu);
    }
    dsu.getCurrentAnchoredHashLink((err, current) => {
        if (err) {
            return callback(err);
        }

        dsu.getLatestAnchoredHashLink((err, latest) => {
            if (err) {
                return callback(err);
            }

            if (current && current.getHash() === latest.getHash()) {
                // No new version detected
                return callback(undefined, dsu);
            }

            dsu.hasUnanchoredChanges((err, result) => {
                if (err) {
                    return callback(err);
                }

                if (result) {
                    // The DSU is in the process of anchoring - don't refresh it
                    return callback(undefined, dsu);
                }

                // A new version is detected, refresh the DSU content
                dsu.refresh((err) => {
                    if (err) {
                        return callback(err);
                    }
                    return callback(undefined, dsu);
                });
            })
        });
    });
}

const loadDSUVersion = (keySSI, versionHashlink, options, callback) => {
    if (typeof options === "function") {
        callback = options;
        options = {};
    }

    if (typeof keySSI === "string") {
        try {
            keySSI = keySSISpace.parse(keySSI);
        } catch (e) {
            return callback(createOpenDSUErrorWrapper(`Failed to parse keySSI ${keySSI}`, e));
        }
    }

    const keySSIResolver = getResolver(options);
    options.versionHashlink = versionHashlink;
    keySSIResolver.loadDSU(keySSI, options, callback);
}

const getDSUVersionHashlink = (keySSI, versionNumber, callback) => {
    if (typeof keySSI === "string") {
        try {
            keySSI = keySSISpace.parse(keySSI);
        } catch (e) {
            return callback(createOpenDSUErrorWrapper(`Failed to parse keySSI ${keySSI}`, e));
        }
    }
    const anchoringAPI = require("opendsu").loadAPI("anchoring");
    const anchoringX = anchoringAPI.getAnchoringX();
    keySSI.getAnchorId((err, anchorId) => {
        if (err) {
            return callback(err);
        }
        anchoringX.getAllVersions(anchorId, (err, versions) => {
            if (err) {
                return callback(err);
            }

            if (!versions || !versions.length) {
                return callback(createOpenDSUErrorWrapper(`No versions found for anchor ${anchorId}`));
            }
            const versionHashLink = versions[versionNumber];
            if (!versionHashLink) {
                return callback(createOpenDSUErrorWrapper(`Version number ${versionNumber} for anchor ${anchorId} does not exist.`));
            }

            callback(undefined, versionHashLink);
        })
    })
}

const loadDSUVersionBasedOnVersionNumber = (keySSI, versionNumber, callback) => {
    getDSUVersionHashlink(keySSI, versionNumber, (err, versionHashLink) => {
        if (err) {
            return callback(err);
        }

        loadDSUVersion(keySSI, versionHashLink, callback);
    })
}

let tryToRunRecoveryContentFnc = (keySSI, recoveredInstance, options, anchorFakeHistory, anchorFakeLastVersion, callback) => {
    if (typeof options.contentRecoveryFnc === "function") {
        let ignoreError = false;
        try {
            let cb = (err) => {
                ignoreError = true;
                if (err) {
                    return callback(createOpenDSUErrorWrapper(`Failed to recover fallback DSU for keySSI ${keySSI.getIdentifier()}`, err));
                }

                return callback(undefined, recoveredInstance);
            };
            keySSI.getAnchorId((err, anchorId) => {
                if (err) {
                    throw createOpenDSUErrorWrapper(`Surprise error!`, err);
                }
                let {
                    markAnchorForRecovery
                } = require("opendsu").loadApi("anchoring").getAnchoringX();
                markAnchorForRecovery(anchorId, anchorFakeHistory, anchorFakeLastVersion);
                options.contentRecoveryFnc(recoveredInstance, cb);
            });

        } catch (err) {
            if (!ignoreError) {
                return callback(createOpenDSUErrorWrapper(`Caught an error in contentRecoveryFunction`, err));
            }
            throw err;
        }
        //callback already called above
        return;
    }
    callback(undefined, recoveredInstance);
}

const loadFallbackDSU = (keySSI, options, callback) => {
    if (typeof keySSI === "string") {
        try {
            keySSI = keySSISpace.parse(keySSI);
        } catch (e) {
            return callback(createOpenDSUErrorWrapper(`Failed to parse keySSI ${keySSI}`, e));
        }
    }
    const anchoringAPI = require("opendsu").loadAPI("anchoring");
    const anchoringX = anchoringAPI.getAnchoringX();

    keySSI.getAnchorId((err, anchorId) => {
        if (err) {
            return callback(createOpenDSUErrorWrapper(`Failed to get anchorId for keySSI ${keySSI.getIdentifier()}`, err));
        }

        anchoringX.getAllVersions(anchorId, {realHistory:true}, (err, versions) => {
            if (err) {
                return callback(createOpenDSUErrorWrapper(`Failed to get versions for anchorId ${anchorId}`, err));
            }

            if (!versions || !versions.length) {
                return callback(createOpenDSUErrorWrapper(`No versions found for anchorId ${anchorId}`));
            }

            const __loadFallbackDSURecursively = (index) => {
                const versionHashlink = versions[index];
                if (typeof versionHashlink === "undefined") {
                    //we weren't able to load any version of the dsu (const or not)
                    options.addLog = false;
                    return createDSUForExistingSSI(keySSI, options, (err, recoveredInstance) => {
                        if (err) {
                            return callback(err);
                        }

                        return tryToRunRecoveryContentFnc(keySSI, recoveredInstance, options, [], versions[versions.length - 1], callback);
                    });
                }

                loadDSUVersion(keySSI, versionHashlink, options, (err, dsuInstance) => {
                    if (err) {
                        return __loadFallbackDSURecursively(index - 1);
                    }
                    if (index < versions.length - 1) {
                        return tryToRunRecoveryContentFnc(keySSI, dsuInstance, options, versions.slice(0, index), versions[versions.length - 1], callback);
                    }
                    callback(undefined, dsuInstance);
                })
            }

            __loadFallbackDSURecursively(versions.length - 1);
        })
    })
}

const loadDSU = (keySSI, options, callback) => {
    if (typeof options === "function") {
        callback = options;
        options = {};
    }

    if (typeof keySSI === "string") {
        try {
            keySSI = keySSISpace.parse(keySSI);
        } catch (e) {
            return callback(createOpenDSUErrorWrapper(`Failed to parse keySSI ${keySSI}`, e));
        }
    }

    const versionNumber = keySSI.getDSUVersionHint();
    if (Number.isInteger(versionNumber)) {
        return loadDSUVersionBasedOnVersionNumber(keySSI, versionNumber, callback);
    }

    if (options && options.recoveryMode) {
        return loadFallbackDSU(keySSI, options, callback);
    }

    const loadDSU = (addInCache) => {
        
        const keySSIResolver = getResolver(options);
        keySSIResolver.loadDSU(keySSI, options, (err, dsuInstance) => {
            if (err) {
                return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to load DSU`, err));
            }

            if (addInCache) {
                return addDSUInstanceInCache(dsuInstance, callback);
            }

            callback(undefined, dsuInstance);
        });
    };

    if (typeof options === 'object' && options !== null && options.skipCache) {
        return loadDSU(false);
    }

    keySSI.getAnchorId((err, cacheKey) => {
        if (err) {
            return callback(err);
        }
        const cachedDSU = dsuCache.get(cacheKey);
        if (cachedDSU) {
            return getLatestDSUVersion(cachedDSU, callback);
        }
        loadDSU(true);
    })
};

/*
    boot the DSU in a thread
 */
const getDSUHandler = (dsuKeySSI) => {
    if (typeof dsuKeySSI === "string") {
        // validate the dsuKeySSI to ensure it's valid
        try {
            keySSISpace.parse(dsuKeySSI);
        } catch (error) {
            const errorMessage = `Cannot parse keySSI ${dsuKeySSI}`;
            console.error(errorMessage, error);
            throw new Error(errorMessage);
        }
    }

    const syndicate = require("syndicate");

    function DSUHandler() {
        switch ($$.environmentType) {
            case ENVIRONMENT_TYPES.SERVICE_WORKER_ENVIRONMENT_TYPE:
                throw new Error(`service-worker environment is not supported!`);
            case ENVIRONMENT_TYPES.BROWSER_ENVIRONMENT_TYPE:
                if (!window.Worker) {
                    throw new Error("Current environment does not support Web Workers!");
                }

                console.log("[Handler] starting web worker...");

                let blobURL = getWebWorkerBootScript(dsuKeySSI);
                workerPool = syndicate.createWorkerPool({
                    bootScript: blobURL,
                    maximumNumberOfWorkers: 1,
                    workerStrategy: syndicate.WorkerStrategies.WEB_WORKERS,
                });

                setTimeout(() => {
                    // after usage, the blob must be removed in order to avoit memory leaks
                    // it requires a timeout in order for syndicate to be able to get the blob script before it's removed
                    URL.revokeObjectURL(blobURL);
                });

                break;
            case ENVIRONMENT_TYPES.NODEJS_ENVIRONMENT_TYPE: {
                console.log("[Handler] starting node worker...");

                const script = getNodeWorkerBootScript(dsuKeySSI);
                workerPool = syndicate.createWorkerPool({
                    bootScript: script,
                    maximumNumberOfWorkers: 1,
                    workerOptions: {
                        eval: true,
                    },
                });

                break;
            }
            default:
                throw new Error(`Unknown environment ${$$.environmentType}!`);
        }

        const sendTaskToWorker = (task, callback) => {
            workerPool.addTask(task, (err, message) => {
                if (err) {
                    return callback(err);
                }

                let {error, result} =
                    typeof Event !== "undefined" && message instanceof Event ? message.data : message;

                if (error) {
                    return callback(error);
                }

                if (result) {
                    if (result instanceof Uint8Array) {
                        // the buffers sent from the worker will be converted to Uint8Array when sending to parent
                        result = Buffer.from(result);
                    } else {
                        try {
                            result = JSON.parse(result);
                        } catch (error) {
                            // if parsing fails then the string must be an ordinary one so we leave it as it is
                        }
                    }
                }

                callback(error, result);
            });
        };

        this.callDSUAPI = function (fn, ...args) {
            const fnArgs = [...args];
            const callback = fnArgs.pop();

            const parseResult = (error, result) => {
                if (error) {
                    return callback(error);
                }

                // try to recreate keyssi
                try {
                    result = keySSISpace.parse(result);
                } catch (error) {
                    // if it fails, then the result is not a valid KeySSI
                }
                callback(undefined, result);
            };

            sendTaskToWorker({fn, args: fnArgs}, parseResult);
        };

        this.callApi = function (fn, ...args) {
            const apiArgs = [...args];
            const callback = apiArgs.pop();
            sendTaskToWorker({api: fn, args: apiArgs}, callback);
        };
    }

    let res = new DSUHandler();
    let availableFunctions = [
        "addFile",
        "addFiles",
        "addFolder",
        "appendToFile",
        "createFolder",
        "delete",
        //"extractFile",
        //"extractFolder",
        "listFiles",
        "listFolders",
        "mount",
        "readDir",
        "readFile",
        "rename",
        "unmount",
        "writeFile",
        "listMountedDSUs",
        "beginBatch",
        "commitBatch",
        "cancelBatch",
    ];

    function getWrapper(functionName) {
        return function (...args) {
            res.callDSUAPI(functionName, ...args);
        }.bind(res);
    }

    for (let f of availableFunctions) {
        res[f] = getWrapper(f);
    }

    return res;
};

const getRemoteHandler = (dsuKeySSI, remoteURL, presentation) => {
    throw Error("Not available yet");
};

function invalidateDSUCache(dsuKeySSI, callback) {
    try {
        if (typeof dsuKeySSI === "string") {
            dsuKeySSI = keySSISpace.parse(dsuKeySSI);
        }
    } catch (e) {
        console.error(e);
    }
    dsuKeySSI.getAnchorId((err, cacheKey) => {
        if (err) {
            return callback(err);
        }
        if (cacheKey) {
            delete dsuCache.set(cacheKey, undefined);
        }

        callback();
    });
}

function addDSUInstanceInCache(dsuInstance, callback) {
    return callback(undefined, dsuInstance);
    /*dsuInstance.getKeySSIAsObject((err, keySSI) => {
        if (err) {
            return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to retrieve keySSI`, err));
        }
        keySSI.getAnchorId((err, cacheKey) => {
            if (err) {
                return callback(err);
            }
            dsuCache.set(cacheKey, dsuInstance);
            callback(undefined, dsuInstance);
        });
    });*/
}

/**
 *
 * @param keySSI
 * @param callback
 * @returns: (error -> error.rootCause: network | throttler | business | unknown, result: true | false)
 */
function dsuExists(keySSI, callback) {
    const anchoringAPI = require("opendsu").loadAPI("anchoring");
    const anchoringX = anchoringAPI.getAnchoringX();
    if (typeof keySSI === "string") {
        try {
            keySSI = keySSISpace.parse(keySSI);
        } catch (e) {
            return callback(createOpenDSUErrorWrapper(`Failed to parse KeySSI <${keySSI}>`, e, constants.ERROR_ROOT_CAUSE.DATA_INPUT_ERROR));
        }
    }
    keySSI.getAnchorId((err, anchorId) => {
        if (err) {
            return callback(createOpenDSUErrorWrapper(`Failed get anchor id`, err));
        }

        anchoringX.getLastVersion(anchorId, (err, anchorVersion) => {
            if (err) {
                if (err.rootCause === constants.ERROR_ROOT_CAUSE.MISSING_DATA_ERROR) {
                    return callback(undefined, false);
                }

                return callback(createOpenDSUErrorWrapper(`Failed to get version for anchor id <${anchorId}>`, err));
            }

            if (typeof anchorVersion === "undefined" || anchorVersion === "") {
                return callback(undefined, false);
            }

            callback(undefined, true);
        })
    })
}

module.exports = {
    createDSU,
    createDSUx,
    createSeedDSU,
    createConstDSU,
    createArrayDSU,
    createDSUForExistingSSI,
    createVersionlessDSU,
    loadDSU,
    getDSUHandler,
    registerDSUFactory,
    invalidateDSUCache,
    loadDSUVersion,
    dsuExists
};

}).call(this)}).call(this,require("buffer").Buffer)

},{"../cache":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/cache/index.js","../error":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/error/index.js","../moduleConstants":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/moduleConstants.js","../moduleConstants.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/moduleConstants.js","./resolver-utils":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/resolver/resolver-utils.js","buffer":false,"key-ssi-resolver":"key-ssi-resolver","opendsu":"opendsu","syndicate":"syndicate"}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/resolver/resolver-utils.js":[function(require,module,exports){
(function (global,__dirname){(function (){
function getWebWorkerBootScript(dsuKeySSI) {
    const scriptLocation = document.currentScript
        ? document.currentScript
        : new Error().stack.match(/([^ ^(\n])*([a-z]*:\/\/\/?)*?[a-z0-9/\\]*\.js/gi)[0];
    let blobURL = URL.createObjectURL(
        new Blob(
            [
                `
                (function () {
                    importScripts("${scriptLocation}");
                    require("opendsu").loadApi("boot")("${dsuKeySSI}");                                    
                })()
                `,
            ],
            { type: "application/javascript" }
        )
    );
    return blobURL;
}

function getNodeWorkerBootScript(dsuKeySSI) {
    const pathAPI = require("path");
    const openDSUScriptPath = pathAPI.join(__dirname, "../../../", global.bundlePaths.openDSU);
    const script = `require("${openDSUScriptPath}");require('opendsu').loadApi('boot')('${dsuKeySSI}')`;
    return script;
}

module.exports = {
    getWebWorkerBootScript,
    getNodeWorkerBootScript,
};

}).call(this)}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},"/modules/opendsu/resolver")

},{"path":false}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/sc/index.js":[function(require,module,exports){
/*
    Security Context related functionalities

 */

const constants = require("../moduleConstants");
const openDSU = require("opendsu");
const config = openDSU.loadAPI("config")
const crypto = openDSU.loadAPI("crypto")
const MainDSU = require("./lib/MainDSU");
const SecurityContext = require("./lib/SecurityContext");

const getVaultDomain = (callback) => {
    config.getEnv(constants.VAULT_DOMAIN, (err, vaultDomain) => {
        if (err || !vaultDomain) {
            console.log(`The property <${constants.DOMAIN}> is deprecated in environment.js. Use the property <${constants.VAULT_DOMAIN}> instead`)
            return config.getEnv(constants.DOMAIN, callback);
        }

        callback(undefined, vaultDomain);
    });
}

const getDIDDomain = (callback) => {
    config.getEnv(constants.DID_DOMAIN, callback);
}

const securityContextIsInitialised = () => {
    if (typeof $$.sc === "undefined") {
        return false;
    }

    return $$.sc.isInitialised();
}

const getSecurityContext = () => {
    if (typeof $$.sc === "undefined") {
        $$.sc = new SecurityContext();
    }

    return $$.sc;
};

const refreshSecurityContext = (pin) => {
    $$.sc = new SecurityContext(undefined, pin);
    return $$.sc;
};

const getMainEnclave = (callback) => {
    if (!$$.sc && !callback) {
        return;
    }
    const sc = getSecurityContext();
    if (sc.isInitialised()) {
        return sc.getMainEnclaveDB(callback);
    } else {
        sc.on("initialised", () => {
            sc.getMainEnclaveDB(callback);
        });
    }
}

const getSharedEnclave = (callback) => {
    const sc = getSecurityContext();
    if (sc.isInitialised()) {
        sc.getSharedEnclaveDB(callback);
    } else {
        sc.on("initialised", () => {
            sc.getSharedEnclaveDB(callback);
        });
    }
}

const sharedEnclaveExists = () => {
    const sc = getSecurityContext();
    return sc.sharedEnclaveExists();
}

const configEnvironment = (config, refreshSC, callback) => {
    if (typeof refreshSC === "function") {
        callback = refreshSC;
        refreshSC = true;
    }
    MainDSU.getMainDSU(async (err, mainDSU) => {
        if (err) {
            return callback(createOpenDSUErrorWrapper("Failed to get main DSU", err));
        }

        let [error, env] = await $$.call(mainDSU.readFile, constants.ENVIRONMENT_PATH);
        if (error) {
            return callback(createOpenDSUErrorWrapper("Failed to read env", error));
        }

        if(crypto.sha256(JSON.parse(env.toString())) === crypto.sha256(config)){
            return callback(undefined, getSecurityContext());
        }

        mainDSU.startOrAttachBatch((err, batchId) => {
            if (err) {
                return callback(createOpenDSUErrorWrapper("Failed to begin batch", err));
            }
            mainDSU.writeFile(constants.ENVIRONMENT_PATH, JSON.stringify(config), async (err) => {
                if (err) {
                    const writeFileError = createOpenDSUErrorWrapper("Failed to write env", err);
                    try {
                        await mainDSU.cancelBatchAsync(batchId);
                    }catch (e) {
                        //not that important
                        //return callback(createOpenDSUErrorWrapper("Failed to cancel batch", e, writeFileError));
                        console.log(e);
                    }
                    return callback(writeFileError);
                }

                mainDSU.commitBatch(batchId, (err) => {
                    if (err) {
                        return callback(createOpenDSUErrorWrapper("Failed to commit batch", err));
                    }
                    if (refreshSC) {
                        const pin = getSecurityContext().getPaddedPIN();
                        const sc = refreshSecurityContext(pin);
                        sc.on("initialised", () => callback(undefined, sc));
                    } else {
                        const sc = getSecurityContext();
                        if (securityContextIsInitialised()) {
                            return callback(undefined, sc);
                        }

                        sc.on("initialised", () => {
                            callback(undefined, sc)
                        });
                    }
                });
            });
        });
    });
}

const setEnclave = (enclave, type, callback) => {
    config.readEnvFile((err, config) => {
        if (err) {
            return callback(err);
        }
        enclave.getDID((err, did) => {
            if (err) {
                return callback(err);
            }

            config[openDSU.constants[type].DID] = did;
            enclave.getKeySSI((err, keySSI) => {
                if (err) {
                    return callback(err);
                }

                setEnclaveKeySSI(type, keySSI, config);

                config[openDSU.constants[type].TYPE] = enclave.getEnclaveType();
                configEnvironment(config, callback);
            })
        })
    })
}

const setEnclaveKeySSI = (type, keySSI, config) => {
    const sc = getSecurityContext();
    const pin = sc.getPaddedPIN();
    if (typeof keySSI !== "string") {
        keySSI = keySSI.getIdentifier();
    }

    if (type != "SHARED_ENCLAVE" || pin == undefined) {
        config[openDSU.constants[type].KEY_SSI] = keySSI;
        return;
    }

    const decodedBase58 = crypto.decodeBase58(keySSI);
    const encryptedKey = crypto.encrypt(decodedBase58, pin)
    const base58EncryptedKey = crypto.encodeBase58(encryptedKey);
    config[openDSU.constants[type].KEY_SSI] = base58EncryptedKey;
}

const deleteEnclave = (type, callback) => {
    config.readEnvFile((err, env) => {
        if (err) {
            return callback(err);
        }

        delete env[openDSU.constants[type].DID];
        delete env[openDSU.constants[type].KEY_SSI];
        delete env[openDSU.constants[type].TYPE];
        configEnvironment(env, callback);
    })
}

const deleteSharedEnclave = (callback) => {
    deleteEnclave("SHARED_ENCLAVE", callback);
}

const setMainEnclave = (enclave, callback) => {
    setEnclave(enclave, "MAIN_ENCLAVE", callback);
};

const setSharedEnclave = (enclave, callback) => {
    setEnclave(enclave, "SHARED_ENCLAVE", callback);
};

const setPIN = (pin) => {
    const sc = getSecurityContext();
    sc.setPIN(pin);
}

const isPINNeeded = async () => {
    const sc = getSecurityContext();
    return await sc.isPINNeeded();
}

const mainEnclaveIsInitialised = () => {
    return securityContextIsInitialised();
};

const MAINDIDKEY = "WALLET_MAIN_DID";
const MAINDIDKEYFALLBACK = "mainAppDID";
const setMainDID = (did, callback) => {
    config.setEnv(MAINDIDKEY, did, callback);
}

const setMainDIDAsync = (did) =>{
    return $$.promisify(setMainDID)(did);
}

const getMainDID = (callback) => {
    let keys = [MAINDIDKEY, MAINDIDKEYFALLBACK];
    config.readEnvFile((err, env)=>{
        if(err){
            return callback(err);
        }
        for(let key of keys){
            if(env[key]){
                return callback(undefined, env[key]);
            }
        }
        return callback(undefined, undefined);
    });
}

const getMainDIDAsync = () =>{
    return $$.promisify(getMainDID)();
}

module.exports = {
    setMainDSU: MainDSU.setMainDSU,
    getMainDSU: MainDSU.getMainDSU,
    getVaultDomain,
    getSecurityContext,
    refreshSecurityContext,
    getDIDDomain,
    securityContextIsInitialised,
    getMainEnclave,
    setMainEnclave,
    getSharedEnclave,
    setSharedEnclave,
    setEnclave,
    deleteSharedEnclave,
    configEnvironment,
    sharedEnclaveExists,
    setPIN,
    setEnclaveKeySSI,
    isPINNeeded,
    mainEnclaveIsInitialised,
    setMainDID,
    getMainDID,
    setMainDIDAsync,
    getMainDIDAsync,
    getMainDSUForNode:MainDSU.getMainDSUForNode
};

},{"../moduleConstants":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/moduleConstants.js","./lib/MainDSU":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/sc/lib/MainDSU.js","./lib/SecurityContext":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/sc/lib/SecurityContext.js","opendsu":"opendsu"}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/sc/lib/InMemoryMainDSU.js":[function(require,module,exports){
(function (Buffer){(function (){
function InMemoryMainDSU() {
    const obj = {};
    let batchInProgress = false;
    obj["/environment.json"] = Buffer.from(JSON.stringify({
        vaultDomain: "vault",
        didDomain: "vault"
    }))

    obj["environment.json"] = obj["/environment.json"];

    const preventUpdateOutsideBatch = (updateFn, ...args) => {
        if($$.LEGACY_BEHAVIOUR_ENABLED){
            return updateFn(...args);
        }

        if (!this.batchInProgress()) {
            const callback = args.pop();
            return callback(Error("Batch not started. Use safeBeginBatch() or safeBeginBatchAsync before calling this method."));
        }

        updateFn(...args);
    }
    const convertUpdateFnToAsync = (updateFn, ...args) => {
        if (!this.batchInProgress()) {
            throw Error("No batch has been started");
        }

        return $$.promisify(updateFn)(...args);
    }

    const convertGetFunctionToAsync = (getFn, ...args) => {
        return $$.promisify(getFn)(...args);
    }

    this.writeFile = (path, data, callback) => {
        if (!path.startsWith("/")) {
            path = `/${path}`;
        }

        const _writeFile = (path, data, callback) => {
            obj[path] = data;
            callback();
        }
        preventUpdateOutsideBatch(_writeFile, path, data, callback);
    }

    this.writeFileAsync = async (path, data) => {
        return convertUpdateFnToAsync(this.writeFile, path, data);
    }

    this.readFile = (path, callback) => {
        if (!path.startsWith("/")) {
            path = `/${path}`;
        }
        callback(undefined, obj[path]);
    }

    this.readFileAsync = async (path) => {
        return convertGetFunctionToAsync(this.readFile, path);
    }

    this.batchInProgress = () => {
        return batchInProgress;
    }

    this.safeBeginBatch = (wait, callback) => {
        if(typeof wait === "function"){
            callback = wait;
            wait = false;
        }
        if (this.batchInProgress()) {
            return callback(Error("Batch already in progress"));
        }
        batchInProgress = true;
        callback();
    }

    this.startOrAttachBatch = (callback) => {
        return this.safeBeginBatch(true, callback);
    }

    this.startOrAttachBatchAsync = ()=>{
        return convertGetFunctionToAsync(this.startOrAttachBatch);
    }

    this.safeBeginBatchAsync = async (wait) => {
        return convertGetFunctionToAsync(this.safeBeginBatch, wait);
    }

    this.commitBatch = (batchId, callback) => {
        if(typeof callback === "undefined"){
            callback = batchId;
            batchId = undefined;
        }
        batchInProgress = false;
        callback();
    }

    this.commitBatchAsync = async (batchId) => {
        convertUpdateFnToAsync(this.commitBatch);
    }

    this.refresh = (callback)=>{
        callback();
    }
}

module.exports = InMemoryMainDSU;
}).call(this)}).call(this,require("buffer").Buffer)

},{"buffer":false}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/sc/lib/MainDSU.js":[function(require,module,exports){
const constants = require("../../moduleConstants");
const {getURLForSsappContext} = require("../../utils/getURLForSsappContext");
const openDSU = require("opendsu");
const http = openDSU.loadAPI("http")
const keySSISpace = openDSU.loadAPI("keyssi");
const resolver = openDSU.loadAPI("resolver");

const setMainDSU = (mainDSU) => {
    return setGlobalVariable("rawDossier", mainDSU);
};

function getMainDSU(callback) {
    callback = $$.makeSaneCallback(callback);
    if (globalVariableExists("rawDossier")) {
        return callback(undefined, getGlobalVariable("rawDossier"));
    }
    switch ($$.environmentType) {
        case constants.ENVIRONMENT_TYPES.WEB_WORKER_ENVIRONMENT_TYPE:
        case constants.ENVIRONMENT_TYPES.SERVICE_WORKER_ENVIRONMENT_TYPE:

        function __getMainDSUFromSw() {
            if (!globalVariableExists("rawDossier")) {
                setTimeout(() => {
                    __getMainDSUFromSw()
                }, 100);
                return;
            }
            return callback(undefined, getGlobalVariable("rawDossier"));
        }

            return __getMainDSUFromSw();
        case constants.ENVIRONMENT_TYPES.BROWSER_ENVIRONMENT_TYPE:
            return getMainDSUForIframe(callback);
        case constants.ENVIRONMENT_TYPES.NODEJS_ENVIRONMENT_TYPE:
            return getMainDSUForNode(callback);
        default:
            return callback(Error("Main DSU does not exist in the current context."));
    }
}

function getMainDSUForNode(callback) {
    if (process.env.MAIN_WALLET) {
        const resolver = require("opendsu").loadAPI("resolver");
        return resolver.loadDSU(process.env.MAIN_WALLET, (err, mainDSU) => {
            if (err) {
                return callback(err);
            }

            setMainDSU(mainDSU);
            callback(undefined, mainDSU);
        });
    }
    const InMemoryMainDSU = require("./InMemoryMainDSU");
    const mainDSU = new InMemoryMainDSU();
    console.log("Warning: Initializing in memory wallet ...");
    setMainDSU(mainDSU);
    callback(undefined, mainDSU);
}

function getMainDSUForIframe(callback) {
    let mainDSU = getGlobalVariable("rawDossier");
    if (mainDSU) {
        return callback(undefined, mainDSU);
    }

    http.doGet(getURLForSsappContext("/getSSIForMainDSU"), (err, res) => {
        if (err || res.length === 0) {
            return callback(createOpenDSUErrorWrapper("Failed to get main DSU SSI", err));
        }

        let mainSSI = keySSISpace.parse(res);
        resolver.loadDSU(mainSSI, (err, mainDSU) => {
            if (err) {
                return callback(createOpenDSUErrorWrapper("Failed to load main DSU ", err));
            }

            setMainDSU(mainDSU);
            callback(undefined, mainDSU);
        });
    });
}

module.exports = {
    getMainDSU,
    setMainDSU,
    getMainDSUForNode
}

},{"../../moduleConstants":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/moduleConstants.js","../../utils/getURLForSsappContext":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/utils/getURLForSsappContext.js","./InMemoryMainDSU":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/sc/lib/InMemoryMainDSU.js","opendsu":"opendsu"}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/sc/lib/SecurityContext.js":[function(require,module,exports){
const constants = require("../../moduleConstants");
const {createOpenDSUErrorWrapper} = require("../../error");

function SecurityContext(target, PIN) {
    target = target || this;

    const ObservableMixin = require("../../utils/ObservableMixin");
    ObservableMixin(target);
    const openDSU = require("opendsu");
    const config = openDSU.loadAPI("config");
    const enclaveAPI = openDSU.loadAPI("enclave");
    const keySSIApi = openDSU.loadAPI("keyssi");
    const crypto = openDSU.loadAPI("crypto");
    let enclave;
    let sharedEnclave;
    let storageDSU;
    let scDSUKeySSI;
    let mainDID;
    let paddedPIN;

    let initialised = false;
    let pinNeeded = false;

    const initSharedEnclave = async () => {
        let sharedEnclaveType;
        let sharedEnclaveKeySSI;
        try {
            sharedEnclaveType = await $$.promisify(config.getEnv)(constants.SHARED_ENCLAVE.TYPE);
        } catch (e) {
            return;
        }
        if (!sharedEnclaveType) {
            return;
        }
        try {
            sharedEnclaveKeySSI = await $$.promisify(config.getEnv)(constants.SHARED_ENCLAVE.KEY_SSI);
        } catch (e) {
            if (sharedEnclaveType === constants.ENCLAVE_TYPES.WALLET_DB_ENCLAVE) {
                throw Error(`A key SSI should be provided when creating a WalletDB enclave`);
            }
        }

        if (PIN == undefined) {
            try {
                keySSIApi.parse(sharedEnclaveKeySSI);
                sharedEnclave = enclaveAPI.createEnclave(sharedEnclaveType, sharedEnclaveKeySSI);
                return sharedEnclave;
            } catch (err) {
                pinNeeded = true;
                sharedEnclave = new Promise((res) => {
                    target.on("pinSet", async () => {
                        await initSharedEnclave();
                        pinNeeded = false;
                        res(sharedEnclave)
                    })
                })
                return;
            }
        } else {
            const decodedBase58 = crypto.decodeBase58(sharedEnclaveKeySSI);
            const decryptedKey = crypto.decrypt(decodedBase58, paddedPIN);
            const keySSI = crypto.encodeBase58(decryptedKey);
            try {
                sharedEnclave = enclaveAPI.createEnclave(sharedEnclaveType, keySSI);
            } catch (e) {
                throw Error(e);
            }
        }
    }

    target.init = async () => {
        let enclaveType;
        let enclaveDID;
        try {
            enclaveType = await $$.promisify(config.getEnv)(constants.MAIN_ENCLAVE.TYPE);
        } catch (e) {
            throw createOpenDSUErrorWrapper(`Failed to get env enclaveType`, e);
        }

        if (typeof enclaveType === "undefined") {
            enclaveType = constants.ENCLAVE_TYPES.MEMORY_ENCLAVE;
        }

        try {
            enclaveDID = await $$.promisify(config.getEnv)(constants.MAIN_ENCLAVE.DID);
        } catch (e) {
            throw createOpenDSUErrorWrapper(`Failed to get env enclaveDID`, e);
        }

        enclave = enclaveAPI.createEnclave(enclaveType);
        const __saveEnclaveDIDAndFinishInit = async () => {
            if (typeof enclaveDID === "undefined") {
                enclaveDID = await $$.promisify(enclave.getDID)();
                try {
                    await $$.promisify(config.setEnv)(constants.MAIN_ENCLAVE.DID, enclaveDID)
                } catch (e) {
                    throw createOpenDSUErrorWrapper(`Failed to set env enclaveDID`, e);
                }
            }

            await initSharedEnclave();

            if (!sharedEnclave || isPromise(sharedEnclave)) {
                return finishInit();
            }
            if (!sharedEnclave.isInitialised()) {
                sharedEnclave.on("initialised", () => {
                    finishInit();
                });
            } else {
                finishInit();
            }
        }

        if (enclave.isInitialised()) {
            __saveEnclaveDIDAndFinishInit()
        } else {
            enclave.on("initialised", async () => {
                __saveEnclaveDIDAndFinishInit();
            });
        }
    }

    const finishInit = () => {
        initialised = true;
        target.finishInitialisation();
        target.dispatchEvent("initialised")
    }

    target.registerDID = (didDocument, callback) => {
        let privateKeys;
        try {
            privateKeys = didDocument.getPrivateKeys();
        } catch (e) {
            return callback(createOpenDSUErrorWrapper(`Failed to save new private key and public key in security context`, e));
        }
        if (!Array.isArray(privateKeys)) {
            privateKeys = [privateKeys]
        }
        enclave.storeDID(didDocument, didDocument, privateKeys, callback);
    };

    target.addPrivateKeyForDID = (didDocument, privateKey, callback) => {
        enclave.addPrivateKeyForDID(didDocument, privateKey, callback);
    }

    target.registerKeySSI = (forDID, keySSI, callback) => {
        const generateUid = require("swarmutils").generateUid;
        const alias = generateUid(10).toString("hex");
        if (sharedEnclave) {
            sharedEnclave.storeSeedSSI(forDID, keySSI, alias, err => {
                if (err) {
                    return callback(err);
                }

                callback(undefined, alias);
            })
        } else {
            enclave.storeSeedSSI(forDID, keySSI, alias, err => {
                if (err) {
                    return callback(err);
                }

                callback(undefined, alias);
            })
        }
    };

    target.signForKeySSI = (forDID, keySSI, data, callback) => {
        enclave.signForKeySSI(forDID, keySSI, data, (err, signature) => {
            if (err) {
                sharedEnclave.signForKeySSI(forDID, keySSI, data, callback);
                return;
            }

            callback(undefined, signature);
        });
    }

    target.signAsDID = (didDocument, data, callback) => {
        enclave.signForDID(didDocument, didDocument, data, callback);
    }

    target.verifyForDID = (didDocument, data, signature, callback) => {
        enclave.verifyForDID(didDocument, didDocument, data, signature, callback);
    }


    target.encryptForDID = (senderDIDDocument, receiverDIDDocument, message, callback) => {
        enclave.encryptMessage(senderDIDDocument, senderDIDDocument, receiverDIDDocument, message, callback);
    };

    target.decryptAsDID = (didDocument, encryptedMessage, callback) => {
        enclave.decryptMessage(didDocument, didDocument, encryptedMessage, callback)
    }

    target.isInitialised = () => {
        return initialised;
    }

    target.getDB = (callback) => {
        const dbApi = openDSU.loadAPI("db");
        const db = dbApi.getWalletDB(scDSUKeySSI, "defaultDB")
        db.on("initialised", () => {
            callback(undefined, db);
        })
    }

    target.getDSU = (callback) => {
        callback(undefined, storageDSU);
    }

    const wrapEnclave = (asDID, enclave) => {
        const wrappedEnclave = {};
        let asyncDBMethods = ["insertRecord", "updateRecord", "getRecord", "deleteRecord", "filter", "getKeySSI", "readKey", "writeKey", "getAllRecords", "addIndex"];
        for (let i = 0; i < asyncDBMethods.length; i++) {
            wrappedEnclave[asyncDBMethods[i]] = (...args) => {
                return enclave[asyncDBMethods[i]](asDID, ...args);
            }

            wrappedEnclave[`${asyncDBMethods[i]}Async`] = $$.promisify(wrappedEnclave[asyncDBMethods[i]]);
        }

        Object.keys(enclave).forEach(methodName => {
            if (typeof wrappedEnclave[methodName] === "undefined") {
                wrappedEnclave[methodName] = (...args) => {
                    return enclave[methodName](asDID, ...args);
                }
            }
        })
        return wrappedEnclave;
    }
    target.getMainEnclaveDB = (asDID, callback) => {
        if (typeof asDID === "function") {
            callback = asDID;
            asDID = mainDID;
        }

        let mainEnclaveDB;
        if (target.isInitialised()) {
            mainEnclaveDB = wrapEnclave(asDID, enclave);
            if (typeof callback === "function") {
                callback(undefined, mainEnclaveDB);
            }
            return mainEnclaveDB;
        } else {
            enclave.on("initialised", () => {
                mainEnclaveDB = wrapEnclave(asDID, enclave);
                callback(undefined, mainEnclaveDB);
            })
        }
    }

    target.getSharedEnclaveDB = (asDID, callback) => {
        if (typeof asDID === "function") {
            callback = asDID;
            asDID = mainDID;
        }

        let sharedEnclaveDB;
        const __getWrappedEnclave = () => {
            if (!sharedEnclave) {
                return callback(Error(`No shared db found`))
            }
            if (isPromise(sharedEnclave)) {
                sharedEnclave.then((sharedEnclave) => {
                    sharedEnclaveDB = wrapEnclave(asDID, sharedEnclave);
                    callback(undefined, sharedEnclaveDB);
                })
                return;
            }
            sharedEnclaveDB = wrapEnclave(asDID, sharedEnclave);
            callback(undefined, sharedEnclaveDB);
        }
        if (target.isInitialised()) {
            __getWrappedEnclave();
        } else {
            enclave.on("initialised", () => {
                __getWrappedEnclave();
            })
        }
    }

    target.sharedEnclaveExists = () => {
        if (typeof sharedEnclave === "undefined") {
            return false;
        }

        return true;
    }

    target.setPIN = (pin) => {
        PIN = pin;
        if (PIN == undefined) return;
        paddedPIN = pad(pin, 32);
        target.dispatchEvent("pinSet");
    }

    target.getPIN = () => {
        return PIN;
    }

    target.getPaddedPIN = () => {
        return paddedPIN;
    }

    target.isPINNeeded = async () => {

        return new Promise((res) => {
            if (initialised) {
                res(pinNeeded);
            } else {
                target.on("initialised", async () => {
                    res(pinNeeded)
                })
            }
        })

    }

    const pad = (key, length) => {
        if (key == undefined) return;
        const padding = "0".repeat(length - key.length);
        return key + padding;
    }

    function isPromise(p) {
        if (typeof p === 'object' && typeof p.then === 'function') {
            return true;
        }
        return false;
    }

    paddedPIN = pad(PIN, 32);

    const bindAutoPendingFunctions = require("../../utils/BindAutoPendingFunctions").bindAutoPendingFunctions;
    bindAutoPendingFunctions(target, ["on", "off", "isInitialised", "init", "sharedEnclaveExists", "dispatchEvent", "isPINNeeded"]);
    target.init();
    return target;
}

module.exports = SecurityContext;

},{"../../error":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/error/index.js","../../moduleConstants":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/moduleConstants.js","../../utils/BindAutoPendingFunctions":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/utils/BindAutoPendingFunctions.js","../../utils/ObservableMixin":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/utils/ObservableMixin.js","opendsu":"opendsu","swarmutils":"swarmutils"}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/storage/DSUStorage.js":[function(require,module,exports){
const { fetch } = require("./utils");

// helpers

function doDownload(url, expectedResultType, callback) {
  fetch(url)
    .then((response) => {
      if (!response.ok) {
        throw new Error(response.statusText);
      }
      response[expectedResultType]()
        .then((data) => {
          return callback(undefined, data);
        })
        .catch((err) => {
          throw err;
        });
    })
    .catch((err) => {
      return callback(err);
    });
}

function doUpload(url, data, callback) {
  fetch(url, {
    method: "POST",
    body: data,
  })
    .then((response) => {
      return response.json().then((data) => {
        if (!response.ok || response.status != 201) {
          let errorMessage = "";
          if (Array.isArray(data) && data.length) {
            errorMessage = `${data[0].error.message}. Code: ${data[0].error.code}`;
          } else if (typeof data === "object") {
            errorMessage = data.message ? data.message : JSON.stringify(data);
          }

          let error = new Error(errorMessage);
          error.data = data;
          throw error;
        }

        if (Array.isArray(data)) {
          let responses = [];
          for (const item of data) {
            console.log(`Uploaded ${item.file.name} to ${item.result.path}`);
            responses.push(item.result.path);
          }
          callback(undefined, responses.length > 1 ? responses : responses[0]);
        }
      });
    })
    .catch((err) => {
      return callback(err);
    });
}

function doFileUpload(path, files, options, callback) {
  if (typeof options === "function") {
    callback = options;
    options = undefined;
  }

  const formData = new FormData();
  let inputType = "file";

  if (Array.isArray(files)) {
    for (const attachment of files) {
      inputType = "files[]";
      formData.append(inputType, attachment);
    }
  } else {
    formData.append(inputType, files);
  }

  let url = `/upload?path=${path}&input=${inputType}`;
  if (typeof options !== "undefined" && options.preventOverwrite) {
    url += "&preventOverwrite=true";
  }
  doUpload(url, formData, callback);
}

function doRemoveFile(url, callback) {
  fetch(url, { method: "DELETE" })
    .then((response) => {
      if (!response.ok) {
        throw new Error(response.statusText);
      }
      callback();
    })
    .catch((err) => {
      return callback(err);
    });
}

function performRemoval(filePathList, callback) {
  if (!Array.isArray(filePathList)) {
    filePathList = [filePathList];
  }

  let errors = [];
  let deletedFiles = [];

  let deleteFile = (path) => {
    let filename = path;
    if (path[0] !== "/") {
      path = "/" + path;
    }
    let url = "/delete" + path;
    doRemoveFile(url, (err) => {
      if (err) {
        //console.log(err);
        errors.push({
          filename: filename,
          message: err.message,
        });
      } else {
        deletedFiles.push(filename);
      }

      if (filePathList.length > 0) {
        return deleteFile(filePathList.shift());
      }
      callback(errors.length ? errors : undefined, deletedFiles);
    });
  };

  deleteFile(filePathList.shift());
}

// service

class DSUStorage {
  constructor() {
    this.directAccessEnabled = false;
  }

  enableDirectAccess(callback) {
    let self = this;

    function addFunctionsFromMainDSU() {
      if (!self.directAccessEnabled) {
        let sc = require("opendsu").loadAPI("sc");
        let availableFunctions = [
          "addFile",
          "addFiles",
          "addFolder",
          "appendToFile",
          "createFolder",
          "delete",
          "extractFile",
          "extractFolder",
          "getArchiveForPath",
          "getCreationSSI",
          "getKeySSI",
          "listFiles",
          "listFolders",
          "mount",
          "readDir",
          "readFile",
          "rename",
          "unmount",
          "writeFile",
          "listMountedDSUs",
          "beginBatch",
          "commitBatch",
          "cancelBatch",
        ];

        sc.getMainDSU((err, mainDSU) => {
          for (let f of availableFunctions) {
            self[f] = mainDSU[f];
          }
          self.directAccessEnabled = true;
          callback(undefined, true);
        });
      } else {
        callback(undefined, true);
      }
    }

    addFunctionsFromMainDSU();
  }

  call(name, ...args) {
    if (args.length === 0) {
      throw Error(
        "Missing arguments. Usage: call(functionName, arg1, arg2 ... callback)"
      );
    }

    const callback = args.pop();
    const url =
      "/api?" +
      new URLSearchParams({ name: name, arguments: JSON.stringify(args) });
    fetch(url, { method: "GET" })
      .then((response) => {
        if (!response.ok) {
          throw new Error(response.statusText);
        }
        return response.json();
      })
      .then((result) => {
        callback(...result);
      })
      .catch((err) => {
        return callback(err);
      });
  }

  setObject(path, data, callback) {
    try {
      let dataSerialized = JSON.stringify(data);
      this.setItem(path, dataSerialized, callback);
    } catch (e) {
      callback(createOpenDSUErrorWrapper("setObject failed", e));
    }
  }

  getObject(path, callback) {
    this.getItem(path, "json", function (err, res) {
      if (err || !res) {
        return callback(undefined, undefined);
      }
      callback(undefined, res);
    });
  }

  setItem(path, data, callback) {
    if (!this.directAccessEnabled) {
      let segments = path.split("/");
      let fileName = segments.splice(segments.length - 1, 1)[0];
      path = segments.join("/");
      if (!path) {
        path = "/";
      }
      let url = `/upload?path=${path}&filename=${fileName}`;
      doUpload(url, data, callback);
    } else {
      this.writeFile(path, data, callback);
    }
  }

  getItem(path, expectedResultType, callback) {
    if (typeof expectedResultType === "function") {
      callback = expectedResultType;
      expectedResultType = "arrayBuffer";
    }

    if (!this.directAccessEnabled) {
      if (path[0] !== "/") {
        path = "/" + path;
      }

      path = "/download" + path;
      doDownload(path, expectedResultType, callback);
    } else {
      this.readFile(path, function (err, res) {
        if (err) {
          return callback(err);
        }
        try {
          if (expectedResultType == "json") {
            res = JSON.parse(res.toString());
          }
        } catch (err) {
          return callback(err);
        }
        callback(undefined, res);
      });
    }
  }

  uploadFile(path, file, options, callback) {
    doFileUpload(...arguments);
  }

  uploadMultipleFiles(path, files, options, callback) {
    doFileUpload(...arguments);
  }

  deleteObjects(objects, callback) {
    performRemoval(objects, callback);
  }

  removeFile(filePath, callback) {
    console.log("[Warning] - obsolete. Use DSU.deleteObjects");
    performRemoval([filePath], callback);
  }

  removeFiles(filePathList, callback) {
    console.log("[Warning] - obsolete. Use DSU.deleteObjects");
    performRemoval(filePathList, callback);
  }
}

let dsuStorageInstance;

function getDSUStorage() {
  if (typeof dsuStorageInstance === "undefined") {
    dsuStorageInstance = new DSUStorage();
  }

  return dsuStorageInstance;
}

module.exports = getDSUStorage;

},{"./utils":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/storage/utils.js","opendsu":"opendsu"}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/storage/index.js":[function(require,module,exports){
module.exports = {
  getDSUStorage: require("./DSUStorage")
};

},{"./DSUStorage":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/storage/DSUStorage.js"}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/storage/utils.js":[function(require,module,exports){
function promisify(fun) {
  return function (...args) {
    return new Promise((resolve, reject) => {
      function callback(err, result) {
        if (err) {
          reject(err);
        } else {
          resolve(result);
        }
      }

      args.push(callback);

      fun.call(this, ...args);
    });
  };
}

function executeFetch(url, ...args) {
  // check if we need to add the BASE_URL to the prefix of the url
  const isBaseUrlSet =
    $$ &&
    $$.SSAPP_CONTEXT &&
    $$.SSAPP_CONTEXT.BASE_URL &&
    $$.SSAPP_CONTEXT.SEED &&
    url.indexOf($$.SSAPP_CONTEXT.BASE_URL) !== 0;
  if (isBaseUrlSet && url.indexOf("data:image") !== 0) {
    // BASE_URL ends with / so make sure that url doesn't already start with /
    url = `${$$.SSAPP_CONTEXT.BASE_URL}${
      url.indexOf("/") === 0 ? url.substr(1) : url
    }`;
  }

  const http = require("opendsu").loadAPI("http");
  return http.fetch(url, ...args);
}

module.exports = {
  promisify,
  fetch: executeFetch,
};

},{"opendsu":"opendsu"}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/svd/index.js":[function(require,module,exports){
const FastSVD = require("fast-svd").FastSVD

class FsSVDStorage {
    constructor(directory) {
        this.persistence = FastSVD.createFSPersistence(directory);
        this.factory = new FastSVD.createFactory(this.persistence);
    }
    registerType(typeName, typeDescription) {
        this.factory.registerType(typeName, typeDescription);
    }
    createTransaction(callback) {
        let t =  new FastSVD.createTransaction(this.factory);
        t.begin(callback);
    }
}

const createFsSVDStorage = (directory) => {
    return new FsSVDStorage(directory);
}
module.exports = {
    createFsSVDStorage
}
},{"fast-svd":"fast-svd"}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/system/index.js":[function(require,module,exports){
const envVariables = {};
function getEnvironmentVariable(name){
    if (typeof envVariables[name] !== "undefined") {
        return envVariables[name];
    }
    return process.env[name];
}
function setEnvironmentVariable(name, value){
    envVariables[name] = value;
}

function getFS(){
    const fsName = "fs";
    return require(fsName);
}

function getPath(){
    const pathName = "path";
    return require(pathName);
}
function getBaseURL(){
    const baseURL = require("../utils/getBaseURL");
    return baseURL();
}
module.exports = {
    getEnvironmentVariable,
    setEnvironmentVariable,
    getFS,
    getPath,
    getBaseURL
}

},{"../utils/getBaseURL":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/utils/getBaseURL.js"}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/utils/BindAutoPendingFunctions.js":[function(require,module,exports){
const PendingCallMixin = require("./PendingCallMixin");
/*
    Utility to make classes that depend on some initialisation easier to use.
    By using the PendingCallMixin, the member function can be used but will be called in order only after proper initialisation
 */

module.exports.bindAutoPendingFunctions = function(obj, exceptionList){
    let originalFunctions = {};

    for(let m in obj){
        if(typeof obj[m] == "function"){
            if(!exceptionList || exceptionList.indexOf(m) === -1){
                originalFunctions[m] = obj[m];
            }
        }
    }
    PendingCallMixin(obj);
    let isInitialised = false;

    obj.finishInitialisation = function(){
        isInitialised = true;
        obj.executeSerialPendingCalls();
    };

   function getWrapper(func){
       return function(...args){
           if(isInitialised){
              return func(...args);
           } else {
               obj.addSerialPendingCall( function(next){
                   let callback = args[args.length -1];
                   if(typeof callback === "function"){
                       args[args.length -1] = function(...args){
                           callback(...args);
                           next();
                       }
                   } else {
                       next();
                   }
                  return func(...args);
               })
           }
       }.bind(obj);
   }

    for(let m in originalFunctions){
        obj[m] = getWrapper(originalFunctions[m]);
    }
    return obj;
};

module.exports.bindParallelAutoPendingFunctions = function(obj, exceptionList){
    let originalFunctions = {};

    for(let m in obj){
        if(typeof obj[m] == "function"){
            if(!exceptionList || exceptionList.indexOf(m) === -1){
                originalFunctions[m] = obj[m];
            }
        }
    }
    PendingCallMixin(obj);
    let isInitialised = false;

    obj.finishInitialisation = function(){
        isInitialised = true;
        obj.executePendingCalls();
    };

    function getWrapper(func){
        return function(...args){
            if(isInitialised){
                return func(...args);
            } else {
                obj.addPendingCall( function(){
                    return func(...args);
                })
            }
        }.bind(obj);
    }

    for(let m in originalFunctions){
        obj[m] = getWrapper(originalFunctions[m]);
    }
    return obj;
};

},{"./PendingCallMixin":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/utils/PendingCallMixin.js"}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/utils/ObservableMixin.js":[function(require,module,exports){
const constants = require("../moduleConstants");
function ObservableMixin(target) {
    let observers = {};

    target.on = function(eventType, callback){
        let arr = observers[eventType];
        if(!arr){
            arr = observers[eventType] = [];
        }
        arr.push(callback);
    }

    target.off = function(eventType, callback){
        let arr = observers[eventType];
        if(!arr){
            //nothing to do...
            reportDevRelevantInfo("Off-ing an unknown observer");
            return;
        }
        let index = observers[eventType].indexOf(callback);
        if(index === -1){
            reportDevRelevantInfo("Observer not found into the list of known observers.");
            return;
        }

        observers[eventType].splice(index, 1);
    }

    target.dispatchEvent = function(eventType, message){
        let arr = observers[eventType];
        if (!arr) {
            //no handlers registered
            if (eventType !== constants.NOTIFICATION_TYPES.DEV) {
                reportDevRelevantInfo(`No observers found for event type ${eventType}`);
            } else {
                console.debug(`No observers found for event type ${eventType}`);
            }

            return;
        }

        arr.forEach( c => {
            try{
                c(message);
            }catch(err){
				console.error(err);
                reportDevRelevantInfo(`Caught an error during the delivery of ${eventType} to ${c.toString()}`);
            }

        });
    }

    target.removeAllObservers = function (eventType){
        if(observers[eventType]){
            delete observers[eventType];
        } else {
            reportDevRelevantInfo("No observers found in the list of known observers.");
        }
    }
}

module.exports = ObservableMixin;

},{"../moduleConstants":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/moduleConstants.js"}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/utils/PendingCallMixin.js":[function(require,module,exports){
function PendingCallMixin(target) {
    let pendingCalls = [];
    let serialPendingCalls = [];
    let isSerialExecutionReady = false;
    let isExecutionReady = false;
    target.addPendingCall = (pendingFn) => {
        if (isExecutionReady) {
            pendingFn();
        } else {
            pendingCalls.push(pendingFn);
        }
    };

    target.executePendingCalls = () => {
        isExecutionReady = true;
        pendingCalls.forEach(fn => fn());
        pendingCalls = [];
    };

    target.addSerialPendingCall = (pendingFn) => {
        serialPendingCalls.push(pendingFn);
        if (isSerialExecutionReady) {
            next();
        }
    };

    function next() {
        const fn = serialPendingCalls.shift();
        if (typeof fn !== "undefined") {
            try {
                fn(function () {
                    setTimeout(() => {
                        next();
                    }, 0);
                });
            } catch (e) {
                console.log(e);
            }
        }
    }

    target.executeSerialPendingCalls = () => {
        isSerialExecutionReady = true;
        next();
    };
}

module.exports = PendingCallMixin;
},{}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/utils/SmartUrl.js":[function(require,module,exports){
function SmartUrl(bdnsEntry){
    const {fetch, doPut, doPost, doGet} = require("opendsu").loadAPI("http");
    let url = typeof bdnsEntry === "string" ? bdnsEntry : bdnsEntry.url;

    if(!url){
        console.debug(`<${JSON.stringify(bdnsEntry)}> BDNS entry wrong configuration.`);
        throw new Error(`<${JSON.stringify(bdnsEntry)}> BDNS entry wrong configuration.`);
    }

    function getOptions(options){
        let opts = options || {};
        if(url !== bdnsEntry && bdnsEntry.headers){
            if(!opts.headers){
                opts.headers = {};
            }
            Object.assign(opts.headers, bdnsEntry.headers);
        }
        return opts;
    }

    this.fetch = (options)=>{
        return fetch(url, getOptions(options));
    }

    this.doPut = (body, options, callback)=>{
        if(typeof options === "function"){
            callback = options;
            options = undefined;
        }
       return doPut(url, body, getOptions(options), callback);
    }

    this.doPost = (body, options, callback)=>{
        if(typeof options === "function"){
            callback = options;
            options = undefined;
        }
       return doPost(url, body, getOptions(options), callback);
    }

    this.doGet = (options, callback)=>{
        if(typeof options === "function"){
            callback = options;
            options = undefined;
        }
        return doGet(url, getOptions(options), callback);
    }

    function concatUrls(base, path){
        let returnUrl = base;
        if(returnUrl.endsWith("/") && path.startsWith("/")){
            returnUrl = returnUrl.slice(0, returnUrl.length-1);
        }
        returnUrl += path;
        return returnUrl;
    }

    this.concatWith = (path) => {
        return new SmartUrl(bdnsEntry === url ? concatUrls(url, path) :{url: concatUrls(url, path), headers:bdnsEntry.headers});
    }
}

module.exports = SmartUrl;
},{"opendsu":"opendsu"}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/utils/array.js":[function(require,module,exports){
function shuffle(array) {
  for (let i = array.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [array[i], array[j]] = [array[j], array[i]];
  }
}

module.exports.shuffle = shuffle;

},{}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/utils/getBaseURL.js":[function(require,module,exports){
const constants = require("../moduleConstants");
const system = require("../system");
function getBaseURL(){
    switch ($$.environmentType) {
        case constants.ENVIRONMENT_TYPES.SERVICE_WORKER_ENVIRONMENT_TYPE:
            let scope = self.registration.scope;

            let parts = scope.split("/");
            return `${parts[0]}//${parts[2]}`;

        case constants.ENVIRONMENT_TYPES.BROWSER_ENVIRONMENT_TYPE:            
            const protocol = window.location.protocol;
            const host = window.location.hostname;
            const port = window.location.port;

            return `${protocol}//${host}:${port}`;

        case constants.ENVIRONMENT_TYPES.WEB_WORKER_ENVIRONMENT_TYPE:            
            return self.location.origin;

        case constants.ENVIRONMENT_TYPES.NODEJS_ENVIRONMENT_TYPE:
            let baseUrl = system.getEnvironmentVariable(constants.BDNS_ROOT_HOSTS);
            if (typeof baseUrl === "undefined") {
                baseUrl = "http://127.0.0.1:8080";
            } else {
                const myURL = new URL(baseUrl);
                baseUrl = myURL.origin;
            }
            if (baseUrl.endsWith("/")) {
                baseUrl = baseUrl.slice(0, -1);
            }
            return baseUrl;

        default:
    }
}

module.exports = getBaseURL;
},{"../moduleConstants":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/moduleConstants.js","../system":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/system/index.js"}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/utils/getURLForSsappContext.js":[function(require,module,exports){
function getURLForSsappContext(relativePath) {
    if (window["$$"] && $$.SSAPP_CONTEXT && $$.SSAPP_CONTEXT.BASE_URL && $$.SSAPP_CONTEXT.SEED) {
        // if we have a BASE_URL then we prefix the fetch url with BASE_URL
        return `${new URL($$.SSAPP_CONTEXT.BASE_URL).pathname}${
            relativePath.indexOf("/") === 0 ? relativePath.substring(1) : relativePath
        }`;
    }
    return relativePath;
}

module.exports = {
    getURLForSsappContext
}

},{}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/utils/index.js":[function(require,module,exports){
module.exports = {
    bindAutoPendingFunctions: require("./BindAutoPendingFunctions").bindAutoPendingFunctions,
    bindParallelAutoPendingFunctions: require("./BindAutoPendingFunctions").bindParallelAutoPendingFunctions,
    ObservableMixin: require("./ObservableMixin"),
    PendingCallMixin: require('./PendingCallMixin'),
    SmartUrl: require("./SmartUrl"),
    promiseRunner: require("./promise-runner"),
    sleepAsync: function sleep(ms) {
        return new Promise(resolve => setTimeout(resolve, ms));
    }
}
},{"./BindAutoPendingFunctions":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/utils/BindAutoPendingFunctions.js","./ObservableMixin":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/utils/ObservableMixin.js","./PendingCallMixin":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/utils/PendingCallMixin.js","./SmartUrl":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/utils/SmartUrl.js","./promise-runner":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/utils/promise-runner.js"}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/utils/observable.js":[function(require,module,exports){
module.exports.createObservable = function(){
	let observableMixin = require("./ObservableMixin");
	let obs = {};

	observableMixin(obs);
	return obs;
}
},{"./ObservableMixin":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/utils/ObservableMixin.js"}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/utils/promise-runner.js":[function(require,module,exports){
const arrayUtils = require("./array");
const { OpenDSUSafeCallback, createOpenDSUErrorWrapper } = require('./../error')

function validateMajorityRunAllWithSuccess(successResults, errorResults, totalCount) {
  const successCount = successResults.length;
  const errorCount = errorResults.length;

  if (totalCount == null) {
    // totalCount was not provided, so we consider to be the sum of the other results
    totalCount = successCount + errorCount;
  }

  const isMajorityWithSuccess = successCount >= Math.ceil(totalCount / 2);
  return isMajorityWithSuccess;
}

function runSinglePromise(executePromise, promiseInput) {
  return executePromise(promiseInput)
    .then((result) => {
      return {
        success: true,
        result,
      };
    })
    .catch((error) => {
      return {
        error,
      };
    });
}

async function runAll(listEntries, executeEntry, validateResults, callback, debugInfo) {
  if (typeof validateResults !== "function") {
    validateResults = validateMajorityRunAllWithSuccess;
  }

  const allInitialExecutions = listEntries.map((entry) => {
    return runSinglePromise(executeEntry, entry);
  });

  let results;

  try {
    results = await Promise.all(allInitialExecutions)
  } catch (e) {
    return callback(e);
  }

  const successExecutions = results.filter((run) => run.success);
  let errorExecutions = results.filter((run) => !run.success);
  errorExecutions = errorExecutions.map(e => {
    if (e.error && e.error.error) {
      return e.error.error;
    }else {
      return e;
    }
  });
  const isConsideredSuccessfulRun = validateResults(successExecutions, errorExecutions);
  if (isConsideredSuccessfulRun) {
    const successExecutionResults = successExecutions.map((run) => run.result);
    return callback(null, successExecutionResults);
  }

  let baseError = debugInfo;
  if(errorExecutions.length){
    if(baseError){
      baseError = OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper("Error found during runAll", errorExecutions[0], errorExecutions));
    }
  }
  return OpenDSUSafeCallback(callback)((createOpenDSUErrorWrapper("FAILED to runAll " , baseError)));
}

function runOneSuccessful(listEntries, executeEntry, callback, debugInfo) {
  if (!listEntries.length) {
    return callback("EMPTY_LIST");
  }

  let availableListEntries = [...listEntries];
  arrayUtils.shuffle(availableListEntries);

  const entry = availableListEntries.shift();

  const executeForSingleEntry = async (entry) => {
      let result;
      try {
          result = await executeEntry(entry);
      } catch (err) {
          if (!availableListEntries.length) {
              return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to execute entry`+debugInfo, err));
          }

          const nextEntry = availableListEntries.shift();
          return executeForSingleEntry(nextEntry);
      }

     return callback(undefined, result);
  };

  executeForSingleEntry(entry);
}

async function runEnoughForMajority(listEntries, executeEntry, initialRunCount, validateResults, callback, debugInfo) {
  const totalCount = listEntries.length;

  if (!initialRunCount || typeof initialRunCount !== "number") {
    // no initiaRunCount was specified, so we execute half of them initially
    initialRunCount = Math.ceil(totalCount / 2);
  }
  initialRunCount = Math.min(initialRunCount, totalCount);

  if (typeof validateResults !== "function") {
    validateResults = validateMajorityRunAllWithSuccess;
  }

  let allExecutedRunResults = [];
  const initialEntries = listEntries.slice(0, initialRunCount);
  const remainingEntries = listEntries.slice(initialRunCount);

  const checkAllExecutedRunResults = async () => {
    const successExecutions = allExecutedRunResults.filter((run) => run.success);
    const errorExecutions = allExecutedRunResults.filter((run) => !run.success);

    const isConsideredSuccessfulRun = validateResults(successExecutions, errorExecutions, totalCount);
    if (isConsideredSuccessfulRun) {
      const successExecutionResults = successExecutions.map((run) => run.result);
      return callback(null, successExecutionResults);
    }

    if (!remainingEntries.length) {
      // the results weren't validated, but we don't have any other entry to run
      return callback(new Error("FAILED to run enough in majority"+debugInfo));
    }

    const nextEntry = remainingEntries.shift();

    const nextEntryResult = await runSinglePromise(executeEntry, nextEntry);
    allExecutedRunResults.push(nextEntryResult);
    checkAllExecutedRunResults();
  };

  const allInitialExecutions = initialEntries.map((entry) => {
    return runSinglePromise(executeEntry, entry);
  });

  try {
    allExecutedRunResults = await Promise.all(allInitialExecutions);
  } catch (e) {
    return callback(e);
  }
  checkAllExecutedRunResults();
}

module.exports = {
  runAll,
  runOneSuccessful,
  runEnoughForMajority,
};

},{"./../error":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/error/index.js","./array":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/utils/array.js"}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/w3cdid/CryptographicSkills/CryptographicSkills.js":[function(require,module,exports){
const cryptoSkillsRegistry = {};
const methodsNames = require("../didMethodsNames");
const KeyDID_CryptographicSkills = require("./KeyDID_CryptographicSkills");
const NameDID_CryptographicSkills = require("./NameDID_CryptographicSkills");
const GroupDID_CryptographicSkills = require("./GroupDID_CryptographicSkills");
const SReadDID_CryptographicSkills = require("./SReadDID_CryptographicSkills");
const SSI_KeyDID_CryptographicSkills = require("./SSI_KeyDID_CryptographicSkills");

const registerSkills = (didMethod, skills) => {
    cryptoSkillsRegistry[didMethod] = skills;
}

const applySkill = (didMethod, skillName, ...args) => {
    return cryptoSkillsRegistry[didMethod][skillName](...args);
}

registerSkills(methodsNames.NAME_SUBTYPE, new NameDID_CryptographicSkills());
registerSkills(methodsNames.GROUP_METHOD_NAME, new GroupDID_CryptographicSkills());
registerSkills(methodsNames.S_READ_SUBTYPE, new SReadDID_CryptographicSkills());
registerSkills(methodsNames.SSI_KEY_SUBTYPE, new SSI_KeyDID_CryptographicSkills());
registerSkills(methodsNames.KEY_SUBTYPE, new KeyDID_CryptographicSkills());

module.exports = {
    registerSkills,
    applySkill,
    NAMES: require("./cryptographicSkillsNames"),
    CryptographicSkillsMixin: require("./CryptographicSkillsMixin")
};
},{"../didMethodsNames":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/w3cdid/didMethodsNames.js","./CryptographicSkillsMixin":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/w3cdid/CryptographicSkills/CryptographicSkillsMixin.js","./GroupDID_CryptographicSkills":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/w3cdid/CryptographicSkills/GroupDID_CryptographicSkills.js","./KeyDID_CryptographicSkills":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/w3cdid/CryptographicSkills/KeyDID_CryptographicSkills.js","./NameDID_CryptographicSkills":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/w3cdid/CryptographicSkills/NameDID_CryptographicSkills.js","./SReadDID_CryptographicSkills":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/w3cdid/CryptographicSkills/SReadDID_CryptographicSkills.js","./SSI_KeyDID_CryptographicSkills":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/w3cdid/CryptographicSkills/SSI_KeyDID_CryptographicSkills.js","./cryptographicSkillsNames":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/w3cdid/CryptographicSkills/cryptographicSkillsNames.js"}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/w3cdid/CryptographicSkills/CryptographicSkillsMixin.js":[function(require,module,exports){
function CryptographicSkillsMixin(target) {
    target = target || {};
    const crypto = require("pskcrypto");
    const openDSU = require("opendsu");
    const keySSISpace = openDSU.loadAPI("keyssi");
    const cryptoSpace = openDSU.loadAPI("crypto");

    let config = {
        curveName: 'secp256k1',
        encodingFormat: 'base64',
        macAlgorithmName: 'sha256',
        macKeySize: 16,
        hashFunctionName: 'sha256',
        hashSize: 32,
        signAlgorithmName: 'sha256',
        symmetricCipherName: 'aes-128-cbc',
        symmetricCipherKeySize: 16,
        ivSize: 16
    };

    target.getConfigForIES = () => {
        return config;
    };

    target.hash = (data) => {
        return target.encoding(crypto.hash('sha256', data));
    }

    target.keyDerivation = (password, iterations) => {
        return crypto.deriveKey('aes-256-gcm', password, iterations);
    }

    target.encryptionKeyGeneration = () => {
        const pskEncryption = crypto.createPskEncryption('aes-256-gcm');
        return pskEncryption.generateEncryptionKey();
    }

    target.encryption = (plainData, encryptionKey, options) => {
        const pskEncryption = crypto.createPskEncryption('aes-256-gcm');
        return pskEncryption.encrypt(plainData, encryptionKey, options);
    }

    target.decryption = (encryptedData, decryptionKey, authTagLength, options) => {
        const pskEncryption = crypto.createPskEncryption('aes-256-gcm');
        const utils = require("swarmutils");
        if (!$$.Buffer.isBuffer(decryptionKey) && (decryptionKey instanceof ArrayBuffer || ArrayBuffer.isView(decryptionKey))) {
            decryptionKey = utils.ensureIsBuffer(decryptionKey);
        }
        if (!$$.Buffer.isBuffer(encryptedData) && (decryptionKey instanceof ArrayBuffer || ArrayBuffer.isView(decryptionKey))) {
            encryptedData = utils.ensureIsBuffer(encryptedData);
        }
        return pskEncryption.decrypt(encryptedData, decryptionKey, 16, options);
    }

    target.encoding = (data) => {
        return crypto.pskBase58Encode(data);
    }

    target.decoding = (data) => {
        return crypto.pskBase58Decode(data);
    }

    target.keyPairGenerator = () => {
        return crypto.createKeyPairGenerator();
    }

    target.convertPublicKey = (rawPublicKey, options) => {
        const keyGenerator = crypto.createKeyPairGenerator();
        return keyGenerator.convertPublicKey(rawPublicKey, options);
    };

    target.sign = (data, privateKey) => {
        const keyGenerator = crypto.createKeyPairGenerator();
        const rawPublicKey = keyGenerator.getPublicKey(privateKey, 'secp256k1');
        return crypto.sign('sha256', data, keyGenerator.getPemKeys(privateKey, rawPublicKey).privateKey);
    }

    target.verify = (data, publicKey, signature) => {
        return crypto.verify('sha256', data, publicKey, signature);
    }

    target.ecies_encryption = (receiverPublicKey, message) => {
        return crypto.ecies_encrypt(receiverPublicKey, message, target.getConfigForIES())
    };

    target.ecies_decryption = (receiverPrivateKey, encEnvelope) => {
        return crypto.ecies_decrypt(receiverPrivateKey, encEnvelope, target.getConfigForIES());
    };

    const saveNewKeyPairInSC = async (didDocument, compatibleSSI) => {
        const securityContext = openDSU.loadAPI("sc").getSecurityContext();

        try {
            await $$.promisify(securityContext.addPrivateKeyForDID)(
                didDocument,
                compatibleSSI.getPrivateKey("raw")
            );
            // await $$.promisify(securityContext.addPublicKeyForDID)(
            //   didDocument,
            //   compatibleSSI.getPublicKey("raw")
            // );
        } catch (e) {
            throw createOpenDSUErrorWrapper(`Failed to save new private key and public key in security context`, e);
        }

        try {
            await $$.promisify(didDocument.addPublicKey)(
                compatibleSSI.getPublicKey("raw")
            );
        } catch (e) {
            throw createOpenDSUErrorWrapper(`Failed to save new private key and public key in security context`, e);
        }
    };

    target.encryptMessage = (privateKeys, didFrom, didTo, message, callback) => {
        const senderSeedSSI = keySSISpace.createTemplateSeedSSI(didFrom.getDomain());
        try {
            senderSeedSSI.initialize(didFrom.getDomain(), privateKeys[privateKeys.length - 1]);
        } catch (e) {
            return callback(createOpenDSUErrorWrapper(`Failed to initialize seedSSI`, e));
        }

        didTo.getPublicKey("raw", async (err, receiverPublicKey) => {
            if (err) {
                return callback(createOpenDSUErrorWrapper(`Failed to get sender publicKey`, err));
            }

            const publicKeySSI = keySSISpace.createPublicKeySSI("seed", receiverPublicKey);

            const __encryptMessage = (senderKeySSI) => {
                let encryptedMessage;
                try {
                    encryptedMessage = cryptoSpace.ecies_encrypt_ds(senderKeySSI, publicKeySSI, message);
                } catch (e) {
                    return callback(createOpenDSUErrorWrapper(`Failed to encrypt message`, e));
                }

                callback(undefined, encryptedMessage);
            };

            __encryptMessage(senderSeedSSI);
        });
    };

    target.decryptMessage = (privateKeys, didTo, encryptedMessage, callback) => {
        let decryptedMessageObj;
        const decryptMessageRecursively = (privateKeyIndex) => {
            if(privateKeyIndex >= privateKeys.length){
                return callback(createOpenDSUErrorWrapper(`Failed to decrypt message`, new Error("No private key available")));
            }
            const privateKey = privateKeys[privateKeyIndex];

            if (!privateKey) {
                return decryptMessageRecursively(privateKeyIndex + 1);
            }

            const receiverSeedSSI = keySSISpace.createTemplateSeedSSI(didTo.getDomain());
            try {
                receiverSeedSSI.initialize(didTo.getDomain(), privateKey);
            } catch (e) {
                return callback(createOpenDSUErrorWrapper(`Failed to initialize seedSSI`, e));
            }
            try {
                decryptedMessageObj = cryptoSpace.ecies_decrypt_ds(receiverSeedSSI, encryptedMessage);
            } catch (e) {
                return decryptMessageRecursively(privateKeyIndex + 1);
            }

            callback(undefined, decryptedMessageObj.message.toString());
        };

        decryptMessageRecursively(0);
    };
    target.ecies_encryption_ds = (senderKeyPair, receiverPublicKey, message) => {
        return crypto.ecies_encrypt_ds(senderKeyPair, receiverPublicKey, message, target.getConfigForIES())
    };

    target.ecies_decryption_ds = (receiverPrivateKey, encEnvelope) => {
        return crypto.ecies_decrypt_ds(receiverPrivateKey, encEnvelope, target.getConfigForIES());
    };

    target.ecies_encryption_kmac = (senderKeyPair, receiverPublicKey, message) => {
        return crypto.ecies_encrypt_kmac(senderKeyPair, receiverPublicKey, message, target.getConfigForIES())
    };

    target.ecies_decryption_kmac = (receiverPrivateKey, encEnvelope) => {
        return crypto.ecies_decrypt_kmac(receiverPrivateKey, encEnvelope, target.getConfigForIES());
    };

    return target;
}

module.exports = CryptographicSkillsMixin;

},{"opendsu":"opendsu","pskcrypto":"pskcrypto","swarmutils":"swarmutils"}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/w3cdid/CryptographicSkills/GroupDID_CryptographicSkills.js":[function(require,module,exports){
const didDocumentsFactory = require("../didDocumentsFactory");
const didMethodsNames = require("../didMethodsNames");
function GroupDID_CryptographicSkills() {
    const CryptoGraphicSkillsMixin = require("./CryptographicSkillsMixin");
    CryptoGraphicSkillsMixin(this);

    this.createDID_Document = (domain, groupName) => {
        return didDocumentsFactory.createDID_Document(didMethodsNames.GROUP_METHOD_NAME, domain, groupName);
    }
}

module.exports = GroupDID_CryptographicSkills;
},{"../didDocumentsFactory":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/w3cdid/didDocumentsFactory.js","../didMethodsNames":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/w3cdid/didMethodsNames.js","./CryptographicSkillsMixin":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/w3cdid/CryptographicSkills/CryptographicSkillsMixin.js"}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/w3cdid/CryptographicSkills/KeyDID_CryptographicSkills.js":[function(require,module,exports){
const didDocumentsFactory = require("../didDocumentsFactory");
const didMethodsNames = require("../didMethodsNames");
function KeyDID_CryptographicSkills() {
    const CryptoGraphicSkillsMixin = require("./CryptographicSkillsMixin");
    CryptoGraphicSkillsMixin(this);

    this.createDID_Document = () => {
        return didDocumentsFactory.createDID_Document(didMethodsNames.KEY_SUBTYPE);
    }
}

module.exports = KeyDID_CryptographicSkills;
},{"../didDocumentsFactory":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/w3cdid/didDocumentsFactory.js","../didMethodsNames":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/w3cdid/didMethodsNames.js","./CryptographicSkillsMixin":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/w3cdid/CryptographicSkills/CryptographicSkillsMixin.js"}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/w3cdid/CryptographicSkills/NameDID_CryptographicSkills.js":[function(require,module,exports){
const didDocumentsFactory = require("../didDocumentsFactory");
const didMethodsNames = require("../didMethodsNames");
function NameDID_CryptographicSkills() {
    const CryptoGraphicSkillsMixin = require("./CryptographicSkillsMixin");
    CryptoGraphicSkillsMixin(this);

    this.createDID_Document = (domain, name) => {
        return didDocumentsFactory.createDID_Document(didMethodsNames.NAME_SUBTYPE, domain, name);
    }
}

module.exports = NameDID_CryptographicSkills;
},{"../didDocumentsFactory":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/w3cdid/didDocumentsFactory.js","../didMethodsNames":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/w3cdid/didMethodsNames.js","./CryptographicSkillsMixin":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/w3cdid/CryptographicSkills/CryptographicSkillsMixin.js"}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/w3cdid/CryptographicSkills/SReadDID_CryptographicSkills.js":[function(require,module,exports){
const didDocumentsFactory = require("../didDocumentsFactory");
const didMethodsNames = require("../didMethodsNames");
function SReadDID_CryptographicSkills() {
    const CryptoGraphicSkillsMixin = require("./CryptographicSkillsMixin");
    CryptoGraphicSkillsMixin(this);

    this.createDID_Document = (seedSSI) => {
        return didDocumentsFactory.createDID_Document(didMethodsNames.S_READ_SUBTYPE, seedSSI);
    }
}

module.exports = SReadDID_CryptographicSkills;
},{"../didDocumentsFactory":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/w3cdid/didDocumentsFactory.js","../didMethodsNames":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/w3cdid/didMethodsNames.js","./CryptographicSkillsMixin":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/w3cdid/CryptographicSkills/CryptographicSkillsMixin.js"}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/w3cdid/CryptographicSkills/SSI_KeyDID_CryptographicSkills.js":[function(require,module,exports){
const didDocumentsFactory = require("../didDocumentsFactory");
const didMethodsNames = require("../didMethodsNames");
function SSI_KeyDID_CryptographicSkills() {
    const CryptoGraphicSkillsMixin = require("./CryptographicSkillsMixin");
    CryptoGraphicSkillsMixin(this);

    this.createDID_Document = (seedSSI) => {
        return didDocumentsFactory.createDID_Document(didMethodsNames.SSI_KEY_SUBTYPE, seedSSI);
    }
}

module.exports = SSI_KeyDID_CryptographicSkills;
},{"../didDocumentsFactory":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/w3cdid/didDocumentsFactory.js","../didMethodsNames":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/w3cdid/didMethodsNames.js","./CryptographicSkillsMixin":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/w3cdid/CryptographicSkills/CryptographicSkillsMixin.js"}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/w3cdid/CryptographicSkills/cryptographicSkillsNames.js":[function(require,module,exports){
module.exports = {
    CREATE_DID_DOCUMENT:"createDID_Document",
    SIGN: "sign",
    VERIFY: "verify",
    ENCRYPT_MESSAGE: "encryptMessage",
    DECRYPT_MESSAGE: "decryptMessage"
}
},{}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/w3cdid/W3CDID_Mixin.js":[function(require,module,exports){
/*
    W3CDID Minxin is abstracting the DID document for OpenDSU compatible DID methods

    did:whatever   resolved to an OpenDSU abstraction: W3CDIDDocument
    verify signatures
    sign
    send and receive encrypted messages


 */

function W3CDID_Mixin(target, enclave) {
    const openDSU = require("opendsu");
    const dbAPI = openDSU.loadAPI("db");
    const crypto = openDSU.loadAPI("crypto");
    target.findPrivateKeysInSecurityContext = function (callback) {

    };

    const __ensureEnclaveExistsThenExecute = (fnName, ...args) => {
        const callback = args[args.length - 1];
        if (typeof enclave === "undefined") {
            dbAPI.getMainEnclave((err, mainEnclave) => {
                if (err) {
                    return callback(err);
                }

                enclave = mainEnclave;
                enclave[fnName](...args);
            })
        } else {
            enclave[fnName](...args);
        }
    }

    target.sign = function (hash, callback) {
        __ensureEnclaveExistsThenExecute("signForDID", target, hash, callback);
    };

    target.verify = function (hash, signature, callback) {
        __ensureEnclaveExistsThenExecute("verifyForDID", target, hash, signature, callback);
    };

    /*Elliptic Curve Integrated Encryption Scheme
     * https://github.com/bin-y/standard-ecies/blob/master/main.js
     * https://www.npmjs.com/package/ecies-lite  //try to use functions from SSI and from crypto
     * https://github.com/ecies/js
     * https://github.com/sigp/ecies-parity
     * https://github.com/pedrouid/eccrypto-js
     *
     * annoncrypt  - symertric enc (IES)
     * authcrypt   -  asymetric enc + sign
     * plaintext   + asym sign
     *
     * A -> B   sign(enc( ASYM_PK_B, M), PK_A)
     * */

    target.encryptMessage = function (receiverDID, message, callback) {
        __ensureEnclaveExistsThenExecute("encryptMessage", target, receiverDID, message, callback);
    };

    target.decryptMessage = function (encryptedMessage, callback) {
        __ensureEnclaveExistsThenExecute("decryptMessage", target, encryptedMessage, callback);
    };

    /* messages to the APiHUb MQ compatible APIs

      * */

    target.getHash = () => {
        return crypto.sha256(target.getIdentifier());
    };

    target.sendMessage = function (message, toOtherDID, callback) {
        if (typeof message === "object") {
            try {
                message = message.getSerialisation();
            } catch (e) {
                message = JSON.stringify(message);
            }
        }

        const __sendMessage = () => {
            const mqHandler = require("opendsu")
                .loadAPI("mq")
                .getMQHandlerForDID(toOtherDID);
            target.encryptMessage(toOtherDID, message, (err, encryptedMessage) => {
                if (err) {
                    return callback(
                        createOpenDSUErrorWrapper(`Failed to encrypt message`, err)
                    );
                }

                mqHandler.writeMessage(JSON.stringify(encryptedMessage), callback);
            });
        }

        if (typeof toOtherDID === "string") {
            enclave.resolveDID(toOtherDID, (err, didDocument) => {
                if (err) {
                    return callback(err);
                }

                toOtherDID = didDocument;
                __sendMessage();
            })
        } else {
            __sendMessage();
        }
    };

    target.readMessage = function (callback) {
        const mqHandler = require("opendsu")
            .loadAPI("mq")
            .getMQHandlerForDID(target);
        mqHandler.previewMessage((err, encryptedMessage) => {
            if (err) {
                return callback(createOpenDSUErrorWrapper(`Failed to read message`, err));
            }

            let message;
            try {
                message = JSON.parse(encryptedMessage.message);
            } catch (e) {
                return callback(createOpenDSUErrorWrapper(`Failed to parse received message`, err));
            }

            mqHandler.deleteMessage(encryptedMessage.messageId, (err) => {
                if (err) {
                    return callback(createOpenDSUErrorWrapper(`Failed to delete message`, err));
                }
                target.decryptMessage(message, callback);
            })
        });
    };

    target.subscribe = function (callback) {
        const mqHandler = require("opendsu")
            .loadAPI("mq")
            .getMQHandlerForDID(target);
        mqHandler.subscribe((err, encryptedMessage) => {
            if (err) {
                return callback(createOpenDSUErrorWrapper(`Failed to read message`, err));
            }
            let message;
            try {
                message = JSON.parse(encryptedMessage.message);
            } catch (e) {
                return callback(createOpenDSUErrorWrapper(`Failed to parse received message`, err));
            }

            target.decryptMessage(message, (decryptError, decryptedMessage) => {
                mqHandler.deleteMessage(encryptedMessage.messageId, (err) => {
                    if(decryptError){
                        //if we fail to decrypt a message, we delete and skip it
                        return;
                    }
                    if (err) {
                        return callback(createOpenDSUErrorWrapper(`Failed to delete message`, err));
                    }
                    callback(undefined, decryptedMessage);
                })
            });
        });
    };

    target.waitForMessages = function (callback) {
        const mqHandler = require("opendsu")
            .loadAPI("mq")
            .getMQHandlerForDID(target);

        target.onCallback = (err, encryptedMessage, notificationHandler) => {
            if (target.stopReceivingMessages) {
                console.log(`Received message for unsubscribed DID`);
                return;
            }

            if (err) {
                return callback(createOpenDSUErrorWrapper(`Failed to read message`, err));
            }

            if (notificationHandler) {
                notificationHandler();
            }

            let message;
            try {
                message = JSON.parse(encryptedMessage.message);
            } catch (e) {
                return callback(createOpenDSUErrorWrapper(`Failed to parse received message`, e));
            }

            target.decryptMessage(message, (decryptError, decryptedMessage)=>{
                if(err){
                    return mqHandler.deleteMessage(encryptedMessage.messageId, (err) => {
                        if(err){
                            //if we fail to auto delete the message that failed to decrypt we call the callback with the original decrypt error
                            return callback(decryptError);
                        }
                    });
                }
                callback(undefined, decryptedMessage);
            });
            return target.stopWaitingForMessages;
        }
        mqHandler.waitForMessages(target.onCallback);
    };

    target.stopWaitingForMessages = function () {
        const mqHandler = require("opendsu")
            .loadAPI("mq")
            .getMQHandlerForDID(target);
        mqHandler.stopReceivingMessages = true;
        target.stopReceivingMessages = true;
    }

    target.startWaitingForMessages = function () {
        const mqHandler = require("opendsu")
            .loadAPI("mq")
            .getMQHandlerForDID(target);
        mqHandler.stopReceivingMessages = false;
        target.stopReceivingMessages = false;
    }

    target.getEnclave = () => {
        return enclave;
    }

    target.on = function (callback) {
    };

    target.revokeDID = function (callback) {
    };

    target.revokeKey = function (key, callback) {
    };

    target.getControllerKey = function (callback) {
    };

    target.getPublicKeys = function (callback) {
    };

    target.getDomain = function () {
    }
}

module.exports = W3CDID_Mixin;

},{"opendsu":"opendsu"}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/w3cdid/W3CVC_Mixin.js":[function(require,module,exports){

/*
    W3CVC Mixin is abstracting a JWT based credential
    The same approach/interface can be used with credentials represented in other formats
 */

function W3CVC_Mixin(){
    let serialisation;
    /*
        Verify that the signature of the issuer is correct
     */
    this.load = function(vcSerialisationDocument, callback){
        serialisation = vcSerialisationDocument;
    };

    /*
        Verify that the signature of the issuer is correct
     */
    this.verify = function(callback){

    };

}

module.exports = W3CVC_Mixin;

},{}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/w3cdid/didDocumentsFactory.js":[function(require,module,exports){
const methodsNames = require("./didMethodsNames");
const createNameDIDDocument = require("./didssi/NameDID_Document").initiateDIDDocument;
const createGroupDID_Document = require("./didssi/GroupDID_Document").initiateDIDDocument;
const createSReadDID_Document = require("./didssi/SReadDID_Document").initiateDIDDocument;
const createSSI_KeyDID_Document = require("./didssi/SSIKeyDID_Document").initiateDIDDocument;
const createKeyDID_Document = require("./w3cdids/KeyDID_Document").initiateDIDDocument;

const didsConstructors = {};

const registerDID_Document_Constructor = (didMethod, didConstructor) => {
    didsConstructors[didMethod] = didConstructor;
}

const createDID_Document = (didMethod, ...args) => {
    return didsConstructors[didMethod](...args);
}

registerDID_Document_Constructor(methodsNames.NAME_SUBTYPE, createNameDIDDocument);
registerDID_Document_Constructor(methodsNames.GROUP_METHOD_NAME, createGroupDID_Document);
registerDID_Document_Constructor(methodsNames.S_READ_SUBTYPE, createSReadDID_Document);
registerDID_Document_Constructor(methodsNames.SSI_KEY_SUBTYPE, createSSI_KeyDID_Document);
registerDID_Document_Constructor(methodsNames.KEY_SUBTYPE, createKeyDID_Document);

module.exports = {
    registerDID_Document_Constructor,
    createDID_Document
}
},{"./didMethodsNames":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/w3cdid/didMethodsNames.js","./didssi/GroupDID_Document":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/w3cdid/didssi/GroupDID_Document.js","./didssi/NameDID_Document":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/w3cdid/didssi/NameDID_Document.js","./didssi/SReadDID_Document":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/w3cdid/didssi/SReadDID_Document.js","./didssi/SSIKeyDID_Document":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/w3cdid/didssi/SSIKeyDID_Document.js","./w3cdids/KeyDID_Document":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/w3cdid/w3cdids/KeyDID_Document.js"}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/w3cdid/didMethodsNames.js":[function(require,module,exports){
module.exports = {
    OPENDSU_METHOD_NAME: "ssi",
    KEY_SUBTYPE: "key",
    SSI_KEY_SUBTYPE: "ssi:key",
    S_READ_SUBTYPE: "ssi:sread",
    NAME_SUBTYPE: "ssi:name",
    GROUP_METHOD_NAME: "ssi:group",
    DEMO_METHOD_NAME: "demo"
}
},{}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/w3cdid/didssi/ConstDID_Document_Mixin.js":[function(require,module,exports){
(function (Buffer){(function (){
const {createOpenDSUErrorWrapper} = require("../../error");

function ConstDID_Document_Mixin(target, enclave, domain, name, isInitialisation, desiredPrivateKey) {
    if (arguments.length === 4) {
        isInitialisation = name;
        name = domain;
        domain = undefined;
    }
    let mixin = require("../W3CDID_Mixin");
    const observableMixin = require("../../utils/ObservableMixin")
    mixin(target, enclave);
    observableMixin(target);

    const openDSU = require("opendsu");
    const scAPI = openDSU.loadAPI("sc");
    const crypto = openDSU.loadAPI("crypto");
    const keySSISpace = openDSU.loadAPI("keyssi");
    const resolver = openDSU.loadAPI("resolver");

    const WRITABLE_DSU_PATH = "writableDSU";
    const PUB_KEYS_PATH = "publicKeys";
    let initialised = false;
    const generatePublicKey = async () => {
        let seedSSI;
        try {
            seedSSI = await $$.promisify(keySSISpace.createSeedSSI)(domain, desiredPrivateKey);
        } catch (e) {
            return target.dispatchEvent("error", createOpenDSUErrorWrapper(`Failed to create SeedSSI`, e));
        }

        target.privateKey = seedSSI.getPrivateKey();
        return seedSSI.getPublicKey("raw");
    };

    const createDSU = async () => {
        let constDSU;
        try {
            constDSU = await $$.promisify(resolver.createConstDSU)(domain, name);
        } catch (e) {
            return target.dispatchEvent("error", createOpenDSUErrorWrapper(`Failed to create constDSU`, e));
        }

        try {
            target.dsu = await $$.promisify(resolver.createSeedDSU)(domain);
        } catch (e) {
            return target.dispatchEvent("error", createOpenDSUErrorWrapper(`Failed to create writableDSU`, e));
        }

        let publicKey = await generatePublicKey();
        try {
            await $$.promisify(target.addPublicKey)(publicKey);
        } catch (e) {
            return target.dispatchEvent("error", createOpenDSUErrorWrapper(`Failed to save public key`, e));
        }
        let seedSSI;
        try {
            seedSSI = await $$.promisify(target.dsu.getKeySSIAsString)();
        } catch (e) {
            return target.dispatchEvent("error", createOpenDSUErrorWrapper(`Failed to get seedSSI`, e));
        }

        try {
            await constDSU.safeBeginBatchAsync();
        } catch (e) {
            return target.dispatchEvent("error", createOpenDSUErrorWrapper(`Failed to begin batch in Const DSU`, e));
        }

        try {
            await $$.promisify(constDSU.mount)(WRITABLE_DSU_PATH, seedSSI);
        } catch (e) {
            const mountError = createOpenDSUErrorWrapper(`Failed to mount writable DSU`, e);
            try {
                await constDSU.cancelBatchAsync();
            }catch (error) {
                return target.dispatchEvent("error", createOpenDSUErrorWrapper(`Failed to cancel batch in Const DSU`, error));
            }
            return target.dispatchEvent("error", mountError);
        }

        try {
            await constDSU.commitBatchAsync();
        } catch (e) {
            return target.dispatchEvent("error", createOpenDSUErrorWrapper(`Failed to commit batch in Const DSU`, e));
        }

        target.finishInitialisation();
        target.dispatchEvent("initialised");
        initialised = true;
    };

    let init = async () => {
        if (!domain) {
            try {
                domain = await $$.promisify(scAPI.getDIDDomain)();
            } catch (e) {
                return target.dispatchEvent("error", createOpenDSUErrorWrapper(`Failed to get did domain`, e));
            }
        }
        resolver.loadDSU(keySSISpace.createConstSSI(domain, name), async (err, constDSUInstance) => {
            if (err) {
                if (isInitialisation === false) {
                    return target.dispatchEvent("error", err);
                }
                try {
                    await createDSU(domain, name);
                } catch (e) {
                    return target.dispatchEvent("error", createOpenDSUErrorWrapper(`Failed to create DSU`, e));
                }
                return;
            }

            try {
                const dsuContext = await $$.promisify(constDSUInstance.getArchiveForPath)(WRITABLE_DSU_PATH);
                target.dsu = dsuContext.archive;
            } catch (e) {
                return target.dispatchEvent("error", createOpenDSUErrorWrapper(`Failed to load writableDSU`, e));
            }

            target.finishInitialisation();
            target.dispatchEvent("initialised");
        });
    }

    target.init = () => {
        //this settimeout is to allow proper event setup before initialization
        setTimeout(init, 0);
    }

    target.getPrivateKeys = () => {
        if (!target.privateKey) {
            throw Error(`Private key not available. DID init status: ${initialised}`);
        }
        return [target.privateKey];
    };

    target.getPublicKey = (format, callback) => {
        target.dsu.listFiles(PUB_KEYS_PATH, (err, pubKeys) => {
            if (err) {
                return callback(createOpenDSUErrorWrapper(`Failed to read public key for did ${target.getIdentifier()}`, err));
            }

            let pubKey = Buffer.from(pubKeys[pubKeys.length - 1], "hex");
            if (format === "raw") {
                return callback(undefined, pubKey);
            }

            try {
                pubKey = crypto.convertPublicKey(pubKey, format);
            } catch (e) {
                return callback(createOpenDSUErrorWrapper(`Failed to convert raw public key to pem`, e));
            }

            callback(undefined, pubKey);
        });
    };

    target.getDomain = () => {
        return domain;
    };

    target.addPublicKey = (publicKey, callback) => {
        target.dsu.startOrAttachBatch((err, batchId) => {
            if (err) {
                return callback(createOpenDSUErrorWrapper(`Failed to begin batch`, err));
            }

            target.dsu.writeFile(`${PUB_KEYS_PATH}/${publicKey.toString("hex")}`, async (err) => {
                if (err) {
                    const writeError = createOpenDSUErrorWrapper(`Failed to add public key for did ${target.getIdentifier()}`, err);
                    try {
                        await target.dsu.cancelBatchAsync(batchId);
                    }catch (e) {
                        //not that relevant
                        //return callback(createOpenDSUErrorWrapper(`Failed to cancel batch`, e, writeError));
                        console.log(e);
                    }
                    return callback(writeError);
                }

                target.dsu.commitBatch(batchId, callback);
            });
        });
    }
}

module.exports = ConstDID_Document_Mixin;

}).call(this)}).call(this,require("buffer").Buffer)

},{"../../error":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/error/index.js","../../utils/ObservableMixin":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/utils/ObservableMixin.js","../W3CDID_Mixin":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/w3cdid/W3CDID_Mixin.js","buffer":false,"opendsu":"opendsu"}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/w3cdid/didssi/GroupDID_Document.js":[function(require,module,exports){
const methodsNames = require("../didMethodsNames");
const {createOpenDSUErrorWrapper} = require("../../error");

function GroupDID_Document(enclave, domain, groupName, isInitialisation) {
    if (typeof domain === "undefined" || typeof groupName === "undefined") {
        throw Error(`Invalid number of arguments. Expected blockchain domain and group name.`);
    }

    let mixin = require("./ConstDID_Document_Mixin");
    mixin(this, enclave, domain, groupName, isInitialisation);
    const bindAutoPendingFunctions = require("../../utils/BindAutoPendingFunctions").bindAutoPendingFunctions;
    const openDSU = require("opendsu");
    const MEMBERS_FILE = "members";

    this.getMethodName = () => {
        return methodsNames.GROUP_METHOD_NAME;
    }

    this.addMember = (identity, memberInfo, callback) => {
        if (typeof memberInfo === "function") {
            callback = memberInfo;
            memberInfo = identity;
        }
        updateMembers("add", [identity], [memberInfo], callback);
    };

    this.addMembers = (identities, aliases, callback) => {
        updateMembers("add", identities, aliases, callback);
    };

    this.removeMember = (identity, callback) => {
        updateMembers("remove", [identity], callback);
    };

    this.removeMembers = (identities, callback) => {
        updateMembers("remove", identities, callback);
    };

    this.listMembersInfo = (callback) => {
        readMembers((err, members) => {
            if (err) {
                return callback(err);
            }

            callback(undefined, Object.values(members));
        });
    };

    this.listMembersByIdentity = (callback) => {
        readMembers((err, members) => {
            if (err) {
                return callback(err);
            }

            callback(undefined, Object.keys(members));
        });
    };

    this.getMemberIdentity = (name, callback) => {
        readMembers((err, members) => {
            if (err) {
                return callback(err);
            }

            const member = Object.keys(members).find(identifier => members[identifier] === name);
            if (typeof member === "undefined") {
                return callback(Error(`Failed to find member with alias ${name}`));
            }
            callback(undefined, Object.keys(member)[0]);
        });
    };

    this.getMemberInfo = (identity, callback) => {
        readMembers((err, members) => {
            if (err) {
                return callback(err);
            }

            const memberInfo = members[identity];
            if (typeof memberInfo === "undefined") {
                return callback(Error(`Failed to find member with id ${identity}`));
            }
            callback(undefined, memberInfo);
        });
    };

    this.getMembers = (callback) => {
        readMembers(callback);
    }

    this.getIdentifier = () => {
        return `did:ssi:group:${domain}:${groupName}`;
    };

    this.getGroupName = () => {
        return groupName;
    };

    this.sendMessage = (message, callback) => {
        const w3cDID = openDSU.loadAPI("w3cdid");
        if (typeof message === "object") {
            try {
                message = message.getSerialisation();
            } catch (e) {
                return callback(e);
            }
        }
        readMembers(async (err, members) => {
            if (err) {
                return callback(err);
            }

            const membersIds = Object.keys(members);
            const noMembers = membersIds.length;
            let senderDIDDocument;
            try {
                senderDIDDocument = await $$.promisify(w3cDID.resolveDID)(membersIds[0]);
            } catch (e) {
                return callback(e);
            }
            let counter = noMembers;
            for (let i = 0; i < noMembers; i++) {
                try {
                    const receiverDIDDocument = await $$.promisify(w3cDID.resolveDID)(membersIds[i]);
                    await $$.promisify(senderDIDDocument.sendMessage)(message, receiverDIDDocument)
                } catch (e) {
                    return callback(e);
                }

                counter--;
                if (counter === 0) {
                    return callback();
                }
            }
        });
    };

    const readMembers = (callback) => {
        this.dsu.readFile(MEMBERS_FILE, (err, members) => {
            if (err || typeof members === "undefined") {
                members = {};
            } else {
                try {
                    members = JSON.parse(members.toString());
                } catch (e) {
                    return callback(e);
                }
            }

            callback(undefined, members);
        });
    };

    const updateMembers = (operation, identities, info, callback) => {
        if (typeof info === "function") {
            callback = info;
            info = identities;
        }

        if (!Array.isArray(identities)) {
            return callback(Error(`Invalid format for identities. Expected array.`));
        }

        if (operation === "remove" && !Array.isArray(info)) {
            return callback(Error(`Invalid format for info. Expected array.`));
        }

        readMembers((err, members) => {
            if (err) {
                return callback(err);
            }

            if (operation === "remove" || operation === "add") {
                if (operation === "remove") {
                    identities.forEach(id => {
                        if (typeof members[id] !== "undefined") {
                            delete members[id];
                        }
                    });
                } else {
                    identities.forEach((id, index) => {
                        if (typeof id === "object") {
                            id = id.getIdentifier();
                        }
                        if (typeof members[id] === "undefined") {
                            members[id] = info[index];
                        }
                    });
                }

                return this.dsu.startOrAttachBatch( (err, batchId) => {
                    if (err) {
                        return callback(err);
                    }

                    this.dsu.writeFile(MEMBERS_FILE, JSON.stringify(members), async err => {
                        if (err) {
                            const writeError = createOpenDSUErrorWrapper(`Failed to write members`, err);
                            try{
                                await this.dsu.cancelBatchAsync(batchId);
                            }catch (e) {
                                //not that relevant
                                //return callback(createOpenDSUErrorWrapper(`Failed to cancel batch`, e, writeError));
                                console.log(e);
                            }
                            return callback(writeError);
                        }

                        this.dsu.commitBatch(batchId, callback);
                    });
                })
            } else {
                callback(Error(`Invalid operation ${operation}`));
            }
        });
    };

    bindAutoPendingFunctions(this, ["init", "getIdentifier", "getGroupName", "addPublicKey", "on", "off", "dispatchEvent", "removeAllObservers"]);

    try {
        this.init();
    } catch (e) {
        this.dispatchEvent("error", e);
    }
    return this;
}


module.exports = {
    initiateDIDDocument: function (enclave, domain, groupName) {
        return new GroupDID_Document(enclave, domain, groupName)
    },
    createDIDDocument: function (enclave, tokens) {
        return new GroupDID_Document(enclave, tokens[3], tokens[4], false);
    }
};

},{"../../error":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/error/index.js","../../utils/BindAutoPendingFunctions":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/utils/BindAutoPendingFunctions.js","../didMethodsNames":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/w3cdid/didMethodsNames.js","./ConstDID_Document_Mixin":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/w3cdid/didssi/ConstDID_Document_Mixin.js","opendsu":"opendsu"}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/w3cdid/didssi/NameDID_Document.js":[function(require,module,exports){
const methodsNames = require("../didMethodsNames");

function NameDID_Document(enclave, domain, name, isInitialisation, desiredPrivateKey) {
    if (arguments.length === 3) {
        isInitialisation = name;
        name = domain;
        domain = undefined;
    }
    if (typeof name === "undefined") {
        throw Error(`Argument name is missing`);
    }

    let mixin = require("./ConstDID_Document_Mixin");
    mixin(this, enclave, domain, name, isInitialisation, desiredPrivateKey);
    const bindAutoPendingFunctions = require("../../utils/BindAutoPendingFunctions").bindAutoPendingFunctions;

    this.getMethodName = () => {
        return methodsNames.NAME_SUBTYPE;
    }

    this.getIdentifier = () => {
        return `did:ssi:name:${this.getDomain()}:${name}`;
    };

    this.getName = () => {
        return name;
    };

    bindAutoPendingFunctions(this, ["getPrivateKeys", "init", "getIdentifier", "getName", "on", "off", "dispatchEvent", "removeAllObservers", "addPublicKey", "readMessage", "getDomain", "getHash"]);
    this.init();
    return this;
}


module.exports = {
    initiateDIDDocument: function (enclave, domain, name, desiredPrivateKey) {
        return new NameDID_Document(enclave, domain, name, true, desiredPrivateKey);
    },
    createDIDDocument: function (enclave, tokens, desiredPrivateKey) {
        return new NameDID_Document(enclave, tokens[3], tokens[4], false, desiredPrivateKey);
    }
};

},{"../../utils/BindAutoPendingFunctions":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/utils/BindAutoPendingFunctions.js","../didMethodsNames":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/w3cdid/didMethodsNames.js","./ConstDID_Document_Mixin":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/w3cdid/didssi/ConstDID_Document_Mixin.js"}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/w3cdid/didssi/SReadDID_Document.js":[function(require,module,exports){
const methodsNames = require("../didMethodsNames");

function SReadDID_Document(enclave, isInitialisation, seedSSI) {
    const DID_mixin = require("./ConstDID_Document_Mixin");
    const ObservableMixin = require("../../utils/ObservableMixin");
    let tokens;
    let sReadSSI;

    const PUB_KEYS_PATH = "publicKeys";
    DID_mixin(this, enclave);
    ObservableMixin(this);
    const openDSU = require("opendsu");
    const keySSISpace = openDSU.loadAPI("keyssi");
    const resolver = openDSU.loadAPI("resolver");

    const createSeedDSU = async () => {
        try {
            this.dsu = await $$.promisify(resolver.createDSUForExistingSSI)(seedSSI);
        } catch (e) {
            return this.dispatchEvent("error", createOpenDSUErrorWrapper(`Failed to create seed dsu`, e));
        }

        let ssi;
        try {
            ssi = await $$.promisify(keySSISpace.createSeedSSI)(seedSSI.getDLDomain());
        } catch (e) {
            return this.dispatchEvent("error", createOpenDSUErrorWrapper(`Failed to create seed ssi`, e));
        }

        this.privateKey = ssi.getPrivateKey();
        const publicKey = ssi.getPublicKey("raw");

        try {
            await $$.promisify(this.dsu.writeFile)(`${PUB_KEYS_PATH}/${publicKey.toString("hex")}`);
        } catch (e) {
            return this.dispatchEvent("error", createOpenDSUErrorWrapper(`Failed to write public key in dsu`, e));
        }
    };

    this.init = async () => {
        if (typeof seedSSI === "string") {
            try {
                seedSSI = keySSISpace.parse(seedSSI);
            } catch (e) {
                return this.dispatchEvent("error", createOpenDSUErrorWrapper(`Failed to parse ssi ${seedSSI}`, e));
            }
        }

        if (isInitialisation) {
            try {
                sReadSSI = await $$.promisify(seedSSI.derive)();
            } catch (e) {
                return this.dispatchEvent("error", createOpenDSUErrorWrapper(`Failed to derive seedSSI ${seedSSI.getIdentifier()}`, e));
            }
            await createSeedDSU();
            this.finishInitialisation();
            this.dispatchEvent("initialised");
        } else {
            tokens = seedSSI;
            sReadSSI = tokens.join(":");
            sReadSSI = keySSISpace.parse(sReadSSI);
            seedSSI = undefined;

            try {
                this.dsu = await $$.promisify(resolver.loadDSU)(sReadSSI);
            } catch (e) {
                return this.dispatchEvent("error", createOpenDSUErrorWrapper(`Failed to load dsu`, e));
            }

            this.finishInitialisation();
            this.dispatchEvent("initialised");
        }
    };

    this.getMethodName = () => {
        return methodsNames.S_READ_SUBTYPE;
    }

    this.getDomain = () => {
        let domain;
        if (!isInitialisation) {
            domain = sReadSSI.getDLDomain();
        } else {
            domain = seedSSI.getDLDomain();
        }

        return domain;
    }

    this.getIdentifier = () => {
        return `did:${sReadSSI.getIdentifier(true)}`
    };

    const bindAutoPendingFunctions = require("../../utils/BindAutoPendingFunctions").bindAutoPendingFunctions;
    bindAutoPendingFunctions(this, ["init", "getIdentifier", "getDomain", "on", "off", "addPublicKey"]);

    this.init();
    return this;
}

module.exports = {
    initiateDIDDocument: function (enclave, seedSSI) {
        return new SReadDID_Document(enclave, true, seedSSI)
    },
    createDIDDocument: function (enclave, tokens) {
        return new SReadDID_Document(enclave, false, tokens.slice(1));
    }
};

},{"../../utils/BindAutoPendingFunctions":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/utils/BindAutoPendingFunctions.js","../../utils/ObservableMixin":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/utils/ObservableMixin.js","../didMethodsNames":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/w3cdid/didMethodsNames.js","./ConstDID_Document_Mixin":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/w3cdid/didssi/ConstDID_Document_Mixin.js","opendsu":"opendsu"}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/w3cdid/didssi/SSIKeyDID_Document.js":[function(require,module,exports){
const methodsNames = require("../didMethodsNames");

function SSIKeyDID_Document(enclave, isInitialisation, seedSSI) {
    let DID_mixin = require("../W3CDID_Mixin");
    DID_mixin(this, enclave);
    const ObservableMixin = require("../../utils/ObservableMixin");
    ObservableMixin(this);
    const openDSU = require("opendsu");
    const keySSISpace = openDSU.loadAPI("keyssi");
    const crypto = openDSU.loadAPI("crypto");

    let tokens;
    const __init = async () => {
        if (!isInitialisation) {
            tokens = seedSSI;
            seedSSI = undefined;
        }

        if (typeof seedSSI === "string") {
            try {
                seedSSI = keySSISpace.parse(seedSSI);
            } catch (e) {
                return this.dispatchEvent("error", createOpenDSUErrorWrapper(`Failed to parse ssi ${seedSSI}`));
            }
        }

        setTimeout(()=>{
            this.dispatchEvent("initialised");
        },1)
    }

    this.getMethodName = () => {
        return methodsNames.SSI_KEY_SUBTYPE;
    }

    this.getDomain = () => {
        let domain;
        if (!isInitialisation) {
            domain = tokens[0];
        } else {
            domain = seedSSI.getDLDomain();
        }

        return domain;
    }

    const getRawPublicKey = () => {
        let publicKey;
        if (!isInitialisation) {
            publicKey = crypto.decodeBase58(tokens[1])
        } else {
            publicKey = seedSSI.getPublicKey("raw");
        }

        return publicKey;
    }

    this.getPublicKey = (format, callback) => {
        let pubKey = getRawPublicKey();
        try {
            pubKey = crypto.convertPublicKey(pubKey, format);
        } catch (e) {
            return callback(createOpenDSUErrorWrapper(`Failed to convert public key to ${format}`, e));
        }

        callback(undefined, pubKey);
    };

    this.getIdentifier = () => {
        const domain = this.getDomain();
        let publicKey = getRawPublicKey();
        publicKey = crypto.encodeBase58(publicKey);
        return `did:ssi:key:${domain}:${publicKey}`;
    };

    this.getPrivateKeys = () => {
        if(typeof seedSSI === "undefined"){
           throw Error("SeedSSI is not defined");
        }
        return [seedSSI.getPrivateKey()];
    };

    __init();
    return this;
}

module.exports = {
    initiateDIDDocument: function (enclave, seedSSI) {
        return new SSIKeyDID_Document(enclave, true, seedSSI);
    },
    createDIDDocument: function (enclave, tokens) {
        return new SSIKeyDID_Document(enclave, false,  [tokens[3], tokens[4]]);
    }
};

},{"../../utils/ObservableMixin":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/utils/ObservableMixin.js","../W3CDID_Mixin":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/w3cdid/W3CDID_Mixin.js","../didMethodsNames":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/w3cdid/didMethodsNames.js","opendsu":"opendsu"}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/w3cdid/didssi/ssiMethods.js":[function(require,module,exports){
function SReadDID_Method() {
    let SReadDID_Document = require("./SReadDID_Document");
    this.create = (enclave, seedSSI, callback) => {
        const sReadDIDDocument = SReadDID_Document.initiateDIDDocument(enclave, seedSSI);
        sReadDIDDocument.on("error", (err) => {
            callback(err);
        });

        sReadDIDDocument.on("initialised", () => {
            callback(undefined, sReadDIDDocument);
        });
    }
    this.resolve = function (enclave, tokens, callback) {
        const sReadDIDDocument = SReadDID_Document.createDIDDocument(enclave, tokens);
        sReadDIDDocument.on("initialised", () => {
            callback(undefined, sReadDIDDocument);
        });
    }
}

function SSIKeyDID_Method() {
    let KeyDIDDocument = require("./SSIKeyDID_Document");
    this.create = function (enclave, seedSSI, callback) {
        const keyDIDDocument = KeyDIDDocument.initiateDIDDocument(enclave, seedSSI);
        keyDIDDocument.on("error", callback);

        keyDIDDocument.on("initialised", () => {
            callback(undefined, keyDIDDocument);
        })
    }

    this.resolve = function (enclave, tokens, callback) {
        const keyDIDDocument = KeyDIDDocument.createDIDDocument(enclave, tokens)
        keyDIDDocument.on("error", callback);

        keyDIDDocument.on("initialised", () => {
            callback(undefined, keyDIDDocument);
        })
    }
}

function NameDID_Method() {
    const NameDIDDocument = require("./NameDID_Document");

    this.create = (enclave, domain, publicName, secret, callback) => {
        if(typeof secret === "function"){
            callback = secret;
            secret = undefined;
        }

        if (typeof publicName === "function") {
            callback = publicName;
            publicName = domain;
            domain = undefined;
        }
        const nameDIDDocument = NameDIDDocument.initiateDIDDocument(enclave, domain, publicName, secret);

        nameDIDDocument.on("error", (err) => {
            return callback(err);
        })

        nameDIDDocument.on("initialised", () => {
            callback(undefined, nameDIDDocument);
        });
    }

    this.resolve = (enclave, tokens, callback) => {
        const nameDIDDocument = NameDIDDocument.createDIDDocument(enclave, tokens);
        nameDIDDocument.on("error", (err) => {
            return callback(err);
        })

        nameDIDDocument.on("initialised", () => {
            callback(null, nameDIDDocument)
        });
    }
}

function GroupDID_Method() {
    const GroupDIDDocument = require("./GroupDID_Document");

    this.create = (enclave, domain, groupName, callback) => {
        const groupDIDDocument = GroupDIDDocument.initiateDIDDocument(enclave, domain, groupName);

        groupDIDDocument.on("error", (err) => {
            return callback(err);
        })

        groupDIDDocument.on("initialised", () => {
            callback(undefined, groupDIDDocument);
        })
    }

    this.resolve = (enclave, tokens, callback) => {
        const groupDIDDocument = GroupDIDDocument.createDIDDocument(enclave, tokens);

        groupDIDDocument.on("error", (err) => {
            return callback(err);
        })

        groupDIDDocument.on("initialised", () => {
            return callback(undefined, groupDIDDocument);
        })
    }
}

function create_SSIKeyDID_Method() {
    return new SSIKeyDID_Method();
}

function create_SReadDID_Method() {
    return new SReadDID_Method();
}

function create_NameDID_Method() {
    return new NameDID_Method();
}

function create_GroupDID_Method() {
    return new GroupDID_Method();
}


module.exports = {
    create_SSIKeyDID_Method,
    create_SReadDID_Method,
    create_NameDID_Method,
    create_GroupDID_Method
}

},{"./GroupDID_Document":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/w3cdid/didssi/GroupDID_Document.js","./NameDID_Document":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/w3cdid/didssi/NameDID_Document.js","./SReadDID_Document":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/w3cdid/didssi/SReadDID_Document.js","./SSIKeyDID_Document":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/w3cdid/didssi/SSIKeyDID_Document.js"}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/w3cdid/hubs/CommunicationHub.js":[function(require,module,exports){
let didDocuments = {};

function CommunicationHub() {
    const pubSub = require("soundpubsub").soundPubSub;
    const didAPI = require("opendsu").loadAPI("w3cdid");
    const connectedToMQ = {};
    let strongPubSub;
    const ERROR_CHANNEL = "errorChannel";
    const getChannelName = (did, messageType) => {
        return `${did.getIdentifier()}/${messageType}`;
    }

    const ensureDIDDocumentIsLoadedThenExecute = (did, fnToExecute) => {
        if (typeof did === "string") {
            if(didDocuments[did]){
                return fnToExecute(undefined, didDocuments[did]);
            }
            return didAPI.resolveDID(did, (err, resolvedDID) => {
                if (err) {
                    fnToExecute(err);
                    return;
                }

                didDocuments[did] = resolvedDID;
                did = resolvedDID;
                fnToExecute(undefined, did);
            });
        }
        let identifier = did.getIdentifier();
        if(!didDocuments[identifier]){
            didDocuments[identifier] = did;
        }
        fnToExecute(undefined, didDocuments[identifier]);
    }

    this.subscribe = (did, messageType, callback) => {
        const __subscribe = (err, did) => {
            if (!connectedToMQ[did.getIdentifier()]) {
                connectedToMQ[did.getIdentifier()] = true;
                did.waitForMessages((err, message) => {
                    if (err) {
                        pubSub.publish(getChannelName(did, ERROR_CHANNEL), {err});
                        console.error(err);
                        return;
                    }

                    try {
                        message = JSON.parse(message);
                    } catch (e) {
                        pubSub.publish(getChannelName(did, ERROR_CHANNEL), {err:e, message});
                        console.error(e);
                        return;
                    }

                    const channelName = getChannelName(did, message.messageType);
                    if (!pubSub.hasChannel(channelName)) {
                        pubSub.addChannel(channelName);
                    }

                    pubSub.publish(channelName, message);
                });
            }
            const channel = getChannelName(did, messageType);
            pubSub.subscribe(channel, callback);
        }

        ensureDIDDocumentIsLoadedThenExecute(did, __subscribe);
    };

    this.unsubscribe = (did, messageType, callback) => {
        const stopWaitingForMessages = (err, did) => {
            did.stopWaitingForMessages();
            const channel = getChannelName(did, messageType);
            delete connectedToMQ[did.getIdentifier()];
            pubSub.unsubscribe(channel, callback);
        }

        ensureDIDDocumentIsLoadedThenExecute(did, stopWaitingForMessages);
    };

    const subscribers = {};
    // soundpubSub keeps WeakRefs
    this.strongSubscribe = (did, messageType, callback) => {
        const __strongSubscribe = (err, did) => {
            const channelName = getChannelName(did, messageType);
            if (!subscribers[channelName]) {
                subscribers[channelName] = [];
            }

            const index = subscribers[channelName].findIndex(sub => sub === callback);
            if (index === -1) {
                subscribers[channelName].push(callback);
            }

            this.subscribe(did, messageType, callback);
        }

        ensureDIDDocumentIsLoadedThenExecute(did, __strongSubscribe);
    }

    this.strongUnsubscribe = (did, messageType, callback) => {
        const channelName = getChannelName(did, messageType);
        const __strongUnsubscribe = (err, did) => {
            if (!subscribers[channelName]) {
                return callback();
            }

            const index = subscribers[channelName].findIndex(sub => sub === callback);
            if (index === -1) {
                return callback();
            }

            subscribers[channelName].splice(index);
            if (subscribers[channelName].length === 0) {
                delete subscribers[channelName];
                return callback();
            }

            this.unsubscribe(did, messageType, callback);
        }

        ensureDIDDocumentIsLoadedThenExecute(did, __strongUnsubscribe);
    }

    this.getPubSub = () => {
        return pubSub;
    }

    const createStrongPubSub = (_pubSub) => {
        const strongPubSub = Object.assign({}, _pubSub);
        strongPubSub.subscribe = (target, callback, waitForMore, filter) => {
            if (!subscribers[target]) {
                subscribers[target] = [];
            }

            const index = subscribers[target].findIndex(sub => sub === callback);
            if (index === -1) {
                subscribers[target].push(callback);
            }

            if (!_pubSub.hasChannel(target)) {
                _pubSub.addChannel(target);
            }

            _pubSub.subscribe(target, callback, waitForMore, filter);
        }

        strongPubSub.unsubscribe = (target, callback, filter) => {
            if (!strongPubSub[target]) {
                return callback();
            }

            const index = subscribers[target].findIndex(sub => sub === callback);
            if (index === -1) {
                return callback();
            }

            subscribers[target].splice(index);
            if (subscribers[target].length === 0) {
                delete subscribers[target];
                return callback();
            }

            _pubSub.unsubscribe(target, callback, filter);
        }

        return strongPubSub;
    }

    this.getStrongPubSub = () => {
        if (!strongPubSub) {
            strongPubSub = createStrongPubSub(pubSub);
        }

        return strongPubSub;
    }

    this.stop = (did)=>{
        ensureDIDDocumentIsLoadedThenExecute(did, (err, didDocument)=>{
                didDocument.stopWaitingForMessages();
        });
    }

    this.registerErrorHandler = (did, handler)=>{
        ensureDIDDocumentIsLoadedThenExecute(did, (err, didDocument)=>{
            pubSub.subscribe(getChannelName(didDocument, ERROR_CHANNEL), handler);
        });
    }

    this.unRegisterErrorHandler = (did, handler) => {
        ensureDIDDocumentIsLoadedThenExecute(did, (err, didDocument)=>{
            pubSub.unsubscribe(getChannelName(didDocument, ERROR_CHANNEL), handler);
        });
    }
}

const getCommunicationHub = () => {
    if (!$$.CommunicationHub) {
        $$.CommunicationHub = new CommunicationHub();
    }

    return $$.CommunicationHub;
}

module.exports = {
    getCommunicationHub
}

},{"opendsu":"opendsu","soundpubsub":"soundpubsub"}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/w3cdid/hubs/TypicalBusinessLogicHub.js":[function(require,module,exports){
const {createOpenDSUErrorWrapper} = require("../../error");
const getCheckVariableFunction = function (envVariableName, hubContext, selector,  callback) {
    if (hubContext[selector]) {
        hubContext.self.finishInitialisation();
        return callback(undefined, hubContext[selector]);
    }
    hubContext.configAPI.getEnv(envVariableName, (err, envValue) => {
        if (err || !envValue) {
            return callback(undefined, false);
        }

        hubContext[selector] = envValue;
        hubContext.self.finishInitialisation();
        callback(undefined, envValue);
    });
};

const setVariable = function (envVariableName, value, hubContext, selector, callback) {
    hubContext[selector] = value;
    hubContext.configAPI.setEnv(envVariableName, value, err => {
        if (err) {
            return callback(createOpenDSUErrorWrapper(`Failed to initialise app`, err));
        }

        hubContext.self.finishInitialisation();
        callback(undefined);
    });
};
function TypicalBusinessLogicHub() {
    const openDSU = require("opendsu");
    const didAPI = openDSU.loadAPI("w3cdid");
    const configAPI = openDSU.loadAPI("config");
    const utilsAPI = openDSU.loadAPI("utils");
    const constants = openDSU.constants;
    const APP_MAIN_DID = "appMainDID";
    const SHARED_ENCLAVE = "sharedEnclave";
    let hubContext = {
        appMainDID: undefined,
        sharedEnclave: undefined,
        self: this,
        configAPI
    }
    const commHub = didAPI.getCommunicationHub();

    this.mainDIDCreated = (callback) => {
        getCheckVariableFunction(constants.MAIN_APP_DID, hubContext, APP_MAIN_DID, callback);
    }

    this.setMainDID = (appMainDID, callback) => {
        setVariable(constants.MAIN_APP_DID, appMainDID, hubContext, APP_MAIN_DID, callback);
    }

    this.sharedEnclaveIsSet = (callback) => {
        getCheckVariableFunction(constants.SHARED_ENCLAVE, hubContext, SHARED_ENCLAVE, callback);
    }

    this.setSharedEnclave = (sharedEnclaveKeySSI, callback) => {
        setVariable(constants.SHARED_ENCLAVE, sharedEnclaveKeySSI, hubContext, SHARED_ENCLAVE, callback);
    }

    this.subscribe = (messageType, checkSecurityMethod, callback) => {
        commHub.subscribe(hubContext.appMainDID, messageType, checkSecurityMethod, callback);
    }

    this.unsubscribe = (messageType, callback) => {
        commHub.unsubscribe(hubContext.appMainDID, messageType, callback);
    }

    this.strongSubscribe = (messageType, callback) => {
        commHub.strongSubscribe(hubContext.appMainDID, messageType, callback);
    }

    this.strongUnsubscribe = (messageType, callback) => {
        commHub.strongUnsubscribe(hubContext.appMainDID, messageType, callback);
    }

    this.stop = () => {
        commHub.stop(hubContext.appMainDID);
    }

    this.registerErrorHandler = (handler) => {
        commHub.registerErrorHandler(hubContext.appMainDID, handler);
    }

    this.unRegisterErrorHandler = (handler) => {
        commHub.unRegisterErrorHandler(hubContext.appMainDID, handler);
    }

    utilsAPI.bindParallelAutoPendingFunctions(this, ["mainDIDCreated", "setMainDID", "sharedEnclaveIsSet", "setSharedEnclave"]);
}

const getTypicalBusinessLogicHub = () => {
    if (!$$.TypicalBusinessLogicHub) {
        $$.TypicalBusinessLogicHub = new TypicalBusinessLogicHub();
    }

    return $$.TypicalBusinessLogicHub;
}

module.exports = {
    getTypicalBusinessLogicHub
}
},{"../../error":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/error/index.js","opendsu":"opendsu"}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/w3cdid/index.js":[function(require,module,exports){
/*
    OpenDSU W3C compatible  ID pluginisable resolver  that can resolve arbitrary DID methods.

        1. SeedSSI compatible DID method that does not need anchoring or external DSUs
            did:ssi:key:blockchain_domain::publicKey:v2:

        2.  DID method storing the public key in an anchored DSU. It is a SeedSSI compatible DID method.
            did:ssi:sread:blockchain_domain:hash_privateKey:hash_publicKey:

        3.  DID method storing the public key in an immutable DSU that is mounting another mutable DSU to store the keys
            did:ssi:name:blockchain_domain:public-name:::

        4. Group DID
            did:ssi:group:blockchain_domain:const_string

        5. DID Web Method
            did:web:internet_domain.

        6. SSI DID_KEY
            did:key:public_key

        7. DID DEMO
            did:demo:const_string
        TODO: analise the implementation of resolvers  masquerading as DSUs anchored in the BDNS central root:  did:ethereum:whatever

 */

const methodsNames = require("./didMethodsNames");
let methodRegistry = {};

const openDSU = require("opendsu");
const scAPI = openDSU.loadAPI("sc");

/*
    Create a new W3CDID based on SeedSSI
 */
function createIdentity(didMethod, ...args) {
    we_createIdentity(undefined, didMethod, ...args);
}

function resolveNameDID(domain, publicName, secret, callback) {
    if (typeof secret == "function") {
        callback = secret;
        secret = undefined;
    }
    const identifier = `did:ssi:name:${domain}:${publicName}`;
    if (secret) {
        resolveDID(identifier, (err, didDocument) => {
            if (err) {
                createIdentity("ssi:name", domain, publicName, secret, callback);
            } else {
                registerNameDIDSecret(domain, publicName, secret, (err) => {
                    if (err) {
                        return callback(err);
                    }
                    // A new DID document instance, containing the new private key is needed
                    resolveDID(identifier, callback)
                });
            }
        })
    } else {
        resolveDID(identifier, callback);
    }
}

function registerNameDIDSecret(domain, publicName, secret, callback) {
    const sc = openDSU.loadAPI("sc");
    sc.getMainEnclave((err, enclave) => {
        if (err) {
            return callback(err, undefined);
        }
        const identifier = `did:ssi:name:${domain}:${publicName}`;
        resolveDID(identifier, (err, didDoc) => {
            if (err) {
                return callback(err, undefined);
            }
            enclave.addPrivateKeyForDID(didDoc, secret, callback);
        });
    })
}

function we_createIdentity(enclave, didMethod, ...args) {
    let callback = args.pop();

    const __createAndStoreDID = (enclave) => {
        methodRegistry[didMethod].create(enclave, ...args, (err, didDocument) => {
            if (err) {
                return callback(err);
            }

            let privateKeys;
            try {
                privateKeys = didDocument.getPrivateKeys();
            } catch (e) {
                return callback(e);
            }
            enclave.storeDID(didDocument, privateKeys, err => callback(err, didDocument));
        });
    }
    if (typeof enclave === "undefined") {
        if (!scAPI.mainEnclaveIsInitialised()) {
            return methodRegistry[didMethod].create(enclave, ...args, callback);
        }
        scAPI.getMainEnclave((err, mainEnclave) => {
            if (err) {
                return callback(err);
            }

            __createAndStoreDID(mainEnclave);
        });
    } else {
        __createAndStoreDID(enclave);
    }
}

/*
    Returns an error or an instance of W3CDID
 */
function resolveDID(identifier, callback) {
    we_resolveDID(undefined, identifier, callback);
}

function we_resolveDID(enclave, identifier, callback) {
    let tokens = identifier.split(":");
    if (tokens[0] !== "did") {
        return callback(Error("Wrong identifier format. Missing did keyword."));
    }
    let method = tokens[1];
    if (tokens[1] === methodsNames.OPENDSU_METHOD_NAME) {
        method = `${tokens[1]}:${tokens[2]}`;
    }

    if (typeof enclave === "undefined") {
        if (!scAPI.mainEnclaveIsInitialised()) {
            methodRegistry[method].resolve(undefined, tokens, callback);
            return;
        }
        scAPI.getMainEnclave((err, mainEnclave) => {
            if (err) {
                return callback(err);
            }

            methodRegistry[method].resolve(mainEnclave, tokens, callback);
        })
    } else {
        methodRegistry[method].resolve(enclave, tokens, callback);
    }
}

function getKeyDIDFromSecret(secret, callback) {
    createIdentity(methodsNames.KEY_SUBTYPE, secret, callback);
}

function registerDIDMethod(method, implementation) {
    methodRegistry[method] = implementation;
}

function generateSystemDIDFromSecret(secret) {
    getKeyDIDFromSecret(secret, (err, didDocument) => {
        if (err) {
            console.error("Failed to create the system DID", err);
            throw err;
        }
        $$.SYSTEM_DID_DOCUMENT = didDocument;
        $$.SYSTEM_IDENTIFIER = didDocument.getIdentifier();
    });
}

function initSystemDID() {
    if (process.env.SSO_SECRETS_ENCRYPTION_KEY) {
        generateSystemDIDFromSecret(process.env.SSO_SECRETS_ENCRYPTION_KEY);
    } else {
        console.warn("The system is not safe for production. The SSO_SECRETS_ENCRYPTION_KEY environment variable is not set.")
        generateSystemDIDFromSecret("default");
    }
}

registerDIDMethod(methodsNames.S_READ_SUBTYPE, require("./didssi/ssiMethods").create_SReadDID_Method());
registerDIDMethod(methodsNames.SSI_KEY_SUBTYPE, require("./didssi/ssiMethods").create_SSIKeyDID_Method());
registerDIDMethod(methodsNames.NAME_SUBTYPE, require("./didssi/ssiMethods").create_NameDID_Method());

registerDIDMethod(methodsNames.GROUP_METHOD_NAME, require("./didssi/ssiMethods").create_GroupDID_Method());
registerDIDMethod(methodsNames.KEY_SUBTYPE, require("./w3cdids/didMethods").create_KeyDID_Method());

registerDIDMethod(methodsNames.DEMO_METHOD_NAME, require("./w3cdids/didMethods").create_KeyDID_Method());
// registerDIDMethod(methodsNames.DEMO_METHOD_NAME, require("./demo/diddemo").create_demo_DIDMethod());

module.exports = {
    createIdentity,
    we_createIdentity,
    resolveDID,
    we_resolveDID,
    registerDIDMethod,
    resolveNameDID,
    registerNameDIDSecret,
    initSystemDID,
    getKeyDIDFromSecret,
    CryptographicSkills: require("./CryptographicSkills/CryptographicSkills"),
    W3CDIDMixin: require('./W3CDID_Mixin'),
    W3CCVCMixin: require('./W3CVC_Mixin'),
    getCommunicationHub: require("./hubs/CommunicationHub").getCommunicationHub,
    getTypicalBusinessLogicHub: require("./hubs/TypicalBusinessLogicHub").getTypicalBusinessLogicHub,
    SecretsHandler: require("./utils/SecretsHandler.js")
}

},{"./CryptographicSkills/CryptographicSkills":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/w3cdid/CryptographicSkills/CryptographicSkills.js","./W3CDID_Mixin":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/w3cdid/W3CDID_Mixin.js","./W3CVC_Mixin":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/w3cdid/W3CVC_Mixin.js","./didMethodsNames":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/w3cdid/didMethodsNames.js","./didssi/ssiMethods":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/w3cdid/didssi/ssiMethods.js","./hubs/CommunicationHub":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/w3cdid/hubs/CommunicationHub.js","./hubs/TypicalBusinessLogicHub":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/w3cdid/hubs/TypicalBusinessLogicHub.js","./utils/SecretsHandler.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/w3cdid/utils/SecretsHandler.js","./w3cdids/didMethods":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/w3cdid/w3cdids/didMethods.js","opendsu":"opendsu"}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/w3cdid/utils/SecretsHandler.js":[function(require,module,exports){
function SecretsHandler(){

  const opendsu = require("opendsu");
  const w3cdid = opendsu.loadApi("w3cdid");

  const knownDIDs = {};

  let didDocument;
  this.setDIDDocument = async (currentDID)=>{
    didDocument = await $$.promisify(w3cdid.resolveDID)(currentDID);
    return;
  }

  function base58DID(did){
    const crypto = opendsu.loadApi("crypto");
    if(typeof did === "object"){
      did = did.getIdentifier();
    }
    return crypto.encodeBase58(did);
  }

  async function storeSecret(userDID, secret, name="credential"){
    let origin = window.top.location.origin;
    let request = {
      method: "PUT",
      headers: {
        "Content-Type": "application/json"
      },
      body: secret
    }

    if(typeof request.body !== "string"){
      request.body = JSON.stringify(request.body);
    }
    let encodedDID = base58DID(userDID);
    return await fetch(`${origin}/putDIDSecret/${encodedDID}/${name}`, request);
  }

  async function clearSecret(did, name="credential"){
    let origin = window.top.location.origin;
    let request = {
      method: "DELETE",
      headers: {
        "Content-Type": "application/json"
      }
    }
    let encodedDID = base58DID(did);
    return await fetch(`${origin}/removeDIDSecret/${encodedDID}/${name}`, request);
  }

  async function getSecret(did, name="credential"){
    let origin = window.top.location.origin;
    let request = {
      method: "GET",
      headers: {
        "Content-Type": "application/json"
      }
    }
    let encodedDID = base58DID(did);
    return await fetch(`${origin}/getDIDSecret/${encodedDID}/${name}`, request).then(result=>{
      if(result.ok){
        return result.json();
      }
      let err = Error("Failed to get secret");
      err.code = result.status;
      throw err;
    });
  }

  function clean(target){
    if(target){
      target.pk = undefined;
      delete target.pk;
      target.__timestamp = undefined;
      delete target.__timestamp;
      target.__version = undefined;
      delete target.__version;
    }
    return target;
  }

  this.authorizeUser = async (userDID, groupCredential, enclave) => {
    //starting to clean
    if(groupCredential && groupCredential.allPossibleGroups){
      for(let i=0; i < groupCredential.allPossibleGroups.length; i++){
        let group = groupCredential.allPossibleGroups[i];
        groupCredential.allPossibleGroups[i] = clean(group);
      }
    }
    groupCredential = clean(groupCredential);
    enclave = clean(enclave);
    //done cleaning...

    let secret = {groupCredential, enclave};
    let userDidDocument = await $$.promisify(w3cdid.resolveDID)(userDID);
    let encryptedSecret = await $$.promisify(didDocument.encryptMessage)(userDidDocument, JSON.stringify(secret))
    return await storeSecret(userDID, encryptedSecret);
  }

  this.unAuthorizeUser = async (did) => {
    return await clearSecret(did);
  }

  this.checkIfUserIsAuthorized = async (did) => {
    let secret = await getSecret(did);
    if(secret){
      let userDidDocument;
      if(!knownDIDs[did]){
        userDidDocument = await $$.promisify(w3cdid.resolveDID)(did);
        knownDIDs[did] = userDidDocument;
      }else{
        userDidDocument = knownDIDs[did];
      }

      if(typeof secret !== "object"){
        secret = JSON.parse(secret);
      }
      let decryptedSecret = await $$.promisify(userDidDocument.decryptMessage)(secret);
      let creds = JSON.parse(decryptedSecret);
      return creds;
    }
    return;
  }

  this.storeDIDSecret = storeSecret;
  this.getDIDSecret = getSecret;
  this.clearDIDSecret = clearSecret;
}

let instance;
async function getInstance(currentDID){
  if($$.environmentType !== "browser"){
    throw Error("Implementation is meant to be used on browser environment for the moment!");
  }
  if(instance){
    return instance;
  }

  if(!currentDID){
    //when the app doesn't have a did for us...
    return new SecretsHandler();
  }

  instance = new SecretsHandler();
  await instance.setDIDDocument(currentDID);

  return instance;
}

module.exports = {getInstance};
},{"opendsu":"opendsu"}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/w3cdid/w3cdids/KeyDID_Document.js":[function(require,module,exports){
(function (Buffer){(function (){
const methodsNames = require("../didMethodsNames");

function KeyDID_Document(enclave, isInitialisation, publicKey, privateKey) {
    const DID_mixin = require("../W3CDID_Mixin");
    const ObservableMixin = require("../../utils/ObservableMixin");
    DID_mixin(this, enclave);
    ObservableMixin(this);
    let domain;
    const openDSU = require("opendsu");
    const crypto = openDSU.loadAPI("crypto");

    const create = () => {
        if (typeof privateKey === "undefined") {
            if (typeof publicKey === "undefined") {
                const keyPair = crypto.generateKeyPair();
                privateKey = keyPair.privateKey;
                publicKey = crypto.encodeBase58(keyPair.publicKey);
            }
        } else {
            if (typeof privateKey === "string") {
                privateKey = Buffer.from(privateKey);
            }
            publicKey = crypto.encodeBase58(crypto.getPublicKeyFromPrivateKey(privateKey));
        }
    }

    const load = () => {
        if (!publicKey) {
            return this.dispatchEvent("error", Error("Public key is missing from argument list."));
        }
        publicKey = publicKey.slice(4);
    }

    const init = () => {
        setTimeout(() => {
            if (isInitialisation) {
                create();
            } else {
                load();
            }
            this.dispatchEvent("initialised");
        }, 1)
    };

    const getRawPublicKey = () => {
        return crypto.decodeBase58(publicKey);
    }

    this.getPublicKey = (format, callback) => {
        let pubKey = getRawPublicKey();
        if (format === "raw") {
            return callback(undefined, pubKey);
        }
        try {
            pubKey = crypto.convertPublicKey(pubKey, format);
        } catch (e) {
            return callback(createOpenDSUErrorWrapper(`Failed to convert public key to ${format}`, e));
        }

        callback(undefined, pubKey);
    };

    this.getMethodName = () => {
        return methodsNames.KEY_SUBTYPE;
    }

    this.getDomain = () => {
        return domain;
    }

    this.getIdentifier = () => {
        return `did:key:zQ3s${publicKey}`;
    };

    this.getPrivateKeys = () => {
        return [privateKey];
    };

    init();
}

module.exports = {
    initiateDIDDocument: function (enclave, publicKey, privateKey) {
        return new KeyDID_Document(enclave, true, publicKey, privateKey);
    }, createDIDDocument: function (enclave, tokens) {
        return new KeyDID_Document(enclave, false, tokens[2]);
    }
};

}).call(this)}).call(this,require("buffer").Buffer)

},{"../../utils/ObservableMixin":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/utils/ObservableMixin.js","../W3CDID_Mixin":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/w3cdid/W3CDID_Mixin.js","../didMethodsNames":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/w3cdid/didMethodsNames.js","buffer":false,"opendsu":"opendsu"}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/w3cdid/w3cdids/didMethods.js":[function(require,module,exports){
function KeyDID_Method() {
    let KeyDIDDocument = require("./KeyDID_Document");
    this.create = function (enclave, publicKey, privateKey, secret, callback) {
        if (typeof publicKey === "function") {
            callback = publicKey;
            publicKey = undefined;
            privateKey = undefined;
            secret = undefined;
        }

        if (typeof privateKey === "function") {
            callback = privateKey;
            privateKey = undefined;
            secret = publicKey;
        }

        if (typeof secret === "function") {
            callback = secret;
            secret = undefined;
        }

        if(privateKey && secret){
            return callback(Error("Only one of privateKey or secret should be provided"));
        }

        if (secret) {
            privateKey = require("opendsu").loadAPI("crypto").deriveEncryptionKey(secret);
        }
        const keyDIDDocument = KeyDIDDocument.initiateDIDDocument(enclave, publicKey, privateKey);
        keyDIDDocument.on("error", callback);

        keyDIDDocument.on("initialised", () => {
            callback(undefined, keyDIDDocument);
        });
    }

    this.resolve = function (enclave, tokens, callback) {
        const keyDIDDocument = KeyDIDDocument.createDIDDocument(enclave, tokens);
        keyDIDDocument.on("error", callback);

        keyDIDDocument.on("initialised", () => {
            callback(undefined, keyDIDDocument);
        });
    }
}

module.exports = {
    create_KeyDID_Method() {
        return new KeyDID_Method();
    }
}
},{"./KeyDID_Document":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/w3cdid/w3cdids/KeyDID_Document.js","opendsu":"opendsu"}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/workers/bootScript/node.js":[function(require,module,exports){
module.exports = () => {
    const worker_threads = "worker_threads";
    const { parentPort } = require(worker_threads);

    parentPort.postMessage("ready");

    parentPort.on("message", ({ functionName, payload }) => {
        console.log(`[workers] node worker activated by function "${functionName}"`);

        try {
            const result = require("opendsu").loadAPI("workers").getFunctionsRegistry()[functionName](payload);
            parentPort.postMessage({ result });
        } catch (error) {
            parentPort.postMessage({ error });
        }
    });

    process.on("uncaughtException", (error) => {
        console.error("[workers] uncaughtException inside node worker", error);

        setTimeout(() => process.exit(1), 100);
    });
}
},{"opendsu":"opendsu"}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/workers/bootScript/web.js":[function(require,module,exports){
module.exports = () => {
    addEventListener('message', (event) => {
        const { functionName, payload } = event.data;

        console.log(`[workers] web worker activated by function "${functionName}"`);

        try {
            const result = require("opendsu").loadAPI("workers").getFunctionsRegistry()[functionName](payload);
            postMessage({ result });
        } catch (error) {
            postMessage({ error });
        }
    });

    addEventListener('error', (event) => {
        const error = event.data;

        console.error("[workers] web worker error", error);
    });
}
},{"opendsu":"opendsu"}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/workers/functions.js":[function(require,module,exports){
function runSyncFunction({ apiSpaceName, functionName, params }) {
    const openDSU = require("opendsu");
    const api = openDSU.loadAPI(apiSpaceName);

    if (!api[functionName]) {
        throw Error(`function "${functionName}" does not exists in "${apiSpaceName}"!`)
    }

    return api[functionName].apply(undefined, params);
}

function runSyncFunctionOnlyFromWorker({ apiSpaceName, functionName, params }) {
    return runSyncFunction({ apiSpaceName, functionName, params })
}

module.exports = {
    runSyncFunction,
    runSyncFunctionOnlyFromWorker
}
},{"opendsu":"opendsu"}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/workers/index.js":[function(require,module,exports){
(function (global,__dirname){(function (){
function getWebWorkerBootScript() {
    const scriptLocation = document.currentScript
        ? document.currentScript
        : new Error().stack.match(/([^ ^(\n])*([a-z]*:\/\/\/?)*?[a-z0-9/\\]*\.js/gi)[0];
    return URL.createObjectURL(
        new Blob(
            [
                `
                (function () {
                    importScripts("${scriptLocation}");
                    (${require("./bootScript/web").toString()})();     
                })()
                `
            ],
            { type: "application/javascript" }
        )
    );
}

function getNodeWorkerBootScript() {
    const openDSUScriptPath = require("path").join(__dirname, "../../../", global.bundlePaths.openDSU);
    return `
        require("${openDSUScriptPath}");
        (${require("./bootScript/node").toString()})();
    `;
}

function createPoolOfWebWorkers(options = {}) {
    if (!window.Worker) {
        return;
    }

    console.log("[workers] starting web worker...");

    const syndicate = require("syndicate");
    const blobURL = getWebWorkerBootScript();
    const workerPool = syndicate.createWorkerPool({
        bootScript: blobURL,
        workerStrategy: syndicate.WorkerStrategies.WEB_WORKERS,
        ...options
    });

    setTimeout(() => {
        // after usage, the blob must be removed in order to avoid memory leaks
        // it requires a timeout in order for syndicate to be able to get the blob script before it's removed
        URL.revokeObjectURL(blobURL);
    });

    return workerPool;
}

function createPoolOfNodeWorkers(options = {}) {
    const worker_threads = "worker_threads";
    const { isMainThread } = require(worker_threads);

    if (!isMainThread) {
        return;
    }

    console.log("[workers] starting node worker...");

    return require("syndicate").createWorkerPool({
        bootScript: getNodeWorkerBootScript(),
        workerOptions: { eval: true },
        ...options,
    });
}

function callbackForWorker(callback) {
    return (error, result) => {
        if (error) {
            return callback(error);
        }

        // this is quite a hack or workaround made for portability
        // in WebWorkers messages are transmitted through "Events" (event.data)
        // but in NodeWorkers messages are send as "Objects" (data)
        const {
            error: taskError,
            result: taskResult
        } = typeof Event !== "undefined" && result instanceof Event ? result.data : result;

        if (taskError) {
            return callback(taskError);
        }

        return callback(undefined, taskResult);
    }
}

function runTask(functionName, payload, callback) {
    // task is executed if there is a worker available
    const isExecuted = this.workerPool.runTaskImmediately({ functionName, payload }, callbackForWorker(callback));

    if (!isExecuted) {
        try {
            const result = require("opendsu").loadAPI("workers").getFunctionsRegistry()[functionName](payload);
            return callback(undefined, result);
        } catch (error) {
            return callback(error);
        }
    }
}

function addTask(functionName, payload, callback) {
    // task is queued if there is no worker available
    this.workerPool.addTask({ functionName, payload }, callbackForWorker(callback));
}


/**
 * Cross Environment wrapper over syndicate
 */
class CrossEnvironmentWorkerPool {
    constructor(options) {
        const { ENVIRONMENT_TYPES } = require("../moduleConstants.js");
        this.workerPool = undefined;
        this.environmentType = undefined;

        switch ($$.environmentType) {
            case ENVIRONMENT_TYPES.BROWSER_ENVIRONMENT_TYPE:
                this.workerPool = createPoolOfWebWorkers(options);
                this.environmentType = ENVIRONMENT_TYPES.BROWSER_ENVIRONMENT_TYPE;
                break;
            case ENVIRONMENT_TYPES.NODEJS_ENVIRONMENT_TYPE:
                this.workerPool = createPoolOfNodeWorkers(options);
                this.environmentType = ENVIRONMENT_TYPES.NODEJS_ENVIRONMENT_TYPE;
                break;
        }
    }

    runSyncFunction(apiSpaceName, functionName, ...params) {
        const currentFunctionName = "runSyncFunction";
        const callback = params.pop();
        const payload = { apiSpaceName, functionName, params };

        if (typeof callback !== 'function') {
            console.error(`[workers] function ${currentFunctionName} must receive a callback!`);
            return;
        }

        runTask.call(this, currentFunctionName, payload, callback);
    }

    runSyncFunctionOnlyByWorker(apiSpaceName, functionName, ...params) {
        const currentFunctionName = "runSyncFunctionOnlyFromWorker";
        const callback = params.pop();
        const payload = { apiSpaceName, functionName, params };

        if (typeof callback !== 'function') {
            console.error(`[workers] function ${currentFunctionName} must receive a callback!`);
            return;
        }

        addTask.call(this, "runSyncFunctionOnlyFromWorker", payload, callback);
    }

    get environment() {
        return this.environmentType;
    }
}

function createPool(options) {
    const pool = new CrossEnvironmentWorkerPool(options);
    return pool.environment ? pool : undefined;
}

function getFunctionsRegistry() {
    return require("./functions");
}

module.exports = {
    createPool,
    getFunctionsRegistry
}
}).call(this)}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},"/modules/opendsu/workers")

},{"../moduleConstants.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/moduleConstants.js","./bootScript/node":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/workers/bootScript/node.js","./bootScript/web":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/workers/bootScript/web.js","./functions":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/workers/functions.js","opendsu":"opendsu","path":false,"syndicate":"syndicate"}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/overwrite-require/src/Logger.js":[function(require,module,exports){
const envTypes = require("./moduleConstants");
const originalConsole = Object.assign({}, console);
const IS_DEV_MODE = process.env.DEV === "true" || typeof process.env.DEV === "undefined";
const errorTypes = require("./errorTypes");
if (typeof process.env.OPENDSU_ENABLE_DEBUG === "undefined") {
    process.env.OPENDSU_ENABLE_DEBUG = IS_DEV_MODE.toString();
}
const DEBUG_LOG_ENABLED = process.env.OPENDSU_ENABLE_DEBUG === "true";
if ($$.environmentType === envTypes.NODEJS_ENVIRONMENT_TYPE) {
    const logger = new Logger("Logger", "overwrite-require");
    if (DEBUG_LOG_ENABLED) {
        logger.log = logger.debug;
    } else {
        logger.log = () => {
        }
    }
    Object.assign(console, logger);
} else {
    $$.memoryLogger = new MemoryFileMock();
    const logger = new Logger("Logger", "overwrite-require", $$.memoryLogger);
    Object.assign(console, logger);
}

function MemoryFileMock() {
    let arr = [];
    this.append = (logLine) => {
        arr.push(logLine);
    }
    this.dump = () => {
        return JSON.stringify(arr);
    }
}


function Logger(className, moduleName, logFile) {
    const MAX_STRING_LENGTH = 11;
    const verbosityLevels = {
        "trace": 0,
        "debug": 1,
        "info": 2,
        "log": 3,
        "warn": 3,
        "error": 4,
        "critical": 5,
        "audit": 6
    }

    let verbosity;


    const getPaddingForArg = (arg, maxLen = MAX_STRING_LENGTH) => {
        let noSpaces = Math.abs(maxLen - arg.length);
        let spaces = String(" ").repeat(noSpaces);
        return spaces;
    };

    const convertIntToHexString = (number) => {
        let hexString = number.toString("16");
        if (hexString.length === 1) {
            hexString = "0" + hexString;
        }
        return "0x" + hexString;
    }

    const normalizeArg = (arg) => {
        if (arg.length >= MAX_STRING_LENGTH) {
            return arg.substring(0, MAX_STRING_LENGTH);
        } else {
            return `${arg}${getPaddingForArg(arg)}`;
        }
    }

    const getLogMessage = (data) => {
        let msg = '';
        try {
            if (typeof data === "object") {
                if (data instanceof Error) {
                    msg = `${data.message}\n${data.stack}`;
                } else if (data.debug_stack || data.debug_message) {
                    msg = data.toString();
                } else {
                    msg = JSON.stringify(data) + " ";
                }
            } else {
                msg = data + " ";
            }
        } catch (e) {
            msg = e.message + " ";
        }
        return msg;
    }

    const createLogObject = (functionName, code = 0, ...args) => {
        let message = "";
        for (let i = 0; i < args.length; i++) {
            message += getLogMessage(args[i]);
        }

        message = message.trimEnd();
        const logObject = {
            severity: functionName.toUpperCase(),
            timestamp: new Date().toISOString(),
            eventTypeId: convertIntToHexString(code),
            component: moduleName,
            className: className,
            message
        }
        return logObject;
    }

    const getLogStringFromObject = (logObject, appendEOL = false) => {
        let logString;
        if (IS_DEV_MODE) {
            logObject.message = logObject.message.replaceAll("\n", "\n\t");
            logString = `${logObject.severity}${getPaddingForArg(logObject.severity, 9)}${logObject.eventTypeId}${getPaddingForArg(logObject.eventTypeId, 3)} ${logObject.timestamp}`;

            if (typeof logObject.component !== "undefined") {
                logString = `${logString} ${normalizeArg(logObject.component)}`;
            }
            if (typeof logObject.className !== "undefined") {
                logString = `${logString} ${normalizeArg(logObject.className)}`;
            }

            logString = `${logString} ${logObject.message}`;

            if (appendEOL) {
                logString += require("os").EOL;
            }
        } else {
            logObject.message = logObject.message.replaceAll("\n", "\\n");
            logObject.message = logObject.message.replaceAll("\r", "\\r");
            logString = JSON.stringify(logObject);
        }
        return logString;
    }

    const getLogAsString = (functionName, appendEOL = false, ...args) => {
        const res = stripCodeFromArgs(...args);
        let logObject = createLogObject(functionName, res.code, ...res.args);
        let logString = getLogStringFromObject(logObject, appendEOL);
        return logString;
    }

    const stripCodeFromArgs = (...args) => {
        let code = args[0];
        if (typeof code !== "number" || args.length === 1) {
            code = 0;
        } else {
            args.shift();
        }

        return {
            code,
            args
        }
    }

    const functions = errorTypes;
    const getConsoleFunction = (functionName) => {
        if (functionName === functions.CRITICAL) {
            functionName = functions.ERROR;
        }

        if (functionName === functions.AUDIT) {
            functionName = functions.LOG;
        }

        return functionName;
    }

    const executeFunctionFromConsole = (functionName, ...args) => {
        if (typeof $$.debug !== "undefined" && typeof $$.debug.getVerbosityLevel === "function") {
            verbosity = verbosityLevels[$$.debug.getVerbosityLevel()];
        } else {
            verbosity = verbosityLevels["trace"];
        }

        if (verbosity > verbosityLevels[functionName]) {
            return;
        }
        if ($$.memoryLogger) {
            originalConsole[getConsoleFunction(functionName)](...args);
        } else {
            const log = getLogAsString(functionName, false, ...args);
            originalConsole[getConsoleFunction(functionName)](log);
        }
    }

    const writeToFile = (functionName, ...args) => {
        const fs = require("fs");
        const path = require("path");
        if (typeof logFile === "undefined") {
            return;
        }

        let log = getLogAsString(functionName, true, ...args);
        if (logFile instanceof MemoryFileMock) {
            logFile.append(log);
            return;
        }
        try {
            fs.accessSync(path.dirname(logFile));
        } catch (e) {
            fs.mkdirSync(path.dirname(logFile), {recursive: true});
        }

        fs.appendFileSync(logFile, log);
    }

    const printToConsoleAndFile = (functionName, ...args) => {
        executeFunctionFromConsole(functionName, ...args);
        writeToFile(functionName, ...args);
    }

    for (let fnName in functions) {
        this[functions[fnName]] = (...args) => {
            printToConsoleAndFile(functions[fnName], ...args);
        }
    }
    //adding alias for warn fnc
    this.warning = this.warn;

    if (!DEBUG_LOG_ENABLED) {
        this[functions.TRACE] = this[functions.DEBUG] = () => {
        };
    }

    const originalWarn = this.warn;
    const originalError = this.error;
    const originalTrace = this.trace;

    if ($$.debug && typeof $$.debug.errorWithCodeShouldBeRedirectedToStdout === "function") {
        const __generateFunction = (functionName) => {
            return (...args) => {
                const res = stripCodeFromArgs(...args);
                if ($$.debug.errorWithCodeShouldBeRedirectedToStdout(res.code)) {
                    executeFunctionFromConsole(functions.DEBUG, ...args);
                    $$.debug.useStderrForErrorWithCode(res.code);
                    this.warn = originalWarn;
                    this.error = originalError;
                    this.trace = originalTrace;
                    console.error = this.error;
                    console.warn = this.warn;
                    console.trace = this.trace;
                } else {
                    printToConsoleAndFile(functionName, ...args);
                }
            }
        }
        this.error = __generateFunction(functions.ERROR);
        this.warn = __generateFunction(functions.WARN);
        this.trace = __generateFunction(functions.TRACE);

        console.error = this.error;
        console.warn = this.warn;
        console.trace = this.trace;
    }
}

const getLogger = (className, moduleName, criticalLogFile) => {
    return new Logger(className, moduleName, criticalLogFile);
}

module.exports = {
    getLogger
}

},{"./errorTypes":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/overwrite-require/src/errorTypes.js","./moduleConstants":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/overwrite-require/src/moduleConstants.js","fs":false,"os":false,"path":false}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/overwrite-require/src/errorTypes.js":[function(require,module,exports){
module.exports = {
    LOG: "log",
    ERROR: "error",
    WARN: "warn",
    INFO: "info",
    DEBUG: "debug",
    TRACE: "trace",
    CRITICAL: "critical",
    AUDIT: "audit"
}
},{}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/overwrite-require/src/moduleConstants.js":[function(require,module,exports){
module.exports = {
  BROWSER_ENVIRONMENT_TYPE: 'browser',
  MOBILE_BROWSER_ENVIRONMENT_TYPE: 'mobile-browser',
  WEB_WORKER_ENVIRONMENT_TYPE: 'web-worker',
  SERVICE_WORKER_ENVIRONMENT_TYPE: 'service-worker',
  ISOLATE_ENVIRONMENT_TYPE: 'isolate',
  THREAD_ENVIRONMENT_TYPE: 'thread',
  NODEJS_ENVIRONMENT_TYPE: 'nodejs'
};

},{}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/overwrite-require/src/standardGlobalSymbols.js":[function(require,module,exports){
(function (global){(function (){
let logger = console;

if(typeof $$.Buffer === "undefined"){
    $$.Buffer = require("buffer").Buffer;
}

if (typeof global.$$.uidGenerator == "undefined") {
    $$.uidGenerator = {};
    $$.uidGenerator.safe_uuid = require("swarmutils").safe_uuid;
}

if (!global.process || process.env.NO_LOGS !== 'true') {
    try {
        const zmqName = "zeromq";
        require(zmqName);
        const PSKLoggerModule = require('psklogger');
        const PSKLogger = PSKLoggerModule.PSKLogger;

        logger = PSKLogger.getLogger();

        console.log('Logger init successful', process.pid);
    } catch (e) {
        if(e.message.indexOf("psklogger")!==-1 || e.message.indexOf("zeromq")!==-1){
            console.log('Logger not available, using console');
            logger = console;
        }else{
            console.log(e);
        }
    }
} else {
    console.log('Environment flag NO_LOGS is set, logging to console');
}

$$.registerGlobalSymbol = function (newSymbol, value) {
    if (typeof $$[newSymbol] == "undefined") {
        Object.defineProperty($$, newSymbol, {
            value: value,
            writable: false
        });
    } else {
        logger.error("Refusing to overwrite $$." + newSymbol);
    }
};

console.warn = (...args)=>{
    console.log(...args);
};

/**
 * @method
 * @name $$#autoThrow
 * @param {Error} err
 * @throws {Error}
 */

$$.registerGlobalSymbol("autoThrow", function (err) {
    if (!err) {
        throw err;
    }
});

/**
 * @method
 * @name $$#propagateError
 * @param {Error} err
 * @param {function} callback
 */
$$.registerGlobalSymbol("propagateError", function (err, callback) {
    if (err) {
        callback(err);
        throw err; //stop execution
    }
});

/**
 * @method
 * @name $$#logError
 * @param {Error} err
 */
$$.registerGlobalSymbol("logError", function (err) {
    if (err) {
        console.log(err);
        $$.err(err);
    }
});

/**
 * @method
 * @name $$#fixMe
 * @param {...*} args
 */

$$.registerGlobalSymbol("fixMe", function (...args) {
    console.log("Fix this:", ...args);
});

/**
 * @method - Throws an error
 * @name $$#exception
 * @param {string} message
 * @param {*} type
 */
$$.registerGlobalSymbol("exception", function (message, type) {
    throw new Error(message);
});

/**
 * @method - Throws an error
 * @name $$#throw
 * @param {string} message
 * @param {*} type
 */
$$.registerGlobalSymbol("throw", function (message, type) {
    throw new Error(message);
});


/**
 * @method - Warns that method is not implemented
 * @name $$#incomplete
 * @param {...*} args
 */
/* signal a  planned feature but not implemented yet (during development) but
also it could remain in production and should be flagged asap*/
$$.incomplete = function (...args) {
    args.unshift("Incomplete feature touched:");
    logger.warn(...args);
};

/**
 * @method - Warns that method is not implemented
 * @name $$#notImplemented
 * @param {...*} args
 */
$$.notImplemented = $$.incomplete;


/**
 * @method Throws if value is false
 * @name $$#assert
 * @param {boolean} value - Value to assert against
 * @param {string} explainWhy - Reason why assert failed (why value is false)
 */
/* used during development and when trying to discover elusive errors*/
$$.registerGlobalSymbol("assert", function (value, explainWhy) {
    if (!value) {
        throw new Error("Assert false " + explainWhy);
    }
});

/**
 * @method
 * @name $$#flags
 * @param {string} flagName
 * @param {*} value
 */
/* enable/disabale flags that control psk behaviour*/
$$.registerGlobalSymbol("flags", function (flagName, value) {
    $$.incomplete("flags handling not implemented");
});

/**
 * @method - Warns that a method is obsolete
 * @name $$#obsolete
 * @param {...*} args
 */
$$.registerGlobalSymbol("obsolete", function (...args) {
    args.unshift("Obsolete feature:");
    logger.log(...args);
    console.log(...args);
});

/**
 * @method - Uses the logger to log a message of level "log"
 * @name $$#log
 * @param {...*} args
 */
$$.registerGlobalSymbol("log", function (...args) {
    args.unshift("Log:");
    logger.log(...args);
});

/**
 * @method - Uses the logger to log a message of level "info"
 * @name $$#info
 * @param {...*} args
 */
$$.registerGlobalSymbol("info", function (...args) {
    args.unshift("Info:");
    logger.log(...args);
    console.log(...args);
});

/**
 * @method - Uses the logger to log a message of level "error"
 * @name $$#err
 * @param {...*} args
 */
$$.registerGlobalSymbol("err", function (...args) {
    args.unshift("Error:");
    logger.error(...args);
    console.error(...args);
});

/**
 * @method - Uses the logger to log a message of level "error"
 * @name $$#err
 * @param {...*} args
 */
$$.registerGlobalSymbol("error", function (...args) {
    args.unshift("Error:");
    logger.error(...args);
    console.error(...args);
});

/**
 * @method - Uses the logger to log a message of level "warning"
 * @name $$#warn
 * @param {...*} args
 */
$$.registerGlobalSymbol("warn", function (...args) {
    args.unshift("Warn:");
    logger.warn(...args);
    console.log(...args);
});

/**
 * @method - Uses the logger to log a message of level "syntexError"
 * @name $$#syntexError
 * @param {...*} args
 */
$$.registerGlobalSymbol("syntaxError", function (...args) {
    args.unshift("Syntax error:");
    logger.error(...args);
    try{
        throw new Error("Syntax error or misspelled symbol!");
    }catch(err){
        console.error(...args);
        console.error(err.stack);
    }

});

/**
 * @method - Logs an invalid member name for a swarm
 * @name $$#invalidMemberName
 * @param {string} name
 * @param {Object} swarm
 */
$$.invalidMemberName = function (name, swarm) {
    let swarmName = "unknown";
    if (swarm && swarm.meta) {
        swarmName = swarm.meta.swarmTypeName;
    }
    const text = "Invalid member name " + name + "in swarm " + swarmName;
    console.error(text);
    logger.err(text);
};

/**
 * @method - Logs an invalid swarm name
 * @name $$#invalidSwarmName
 * @param {string} name
 * @param {Object} swarm
 */
$$.registerGlobalSymbol("invalidSwarmName", function (swarmName) {
    const text = "Invalid swarm name " + swarmName;
    console.error(text);
    logger.err(text);
});

/**
 * @method - Logs unknown exceptions
 * @name $$#unknownException
 * @param {...*} args
 */
$$.registerGlobalSymbol("unknownException", function (...args) {
    args.unshift("unknownException:");
    logger.err(...args);
    console.error(...args);
});

/**
 * @method - PrivateSky event, used by monitoring and statistics
 * @name $$#event
 * @param {string} event
 * @param {...*} args
 */
$$.registerGlobalSymbol("event", function (event, ...args) {
    if (logger.hasOwnProperty('event')) {
        logger.event(event, ...args);
    } else {
        if(event === "status.domains.boot"){
            console.log("Failing to console...", event, ...args);
        }
    }
});

/**
 * @method -
 * @name $$#redirectLog
 * @param {string} event
 * @param {...*} args
 */
$$.registerGlobalSymbol("redirectLog", function (logType, logObject) {
    if(logger.hasOwnProperty('redirect')) {
        logger.redirect(logType, logObject);
    }
});

/**
 * @method - log throttling event // it is just an event?
 * @name $$#throttlingEvent
 * @param {...*} args
 */
$$.registerGlobalSymbol("throttlingEvent", function (...args) {
    logger.log(...args);
});

}).call(this)}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"buffer":false,"psklogger":false,"swarmutils":"swarmutils"}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/psk-cache/lib/Cache.js":[function(require,module,exports){
const DEFAULT_ITEMS_LIMIT = 1000;
const DEFAULT_STORAGE_LEVELS = 3;

/**
 * @param {object} options
 * @param {Number} options.maxLevels Number of storage levels. Defaults to 3
 * @param {Number} options.limit Number of max items the cache can store per level.
 *                               Defaults to 1000
 */
function Cache(options) {
    options = options || {};
    this.limit = parseInt(options.limit, 10) || DEFAULT_ITEMS_LIMIT;
    this.maxLevels = parseInt(options.maxLevels, 10) || DEFAULT_STORAGE_LEVELS;
    this.storage = null;

    if (this.limit < 0) {
        throw new Error('Limit must be a positive number');
    }
    if (this.maxLevels < 1) {
        throw new Error('Cache needs at least one storage level');
    }


    /**
     * Create an array of Map objects for storing items
     *
     * @param {Number} maxLevels
     * @return {Array.<Map>}
     */
    this.createStorage = function (maxLevels) {
        const storage = [];
        for (let i = 0; i < maxLevels; i++) {
            storage.push(new Map());
        }

        return storage;
    }

    this.storage = this.createStorage(this.maxLevels);

    this.resetCache = ()=>{
        this.storage = this.createStorage(this.maxLevels);
    }

    /**
     * @param {*} key
     * @param {*} value
     */
    this.set = function (key, value) {
        if (this.cacheIsFull()) {
            this.makeRoom();
        }

        this.storage[0].set(key, value);
    }

    /**
     * @param {*} key
     * @return {Boolean}
     */
    this.has = function (key) {
        for (let i = 0; i < this.storage.length; i++) {
            if (this.storage[i].has(key)) {
                return true;
            }
        }

        return false;
    }

    /**
     * @param {*} key
     * @return {*}
     */
    this.get = function (key) {
        if (this.storage[0].has(key)) {
            return this.storage[0].get(key);
        }

        return this.getFromLowerLevels(key);
    }

    /**
     * Get an item from the lower levels.
     * If one is found added it to the first level as well
     *
     * @param {*} key
     * @return {*}
     */
    this.getFromLowerLevels = function (key) {
        for (let i = 1; i < this.storage.length; i++) {
            const storageLevel = this.storage[i];
            if (!storageLevel.has(key)) {
                continue;
            }
            const value = storageLevel.get(key);
            this.set(key, value);
            return value;
        }
    }

    /**
     * @return {Boolean}
     */
    this.cacheIsFull = function () {
        return this.storage[0].size >= this.limit;
    }

    /**
     * Move all the items down by one level
     * and clear the first one to make room for new items
     */
    this.makeRoom = function () {
        for (let i = this.storage.length - 1; i > 0; i--) {
            this.storage[i] = this.storage[i - 1];
        }
        this.storage[0] = new Map();
    }
}

module.exports = Cache;

},{}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/psk-http-client/lib/psk-abstract-client.js":[function(require,module,exports){
/**********************  utility class **********************************/
function RequestManager(pollingTimeOut) {
    if (!pollingTimeOut) {
        pollingTimeOut = 1000; //1 second by default
    }

    const self = this;

    function Request(endPoint, initialSwarm, delayedStart) {
        let onReturnCallbacks = [];
        let onErrorCallbacks = [];
        let onCallbacks = [];
        const requestId = initialSwarm ? initialSwarm.meta.requestId : "weneedarequestid";
        initialSwarm = null;

        this.getRequestId = function () {
            return requestId;
        };

        this.on = function (phaseName, callback) {
            if (typeof phaseName != "string" && typeof callback != "function") {
                throw new Error("The first parameter should be a string and the second parameter should be a function");
            }

            onCallbacks.push({
                callback: callback,
                phase: phaseName
            });

            if (typeof delayedStart === "undefined") {
                self.poll(endPoint, this);
            }

            return this;
        };

        this.onReturn = function (callback) {
            onReturnCallbacks.push(callback);
            if (typeof delayedStart === "undefined") {
                self.poll(endPoint, this);
            }
            return this;
        };

        this.onError = function (callback) {
            if (onErrorCallbacks.indexOf(callback) !== -1) {
                onErrorCallbacks.push(callback);
            } else {
                console.log("Error callback already registered!");
            }
        };

        this.start = function () {
            if (typeof delayedStart !== "undefined") {
                self.poll(endPoint, this);
            }
        };

        this.dispatch = function (err, result) {
            if (result instanceof ArrayBuffer) {
                result = SwarmPacker.unpack(result);
            }

            result = typeof result === "string" ? JSON.parse(result) : result;

            result = OwM.prototype.convert(result);
            const resultReqId = result.getMeta("requestId");
            const phaseName = result.getMeta("phaseName");
            let onReturn = false;

            if (resultReqId === requestId) {
                onReturnCallbacks.forEach(function (c) {
                    c(null, result);
                    onReturn = true;
                });
                if (onReturn) {
                    onReturnCallbacks = [];
                    onErrorCallbacks = [];
                }

                onCallbacks.forEach(function (i) {
                    //console.log("XXXXXXXX:", phaseName , i);
                    if (phaseName === i.phase || i.phase === '*') {
                        i.callback(err, result);
                    }
                });
            }

            if (onReturnCallbacks.length === 0 && onCallbacks.length === 0) {
                self.unpoll(endPoint, this);
            }
        };

        this.dispatchError = function (err) {
            for (let i = 0; i < onErrorCallbacks.length; i++) {
                const errCb = onErrorCallbacks[i];
                errCb(err);
            }
        };

        this.off = function () {
            self.unpoll(endPoint, this);
        };
    }

    this.createRequest = function (remoteEndPoint, swarm, delayedStart) {
        return new Request(remoteEndPoint, swarm, delayedStart);
    };

    /* *************************** polling zone ****************************/

    const pollSet = {};

    const activeConnections = {};

    this.poll = function (remoteEndPoint, request) {
        let requests = pollSet[remoteEndPoint];
        if (!requests) {
            requests = {};
            pollSet[remoteEndPoint] = requests;
        }
        requests[request.getRequestId()] = request;
        pollingHandler();
    };

    this.unpoll = function (remoteEndPoint, request) {
        const requests = pollSet[remoteEndPoint];
        if (requests) {
            delete requests[request.getRequestId()];
            if (Object.keys(requests).length === 0) {
                delete pollSet[remoteEndPoint];
            }
        } else {
            console.log("Unpolling wrong request:", remoteEndPoint, request);
        }
    };

    function createPollThread(remoteEndPoint) {
        function reArm() {
            $$.remote.doHttpGet(remoteEndPoint, function (err, res) {
                let requests = pollSet[remoteEndPoint];
                if (err) {
                    for (const req_id in requests) {
                        if (!requests.hasOwnProperty(req_id)) {
                            return;
                        }

                        let err_handler = requests[req_id].dispatchError;
                        if (err_handler) {
                            err_handler(err);
                        }
                    }
                    activeConnections[remoteEndPoint] = false;
                } else {

                    for (const k in requests) {
                        if (!requests.hasOwnProperty(k)) {
                            return;
                        }

                        requests[k].dispatch(null, res);
                    }

                    if (Object.keys(requests).length !== 0) {
                        reArm();
                    } else {
                        delete activeConnections[remoteEndPoint];
                        console.log("Ending polling for ", remoteEndPoint);
                    }
                }
            });
        }

        reArm();
    }

    function pollingHandler() {
        let setTimer = false;
        for (const remoteEndPoint in pollSet) {
            if (!pollSet.hasOwnProperty(remoteEndPoint)) {
                return;
            }

            if (!activeConnections[remoteEndPoint]) {
                createPollThread(remoteEndPoint);
                activeConnections[remoteEndPoint] = true;
            }
            setTimer = true;
        }
        if (setTimer) {
            setTimeout(pollingHandler, pollingTimeOut);
        }
    }

    setTimeout(pollingHandler, pollingTimeOut);
}

function urlEndWithSlash(url) {
    if (url[url.length - 1] !== "/") {
        url += "/";
    }
    return url;
}

/********************** main APIs on working with virtualMQ channels **********************************/
function HttpChannelClient(remoteEndPoint, channelName, options) {

    let clientType;
    const opts = {
        autoCreate: true,
        publicSignature: "no_signature_provided"
    };

    Object.keys(options).forEach((optName) => {
        opts[optName] = options[optName];
    });

    let channelCreated = false;
    function readyToBeUsed(){
        let res = false;

        if(clientType === HttpChannelClient.prototype.PRODUCER_CLIENT_TYPE){
            res = true;
        }
        if(clientType === HttpChannelClient.prototype.CONSUMER_CLIENT_TYPE){
            if(!options.autoCreate){
                res = true;
            }else{
                res = channelCreated;
            }
        }

        return res;
    }

    function encryptChannelName(channelName) {
        return $$.remote.base64Encode(channelName);
    }

    function CatchAll(swarmName, phaseName, callback) { //same interface as Request
        const requestId = requestsCounter++;
        this.getRequestId = function () {
            return "swarmName" + "phaseName" + requestId;
        };

        this.dispatch = function (err, result) {
            /*result = OwM.prototype.convert(result);
            const currentPhaseName = result.getMeta("phaseName");
            const currentSwarmName = result.getMeta("swarmTypeName");
            if ((currentSwarmName === swarmName || swarmName === '*') && (currentPhaseName === phaseName || phaseName === '*')) {
                return callback(err, result);
            }*/
            return callback(err, result);
        };
    }

    this.setSenderMode = function () {
        if (typeof clientType !== "undefined") {
            throw new Error(`HttpChannelClient is set as ${clientType}`);
        }
        clientType = HttpChannelClient.prototype.PRODUCER_CLIENT_TYPE;

        this.sendSwarm = function (swarmSerialization) {
            $$.remote.doHttpPost(getRemoteToSendMessage(remoteEndPoint, channelName), swarmSerialization, (err, res)=>{
                if(err){
                    console.log("Sending swarm failed", err);
                }else{
                    console.log("Swarm sent");
                }
            });
        };
    };

    this.setReceiverMode = function () {
        if (typeof clientType !== "undefined") {
            throw new Error(`HttpChannelClient is set as ${clientType}`);
        }
        clientType = HttpChannelClient.prototype.CONSUMER_CLIENT_TYPE;

        function createChannel(callback){
            if (!readyToBeUsed()) {
                $$.remote.doHttpPut(getRemoteToCreateChannel(), opts.publicSignature, (err) => {
                    if (err) {
                        if (err.statusCode !== 409) {
                            return callback(err);
                        }
                    }
                    channelCreated = true;
                    if(opts.enableForward){
                        console.log("Enabling forward");
                        $$.remote.doHttpPost(getUrlToEnableForward(), opts.publicSignature, (err, res)=>{
                            if(err){
                                console.log("Request to enable forward to zeromq failed", err);
                            }
                        });
                    }
                    return callback();
                });
            }
        }

        this.getReceiveAddress = function(){
            return getRemoteToSendMessage();
        };

        this.on = function (swarmId, swarmName, phaseName, callback) {
            const c = new CatchAll(swarmName, phaseName, callback);
            allCatchAlls.push({
                s: swarmName,
                p: phaseName,
                c: c
            });

           /* if (!readyToBeUsed()) {
                createChannel((err)=>{
                    $$.remote.requestManager.poll(getRemoteToReceiveMessage(), c);
                });
            } else {*/
                $$.remote.requestManager.poll(getRemoteToReceiveMessage(), c);
            /*}*/
        };

        this.off = function (swarmName, phaseName) {
            allCatchAlls.forEach(function (ca) {
                if ((ca.s === swarmName || swarmName === '*') && (phaseName === ca.p || phaseName === '*')) {
                    $$.remote.requestManager.unpoll(getRemoteToReceiveMessage(remoteEndPoint, domainInfo.domain), ca.c);
                }
            });
        };

        createChannel((err) => {
            if(err){
                console.log(err);
            }
        });

        $$.remote.createRequestManager();
    };

    const allCatchAlls = [];
    let requestsCounter = 0;

    this.uploadCSB = function (cryptoUid, binaryData, callback) {
        $$.remote.doHttpPost(baseOfRemoteEndPoint + "/CSB/" + cryptoUid, binaryData, callback);
    };

    this.downloadCSB = function (cryptoUid, callback) {
        $$.remote.doHttpGet(baseOfRemoteEndPoint + "/CSB/" + cryptoUid, callback);
    };

    function getRemoteToReceiveMessage() {
        return [urlEndWithSlash(remoteEndPoint), urlEndWithSlash(HttpChannelClient.prototype.RECEIVE_API_NAME), urlEndWithSlash(encryptChannelName(channelName))].join("");
    }

    function getRemoteToSendMessage() {
        return [urlEndWithSlash(remoteEndPoint), urlEndWithSlash(HttpChannelClient.prototype.SEND_API_NAME), urlEndWithSlash(encryptChannelName(channelName))].join("");
    }

    function getRemoteToCreateChannel() {
        return [urlEndWithSlash(remoteEndPoint), urlEndWithSlash(HttpChannelClient.prototype.CREATE_CHANNEL_API_NAME), urlEndWithSlash(encryptChannelName(channelName))].join("");
    }

    function getUrlToEnableForward() {
        return [urlEndWithSlash(remoteEndPoint), urlEndWithSlash(HttpChannelClient.prototype.FORWARD_CHANNEL_API_NAME), urlEndWithSlash(encryptChannelName(channelName))].join("");
    }
}

/********************** constants **********************************/
HttpChannelClient.prototype.RECEIVE_API_NAME = "receive-message";
HttpChannelClient.prototype.SEND_API_NAME = "send-message";
HttpChannelClient.prototype.CREATE_CHANNEL_API_NAME = "create-channel";
HttpChannelClient.prototype.FORWARD_CHANNEL_API_NAME = "forward-zeromq";
HttpChannelClient.prototype.PRODUCER_CLIENT_TYPE = "producer";
HttpChannelClient.prototype.CONSUMER_CLIENT_TYPE = "consumer";

/********************** initialisation stuff **********************************/
if (typeof $$ === "undefined") {
    $$ = {};
}

if (typeof $$.remote === "undefined") {
    $$.remote = {};

    function createRequestManager(timeOut) {
        const newRequestManager = new RequestManager(timeOut);
        Object.defineProperty($$.remote, "requestManager", {value: newRequestManager});
    }

    function registerHttpChannelClient(alias, remoteEndPoint, channelName, options) {
        $$.remote[alias] = new HttpChannelClient(remoteEndPoint, channelName, options);
    }

    Object.defineProperty($$.remote, "createRequestManager", {value: createRequestManager});
    Object.defineProperty($$.remote, "registerHttpChannelClient", {value: registerHttpChannelClient});

    $$.remote.doHttpPost = function (url, data, callback) {
        throw new Error("Overwrite this!");
    };

    $$.remote.doHttpPut = function (url, data, callback) {
        throw new Error("Overwrite this!");
    };

    $$.remote.doHttpGet = function doHttpGet(url, callback) {
        throw new Error("Overwrite this!");
    };

    $$.remote.base64Encode = function base64Encode(stringToEncode) {
        throw new Error("Overwrite this!");
    };

    $$.remote.base64Decode = function base64Decode(encodedString) {
        throw new Error("Overwrite this!");
    };
}


//new implementation in order to expose as much as possible APIHUB services
$$.apihub = {connections:{}};
$$.apihub.createConnection = function(alias, url, ssi){

    $$.apihub.connections[alias] = {
        //mq apis
        createMQ: function(queueName, callback){

        },
        sendMessageToQueue: function(queueName, message, callback){

        },
        receiveMessageFromQueue: function(queueName, callback){
            // integrate request manager from above in order to have long pooling mechanism enabled
        },

        //notifications apis
        subscribe: function(topic, callback){
            // integrate request manager from above in order to have long pooling mechanism enabled
        },

        unsubscribe: function(topic, callback){

        },

        publish: function(topic, message, callback){

        },

        //authentication apis
        getAuthToken: function(expiration, callback){

        },

        setQuota: function(quota, targetSSI, callback){

        },

        setTagPolicy: function(tag, requireAuthToken, callback){

        },

        addUserInTag: function(targetSSI, callback){

        },

        addAdmin: function(targetSSI, callback){

        },

        removeAdmin: function(callback){

        }

    }

    return $$.apihub.connections[alias];
}

},{}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/psk-http-client/lib/psk-browser-client.js":[function(require,module,exports){
function generateMethodForRequestWithData(httpMethod) {
    return function (url, data, callback) {
        const xhr = new XMLHttpRequest();

        xhr.onload = function () {
            if (xhr.readyState === 4 && (xhr.status >= 200 && xhr.status < 300)) {
                const data = xhr.response;
                callback(undefined, data);
            } else {
                if(xhr.status>=400){
                    const error = new Error("An error occured. StatusCode: " + xhr.status);
                    callback({error: error, statusCode: xhr.status});
                } else {
                    console.log(`Status code ${xhr.status} received, response is ignored.`);
                }
            }
        };

        xhr.onerror = function (e) {
            callback(new Error("A network error occurred"));
        };

        xhr.open(httpMethod, url, true);
        //xhr.setRequestHeader("Content-Type", "application/json;charset=UTF-8");

        if(data && data.pipe && typeof data.pipe === "function"){
            const buffers = [];
            data.on("data", function(data) {
                buffers.push(data);
            });
            data.on("end", function() {
                const actualContents = $$.Buffer.concat(buffers);
                xhr.send(actualContents);
            });
        }
        else {
            if(data instanceof ArrayBuffer){
                data = new DataView(data);
            }

            if(ArrayBuffer.isView(data)) {
                xhr.setRequestHeader('Content-Type', 'application/octet-stream');

                /**
                 * Content-Length is an unsafe header and we cannot set it.
                 * When browser is making a request that is intercepted by a service worker,
                 * the Content-Length header is not set implicitly.
                 */
                xhr.setRequestHeader('X-Content-Length', data.byteLength);
            }
            xhr.send(data);
        }
    };
}


$$.remote.doHttpPost = generateMethodForRequestWithData('POST');

$$.remote.doHttpPut = generateMethodForRequestWithData('PUT');


$$.remote.doHttpGet = function doHttpGet(url, callback) {

    var xhr = new XMLHttpRequest();

    xhr.onreadystatechange = function () {
        //check if headers were received and if any action should be performed before receiving data
        if (xhr.readyState === 2) {
            var contentType = xhr.getResponseHeader("Content-Type");
            if (contentType === "application/octet-stream") {
                xhr.responseType = 'arraybuffer';
            }
        }
    };

    xhr.onload = function () {
        if (xhr.readyState === 4 && xhr.status == "200") {
            var contentType = xhr.getResponseHeader("Content-Type");
            if (contentType === "application/octet-stream") {
                let responseBuffer = this.response;

                let buffer = new $$.Buffer(responseBuffer.byteLength);
                let view = new Uint8Array(responseBuffer);
                for (let i = 0; i < buffer.length; ++i) {
                    buffer[i] = view[i];
                }
                callback(undefined, buffer);
            }
            else{
                callback(undefined, xhr.response);
            }
        } else {
            const error = new Error("An error occurred. StatusCode: " + xhr.status);

            callback({error: error, statusCode: xhr.status});
        }
    };
    xhr.onerror = function (e) {
        callback(new Error("A network error occurred"));
    };

    xhr.open("GET", url);
    xhr.send();
};


function CryptoProvider(){

    this.generateSafeUid = function(){
        let uid = "";
        var array = new Uint32Array(10);
        window.crypto.getRandomValues(array);


        for (var i = 0; i < array.length; i++) {
            uid += array[i].toString(16);
        }

        return uid;
    };

    this.signSwarm = function(swarm, agent){
        swarm.meta.signature = agent;
    };
}



$$.remote.cryptoProvider = new CryptoProvider();

$$.remote.base64Encode = function base64Encode(stringToEncode){
    return window.btoa(stringToEncode);
};

$$.remote.base64Decode = function base64Decode(encodedString){
    return window.atob(encodedString);
};

},{}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/psk-http-client/lib/psk-node-client.js":[function(require,module,exports){
require("./psk-abstract-client");

const http = require("http");
const https = require("https");
const URL = require("url");
const userAgent = 'PSK NodeAgent/0.0.1';
const signatureHeaderName = process.env.vmq_signature_header_name || "x-signature";


console.log("PSK node client loading");

function getNetworkForOptions(options) {
	if(options.protocol === 'http:') {
		return http;
	} else if(options.protocol === 'https:') {
		return https;
	} else {
		throw new Error(`Can't handle protocol ${options.protocol}`);
	}

}

function generateMethodForRequestWithData(httpMethod) {
	return function (url, data, callback) {
		const innerUrl = URL.parse(url);

		const options = {
			hostname: innerUrl.hostname,
			path: innerUrl.pathname,
			port: parseInt(innerUrl.port),
			headers: {
				'User-Agent': userAgent,
				[signatureHeaderName]: 'replaceThisPlaceholderSignature'
			},
			method: httpMethod
		};

		const network = getNetworkForOptions(innerUrl);

		if (ArrayBuffer.isView(data) || $$.Buffer.isBuffer(data) || data instanceof ArrayBuffer) {
			if (!$$.Buffer.isBuffer(data)) {
				data = $$.Buffer.from(data);
			}

			options.headers['Content-Type'] = 'application/octet-stream';
			options.headers['Content-Length'] = data.length;
		}

		const req = network.request(options, (res) => {
			const {statusCode} = res;

			let error;
			if (statusCode >= 400) {
				error = new Error('Request Failed.\n' +
					`Status Code: ${statusCode}\n` +
					`URL: ${options.hostname}:${options.port}${options.path}`);
			}

			if (error) {
				callback({error: error, statusCode: statusCode});
				// free up memory
				res.resume();
				return;
			}

			let rawData = '';
			res.on('data', (chunk) => {
				rawData += chunk;
			});
			res.on('end', () => {
				try {
					callback(undefined, rawData, res.headers);
				} catch (err) {
                    console.error(err);
				}finally {
					//trying to prevent getting ECONNRESET error after getting our response
					req.abort();
				}
			});
		}).on("error", (error) => {
			console.log(`[POST] ${url}`, error);
			callback(error);
		});

		if (data && data.pipe && typeof data.pipe === "function") {
			data.pipe(req);
			return;
		}

		if (typeof data !== 'string' && !$$.Buffer.isBuffer(data) && !ArrayBuffer.isView(data)) {
			data = JSON.stringify(data);
		}

		req.write(data);
		req.end();
	};
}

$$.remote.doHttpPost = generateMethodForRequestWithData('POST');

$$.remote.doHttpPut = generateMethodForRequestWithData('PUT');

$$.remote.doHttpGet = function doHttpGet(url, callback){
    const innerUrl = URL.parse(url);

	const options = {
		hostname: innerUrl.hostname,
		path: innerUrl.pathname + (innerUrl.search || ''),
		port: parseInt(innerUrl.port),
		headers: {
			'User-Agent': userAgent,
            [signatureHeaderName]: 'someSignature'
		},
		method: 'GET'
	};

	const network = getNetworkForOptions(innerUrl);
	const req = network.request(options, (res) => {
		const { statusCode } = res;

		let error;
		if (statusCode !== 200) {
			error = new Error('Request Failed.\n' +
				`Status Code: ${statusCode}`);
			error.code = statusCode;
		}

		if (error) {
			callback({error:error, statusCode:statusCode});
			// free up memory
			res.resume();
			return
		}

		let rawData;
		const contentType = res.headers['content-type'];

		if(contentType === "application/octet-stream"){
			rawData = [];
		}else{
			rawData = '';
		}

		res.on('data', (chunk) => {
			if(Array.isArray(rawData)){
				rawData.push(...chunk);
			}else{
				rawData += chunk;
			}
		});
		res.on('end', () => {
			try {
				if(Array.isArray(rawData)){
					rawData = $$.Buffer.from(rawData);
				}
				callback(null, rawData, res.headers);
			} catch (err) {
				console.log("Client error:", err);
			}finally {
				//trying to prevent getting ECONNRESET error after getting our response
				req.abort();
			}
		});
	});

	req.on("error", (error) => {
		if(error && error.code !== 'ECONNRESET'){
        	console.log(`[GET] ${url}`, error);
		}

		callback(error);
	});

	req.end();
};

$$.remote.base64Encode = function base64Encode(stringToEncode){
    return $$.Buffer.from(stringToEncode).toString('base64');
};

$$.remote.base64Decode = function base64Decode(encodedString){
    return $$.Buffer.from(encodedString, 'base64').toString('ascii');
};

},{"./psk-abstract-client":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/psk-http-client/lib/psk-abstract-client.js","http":false,"https":false,"url":false}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/browser/index.js":[function(require,module,exports){
module.exports = {
    compactDecrypt: require('./jwe/compact/decrypt.js').compactDecrypt,
    flattenedDecrypt: require('./jwe/flattened/decrypt.js').flattenedDecrypt,
    generalDecrypt: require('./jwe/general/decrypt.js').generalDecrypt,
    compactVerify: require('./jws/compact/verify.js').compactVerify,
    flattenedVerify: require('./jws/flattened/verify.js').flattenedVerify,
    generalVerify: require('./jws/general/verify.js').generalVerify,
    jwtVerify: require('./jwt/verify.js').jwtVerify,
    jwtDecrypt: require('./jwt/decrypt.js').jwtDecrypt,
    CompactEncrypt: require('./jwe/compact/encrypt.js').CompactEncrypt,
    FlattenedEncrypt: require('./jwe/flattened/encrypt.js').FlattenedEncrypt,
    CompactSign: require('./jws/compact/sign.js').CompactSign,
    FlattenedSign: require('./jws/flattened/sign.js').FlattenedSign,
    GeneralSign: require('./jws/general/sign.js').GeneralSign,
    SignJWT: require('./jwt/sign.js').SignJWT,
    EncryptJWT: require('./jwt/encrypt.js').EncryptJWT,
    calculateJwkThumbprint: require('./jwk/thumbprint.js').calculateJwkThumbprint,
    EmbeddedJWK: require('./jwk/embedded.js').EmbeddedJWK,
    createRemoteJWKSet: require('./jwks/remote.js').createRemoteJWKSet,
    UnsecuredJWT: require('./jwt/unsecured.js').UnsecuredJWT,
    exportPKCS8: require('./key/export.js').exportPKCS8,
    exportSPKI: require('./key/export.js').exportSPKI,
    exportJWK: require('./key/export.js').exportJWK,
    importSPKI: require('./key/import.js').importSPKI,
    importPKCS8: require('./key/import.js').importPKCS8,
    importX509: require('./key/import.js').importX509,
    importJWK: require('./key/import.js').importJWK,
    decodeProtectedHeader: require('./util/decode_protected_header.js').decodeProtectedHeader,
    errors: require('./util/errors.js'),
    generateKeyPair: require('./key/generate_key_pair.js').generateKeyPair,
    generateSecret: require('./key/generate_secret.js').generateSecret,
    base64url: require('./util/base64url.js'),
}
},{"./jwe/compact/decrypt.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/browser/jwe/compact/decrypt.js","./jwe/compact/encrypt.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/browser/jwe/compact/encrypt.js","./jwe/flattened/decrypt.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/browser/jwe/flattened/decrypt.js","./jwe/flattened/encrypt.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/browser/jwe/flattened/encrypt.js","./jwe/general/decrypt.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/browser/jwe/general/decrypt.js","./jwk/embedded.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/browser/jwk/embedded.js","./jwk/thumbprint.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/browser/jwk/thumbprint.js","./jwks/remote.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/browser/jwks/remote.js","./jws/compact/sign.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/browser/jws/compact/sign.js","./jws/compact/verify.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/browser/jws/compact/verify.js","./jws/flattened/sign.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/browser/jws/flattened/sign.js","./jws/flattened/verify.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/browser/jws/flattened/verify.js","./jws/general/sign.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/browser/jws/general/sign.js","./jws/general/verify.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/browser/jws/general/verify.js","./jwt/decrypt.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/browser/jwt/decrypt.js","./jwt/encrypt.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/browser/jwt/encrypt.js","./jwt/sign.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/browser/jwt/sign.js","./jwt/unsecured.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/browser/jwt/unsecured.js","./jwt/verify.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/browser/jwt/verify.js","./key/export.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/browser/key/export.js","./key/generate_key_pair.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/browser/key/generate_key_pair.js","./key/generate_secret.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/browser/key/generate_secret.js","./key/import.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/browser/key/import.js","./util/base64url.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/browser/util/base64url.js","./util/decode_protected_header.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/browser/util/decode_protected_header.js","./util/errors.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/browser/util/errors.js"}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/browser/jwe/compact/decrypt.js":[function(require,module,exports){
const {flattenedDecrypt} = require('../flattened/decrypt.js');
const {JWEInvalid} = require('../../util/errors.js');
module.exports.compactDecrypt = async function compactDecrypt(jwe, key, options) {
    if (jwe instanceof Uint8Array) {
        jwe = jwe.toString();
    }
    if (typeof jwe !== 'string') {
        throw new JWEInvalid('Compact JWE must be a string or Uint8Array');
    }
    const { 0: protectedHeader, 1: encryptedKey, 2: iv, 3: ciphertext, 4: tag, length, } = jwe.split('.');
    if (length !== 5) {
        throw new JWEInvalid('Invalid Compact JWE');
    }
    const decrypted = await flattenedDecrypt({
        ciphertext: (ciphertext || undefined),
        iv: (iv || undefined),
        protected: protectedHeader || undefined,
        tag: (tag || undefined),
        encrypted_key: encryptedKey || undefined,
    }, key, options);
    const result = { plaintext: decrypted.plaintext, protectedHeader: decrypted.protectedHeader };
    if (typeof key === 'function') {
        return { ...result, key: decrypted.key };
    }
    return result;
}

},{"../../util/errors.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/browser/util/errors.js","../flattened/decrypt.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/browser/jwe/flattened/decrypt.js"}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/browser/jwe/compact/encrypt.js":[function(require,module,exports){
const {FlattenedEncrypt} = require('../flattened/encrypt.js');
class CompactEncrypt {
    constructor(plaintext) {
        this._flattened = new FlattenedEncrypt(plaintext);
    }
    setContentEncryptionKey(cek) {
        this._flattened.setContentEncryptionKey(cek);
        return this;
    }
    setInitializationVector(iv) {
        this._flattened.setInitializationVector(iv);
        return this;
    }
    setProtectedHeader(protectedHeader) {
        this._flattened.setProtectedHeader(protectedHeader);
        return this;
    }
    setKeyManagementParameters(parameters) {
        this._flattened.setKeyManagementParameters(parameters);
        return this;
    }
    async encrypt(key, options) {
        const jwe = await this._flattened.encrypt(key, options);
        return [jwe.protected, jwe.encrypted_key, jwe.iv, jwe.ciphertext, jwe.tag].join('.');
    }
}

module.exports.CompactEncrypt = CompactEncrypt;
},{"../flattened/encrypt.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/browser/jwe/flattened/encrypt.js"}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/browser/jwe/flattened/decrypt.js":[function(require,module,exports){
const {decode: base64url} = require('../../runtime/base64url.js');
const decrypt = require('../../runtime/decrypt.js');
const {inflate} = require('../../runtime/zlib.js');
const {JOSEAlgNotAllowed, JOSENotSupported, JWEInvalid} = require('../../util/errors.js');
const isDisjoint = require('../../lib/is_disjoint.js');
const isObject = require('../../lib/is_object.js');
const decryptKeyManagement = require('../../lib/decrypt_key_management.js');
const {concat} = require('../../lib/buffer_utils.js');
const generateCek = require('../../lib/cek.js');
const validateCrit = require('../../lib/validate_crit.js');
const validateAlgorithms = require('../../lib/validate_algorithms.js');
module.exports.flattenedDecrypt = async function flattenedDecrypt(jwe, key, options) {
    var _a;
    if (!isObject(jwe)) {
        throw new JWEInvalid('Flattened JWE must be an object');
    }
    if (jwe.protected === undefined && jwe.header === undefined && jwe.unprotected === undefined) {
        throw new JWEInvalid('JOSE Header missing');
    }
    if (typeof jwe.iv !== 'string') {
        throw new JWEInvalid('JWE Initialization Vector missing or incorrect type');
    }
    if (typeof jwe.ciphertext !== 'string') {
        throw new JWEInvalid('JWE Ciphertext missing or incorrect type');
    }
    if (typeof jwe.tag !== 'string') {
        throw new JWEInvalid('JWE Authentication Tag missing or incorrect type');
    }
    if (jwe.protected !== undefined && typeof jwe.protected !== 'string') {
        throw new JWEInvalid('JWE Protected Header incorrect type');
    }
    if (jwe.encrypted_key !== undefined && typeof jwe.encrypted_key !== 'string') {
        throw new JWEInvalid('JWE Encrypted Key incorrect type');
    }
    if (jwe.aad !== undefined && typeof jwe.aad !== 'string') {
        throw new JWEInvalid('JWE AAD incorrect type');
    }
    if (jwe.header !== undefined && !isObject(jwe.header)) {
        throw new JWEInvalid('JWE Shared Unprotected Header incorrect type');
    }
    if (jwe.unprotected !== undefined && !isObject(jwe.unprotected)) {
        throw new JWEInvalid('JWE Per-Recipient Unprotected Header incorrect type');
    }
    let parsedProt;
    if (jwe.protected) {
        const protectedHeader = base64url(jwe.protected);
        try {
            parsedProt = JSON.parse(protectedHeader.toString());
        }
        catch (_b) {
            throw new JWEInvalid('JWE Protected Header is invalid');
        }
    }
    if (!isDisjoint(parsedProt, jwe.header, jwe.unprotected)) {
        throw new JWEInvalid('JWE Protected, JWE Unprotected Header, and JWE Per-Recipient Unprotected Header Parameter names must be disjoint');
    }
    const joseHeader = {
        ...parsedProt,
        ...jwe.header,
        ...jwe.unprotected,
    };
    validateCrit(JWEInvalid, new Map(), options === null || options === void 0 ? void 0 : options.crit, parsedProt, joseHeader);
    if (joseHeader.zip !== undefined) {
        if (!parsedProt || !parsedProt.zip) {
            throw new JWEInvalid('JWE "zip" (Compression Algorithm) Header MUST be integrity protected');
        }
        if (joseHeader.zip !== 'DEF') {
            throw new JOSENotSupported('Unsupported JWE "zip" (Compression Algorithm) Header Parameter value');
        }
    }
    const { alg, enc } = joseHeader;
    if (typeof alg !== 'string' || !alg) {
        throw new JWEInvalid('missing JWE Algorithm (alg) in JWE Header');
    }
    if (typeof enc !== 'string' || !enc) {
        throw new JWEInvalid('missing JWE Encryption Algorithm (enc) in JWE Header');
    }
    const keyManagementAlgorithms = options && validateAlgorithms('keyManagementAlgorithms', options.keyManagementAlgorithms);
    const contentEncryptionAlgorithms = options &&
        validateAlgorithms('contentEncryptionAlgorithms', options.contentEncryptionAlgorithms);
    if (keyManagementAlgorithms && !keyManagementAlgorithms.has(alg)) {
        throw new JOSEAlgNotAllowed('"alg" (Algorithm) Header Parameter not allowed');
    }
    if (contentEncryptionAlgorithms && !contentEncryptionAlgorithms.has(enc)) {
        throw new JOSEAlgNotAllowed('"enc" (Encryption Algorithm) Header Parameter not allowed');
    }
    let encryptedKey;
    if (jwe.encrypted_key !== undefined) {
        encryptedKey = base64url(jwe.encrypted_key);
    }
    let resolvedKey = false;
    if (typeof key === 'function') {
        key = await key(parsedProt, jwe);
        resolvedKey = true;
    }
    let cek;
    try {
        cek = await decryptKeyManagement(alg, key, encryptedKey, joseHeader);
    }
    catch (err) {
        if (err instanceof TypeError) {
            throw err;
        }
        cek = generateCek(enc);
    }
    const iv = base64url(jwe.iv);
    const tag = base64url(jwe.tag);
    const protectedHeader = $$.Buffer.from((_a = jwe.protected) !== null && _a !== void 0 ? _a : '');
    let additionalData;
    if (jwe.aad !== undefined) {
        additionalData = concat(protectedHeader, $$.Buffer.from('.'), $$.Buffer.from(jwe.aad));
    }
    else {
        additionalData = protectedHeader;
    }
    let plaintext = await decrypt(enc, cek, base64url(jwe.ciphertext), iv, tag, additionalData);
    if (joseHeader.zip === 'DEF') {
        plaintext = await ((options === null || options === void 0 ? void 0 : options.inflateRaw) || inflate)(plaintext);
    }
    const result = { plaintext };
    if (jwe.protected !== undefined) {
        result.protectedHeader = parsedProt;
    }
    if (jwe.aad !== undefined) {
        result.additionalAuthenticatedData = base64url(jwe.aad);
    }
    if (jwe.unprotected !== undefined) {
        result.sharedUnprotectedHeader = jwe.unprotected;
    }
    if (jwe.header !== undefined) {
        result.unprotectedHeader = jwe.header;
    }
    if (resolvedKey) {
        return { ...result, key };
    }
    return result;
}

},{"../../lib/buffer_utils.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/browser/lib/buffer_utils.js","../../lib/cek.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/browser/lib/cek.js","../../lib/decrypt_key_management.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/browser/lib/decrypt_key_management.js","../../lib/is_disjoint.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/browser/lib/is_disjoint.js","../../lib/is_object.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/browser/lib/is_object.js","../../lib/validate_algorithms.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/browser/lib/validate_algorithms.js","../../lib/validate_crit.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/browser/lib/validate_crit.js","../../runtime/base64url.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/browser/runtime/base64url.js","../../runtime/decrypt.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/browser/runtime/decrypt.js","../../runtime/zlib.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/browser/runtime/zlib.js","../../util/errors.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/browser/util/errors.js"}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/browser/jwe/flattened/encrypt.js":[function(require,module,exports){
const {encode: base64url} = require('../../runtime/base64url.js');
const encrypt = require('../../runtime/encrypt.js');
const {deflate} = require('../../runtime/zlib.js');
const generateIv = require('../../lib/iv.js');
const encryptKeyManagement = require('../../lib/encrypt_key_management.js');
const {JOSENotSupported, JWEInvalid} = require('../../util/errors.js');
const isDisjoint = require('../../lib/is_disjoint.js');
const {concat} = require('../../lib/buffer_utils.js');
const validateCrit = require('../../lib/validate_crit.js');
class FlattenedEncrypt {
    constructor(plaintext) {
        if (!(plaintext instanceof Uint8Array)) {
            throw new TypeError('plaintext must be an instance of Uint8Array');
        }
        this._plaintext = plaintext;
    }
    setKeyManagementParameters(parameters) {
        if (this._keyManagementParameters) {
            throw new TypeError('setKeyManagementParameters can only be called once');
        }
        this._keyManagementParameters = parameters;
        return this;
    }
    setProtectedHeader(protectedHeader) {
        if (this._protectedHeader) {
            throw new TypeError('setProtectedHeader can only be called once');
        }
        this._protectedHeader = protectedHeader;
        return this;
    }
    setSharedUnprotectedHeader(sharedUnprotectedHeader) {
        if (this._sharedUnprotectedHeader) {
            throw new TypeError('setSharedUnprotectedHeader can only be called once');
        }
        this._sharedUnprotectedHeader = sharedUnprotectedHeader;
        return this;
    }
    setUnprotectedHeader(unprotectedHeader) {
        if (this._unprotectedHeader) {
            throw new TypeError('setUnprotectedHeader can only be called once');
        }
        this._unprotectedHeader = unprotectedHeader;
        return this;
    }
    setAdditionalAuthenticatedData(aad) {
        this._aad = aad;
        return this;
    }
    setContentEncryptionKey(cek) {
        if (this._cek) {
            throw new TypeError('setContentEncryptionKey can only be called once');
        }
        this._cek = cek;
        return this;
    }
    setInitializationVector(iv) {
        if (this._iv) {
            throw new TypeError('setInitializationVector can only be called once');
        }
        this._iv = iv;
        return this;
    }
    async encrypt(key, options) {
        if (!this._protectedHeader && !this._unprotectedHeader && !this._sharedUnprotectedHeader) {
            throw new JWEInvalid('either setProtectedHeader, setUnprotectedHeader, or sharedUnprotectedHeader must be called before #encrypt()');
        }
        if (!isDisjoint(this._protectedHeader, this._unprotectedHeader, this._sharedUnprotectedHeader)) {
            throw new JWEInvalid('JWE Shared Protected, JWE Shared Unprotected and JWE Per-Recipient Header Parameter names must be disjoint');
        }
        const joseHeader = {
            ...this._protectedHeader,
            ...this._unprotectedHeader,
            ...this._sharedUnprotectedHeader,
        };
        validateCrit(JWEInvalid, new Map(), options === null || options === void 0 ? void 0 : options.crit, this._protectedHeader, joseHeader);
        if (joseHeader.zip !== undefined) {
            if (!this._protectedHeader || !this._protectedHeader.zip) {
                throw new JWEInvalid('JWE "zip" (Compression Algorithm) Header MUST be integrity protected');
            }
            if (joseHeader.zip !== 'DEF') {
                throw new JOSENotSupported('Unsupported JWE "zip" (Compression Algorithm) Header Parameter value');
            }
        }
        const { alg, enc } = joseHeader;
        if (typeof alg !== 'string' || !alg) {
            throw new JWEInvalid('JWE "alg" (Algorithm) Header Parameter missing or invalid');
        }
        if (typeof enc !== 'string' || !enc) {
            throw new JWEInvalid('JWE "enc" (Encryption Algorithm) Header Parameter missing or invalid');
        }
        let encryptedKey;
        if (alg === 'dir') {
            if (this._cek) {
                throw new TypeError('setContentEncryptionKey cannot be called when using Direct Encryption');
            }
        }
        else if (alg === 'ECDH-ES') {
            if (this._cek) {
                throw new TypeError('setContentEncryptionKey cannot be called when using Direct Key Agreement');
            }
        }
        let cek;
        {
            let parameters;
            ({ cek, encryptedKey, parameters } = await encryptKeyManagement(alg, enc, key, this._cek, this._keyManagementParameters));
            if (parameters) {
                if (!this._protectedHeader) {
                    this.setProtectedHeader(parameters);
                }
                else {
                    this._protectedHeader = { ...this._protectedHeader, ...parameters };
                }
            }
        }
        this._iv || (this._iv = generateIv(enc));
        let additionalData;
        let protectedHeader;
        let aadMember;
        if (this._protectedHeader) {
            protectedHeader = $$.Buffer.from(base64url(JSON.stringify(this._protectedHeader)));
        }
        else {
            protectedHeader = $$.Buffer.from('');
        }
        if (this._aad) {
            aadMember = base64url(this._aad);
            additionalData = concat(protectedHeader, $$.Buffer.from('.'), $$.Buffer.from(aadMember));
        }
        else {
            additionalData = protectedHeader;
        }
        let ciphertext;
        let tag;
        if (joseHeader.zip === 'DEF') {
            const deflated = await ((options === null || options === void 0 ? void 0 : options.deflateRaw) || deflate)(this._plaintext);
            ({ ciphertext, tag } = await encrypt(enc, deflated, cek, this._iv, additionalData));
        }
        else {
            
            ({ ciphertext, tag } = await encrypt(enc, this._plaintext, cek, this._iv, additionalData));
        }
        const jwe = {
            ciphertext: base64url(ciphertext),
            iv: base64url(this._iv),
            tag: base64url(tag),
        };
        if (encryptedKey) {
            jwe.encrypted_key = base64url(encryptedKey);
        }
        if (aadMember) {
            jwe.aad = aadMember;
        }
        if (this._protectedHeader) {
            jwe.protected = protectedHeader.toString();
        }
        if (this._sharedUnprotectedHeader) {
            jwe.unprotected = this._sharedUnprotectedHeader;
        }
        if (this._unprotectedHeader) {
            jwe.header = this._unprotectedHeader;
        }
        return jwe;
    }
}

module.exports.FlattenedEncrypt = FlattenedEncrypt;
},{"../../lib/buffer_utils.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/browser/lib/buffer_utils.js","../../lib/encrypt_key_management.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/browser/lib/encrypt_key_management.js","../../lib/is_disjoint.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/browser/lib/is_disjoint.js","../../lib/iv.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/browser/lib/iv.js","../../lib/validate_crit.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/browser/lib/validate_crit.js","../../runtime/base64url.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/browser/runtime/base64url.js","../../runtime/encrypt.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/browser/runtime/encrypt.js","../../runtime/zlib.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/browser/runtime/zlib.js","../../util/errors.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/browser/util/errors.js"}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/browser/jwe/general/decrypt.js":[function(require,module,exports){
const {flattenedDecrypt} = require('../flattened/decrypt.js');
const {JWEDecryptionFailed, JWEInvalid} = require('../../util/errors.js');
const isObject = require('../../lib/is_object.js');
module.exports.generalDecrypt = async function generalDecrypt(jwe, key, options) {
    if (!isObject(jwe)) {
        throw new JWEInvalid('General JWE must be an object');
    }
    if (!Array.isArray(jwe.recipients) || !jwe.recipients.every(isObject)) {
        throw new JWEInvalid('JWE Recipients missing or incorrect type');
    }
    for (const recipient of jwe.recipients) {
        try {
            return await flattenedDecrypt({
                aad: jwe.aad,
                ciphertext: jwe.ciphertext,
                encrypted_key: recipient.encrypted_key,
                header: recipient.header,
                iv: jwe.iv,
                protected: jwe.protected,
                tag: jwe.tag,
                unprotected: jwe.unprotected,
            }, key, options);
        }
        catch (_a) {
        }
    }
    throw new JWEDecryptionFailed();
}

},{"../../lib/is_object.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/browser/lib/is_object.js","../../util/errors.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/browser/util/errors.js","../flattened/decrypt.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/browser/jwe/flattened/decrypt.js"}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/browser/jwk/embedded.js":[function(require,module,exports){
const {importJWK} = require('../key/import.js');
const isObject = require('../lib/is_object.js');
const {JWSInvalid} = require('../util/errors.js');
module.exports.EmbeddedJWK =  async function EmbeddedJWK(protectedHeader, token) {
    const joseHeader = {
        ...protectedHeader,
        ...token.header,
    };
    if (!isObject(joseHeader.jwk)) {
        throw new JWSInvalid('"jwk" (JSON Web Key) Header Parameter must be a JSON object');
    }
    const key = await importJWK({ ...joseHeader.jwk, ext: true }, joseHeader.alg, true);
    if (key instanceof Uint8Array || key.type !== 'public') {
        throw new JWSInvalid('"jwk" (JSON Web Key) Header Parameter must be a public key');
    }
    return key;
}

},{"../key/import.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/browser/key/import.js","../lib/is_object.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/browser/lib/is_object.js","../util/errors.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/browser/util/errors.js"}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/browser/jwk/thumbprint.js":[function(require,module,exports){
const digest = require('../runtime/digest.js');
const {encode: base64url} = require('../runtime/base64url.js');
const {JOSENotSupported, JWKInvalid} = require('../util/errors.js');
const isObject = require('../lib/is_object.js');
const check = (value, description) => {
    if (typeof value !== 'string' || !value) {
        throw new JWKInvalid(`${description} missing or invalid`);
    }
};
module.exports.calculateJwkThumbprint = async function calculateJwkThumbprint(jwk, digestAlgorithm = 'sha256') {
    if (!isObject(jwk)) {
        throw new TypeError('JWK must be an object');
    }
    let components;
    switch (jwk.kty) {
        case 'EC':
            check(jwk.crv, '"crv" (Curve) Parameter');
            check(jwk.x, '"x" (X Coordinate) Parameter');
            check(jwk.y, '"y" (Y Coordinate) Parameter');
            components = {crv: jwk.crv, kty: jwk.kty, x: jwk.x, y: jwk.y};
            break;
        case 'OKP':
            check(jwk.crv, '"crv" (Subtype of Key Pair) Parameter');
            check(jwk.x, '"x" (Public Key) Parameter');
            components = {crv: jwk.crv, kty: jwk.kty, x: jwk.x};
            break;
        case 'RSA':
            check(jwk.e, '"e" (Exponent) Parameter');
            check(jwk.n, '"n" (Modulus) Parameter');
            components = {e: jwk.e, kty: jwk.kty, n: jwk.n};
            break;
        case 'oct':
            check(jwk.k, '"k" (Key Value) Parameter');
            components = {k: jwk.k, kty: jwk.kty};
            break;
        default:
            throw new JOSENotSupported('"kty" (Key Type) Parameter missing or unsupported');
    }
    const data = $$.Buffer.from(JSON.stringify(components));
    return base64url(await digest(digestAlgorithm, data));
}

},{"../lib/is_object.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/browser/lib/is_object.js","../runtime/base64url.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/browser/runtime/base64url.js","../runtime/digest.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/browser/runtime/digest.js","../util/errors.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/browser/util/errors.js"}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/browser/jwks/remote.js":[function(require,module,exports){
const fetchJwks = require('../runtime/fetch_jwks.js');
const {importJWK} = require('../key/import.js');
const {JWKSInvalid, JOSENotSupported, JWKSNoMatchingKey, JWKSMultipleMatchingKeys,} = require('../util/errors.js');
const isObject = require('../lib/is_object.js');

function getKtyFromAlg(alg) {
    switch (typeof alg === 'string' && alg.substr(0, 2)) {
        case 'RS':
        case 'PS':
            return 'RSA';
        case 'ES':
            return 'EC';
        case 'Ed':
            return 'OKP';
        default:
            throw new JOSENotSupported('Unsupported "alg" value for a JSON Web Key Set');
    }
}

function isJWKLike(key) {
    return isObject(key);
}

class RemoteJWKSet {
    constructor(url, options) {
        this._cached = new WeakMap();
        if (!(url instanceof URL)) {
            throw new TypeError('url must be an instance of URL');
        }
        this._url = new URL(url.href);
        this._options = {agent: options === null || options === void 0 ? void 0 : options.agent};
        this._timeoutDuration =
            typeof (options === null || options === void 0 ? void 0 : options.timeoutDuration) === 'number' ? options === null || options === void 0 ? void 0 : options.timeoutDuration : 5000;
        this._cooldownDuration =
            typeof (options === null || options === void 0 ? void 0 : options.cooldownDuration) === 'number' ? options === null || options === void 0 ? void 0 : options.cooldownDuration : 30000;
    }

    coolingDown() {
        if (!this._cooldownStarted) {
            return false;
        }
        return Date.now() < this._cooldownStarted + this._cooldownDuration;
    }

    async getKey(protectedHeader) {
        if (!this._jwks) {
            await this.reload();
        }
        const candidates = this._jwks.keys.filter((jwk) => {
            let candidate = jwk.kty === getKtyFromAlg(protectedHeader.alg);
            if (candidate && typeof protectedHeader.kid === 'string') {
                candidate = protectedHeader.kid === jwk.kid;
            }
            if (candidate && typeof jwk.alg === 'string') {
                candidate = protectedHeader.alg === jwk.alg;
            }
            if (candidate && typeof jwk.use === 'string') {
                candidate = jwk.use === 'sig';
            }
            if (candidate && Array.isArray(jwk.key_ops)) {
                candidate = jwk.key_ops.includes('verify');
            }
            if (candidate && protectedHeader.alg === 'EdDSA') {
                candidate = jwk.crv === 'Ed25519' || jwk.crv === 'Ed448';
            }
            if (candidate) {
                switch (protectedHeader.alg) {
                    case 'ES256':
                        candidate = jwk.crv === 'P-256';
                        break;
                    case 'ES256K':
                        candidate = jwk.crv === 'secp256k1';
                        break;
                    case 'ES384':
                        candidate = jwk.crv === 'P-384';
                        break;
                    case 'ES512':
                        candidate = jwk.crv === 'P-521';
                        break;
                    default:
                }
            }
            return candidate;
        });
        const {0: jwk, length} = candidates;
        if (length === 0) {
            if (this.coolingDown() === false) {
                await this.reload();
                return this.getKey(protectedHeader);
            }
            throw new JWKSNoMatchingKey();
        } else if (length !== 1) {
            throw new JWKSMultipleMatchingKeys();
        }
        const cached = this._cached.get(jwk) || this._cached.set(jwk, {}).get(jwk);
        if (cached[protectedHeader.alg] === undefined) {
            const keyObject = await importJWK({...jwk, ext: true}, protectedHeader.alg);
            if (keyObject instanceof Uint8Array || keyObject.type !== 'public') {
                throw new JWKSInvalid('JSON Web Key Set members must be public keys');
            }
            cached[protectedHeader.alg] = keyObject;
        }
        return cached[protectedHeader.alg];
    }

    async reload() {
        if (!this._pendingFetch) {
            this._pendingFetch = fetchJwks(this._url, this._timeoutDuration, this._options)
                .then((json) => {
                    if (typeof json !== 'object' ||
                        !json ||
                        !Array.isArray(json.keys) ||
                        !json.keys.every(isJWKLike)) {
                        throw new JWKSInvalid('JSON Web Key Set malformed');
                    }
                    this._jwks = {keys: json.keys};
                    this._cooldownStarted = Date.now();
                    this._pendingFetch = undefined;
                })
                .catch((err) => {
                    this._pendingFetch = undefined;
                    throw err;
                });
        }
        await this._pendingFetch;
    }
}

module.exports.createRemoteJWKSet = function createRemoteJWKSet(url, options) {
    return RemoteJWKSet.prototype.getKey.bind(new RemoteJWKSet(url, options));
};

},{"../key/import.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/browser/key/import.js","../lib/is_object.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/browser/lib/is_object.js","../runtime/fetch_jwks.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/browser/runtime/fetch_jwks.js","../util/errors.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/browser/util/errors.js"}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/browser/jws/compact/sign.js":[function(require,module,exports){
const {FlattenedSign} = require('../flattened/sign.js');
class CompactSign {
    constructor(payload) {
        this._flattened = new FlattenedSign(payload);
    }
    setProtectedHeader(protectedHeader) {
        this._flattened.setProtectedHeader(protectedHeader);
        return this;
    }
    async sign(key, options) {
        const jws = await this._flattened.sign(key, options);
        if (jws.payload === undefined) {
            throw new TypeError('use the flattened module for creating JWS with b64: false');
        }
        return `${jws.protected}.${jws.payload}.${jws.signature}`;
    }
}

module.exports.CompactSign = CompactSign;
},{"../flattened/sign.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/browser/jws/flattened/sign.js"}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/browser/jws/compact/verify.js":[function(require,module,exports){
const {flattenedVerify} = require('../flattened/verify.js');
const {JWSInvalid} = require('../../util/errors.js');
module.exports.compactVerify =  async function compactVerify(jws, key, options) {
    if (jws instanceof Uint8Array) {
        jws = jws.toString();
    }
    if (typeof jws !== 'string') {
        throw new JWSInvalid('Compact JWS must be a string or Uint8Array');
    }
    const { 0: protectedHeader, 1: payload, 2: signature, length } = jws.split('.');
    if (length !== 3) {
        throw new JWSInvalid('Invalid Compact JWS');
    }
    const verified = await flattenedVerify({
        payload: (payload || undefined),
        protected: protectedHeader || undefined,
        signature: (signature || undefined),
    }, key, options);
    const result = { payload: verified.payload, protectedHeader: verified.protectedHeader };
    if (typeof key === 'function') {
        return { ...result, key: verified.key };
    }
    return result;
}

},{"../../util/errors.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/browser/util/errors.js","../flattened/verify.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/browser/jws/flattened/verify.js"}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/browser/jws/flattened/sign.js":[function(require,module,exports){
const {encode: base64url} = require('../../runtime/base64url.js');
const sign = require('../../runtime/sign.js');
const isDisjoint = require('../../lib/is_disjoint.js');
const {JWSInvalid} = require('../../util/errors.js');
const checkKeyType = require('../../lib/check_key_type.js');
const validateCrit = require('../../lib/validate_crit.js');
class FlattenedSign {
    constructor(payload) {
        if (!(payload instanceof Uint8Array)) {
            throw new TypeError('payload must be an instance of Uint8Array');
        }
        this._payload = payload;
    }
    setProtectedHeader(protectedHeader) {
        if (this._protectedHeader) {
            throw new TypeError('setProtectedHeader can only be called once');
        }
        this._protectedHeader = protectedHeader;
        return this;
    }
    setUnprotectedHeader(unprotectedHeader) {
        if (this._unprotectedHeader) {
            throw new TypeError('setUnprotectedHeader can only be called once');
        }
        this._unprotectedHeader = unprotectedHeader;
        return this;
    }
    async sign(key, options) {
        if (!this._protectedHeader && !this._unprotectedHeader) {
            throw new JWSInvalid('either setProtectedHeader or setUnprotectedHeader must be called before #sign()');
        }
        if (!isDisjoint(this._protectedHeader, this._unprotectedHeader)) {
            throw new JWSInvalid('JWS Protected and JWS Unprotected Header Parameter names must be disjoint');
        }
        const joseHeader = {
            ...this._protectedHeader,
            ...this._unprotectedHeader,
        };
        const extensions = validateCrit(JWSInvalid, new Map([['b64', true]]), options === null || options === void 0 ? void 0 : options.crit, this._protectedHeader, joseHeader);
        let b64 = true;
        if (extensions.has('b64')) {
            b64 = this._protectedHeader.b64;
            if (typeof b64 !== 'boolean') {
                throw new JWSInvalid('The "b64" (base64url-encode payload) Header Parameter must be a boolean');
            }
        }
        const { alg } = joseHeader;
        if (typeof alg !== 'string' || !alg) {
            throw new JWSInvalid('JWS "alg" (Algorithm) Header Parameter missing or invalid');
        }
        checkKeyType(alg, key, 'sign');
        let payload = this._payload;
        if (b64) {
            payload = $$.Buffer.from(base64url(payload));
        }
        let protectedHeader;
        if (this._protectedHeader) {
            protectedHeader = $$.Buffer.from(base64url(JSON.stringify(this._protectedHeader)));
        }
        else {
            protectedHeader = $$.Buffer.from('');
        }
        const data = concat(protectedHeader, $$.Buffer.from('.'), payload);
        const signature = await sign(alg, key, data);
        const jws = {
            signature: base64url(signature),
            payload: '',
        };
        if (b64) {
            jws.payload = payload.toString();
        }
        if (this._unprotectedHeader) {
            jws.header = this._unprotectedHeader;
        }
        if (this._protectedHeader) {
            jws.protected = protectedHeader.toString();
        }
        return jws;
    }
}

module.exports.FlattenedSign = FlattenedSign;
},{"../../lib/check_key_type.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/browser/lib/check_key_type.js","../../lib/is_disjoint.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/browser/lib/is_disjoint.js","../../lib/validate_crit.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/browser/lib/validate_crit.js","../../runtime/base64url.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/browser/runtime/base64url.js","../../runtime/sign.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/browser/runtime/sign.js","../../util/errors.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/browser/util/errors.js"}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/browser/jws/flattened/verify.js":[function(require,module,exports){
const {decode: base64url} = require('../../runtime/base64url.js');
const verify = require('../../runtime/verify.js');
const {JOSEAlgNotAllowed, JWSInvalid, JWSSignatureVerificationFailed} = require('../../util/errors.js');
const {concat} = require('../../lib/buffer_utils.js');
const isDisjoint = require('../../lib/is_disjoint.js');
const isObject = require('../../lib/is_object.js');
const checkKeyType = require('../../lib/check_key_type.js');
const validateCrit = require('../../lib/validate_crit.js');
const validateAlgorithms = require('../../lib/validate_algorithms.js');
module.exports.flattenedVerify = async function flattenedVerify(jws, key, options) {
    var _a;
    if (!isObject(jws)) {
        throw new JWSInvalid('Flattened JWS must be an object');
    }
    if (jws.protected === undefined && jws.header === undefined) {
        throw new JWSInvalid('Flattened JWS must have either of the "protected" or "header" members');
    }
    if (jws.protected !== undefined && typeof jws.protected !== 'string') {
        throw new JWSInvalid('JWS Protected Header incorrect type');
    }
    if (jws.payload === undefined) {
        throw new JWSInvalid('JWS Payload missing');
    }
    if (typeof jws.signature !== 'string') {
        throw new JWSInvalid('JWS Signature missing or incorrect type');
    }
    if (jws.header !== undefined && !isObject(jws.header)) {
        throw new JWSInvalid('JWS Unprotected Header incorrect type');
    }
    let parsedProt = {};
    if (jws.protected) {
        const protectedHeader = base64url(jws.protected);
        try {
            parsedProt = JSON.parse(protectedHeader.toString());
        }
        catch (_b) {
            throw new JWSInvalid('JWS Protected Header is invalid');
        }
    }
    if (!isDisjoint(parsedProt, jws.header)) {
        throw new JWSInvalid('JWS Protected and JWS Unprotected Header Parameter names must be disjoint');
    }
    const joseHeader = {
        ...parsedProt,
        ...jws.header,
    };
    const extensions = validateCrit(JWSInvalid, new Map([['b64', true]]), options === null || options === void 0 ? void 0 : options.crit, parsedProt, joseHeader);
    let b64 = true;
    if (extensions.has('b64')) {
        b64 = parsedProt.b64;
        if (typeof b64 !== 'boolean') {
            throw new JWSInvalid('The "b64" (base64url-encode payload) Header Parameter must be a boolean');
        }
    }
    const { alg } = joseHeader;
    if (typeof alg !== 'string' || !alg) {
        throw new JWSInvalid('JWS "alg" (Algorithm) Header Parameter missing or invalid');
    }
    const algorithms = options && validateAlgorithms('algorithms', options.algorithms);
    if (algorithms && !algorithms.has(alg)) {
        throw new JOSEAlgNotAllowed('"alg" (Algorithm) Header Parameter not allowed');
    }
    if (b64) {
        if (typeof jws.payload !== 'string') {
            throw new JWSInvalid('JWS Payload must be a string');
        }
    }
    else if (typeof jws.payload !== 'string' && !(jws.payload instanceof Uint8Array)) {
        throw new JWSInvalid('JWS Payload must be a string or an Uint8Array instance');
    }
    let resolvedKey = false;
    if (typeof key === 'function') {
        key = await key(parsedProt, jws);
        resolvedKey = true;
    }
    checkKeyType(alg, key, 'verify');
    const data = concat($$.Buffer.from((_a = jws.protected) !== null && _a !== void 0 ? _a : ''), $$.Buffer.from('.'), typeof jws.payload === 'string' ? $$.Buffer.from(jws.payload) : jws.payload);
    const signature = base64url(jws.signature);
    const verified = await verify(alg, key, signature, data);
    if (!verified) {
        throw new JWSSignatureVerificationFailed();
    }
    let payload;
    if (b64) {
        payload = base64url(jws.payload);
    }
    else if (typeof jws.payload === 'string') {
        payload = $$.Buffer.from(jws.payload);
    }
    else {
        payload = jws.payload;
    }
    const result = { payload };
    if (jws.protected !== undefined) {
        result.protectedHeader = parsedProt;
    }
    if (jws.header !== undefined) {
        result.unprotectedHeader = jws.header;
    }
    if (resolvedKey) {
        return { ...result, key };
    }
    return result;
}

},{"../../lib/buffer_utils.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/browser/lib/buffer_utils.js","../../lib/check_key_type.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/browser/lib/check_key_type.js","../../lib/is_disjoint.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/browser/lib/is_disjoint.js","../../lib/is_object.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/browser/lib/is_object.js","../../lib/validate_algorithms.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/browser/lib/validate_algorithms.js","../../lib/validate_crit.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/browser/lib/validate_crit.js","../../runtime/base64url.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/browser/runtime/base64url.js","../../runtime/verify.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/browser/runtime/verify.js","../../util/errors.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/browser/util/errors.js"}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/browser/jws/general/sign.js":[function(require,module,exports){
const {FlattenedSign} = require('../flattened/sign.js');
const {JWSInvalid} = require('../../util/errors.js');
const signatureRef = new WeakMap();
class IndividualSignature {
    setProtectedHeader(protectedHeader) {
        if (this._protectedHeader) {
            throw new TypeError('setProtectedHeader can only be called once');
        }
        this._protectedHeader = protectedHeader;
        return this;
    }
    setUnprotectedHeader(unprotectedHeader) {
        if (this._unprotectedHeader) {
            throw new TypeError('setUnprotectedHeader can only be called once');
        }
        this._unprotectedHeader = unprotectedHeader;
        return this;
    }
    set _protectedHeader(value) {
        signatureRef.get(this).protectedHeader = value;
    }
    get _protectedHeader() {
        return signatureRef.get(this).protectedHeader;
    }
    set _unprotectedHeader(value) {
        signatureRef.get(this).unprotectedHeader = value;
    }
    get _unprotectedHeader() {
        return signatureRef.get(this).unprotectedHeader;
    }
}
class GeneralSign {
    constructor(payload) {
        this._signatures = [];
        this._payload = payload;
    }
    addSignature(key, options) {
        const signature = new IndividualSignature();
        signatureRef.set(signature, { key, options });
        this._signatures.push(signature);
        return signature;
    }
    async sign() {
        if (!this._signatures.length) {
            throw new JWSInvalid('at least one signature must be added');
        }
        const jws = {
            signatures: [],
            payload: '',
        };
        let payloads = new Set();
        await Promise.all(this._signatures.map(async (sig) => {
            const { protectedHeader, unprotectedHeader, options, key } = signatureRef.get(sig);
            const flattened = new FlattenedSign(this._payload);
            if (protectedHeader) {
                flattened.setProtectedHeader(protectedHeader);
            }
            if (unprotectedHeader) {
                flattened.setUnprotectedHeader(unprotectedHeader);
            }
            const { payload, ...rest } = await flattened.sign(key, options);
            payloads.add(payload);
            jws.payload = payload;
            jws.signatures.push(rest);
        }));
        if (payloads.size !== 1) {
            throw new JWSInvalid('inconsistent use of JWS Unencoded Payload Option (RFC7797)');
        }
        return jws;
    }
}

module.exports.GeneralSign = GeneralSign;
},{"../../util/errors.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/browser/util/errors.js","../flattened/sign.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/browser/jws/flattened/sign.js"}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/browser/jws/general/verify.js":[function(require,module,exports){
const {flattenedVerify} = require('../flattened/verify.js');
const {JWSInvalid, JWSSignatureVerificationFailed} = require('../../util/errors.js');
const isObject = require('../../lib/is_object.js');
module.exports.generalVerify = async function generalVerify(jws, key, options) {
    if (!isObject(jws)) {
        throw new JWSInvalid('General JWS must be an object');
    }
    if (!Array.isArray(jws.signatures) || !jws.signatures.every(isObject)) {
        throw new JWSInvalid('JWS Signatures missing or incorrect type');
    }
    for (const signature of jws.signatures) {
        try {
            return await flattenedVerify({
                header: signature.header,
                payload: jws.payload,
                protected: signature.protected,
                signature: signature.signature,
            }, key, options);
        } catch (_a) {
        }
    }
    throw new JWSSignatureVerificationFailed();
}

},{"../../lib/is_object.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/browser/lib/is_object.js","../../util/errors.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/browser/util/errors.js","../flattened/verify.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/browser/jws/flattened/verify.js"}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/browser/jwt/decrypt.js":[function(require,module,exports){
const {compactDecrypt} = require('../jwe/compact/decrypt.js');
const jwtPayload = require('../lib/jwt_claims_set.js');
const {JWTClaimValidationFailed} = require('../util/errors.js');
module.exports.jwtDecrypt = async function jwtDecrypt(jwt, key, options) {
    const decrypted = await compactDecrypt(jwt, key, options);
    const payload = jwtPayload(decrypted.protectedHeader, decrypted.plaintext, options);
    const {protectedHeader} = decrypted;
    if (protectedHeader.iss !== undefined && protectedHeader.iss !== payload.iss) {
        throw new JWTClaimValidationFailed('replicated "iss" claim header parameter mismatch', 'iss', 'mismatch');
    }
    if (protectedHeader.sub !== undefined && protectedHeader.sub !== payload.sub) {
        throw new JWTClaimValidationFailed('replicated "sub" claim header parameter mismatch', 'sub', 'mismatch');
    }
    if (protectedHeader.aud !== undefined &&
        JSON.stringify(protectedHeader.aud) !== JSON.stringify(payload.aud)) {
        throw new JWTClaimValidationFailed('replicated "aud" claim header parameter mismatch', 'aud', 'mismatch');
    }
    const result = {payload, protectedHeader};
    if (typeof key === 'function') {
        return {...result, key: decrypted.key};
    }
    return result;
}

},{"../jwe/compact/decrypt.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/browser/jwe/compact/decrypt.js","../lib/jwt_claims_set.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/browser/lib/jwt_claims_set.js","../util/errors.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/browser/util/errors.js"}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/browser/jwt/encrypt.js":[function(require,module,exports){
const {CompactEncrypt} = require('../jwe/compact/encrypt.js');
const {ProduceJWT} = require('./produce.js');
class EncryptJWT extends ProduceJWT {
    setProtectedHeader(protectedHeader) {
        if (this._protectedHeader) {
            throw new TypeError('setProtectedHeader can only be called once');
        }
        this._protectedHeader = protectedHeader;
        return this;
    }
    setKeyManagementParameters(parameters) {
        if (this._keyManagementParameters) {
            throw new TypeError('setKeyManagementParameters can only be called once');
        }
        this._keyManagementParameters = parameters;
        return this;
    }
    setContentEncryptionKey(cek) {
        if (this._cek) {
            throw new TypeError('setContentEncryptionKey can only be called once');
        }
        this._cek = cek;
        return this;
    }
    setInitializationVector(iv) {
        if (this._iv) {
            throw new TypeError('setInitializationVector can only be called once');
        }
        this._iv = iv;
        return this;
    }
    replicateIssuerAsHeader() {
        this._replicateIssuerAsHeader = true;
        return this;
    }
    replicateSubjectAsHeader() {
        this._replicateSubjectAsHeader = true;
        return this;
    }
    replicateAudienceAsHeader() {
        this._replicateAudienceAsHeader = true;
        return this;
    }
    async encrypt(key, options) {
        const enc = new CompactEncrypt($$.Buffer.from(JSON.stringify(this._payload)));
        if (this._replicateIssuerAsHeader) {
            this._protectedHeader = { ...this._protectedHeader, iss: this._payload.iss };
        }
        if (this._replicateSubjectAsHeader) {
            this._protectedHeader = { ...this._protectedHeader, sub: this._payload.sub };
        }
        if (this._replicateAudienceAsHeader) {
            this._protectedHeader = { ...this._protectedHeader, aud: this._payload.aud };
        }
        enc.setProtectedHeader(this._protectedHeader);
        if (this._iv) {
            enc.setInitializationVector(this._iv);
        }
        if (this._cek) {
            enc.setContentEncryptionKey(this._cek);
        }
        if (this._keyManagementParameters) {
            enc.setKeyManagementParameters(this._keyManagementParameters);
        }
        return enc.encrypt(key, options);
    }
}

module.exports.EncryptJWT = EncryptJWT;
},{"../jwe/compact/encrypt.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/browser/jwe/compact/encrypt.js","./produce.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/browser/jwt/produce.js"}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/browser/jwt/produce.js":[function(require,module,exports){
const epoch = require('../lib/epoch.js');
const isObject = require('../lib/is_object.js');
const secs = require('../lib/secs.js');
class ProduceJWT {
    constructor(payload) {
        if (!isObject(payload)) {
            throw new TypeError('JWT Claims Set MUST be an object');
        }
        this._payload = payload;
    }
    setIssuer(issuer) {
        this._payload = { ...this._payload, iss: issuer };
        return this;
    }
    setSubject(subject) {
        this._payload = { ...this._payload, sub: subject };
        return this;
    }
    setAudience(audience) {
        this._payload = { ...this._payload, aud: audience };
        return this;
    }
    setJti(jwtId) {
        this._payload = { ...this._payload, jti: jwtId };
        return this;
    }
    setNotBefore(input) {
        if (typeof input === 'number') {
            this._payload = { ...this._payload, nbf: input };
        }
        else {
            this._payload = { ...this._payload, nbf: epoch(new Date()) + secs(input) };
        }
        return this;
    }
    setExpirationTime(input) {
        if (typeof input === 'number') {
            this._payload = { ...this._payload, exp: input };
        }
        else {
            this._payload = { ...this._payload, exp: epoch(new Date()) + secs(input) };
        }
        return this;
    }
    setIssuedAt(input) {
        if (typeof input === 'undefined') {
            this._payload = { ...this._payload, iat: epoch(new Date()) };
        }
        else {
            this._payload = { ...this._payload, iat: input };
        }
        return this;
    }
}

module.exports.ProduceJWT = ProduceJWT;
},{"../lib/epoch.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/browser/lib/epoch.js","../lib/is_object.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/browser/lib/is_object.js","../lib/secs.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/browser/lib/secs.js"}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/browser/jwt/sign.js":[function(require,module,exports){
const {CompactSign} = require('../jws/compact/sign.js');
const {JWTInvalid} = require('../util/errors.js');
const {encoder} = require('../lib/buffer_utils.js');
const {ProduceJWT} = require('./produce.js');

class SignJWT extends ProduceJWT {
    setProtectedHeader(protectedHeader) {
        this._protectedHeader = protectedHeader;
        return this;
    }

    async sign(key, options) {
        var _a;
        const sig = new CompactSign($$.Buffer.from(JSON.stringify(this._payload)));
        sig.setProtectedHeader(this._protectedHeader);
        if (Array.isArray((_a = this._protectedHeader) === null || _a === void 0 ? void 0 : _a.crit) &&
            this._protectedHeader.crit.includes('b64') &&
            this._protectedHeader.b64 === false) {
            throw new JWTInvalid('JWTs MUST NOT use unencoded payload');
        }
        return sig.sign(key, options);
    }
}

module.exports.SignJWT = SignJWT;
},{"../jws/compact/sign.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/browser/jws/compact/sign.js","../lib/buffer_utils.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/browser/lib/buffer_utils.js","../util/errors.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/browser/util/errors.js","./produce.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/browser/jwt/produce.js"}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/browser/jwt/unsecured.js":[function(require,module,exports){
const base64url = require('../runtime/base64url.js');
const {JWTInvalid} = require('../util/errors.js');
const jwtPayload = require('../lib/jwt_claims_set.js');
const {ProduceJWT} = require('./produce.js');

class UnsecuredJWT extends ProduceJWT {
    encode() {
        const header = base64url.encode(JSON.stringify({alg: 'none'}));
        const payload = base64url.encode(JSON.stringify(this._payload));
        return `${header}.${payload}.`;
    }

    static decode(jwt, options) {
        if (typeof jwt !== 'string') {
            throw new JWTInvalid('Unsecured JWT must be a string');
        }
        const {0: encodedHeader, 1: encodedPayload, 2: signature, length} = jwt.split('.');
        if (length !== 3 || signature !== '') {
            throw new JWTInvalid('Invalid Unsecured JWT');
        }
        let header;
        try {
            header = JSON.parse(base64url.decode(encodedHeader).toString());
            if (header.alg !== 'none')
                throw new Error();
        } catch (_a) {
            throw new JWTInvalid('Invalid Unsecured JWT');
        }
        const payload = jwtPayload(header, base64url.decode(encodedPayload), options);
        return {payload, header};
    }
}

module.exports.UnsecuredJWT = UnsecuredJWT;
},{"../lib/jwt_claims_set.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/browser/lib/jwt_claims_set.js","../runtime/base64url.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/browser/runtime/base64url.js","../util/errors.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/browser/util/errors.js","./produce.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/browser/jwt/produce.js"}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/browser/jwt/verify.js":[function(require,module,exports){
const {compactVerify} = require('../jws/compact/verify.js');
const jwtPayload = require('../lib/jwt_claims_set.js');
const {JWTInvalid} = require('../util/errors.js');
module.exports.jwtVerify = async function jwtVerify(jwt, key, options) {
    var _a;
    const verified = await compactVerify(jwt, key, options);
    if (((_a = verified.protectedHeader.crit) === null || _a === void 0 ? void 0 : _a.includes('b64')) && verified.protectedHeader.b64 === false) {
        throw new JWTInvalid('JWTs MUST NOT use unencoded payload');
    }
    const payload = jwtPayload(verified.protectedHeader, verified.payload, options);
    const result = { payload, protectedHeader: verified.protectedHeader };
    if (typeof key === 'function') {
        return { ...result, key: verified.key };
    }
    return result;
}

},{"../jws/compact/verify.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/browser/jws/compact/verify.js","../lib/jwt_claims_set.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/browser/lib/jwt_claims_set.js","../util/errors.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/browser/util/errors.js"}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/browser/key/export.js":[function(require,module,exports){
const {toSPKI: exportPublic} = require('../runtime/asn1.js');
const {toPKCS8: exportPrivate} = require('../runtime/asn1.js');
const keyToJWK = require('../runtime/key_to_jwk.js');

module.exports.exportSPKI = function exportSPKI(key) {
    return exportPublic(key);
}

module.exports.exportPKCS8 = function exportPKCS8(key) {
    return exportPrivate(key);
}

module.exports.exportJWK = function exportJWK(key) {
    return keyToJWK(key);
}

},{"../runtime/asn1.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/browser/runtime/asn1.js","../runtime/key_to_jwk.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/browser/runtime/key_to_jwk.js"}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/browser/key/generate_key_pair.js":[function(require,module,exports){
const {generateKeyPair: generate} = require('../runtime/generate.js');
module.exports.generateKeyPair = async function generateKeyPair(alg, options) {
    return generate(alg, options);
}

},{"../runtime/generate.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/browser/runtime/generate.js"}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/browser/key/generate_secret.js":[function(require,module,exports){
const {generateSecret: generate} = require('../runtime/generate.js');
module.exports.generateSecret = async function generateSecret(alg, options) {
    return generate(alg, options);
};

},{"../runtime/generate.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/browser/runtime/generate.js"}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/browser/key/import.js":[function(require,module,exports){
const {decode: decodeBase64URL, encodeBase64, decodeBase64} = require('../runtime/base64url.js');
const {fromSPKI: importPublic} = require('../runtime/asn1.js');
const {fromPKCS8: importPrivate} = require('../runtime/asn1.js');
const asKeyObject = require('../runtime/jwk_to_key.js');
const {JOSENotSupported} = require('../util/errors.js');
const formatPEM = require('../lib/format_pem.js');
const isObject = require('../lib/is_object.js');
function getElement(seq) {
    let result = [];
    let next = 0;
    while (next < seq.length) {
        let nextPart = parseElement(seq.subarray(next));
        result.push(nextPart);
        next += nextPart.byteLength;
    }
    return result;
}
function parseElement(bytes) {
    let position = 0;
    let tag = bytes[0] & 0x1f;
    position++;
    if (tag === 0x1f) {
        tag = 0;
        while (bytes[position] >= 0x80) {
            tag = tag * 128 + bytes[position] - 0x80;
            position++;
        }
        tag = tag * 128 + bytes[position] - 0x80;
        position++;
    }
    let length = 0;
    if (bytes[position] < 0x80) {
        length = bytes[position];
        position++;
    }
    else {
        let numberOfDigits = bytes[position] & 0x7f;
        position++;
        length = 0;
        for (let i = 0; i < numberOfDigits; i++) {
            length = length * 256 + bytes[position];
            position++;
        }
    }
    if (length === 0x80) {
        length = 0;
        while (bytes[position + length] !== 0 || bytes[position + length + 1] !== 0) {
            length++;
        }
        const byteLength = position + length + 2;
        return {
            byteLength,
            contents: bytes.subarray(position, position + length),
            raw: bytes.subarray(0, byteLength),
        };
    }
    const byteLength = position + length;
    return {
        byteLength,
        contents: bytes.subarray(position, byteLength),
        raw: bytes.subarray(0, byteLength),
    };
}
function spkiFromX509(buf) {
    return encodeBase64(getElement(getElement(parseElement(buf).contents)[0].contents)[6].raw);
}
function getSPKI(x509) {
    const pem = x509.replace(/(?:-----(?:BEGIN|END) CERTIFICATE-----|\s)/g, '');
    const raw = decodeBase64(pem);
    return formatPEM(spkiFromX509(raw), 'PUBLIC KEY');
}
async function importSPKI(spki, alg, options) {
    if (typeof spki !== 'string' || spki.indexOf('-----BEGIN PUBLIC KEY-----') !== 0) {
        throw new TypeError('"spki" must be SPKI formatted string');
    }
    return importPublic(spki, alg, options);
}
async function importX509(x509, alg, options) {
    if (typeof x509 !== 'string' || x509.indexOf('-----BEGIN CERTIFICATE-----') !== 0) {
        throw new TypeError('"x509" must be X.509 formatted string');
    }
    const spki = getSPKI(x509);
    return importPublic(spki, alg, options);
}
async function importPKCS8(pkcs8, alg, options) {
    if (typeof pkcs8 !== 'string' || pkcs8.indexOf('-----BEGIN PRIVATE KEY-----') !== 0) {
        throw new TypeError('"pkcs8" must be PCKS8 formatted string');
    }
    return importPrivate(pkcs8, alg, options);
}
async function importJWK(jwk, alg, octAsKeyObject) {
    if (!isObject(jwk)) {
        throw new TypeError('JWK must be an object');
    }
    alg || (alg = jwk.alg);
    if (typeof alg !== 'string' || !alg) {
        throw new TypeError('"alg" argument is required when "jwk.alg" is not present');
    }
    switch (jwk.kty) {
        case 'oct':
            if (typeof jwk.k !== 'string' || !jwk.k) {
                throw new TypeError('missing "k" (Key Value) Parameter value');
            }
            octAsKeyObject !== null && octAsKeyObject !== void 0 ? octAsKeyObject : (octAsKeyObject = jwk.ext !== true);
            if (octAsKeyObject) {
                return asKeyObject({ ...jwk, alg, ext: false });
            }
            return decodeBase64URL(jwk.k);
        case 'RSA':
            if (jwk.oth !== undefined) {
                throw new JOSENotSupported('RSA JWK "oth" (Other Primes Info) Parameter value is not supported');
            }
        case 'EC':
        case 'OKP':
            return asKeyObject({ ...jwk, alg });
        default:
            throw new JOSENotSupported('Unsupported "kty" (Key Type) Parameter value');
    }
}

module.exports = {
    importSPKI,
    importX509,
    importPKCS8,
    importJWK
}
},{"../lib/format_pem.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/browser/lib/format_pem.js","../lib/is_object.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/browser/lib/is_object.js","../runtime/asn1.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/browser/runtime/asn1.js","../runtime/base64url.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/browser/runtime/base64url.js","../runtime/jwk_to_key.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/browser/runtime/jwk_to_key.js","../util/errors.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/browser/util/errors.js"}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/browser/lib/aesgcmkw.js":[function(require,module,exports){
const encrypt = require('../runtime/encrypt.js');
const decrypt = require('../runtime/decrypt.js');
const generateIv = require('./iv.js');
const {encode: base64url} = require('../runtime/base64url.js');
module.exports.wrap = async function wrap(alg, key, cek, iv) {
    const jweAlgorithm = alg.substr(0, 7);
    iv || (iv = generateIv(jweAlgorithm));
    const {ciphertext: encryptedKey, tag} = await encrypt(jweAlgorithm, cek, key, iv, new Uint8Array(0));
    return {encryptedKey, iv: base64url(iv), tag: base64url(tag)};
}
module.exports.unwrap = async function unwrap(alg, key, encryptedKey, iv, tag) {
    const jweAlgorithm = alg.substr(0, 7);
    return decrypt(jweAlgorithm, key, encryptedKey, iv, tag, new Uint8Array(0));
}

},{"../runtime/base64url.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/browser/runtime/base64url.js","../runtime/decrypt.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/browser/runtime/decrypt.js","../runtime/encrypt.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/browser/runtime/encrypt.js","./iv.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/browser/lib/iv.js"}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/browser/lib/buffer_utils.js":[function(require,module,exports){
const encoder = new TextEncoder();
const decoder = new TextDecoder();
const MAX_INT32 = 2 ** 32;

function concat(...buffers) {
    const size = buffers.reduce((acc, {length}) => acc + length, 0);
    const buf = new Uint8Array(size);
    let i = 0;
    buffers.forEach((buffer) => {
        buf.set(buffer, i);
        i += buffer.length;
    });
    return buf;
}

function p2s(alg, p2sInput) {
    return concat($$.Buffer.from(alg), new Uint8Array([0]), p2sInput);
}

function writeUInt32BE(buf, value, offset) {
    if (value < 0 || value >= MAX_INT32) {
        throw new RangeError(`value must be >= 0 and <= ${MAX_INT32 - 1}. Received ${value}`);
    }
    buf.set([value >>> 24, value >>> 16, value >>> 8, value & 0xff], offset);
}

function uint64be(value) {
    const high = Math.floor(value / MAX_INT32);
    const low = value % MAX_INT32;
    const buf = new Uint8Array(8);
    writeUInt32BE(buf, high, 0);
    writeUInt32BE(buf, low, 4);
    return buf;
}

function uint32be(value) {
    const buf = new Uint8Array(4);
    writeUInt32BE(buf, value);
    return buf;
}

async function concatKdf(digest, secret, bits, value) {
    const iterations = Math.ceil((bits >> 3) / 32);
    let res;
    for (let iter = 1; iter <= iterations; iter++) {
        const buf = new Uint8Array(4 + secret.length + value.length);
        buf.set(uint32be(iter));
        buf.set(secret, 4);
        buf.set(value, 4 + secret.length);
        if (!res) {
            res = await digest('sha256', buf);
        } else {
            res = concat(res, await digest('sha256', buf));
        }
    }
    res = res.slice(0, bits >> 3);
    return res;
}

module.exports = {
    encoder,
    decoder,
    uint64be,
    uint32be,
    p2s,
    concatKdf,
    concat
}
},{}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/browser/lib/cek.js":[function(require,module,exports){
const {JOSENotSupported} = require('../util/errors.js');
const crypto = require("crypto");
module.exports.bitLength = function bitLength(alg) {
    switch (alg) {
        case 'A128CBC-HS256':
            return 256;
        case 'A192CBC-HS384':
            return 384;
        case 'A256CBC-HS512':
            return 512;
        case 'A128GCM':
            return 128;
        case 'A192GCM':
            return 192;
        case 'A256GCM':
            return 256;
        default:
            throw new JOSENotSupported(`Unsupported JWE Algorithm: ${alg}`);
    }
}
module.exports = (alg) => crypto.randomBytes(module.exports.bitLength(alg) >> 3);

},{"../util/errors.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/browser/util/errors.js","crypto":false}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/browser/lib/check_iv_length.js":[function(require,module,exports){
const {JWEInvalid} = require('../util/errors.js');
const {bitLength} = require('./iv.js');
const checkIvLength = (enc, iv) => {
    if (iv.length << 3 !== bitLength(enc)) {
        throw new JWEInvalid('Invalid Initialization Vector length');
    }
};
module.exports = checkIvLength;

},{"../util/errors.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/browser/util/errors.js","./iv.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/browser/lib/iv.js"}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/browser/lib/check_key_type.js":[function(require,module,exports){
const invalidKeyInput = require('./invalid_key_input.js');
const isKeyLike = require('../runtime/is_key_like.js');
const types = isKeyLike.types;
const symmetricTypeCheck = (key) => {
    if (key instanceof Uint8Array)
        return;
    if (!isKeyLike(key)) {
        throw new TypeError(invalidKeyInput(key, ...types, 'Uint8Array'));
    }
    if (key.type !== 'secret') {
        throw new TypeError(`${types.join(' or ')} instances for symmetric algorithms must be of type "secret"`);
    }
};
const asymmetricTypeCheck = (key, usage) => {
    if (!isKeyLike(key)) {
        throw new TypeError(invalidKeyInput(key, ...types));
    }
    if (key.type === 'secret') {
        throw new TypeError(`${types.join(' or ')} instances for asymmetric algorithms must not be of type "secret"`);
    }
    if (usage === 'sign' && key.type === 'public') {
        throw new TypeError(`${types.join(' or ')} instances for asymmetric algorithm signing must be of type "private"`);
    }
    if (usage === 'decrypt' && key.type === 'public') {
        throw new TypeError(`${types.join(' or ')} instances for asymmetric algorithm decryption must be of type "private"`);
    }
    if (key.algorithm && usage === 'verify' && key.type === 'private') {
        throw new TypeError(`${types.join(' or ')} instances for asymmetric algorithm verifying must be of type "public"`);
    }
    if (key.algorithm && usage === 'encrypt' && key.type === 'private') {
        throw new TypeError(`${types.join(' or ')} instances for asymmetric algorithm encryption must be of type "public"`);
    }
};
const checkKeyType = (alg, key, usage) => {
    const symmetric = alg.startsWith('HS') ||
        alg === 'dir' ||
        alg.startsWith('PBES2') ||
        /^A\d{3}(?:GCM)?KW$/.test(alg);
    if (symmetric) {
        symmetricTypeCheck(key);
    } else {
        asymmetricTypeCheck(key, usage);
    }
};
module.exports = checkKeyType;

},{"../runtime/is_key_like.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/browser/runtime/is_key_like.js","./invalid_key_input.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/browser/lib/invalid_key_input.js"}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/browser/lib/check_p2s.js":[function(require,module,exports){
const {JWEInvalid} = require('../util/errors.js');
module.exports = function checkP2s(p2s) {
    if (!(p2s instanceof Uint8Array) || p2s.length < 8) {
        throw new JWEInvalid('PBES2 Salt Input must be 8 or more octets');
    }
}

},{"../util/errors.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/browser/util/errors.js"}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/browser/lib/crypto_key.js":[function(require,module,exports){
const {isCloudflareWorkers, isNodeJs} = require('../runtime/global.js');

function unusable(name, prop = 'algorithm.name') {
    return new TypeError(`CryptoKey does not support this operation, its ${prop} must be ${name}`);
}

function isAlgorithm(algorithm, name) {
    return algorithm.name === name;
}

function getHashLength(hash) {
    return parseInt(hash.name.substr(4), 10);
}

function getNamedCurve(alg) {
    switch (alg) {
        case 'ES256':
            return 'P-256';
        case 'ES384':
            return 'P-384';
        case 'ES512':
            return 'P-521';
        default:
            throw new Error('unreachable');
    }
}

function checkUsage(key, usages) {
    if (usages.length && !usages.some((expected) => key.usages.includes(expected))) {
        let msg = 'CryptoKey does not support this operation, its usages must include ';
        if (usages.length > 2) {
            const last = usages.pop();
            msg += `one of ${usages.join(', ')}, or ${last}.`;
        } else if (usages.length === 2) {
            msg += `one of ${usages[0]} or ${usages[1]}.`;
        } else {
            msg += `${usages[0]}.`;
        }
        throw new TypeError(msg);
    }
}

module.exports.checkSigCryptoKey = function checkSigCryptoKey(key, alg, ...usages) {
    switch (alg) {
        case 'HS256':
        case 'HS384':
        case 'HS512': {
            if (!isAlgorithm(key.algorithm, 'HMAC'))
                throw unusable('HMAC');
            const expected = parseInt(alg.substr(2), 10);
            const actual = getHashLength(key.algorithm.hash);
            if (actual !== expected)
                throw unusable(`SHA-${expected}`, 'algorithm.hash');
            break;
        }
        case 'RS256':
        case 'RS384':
        case 'RS512': {
            if (!isAlgorithm(key.algorithm, 'RSASSA-PKCS1-v1_5'))
                throw unusable('RSASSA-PKCS1-v1_5');
            const expected = parseInt(alg.substr(2), 10);
            const actual = getHashLength(key.algorithm.hash);
            if (actual !== expected)
                throw unusable(`SHA-${expected}`, 'algorithm.hash');
            break;
        }
        case 'PS256':
        case 'PS384':
        case 'PS512': {
            if (!isAlgorithm(key.algorithm, 'RSA-PSS'))
                throw unusable('RSA-PSS');
            const expected = parseInt(alg.substr(2), 10);
            const actual = getHashLength(key.algorithm.hash);
            if (actual !== expected)
                throw unusable(`SHA-${expected}`, 'algorithm.hash');
            break;
        }
        case isNodeJs() && 'EdDSA': {
            if (key.algorithm.name !== 'NODE-ED25519' && key.algorithm.name !== 'NODE-ED448')
                throw unusable('NODE-ED25519 or NODE-ED448');
            break;
        }
        case isCloudflareWorkers() && 'EdDSA': {
            if (!isAlgorithm(key.algorithm, 'NODE-ED25519'))
                throw unusable('NODE-ED25519');
            break;
        }
        case 'ES256':
        case 'ES384':
        case 'ES512': {
            if (!isAlgorithm(key.algorithm, 'ECDSA'))
                throw unusable('ECDSA');
            const expected = getNamedCurve(alg);
            const actual = key.algorithm.namedCurve;
            if (actual !== expected)
                throw unusable(expected, 'algorithm.namedCurve');
            break;
        }
        default:
            throw new TypeError('CryptoKey does not support this operation');
    }
    checkUsage(key, usages);
}
module.exports.checkEncCryptoKey = function checkEncCryptoKey(key, alg, ...usages) {
    switch (alg) {
        case 'A128GCM':
        case 'A192GCM':
        case 'A256GCM': {
            if (!isAlgorithm(key.algorithm, 'AES-GCM'))
                throw unusable('AES-GCM');
            const expected = parseInt(alg.substr(1, 3), 10);
            const actual = key.algorithm.length;
            if (actual !== expected)
                throw unusable(expected, 'algorithm.length');
            break;
        }
        case 'A128KW':
        case 'A192KW':
        case 'A256KW': {
            if (!isAlgorithm(key.algorithm, 'AES-KW'))
                throw unusable('AES-KW');
            const expected = parseInt(alg.substr(1, 3), 10);
            const actual = key.algorithm.length;
            if (actual !== expected)
                throw unusable(expected, 'algorithm.length');
            break;
        }
        case 'ECDH-ES':
            if (!isAlgorithm(key.algorithm, 'ECDH'))
                throw unusable('ECDH');
            break;
        case 'PBES2-HS256+A128KW':
        case 'PBES2-HS384+A192KW':
        case 'PBES2-HS512+A256KW':
            if (!isAlgorithm(key.algorithm, 'PBKDF2'))
                throw unusable('PBKDF2');
            break;
        case 'RSA-OAEP':
        case 'RSA-OAEP-256':
        case 'RSA-OAEP-384':
        case 'RSA-OAEP-512': {
            if (!isAlgorithm(key.algorithm, 'RSA-OAEP'))
                throw unusable('RSA-OAEP');
            const expected = parseInt(alg.substr(9), 10) || 1;
            const actual = getHashLength(key.algorithm.hash);
            if (actual !== expected)
                throw unusable(`SHA-${expected}`, 'algorithm.hash');
            break;
        }
        default:
            throw new TypeError('CryptoKey does not support this operation');
    }
    checkUsage(key, usages);
}

},{"../runtime/global.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/browser/runtime/global.js"}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/browser/lib/decrypt_key_management.js":[function(require,module,exports){
const {unwrap: aesKw} = require('../runtime/aeskw.js');
const ECDH = require('../runtime/ecdhes.js');
const {decrypt: pbes2Kw} = require('../runtime/pbes2kw.js');
const {decrypt: rsaEs} = require('../runtime/rsaes.js');
const {decode: base64url} = require('../runtime/base64url.js');
const {JOSENotSupported, JWEInvalid} = require('../util/errors.js');
const {bitLength: cekLength} = require('../lib/cek.js');
const {importJWK} = require('../key/import.js');
const checkKeyType = require('./check_key_type.js');
const isObject = require('./is_object.js');
const {unwrap: aesGcmKw} = require('./aesgcmkw.js');
async function decryptKeyManagement(alg, key, encryptedKey, joseHeader) {
    checkKeyType(alg, key, 'decrypt');
    switch (alg) {
        case 'dir': {
            if (encryptedKey !== undefined)
                throw new JWEInvalid('Encountered unexpected JWE Encrypted Key');
            return key;
        }
        case 'ECDH-ES':
            if (encryptedKey !== undefined)
                throw new JWEInvalid('Encountered unexpected JWE Encrypted Key');
        case 'ECDH-ES+A128KW':
        case 'ECDH-ES+A192KW':
        case 'ECDH-ES+A256KW': {
            if (!isObject(joseHeader.epk))
                throw new JWEInvalid(`JOSE Header "epk" (Ephemeral Public Key) missing or invalid`);
            if (!ECDH.ecdhAllowed(key))
                throw new JOSENotSupported('ECDH-ES with the provided key is not allowed or not supported by your javascript runtime');
            const epk = await importJWK(joseHeader.epk, alg);
            let partyUInfo;
            let partyVInfo;
            if (joseHeader.apu !== undefined) {
                if (typeof joseHeader.apu !== 'string')
                    throw new JWEInvalid(`JOSE Header "apu" (Agreement PartyUInfo) invalid`);
                partyUInfo = base64url(joseHeader.apu);
            }
            if (joseHeader.apv !== undefined) {
                if (typeof joseHeader.apv !== 'string')
                    throw new JWEInvalid(`JOSE Header "apv" (Agreement PartyVInfo) invalid`);
                partyVInfo = base64url(joseHeader.apv);
            }
            const sharedSecret = await ECDH.deriveKey(epk, key, alg === 'ECDH-ES' ? joseHeader.enc : alg, parseInt(alg.substr(-5, 3), 10) || cekLength(joseHeader.enc), partyUInfo, partyVInfo);
            if (alg === 'ECDH-ES')
                return sharedSecret;
            if (encryptedKey === undefined)
                throw new JWEInvalid('JWE Encrypted Key missing');
            return aesKw(alg.substr(-6), sharedSecret, encryptedKey);
        }
        case 'RSA1_5':
        case 'RSA-OAEP':
        case 'RSA-OAEP-256':
        case 'RSA-OAEP-384':
        case 'RSA-OAEP-512': {
            if (encryptedKey === undefined)
                throw new JWEInvalid('JWE Encrypted Key missing');
            return rsaEs(alg, key, encryptedKey);
        }
        case 'PBES2-HS256+A128KW':
        case 'PBES2-HS384+A192KW':
        case 'PBES2-HS512+A256KW': {
            if (encryptedKey === undefined)
                throw new JWEInvalid('JWE Encrypted Key missing');
            if (typeof joseHeader.p2c !== 'number')
                throw new JWEInvalid(`JOSE Header "p2c" (PBES2 Count) missing or invalid`);
            if (typeof joseHeader.p2s !== 'string')
                throw new JWEInvalid(`JOSE Header "p2s" (PBES2 Salt) missing or invalid`);
            return pbes2Kw(alg, key, encryptedKey, joseHeader.p2c, base64url(joseHeader.p2s));
        }
        case 'A128KW':
        case 'A192KW':
        case 'A256KW': {
            if (encryptedKey === undefined)
                throw new JWEInvalid('JWE Encrypted Key missing');
            return aesKw(alg, key, encryptedKey);
        }
        case 'A128GCMKW':
        case 'A192GCMKW':
        case 'A256GCMKW': {
            if (encryptedKey === undefined)
                throw new JWEInvalid('JWE Encrypted Key missing');
            if (typeof joseHeader.iv !== 'string')
                throw new JWEInvalid(`JOSE Header "iv" (Initialization Vector) missing or invalid`);
            if (typeof joseHeader.tag !== 'string')
                throw new JWEInvalid(`JOSE Header "tag" (Authentication Tag) missing or invalid`);
            const iv = base64url(joseHeader.iv);
            const tag = base64url(joseHeader.tag);
            return aesGcmKw(alg, key, encryptedKey, iv, tag);
        }
        default: {
            throw new JOSENotSupported('Invalid or unsupported "alg" (JWE Algorithm) header value');
        }
    }
}
module.exports = decryptKeyManagement;

},{"../key/import.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/browser/key/import.js","../lib/cek.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/browser/lib/cek.js","../runtime/aeskw.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/browser/runtime/aeskw.js","../runtime/base64url.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/browser/runtime/base64url.js","../runtime/ecdhes.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/browser/runtime/ecdhes.js","../runtime/pbes2kw.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/browser/runtime/pbes2kw.js","../runtime/rsaes.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/browser/runtime/rsaes.js","../util/errors.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/browser/util/errors.js","./aesgcmkw.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/browser/lib/aesgcmkw.js","./check_key_type.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/browser/lib/check_key_type.js","./is_object.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/browser/lib/is_object.js"}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/browser/lib/encrypt_key_management.js":[function(require,module,exports){
const {wrap: aesKw} = require('../runtime/aeskw.js');
const ECDH = require('../runtime/ecdhes.js');
const {encrypt: pbes2Kw} = require('../runtime/pbes2kw.js');
const {encrypt: rsaEs} = require('../runtime/rsaes.js');
const {encode: base64url} = require('../runtime/base64url.js');
const generateCek = require('../lib/cek.js');
const {JOSENotSupported} = require('../util/errors.js');
const {exportJWK} = require('../key/export.js');
const checkKeyType = require('./check_key_type.js');
const {wrap: aesGcmKw} = require('./aesgcmkw.js');

async function encryptKeyManagement(alg, enc, key, providedCek, providedParameters = {}) {
    let encryptedKey;
    let parameters;
    let cek;
    checkKeyType(alg, key, 'encrypt');
    switch (alg) {
        case 'dir': {
            cek = key;
            break;
        }
        case 'ECDH-ES':
        case 'ECDH-ES+A128KW':
        case 'ECDH-ES+A192KW':
        case 'ECDH-ES+A256KW': {
            if (!ECDH.ecdhAllowed(key)) {
                throw new JOSENotSupported('ECDH-ES with the provided key is not allowed or not supported by your javascript runtime');
            }
            const {apu, apv} = providedParameters;
            let {epk: ephemeralKey} = providedParameters;
            ephemeralKey || (ephemeralKey = await ECDH.generateEpk(key));
            const {x, y, crv, kty} = await exportJWK(ephemeralKey);
            const sharedSecret = await ECDH.deriveKey(key, ephemeralKey, alg === 'ECDH-ES' ? enc : alg, parseInt(alg.substr(-5, 3), 10) || generateCek.bitLength(enc), apu, apv);
            parameters = {epk: {x, y, crv, kty}};
            if (apu)
                parameters.apu = base64url(apu);
            if (apv)
                parameters.apv = base64url(apv);
            if (alg === 'ECDH-ES') {
                cek = sharedSecret;
                break;
            }
            cek = providedCek || generateCek(enc);
            const kwAlg = alg.substr(-6);
            encryptedKey = await aesKw(kwAlg, sharedSecret, cek);
            break;
        }
        case 'RSA1_5':
        case 'RSA-OAEP':
        case 'RSA-OAEP-256':
        case 'RSA-OAEP-384':
        case 'RSA-OAEP-512': {
            cek = providedCek || generateCek(enc);
            encryptedKey = await rsaEs(alg, key, cek);
            break;
        }
        case 'PBES2-HS256+A128KW':
        case 'PBES2-HS384+A192KW':
        case 'PBES2-HS512+A256KW': {
            cek = providedCek || generateCek(enc);
            const {p2c, p2s} = providedParameters;
            ({encryptedKey, ...parameters} = await pbes2Kw(alg, key, cek, p2c, p2s));
            break;
        }
        case 'A128KW':
        case 'A192KW':
        case 'A256KW': {
            cek = providedCek || generateCek(enc);
            encryptedKey = await aesKw(alg, key, cek);
            break;
        }
        case 'A128GCMKW':
        case 'A192GCMKW':
        case 'A256GCMKW': {
            cek = providedCek || generateCek(enc);
            const {iv} = providedParameters;
            ({encryptedKey, ...parameters} = await aesGcmKw(alg, key, cek, iv));
            break;
        }
        default: {
            throw new JOSENotSupported('Invalid or unsupported "alg" (JWE Algorithm) header value');
        }
    }
    return {cek, encryptedKey, parameters};
}

module.exports = encryptKeyManagement;

},{"../key/export.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/browser/key/export.js","../lib/cek.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/browser/lib/cek.js","../runtime/aeskw.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/browser/runtime/aeskw.js","../runtime/base64url.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/browser/runtime/base64url.js","../runtime/ecdhes.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/browser/runtime/ecdhes.js","../runtime/pbes2kw.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/browser/runtime/pbes2kw.js","../runtime/rsaes.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/browser/runtime/rsaes.js","../util/errors.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/browser/util/errors.js","./aesgcmkw.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/browser/lib/aesgcmkw.js","./check_key_type.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/browser/lib/check_key_type.js"}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/browser/lib/epoch.js":[function(require,module,exports){
module.exports = (date) => Math.floor(date.getTime() / 1000);

},{}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/browser/lib/format_pem.js":[function(require,module,exports){
module.exports = (b64, descriptor) => {
    const newlined = (b64.match(/.{1,64}/g) || []).join('\n');
    return `-----BEGIN ${descriptor}-----\n${newlined}\n-----END ${descriptor}-----`;
};

},{}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/browser/lib/invalid_key_input.js":[function(require,module,exports){
module.exports = (actual, ...types) => {
    let msg = 'Key must be ';
    if (types.length > 2) {
        const last = types.pop();
        msg += `one of type ${types.join(', ')}, or ${last}.`;
    }
    else if (types.length === 2) {
        msg += `one of type ${types[0]} or ${types[1]}.`;
    }
    else {
        msg += `of type ${types[0]}.`;
    }
    if (actual == null) {
        msg += ` Received ${actual}`;
    }
    else if (typeof actual === 'function' && actual.name) {
        msg += ` Received function ${actual.name}`;
    }
    else if (typeof actual === 'object' && actual != null) {
        if (actual.constructor && actual.constructor.name) {
            msg += ` Received an instance of ${actual.constructor.name}`;
        }
    }
    return msg;
};

},{}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/browser/lib/is_disjoint.js":[function(require,module,exports){
const isDisjoint = (...headers) => {
    const sources = headers.filter(Boolean);
    if (sources.length === 0 || sources.length === 1) {
        return true;
    }
    let acc;
    for (const header of sources) {
        const parameters = Object.keys(header);
        if (!acc || acc.size === 0) {
            acc = new Set(parameters);
            continue;
        }
        for (const parameter of parameters) {
            if (acc.has(parameter)) {
                return false;
            }
            acc.add(parameter);
        }
    }
    return true;
};
module.exports = isDisjoint;

},{}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/browser/lib/is_object.js":[function(require,module,exports){
function isObjectLike(value) {
    return typeof value === 'object' && value !== null;
}
module.exports = function isObject(input) {
    if (!isObjectLike(input) || Object.prototype.toString.call(input) !== '[object Object]') {
        return false;
    }
    if (Object.getPrototypeOf(input) === null) {
        return true;
    }
    let proto = input;
    while (Object.getPrototypeOf(proto) !== null) {
        proto = Object.getPrototypeOf(proto);
    }
    return Object.getPrototypeOf(input) === proto;
}

},{}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/browser/lib/iv.js":[function(require,module,exports){
const {JOSENotSupported} = require('../util/errors.js');
const crypto = require("crypto");
module.exports.bitLength = function bitLength(alg) {
    switch (alg) {
        case 'A128CBC-HS256':
            return 128;
        case 'A128GCM':
            return 96;
        case 'A128GCMKW':
            return 96;
        case 'A192CBC-HS384':
            return 128;
        case 'A192GCM':
            return 96;
        case 'A192GCMKW':
            return 96;
        case 'A256CBC-HS512':
            return 128;
        case 'A256GCM':
            return 96;
        case 'A256GCMKW':
            return 96;
        default:
            throw new JOSENotSupported(`Unsupported JWE Algorithm: ${alg}`);
    }
}
module.exports = (alg) => crypto.randomBytes(module.exports.bitLength(alg) >> 3);

},{"../util/errors.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/browser/util/errors.js","crypto":false}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/browser/lib/jwt_claims_set.js":[function(require,module,exports){
const {JWTClaimValidationFailed, JWTExpired, JWTInvalid} = require('../util/errors.js');
const epoch = require('./epoch.js');
const secs = require('./secs.js');
const isObject = require('./is_object.js');
const normalizeTyp = (value) => value.toLowerCase().replace(/^application\//, '');
const checkAudiencePresence = (audPayload, audOption) => {
    if (typeof audPayload === 'string') {
        return audOption.includes(audPayload);
    }
    if (Array.isArray(audPayload)) {
        return audOption.some(Set.prototype.has.bind(new Set(audPayload)));
    }
    return false;
};
module.exports = (protectedHeader, encodedPayload, options = {}) => {
    const { typ } = options;
    if (typ &&
        (typeof protectedHeader.typ !== 'string' ||
            normalizeTyp(protectedHeader.typ) !== normalizeTyp(typ))) {
        throw new JWTClaimValidationFailed('unexpected "typ" JWT header value', 'typ', 'check_failed');
    }
    let payload;
    try {
        payload = JSON.parse(encodedPayload.toString());
    }
    catch (_a) {
    }
    if (!isObject(payload)) {
        throw new JWTInvalid('JWT Claims Set must be a top-level JSON object');
    }
    const { issuer } = options;
    if (issuer && !(Array.isArray(issuer) ? issuer : [issuer]).includes(payload.iss)) {
        throw new JWTClaimValidationFailed('unexpected "iss" claim value', 'iss', 'check_failed');
    }
    const { subject } = options;
    if (subject && payload.sub !== subject) {
        throw new JWTClaimValidationFailed('unexpected "sub" claim value', 'sub', 'check_failed');
    }
    const { audience } = options;
    if (audience &&
        !checkAudiencePresence(payload.aud, typeof audience === 'string' ? [audience] : audience)) {
        throw new JWTClaimValidationFailed('unexpected "aud" claim value', 'aud', 'check_failed');
    }
    let tolerance;
    switch (typeof options.clockTolerance) {
        case 'string':
            tolerance = secs(options.clockTolerance);
            break;
        case 'number':
            tolerance = options.clockTolerance;
            break;
        case 'undefined':
            tolerance = 0;
            break;
        default:
            throw new TypeError('Invalid clockTolerance option type');
    }
    const { currentDate } = options;
    const now = epoch(currentDate || new Date());
    if (payload.iat !== undefined || options.maxTokenAge) {
        if (typeof payload.iat !== 'number') {
            throw new JWTClaimValidationFailed('"iat" claim must be a number', 'iat', 'invalid');
        }
        if (payload.exp === undefined && payload.iat > now + tolerance) {
            throw new JWTClaimValidationFailed('"iat" claim timestamp check failed (it should be in the past)', 'iat', 'check_failed');
        }
    }
    if (payload.nbf !== undefined) {
        if (typeof payload.nbf !== 'number') {
            throw new JWTClaimValidationFailed('"nbf" claim must be a number', 'nbf', 'invalid');
        }
        if (payload.nbf > now + tolerance) {
            throw new JWTClaimValidationFailed('"nbf" claim timestamp check failed', 'nbf', 'check_failed');
        }
    }
    if (payload.exp !== undefined) {
        if (typeof payload.exp !== 'number') {
            throw new JWTClaimValidationFailed('"exp" claim must be a number', 'exp', 'invalid');
        }
        if (payload.exp <= now - tolerance) {
            throw new JWTExpired('"exp" claim timestamp check failed', 'exp', 'check_failed');
        }
    }
    if (options.maxTokenAge) {
        const age = now - payload.iat;
        const max = typeof options.maxTokenAge === 'number' ? options.maxTokenAge : secs(options.maxTokenAge);
        if (age - tolerance > max) {
            throw new JWTExpired('"iat" claim timestamp check failed (too far in the past)', 'iat', 'check_failed');
        }
        if (age < 0 - tolerance) {
            throw new JWTClaimValidationFailed('"iat" claim timestamp check failed (it should be in the past)', 'iat', 'check_failed');
        }
    }
    return payload;
};

},{"../util/errors.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/browser/util/errors.js","./epoch.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/browser/lib/epoch.js","./is_object.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/browser/lib/is_object.js","./secs.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/browser/lib/secs.js"}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/browser/lib/secs.js":[function(require,module,exports){
const minute = 60;
const hour = minute * 60;
const day = hour * 24;
const week = day * 7;
const year = day * 365.25;
const REGEX = /^(\d+|\d+\.\d+) ?(seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)$/i;
module.exports = (str) => {
    const matched = REGEX.exec(str);
    if (!matched) {
        throw new TypeError('Invalid time period format');
    }
    const value = parseFloat(matched[1]);
    const unit = matched[2].toLowerCase();
    switch (unit) {
        case 'sec':
        case 'secs':
        case 'second':
        case 'seconds':
        case 's':
            return Math.round(value);
        case 'minute':
        case 'minutes':
        case 'min':
        case 'mins':
        case 'm':
            return Math.round(value * minute);
        case 'hour':
        case 'hours':
        case 'hr':
        case 'hrs':
        case 'h':
            return Math.round(value * hour);
        case 'day':
        case 'days':
        case 'd':
            return Math.round(value * day);
        case 'week':
        case 'weeks':
        case 'w':
            return Math.round(value * week);
        default:
            return Math.round(value * year);
    }
};

},{}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/browser/lib/validate_algorithms.js":[function(require,module,exports){
const validateAlgorithms = (option, algorithms) => {
    if (algorithms !== undefined &&
        (!Array.isArray(algorithms) || algorithms.some((s) => typeof s !== 'string'))) {
        throw new TypeError(`"${option}" option must be an array of strings`);
    }
    if (!algorithms) {
        return undefined;
    }
    return new Set(algorithms);
};
module.exports = validateAlgorithms;

},{}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/browser/lib/validate_crit.js":[function(require,module,exports){
const {JOSENotSupported} = require('../util/errors.js');
function validateCrit(Err, recognizedDefault, recognizedOption, protectedHeader, joseHeader) {
    if (joseHeader.crit !== undefined && protectedHeader.crit === undefined) {
        throw new Err('"crit" (Critical) Header Parameter MUST be integrity protected');
    }
    if (!protectedHeader || protectedHeader.crit === undefined) {
        return new Set();
    }
    if (!Array.isArray(protectedHeader.crit) ||
        protectedHeader.crit.length === 0 ||
        protectedHeader.crit.some((input) => typeof input !== 'string' || input.length === 0)) {
        throw new Err('"crit" (Critical) Header Parameter MUST be an array of non-empty strings when present');
    }
    let recognized;
    if (recognizedOption !== undefined) {
        recognized = new Map([...Object.entries(recognizedOption), ...recognizedDefault.entries()]);
    }
    else {
        recognized = recognizedDefault;
    }
    for (const parameter of protectedHeader.crit) {
        if (!recognized.has(parameter)) {
            throw new JOSENotSupported(`Extension Header Parameter "${parameter}" is not recognized`);
        }
        if (joseHeader[parameter] === undefined) {
            throw new Err(`Extension Header Parameter "${parameter}" is missing`);
        }
        else if (recognized.get(parameter) && protectedHeader[parameter] === undefined) {
            throw new Err(`Extension Header Parameter "${parameter}" MUST be integrity protected`);
        }
    }
    return new Set(protectedHeader.crit);
}
module.exports = validateCrit;

},{"../util/errors.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/browser/util/errors.js"}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/browser/runtime/aeskw.js":[function(require,module,exports){
const bogusWebCrypto = require('./bogus.js');
const crypto = require('./webcrypto.js');
const {checkEncCryptoKey} = require('../lib/crypto_key.js');
const invalidKeyInput = require('../lib/invalid_key_input.js');

function checkKeySize(key, alg) {
    if (key.algorithm.length !== parseInt(alg.substr(1, 3), 10)) {
        throw new TypeError(`Invalid key size for alg: ${alg}`);
    }
}

function getCryptoKey(key, alg, usage) {
    if (crypto.isCryptoKey(key)) {
        checkEncCryptoKey(key, alg, usage);
        return key;
    }
    if (key instanceof Uint8Array) {
        return crypto.subtle.importKey('raw', key, 'AES-KW', true, [usage]);
    }
    throw new TypeError(invalidKeyInput(key, 'CryptoKey', 'Uint8Array'));
}

const wrap = async (alg, key, cek) => {
    const cryptoKey = await getCryptoKey(key, alg, 'wrapKey');
    checkKeySize(cryptoKey, alg);
    const cryptoKeyCek = await crypto.subtle.importKey('raw', cek, ...bogusWebCrypto);
    return new Uint8Array(await crypto.subtle.wrapKey('raw', cryptoKeyCek, cryptoKey, 'AES-KW'));
};
const unwrap = async (alg, key, encryptedKey) => {
    const cryptoKey = await getCryptoKey(key, alg, 'unwrapKey');
    checkKeySize(cryptoKey, alg);
    const cryptoKeyCek = await crypto.subtle.unwrapKey('raw', encryptedKey, cryptoKey, 'AES-KW', ...bogusWebCrypto);
    return new Uint8Array(await crypto.subtle.exportKey('raw', cryptoKeyCek));
};

module.exports = {
    wrap,
    unwrap
}
},{"../lib/crypto_key.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/browser/lib/crypto_key.js","../lib/invalid_key_input.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/browser/lib/invalid_key_input.js","./bogus.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/browser/runtime/bogus.js","./webcrypto.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/browser/runtime/webcrypto.js"}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/browser/runtime/asn1.js":[function(require,module,exports){
const globalThis = require('./global.js');
const crypto = require('./webcrypto.js');
const invalidKeyInput = require('../lib/invalid_key_input.js');
const {encodeBase64} = require('./base64url.js');
const formatPEM = require('../lib/format_pem.js');
const {JOSENotSupported} = require('../util/errors.js');
const genericExport = async (keyType, keyFormat, key) => {
    if (!crypto.isCryptoKey(key)) {
        throw new TypeError(invalidKeyInput(key, 'CryptoKey'));
    }
    if (!key.extractable) {
        throw new TypeError('CryptoKey is not extractable');
    }
    if (key.type !== keyType) {
        throw new TypeError(`key is not a ${keyType} key`);
    }
    return formatPEM(encodeBase64(new Uint8Array(await crypto.subtle.Key(keyFormat, key))), `${keyType.toUpperCase()} KEY`);
};
const toSPKI = (key) => {
    return genericExport('public', 'spki', key);
};
const toPKCS8 = (key) => {
    return genericExport('private', 'pkcs8', key);
};
const getNamedCurve = (keyData) => {
    const keyDataStr = keyData.toString();
    switch (true) {
        case keyDataStr.includes(new Uint8Array([
            0x06, 0x07, 0x2a, 0x86, 0x48, 0xce, 0x3d, 0x02, 0x01, 0x06, 0x08, 0x2a, 0x86, 0x48, 0xce,
            0x3d, 0x03, 0x01, 0x07,
        ]).toString()):
            return 'P-256';
        case keyDataStr.includes(new Uint8Array([
            0x06, 0x07, 0x2a, 0x86, 0x48, 0xce, 0x3d, 0x02, 0x01, 0x06, 0x05, 0x2b, 0x81, 0x04, 0x00,
            0x22,
        ]).toString()):
            return 'P-384';
        case keyDataStr.includes(new Uint8Array([
            0x06, 0x07, 0x2a, 0x86, 0x48, 0xce, 0x3d, 0x02, 0x01, 0x06, 0x05, 0x2b, 0x81, 0x04, 0x00,
            0x23,
        ]).toString()):
            return 'P-521';
        case (globalThis.isCloudflareWorkers() || globalThis.isNodeJs()) &&
        keyDataStr.includes(new Uint8Array([0x06, 0x03, 0x2b, 0x65, 0x70]).toString()):
            return 'Ed25519';
        case isNodeJs() &&
        keyDataStr.includes(new Uint8Array([0x06, 0x03, 0x2b, 0x65, 0x71]).toString()):
            return 'Ed448';
        default:
            throw new JOSENotSupported('Invalid or unsupported EC Key Curve or OKP Key Sub Type');
    }
};
const genericImport = async (replace, keyFormat, pem, alg, options) => {
    var _a;
    let algorithm;
    let keyUsages;
    const keyData = new Uint8Array(globalThis
        .atob(pem.replace(replace, ''))
        .split('')
        .map((c) => c.charCodeAt(0)));
    const isPublic = keyFormat === 'spki';
    switch (alg) {
        case 'PS256':
        case 'PS384':
        case 'PS512':
            algorithm = {name: 'RSA-PSS', hash: `SHA-${alg.substr(-3)}`};
            keyUsages = isPublic ? ['verify'] : ['sign'];
            break;
        case 'RS256':
        case 'RS384':
        case 'RS512':
            algorithm = {name: 'RSASSA-PKCS1-v1_5', hash: `SHA-${alg.substr(-3)}`};
            keyUsages = isPublic ? ['verify'] : ['sign'];
            break;
        case 'RSA-OAEP':
        case 'RSA-OAEP-256':
        case 'RSA-OAEP-384':
        case 'RSA-OAEP-512':
            algorithm = {
                name: 'RSA-OAEP',
                hash: `SHA-${parseInt(alg.substr(-3), 10) || 1}`,
            };
            keyUsages = isPublic ? ['encrypt', 'wrapKey'] : ['decrypt', 'unwrapKey'];
            break;
        case 'ES256':
            algorithm = {name: 'ECDSA', namedCurve: 'P-256'};
            keyUsages = isPublic ? ['verify'] : ['sign'];
            break;
        case 'ES384':
            algorithm = {name: 'ECDSA', namedCurve: 'P-384'};
            keyUsages = isPublic ? ['verify'] : ['sign'];
            break;
        case 'ES512':
            algorithm = {name: 'ECDSA', namedCurve: 'P-521'};
            keyUsages = isPublic ? ['verify'] : ['sign'];
            break;
        case 'ECDH-ES':
        case 'ECDH-ES+A128KW':
        case 'ECDH-ES+A192KW':
        case 'ECDH-ES+A256KW':
            algorithm = {name: 'ECDH', namedCurve: getNamedCurve(keyData)};
            keyUsages = isPublic ? [] : ['deriveBits'];
            break;
        case (globalThis.isCloudflareWorkers() || globalThis.isNodeJs()) && 'EdDSA':
            const namedCurve = getNamedCurve(keyData).toUpperCase();
            algorithm = {name: `NODE-${namedCurve}`, namedCurve: `NODE-${namedCurve}`};
            keyUsages = isPublic ? ['verify'] : ['sign'];
            break;
        default:
            throw new JOSENotSupported('Invalid or unsupported "alg" (Algorithm) value');
    }
    return crypto.subtle.importKey(keyFormat, keyData, algorithm, (_a = options === null || options === void 0 ? void 0 : options.extractable) !== null && _a !== void 0 ? _a : false, keyUsages);
};
const fromPKCS8 = (pem, alg, options) => {
    return genericImport(/(?:-----(?:BEGIN|END) PRIVATE KEY-----|\s)/g, 'pkcs8', pem, alg, options);
};
const fromSPKI = (pem, alg, options) => {
    return genericImport(/(?:-----(?:BEGIN|END) PUBLIC KEY-----|\s)/g, 'spki', pem, alg, options);
};

module.exports = {
    toSPKI,
    toPKCS8,
    fromSPKI,
    fromPKCS8
}
},{"../lib/format_pem.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/browser/lib/format_pem.js","../lib/invalid_key_input.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/browser/lib/invalid_key_input.js","../util/errors.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/browser/util/errors.js","./base64url.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/browser/runtime/base64url.js","./global.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/browser/runtime/global.js","./webcrypto.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/browser/runtime/webcrypto.js"}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/browser/runtime/base64url.js":[function(require,module,exports){
const encodeBase64 = (input) => {
    return $$.Buffer.from(input).toString("base64");
};
const encode = (input) => {
    return encodeBase64(input).replace(/=/g, '').replace(/\+/g, '-').replace(/\//g, '_');
};
const decodeBase64 = (encoded) => {
    return $$.Buffer.from(encoded, "base64").toString();
};
const decode = (input) => {
    let encoded = input;
    if ($$.Buffer.isBuffer(encoded)) {
        encoded = encoded.toString();
    }
    encoded = encoded.replace(/-/g, '+').replace(/_/g, '/').replace(/\s/g, '');
    try {
        return decodeBase64(encoded);
    }
    catch (_a) {
        throw new TypeError('The input to be decoded is not correctly encoded.');
    }
};

module.exports = {
    encodeBase64,
    encode,
    decodeBase64,
    decode
}
},{}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/browser/runtime/bogus.js":[function(require,module,exports){
const bogusWebCrypto = [
    { hash: 'SHA-256', name: 'HMAC' },
    true,
    ['sign'],
];
module.exports = bogusWebCrypto;

},{}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/browser/runtime/check_cek_length.js":[function(require,module,exports){
const {JWEInvalid} = require('../util/errors.js');
const checkCekLength = (cek, expected) => {
    if (cek.length << 3 !== expected) {
        throw new JWEInvalid('Invalid Content Encryption Key length');
    }
};
module.exports = checkCekLength;

},{"../util/errors.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/browser/util/errors.js"}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/browser/runtime/check_key_length.js":[function(require,module,exports){
module.exports = (alg, key) => {
    if (alg.startsWith('HS')) {
        const bitlen = parseInt(alg.substr(-3), 10);
        const { length } = key.algorithm;
        if (typeof length !== 'number' || length < bitlen) {
            throw new TypeError(`${alg} requires symmetric keys to be ${bitlen} bits or larger`);
        }
    }
    if (alg.startsWith('RS') || alg.startsWith('PS')) {
        const { modulusLength } = key.algorithm;
        if (typeof modulusLength !== 'number' || modulusLength < 2048) {
            throw new TypeError(`${alg} requires key modulusLength to be 2048 bits or larger`);
        }
    }
};

},{}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/browser/runtime/decrypt.js":[function(require,module,exports){
const {concat, uint64be} = require('../lib/buffer_utils.js');
const checkIvLength = require('../lib/check_iv_length.js');
const checkCekLength = require('./check_cek_length.js');
const timingSafeEqual = require('./timing_safe_equal.js');
const {JOSENotSupported, JWEDecryptionFailed} = require('../util/errors.js');
const crypto = require('./webcrypto.js');
const {checkEncCryptoKey} = require('../lib/crypto_key.js');
const invalidKeyInput = require('../lib/invalid_key_input.js');

async function cbcDecrypt(enc, cek, ciphertext, iv, tag, aad) {
    if (!(cek instanceof Uint8Array)) {
        throw new TypeError(invalidKeyInput(cek, 'Uint8Array'));
    }
    const keySize = parseInt(enc.substr(1, 3), 10);
    const encKey = await crypto.subtle.importKey('raw', cek.subarray(keySize >> 3), 'AES-CBC', false, ['decrypt']);
    const macKey = await crypto.subtle.importKey('raw', cek.subarray(0, keySize >> 3), {
        hash: `SHA-${keySize << 1}`,
        name: 'HMAC',
    }, false, ['sign']);
    const macData = concat(aad, iv, ciphertext, uint64be(aad.length << 3));
    const expectedTag = new Uint8Array((await crypto.subtle.sign('HMAC', macKey, macData)).slice(0, keySize >> 3));
    let macCheckPassed;
    try {
        macCheckPassed = timingSafeEqual(tag, expectedTag);
    } catch (_a) {
    }
    if (!macCheckPassed) {
        throw new JWEDecryptionFailed();
    }
    let plaintext;
    try {
        plaintext = new Uint8Array(await crypto.subtle.decrypt({iv, name: 'AES-CBC'}, encKey, ciphertext));
    } catch (_b) {
    }
    if (!plaintext) {
        throw new JWEDecryptionFailed();
    }
    return plaintext;
}

async function gcmDecrypt(enc, cek, ciphertext, iv, tag, aad) {
    let encKey;
    if (cek instanceof Uint8Array) {
        encKey = await crypto.subtle.importKey('raw', cek, 'AES-GCM', false, ['decrypt']);
    } else {
        checkEncCryptoKey(cek, enc, 'decrypt');
        encKey = cek;
    }
    try {
        return new Uint8Array(await crypto.subtle.decrypt({
            additionalData: aad,
            iv,
            name: 'AES-GCM',
            tagLength: 128,
        }, encKey, concat(ciphertext, tag)));
    } catch (_a) {
        throw new JWEDecryptionFailed();
    }
}

const decrypt = async (enc, cek, ciphertext, iv, tag, aad) => {
    if (!crypto.isCryptoKey(cek) && !(cek instanceof Uint8Array)) {
        throw new TypeError(invalidKeyInput(cek, 'CryptoKey', 'Uint8Array'));
    }
    checkIvLength(enc, iv);
    switch (enc) {
        case 'A128CBC-HS256':
        case 'A192CBC-HS384':
        case 'A256CBC-HS512':
            if (cek instanceof Uint8Array)
                checkCekLength(cek, parseInt(enc.substr(-3), 10));
            return cbcDecrypt(enc, cek, ciphertext, iv, tag, aad);
        case 'A128GCM':
        case 'A192GCM':
        case 'A256GCM':
            if (cek instanceof Uint8Array)
                checkCekLength(cek, parseInt(enc.substr(1, 3), 10));
            return gcmDecrypt(enc, cek, ciphertext, iv, tag, aad);
        default:
            throw new JOSENotSupported('Unsupported JWE Content Encryption Algorithm');
    }
};
module.exports = decrypt;

},{"../lib/buffer_utils.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/browser/lib/buffer_utils.js","../lib/check_iv_length.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/browser/lib/check_iv_length.js","../lib/crypto_key.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/browser/lib/crypto_key.js","../lib/invalid_key_input.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/browser/lib/invalid_key_input.js","../util/errors.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/browser/util/errors.js","./check_cek_length.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/browser/runtime/check_cek_length.js","./timing_safe_equal.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/browser/runtime/timing_safe_equal.js","./webcrypto.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/browser/runtime/webcrypto.js"}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/browser/runtime/digest.js":[function(require,module,exports){
const crypto = require('./webcrypto.js');
const digest = async (algorithm, data) => {
    const subtleDigest = `SHA-${algorithm.substr(-3)}`;
    return new Uint8Array(await crypto.subtle.digest(subtleDigest, data));
};
module.exports = digest;

},{"./webcrypto.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/browser/runtime/webcrypto.js"}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/browser/runtime/ecdhes.js":[function(require,module,exports){
const { concat, uint32be, lengthAndInput, concatKdf} = require('../lib/buffer_utils.js');
const crypto = require('./webcrypto.js');
const {checkEncCryptoKey} = require('../lib/crypto_key.js');
const digest = require('./digest.js');
const invalidKeyInput = require('../lib/invalid_key_input.js');
 const deriveKey = async (publicKey, privateKey, algorithm, keyLength, apu = new Uint8Array(0), apv = new Uint8Array(0)) => {
    if (!crypto.isCryptoKey(publicKey)) {
        throw new TypeError(invalidKeyInput(publicKey, 'CryptoKey'));
    }
    checkEncCryptoKey(publicKey, 'ECDH-ES');
    if (!crypto.isCryptoKey(privateKey)) {
        throw new TypeError(invalidKeyInput(privateKey, 'CryptoKey'));
    }
    checkEncCryptoKey(privateKey, 'ECDH-ES', 'deriveBits', 'deriveKey');
    const value = concat(lengthAndInput($$.Buffer.from(algorithm)), lengthAndInput(apu), lengthAndInput(apv), uint32be(keyLength));
    if (!privateKey.usages.includes('deriveBits')) {
        throw new TypeError('ECDH-ES private key "usages" must include "deriveBits"');
    }
    const sharedSecret = new Uint8Array(await crypto.subtle.deriveBits({
        name: 'ECDH',
        public: publicKey,
    }, privateKey, Math.ceil(parseInt(privateKey.algorithm.namedCurve.substr(-3), 10) / 8) <<
        3));
    return concatKdf(digest, sharedSecret, keyLength, value);
};
 const generateEpk = async (key) => {
    if (!crypto.isCryptoKey(key)) {
        throw new TypeError(invalidKeyInput(key, 'CryptoKey'));
    }
    return (await crypto.subtle.generateKey({ name: 'ECDH', namedCurve: key.algorithm.namedCurve }, true, ['deriveBits'])).privateKey;
};
 const ecdhAllowed = (key) => {
    if (!crypto.isCryptoKey(key)) {
        throw new TypeError(invalidKeyInput(key, 'CryptoKey'));
    }
    return ['P-256', 'P-384', 'P-521'].includes(key.algorithm.namedCurve);
};

module.exports = {
    deriveKey,
    generateEpk,
    ecdhAllowed
}
},{"../lib/buffer_utils.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/browser/lib/buffer_utils.js","../lib/crypto_key.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/browser/lib/crypto_key.js","../lib/invalid_key_input.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/browser/lib/invalid_key_input.js","./digest.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/browser/runtime/digest.js","./webcrypto.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/browser/runtime/webcrypto.js"}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/browser/runtime/encrypt.js":[function(require,module,exports){
const {concat, uint64be} = require('../lib/buffer_utils.js');
const checkIvLength = require('../lib/check_iv_length.js');
const checkCekLength = require('./check_cek_length.js');
const crypto = require('./webcrypto.js');
const {checkEncCryptoKey} = require('../lib/crypto_key.js');
const invalidKeyInput = require('../lib/invalid_key_input.js');
const {JOSENotSupported} = require('../util/errors.js');

async function cbcEncrypt(enc, plaintext, cek, iv, aad) {
    if (!(cek instanceof Uint8Array)) {
        throw new TypeError(invalidKeyInput(cek, 'Uint8Array'));
    }
    const keySize = parseInt(enc.substr(1, 3), 10);
    const encKey = await crypto.subtle.importKey('raw', cek.subarray(keySize >> 3), 'AES-CBC', false, ['encrypt']);
    const macKey = await crypto.subtle.importKey('raw', cek.subarray(0, keySize >> 3), {
        hash: `SHA-${keySize << 1}`,
        name: 'HMAC',
    }, false, ['sign']);
    const ciphertext = new Uint8Array(await crypto.subtle.encrypt({
        iv,
        name: 'AES-CBC',
    }, encKey, plaintext));
    const macData = concat(aad, iv, ciphertext, uint64be(aad.length << 3));
    const tag = new Uint8Array((await crypto.subtle.sign('HMAC', macKey, macData)).slice(0, keySize >> 3));
    return {ciphertext, tag};
}

async function gcmEncrypt(enc, plaintext, cek, iv, aad) {
    let encKey;
    if (cek instanceof Uint8Array) {
        encKey = await crypto.subtle.importKey('raw', cek, 'AES-GCM', false, ['encrypt']);
    } else {
        checkEncCryptoKey(cek, enc, 'encrypt');
        encKey = cek;
    }
    const encrypted = new Uint8Array(await crypto.subtle.encrypt({
        additionalData: aad,
        iv,
        name: 'AES-GCM',
        tagLength: 128,
    }, encKey, plaintext));
    const tag = encrypted.slice(-16);
    const ciphertext = encrypted.slice(0, -16);
    return {ciphertext, tag};
}

const encrypt = async (enc, plaintext, cek, iv, aad) => {
    if (!crypto.isCryptoKey(cek) && !(cek instanceof Uint8Array)) {
        throw new TypeError(invalidKeyInput(cek, 'CryptoKey', 'Uint8Array'));
    }
    checkIvLength(enc, iv);
    switch (enc) {
        case 'A128CBC-HS256':
        case 'A192CBC-HS384':
        case 'A256CBC-HS512':
            if (cek instanceof Uint8Array)
                checkCekLength(cek, parseInt(enc.substr(-3), 10));
            return cbcEncrypt(enc, plaintext, cek, iv, aad);
        case 'A128GCM':
        case 'A192GCM':
        case 'A256GCM':
            if (cek instanceof Uint8Array)
                checkCekLength(cek, parseInt(enc.substr(1, 3), 10));
            return gcmEncrypt(enc, plaintext, cek, iv, aad);
        default:
            throw new JOSENotSupported('Unsupported JWE Content Encryption Algorithm');
    }
};
module.exports = encrypt;

},{"../lib/buffer_utils.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/browser/lib/buffer_utils.js","../lib/check_iv_length.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/browser/lib/check_iv_length.js","../lib/crypto_key.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/browser/lib/crypto_key.js","../lib/invalid_key_input.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/browser/lib/invalid_key_input.js","../util/errors.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/browser/util/errors.js","./check_cek_length.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/browser/runtime/check_cek_length.js","./webcrypto.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/browser/runtime/webcrypto.js"}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/browser/runtime/fetch_jwks.js":[function(require,module,exports){
const {JOSEError, JWKSTimeout} = require('../util/errors.js');
const globalThis = require('./global.js');
const http = require("opendsu").loadAPI("http");
const fetchJwks = async (url, timeout) => {
    let controller;
    let id;
    let timedOut = false;
    if (typeof AbortController === 'function') {
        controller = new AbortController();
        id = setTimeout(() => {
            timedOut = true;
            controller.abort();
        }, timeout);
    }
    const response = await http
        .fetch(url.href, {
            signal: controller ? controller.signal : undefined,
            redirect: 'manual',
            method: 'GET',
            ...(!globalThis.isCloudflareWorkers()
                ? {
                    referrerPolicy: 'no-referrer',
                    credentials: 'omit',
                    mode: 'cors',
                }
                : undefined),
        })
        .catch((err) => {
            if (timedOut)
                throw new JWKSTimeout();
            throw err;
        });
    if (id !== undefined)
        clearTimeout(id);
    if (response.statusCode !== 200) {
        throw new JOSEError('Expected 200 OK = require( the JSON Web Key Set HTTP response');
    }
    try {
        return await response.json();
    } catch (_a) {
        throw new JOSEError('Failed to parse the JSON Web Key Set HTTP response:JSON');
    }
};
module.exports = fetchJwks;

},{"../util/errors.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/browser/util/errors.js","./global.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/browser/runtime/global.js","opendsu":"opendsu"}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/browser/runtime/generate.js":[function(require,module,exports){
const {isCloudflareWorkers, isNodeJs} = require('./global.js');
const webcrypto = require('./webcrypto.js');
const {JOSENotSupported} = require('../util/errors.js');
const crypto = require("crypto");
async function generateSecret(alg, options) {
    var _a;
    let length;
    let algorithm;
    let keyUsages;
    switch (alg) {
        case 'HS256':
        case 'HS384':
        case 'HS512':
            length = parseInt(alg.substr(-3), 10);
            algorithm = {name: 'HMAC', hash: `SHA-${length}`, length};
            keyUsages = ['sign', 'verify'];
            break;
        case 'A128CBC-HS256':
        case 'A192CBC-HS384':
        case 'A256CBC-HS512':
            length = parseInt(alg.substr(-3), 10);
            return crypto.randomBytes(length >> 3);
        case 'A128KW':
        case 'A192KW':
        case 'A256KW':
            length = parseInt(alg.substring(1, 4), 10);
            algorithm = {name: 'AES-KW', length};
            keyUsages = ['wrapKey', 'unwrapKey'];
            break;
        case 'A128GCMKW':
        case 'A192GCMKW':
        case 'A256GCMKW':
        case 'A128GCM':
        case 'A192GCM':
        case 'A256GCM':
            length = parseInt(alg.substring(1, 4), 10);
            algorithm = {name: 'AES-GCM', length};
            keyUsages = ['encrypt', 'decrypt'];
            break;
        default:
            throw new JOSENotSupported('Invalid or unsupported JWK "alg" (Algorithm) Parameter value');
    }
    return webcrypto.subtle.generateKey(algorithm, (_a = options === null || options === void 0 ? void 0 : options.extractable) !== null && _a !== void 0 ? _a : false, keyUsages);
}

function getModulusLengthOption(options) {
    var _a;
    const modulusLength = (_a = options === null || options === void 0 ? void 0 : options.modulusLength) !== null && _a !== void 0 ? _a : 2048;
    if (typeof modulusLength !== 'number' || modulusLength < 2048) {
        throw new JOSENotSupported('Invalid or unsupported modulusLength option provided, 2048 bits or larger keys must be used');
    }
    return modulusLength;
}

async function generateKeyPair(alg, options) {
    var _a, _b;
    let algorithm;
    let keyUsages;
    switch (alg) {
        case 'PS256':
        case 'PS384':
        case 'PS512':
            algorithm = {
                name: 'RSA-PSS',
                hash: `SHA-${alg.substr(-3)}`,
                publicExponent: new Uint8Array([0x01, 0x00, 0x01]),
                modulusLength: getModulusLengthOption(options),
            };
            keyUsages = ['sign', 'verify'];
            break;
        case 'RS256':
        case 'RS384':
        case 'RS512':
            algorithm = {
                name: 'RSASSA-PKCS1-v1_5',
                hash: `SHA-${alg.substr(-3)}`,
                publicExponent: new Uint8Array([0x01, 0x00, 0x01]),
                modulusLength: getModulusLengthOption(options),
            };
            keyUsages = ['sign', 'verify'];
            break;
        case 'RSA-OAEP':
        case 'RSA-OAEP-256':
        case 'RSA-OAEP-384':
        case 'RSA-OAEP-512':
            algorithm = {
                name: 'RSA-OAEP',
                hash: `SHA-${parseInt(alg.substr(-3), 10) || 1}`,
                publicExponent: new Uint8Array([0x01, 0x00, 0x01]),
                modulusLength: getModulusLengthOption(options),
            };
            keyUsages = ['decrypt', 'unwrapKey', 'encrypt', 'wrapKey'];
            break;
        case 'ES256':
            algorithm = {name: 'ECDSA', namedCurve: 'P-256'};
            keyUsages = ['sign', 'verify'];
            break;
        case 'ES384':
            algorithm = {name: 'ECDSA', namedCurve: 'P-384'};
            keyUsages = ['sign', 'verify'];
            break;
        case 'ES512':
            algorithm = {name: 'ECDSA', namedCurve: 'P-521'};
            keyUsages = ['sign', 'verify'];
            break;
        case (isCloudflareWorkers() || isNodeJs()) && 'EdDSA':
            switch (options === null || options === void 0 ? void 0 : options.crv) {
                case undefined:
                case 'Ed25519':
                    algorithm = {name: 'NODE-ED25519', namedCurve: 'NODE-ED25519'};
                    keyUsages = ['sign', 'verify'];
                    break;
                case isNodeJs() && 'Ed448':
                    algorithm = {name: 'NODE-ED448', namedCurve: 'NODE-ED448'};
                    keyUsages = ['sign', 'verify'];
                    break;
                default:
                    throw new JOSENotSupported('Invalid or unsupported crv option provided, supported values are Ed25519 and Ed448');
            }
            break;
        case 'ECDH-ES':
        case 'ECDH-ES+A128KW':
        case 'ECDH-ES+A192KW':
        case 'ECDH-ES+A256KW':
            algorithm = {
                name: 'ECDH',
                namedCurve: (_a = options === null || options === void 0 ? void 0 : options.crv) !== null && _a !== void 0 ? _a : 'P-256'
            };
            keyUsages = ['deriveKey', 'deriveBits'];
            break;
        default:
            throw new JOSENotSupported('Invalid or unsupported JWK "alg" (Algorithm) Parameter value');
    }
    return (webcrypto.subtle.generateKey(algorithm, (_b = options === null || options === void 0 ? void 0 : options.extractable) !== null && _b !== void 0 ? _b : false, keyUsages));
}

module.exports = {
    generateSecret,
    generateKeyPair
}
},{"../util/errors.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/browser/util/errors.js","./global.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/browser/runtime/global.js","./webcrypto.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/browser/runtime/webcrypto.js","crypto":false}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/browser/runtime/get_sign_verify_key.js":[function(require,module,exports){
const crypto = require('./webcrypto.js');
const {checkSigCryptoKey} = require('../lib/crypto_key.js');
const invalidKeyInput = require('../lib/invalid_key_input.js');
module.exports = function getCryptoKey(alg, key, usage) {
    if (crypto.isCryptoKey(key)) {
        checkSigCryptoKey(key, alg, usage);
        return key;
    }
    if (key instanceof Uint8Array) {
        if (!alg.startsWith('HS')) {
            throw new TypeError(invalidKeyInput(key, 'CryptoKey'));
        }
        return crypto.subtle.importKey('raw', key, {hash: `SHA-${alg.substr(-3)}`, name: 'HMAC'}, false, [usage]);
    }
    throw new TypeError(invalidKeyInput(key, 'CryptoKey', 'Uint8Array'));
}

},{"../lib/crypto_key.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/browser/lib/crypto_key.js","../lib/invalid_key_input.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/browser/lib/invalid_key_input.js","./webcrypto.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/browser/runtime/webcrypto.js"}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/browser/runtime/global.js":[function(require,module,exports){
function getGlobal() {
    if (typeof globalThis !== 'undefined')
        return globalThis;
    if (typeof self !== 'undefined')
        return self;
    if (typeof window !== 'undefined')
        return window;
    throw new Error('unable to locate global object');
}

module.exports = getGlobal();
module.exports.isCloudflareWorkers = function isCloudflareWorkers() {
    try {
        return getGlobal().WebSocketPair !== undefined;
    } catch (_a) {
        return false;
    }
}
module.exports.isNodeJs = function isNodeJs() {
    var _a, _b;
    try {
        return ((_b = (_a = getGlobal().process) === null || _a === void 0 ? void 0 : _a.versions) === null || _b === void 0 ? void 0 : _b.node) !== undefined;
    } catch (_c) {
        return false;
    }
}

},{}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/browser/runtime/is_key_like.js":[function(require,module,exports){
const {isCryptoKey} = require('./webcrypto.js');
module.exports = (key) => {
    return isCryptoKey(key);
};
module.exports.types = ['CryptoKey'];

},{"./webcrypto.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/browser/runtime/webcrypto.js"}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/browser/runtime/jwk_to_key.js":[function(require,module,exports){
const {isCloudflareWorkers, isNodeJs} = require('./global.js');
const crypto = require('./webcrypto.js');
const {JOSENotSupported} = require('../util/errors.js');
const {decode: base64url} = require('./base64url.js');
function subtleMapping(jwk) {
    let algorithm;
    let keyUsages;
    switch (jwk.kty) {
        case 'oct': {
            switch (jwk.alg) {
                case 'HS256':
                case 'HS384':
                case 'HS512':
                    algorithm = { name: 'HMAC', hash: `SHA-${jwk.alg.substr(-3)}` };
                    keyUsages = ['sign', 'verify'];
                    break;
                case 'A128CBC-HS256':
                case 'A192CBC-HS384':
                case 'A256CBC-HS512':
                    throw new JOSENotSupported(`${jwk.alg} keys cannot be imported:CryptoKey instances`);
                case 'A128GCM':
                case 'A192GCM':
                case 'A256GCM':
                case 'A128GCMKW':
                case 'A192GCMKW':
                case 'A256GCMKW':
                    algorithm = { name: 'AES-GCM' };
                    keyUsages = ['encrypt', 'decrypt'];
                    break;
                case 'A128KW':
                case 'A192KW':
                case 'A256KW':
                    algorithm = { name: 'AES-KW' };
                    keyUsages = ['wrapKey', 'unwrapKey'];
                    break;
                case 'PBES2-HS256+A128KW':
                case 'PBES2-HS384+A192KW':
                case 'PBES2-HS512+A256KW':
                    algorithm = { name: 'PBKDF2' };
                    keyUsages = ['deriveBits'];
                    break;
                default:
                    throw new JOSENotSupported('Invalid or unsupported JWK "alg" (Algorithm) Parameter value');
            }
            break;
        }
        case 'RSA': {
            switch (jwk.alg) {
                case 'PS256':
                case 'PS384':
                case 'PS512':
                    algorithm = { name: 'RSA-PSS', hash: `SHA-${jwk.alg.substr(-3)}` };
                    keyUsages = jwk.d ? ['sign'] : ['verify'];
                    break;
                case 'RS256':
                case 'RS384':
                case 'RS512':
                    algorithm = { name: 'RSASSA-PKCS1-v1_5', hash: `SHA-${jwk.alg.substr(-3)}` };
                    keyUsages = jwk.d ? ['sign'] : ['verify'];
                    break;
                case 'RSA-OAEP':
                case 'RSA-OAEP-256':
                case 'RSA-OAEP-384':
                case 'RSA-OAEP-512':
                    algorithm = {
                        name: 'RSA-OAEP',
                        hash: `SHA-${parseInt(jwk.alg.substr(-3), 10) || 1}`,
                    };
                    keyUsages = jwk.d ? ['decrypt', 'unwrapKey'] : ['encrypt', 'wrapKey'];
                    break;
                default:
                    throw new JOSENotSupported('Invalid or unsupported JWK "alg" (Algorithm) Parameter value');
            }
            break;
        }
        case 'EC': {
            switch (jwk.alg) {
                case 'ES256':
                    algorithm = { name: 'ECDSA', namedCurve: 'P-256' };
                    keyUsages = jwk.d ? ['sign'] : ['verify'];
                    break;
                case 'ES384':
                    algorithm = { name: 'ECDSA', namedCurve: 'P-384' };
                    keyUsages = jwk.d ? ['sign'] : ['verify'];
                    break;
                case 'ES512':
                    algorithm = { name: 'ECDSA', namedCurve: 'P-521' };
                    keyUsages = jwk.d ? ['sign'] : ['verify'];
                    break;
                case 'ECDH-ES':
                case 'ECDH-ES+A128KW':
                case 'ECDH-ES+A192KW':
                case 'ECDH-ES+A256KW':
                    algorithm = { name: 'ECDH', namedCurve: jwk.crv };
                    keyUsages = jwk.d ? ['deriveBits'] : [];
                    break;
                default:
                    throw new JOSENotSupported('Invalid or unsupported JWK "alg" (Algorithm) Parameter value');
            }
            break;
        }
        case (isCloudflareWorkers() || isNodeJs()) && 'OKP':
            if (jwk.alg !== 'EdDSA') {
                throw new JOSENotSupported('Invalid or unsupported JWK "alg" (Algorithm) Parameter value');
            }
            switch (jwk.crv) {
                case 'Ed25519':
                    algorithm = { name: 'NODE-ED25519', namedCurve: 'NODE-ED25519' };
                    keyUsages = jwk.d ? ['sign'] : ['verify'];
                    break;
                case isNodeJs() && 'Ed448':
                    algorithm = { name: 'NODE-ED448', namedCurve: 'NODE-ED448' };
                    keyUsages = jwk.d ? ['sign'] : ['verify'];
                    break;
                default:
                    throw new JOSENotSupported('Invalid or unsupported JWK "crv" (Subtype of Key Pair) Parameter value');
            }
            break;
        default:
            throw new JOSENotSupported('Invalid or unsupported JWK "kty" (Key Type) Parameter value');
    }
    return { algorithm, keyUsages };
}
const parse = async (jwk) => {
    var _a, _b;
    const { algorithm, keyUsages } = subtleMapping(jwk);
    const rest = [
        algorithm,
        (_a = jwk.ext) !== null && _a !== void 0 ? _a : false,
        (_b = jwk.key_ops) !== null && _b !== void 0 ? _b : keyUsages,
    ];
    if (algorithm.name === 'PBKDF2') {
        return crypto.subtle.importKey('raw', base64url(jwk.k), ...rest);
    }
    const keyData = { ...jwk };
    delete keyData.alg;
    return crypto.subtle.importKey('jwk', keyData, ...rest);
};
module.exports = parse;

},{"../util/errors.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/browser/util/errors.js","./base64url.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/browser/runtime/base64url.js","./global.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/browser/runtime/global.js","./webcrypto.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/browser/runtime/webcrypto.js"}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/browser/runtime/key_to_jwk.js":[function(require,module,exports){
const crypto = require('./webcrypto.js');
const invalidKeyInput = require('../lib/invalid_key_input.js');
const {encode: base64url} = require('./base64url.js');
const keyToJWK = async (key) => {
    if (key instanceof Uint8Array) {
        return {
            kty: 'oct',
            k: base64url(key),
        };
    }
    if (!crypto.isCryptoKey(key)) {
        throw new TypeError(invalidKeyInput(key, 'CryptoKey', 'Uint8Array'));
    }
    if (!key.extractable) {
        throw new TypeError('non-extractable CryptoKey cannot be exported:a JWK');
    }
    const {...jwk } = await crypto.subtle.exportKey('jwk', key);
    return jwk;
};
module.exports = keyToJWK;

},{"../lib/invalid_key_input.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/browser/lib/invalid_key_input.js","./base64url.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/browser/runtime/base64url.js","./webcrypto.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/browser/runtime/webcrypto.js"}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/browser/runtime/pbes2kw.js":[function(require,module,exports){
const {p2s: concatSalt} = require('../lib/buffer_utils.js');
const {encode: base64url} = require('./base64url.js');
const {wrap, unwrap} = require('./aeskw.js');
const checkP2s = require('../lib/check_p2s.js');
const webcrypto = require('./webcrypto.js');
const crypto = require("crypto");
const {checkEncCryptoKey} = require('../lib/crypto_key.js');
const invalidKeyInput = require('../lib/invalid_key_input.js');

function getCryptoKey(key, alg) {
    if (key instanceof Uint8Array) {
        return webcrypto.subtle.importKey('raw', key, 'PBKDF2', false, ['deriveBits']);
    }
    if (webcrypto.isCryptoKey(key)) {
        checkEncCryptoKey(key, alg, 'deriveBits', 'deriveKey');
        return key;
    }
    throw new TypeError(invalidKeyInput(key, 'CryptoKey', 'Uint8Array'));
}

async function deriveKey(p2s, alg, p2c, key) {
    checkP2s(p2s);
    const salt = concatSalt(alg, p2s);
    const keylen = parseInt(alg.substr(13, 3), 10);
    const subtleAlg = {
        hash: `SHA-${alg.substr(8, 3)}`,
        iterations: p2c,
        name: 'PBKDF2',
        salt,
    };
    const wrapAlg = {
        length: keylen,
        name: 'AES-KW',
    };
    const cryptoKey = await getCryptoKey(key, alg);
    if (cryptoKey.usages.includes('deriveBits')) {
        return new Uint8Array(await webcrypto.subtle.deriveBits(subtleAlg, cryptoKey, keylen));
    }
    if (cryptoKey.usages.includes('deriveKey')) {
        return webcrypto.subtle.deriveKey(subtleAlg, cryptoKey, wrapAlg, false, ['wrapKey', 'unwrapKey']);
    }
    throw new TypeError('PBKDF2 key "usages" must include "deriveBits" or "deriveKey"');
}

const encrypt = async (alg, key, cek, p2c = Math.floor(Math.random() * 2049) + 2048, p2s = crypto.randomBytes(16)) => {
    const derived = await deriveKey(p2s, alg, p2c, key);
    const encryptedKey = await wrap(alg.substr(-6), derived, cek);
    return {encryptedKey, p2c, p2s: base64url(p2s)};
};
const decrypt = async (alg, key, encryptedKey, p2c, p2s) => {
    const derived = await deriveKey(p2s, alg, p2c, key);
    return unwrap(alg.substr(-6), derived, encryptedKey);
};

module.exports = {
    encrypt,
    decrypt
}
},{"../lib/buffer_utils.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/browser/lib/buffer_utils.js","../lib/check_p2s.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/browser/lib/check_p2s.js","../lib/crypto_key.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/browser/lib/crypto_key.js","../lib/invalid_key_input.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/browser/lib/invalid_key_input.js","./aeskw.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/browser/runtime/aeskw.js","./base64url.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/browser/runtime/base64url.js","./webcrypto.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/browser/runtime/webcrypto.js","crypto":false}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/browser/runtime/rsaes.js":[function(require,module,exports){
const subtleAlgorithm = require('./subtle_rsaes.js');
const bogusWebCrypto = require('./bogus.js');
const crypto = require('./webcrypto.js');
const {checkEncCryptoKey} = require('../lib/crypto_key.js');
const checkKeyLength = require('./check_key_length.js');
const invalidKeyInput = require('../lib/invalid_key_input.js');
const encrypt = async (alg, key, cek) => {
    if (!crypto.isCryptoKey(key)) {
        throw new TypeError(invalidKeyInput(key, 'CryptoKey'));
    }
    checkEncCryptoKey(key, alg, 'encrypt', 'wrapKey');
    checkKeyLength(alg, key);
    if (key.usages.includes('encrypt')) {
        return new Uint8Array(await crypto.subtle.encrypt(subtleAlgorithm(alg), key, cek));
    }
    if (key.usages.includes('wrapKey')) {
        const cryptoKeyCek = await crypto.subtle.importKey('raw', cek, ...bogusWebCrypto);
        return new Uint8Array(await crypto.subtle.wrapKey('raw', cryptoKeyCek, key, subtleAlgorithm(alg)));
    }
    throw new TypeError('RSA-OAEP key "usages" must include "encrypt" or "wrapKey" for this operation');
};
const decrypt = async (alg, key, encryptedKey) => {
    if (!crypto.isCryptoKey(key)) {
        throw new TypeError(invalidKeyInput(key, 'CryptoKey'));
    }
    checkEncCryptoKey(key, alg, 'decrypt', 'unwrapKey');
    checkKeyLength(alg, key);
    if (key.usages.includes('decrypt')) {
        return new Uint8Array(await crypto.subtle.decrypt(subtleAlgorithm(alg), key, encryptedKey));
    }
    if (key.usages.includes('unwrapKey')) {
        const cryptoKeyCek = await crypto.subtle.unwrapKey('raw', encryptedKey, key, subtleAlgorithm(alg), ...bogusWebCrypto);
        return new Uint8Array(await crypto.subtle.exportKey('raw', cryptoKeyCek));
    }
    throw new TypeError('RSA-OAEP key "usages" must include "decrypt" or "unwrapKey" for this operation');
};

module.exports = {
    encrypt,
    decrypt
}
},{"../lib/crypto_key.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/browser/lib/crypto_key.js","../lib/invalid_key_input.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/browser/lib/invalid_key_input.js","./bogus.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/browser/runtime/bogus.js","./check_key_length.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/browser/runtime/check_key_length.js","./subtle_rsaes.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/browser/runtime/subtle_rsaes.js","./webcrypto.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/browser/runtime/webcrypto.js"}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/browser/runtime/sign.js":[function(require,module,exports){
const subtleAlgorithm = require('./subtle_dsa.js');
const crypto = require('./webcrypto.js');
const checkKeyLength = require('./check_key_length.js');
const getSignKey = require('./get_sign_verify_key.js');
const sign = async (alg, key, data) => {
    const cryptoKey = await getSignKey(alg, key, 'sign');
    checkKeyLength(alg, cryptoKey);
    const signature = await crypto.subtle.sign(subtleAlgorithm(alg, cryptoKey.algorithm.namedCurve), cryptoKey, data);
    return new Uint8Array(signature);
};
module.exports = sign;

},{"./check_key_length.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/browser/runtime/check_key_length.js","./get_sign_verify_key.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/browser/runtime/get_sign_verify_key.js","./subtle_dsa.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/browser/runtime/subtle_dsa.js","./webcrypto.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/browser/runtime/webcrypto.js"}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/browser/runtime/subtle_dsa.js":[function(require,module,exports){
const {isCloudflareWorkers, isNodeJs} = require('./global.js');
const {JOSENotSupported} = require('../util/errors.js');
module.exports = function subtleDsa(alg, namedCurve) {
    const length = parseInt(alg.substr(-3), 10);
    switch (alg) {
        case 'HS256':
        case 'HS384':
        case 'HS512':
            return { hash: `SHA-${length}`, name: 'HMAC' };
        case 'PS256':
        case 'PS384':
        case 'PS512':
            return { hash: `SHA-${length}`, name: 'RSA-PSS', saltLength: length >> 3 };
        case 'RS256':
        case 'RS384':
        case 'RS512':
            return { hash: `SHA-${length}`, name: 'RSASSA-PKCS1-v1_5' };
        case 'ES256':
        case 'ES384':
        case 'ES512':
            return { hash: `SHA-${length}`, name: 'ECDSA', namedCurve };
        case (isCloudflareWorkers() || isNodeJs()) && 'EdDSA':
            return { name: namedCurve, namedCurve };
        default:
            throw new JOSENotSupported(`alg ${alg} is not supported either by JOSE or your javascript runtime`);
    }
}

},{"../util/errors.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/browser/util/errors.js","./global.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/browser/runtime/global.js"}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/browser/runtime/subtle_rsaes.js":[function(require,module,exports){
const {JOSENotSupported} = require('../util/errors.js');
module.exports = function subtleRsaEs(alg) {
    switch (alg) {
        case 'RSA-OAEP':
        case 'RSA-OAEP-256':
        case 'RSA-OAEP-384':
        case 'RSA-OAEP-512':
            return 'RSA-OAEP';
        default:
            throw new JOSENotSupported(`alg ${alg} is not supported either by JOSE or your javascript runtime`);
    }
}

},{"../util/errors.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/browser/util/errors.js"}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/browser/runtime/timing_safe_equal.js":[function(require,module,exports){
const timingSafeEqual = (a, b) => {
    if (!(a instanceof Uint8Array)) {
        throw new TypeError('First argument must be a buffer');
    }
    if (!(b instanceof Uint8Array)) {
        throw new TypeError('Second argument must be a buffer');
    }
    if (a.length !== b.length) {
        throw new TypeError('Input buffers must have the same length');
    }
    const len = a.length;
    let out = 0;
    let i = -1;
    while (++i < len) {
        out |= a[i] ^ b[i];
    }
    return out === 0;
};
module.exports = timingSafeEqual;

},{}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/browser/runtime/verify.js":[function(require,module,exports){
const subtleAlgorithm = require('./subtle_dsa.js');
const crypto = require('./webcrypto.js');
const checkKeyLength = require('./check_key_length.js');
const getVerifyKey = require('./get_sign_verify_key.js');
const verify = async (alg, key, signature, data) => {
    const cryptoKey = await getVerifyKey(alg, key, 'verify');
    checkKeyLength(alg, cryptoKey);
    const algorithm = subtleAlgorithm(alg, cryptoKey.algorithm.namedCurve);
    try {
        return await crypto.subtle.verify(algorithm, cryptoKey, signature, data);
    }
    catch (_a) {
        return false;
    }
};
module.exports = verify;

},{"./check_key_length.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/browser/runtime/check_key_length.js","./get_sign_verify_key.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/browser/runtime/get_sign_verify_key.js","./subtle_dsa.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/browser/runtime/subtle_dsa.js","./webcrypto.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/browser/runtime/webcrypto.js"}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/browser/runtime/webcrypto.js":[function(require,module,exports){
let globalThis = require('./global.js');
const isNodeJs = globalThis.isNodeJs();
globalThis = isNodeJs ? require("crypto").webcrypto : globalThis;
module.exports = isNodeJs ? globalThis : globalThis.crypto;
module.exports.isCryptoKey = function isCryptoKey(key) {
    if (typeof globalThis.CryptoKey === 'undefined') {
        return false;
    }
    return key != null && key instanceof globalThis.CryptoKey;
}

},{"./global.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/browser/runtime/global.js","crypto":false}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/browser/runtime/zlib.js":[function(require,module,exports){
const {JOSENotSupported} = require('../util/errors.js');
const inflate = async () => {
    throw new JOSENotSupported('JWE "zip" (Compression Algorithm) Header Parameter is not supported by your javascript runtime. You need to use the `inflateRaw` decrypt option to provide Inflate Raw implementation.');
};
const deflate = async () => {
    throw new JOSENotSupported('JWE "zip" (Compression Algorithm) Header Parameter is not supported by your javascript runtime. You need to use the `deflateRaw` encrypt option to provide Deflate Raw implementation.');
};

module.exports = {
    inflate,
    deflate
}
},{"../util/errors.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/browser/util/errors.js"}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/browser/util/base64url.js":[function(require,module,exports){
const base64url = require('../runtime/base64url.js');
const encode = base64url.encode;
const decode = base64url.decode;
module.exports = {
    encode,
    decode
}
},{"../runtime/base64url.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/browser/runtime/base64url.js"}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/browser/util/decode_protected_header.js":[function(require,module,exports){
const {decode: base64url} = require('./base64url.js');
const isObject = require('../lib/is_object.js');
module.exports.decodeProtectedHeader = function decodeProtectedHeader(token) {
    let protectedB64u;
    if (typeof token === 'string') {
        const parts = token.split('.');
        if (parts.length === 3 || parts.length === 5) {
            
            [protectedB64u] = parts;
        }
    } else if (typeof token === 'object' && token) {
        if ('protected' in token) {
            protectedB64u = token.protected;
        } else {
            throw new TypeError('Token does not contain a Protected Header');
        }
    }
    try {
        if (typeof protectedB64u !== 'string' || !protectedB64u) {
            throw new Error();
        }
        const result = JSON.parse(base64url(protectedB64u).toString());
        if (!isObject(result)) {
            throw new Error();
        }
        return result;
    } catch (_a) {
        throw new TypeError('Invalid Token or Protected Header formatting');
    }
}

},{"../lib/is_object.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/browser/lib/is_object.js","./base64url.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/browser/util/base64url.js"}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/browser/util/errors.js":[function(require,module,exports){
 class JOSEError extends Error {
    constructor(message) {
        var _a;
        super(message);
        this.code = 'ERR_JOSE_GENERIC';
        this.name = this.constructor.name;
        (_a = Error.captureStackTrace) === null || _a === void 0 ? void 0 : _a.call(Error, this, this.constructor);
    }

    static get code() {
        return 'ERR_JOSE_GENERIC';
    }
}

 class JWTClaimValidationFailed extends JOSEError {
    constructor(message, claim = 'unspecified', reason = 'unspecified') {
        super(message);
        this.code = 'ERR_JWT_CLAIM_VALIDATION_FAILED';
        this.claim = claim;
        this.reason = reason;
    }

    static get code() {
        return 'ERR_JWT_CLAIM_VALIDATION_FAILED';
    }
}

 class JWTExpired extends JOSEError {
    constructor(message, claim = 'unspecified', reason = 'unspecified') {
        super(message);
        this.code = 'ERR_JWT_EXPIRED';
        this.claim = claim;
        this.reason = reason;
    }

    static get code() {
        return 'ERR_JWT_EXPIRED';
    }
}

 class JOSEAlgNotAllowed extends JOSEError {
    constructor() {
        super(...arguments);
        this.code = 'ERR_JOSE_ALG_NOT_ALLOWED';
    }

    static get code() {
        return 'ERR_JOSE_ALG_NOT_ALLOWED';
    }
}

 class JOSENotSupported extends JOSEError {
    constructor() {
        super(...arguments);
        this.code = 'ERR_JOSE_NOT_SUPPORTED';
    }

    static get code() {
        return 'ERR_JOSE_NOT_SUPPORTED';
    }
}

 class JWEDecryptionFailed extends JOSEError {
    constructor() {
        super(...arguments);
        this.code = 'ERR_JWE_DECRYPTION_FAILED';
        this.message = 'decryption operation failed';
    }

    static get code() {
        return 'ERR_JWE_DECRYPTION_FAILED';
    }
}

 class JWEInvalid extends JOSEError {
    constructor() {
        super(...arguments);
        this.code = 'ERR_JWE_INVALID';
    }

    static get code() {
        return 'ERR_JWE_INVALID';
    }
}

 class JWSInvalid extends JOSEError {
    constructor() {
        super(...arguments);
        this.code = 'ERR_JWS_INVALID';
    }

    static get code() {
        return 'ERR_JWS_INVALID';
    }
}

 class JWTInvalid extends JOSEError {
    constructor() {
        super(...arguments);
        this.code = 'ERR_JWT_INVALID';
    }

    static get code() {
        return 'ERR_JWT_INVALID';
    }
}

 class JWKInvalid extends JOSEError {
    constructor() {
        super(...arguments);
        this.code = 'ERR_JWK_INVALID';
    }

    static get code() {
        return 'ERR_JWK_INVALID';
    }
}

 class JWKSInvalid extends JOSEError {
    constructor() {
        super(...arguments);
        this.code = 'ERR_JWKS_INVALID';
    }

    static get code() {
        return 'ERR_JWKS_INVALID';
    }
}

 class JWKSNoMatchingKey extends JOSEError {
    constructor() {
        super(...arguments);
        this.code = 'ERR_JWKS_NO_MATCHING_KEY';
        this.message = 'no applicable key found in the JSON Web Key Set';
    }

    static get code() {
        return 'ERR_JWKS_NO_MATCHING_KEY';
    }
}

 class JWKSMultipleMatchingKeys extends JOSEError {
    constructor() {
        super(...arguments);
        this.code = 'ERR_JWKS_MULTIPLE_MATCHING_KEYS';
        this.message = 'multiple matching keys found in the JSON Web Key Set';
    }

    static get code() {
        return 'ERR_JWKS_MULTIPLE_MATCHING_KEYS';
    }
}

 class JWKSTimeout extends JOSEError {
    constructor() {
        super(...arguments);
        this.code = 'ERR_JWKS_TIMEOUT';
        this.message = 'request timed out';
    }

    static get code() {
        return 'ERR_JWKS_TIMEOUT';
    }
}

 class JWSSignatureVerificationFailed extends JOSEError {
    constructor() {
        super(...arguments);
        this.code = 'ERR_JWS_SIGNATURE_VERIFICATION_FAILED';
        this.message = 'signature verification failed';
    }

    static get code() {
        return 'ERR_JWS_SIGNATURE_VERIFICATION_FAILED';
    }
}

module.exports = {
    JOSEError,
    JWTClaimValidationFailed,
    JWTExpired,
    JOSEAlgNotAllowed,
    JOSENotSupported,
    JWEDecryptionFailed,
    JWEInvalid,
    JWSInvalid,
    JWTInvalid,
    JWKInvalid,
    JWKSInvalid,
    JWKSNoMatchingKey,
    JWKSMultipleMatchingKeys,
    JWKSTimeout,
    JWSSignatureVerificationFailed
}
},{}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/index.js":[function(require,module,exports){
if ($$.environmentType === "browser") {
    module.exports = require("./browser");
} else {
    module.exports = require("./node");
}
},{"./browser":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/browser/index.js","./node":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/node/index.js"}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/node/index.js":[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.base64url = exports.generateSecret = exports.generateKeyPair = exports.errors = exports.decodeProtectedHeader = exports.importJWK = exports.importX509 = exports.importPKCS8 = exports.importSPKI = exports.exportJWK = exports.exportSPKI = exports.exportPKCS8 = exports.UnsecuredJWT = exports.createRemoteJWKSet = exports.EmbeddedJWK = exports.calculateJwkThumbprint = exports.EncryptJWT = exports.SignJWT = exports.GeneralSign = exports.FlattenedSign = exports.CompactSign = exports.FlattenedEncrypt = exports.CompactEncrypt = exports.jwtDecrypt = exports.jwtVerify = exports.generalVerify = exports.flattenedVerify = exports.compactVerify = exports.generalDecrypt = exports.flattenedDecrypt = exports.compactDecrypt = void 0;
var decrypt_js_1 = require("./jwe/compact/decrypt.js");
Object.defineProperty(exports, "compactDecrypt", { enumerable: true, get: function () { return decrypt_js_1.compactDecrypt; } });
var decrypt_js_2 = require("./jwe/flattened/decrypt.js");
Object.defineProperty(exports, "flattenedDecrypt", { enumerable: true, get: function () { return decrypt_js_2.flattenedDecrypt; } });
var decrypt_js_3 = require("./jwe/general/decrypt.js");
Object.defineProperty(exports, "generalDecrypt", { enumerable: true, get: function () { return decrypt_js_3.generalDecrypt; } });
var verify_js_1 = require("./jws/compact/verify.js");
Object.defineProperty(exports, "compactVerify", { enumerable: true, get: function () { return verify_js_1.compactVerify; } });
var verify_js_2 = require("./jws/flattened/verify.js");
Object.defineProperty(exports, "flattenedVerify", { enumerable: true, get: function () { return verify_js_2.flattenedVerify; } });
var verify_js_3 = require("./jws/general/verify.js");
Object.defineProperty(exports, "generalVerify", { enumerable: true, get: function () { return verify_js_3.generalVerify; } });
var verify_js_4 = require("./jwt/verify.js");
Object.defineProperty(exports, "jwtVerify", { enumerable: true, get: function () { return verify_js_4.jwtVerify; } });
var decrypt_js_4 = require("./jwt/decrypt.js");
Object.defineProperty(exports, "jwtDecrypt", { enumerable: true, get: function () { return decrypt_js_4.jwtDecrypt; } });
var encrypt_js_1 = require("./jwe/compact/encrypt.js");
Object.defineProperty(exports, "CompactEncrypt", { enumerable: true, get: function () { return encrypt_js_1.CompactEncrypt; } });
var encrypt_js_2 = require("./jwe/flattened/encrypt.js");
Object.defineProperty(exports, "FlattenedEncrypt", { enumerable: true, get: function () { return encrypt_js_2.FlattenedEncrypt; } });
var sign_js_1 = require("./jws/compact/sign.js");
Object.defineProperty(exports, "CompactSign", { enumerable: true, get: function () { return sign_js_1.CompactSign; } });
var sign_js_2 = require("./jws/flattened/sign.js");
Object.defineProperty(exports, "FlattenedSign", { enumerable: true, get: function () { return sign_js_2.FlattenedSign; } });
var sign_js_3 = require("./jws/general/sign.js");
Object.defineProperty(exports, "GeneralSign", { enumerable: true, get: function () { return sign_js_3.GeneralSign; } });
var sign_js_4 = require("./jwt/sign.js");
Object.defineProperty(exports, "SignJWT", { enumerable: true, get: function () { return sign_js_4.SignJWT; } });
var encrypt_js_3 = require("./jwt/encrypt.js");
Object.defineProperty(exports, "EncryptJWT", { enumerable: true, get: function () { return encrypt_js_3.EncryptJWT; } });
var thumbprint_js_1 = require("./jwk/thumbprint.js");
Object.defineProperty(exports, "calculateJwkThumbprint", { enumerable: true, get: function () { return thumbprint_js_1.calculateJwkThumbprint; } });
var embedded_js_1 = require("./jwk/embedded.js");
Object.defineProperty(exports, "EmbeddedJWK", { enumerable: true, get: function () { return embedded_js_1.EmbeddedJWK; } });
var remote_js_1 = require("./jwks/remote.js");
Object.defineProperty(exports, "createRemoteJWKSet", { enumerable: true, get: function () { return remote_js_1.createRemoteJWKSet; } });
var unsecured_js_1 = require("./jwt/unsecured.js");
Object.defineProperty(exports, "UnsecuredJWT", { enumerable: true, get: function () { return unsecured_js_1.UnsecuredJWT; } });
var export_js_1 = require("./key/export.js");
Object.defineProperty(exports, "exportPKCS8", { enumerable: true, get: function () { return export_js_1.exportPKCS8; } });
Object.defineProperty(exports, "exportSPKI", { enumerable: true, get: function () { return export_js_1.exportSPKI; } });
Object.defineProperty(exports, "exportJWK", { enumerable: true, get: function () { return export_js_1.exportJWK; } });
var import_js_1 = require("./key/import.js");
Object.defineProperty(exports, "importSPKI", { enumerable: true, get: function () { return import_js_1.importSPKI; } });
Object.defineProperty(exports, "importPKCS8", { enumerable: true, get: function () { return import_js_1.importPKCS8; } });
Object.defineProperty(exports, "importX509", { enumerable: true, get: function () { return import_js_1.importX509; } });
Object.defineProperty(exports, "importJWK", { enumerable: true, get: function () { return import_js_1.importJWK; } });
var decode_protected_header_js_1 = require("./util/decode_protected_header.js");
Object.defineProperty(exports, "decodeProtectedHeader", { enumerable: true, get: function () { return decode_protected_header_js_1.decodeProtectedHeader; } });
exports.errors = require("./util/errors.js");
var generate_key_pair_js_1 = require("./key/generate_key_pair.js");
Object.defineProperty(exports, "generateKeyPair", { enumerable: true, get: function () { return generate_key_pair_js_1.generateKeyPair; } });
var generate_secret_js_1 = require("./key/generate_secret.js");
Object.defineProperty(exports, "generateSecret", { enumerable: true, get: function () { return generate_secret_js_1.generateSecret; } });
exports.base64url = require("./util/base64url.js");

},{"./jwe/compact/decrypt.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/node/jwe/compact/decrypt.js","./jwe/compact/encrypt.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/node/jwe/compact/encrypt.js","./jwe/flattened/decrypt.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/node/jwe/flattened/decrypt.js","./jwe/flattened/encrypt.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/node/jwe/flattened/encrypt.js","./jwe/general/decrypt.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/node/jwe/general/decrypt.js","./jwk/embedded.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/node/jwk/embedded.js","./jwk/thumbprint.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/node/jwk/thumbprint.js","./jwks/remote.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/node/jwks/remote.js","./jws/compact/sign.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/node/jws/compact/sign.js","./jws/compact/verify.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/node/jws/compact/verify.js","./jws/flattened/sign.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/node/jws/flattened/sign.js","./jws/flattened/verify.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/node/jws/flattened/verify.js","./jws/general/sign.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/node/jws/general/sign.js","./jws/general/verify.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/node/jws/general/verify.js","./jwt/decrypt.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/node/jwt/decrypt.js","./jwt/encrypt.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/node/jwt/encrypt.js","./jwt/sign.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/node/jwt/sign.js","./jwt/unsecured.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/node/jwt/unsecured.js","./jwt/verify.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/node/jwt/verify.js","./key/export.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/node/key/export.js","./key/generate_key_pair.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/node/key/generate_key_pair.js","./key/generate_secret.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/node/key/generate_secret.js","./key/import.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/node/key/import.js","./util/base64url.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/node/util/base64url.js","./util/decode_protected_header.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/node/util/decode_protected_header.js","./util/errors.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/node/util/errors.js"}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/node/jwe/compact/decrypt.js":[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.compactDecrypt = void 0;
const decrypt_js_1 = require("../flattened/decrypt.js");
const errors_js_1 = require("../../util/errors.js");
const buffer_utils_js_1 = require("../../lib/buffer_utils.js");
async function compactDecrypt(jwe, key, options) {
    if (jwe instanceof Uint8Array) {
        jwe = buffer_utils_js_1.decoder.decode(jwe);
    }
    if (typeof jwe !== 'string') {
        throw new errors_js_1.JWEInvalid('Compact JWE must be a string or Uint8Array');
    }
    const { 0: protectedHeader, 1: encryptedKey, 2: iv, 3: ciphertext, 4: tag, length, } = jwe.split('.');
    if (length !== 5) {
        throw new errors_js_1.JWEInvalid('Invalid Compact JWE');
    }
    const decrypted = await (0, decrypt_js_1.flattenedDecrypt)({
        ciphertext: (ciphertext || undefined),
        iv: (iv || undefined),
        protected: protectedHeader || undefined,
        tag: (tag || undefined),
        encrypted_key: encryptedKey || undefined,
    }, key, options);
    const result = { plaintext: decrypted.plaintext, protectedHeader: decrypted.protectedHeader };
    if (typeof key === 'function') {
        return { ...result, key: decrypted.key };
    }
    return result;
}
exports.compactDecrypt = compactDecrypt;

},{"../../lib/buffer_utils.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/node/lib/buffer_utils.js","../../util/errors.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/node/util/errors.js","../flattened/decrypt.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/node/jwe/flattened/decrypt.js"}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/node/jwe/compact/encrypt.js":[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.CompactEncrypt = void 0;
const encrypt_js_1 = require("../flattened/encrypt.js");
class CompactEncrypt {
    constructor(plaintext) {
        this._flattened = new encrypt_js_1.FlattenedEncrypt(plaintext);
    }
    setContentEncryptionKey(cek) {
        this._flattened.setContentEncryptionKey(cek);
        return this;
    }
    setInitializationVector(iv) {
        this._flattened.setInitializationVector(iv);
        return this;
    }
    setProtectedHeader(protectedHeader) {
        this._flattened.setProtectedHeader(protectedHeader);
        return this;
    }
    setKeyManagementParameters(parameters) {
        this._flattened.setKeyManagementParameters(parameters);
        return this;
    }
    async encrypt(key, options) {
        const jwe = await this._flattened.encrypt(key, options);
        return [jwe.protected, jwe.encrypted_key, jwe.iv, jwe.ciphertext, jwe.tag].join('.');
    }
}
exports.CompactEncrypt = CompactEncrypt;

},{"../flattened/encrypt.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/node/jwe/flattened/encrypt.js"}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/node/jwe/flattened/decrypt.js":[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.flattenedDecrypt = void 0;
const base64url_js_1 = require("../../runtime/base64url.js");
const decrypt_js_1 = require("../../runtime/decrypt.js");
const zlib_js_1 = require("../../runtime/zlib.js");
const errors_js_1 = require("../../util/errors.js");
const is_disjoint_js_1 = require("../../lib/is_disjoint.js");
const is_object_js_1 = require("../../lib/is_object.js");
const decrypt_key_management_js_1 = require("../../lib/decrypt_key_management.js");
const buffer_utils_js_1 = require("../../lib/buffer_utils.js");
const cek_js_1 = require("../../lib/cek.js");
const validate_crit_js_1 = require("../../lib/validate_crit.js");
const validate_algorithms_js_1 = require("../../lib/validate_algorithms.js");
async function flattenedDecrypt(jwe, key, options) {
    var _a;
    if (!(0, is_object_js_1.default)(jwe)) {
        throw new errors_js_1.JWEInvalid('Flattened JWE must be an object');
    }
    if (jwe.protected === undefined && jwe.header === undefined && jwe.unprotected === undefined) {
        throw new errors_js_1.JWEInvalid('JOSE Header missing');
    }
    if (typeof jwe.iv !== 'string') {
        throw new errors_js_1.JWEInvalid('JWE Initialization Vector missing or incorrect type');
    }
    if (typeof jwe.ciphertext !== 'string') {
        throw new errors_js_1.JWEInvalid('JWE Ciphertext missing or incorrect type');
    }
    if (typeof jwe.tag !== 'string') {
        throw new errors_js_1.JWEInvalid('JWE Authentication Tag missing or incorrect type');
    }
    if (jwe.protected !== undefined && typeof jwe.protected !== 'string') {
        throw new errors_js_1.JWEInvalid('JWE Protected Header incorrect type');
    }
    if (jwe.encrypted_key !== undefined && typeof jwe.encrypted_key !== 'string') {
        throw new errors_js_1.JWEInvalid('JWE Encrypted Key incorrect type');
    }
    if (jwe.aad !== undefined && typeof jwe.aad !== 'string') {
        throw new errors_js_1.JWEInvalid('JWE AAD incorrect type');
    }
    if (jwe.header !== undefined && !(0, is_object_js_1.default)(jwe.header)) {
        throw new errors_js_1.JWEInvalid('JWE Shared Unprotected Header incorrect type');
    }
    if (jwe.unprotected !== undefined && !(0, is_object_js_1.default)(jwe.unprotected)) {
        throw new errors_js_1.JWEInvalid('JWE Per-Recipient Unprotected Header incorrect type');
    }
    let parsedProt;
    if (jwe.protected) {
        const protectedHeader = (0, base64url_js_1.decode)(jwe.protected);
        try {
            parsedProt = JSON.parse(buffer_utils_js_1.decoder.decode(protectedHeader));
        }
        catch {
            throw new errors_js_1.JWEInvalid('JWE Protected Header is invalid');
        }
    }
    if (!(0, is_disjoint_js_1.default)(parsedProt, jwe.header, jwe.unprotected)) {
        throw new errors_js_1.JWEInvalid('JWE Protected, JWE Unprotected Header, and JWE Per-Recipient Unprotected Header Parameter names must be disjoint');
    }
    const joseHeader = {
        ...parsedProt,
        ...jwe.header,
        ...jwe.unprotected,
    };
    (0, validate_crit_js_1.default)(errors_js_1.JWEInvalid, new Map(), options === null || options === void 0 ? void 0 : options.crit, parsedProt, joseHeader);
    if (joseHeader.zip !== undefined) {
        if (!parsedProt || !parsedProt.zip) {
            throw new errors_js_1.JWEInvalid('JWE "zip" (Compression Algorithm) Header MUST be integrity protected');
        }
        if (joseHeader.zip !== 'DEF') {
            throw new errors_js_1.JOSENotSupported('Unsupported JWE "zip" (Compression Algorithm) Header Parameter value');
        }
    }
    const { alg, enc } = joseHeader;
    if (typeof alg !== 'string' || !alg) {
        throw new errors_js_1.JWEInvalid('missing JWE Algorithm (alg) in JWE Header');
    }
    if (typeof enc !== 'string' || !enc) {
        throw new errors_js_1.JWEInvalid('missing JWE Encryption Algorithm (enc) in JWE Header');
    }
    const keyManagementAlgorithms = options && (0, validate_algorithms_js_1.default)('keyManagementAlgorithms', options.keyManagementAlgorithms);
    const contentEncryptionAlgorithms = options &&
        (0, validate_algorithms_js_1.default)('contentEncryptionAlgorithms', options.contentEncryptionAlgorithms);
    if (keyManagementAlgorithms && !keyManagementAlgorithms.has(alg)) {
        throw new errors_js_1.JOSEAlgNotAllowed('"alg" (Algorithm) Header Parameter not allowed');
    }
    if (contentEncryptionAlgorithms && !contentEncryptionAlgorithms.has(enc)) {
        throw new errors_js_1.JOSEAlgNotAllowed('"enc" (Encryption Algorithm) Header Parameter not allowed');
    }
    let encryptedKey;
    if (jwe.encrypted_key !== undefined) {
        encryptedKey = (0, base64url_js_1.decode)(jwe.encrypted_key);
    }
    let resolvedKey = false;
    if (typeof key === 'function') {
        key = await key(parsedProt, jwe);
        resolvedKey = true;
    }
    let cek;
    try {
        cek = await (0, decrypt_key_management_js_1.default)(alg, key, encryptedKey, joseHeader);
    }
    catch (err) {
        if (err instanceof TypeError) {
            throw err;
        }
        cek = (0, cek_js_1.default)(enc);
    }
    const iv = (0, base64url_js_1.decode)(jwe.iv);
    const tag = (0, base64url_js_1.decode)(jwe.tag);
    const protectedHeader = buffer_utils_js_1.encoder.encode((_a = jwe.protected) !== null && _a !== void 0 ? _a : '');
    let additionalData;
    if (jwe.aad !== undefined) {
        additionalData = (0, buffer_utils_js_1.concat)(protectedHeader, buffer_utils_js_1.encoder.encode('.'), buffer_utils_js_1.encoder.encode(jwe.aad));
    }
    else {
        additionalData = protectedHeader;
    }
    let plaintext = await (0, decrypt_js_1.default)(enc, cek, (0, base64url_js_1.decode)(jwe.ciphertext), iv, tag, additionalData);
    if (joseHeader.zip === 'DEF') {
        plaintext = await ((options === null || options === void 0 ? void 0 : options.inflateRaw) || zlib_js_1.inflate)(plaintext);
    }
    const result = { plaintext };
    if (jwe.protected !== undefined) {
        result.protectedHeader = parsedProt;
    }
    if (jwe.aad !== undefined) {
        result.additionalAuthenticatedData = (0, base64url_js_1.decode)(jwe.aad);
    }
    if (jwe.unprotected !== undefined) {
        result.sharedUnprotectedHeader = jwe.unprotected;
    }
    if (jwe.header !== undefined) {
        result.unprotectedHeader = jwe.header;
    }
    if (resolvedKey) {
        return { ...result, key };
    }
    return result;
}
exports.flattenedDecrypt = flattenedDecrypt;

},{"../../lib/buffer_utils.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/node/lib/buffer_utils.js","../../lib/cek.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/node/lib/cek.js","../../lib/decrypt_key_management.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/node/lib/decrypt_key_management.js","../../lib/is_disjoint.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/node/lib/is_disjoint.js","../../lib/is_object.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/node/lib/is_object.js","../../lib/validate_algorithms.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/node/lib/validate_algorithms.js","../../lib/validate_crit.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/node/lib/validate_crit.js","../../runtime/base64url.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/node/runtime/base64url.js","../../runtime/decrypt.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/node/runtime/decrypt.js","../../runtime/zlib.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/node/runtime/zlib.js","../../util/errors.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/node/util/errors.js"}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/node/jwe/flattened/encrypt.js":[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.FlattenedEncrypt = void 0;
const base64url_js_1 = require("../../runtime/base64url.js");
const encrypt_js_1 = require("../../runtime/encrypt.js");
const zlib_js_1 = require("../../runtime/zlib.js");
const iv_js_1 = require("../../lib/iv.js");
const encrypt_key_management_js_1 = require("../../lib/encrypt_key_management.js");
const errors_js_1 = require("../../util/errors.js");
const is_disjoint_js_1 = require("../../lib/is_disjoint.js");
const buffer_utils_js_1 = require("../../lib/buffer_utils.js");
const validate_crit_js_1 = require("../../lib/validate_crit.js");
class FlattenedEncrypt {
    constructor(plaintext) {
        if (!(plaintext instanceof Uint8Array)) {
            throw new TypeError('plaintext must be an instance of Uint8Array');
        }
        this._plaintext = plaintext;
    }
    setKeyManagementParameters(parameters) {
        if (this._keyManagementParameters) {
            throw new TypeError('setKeyManagementParameters can only be called once');
        }
        this._keyManagementParameters = parameters;
        return this;
    }
    setProtectedHeader(protectedHeader) {
        if (this._protectedHeader) {
            throw new TypeError('setProtectedHeader can only be called once');
        }
        this._protectedHeader = protectedHeader;
        return this;
    }
    setSharedUnprotectedHeader(sharedUnprotectedHeader) {
        if (this._sharedUnprotectedHeader) {
            throw new TypeError('setSharedUnprotectedHeader can only be called once');
        }
        this._sharedUnprotectedHeader = sharedUnprotectedHeader;
        return this;
    }
    setUnprotectedHeader(unprotectedHeader) {
        if (this._unprotectedHeader) {
            throw new TypeError('setUnprotectedHeader can only be called once');
        }
        this._unprotectedHeader = unprotectedHeader;
        return this;
    }
    setAdditionalAuthenticatedData(aad) {
        this._aad = aad;
        return this;
    }
    setContentEncryptionKey(cek) {
        if (this._cek) {
            throw new TypeError('setContentEncryptionKey can only be called once');
        }
        this._cek = cek;
        return this;
    }
    setInitializationVector(iv) {
        if (this._iv) {
            throw new TypeError('setInitializationVector can only be called once');
        }
        this._iv = iv;
        return this;
    }
    async encrypt(key, options) {
        if (!this._protectedHeader && !this._unprotectedHeader && !this._sharedUnprotectedHeader) {
            throw new errors_js_1.JWEInvalid('either setProtectedHeader, setUnprotectedHeader, or sharedUnprotectedHeader must be called before #encrypt()');
        }
        if (!(0, is_disjoint_js_1.default)(this._protectedHeader, this._unprotectedHeader, this._sharedUnprotectedHeader)) {
            throw new errors_js_1.JWEInvalid('JWE Shared Protected, JWE Shared Unprotected and JWE Per-Recipient Header Parameter names must be disjoint');
        }
        const joseHeader = {
            ...this._protectedHeader,
            ...this._unprotectedHeader,
            ...this._sharedUnprotectedHeader,
        };
        (0, validate_crit_js_1.default)(errors_js_1.JWEInvalid, new Map(), options === null || options === void 0 ? void 0 : options.crit, this._protectedHeader, joseHeader);
        if (joseHeader.zip !== undefined) {
            if (!this._protectedHeader || !this._protectedHeader.zip) {
                throw new errors_js_1.JWEInvalid('JWE "zip" (Compression Algorithm) Header MUST be integrity protected');
            }
            if (joseHeader.zip !== 'DEF') {
                throw new errors_js_1.JOSENotSupported('Unsupported JWE "zip" (Compression Algorithm) Header Parameter value');
            }
        }
        const { alg, enc } = joseHeader;
        if (typeof alg !== 'string' || !alg) {
            throw new errors_js_1.JWEInvalid('JWE "alg" (Algorithm) Header Parameter missing or invalid');
        }
        if (typeof enc !== 'string' || !enc) {
            throw new errors_js_1.JWEInvalid('JWE "enc" (Encryption Algorithm) Header Parameter missing or invalid');
        }
        let encryptedKey;
        if (alg === 'dir') {
            if (this._cek) {
                throw new TypeError('setContentEncryptionKey cannot be called when using Direct Encryption');
            }
        }
        else if (alg === 'ECDH-ES') {
            if (this._cek) {
                throw new TypeError('setContentEncryptionKey cannot be called when using Direct Key Agreement');
            }
        }
        let cek;
        {
            let parameters;
            ({ cek, encryptedKey, parameters } = await (0, encrypt_key_management_js_1.default)(alg, enc, key, this._cek, this._keyManagementParameters));
            if (parameters) {
                if (!this._protectedHeader) {
                    this.setProtectedHeader(parameters);
                }
                else {
                    this._protectedHeader = { ...this._protectedHeader, ...parameters };
                }
            }
        }
        this._iv || (this._iv = (0, iv_js_1.default)(enc));
        let additionalData;
        let protectedHeader;
        let aadMember;
        if (this._protectedHeader) {
            protectedHeader = buffer_utils_js_1.encoder.encode((0, base64url_js_1.encode)(JSON.stringify(this._protectedHeader)));
        }
        else {
            protectedHeader = buffer_utils_js_1.encoder.encode('');
        }
        if (this._aad) {
            aadMember = (0, base64url_js_1.encode)(this._aad);
            additionalData = (0, buffer_utils_js_1.concat)(protectedHeader, buffer_utils_js_1.encoder.encode('.'), buffer_utils_js_1.encoder.encode(aadMember));
        }
        else {
            additionalData = protectedHeader;
        }
        let ciphertext;
        let tag;
        if (joseHeader.zip === 'DEF') {
            const deflated = await ((options === null || options === void 0 ? void 0 : options.deflateRaw) || zlib_js_1.deflate)(this._plaintext);
            ({ ciphertext, tag } = await (0, encrypt_js_1.default)(enc, deflated, cek, this._iv, additionalData));
        }
        else {
            
            ({ ciphertext, tag } = await (0, encrypt_js_1.default)(enc, this._plaintext, cek, this._iv, additionalData));
        }
        const jwe = {
            ciphertext: (0, base64url_js_1.encode)(ciphertext),
            iv: (0, base64url_js_1.encode)(this._iv),
            tag: (0, base64url_js_1.encode)(tag),
        };
        if (encryptedKey) {
            jwe.encrypted_key = (0, base64url_js_1.encode)(encryptedKey);
        }
        if (aadMember) {
            jwe.aad = aadMember;
        }
        if (this._protectedHeader) {
            jwe.protected = buffer_utils_js_1.decoder.decode(protectedHeader);
        }
        if (this._sharedUnprotectedHeader) {
            jwe.unprotected = this._sharedUnprotectedHeader;
        }
        if (this._unprotectedHeader) {
            jwe.header = this._unprotectedHeader;
        }
        return jwe;
    }
}
exports.FlattenedEncrypt = FlattenedEncrypt;

},{"../../lib/buffer_utils.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/node/lib/buffer_utils.js","../../lib/encrypt_key_management.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/node/lib/encrypt_key_management.js","../../lib/is_disjoint.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/node/lib/is_disjoint.js","../../lib/iv.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/node/lib/iv.js","../../lib/validate_crit.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/node/lib/validate_crit.js","../../runtime/base64url.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/node/runtime/base64url.js","../../runtime/encrypt.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/node/runtime/encrypt.js","../../runtime/zlib.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/node/runtime/zlib.js","../../util/errors.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/node/util/errors.js"}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/node/jwe/general/decrypt.js":[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.generalDecrypt = void 0;
const decrypt_js_1 = require("../flattened/decrypt.js");
const errors_js_1 = require("../../util/errors.js");
const is_object_js_1 = require("../../lib/is_object.js");
async function generalDecrypt(jwe, key, options) {
    if (!(0, is_object_js_1.default)(jwe)) {
        throw new errors_js_1.JWEInvalid('General JWE must be an object');
    }
    if (!Array.isArray(jwe.recipients) || !jwe.recipients.every(is_object_js_1.default)) {
        throw new errors_js_1.JWEInvalid('JWE Recipients missing or incorrect type');
    }
    for (const recipient of jwe.recipients) {
        try {
            return await (0, decrypt_js_1.flattenedDecrypt)({
                aad: jwe.aad,
                ciphertext: jwe.ciphertext,
                encrypted_key: recipient.encrypted_key,
                header: recipient.header,
                iv: jwe.iv,
                protected: jwe.protected,
                tag: jwe.tag,
                unprotected: jwe.unprotected,
            }, key, options);
        }
        catch {
        }
    }
    throw new errors_js_1.JWEDecryptionFailed();
}
exports.generalDecrypt = generalDecrypt;

},{"../../lib/is_object.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/node/lib/is_object.js","../../util/errors.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/node/util/errors.js","../flattened/decrypt.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/node/jwe/flattened/decrypt.js"}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/node/jwk/embedded.js":[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.EmbeddedJWK = void 0;
const import_js_1 = require("../key/import.js");
const is_object_js_1 = require("../lib/is_object.js");
const errors_js_1 = require("../util/errors.js");
async function EmbeddedJWK(protectedHeader, token) {
    const joseHeader = {
        ...protectedHeader,
        ...token.header,
    };
    if (!(0, is_object_js_1.default)(joseHeader.jwk)) {
        throw new errors_js_1.JWSInvalid('"jwk" (JSON Web Key) Header Parameter must be a JSON object');
    }
    const key = await (0, import_js_1.importJWK)({ ...joseHeader.jwk, ext: true }, joseHeader.alg, true);
    if (key instanceof Uint8Array || key.type !== 'public') {
        throw new errors_js_1.JWSInvalid('"jwk" (JSON Web Key) Header Parameter must be a public key');
    }
    return key;
}
exports.EmbeddedJWK = EmbeddedJWK;

},{"../key/import.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/node/key/import.js","../lib/is_object.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/node/lib/is_object.js","../util/errors.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/node/util/errors.js"}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/node/jwk/thumbprint.js":[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.calculateJwkThumbprint = void 0;
const digest_js_1 = require("../runtime/digest.js");
const base64url_js_1 = require("../runtime/base64url.js");
const errors_js_1 = require("../util/errors.js");
const buffer_utils_js_1 = require("../lib/buffer_utils.js");
const is_object_js_1 = require("../lib/is_object.js");
const check = (value, description) => {
    if (typeof value !== 'string' || !value) {
        throw new errors_js_1.JWKInvalid(`${description} missing or invalid`);
    }
};
async function calculateJwkThumbprint(jwk, digestAlgorithm = 'sha256') {
    if (!(0, is_object_js_1.default)(jwk)) {
        throw new TypeError('JWK must be an object');
    }
    let components;
    switch (jwk.kty) {
        case 'EC':
            check(jwk.crv, '"crv" (Curve) Parameter');
            check(jwk.x, '"x" (X Coordinate) Parameter');
            check(jwk.y, '"y" (Y Coordinate) Parameter');
            components = { crv: jwk.crv, kty: jwk.kty, x: jwk.x, y: jwk.y };
            break;
        case 'OKP':
            check(jwk.crv, '"crv" (Subtype of Key Pair) Parameter');
            check(jwk.x, '"x" (Public Key) Parameter');
            components = { crv: jwk.crv, kty: jwk.kty, x: jwk.x };
            break;
        case 'RSA':
            check(jwk.e, '"e" (Exponent) Parameter');
            check(jwk.n, '"n" (Modulus) Parameter');
            components = { e: jwk.e, kty: jwk.kty, n: jwk.n };
            break;
        case 'oct':
            check(jwk.k, '"k" (Key Value) Parameter');
            components = { k: jwk.k, kty: jwk.kty };
            break;
        default:
            throw new errors_js_1.JOSENotSupported('"kty" (Key Type) Parameter missing or unsupported');
    }
    const data = buffer_utils_js_1.encoder.encode(JSON.stringify(components));
    return (0, base64url_js_1.encode)(await (0, digest_js_1.default)(digestAlgorithm, data));
}
exports.calculateJwkThumbprint = calculateJwkThumbprint;

},{"../lib/buffer_utils.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/node/lib/buffer_utils.js","../lib/is_object.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/node/lib/is_object.js","../runtime/base64url.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/node/runtime/base64url.js","../runtime/digest.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/node/runtime/digest.js","../util/errors.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/node/util/errors.js"}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/node/jwks/remote.js":[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createRemoteJWKSet = void 0;
const fetch_jwks_js_1 = require("../runtime/fetch_jwks.js");
const import_js_1 = require("../key/import.js");
const errors_js_1 = require("../util/errors.js");
const is_object_js_1 = require("../lib/is_object.js");
function getKtyFromAlg(alg) {
    switch (typeof alg === 'string' && alg.substr(0, 2)) {
        case 'RS':
        case 'PS':
            return 'RSA';
        case 'ES':
            return 'EC';
        case 'Ed':
            return 'OKP';
        default:
            throw new errors_js_1.JOSENotSupported('Unsupported "alg" value for a JSON Web Key Set');
    }
}
function isJWKLike(key) {
    return (0, is_object_js_1.default)(key);
}
class RemoteJWKSet {
    constructor(url, options) {
        this._cached = new WeakMap();
        if (!(url instanceof URL)) {
            throw new TypeError('url must be an instance of URL');
        }
        this._url = new URL(url.href);
        this._options = { agent: options === null || options === void 0 ? void 0 : options.agent };
        this._timeoutDuration =
            typeof (options === null || options === void 0 ? void 0 : options.timeoutDuration) === 'number' ? options === null || options === void 0 ? void 0 : options.timeoutDuration : 5000;
        this._cooldownDuration =
            typeof (options === null || options === void 0 ? void 0 : options.cooldownDuration) === 'number' ? options === null || options === void 0 ? void 0 : options.cooldownDuration : 30000;
    }
    coolingDown() {
        if (!this._cooldownStarted) {
            return false;
        }
        return Date.now() < this._cooldownStarted + this._cooldownDuration;
    }
    async getKey(protectedHeader) {
        if (!this._jwks) {
            await this.reload();
        }
        const candidates = this._jwks.keys.filter((jwk) => {
            let candidate = jwk.kty === getKtyFromAlg(protectedHeader.alg);
            if (candidate && typeof protectedHeader.kid === 'string') {
                candidate = protectedHeader.kid === jwk.kid;
            }
            if (candidate && typeof jwk.alg === 'string') {
                candidate = protectedHeader.alg === jwk.alg;
            }
            if (candidate && typeof jwk.use === 'string') {
                candidate = jwk.use === 'sig';
            }
            if (candidate && Array.isArray(jwk.key_ops)) {
                candidate = jwk.key_ops.includes('verify');
            }
            if (candidate && protectedHeader.alg === 'EdDSA') {
                candidate = jwk.crv === 'Ed25519' || jwk.crv === 'Ed448';
            }
            if (candidate) {
                switch (protectedHeader.alg) {
                    case 'ES256':
                        candidate = jwk.crv === 'P-256';
                        break;
                    case 'ES256K':
                        candidate = jwk.crv === 'secp256k1';
                        break;
                    case 'ES384':
                        candidate = jwk.crv === 'P-384';
                        break;
                    case 'ES512':
                        candidate = jwk.crv === 'P-521';
                        break;
                    default:
                }
            }
            return candidate;
        });
        const { 0: jwk, length } = candidates;
        if (length === 0) {
            if (this.coolingDown() === false) {
                await this.reload();
                return this.getKey(protectedHeader);
            }
            throw new errors_js_1.JWKSNoMatchingKey();
        }
        else if (length !== 1) {
            throw new errors_js_1.JWKSMultipleMatchingKeys();
        }
        const cached = this._cached.get(jwk) || this._cached.set(jwk, {}).get(jwk);
        if (cached[protectedHeader.alg] === undefined) {
            const keyObject = await (0, import_js_1.importJWK)({ ...jwk, ext: true }, protectedHeader.alg);
            if (keyObject instanceof Uint8Array || keyObject.type !== 'public') {
                throw new errors_js_1.JWKSInvalid('JSON Web Key Set members must be public keys');
            }
            cached[protectedHeader.alg] = keyObject;
        }
        return cached[protectedHeader.alg];
    }
    async reload() {
        if (!this._pendingFetch) {
            this._pendingFetch = (0, fetch_jwks_js_1.default)(this._url, this._timeoutDuration, this._options)
                .then((json) => {
                if (typeof json !== 'object' ||
                    !json ||
                    !Array.isArray(json.keys) ||
                    !json.keys.every(isJWKLike)) {
                    throw new errors_js_1.JWKSInvalid('JSON Web Key Set malformed');
                }
                this._jwks = { keys: json.keys };
                this._cooldownStarted = Date.now();
                this._pendingFetch = undefined;
            })
                .catch((err) => {
                this._pendingFetch = undefined;
                throw err;
            });
        }
        await this._pendingFetch;
    }
}
function createRemoteJWKSet(url, options) {
    return RemoteJWKSet.prototype.getKey.bind(new RemoteJWKSet(url, options));
}
exports.createRemoteJWKSet = createRemoteJWKSet;

},{"../key/import.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/node/key/import.js","../lib/is_object.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/node/lib/is_object.js","../runtime/fetch_jwks.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/node/runtime/fetch_jwks.js","../util/errors.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/node/util/errors.js"}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/node/jws/compact/sign.js":[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.CompactSign = void 0;
const sign_js_1 = require("../flattened/sign.js");
class CompactSign {
    constructor(payload) {
        this._flattened = new sign_js_1.FlattenedSign(payload);
    }
    setProtectedHeader(protectedHeader) {
        this._flattened.setProtectedHeader(protectedHeader);
        return this;
    }
    async sign(key, options) {
        const jws = await this._flattened.sign(key, options);
        if (jws.payload === undefined) {
            throw new TypeError('use the flattened module for creating JWS with b64: false');
        }
        return `${jws.protected}.${jws.payload}.${jws.signature}`;
    }
}
exports.CompactSign = CompactSign;

},{"../flattened/sign.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/node/jws/flattened/sign.js"}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/node/jws/compact/verify.js":[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.compactVerify = void 0;
const verify_js_1 = require("../flattened/verify.js");
const errors_js_1 = require("../../util/errors.js");
const buffer_utils_js_1 = require("../../lib/buffer_utils.js");
async function compactVerify(jws, key, options) {
    if (jws instanceof Uint8Array) {
        jws = buffer_utils_js_1.decoder.decode(jws);
    }
    if (typeof jws !== 'string') {
        throw new errors_js_1.JWSInvalid('Compact JWS must be a string or Uint8Array');
    }
    const { 0: protectedHeader, 1: payload, 2: signature, length } = jws.split('.');
    if (length !== 3) {
        throw new errors_js_1.JWSInvalid('Invalid Compact JWS');
    }
    const verified = await (0, verify_js_1.flattenedVerify)({
        payload: (payload || undefined),
        protected: protectedHeader || undefined,
        signature: (signature || undefined),
    }, key, options);
    const result = { payload: verified.payload, protectedHeader: verified.protectedHeader };
    if (typeof key === 'function') {
        return { ...result, key: verified.key };
    }
    return result;
}
exports.compactVerify = compactVerify;

},{"../../lib/buffer_utils.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/node/lib/buffer_utils.js","../../util/errors.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/node/util/errors.js","../flattened/verify.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/node/jws/flattened/verify.js"}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/node/jws/flattened/sign.js":[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.FlattenedSign = void 0;
const base64url_js_1 = require("../../runtime/base64url.js");
const sign_js_1 = require("../../runtime/sign.js");
const is_disjoint_js_1 = require("../../lib/is_disjoint.js");
const errors_js_1 = require("../../util/errors.js");
const buffer_utils_js_1 = require("../../lib/buffer_utils.js");
const check_key_type_js_1 = require("../../lib/check_key_type.js");
const validate_crit_js_1 = require("../../lib/validate_crit.js");
class FlattenedSign {
    constructor(payload) {
        if (!(payload instanceof Uint8Array)) {
            throw new TypeError('payload must be an instance of Uint8Array');
        }
        this._payload = payload;
    }
    setProtectedHeader(protectedHeader) {
        if (this._protectedHeader) {
            throw new TypeError('setProtectedHeader can only be called once');
        }
        this._protectedHeader = protectedHeader;
        return this;
    }
    setUnprotectedHeader(unprotectedHeader) {
        if (this._unprotectedHeader) {
            throw new TypeError('setUnprotectedHeader can only be called once');
        }
        this._unprotectedHeader = unprotectedHeader;
        return this;
    }
    async sign(key, options) {
        if (!this._protectedHeader && !this._unprotectedHeader) {
            throw new errors_js_1.JWSInvalid('either setProtectedHeader or setUnprotectedHeader must be called before #sign()');
        }
        if (!(0, is_disjoint_js_1.default)(this._protectedHeader, this._unprotectedHeader)) {
            throw new errors_js_1.JWSInvalid('JWS Protected and JWS Unprotected Header Parameter names must be disjoint');
        }
        const joseHeader = {
            ...this._protectedHeader,
            ...this._unprotectedHeader,
        };
        const extensions = (0, validate_crit_js_1.default)(errors_js_1.JWSInvalid, new Map([['b64', true]]), options === null || options === void 0 ? void 0 : options.crit, this._protectedHeader, joseHeader);
        let b64 = true;
        if (extensions.has('b64')) {
            b64 = this._protectedHeader.b64;
            if (typeof b64 !== 'boolean') {
                throw new errors_js_1.JWSInvalid('The "b64" (base64url-encode payload) Header Parameter must be a boolean');
            }
        }
        const { alg } = joseHeader;
        if (typeof alg !== 'string' || !alg) {
            throw new errors_js_1.JWSInvalid('JWS "alg" (Algorithm) Header Parameter missing or invalid');
        }
        (0, check_key_type_js_1.default)(alg, key, 'sign');
        let payload = this._payload;
        if (b64) {
            payload = buffer_utils_js_1.encoder.encode((0, base64url_js_1.encode)(payload));
        }
        let protectedHeader;
        if (this._protectedHeader) {
            protectedHeader = buffer_utils_js_1.encoder.encode((0, base64url_js_1.encode)(JSON.stringify(this._protectedHeader)));
        }
        else {
            protectedHeader = buffer_utils_js_1.encoder.encode('');
        }
        const data = (0, buffer_utils_js_1.concat)(protectedHeader, buffer_utils_js_1.encoder.encode('.'), payload);
        const signature = await (0, sign_js_1.default)(alg, key, data);
        const jws = {
            signature: (0, base64url_js_1.encode)(signature),
            payload: '',
        };
        if (b64) {
            jws.payload = buffer_utils_js_1.decoder.decode(payload);
        }
        if (this._unprotectedHeader) {
            jws.header = this._unprotectedHeader;
        }
        if (this._protectedHeader) {
            jws.protected = buffer_utils_js_1.decoder.decode(protectedHeader);
        }
        return jws;
    }
}
exports.FlattenedSign = FlattenedSign;

},{"../../lib/buffer_utils.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/node/lib/buffer_utils.js","../../lib/check_key_type.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/node/lib/check_key_type.js","../../lib/is_disjoint.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/node/lib/is_disjoint.js","../../lib/validate_crit.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/node/lib/validate_crit.js","../../runtime/base64url.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/node/runtime/base64url.js","../../runtime/sign.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/node/runtime/sign.js","../../util/errors.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/node/util/errors.js"}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/node/jws/flattened/verify.js":[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.flattenedVerify = void 0;
const base64url_js_1 = require("../../runtime/base64url.js");
const verify_js_1 = require("../../runtime/verify.js");
const errors_js_1 = require("../../util/errors.js");
const buffer_utils_js_1 = require("../../lib/buffer_utils.js");
const is_disjoint_js_1 = require("../../lib/is_disjoint.js");
const is_object_js_1 = require("../../lib/is_object.js");
const check_key_type_js_1 = require("../../lib/check_key_type.js");
const validate_crit_js_1 = require("../../lib/validate_crit.js");
const validate_algorithms_js_1 = require("../../lib/validate_algorithms.js");
async function flattenedVerify(jws, key, options) {
    var _a;
    if (!(0, is_object_js_1.default)(jws)) {
        throw new errors_js_1.JWSInvalid('Flattened JWS must be an object');
    }
    if (jws.protected === undefined && jws.header === undefined) {
        throw new errors_js_1.JWSInvalid('Flattened JWS must have either of the "protected" or "header" members');
    }
    if (jws.protected !== undefined && typeof jws.protected !== 'string') {
        throw new errors_js_1.JWSInvalid('JWS Protected Header incorrect type');
    }
    if (jws.payload === undefined) {
        throw new errors_js_1.JWSInvalid('JWS Payload missing');
    }
    if (typeof jws.signature !== 'string') {
        throw new errors_js_1.JWSInvalid('JWS Signature missing or incorrect type');
    }
    if (jws.header !== undefined && !(0, is_object_js_1.default)(jws.header)) {
        throw new errors_js_1.JWSInvalid('JWS Unprotected Header incorrect type');
    }
    let parsedProt = {};
    if (jws.protected) {
        const protectedHeader = (0, base64url_js_1.decode)(jws.protected);
        try {
            parsedProt = JSON.parse(buffer_utils_js_1.decoder.decode(protectedHeader));
        }
        catch {
            throw new errors_js_1.JWSInvalid('JWS Protected Header is invalid');
        }
    }
    if (!(0, is_disjoint_js_1.default)(parsedProt, jws.header)) {
        throw new errors_js_1.JWSInvalid('JWS Protected and JWS Unprotected Header Parameter names must be disjoint');
    }
    const joseHeader = {
        ...parsedProt,
        ...jws.header,
    };
    const extensions = (0, validate_crit_js_1.default)(errors_js_1.JWSInvalid, new Map([['b64', true]]), options === null || options === void 0 ? void 0 : options.crit, parsedProt, joseHeader);
    let b64 = true;
    if (extensions.has('b64')) {
        b64 = parsedProt.b64;
        if (typeof b64 !== 'boolean') {
            throw new errors_js_1.JWSInvalid('The "b64" (base64url-encode payload) Header Parameter must be a boolean');
        }
    }
    const { alg } = joseHeader;
    if (typeof alg !== 'string' || !alg) {
        throw new errors_js_1.JWSInvalid('JWS "alg" (Algorithm) Header Parameter missing or invalid');
    }
    const algorithms = options && (0, validate_algorithms_js_1.default)('algorithms', options.algorithms);
    if (algorithms && !algorithms.has(alg)) {
        throw new errors_js_1.JOSEAlgNotAllowed('"alg" (Algorithm) Header Parameter not allowed');
    }
    if (b64) {
        if (typeof jws.payload !== 'string') {
            throw new errors_js_1.JWSInvalid('JWS Payload must be a string');
        }
    }
    else if (typeof jws.payload !== 'string' && !(jws.payload instanceof Uint8Array)) {
        throw new errors_js_1.JWSInvalid('JWS Payload must be a string or an Uint8Array instance');
    }
    let resolvedKey = false;
    if (typeof key === 'function') {
        key = await key(parsedProt, jws);
        resolvedKey = true;
    }
    (0, check_key_type_js_1.default)(alg, key, 'verify');
    const data = (0, buffer_utils_js_1.concat)(buffer_utils_js_1.encoder.encode((_a = jws.protected) !== null && _a !== void 0 ? _a : ''), buffer_utils_js_1.encoder.encode('.'), typeof jws.payload === 'string' ? buffer_utils_js_1.encoder.encode(jws.payload) : jws.payload);
    const signature = (0, base64url_js_1.decode)(jws.signature);
    const verified = await (0, verify_js_1.default)(alg, key, signature, data);
    if (!verified) {
        throw new errors_js_1.JWSSignatureVerificationFailed();
    }
    let payload;
    if (b64) {
        payload = (0, base64url_js_1.decode)(jws.payload);
    }
    else if (typeof jws.payload === 'string') {
        payload = buffer_utils_js_1.encoder.encode(jws.payload);
    }
    else {
        payload = jws.payload;
    }
    const result = { payload };
    if (jws.protected !== undefined) {
        result.protectedHeader = parsedProt;
    }
    if (jws.header !== undefined) {
        result.unprotectedHeader = jws.header;
    }
    if (resolvedKey) {
        return { ...result, key };
    }
    return result;
}
exports.flattenedVerify = flattenedVerify;

},{"../../lib/buffer_utils.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/node/lib/buffer_utils.js","../../lib/check_key_type.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/node/lib/check_key_type.js","../../lib/is_disjoint.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/node/lib/is_disjoint.js","../../lib/is_object.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/node/lib/is_object.js","../../lib/validate_algorithms.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/node/lib/validate_algorithms.js","../../lib/validate_crit.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/node/lib/validate_crit.js","../../runtime/base64url.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/node/runtime/base64url.js","../../runtime/verify.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/node/runtime/verify.js","../../util/errors.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/node/util/errors.js"}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/node/jws/general/sign.js":[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.GeneralSign = void 0;
const sign_js_1 = require("../flattened/sign.js");
const errors_js_1 = require("../../util/errors.js");
const signatureRef = new WeakMap();
class IndividualSignature {
    setProtectedHeader(protectedHeader) {
        if (this._protectedHeader) {
            throw new TypeError('setProtectedHeader can only be called once');
        }
        this._protectedHeader = protectedHeader;
        return this;
    }
    setUnprotectedHeader(unprotectedHeader) {
        if (this._unprotectedHeader) {
            throw new TypeError('setUnprotectedHeader can only be called once');
        }
        this._unprotectedHeader = unprotectedHeader;
        return this;
    }
    set _protectedHeader(value) {
        signatureRef.get(this).protectedHeader = value;
    }
    get _protectedHeader() {
        return signatureRef.get(this).protectedHeader;
    }
    set _unprotectedHeader(value) {
        signatureRef.get(this).unprotectedHeader = value;
    }
    get _unprotectedHeader() {
        return signatureRef.get(this).unprotectedHeader;
    }
}
class GeneralSign {
    constructor(payload) {
        this._signatures = [];
        this._payload = payload;
    }
    addSignature(key, options) {
        const signature = new IndividualSignature();
        signatureRef.set(signature, { key, options });
        this._signatures.push(signature);
        return signature;
    }
    async sign() {
        if (!this._signatures.length) {
            throw new errors_js_1.JWSInvalid('at least one signature must be added');
        }
        const jws = {
            signatures: [],
            payload: '',
        };
        let payloads = new Set();
        await Promise.all(this._signatures.map(async (sig) => {
            const { protectedHeader, unprotectedHeader, options, key } = signatureRef.get(sig);
            const flattened = new sign_js_1.FlattenedSign(this._payload);
            if (protectedHeader) {
                flattened.setProtectedHeader(protectedHeader);
            }
            if (unprotectedHeader) {
                flattened.setUnprotectedHeader(unprotectedHeader);
            }
            const { payload, ...rest } = await flattened.sign(key, options);
            payloads.add(payload);
            jws.payload = payload;
            jws.signatures.push(rest);
        }));
        if (payloads.size !== 1) {
            throw new errors_js_1.JWSInvalid('inconsistent use of JWS Unencoded Payload Option (RFC7797)');
        }
        return jws;
    }
}
exports.GeneralSign = GeneralSign;

},{"../../util/errors.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/node/util/errors.js","../flattened/sign.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/node/jws/flattened/sign.js"}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/node/jws/general/verify.js":[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.generalVerify = void 0;
const verify_js_1 = require("../flattened/verify.js");
const errors_js_1 = require("../../util/errors.js");
const is_object_js_1 = require("../../lib/is_object.js");
async function generalVerify(jws, key, options) {
    if (!(0, is_object_js_1.default)(jws)) {
        throw new errors_js_1.JWSInvalid('General JWS must be an object');
    }
    if (!Array.isArray(jws.signatures) || !jws.signatures.every(is_object_js_1.default)) {
        throw new errors_js_1.JWSInvalid('JWS Signatures missing or incorrect type');
    }
    for (const signature of jws.signatures) {
        try {
            return await (0, verify_js_1.flattenedVerify)({
                header: signature.header,
                payload: jws.payload,
                protected: signature.protected,
                signature: signature.signature,
            }, key, options);
        }
        catch {
        }
    }
    throw new errors_js_1.JWSSignatureVerificationFailed();
}
exports.generalVerify = generalVerify;

},{"../../lib/is_object.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/node/lib/is_object.js","../../util/errors.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/node/util/errors.js","../flattened/verify.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/node/jws/flattened/verify.js"}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/node/jwt/decrypt.js":[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.jwtDecrypt = void 0;
const decrypt_js_1 = require("../jwe/compact/decrypt.js");
const jwt_claims_set_js_1 = require("../lib/jwt_claims_set.js");
const errors_js_1 = require("../util/errors.js");
async function jwtDecrypt(jwt, key, options) {
    const decrypted = await (0, decrypt_js_1.compactDecrypt)(jwt, key, options);
    const payload = (0, jwt_claims_set_js_1.default)(decrypted.protectedHeader, decrypted.plaintext, options);
    const { protectedHeader } = decrypted;
    if (protectedHeader.iss !== undefined && protectedHeader.iss !== payload.iss) {
        throw new errors_js_1.JWTClaimValidationFailed('replicated "iss" claim header parameter mismatch', 'iss', 'mismatch');
    }
    if (protectedHeader.sub !== undefined && protectedHeader.sub !== payload.sub) {
        throw new errors_js_1.JWTClaimValidationFailed('replicated "sub" claim header parameter mismatch', 'sub', 'mismatch');
    }
    if (protectedHeader.aud !== undefined &&
        JSON.stringify(protectedHeader.aud) !== JSON.stringify(payload.aud)) {
        throw new errors_js_1.JWTClaimValidationFailed('replicated "aud" claim header parameter mismatch', 'aud', 'mismatch');
    }
    const result = { payload, protectedHeader };
    if (typeof key === 'function') {
        return { ...result, key: decrypted.key };
    }
    return result;
}
exports.jwtDecrypt = jwtDecrypt;

},{"../jwe/compact/decrypt.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/node/jwe/compact/decrypt.js","../lib/jwt_claims_set.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/node/lib/jwt_claims_set.js","../util/errors.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/node/util/errors.js"}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/node/jwt/encrypt.js":[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.EncryptJWT = void 0;
const encrypt_js_1 = require("../jwe/compact/encrypt.js");
const buffer_utils_js_1 = require("../lib/buffer_utils.js");
const produce_js_1 = require("./produce.js");
class EncryptJWT extends produce_js_1.ProduceJWT {
    setProtectedHeader(protectedHeader) {
        if (this._protectedHeader) {
            throw new TypeError('setProtectedHeader can only be called once');
        }
        this._protectedHeader = protectedHeader;
        return this;
    }
    setKeyManagementParameters(parameters) {
        if (this._keyManagementParameters) {
            throw new TypeError('setKeyManagementParameters can only be called once');
        }
        this._keyManagementParameters = parameters;
        return this;
    }
    setContentEncryptionKey(cek) {
        if (this._cek) {
            throw new TypeError('setContentEncryptionKey can only be called once');
        }
        this._cek = cek;
        return this;
    }
    setInitializationVector(iv) {
        if (this._iv) {
            throw new TypeError('setInitializationVector can only be called once');
        }
        this._iv = iv;
        return this;
    }
    replicateIssuerAsHeader() {
        this._replicateIssuerAsHeader = true;
        return this;
    }
    replicateSubjectAsHeader() {
        this._replicateSubjectAsHeader = true;
        return this;
    }
    replicateAudienceAsHeader() {
        this._replicateAudienceAsHeader = true;
        return this;
    }
    async encrypt(key, options) {
        const enc = new encrypt_js_1.CompactEncrypt(buffer_utils_js_1.encoder.encode(JSON.stringify(this._payload)));
        if (this._replicateIssuerAsHeader) {
            this._protectedHeader = { ...this._protectedHeader, iss: this._payload.iss };
        }
        if (this._replicateSubjectAsHeader) {
            this._protectedHeader = { ...this._protectedHeader, sub: this._payload.sub };
        }
        if (this._replicateAudienceAsHeader) {
            this._protectedHeader = { ...this._protectedHeader, aud: this._payload.aud };
        }
        enc.setProtectedHeader(this._protectedHeader);
        if (this._iv) {
            enc.setInitializationVector(this._iv);
        }
        if (this._cek) {
            enc.setContentEncryptionKey(this._cek);
        }
        if (this._keyManagementParameters) {
            enc.setKeyManagementParameters(this._keyManagementParameters);
        }
        return enc.encrypt(key, options);
    }
}
exports.EncryptJWT = EncryptJWT;

},{"../jwe/compact/encrypt.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/node/jwe/compact/encrypt.js","../lib/buffer_utils.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/node/lib/buffer_utils.js","./produce.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/node/jwt/produce.js"}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/node/jwt/produce.js":[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ProduceJWT = void 0;
const epoch_js_1 = require("../lib/epoch.js");
const is_object_js_1 = require("../lib/is_object.js");
const secs_js_1 = require("../lib/secs.js");
class ProduceJWT {
    constructor(payload) {
        if (!(0, is_object_js_1.default)(payload)) {
            throw new TypeError('JWT Claims Set MUST be an object');
        }
        this._payload = payload;
    }
    setIssuer(issuer) {
        this._payload = { ...this._payload, iss: issuer };
        return this;
    }
    setSubject(subject) {
        this._payload = { ...this._payload, sub: subject };
        return this;
    }
    setAudience(audience) {
        this._payload = { ...this._payload, aud: audience };
        return this;
    }
    setJti(jwtId) {
        this._payload = { ...this._payload, jti: jwtId };
        return this;
    }
    setNotBefore(input) {
        if (typeof input === 'number') {
            this._payload = { ...this._payload, nbf: input };
        }
        else {
            this._payload = { ...this._payload, nbf: (0, epoch_js_1.default)(new Date()) + (0, secs_js_1.default)(input) };
        }
        return this;
    }
    setExpirationTime(input) {
        if (typeof input === 'number') {
            this._payload = { ...this._payload, exp: input };
        }
        else {
            this._payload = { ...this._payload, exp: (0, epoch_js_1.default)(new Date()) + (0, secs_js_1.default)(input) };
        }
        return this;
    }
    setIssuedAt(input) {
        if (typeof input === 'undefined') {
            this._payload = { ...this._payload, iat: (0, epoch_js_1.default)(new Date()) };
        }
        else {
            this._payload = { ...this._payload, iat: input };
        }
        return this;
    }
}
exports.ProduceJWT = ProduceJWT;

},{"../lib/epoch.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/node/lib/epoch.js","../lib/is_object.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/node/lib/is_object.js","../lib/secs.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/node/lib/secs.js"}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/node/jwt/sign.js":[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SignJWT = void 0;
const sign_js_1 = require("../jws/compact/sign.js");
const errors_js_1 = require("../util/errors.js");
const buffer_utils_js_1 = require("../lib/buffer_utils.js");
const produce_js_1 = require("./produce.js");
class SignJWT extends produce_js_1.ProduceJWT {
    setProtectedHeader(protectedHeader) {
        this._protectedHeader = protectedHeader;
        return this;
    }
    async sign(key, options) {
        var _a;
        const sig = new sign_js_1.CompactSign(buffer_utils_js_1.encoder.encode(JSON.stringify(this._payload)));
        sig.setProtectedHeader(this._protectedHeader);
        if (Array.isArray((_a = this._protectedHeader) === null || _a === void 0 ? void 0 : _a.crit) &&
            this._protectedHeader.crit.includes('b64') &&
            this._protectedHeader.b64 === false) {
            throw new errors_js_1.JWTInvalid('JWTs MUST NOT use unencoded payload');
        }
        return sig.sign(key, options);
    }
}
exports.SignJWT = SignJWT;

},{"../jws/compact/sign.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/node/jws/compact/sign.js","../lib/buffer_utils.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/node/lib/buffer_utils.js","../util/errors.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/node/util/errors.js","./produce.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/node/jwt/produce.js"}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/node/jwt/unsecured.js":[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.UnsecuredJWT = void 0;
const base64url = require("../runtime/base64url.js");
const buffer_utils_js_1 = require("../lib/buffer_utils.js");
const errors_js_1 = require("../util/errors.js");
const jwt_claims_set_js_1 = require("../lib/jwt_claims_set.js");
const produce_js_1 = require("./produce.js");
class UnsecuredJWT extends produce_js_1.ProduceJWT {
    encode() {
        const header = base64url.encode(JSON.stringify({ alg: 'none' }));
        const payload = base64url.encode(JSON.stringify(this._payload));
        return `${header}.${payload}.`;
    }
    static decode(jwt, options) {
        if (typeof jwt !== 'string') {
            throw new errors_js_1.JWTInvalid('Unsecured JWT must be a string');
        }
        const { 0: encodedHeader, 1: encodedPayload, 2: signature, length } = jwt.split('.');
        if (length !== 3 || signature !== '') {
            throw new errors_js_1.JWTInvalid('Invalid Unsecured JWT');
        }
        let header;
        try {
            header = JSON.parse(buffer_utils_js_1.decoder.decode(base64url.decode(encodedHeader)));
            if (header.alg !== 'none')
                throw new Error();
        }
        catch {
            throw new errors_js_1.JWTInvalid('Invalid Unsecured JWT');
        }
        const payload = (0, jwt_claims_set_js_1.default)(header, base64url.decode(encodedPayload), options);
        return { payload, header };
    }
}
exports.UnsecuredJWT = UnsecuredJWT;

},{"../lib/buffer_utils.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/node/lib/buffer_utils.js","../lib/jwt_claims_set.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/node/lib/jwt_claims_set.js","../runtime/base64url.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/node/runtime/base64url.js","../util/errors.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/node/util/errors.js","./produce.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/node/jwt/produce.js"}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/node/jwt/verify.js":[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.jwtVerify = void 0;
const verify_js_1 = require("../jws/compact/verify.js");
const jwt_claims_set_js_1 = require("../lib/jwt_claims_set.js");
const errors_js_1 = require("../util/errors.js");
async function jwtVerify(jwt, key, options) {
    var _a;
    const verified = await (0, verify_js_1.compactVerify)(jwt, key, options);
    if (((_a = verified.protectedHeader.crit) === null || _a === void 0 ? void 0 : _a.includes('b64')) && verified.protectedHeader.b64 === false) {
        throw new errors_js_1.JWTInvalid('JWTs MUST NOT use unencoded payload');
    }
    const payload = (0, jwt_claims_set_js_1.default)(verified.protectedHeader, verified.payload, options);
    const result = { payload, protectedHeader: verified.protectedHeader };
    if (typeof key === 'function') {
        return { ...result, key: verified.key };
    }
    return result;
}
exports.jwtVerify = jwtVerify;

},{"../jws/compact/verify.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/node/jws/compact/verify.js","../lib/jwt_claims_set.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/node/lib/jwt_claims_set.js","../util/errors.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/node/util/errors.js"}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/node/key/export.js":[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.exportJWK = exports.exportPKCS8 = exports.exportSPKI = void 0;
const asn1_js_1 = require("../runtime/asn1.js");
const asn1_js_2 = require("../runtime/asn1.js");
const key_to_jwk_js_1 = require("../runtime/key_to_jwk.js");
async function exportSPKI(key) {
    return (0, asn1_js_1.toSPKI)(key);
}
exports.exportSPKI = exportSPKI;
async function exportPKCS8(key) {
    return (0, asn1_js_2.toPKCS8)(key);
}
exports.exportPKCS8 = exportPKCS8;
async function exportJWK(key) {
    return (0, key_to_jwk_js_1.default)(key);
}
exports.exportJWK = exportJWK;

},{"../runtime/asn1.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/node/runtime/asn1.js","../runtime/key_to_jwk.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/node/runtime/key_to_jwk.js"}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/node/key/generate_key_pair.js":[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.generateKeyPair = void 0;
const generate_js_1 = require("../runtime/generate.js");
async function generateKeyPair(alg, options) {
    return (0, generate_js_1.generateKeyPair)(alg, options);
}
exports.generateKeyPair = generateKeyPair;

},{"../runtime/generate.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/node/runtime/generate.js"}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/node/key/generate_secret.js":[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.generateSecret = void 0;
const generate_js_1 = require("../runtime/generate.js");
async function generateSecret(alg, options) {
    return (0, generate_js_1.generateSecret)(alg, options);
}
exports.generateSecret = generateSecret;

},{"../runtime/generate.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/node/runtime/generate.js"}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/node/key/import.js":[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.importJWK = exports.importPKCS8 = exports.importX509 = exports.importSPKI = void 0;
const base64url_js_1 = require("../runtime/base64url.js");
const asn1_js_1 = require("../runtime/asn1.js");
const asn1_js_2 = require("../runtime/asn1.js");
const jwk_to_key_js_1 = require("../runtime/jwk_to_key.js");
const errors_js_1 = require("../util/errors.js");
const format_pem_js_1 = require("../lib/format_pem.js");
const is_object_js_1 = require("../lib/is_object.js");
function getElement(seq) {
    let result = [];
    let next = 0;
    while (next < seq.length) {
        let nextPart = parseElement(seq.subarray(next));
        result.push(nextPart);
        next += nextPart.byteLength;
    }
    return result;
}
function parseElement(bytes) {
    let position = 0;
    let tag = bytes[0] & 0x1f;
    position++;
    if (tag === 0x1f) {
        tag = 0;
        while (bytes[position] >= 0x80) {
            tag = tag * 128 + bytes[position] - 0x80;
            position++;
        }
        tag = tag * 128 + bytes[position] - 0x80;
        position++;
    }
    let length = 0;
    if (bytes[position] < 0x80) {
        length = bytes[position];
        position++;
    }
    else {
        let numberOfDigits = bytes[position] & 0x7f;
        position++;
        length = 0;
        for (let i = 0; i < numberOfDigits; i++) {
            length = length * 256 + bytes[position];
            position++;
        }
    }
    if (length === 0x80) {
        length = 0;
        while (bytes[position + length] !== 0 || bytes[position + length + 1] !== 0) {
            length++;
        }
        const byteLength = position + length + 2;
        return {
            byteLength,
            contents: bytes.subarray(position, position + length),
            raw: bytes.subarray(0, byteLength),
        };
    }
    const byteLength = position + length;
    return {
        byteLength,
        contents: bytes.subarray(position, byteLength),
        raw: bytes.subarray(0, byteLength),
    };
}
function spkiFromX509(buf) {
    return (0, base64url_js_1.encodeBase64)(getElement(getElement(parseElement(buf).contents)[0].contents)[6].raw);
}
function getSPKI(x509) {
    const pem = x509.replace(/(?:-----(?:BEGIN|END) CERTIFICATE-----|\s)/g, '');
    const raw = (0, base64url_js_1.decodeBase64)(pem);
    return (0, format_pem_js_1.default)(spkiFromX509(raw), 'PUBLIC KEY');
}
async function importSPKI(spki, alg, options) {
    if (typeof spki !== 'string' || spki.indexOf('-----BEGIN PUBLIC KEY-----') !== 0) {
        throw new TypeError('"spki" must be SPKI formatted string');
    }
    return (0, asn1_js_1.fromSPKI)(spki, alg, options);
}
exports.importSPKI = importSPKI;
async function importX509(x509, alg, options) {
    if (typeof x509 !== 'string' || x509.indexOf('-----BEGIN CERTIFICATE-----') !== 0) {
        throw new TypeError('"x509" must be X.509 formatted string');
    }
    const spki = getSPKI(x509);
    return (0, asn1_js_1.fromSPKI)(spki, alg, options);
}
exports.importX509 = importX509;
async function importPKCS8(pkcs8, alg, options) {
    if (typeof pkcs8 !== 'string' || pkcs8.indexOf('-----BEGIN PRIVATE KEY-----') !== 0) {
        throw new TypeError('"pkcs8" must be PCKS8 formatted string');
    }
    return (0, asn1_js_2.fromPKCS8)(pkcs8, alg, options);
}
exports.importPKCS8 = importPKCS8;
async function importJWK(jwk, alg, octAsKeyObject) {
    if (!(0, is_object_js_1.default)(jwk)) {
        throw new TypeError('JWK must be an object');
    }
    alg || (alg = jwk.alg);
    if (typeof alg !== 'string' || !alg) {
        throw new TypeError('"alg" argument is required when "jwk.alg" is not present');
    }
    switch (jwk.kty) {
        case 'oct':
            if (typeof jwk.k !== 'string' || !jwk.k) {
                throw new TypeError('missing "k" (Key Value) Parameter value');
            }
            octAsKeyObject !== null && octAsKeyObject !== void 0 ? octAsKeyObject : (octAsKeyObject = jwk.ext !== true);
            if (octAsKeyObject) {
                return (0, jwk_to_key_js_1.default)({ ...jwk, alg, ext: false });
            }
            return (0, base64url_js_1.decode)(jwk.k);
        case 'RSA':
            if (jwk.oth !== undefined) {
                throw new errors_js_1.JOSENotSupported('RSA JWK "oth" (Other Primes Info) Parameter value is not supported');
            }
        case 'EC':
        case 'OKP':
            return (0, jwk_to_key_js_1.default)({ ...jwk, alg });
        default:
            throw new errors_js_1.JOSENotSupported('Unsupported "kty" (Key Type) Parameter value');
    }
}
exports.importJWK = importJWK;

},{"../lib/format_pem.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/node/lib/format_pem.js","../lib/is_object.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/node/lib/is_object.js","../runtime/asn1.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/node/runtime/asn1.js","../runtime/base64url.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/node/runtime/base64url.js","../runtime/jwk_to_key.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/node/runtime/jwk_to_key.js","../util/errors.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/node/util/errors.js"}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/node/lib/aesgcmkw.js":[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.unwrap = exports.wrap = void 0;
const encrypt_js_1 = require("../runtime/encrypt.js");
const decrypt_js_1 = require("../runtime/decrypt.js");
const iv_js_1 = require("./iv.js");
const base64url_js_1 = require("../runtime/base64url.js");
async function wrap(alg, key, cek, iv) {
    const jweAlgorithm = alg.substr(0, 7);
    iv || (iv = (0, iv_js_1.default)(jweAlgorithm));
    const { ciphertext: encryptedKey, tag } = await (0, encrypt_js_1.default)(jweAlgorithm, cek, key, iv, new Uint8Array(0));
    return { encryptedKey, iv: (0, base64url_js_1.encode)(iv), tag: (0, base64url_js_1.encode)(tag) };
}
exports.wrap = wrap;
async function unwrap(alg, key, encryptedKey, iv, tag) {
    const jweAlgorithm = alg.substr(0, 7);
    return (0, decrypt_js_1.default)(jweAlgorithm, key, encryptedKey, iv, tag, new Uint8Array(0));
}
exports.unwrap = unwrap;

},{"../runtime/base64url.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/node/runtime/base64url.js","../runtime/decrypt.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/node/runtime/decrypt.js","../runtime/encrypt.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/node/runtime/encrypt.js","./iv.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/node/lib/iv.js"}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/node/lib/buffer_utils.js":[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.concatKdf = exports.lengthAndInput = exports.uint32be = exports.uint64be = exports.p2s = exports.concat = exports.decoder = exports.encoder = void 0;
exports.encoder = new TextEncoder();
exports.decoder = new TextDecoder();
const MAX_INT32 = 2 ** 32;
function concat(...buffers) {
    const size = buffers.reduce((acc, { length }) => acc + length, 0);
    const buf = new Uint8Array(size);
    let i = 0;
    buffers.forEach((buffer) => {
        buf.set(buffer, i);
        i += buffer.length;
    });
    return buf;
}
exports.concat = concat;
function p2s(alg, p2sInput) {
    return concat(exports.encoder.encode(alg), new Uint8Array([0]), p2sInput);
}
exports.p2s = p2s;
function writeUInt32BE(buf, value, offset) {
    if (value < 0 || value >= MAX_INT32) {
        throw new RangeError(`value must be >= 0 and <= ${MAX_INT32 - 1}. Received ${value}`);
    }
    buf.set([value >>> 24, value >>> 16, value >>> 8, value & 0xff], offset);
}
function uint64be(value) {
    const high = Math.floor(value / MAX_INT32);
    const low = value % MAX_INT32;
    const buf = new Uint8Array(8);
    writeUInt32BE(buf, high, 0);
    writeUInt32BE(buf, low, 4);
    return buf;
}
exports.uint64be = uint64be;
function uint32be(value) {
    const buf = new Uint8Array(4);
    writeUInt32BE(buf, value);
    return buf;
}
exports.uint32be = uint32be;
function lengthAndInput(input) {
    return concat(uint32be(input.length), input);
}
exports.lengthAndInput = lengthAndInput;
async function concatKdf(digest, secret, bits, value) {
    const iterations = Math.ceil((bits >> 3) / 32);
    let res;
    for (let iter = 1; iter <= iterations; iter++) {
        const buf = new Uint8Array(4 + secret.length + value.length);
        buf.set(uint32be(iter));
        buf.set(secret, 4);
        buf.set(value, 4 + secret.length);
        if (!res) {
            res = await digest('sha256', buf);
        }
        else {
            res = concat(res, await digest('sha256', buf));
        }
    }
    res = res.slice(0, bits >> 3);
    return res;
}
exports.concatKdf = concatKdf;

},{}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/node/lib/cek.js":[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.bitLength = void 0;
const errors_js_1 = require("../util/errors.js");
const random_js_1 = require("../runtime/random.js");
function bitLength(alg) {
    switch (alg) {
        case 'A128CBC-HS256':
            return 256;
        case 'A192CBC-HS384':
            return 384;
        case 'A256CBC-HS512':
            return 512;
        case 'A128GCM':
            return 128;
        case 'A192GCM':
            return 192;
        case 'A256GCM':
            return 256;
        default:
            throw new errors_js_1.JOSENotSupported(`Unsupported JWE Algorithm: ${alg}`);
    }
}
exports.bitLength = bitLength;
exports.default = (alg) => (0, random_js_1.default)(new Uint8Array(bitLength(alg) >> 3));

},{"../runtime/random.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/node/runtime/random.js","../util/errors.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/node/util/errors.js"}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/node/lib/check_iv_length.js":[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const errors_js_1 = require("../util/errors.js");
const iv_js_1 = require("./iv.js");
const checkIvLength = (enc, iv) => {
    if (iv.length << 3 !== (0, iv_js_1.bitLength)(enc)) {
        throw new errors_js_1.JWEInvalid('Invalid Initialization Vector length');
    }
};
exports.default = checkIvLength;

},{"../util/errors.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/node/util/errors.js","./iv.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/node/lib/iv.js"}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/node/lib/check_key_type.js":[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const invalid_key_input_js_1 = require("./invalid_key_input.js");
const is_key_like_js_1 = require("../runtime/is_key_like.js");
const symmetricTypeCheck = (key) => {
    if (key instanceof Uint8Array)
        return;
    if (!(0, is_key_like_js_1.default)(key)) {
        throw new TypeError((0, invalid_key_input_js_1.default)(key, ...is_key_like_js_1.types, 'Uint8Array'));
    }
    if (key.type !== 'secret') {
        throw new TypeError(`${is_key_like_js_1.types.join(' or ')} instances for symmetric algorithms must be of type "secret"`);
    }
};
const asymmetricTypeCheck = (key, usage) => {
    if (!(0, is_key_like_js_1.default)(key)) {
        throw new TypeError((0, invalid_key_input_js_1.default)(key, ...is_key_like_js_1.types));
    }
    if (key.type === 'secret') {
        throw new TypeError(`${is_key_like_js_1.types.join(' or ')} instances for asymmetric algorithms must not be of type "secret"`);
    }
    if (usage === 'sign' && key.type === 'public') {
        throw new TypeError(`${is_key_like_js_1.types.join(' or ')} instances for asymmetric algorithm signing must be of type "private"`);
    }
    if (usage === 'decrypt' && key.type === 'public') {
        throw new TypeError(`${is_key_like_js_1.types.join(' or ')} instances for asymmetric algorithm decryption must be of type "private"`);
    }
    if (key.algorithm && usage === 'verify' && key.type === 'private') {
        throw new TypeError(`${is_key_like_js_1.types.join(' or ')} instances for asymmetric algorithm verifying must be of type "public"`);
    }
    if (key.algorithm && usage === 'encrypt' && key.type === 'private') {
        throw new TypeError(`${is_key_like_js_1.types.join(' or ')} instances for asymmetric algorithm encryption must be of type "public"`);
    }
};
const checkKeyType = (alg, key, usage) => {
    const symmetric = alg.startsWith('HS') ||
        alg === 'dir' ||
        alg.startsWith('PBES2') ||
        /^A\d{3}(?:GCM)?KW$/.test(alg);
    if (symmetric) {
        symmetricTypeCheck(key);
    }
    else {
        asymmetricTypeCheck(key, usage);
    }
};
exports.default = checkKeyType;

},{"../runtime/is_key_like.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/node/runtime/is_key_like.js","./invalid_key_input.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/node/lib/invalid_key_input.js"}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/node/lib/check_p2s.js":[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const errors_js_1 = require("../util/errors.js");
function checkP2s(p2s) {
    if (!(p2s instanceof Uint8Array) || p2s.length < 8) {
        throw new errors_js_1.JWEInvalid('PBES2 Salt Input must be 8 or more octets');
    }
}
exports.default = checkP2s;

},{"../util/errors.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/node/util/errors.js"}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/node/lib/crypto_key.js":[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.checkEncCryptoKey = exports.checkSigCryptoKey = void 0;
const global_js_1 = require("../runtime/global.js");
function unusable(name, prop = 'algorithm.name') {
    return new TypeError(`CryptoKey does not support this operation, its ${prop} must be ${name}`);
}
function isAlgorithm(algorithm, name) {
    return algorithm.name === name;
}
function getHashLength(hash) {
    return parseInt(hash.name.substr(4), 10);
}
function getNamedCurve(alg) {
    switch (alg) {
        case 'ES256':
            return 'P-256';
        case 'ES384':
            return 'P-384';
        case 'ES512':
            return 'P-521';
        default:
            throw new Error('unreachable');
    }
}
function checkUsage(key, usages) {
    if (usages.length && !usages.some((expected) => key.usages.includes(expected))) {
        let msg = 'CryptoKey does not support this operation, its usages must include ';
        if (usages.length > 2) {
            const last = usages.pop();
            msg += `one of ${usages.join(', ')}, or ${last}.`;
        }
        else if (usages.length === 2) {
            msg += `one of ${usages[0]} or ${usages[1]}.`;
        }
        else {
            msg += `${usages[0]}.`;
        }
        throw new TypeError(msg);
    }
}
function checkSigCryptoKey(key, alg, ...usages) {
    switch (alg) {
        case 'HS256':
        case 'HS384':
        case 'HS512': {
            if (!isAlgorithm(key.algorithm, 'HMAC'))
                throw unusable('HMAC');
            const expected = parseInt(alg.substr(2), 10);
            const actual = getHashLength(key.algorithm.hash);
            if (actual !== expected)
                throw unusable(`SHA-${expected}`, 'algorithm.hash');
            break;
        }
        case 'RS256':
        case 'RS384':
        case 'RS512': {
            if (!isAlgorithm(key.algorithm, 'RSASSA-PKCS1-v1_5'))
                throw unusable('RSASSA-PKCS1-v1_5');
            const expected = parseInt(alg.substr(2), 10);
            const actual = getHashLength(key.algorithm.hash);
            if (actual !== expected)
                throw unusable(`SHA-${expected}`, 'algorithm.hash');
            break;
        }
        case 'PS256':
        case 'PS384':
        case 'PS512': {
            if (!isAlgorithm(key.algorithm, 'RSA-PSS'))
                throw unusable('RSA-PSS');
            const expected = parseInt(alg.substr(2), 10);
            const actual = getHashLength(key.algorithm.hash);
            if (actual !== expected)
                throw unusable(`SHA-${expected}`, 'algorithm.hash');
            break;
        }
        case (0, global_js_1.isNodeJs)() && 'EdDSA': {
            if (key.algorithm.name !== 'NODE-ED25519' && key.algorithm.name !== 'NODE-ED448')
                throw unusable('NODE-ED25519 or NODE-ED448');
            break;
        }
        case (0, global_js_1.isCloudflareWorkers)() && 'EdDSA': {
            if (!isAlgorithm(key.algorithm, 'NODE-ED25519'))
                throw unusable('NODE-ED25519');
            break;
        }
        case 'ES256':
        case 'ES384':
        case 'ES512': {
            if (!isAlgorithm(key.algorithm, 'ECDSA'))
                throw unusable('ECDSA');
            const expected = getNamedCurve(alg);
            const actual = key.algorithm.namedCurve;
            if (actual !== expected)
                throw unusable(expected, 'algorithm.namedCurve');
            break;
        }
        default:
            throw new TypeError('CryptoKey does not support this operation');
    }
    checkUsage(key, usages);
}
exports.checkSigCryptoKey = checkSigCryptoKey;
function checkEncCryptoKey(key, alg, ...usages) {
    switch (alg) {
        case 'A128GCM':
        case 'A192GCM':
        case 'A256GCM': {
            if (!isAlgorithm(key.algorithm, 'AES-GCM'))
                throw unusable('AES-GCM');
            const expected = parseInt(alg.substr(1, 3), 10);
            const actual = key.algorithm.length;
            if (actual !== expected)
                throw unusable(expected, 'algorithm.length');
            break;
        }
        case 'A128KW':
        case 'A192KW':
        case 'A256KW': {
            if (!isAlgorithm(key.algorithm, 'AES-KW'))
                throw unusable('AES-KW');
            const expected = parseInt(alg.substr(1, 3), 10);
            const actual = key.algorithm.length;
            if (actual !== expected)
                throw unusable(expected, 'algorithm.length');
            break;
        }
        case 'ECDH-ES':
            if (!isAlgorithm(key.algorithm, 'ECDH'))
                throw unusable('ECDH');
            break;
        case 'PBES2-HS256+A128KW':
        case 'PBES2-HS384+A192KW':
        case 'PBES2-HS512+A256KW':
            if (!isAlgorithm(key.algorithm, 'PBKDF2'))
                throw unusable('PBKDF2');
            break;
        case 'RSA-OAEP':
        case 'RSA-OAEP-256':
        case 'RSA-OAEP-384':
        case 'RSA-OAEP-512': {
            if (!isAlgorithm(key.algorithm, 'RSA-OAEP'))
                throw unusable('RSA-OAEP');
            const expected = parseInt(alg.substr(9), 10) || 1;
            const actual = getHashLength(key.algorithm.hash);
            if (actual !== expected)
                throw unusable(`SHA-${expected}`, 'algorithm.hash');
            break;
        }
        default:
            throw new TypeError('CryptoKey does not support this operation');
    }
    checkUsage(key, usages);
}
exports.checkEncCryptoKey = checkEncCryptoKey;

},{"../runtime/global.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/node/runtime/global.js"}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/node/lib/decrypt_key_management.js":[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const aeskw_js_1 = require("../runtime/aeskw.js");
const ECDH = require("../runtime/ecdhes.js");
const pbes2kw_js_1 = require("../runtime/pbes2kw.js");
const rsaes_js_1 = require("../runtime/rsaes.js");
const base64url_js_1 = require("../runtime/base64url.js");
const errors_js_1 = require("../util/errors.js");
const cek_js_1 = require("../lib/cek.js");
const import_js_1 = require("../key/import.js");
const check_key_type_js_1 = require("./check_key_type.js");
const is_object_js_1 = require("./is_object.js");
const aesgcmkw_js_1 = require("./aesgcmkw.js");
async function decryptKeyManagement(alg, key, encryptedKey, joseHeader) {
    (0, check_key_type_js_1.default)(alg, key, 'decrypt');
    switch (alg) {
        case 'dir': {
            if (encryptedKey !== undefined)
                throw new errors_js_1.JWEInvalid('Encountered unexpected JWE Encrypted Key');
            return key;
        }
        case 'ECDH-ES':
            if (encryptedKey !== undefined)
                throw new errors_js_1.JWEInvalid('Encountered unexpected JWE Encrypted Key');
        case 'ECDH-ES+A128KW':
        case 'ECDH-ES+A192KW':
        case 'ECDH-ES+A256KW': {
            if (!(0, is_object_js_1.default)(joseHeader.epk))
                throw new errors_js_1.JWEInvalid(`JOSE Header "epk" (Ephemeral Public Key) missing or invalid`);
            if (!ECDH.ecdhAllowed(key))
                throw new errors_js_1.JOSENotSupported('ECDH-ES with the provided key is not allowed or not supported by your javascript runtime');
            const epk = await (0, import_js_1.importJWK)(joseHeader.epk, alg);
            let partyUInfo;
            let partyVInfo;
            if (joseHeader.apu !== undefined) {
                if (typeof joseHeader.apu !== 'string')
                    throw new errors_js_1.JWEInvalid(`JOSE Header "apu" (Agreement PartyUInfo) invalid`);
                partyUInfo = (0, base64url_js_1.decode)(joseHeader.apu);
            }
            if (joseHeader.apv !== undefined) {
                if (typeof joseHeader.apv !== 'string')
                    throw new errors_js_1.JWEInvalid(`JOSE Header "apv" (Agreement PartyVInfo) invalid`);
                partyVInfo = (0, base64url_js_1.decode)(joseHeader.apv);
            }
            const sharedSecret = await ECDH.deriveKey(epk, key, alg === 'ECDH-ES' ? joseHeader.enc : alg, parseInt(alg.substr(-5, 3), 10) || (0, cek_js_1.bitLength)(joseHeader.enc), partyUInfo, partyVInfo);
            if (alg === 'ECDH-ES')
                return sharedSecret;
            if (encryptedKey === undefined)
                throw new errors_js_1.JWEInvalid('JWE Encrypted Key missing');
            return (0, aeskw_js_1.unwrap)(alg.substr(-6), sharedSecret, encryptedKey);
        }
        case 'RSA1_5':
        case 'RSA-OAEP':
        case 'RSA-OAEP-256':
        case 'RSA-OAEP-384':
        case 'RSA-OAEP-512': {
            if (encryptedKey === undefined)
                throw new errors_js_1.JWEInvalid('JWE Encrypted Key missing');
            return (0, rsaes_js_1.decrypt)(alg, key, encryptedKey);
        }
        case 'PBES2-HS256+A128KW':
        case 'PBES2-HS384+A192KW':
        case 'PBES2-HS512+A256KW': {
            if (encryptedKey === undefined)
                throw new errors_js_1.JWEInvalid('JWE Encrypted Key missing');
            if (typeof joseHeader.p2c !== 'number')
                throw new errors_js_1.JWEInvalid(`JOSE Header "p2c" (PBES2 Count) missing or invalid`);
            if (typeof joseHeader.p2s !== 'string')
                throw new errors_js_1.JWEInvalid(`JOSE Header "p2s" (PBES2 Salt) missing or invalid`);
            return (0, pbes2kw_js_1.decrypt)(alg, key, encryptedKey, joseHeader.p2c, (0, base64url_js_1.decode)(joseHeader.p2s));
        }
        case 'A128KW':
        case 'A192KW':
        case 'A256KW': {
            if (encryptedKey === undefined)
                throw new errors_js_1.JWEInvalid('JWE Encrypted Key missing');
            return (0, aeskw_js_1.unwrap)(alg, key, encryptedKey);
        }
        case 'A128GCMKW':
        case 'A192GCMKW':
        case 'A256GCMKW': {
            if (encryptedKey === undefined)
                throw new errors_js_1.JWEInvalid('JWE Encrypted Key missing');
            if (typeof joseHeader.iv !== 'string')
                throw new errors_js_1.JWEInvalid(`JOSE Header "iv" (Initialization Vector) missing or invalid`);
            if (typeof joseHeader.tag !== 'string')
                throw new errors_js_1.JWEInvalid(`JOSE Header "tag" (Authentication Tag) missing or invalid`);
            const iv = (0, base64url_js_1.decode)(joseHeader.iv);
            const tag = (0, base64url_js_1.decode)(joseHeader.tag);
            return (0, aesgcmkw_js_1.unwrap)(alg, key, encryptedKey, iv, tag);
        }
        default: {
            throw new errors_js_1.JOSENotSupported('Invalid or unsupported "alg" (JWE Algorithm) header value');
        }
    }
}
exports.default = decryptKeyManagement;

},{"../key/import.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/node/key/import.js","../lib/cek.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/node/lib/cek.js","../runtime/aeskw.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/node/runtime/aeskw.js","../runtime/base64url.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/node/runtime/base64url.js","../runtime/ecdhes.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/node/runtime/ecdhes.js","../runtime/pbes2kw.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/node/runtime/pbes2kw.js","../runtime/rsaes.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/node/runtime/rsaes.js","../util/errors.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/node/util/errors.js","./aesgcmkw.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/node/lib/aesgcmkw.js","./check_key_type.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/node/lib/check_key_type.js","./is_object.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/node/lib/is_object.js"}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/node/lib/encrypt_key_management.js":[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const aeskw_js_1 = require("../runtime/aeskw.js");
const ECDH = require("../runtime/ecdhes.js");
const pbes2kw_js_1 = require("../runtime/pbes2kw.js");
const rsaes_js_1 = require("../runtime/rsaes.js");
const base64url_js_1 = require("../runtime/base64url.js");
const cek_js_1 = require("../lib/cek.js");
const errors_js_1 = require("../util/errors.js");
const export_js_1 = require("../key/export.js");
const check_key_type_js_1 = require("./check_key_type.js");
const aesgcmkw_js_1 = require("./aesgcmkw.js");
async function encryptKeyManagement(alg, enc, key, providedCek, providedParameters = {}) {
    let encryptedKey;
    let parameters;
    let cek;
    (0, check_key_type_js_1.default)(alg, key, 'encrypt');
    switch (alg) {
        case 'dir': {
            cek = key;
            break;
        }
        case 'ECDH-ES':
        case 'ECDH-ES+A128KW':
        case 'ECDH-ES+A192KW':
        case 'ECDH-ES+A256KW': {
            if (!ECDH.ecdhAllowed(key)) {
                throw new errors_js_1.JOSENotSupported('ECDH-ES with the provided key is not allowed or not supported by your javascript runtime');
            }
            const { apu, apv } = providedParameters;
            let { epk: ephemeralKey } = providedParameters;
            ephemeralKey || (ephemeralKey = await ECDH.generateEpk(key));
            const { x, y, crv, kty } = await (0, export_js_1.exportJWK)(ephemeralKey);
            const sharedSecret = await ECDH.deriveKey(key, ephemeralKey, alg === 'ECDH-ES' ? enc : alg, parseInt(alg.substr(-5, 3), 10) || (0, cek_js_1.bitLength)(enc), apu, apv);
            parameters = { epk: { x, y, crv, kty } };
            if (apu)
                parameters.apu = (0, base64url_js_1.encode)(apu);
            if (apv)
                parameters.apv = (0, base64url_js_1.encode)(apv);
            if (alg === 'ECDH-ES') {
                cek = sharedSecret;
                break;
            }
            cek = providedCek || (0, cek_js_1.default)(enc);
            const kwAlg = alg.substr(-6);
            encryptedKey = await (0, aeskw_js_1.wrap)(kwAlg, sharedSecret, cek);
            break;
        }
        case 'RSA1_5':
        case 'RSA-OAEP':
        case 'RSA-OAEP-256':
        case 'RSA-OAEP-384':
        case 'RSA-OAEP-512': {
            cek = providedCek || (0, cek_js_1.default)(enc);
            encryptedKey = await (0, rsaes_js_1.encrypt)(alg, key, cek);
            break;
        }
        case 'PBES2-HS256+A128KW':
        case 'PBES2-HS384+A192KW':
        case 'PBES2-HS512+A256KW': {
            cek = providedCek || (0, cek_js_1.default)(enc);
            const { p2c, p2s } = providedParameters;
            ({ encryptedKey, ...parameters } = await (0, pbes2kw_js_1.encrypt)(alg, key, cek, p2c, p2s));
            break;
        }
        case 'A128KW':
        case 'A192KW':
        case 'A256KW': {
            cek = providedCek || (0, cek_js_1.default)(enc);
            encryptedKey = await (0, aeskw_js_1.wrap)(alg, key, cek);
            break;
        }
        case 'A128GCMKW':
        case 'A192GCMKW':
        case 'A256GCMKW': {
            cek = providedCek || (0, cek_js_1.default)(enc);
            const { iv } = providedParameters;
            ({ encryptedKey, ...parameters } = await (0, aesgcmkw_js_1.wrap)(alg, key, cek, iv));
            break;
        }
        default: {
            throw new errors_js_1.JOSENotSupported('Invalid or unsupported "alg" (JWE Algorithm) header value');
        }
    }
    return { cek, encryptedKey, parameters };
}
exports.default = encryptKeyManagement;

},{"../key/export.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/node/key/export.js","../lib/cek.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/node/lib/cek.js","../runtime/aeskw.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/node/runtime/aeskw.js","../runtime/base64url.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/node/runtime/base64url.js","../runtime/ecdhes.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/node/runtime/ecdhes.js","../runtime/pbes2kw.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/node/runtime/pbes2kw.js","../runtime/rsaes.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/node/runtime/rsaes.js","../util/errors.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/node/util/errors.js","./aesgcmkw.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/node/lib/aesgcmkw.js","./check_key_type.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/node/lib/check_key_type.js"}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/node/lib/epoch.js":[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = (date) => Math.floor(date.getTime() / 1000);

},{}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/node/lib/format_pem.js":[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = (b64, descriptor) => {
    const newlined = (b64.match(/.{1,64}/g) || []).join('\n');
    return `-----BEGIN ${descriptor}-----\n${newlined}\n-----END ${descriptor}-----`;
};

},{}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/node/lib/invalid_key_input.js":[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = (actual, ...types) => {
    let msg = 'Key must be ';
    if (types.length > 2) {
        const last = types.pop();
        msg += `one of type ${types.join(', ')}, or ${last}.`;
    }
    else if (types.length === 2) {
        msg += `one of type ${types[0]} or ${types[1]}.`;
    }
    else {
        msg += `of type ${types[0]}.`;
    }
    if (actual == null) {
        msg += ` Received ${actual}`;
    }
    else if (typeof actual === 'function' && actual.name) {
        msg += ` Received function ${actual.name}`;
    }
    else if (typeof actual === 'object' && actual != null) {
        if (actual.constructor && actual.constructor.name) {
            msg += ` Received an instance of ${actual.constructor.name}`;
        }
    }
    return msg;
};

},{}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/node/lib/is_disjoint.js":[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const isDisjoint = (...headers) => {
    const sources = headers.filter(Boolean);
    if (sources.length === 0 || sources.length === 1) {
        return true;
    }
    let acc;
    for (const header of sources) {
        const parameters = Object.keys(header);
        if (!acc || acc.size === 0) {
            acc = new Set(parameters);
            continue;
        }
        for (const parameter of parameters) {
            if (acc.has(parameter)) {
                return false;
            }
            acc.add(parameter);
        }
    }
    return true;
};
exports.default = isDisjoint;

},{}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/node/lib/is_object.js":[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
function isObjectLike(value) {
    return typeof value === 'object' && value !== null;
}
function isObject(input) {
    if (!isObjectLike(input) || Object.prototype.toString.call(input) !== '[object Object]') {
        return false;
    }
    if (Object.getPrototypeOf(input) === null) {
        return true;
    }
    let proto = input;
    while (Object.getPrototypeOf(proto) !== null) {
        proto = Object.getPrototypeOf(proto);
    }
    return Object.getPrototypeOf(input) === proto;
}
exports.default = isObject;

},{}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/node/lib/iv.js":[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.bitLength = void 0;
const errors_js_1 = require("../util/errors.js");
const random_js_1 = require("../runtime/random.js");
function bitLength(alg) {
    switch (alg) {
        case 'A128CBC-HS256':
            return 128;
        case 'A128GCM':
            return 96;
        case 'A128GCMKW':
            return 96;
        case 'A192CBC-HS384':
            return 128;
        case 'A192GCM':
            return 96;
        case 'A192GCMKW':
            return 96;
        case 'A256CBC-HS512':
            return 128;
        case 'A256GCM':
            return 96;
        case 'A256GCMKW':
            return 96;
        default:
            throw new errors_js_1.JOSENotSupported(`Unsupported JWE Algorithm: ${alg}`);
    }
}
exports.bitLength = bitLength;
exports.default = (alg) => (0, random_js_1.default)(new Uint8Array(bitLength(alg) >> 3));

},{"../runtime/random.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/node/runtime/random.js","../util/errors.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/node/util/errors.js"}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/node/lib/jwt_claims_set.js":[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const errors_js_1 = require("../util/errors.js");
const buffer_utils_js_1 = require("./buffer_utils.js");
const epoch_js_1 = require("./epoch.js");
const secs_js_1 = require("./secs.js");
const is_object_js_1 = require("./is_object.js");
const normalizeTyp = (value) => value.toLowerCase().replace(/^application\//, '');
const checkAudiencePresence = (audPayload, audOption) => {
    if (typeof audPayload === 'string') {
        return audOption.includes(audPayload);
    }
    if (Array.isArray(audPayload)) {
        return audOption.some(Set.prototype.has.bind(new Set(audPayload)));
    }
    return false;
};
exports.default = (protectedHeader, encodedPayload, options = {}) => {
    const { typ } = options;
    if (typ &&
        (typeof protectedHeader.typ !== 'string' ||
            normalizeTyp(protectedHeader.typ) !== normalizeTyp(typ))) {
        throw new errors_js_1.JWTClaimValidationFailed('unexpected "typ" JWT header value', 'typ', 'check_failed');
    }
    let payload;
    try {
        payload = JSON.parse(buffer_utils_js_1.decoder.decode(encodedPayload));
    }
    catch {
    }
    if (!(0, is_object_js_1.default)(payload)) {
        throw new errors_js_1.JWTInvalid('JWT Claims Set must be a top-level JSON object');
    }
    const { issuer } = options;
    if (issuer && !(Array.isArray(issuer) ? issuer : [issuer]).includes(payload.iss)) {
        throw new errors_js_1.JWTClaimValidationFailed('unexpected "iss" claim value', 'iss', 'check_failed');
    }
    const { subject } = options;
    if (subject && payload.sub !== subject) {
        throw new errors_js_1.JWTClaimValidationFailed('unexpected "sub" claim value', 'sub', 'check_failed');
    }
    const { audience } = options;
    if (audience &&
        !checkAudiencePresence(payload.aud, typeof audience === 'string' ? [audience] : audience)) {
        throw new errors_js_1.JWTClaimValidationFailed('unexpected "aud" claim value', 'aud', 'check_failed');
    }
    let tolerance;
    switch (typeof options.clockTolerance) {
        case 'string':
            tolerance = (0, secs_js_1.default)(options.clockTolerance);
            break;
        case 'number':
            tolerance = options.clockTolerance;
            break;
        case 'undefined':
            tolerance = 0;
            break;
        default:
            throw new TypeError('Invalid clockTolerance option type');
    }
    const { currentDate } = options;
    const now = (0, epoch_js_1.default)(currentDate || new Date());
    if (payload.iat !== undefined || options.maxTokenAge) {
        if (typeof payload.iat !== 'number') {
            throw new errors_js_1.JWTClaimValidationFailed('"iat" claim must be a number', 'iat', 'invalid');
        }
        if (payload.exp === undefined && payload.iat > now + tolerance) {
            throw new errors_js_1.JWTClaimValidationFailed('"iat" claim timestamp check failed (it should be in the past)', 'iat', 'check_failed');
        }
    }
    if (payload.nbf !== undefined) {
        if (typeof payload.nbf !== 'number') {
            throw new errors_js_1.JWTClaimValidationFailed('"nbf" claim must be a number', 'nbf', 'invalid');
        }
        if (payload.nbf > now + tolerance) {
            throw new errors_js_1.JWTClaimValidationFailed('"nbf" claim timestamp check failed', 'nbf', 'check_failed');
        }
    }
    if (payload.exp !== undefined) {
        if (typeof payload.exp !== 'number') {
            throw new errors_js_1.JWTClaimValidationFailed('"exp" claim must be a number', 'exp', 'invalid');
        }
        if (payload.exp <= now - tolerance) {
            throw new errors_js_1.JWTExpired('"exp" claim timestamp check failed', 'exp', 'check_failed');
        }
    }
    if (options.maxTokenAge) {
        const age = now - payload.iat;
        const max = typeof options.maxTokenAge === 'number' ? options.maxTokenAge : (0, secs_js_1.default)(options.maxTokenAge);
        if (age - tolerance > max) {
            throw new errors_js_1.JWTExpired('"iat" claim timestamp check failed (too far in the past)', 'iat', 'check_failed');
        }
        if (age < 0 - tolerance) {
            throw new errors_js_1.JWTClaimValidationFailed('"iat" claim timestamp check failed (it should be in the past)', 'iat', 'check_failed');
        }
    }
    return payload;
};

},{"../util/errors.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/node/util/errors.js","./buffer_utils.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/node/lib/buffer_utils.js","./epoch.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/node/lib/epoch.js","./is_object.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/node/lib/is_object.js","./secs.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/node/lib/secs.js"}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/node/lib/secs.js":[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const minute = 60;
const hour = minute * 60;
const day = hour * 24;
const week = day * 7;
const year = day * 365.25;
const REGEX = /^(\d+|\d+\.\d+) ?(seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)$/i;
exports.default = (str) => {
    const matched = REGEX.exec(str);
    if (!matched) {
        throw new TypeError('Invalid time period format');
    }
    const value = parseFloat(matched[1]);
    const unit = matched[2].toLowerCase();
    switch (unit) {
        case 'sec':
        case 'secs':
        case 'second':
        case 'seconds':
        case 's':
            return Math.round(value);
        case 'minute':
        case 'minutes':
        case 'min':
        case 'mins':
        case 'm':
            return Math.round(value * minute);
        case 'hour':
        case 'hours':
        case 'hr':
        case 'hrs':
        case 'h':
            return Math.round(value * hour);
        case 'day':
        case 'days':
        case 'd':
            return Math.round(value * day);
        case 'week':
        case 'weeks':
        case 'w':
            return Math.round(value * week);
        default:
            return Math.round(value * year);
    }
};

},{}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/node/lib/validate_algorithms.js":[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const validateAlgorithms = (option, algorithms) => {
    if (algorithms !== undefined &&
        (!Array.isArray(algorithms) || algorithms.some((s) => typeof s !== 'string'))) {
        throw new TypeError(`"${option}" option must be an array of strings`);
    }
    if (!algorithms) {
        return undefined;
    }
    return new Set(algorithms);
};
exports.default = validateAlgorithms;

},{}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/node/lib/validate_crit.js":[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const errors_js_1 = require("../util/errors.js");
function validateCrit(Err, recognizedDefault, recognizedOption, protectedHeader, joseHeader) {
    if (joseHeader.crit !== undefined && protectedHeader.crit === undefined) {
        throw new Err('"crit" (Critical) Header Parameter MUST be integrity protected');
    }
    if (!protectedHeader || protectedHeader.crit === undefined) {
        return new Set();
    }
    if (!Array.isArray(protectedHeader.crit) ||
        protectedHeader.crit.length === 0 ||
        protectedHeader.crit.some((input) => typeof input !== 'string' || input.length === 0)) {
        throw new Err('"crit" (Critical) Header Parameter MUST be an array of non-empty strings when present');
    }
    let recognized;
    if (recognizedOption !== undefined) {
        recognized = new Map([...Object.entries(recognizedOption), ...recognizedDefault.entries()]);
    }
    else {
        recognized = recognizedDefault;
    }
    for (const parameter of protectedHeader.crit) {
        if (!recognized.has(parameter)) {
            throw new errors_js_1.JOSENotSupported(`Extension Header Parameter "${parameter}" is not recognized`);
        }
        if (joseHeader[parameter] === undefined) {
            throw new Err(`Extension Header Parameter "${parameter}" is missing`);
        }
        else if (recognized.get(parameter) && protectedHeader[parameter] === undefined) {
            throw new Err(`Extension Header Parameter "${parameter}" MUST be integrity protected`);
        }
    }
    return new Set(protectedHeader.crit);
}
exports.default = validateCrit;

},{"../util/errors.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/node/util/errors.js"}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/node/runtime/aeskw.js":[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.unwrap = exports.wrap = void 0;
const buffer_1 = require("buffer");
const crypto_1 = require("crypto");
const errors_js_1 = require("../util/errors.js");
const buffer_utils_js_1 = require("../lib/buffer_utils.js");
const secret_key_js_1 = require("./secret_key.js");
const webcrypto_js_1 = require("./webcrypto.js");
const crypto_key_js_1 = require("../lib/crypto_key.js");
const is_key_object_js_1 = require("./is_key_object.js");
const invalid_key_input_js_1 = require("../lib/invalid_key_input.js");
const ciphers_js_1 = require("./ciphers.js");
function checkKeySize(key, alg) {
    if (key.symmetricKeySize << 3 !== parseInt(alg.substr(1, 3), 10)) {
        throw new TypeError(`Invalid key size for alg: ${alg}`);
    }
}
function ensureKeyObject(key, alg, usage) {
    if ((0, is_key_object_js_1.default)(key)) {
        return key;
    }
    if (key instanceof Uint8Array) {
        return (0, secret_key_js_1.default)(key);
    }
    if ((0, webcrypto_js_1.isCryptoKey)(key)) {
        (0, crypto_key_js_1.checkEncCryptoKey)(key, alg, usage);
        return crypto_1.KeyObject.from(key);
    }
    throw new TypeError((0, invalid_key_input_js_1.default)(key, 'KeyObject', 'CryptoKey', 'Uint8Array'));
}
const wrap = async (alg, key, cek) => {
    const size = parseInt(alg.substr(1, 3), 10);
    const algorithm = `aes${size}-wrap`;
    if (!(0, ciphers_js_1.default)(algorithm)) {
        throw new errors_js_1.JOSENotSupported(`alg ${alg} is not supported either by JOSE or your javascript runtime`);
    }
    const keyObject = ensureKeyObject(key, alg, 'wrapKey');
    checkKeySize(keyObject, alg);
    const cipher = (0, crypto_1.createCipheriv)(algorithm, keyObject, buffer_1.Buffer.alloc(8, 0xa6));
    return (0, buffer_utils_js_1.concat)(cipher.update(cek), cipher.final());
};
exports.wrap = wrap;
const unwrap = async (alg, key, encryptedKey) => {
    const size = parseInt(alg.substr(1, 3), 10);
    const algorithm = `aes${size}-wrap`;
    if (!(0, ciphers_js_1.default)(algorithm)) {
        throw new errors_js_1.JOSENotSupported(`alg ${alg} is not supported either by JOSE or your javascript runtime`);
    }
    const keyObject = ensureKeyObject(key, alg, 'unwrapKey');
    checkKeySize(keyObject, alg);
    const cipher = (0, crypto_1.createDecipheriv)(algorithm, keyObject, buffer_1.Buffer.alloc(8, 0xa6));
    return (0, buffer_utils_js_1.concat)(cipher.update(encryptedKey), cipher.final());
};
exports.unwrap = unwrap;

},{"../lib/buffer_utils.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/node/lib/buffer_utils.js","../lib/crypto_key.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/node/lib/crypto_key.js","../lib/invalid_key_input.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/node/lib/invalid_key_input.js","../util/errors.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/node/util/errors.js","./ciphers.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/node/runtime/ciphers.js","./is_key_object.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/node/runtime/is_key_object.js","./secret_key.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/node/runtime/secret_key.js","./webcrypto.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/node/runtime/webcrypto.js","buffer":false,"crypto":false}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/node/runtime/asn1.js":[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.fromSPKI = exports.fromPKCS8 = exports.toPKCS8 = exports.toSPKI = void 0;
const crypto_1 = require("crypto");
const buffer_1 = require("buffer");
const webcrypto_js_1 = require("./webcrypto.js");
const is_key_object_js_1 = require("./is_key_object.js");
const invalid_key_input_js_1 = require("../lib/invalid_key_input.js");
const genericExport = (keyType, keyFormat, key) => {
    let keyObject;
    if ((0, webcrypto_js_1.isCryptoKey)(key)) {
        if (!key.extractable) {
            throw new TypeError('CryptoKey is not extractable');
        }
        keyObject = crypto_1.KeyObject.from(key);
    }
    else if ((0, is_key_object_js_1.default)(key)) {
        keyObject = key;
    }
    else {
        throw new TypeError((0, invalid_key_input_js_1.default)(key, 'KeyObject', 'CryptoKey'));
    }
    if (keyObject.type !== keyType) {
        throw new TypeError(`key is not a ${keyType} key`);
    }
    return keyObject.export({ format: 'pem', type: keyFormat });
};
const toSPKI = (key) => {
    return genericExport('public', 'spki', key);
};
exports.toSPKI = toSPKI;
const toPKCS8 = (key) => {
    return genericExport('private', 'pkcs8', key);
};
exports.toPKCS8 = toPKCS8;
const fromPKCS8 = (pem) => (0, crypto_1.createPrivateKey)({
    key: buffer_1.Buffer.from(pem.replace(/(?:-----(?:BEGIN|END) PRIVATE KEY-----|\s)/g, ''), 'base64'),
    type: 'pkcs8',
    format: 'der',
});
exports.fromPKCS8 = fromPKCS8;
const fromSPKI = (pem) => (0, crypto_1.createPublicKey)({
    key: buffer_1.Buffer.from(pem.replace(/(?:-----(?:BEGIN|END) PUBLIC KEY-----|\s)/g, ''), 'base64'),
    type: 'spki',
    format: 'der',
});
exports.fromSPKI = fromSPKI;

},{"../lib/invalid_key_input.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/node/lib/invalid_key_input.js","./is_key_object.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/node/runtime/is_key_object.js","./webcrypto.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/node/runtime/webcrypto.js","buffer":false,"crypto":false}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/node/runtime/asn1_sequence_decoder.js":[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tagInteger = 0x02;
const tagSequence = 0x30;
class Asn1SequenceDecoder {
    constructor(buffer) {
        if (buffer[0] !== tagSequence) {
            throw new TypeError();
        }
        this.buffer = buffer;
        this.offset = 1;
        const len = this.decodeLength();
        if (len !== buffer.length - this.offset) {
            throw new TypeError();
        }
    }
    decodeLength() {
        let length = this.buffer[this.offset++];
        if (length & 0x80) {
            const nBytes = length & ~0x80;
            length = 0;
            for (let i = 0; i < nBytes; i++)
                length = (length << 8) | this.buffer[this.offset + i];
            this.offset += nBytes;
        }
        return length;
    }
    unsignedInteger() {
        if (this.buffer[this.offset++] !== tagInteger) {
            throw new TypeError();
        }
        let length = this.decodeLength();
        if (this.buffer[this.offset] === 0) {
            this.offset++;
            length--;
        }
        const result = this.buffer.slice(this.offset, this.offset + length);
        this.offset += length;
        return result;
    }
    end() {
        if (this.offset !== this.buffer.length) {
            throw new TypeError();
        }
    }
}
exports.default = Asn1SequenceDecoder;

},{}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/node/runtime/asn1_sequence_encoder.js":[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const buffer_1 = require("buffer");
const errors_js_1 = require("../util/errors.js");
const tagInteger = 0x02;
const tagBitStr = 0x03;
const tagOctStr = 0x04;
const tagSequence = 0x30;
const bZero = buffer_1.Buffer.from([0x00]);
const bTagInteger = buffer_1.Buffer.from([tagInteger]);
const bTagBitStr = buffer_1.Buffer.from([tagBitStr]);
const bTagSequence = buffer_1.Buffer.from([tagSequence]);
const bTagOctStr = buffer_1.Buffer.from([tagOctStr]);
const encodeLength = (len) => {
    if (len < 128)
        return buffer_1.Buffer.from([len]);
    const buffer = buffer_1.Buffer.alloc(5);
    buffer.writeUInt32BE(len, 1);
    let offset = 1;
    while (buffer[offset] === 0)
        offset++;
    buffer[offset - 1] = 0x80 | (5 - offset);
    return buffer.slice(offset - 1);
};
const oids = new Map([
    ['P-256', buffer_1.Buffer.from('06 08 2A 86 48 CE 3D 03 01 07'.replace(/ /g, ''), 'hex')],
    ['secp256k1', buffer_1.Buffer.from('06 05 2B 81 04 00 0A'.replace(/ /g, ''), 'hex')],
    ['P-384', buffer_1.Buffer.from('06 05 2B 81 04 00 22'.replace(/ /g, ''), 'hex')],
    ['P-521', buffer_1.Buffer.from('06 05 2B 81 04 00 23'.replace(/ /g, ''), 'hex')],
    ['ecPublicKey', buffer_1.Buffer.from('06 07 2A 86 48 CE 3D 02 01'.replace(/ /g, ''), 'hex')],
    ['X25519', buffer_1.Buffer.from('06 03 2B 65 6E'.replace(/ /g, ''), 'hex')],
    ['X448', buffer_1.Buffer.from('06 03 2B 65 6F'.replace(/ /g, ''), 'hex')],
    ['Ed25519', buffer_1.Buffer.from('06 03 2B 65 70'.replace(/ /g, ''), 'hex')],
    ['Ed448', buffer_1.Buffer.from('06 03 2B 65 71'.replace(/ /g, ''), 'hex')],
]);
class DumbAsn1Encoder {
    constructor() {
        this.length = 0;
        this.elements = [];
    }
    oidFor(oid) {
        const bOid = oids.get(oid);
        if (!bOid) {
            throw new errors_js_1.JOSENotSupported('Invalid or unsupported OID');
        }
        this.elements.push(bOid);
        this.length += bOid.length;
    }
    zero() {
        this.elements.push(bTagInteger, buffer_1.Buffer.from([0x01]), bZero);
        this.length += 3;
    }
    one() {
        this.elements.push(bTagInteger, buffer_1.Buffer.from([0x01]), buffer_1.Buffer.from([0x01]));
        this.length += 3;
    }
    unsignedInteger(integer) {
        if (integer[0] & 0x80) {
            const len = encodeLength(integer.length + 1);
            this.elements.push(bTagInteger, len, bZero, integer);
            this.length += 2 + len.length + integer.length;
        }
        else {
            let i = 0;
            while (integer[i] === 0 && (integer[i + 1] & 0x80) === 0)
                i++;
            const len = encodeLength(integer.length - i);
            this.elements.push(bTagInteger, encodeLength(integer.length - i), integer.slice(i));
            this.length += 1 + len.length + integer.length - i;
        }
    }
    octStr(octStr) {
        const len = encodeLength(octStr.length);
        this.elements.push(bTagOctStr, encodeLength(octStr.length), octStr);
        this.length += 1 + len.length + octStr.length;
    }
    bitStr(bitS) {
        const len = encodeLength(bitS.length + 1);
        this.elements.push(bTagBitStr, encodeLength(bitS.length + 1), bZero, bitS);
        this.length += 1 + len.length + bitS.length + 1;
    }
    add(seq) {
        this.elements.push(seq);
        this.length += seq.length;
    }
    end(tag = bTagSequence) {
        const len = encodeLength(this.length);
        return buffer_1.Buffer.concat([tag, len, ...this.elements], 1 + len.length + this.length);
    }
}
exports.default = DumbAsn1Encoder;

},{"../util/errors.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/node/util/errors.js","buffer":false}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/node/runtime/base64url.js":[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.decode = exports.encode = exports.encodeBase64 = exports.decodeBase64 = void 0;
const buffer_1 = require("buffer");
const buffer_utils_js_1 = require("../lib/buffer_utils.js");
let encodeImpl;
function normalize(input) {
    let encoded = input;
    if (encoded instanceof Uint8Array) {
        encoded = buffer_utils_js_1.decoder.decode(encoded);
    }
    return encoded;
}
if (buffer_1.Buffer.isEncoding('base64url')) {
    encodeImpl = (input) => buffer_1.Buffer.from(input).toString('base64url');
}
else {
    encodeImpl = (input) => buffer_1.Buffer.from(input).toString('base64').replace(/=/g, '').replace(/\+/g, '-').replace(/\//g, '_');
}
const decodeBase64 = (input) => buffer_1.Buffer.from(input, 'base64');
exports.decodeBase64 = decodeBase64;
const encodeBase64 = (input) => buffer_1.Buffer.from(input).toString('base64');
exports.encodeBase64 = encodeBase64;
exports.encode = encodeImpl;
const decode = (input) => buffer_1.Buffer.from(normalize(input), 'base64');
exports.decode = decode;

},{"../lib/buffer_utils.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/node/lib/buffer_utils.js","buffer":false}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/node/runtime/cbc_tag.js":[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const crypto_1 = require("crypto");
const buffer_utils_js_1 = require("../lib/buffer_utils.js");
function cbcTag(aad, iv, ciphertext, macSize, macKey, keySize) {
    const macData = (0, buffer_utils_js_1.concat)(aad, iv, ciphertext, (0, buffer_utils_js_1.uint64be)(aad.length << 3));
    const hmac = (0, crypto_1.createHmac)(`sha${macSize}`, macKey);
    hmac.update(macData);
    return hmac.digest().slice(0, keySize >> 3);
}
exports.default = cbcTag;

},{"../lib/buffer_utils.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/node/lib/buffer_utils.js","crypto":false}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/node/runtime/check_cek_length.js":[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const errors_js_1 = require("../util/errors.js");
const is_key_object_js_1 = require("./is_key_object.js");
const checkCekLength = (enc, cek) => {
    let expected;
    switch (enc) {
        case 'A128CBC-HS256':
        case 'A192CBC-HS384':
        case 'A256CBC-HS512':
            expected = parseInt(enc.substr(-3), 10);
            break;
        case 'A128GCM':
        case 'A192GCM':
        case 'A256GCM':
            expected = parseInt(enc.substr(1, 3), 10);
            break;
        default:
            throw new errors_js_1.JOSENotSupported(`Content Encryption Algorithm ${enc} is not supported either by JOSE or your javascript runtime`);
    }
    if (cek instanceof Uint8Array) {
        if (cek.length << 3 !== expected) {
            throw new errors_js_1.JWEInvalid('Invalid Content Encryption Key length');
        }
        return;
    }
    if ((0, is_key_object_js_1.default)(cek) && cek.type === 'secret') {
        if (cek.symmetricKeySize << 3 !== expected) {
            throw new errors_js_1.JWEInvalid('Invalid Content Encryption Key length');
        }
        return;
    }
    throw new TypeError('Invalid Content Encryption Key type');
};
exports.default = checkCekLength;

},{"../util/errors.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/node/util/errors.js","./is_key_object.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/node/runtime/is_key_object.js"}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/node/runtime/check_modulus_length.js":[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.setModulusLength = exports.weakMap = void 0;
exports.weakMap = new WeakMap();
const getLength = (buf, index) => {
    let len = buf.readUInt8(1);
    if ((len & 0x80) === 0) {
        if (index === 0) {
            return len;
        }
        return getLength(buf.subarray(2 + len), index - 1);
    }
    const num = len & 0x7f;
    len = 0;
    for (let i = 0; i < num; i++) {
        len <<= 8;
        const j = buf.readUInt8(2 + i);
        len |= j;
    }
    if (index === 0) {
        return len;
    }
    return getLength(buf.subarray(2 + len), index - 1);
};
const getLengthOfSeqIndex = (sequence, index) => {
    const len = sequence.readUInt8(1);
    if ((len & 0x80) === 0) {
        return getLength(sequence.subarray(2), index);
    }
    const num = len & 0x7f;
    return getLength(sequence.subarray(2 + num), index);
};
const getModulusLength = (key) => {
    var _a, _b;
    if (exports.weakMap.has(key)) {
        return exports.weakMap.get(key);
    }
    const modulusLength = (_b = (_a = key.asymmetricKeyDetails) === null || _a === void 0 ? void 0 : _a.modulusLength) !== null && _b !== void 0 ? _b : (getLengthOfSeqIndex(key.export({ format: 'der', type: 'pkcs1' }), key.type === 'private' ? 1 : 0) -
        1) <<
        3;
    exports.weakMap.set(key, modulusLength);
    return modulusLength;
};
const setModulusLength = (keyObject, modulusLength) => {
    exports.weakMap.set(keyObject, modulusLength);
};
exports.setModulusLength = setModulusLength;
exports.default = (key, alg) => {
    if (getModulusLength(key) < 2048) {
        throw new TypeError(`${alg} requires key modulusLength to be 2048 bits or larger`);
    }
};

},{}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/node/runtime/ciphers.js":[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const crypto_1 = require("crypto");
let ciphers;
exports.default = (algorithm) => {
    ciphers || (ciphers = new Set((0, crypto_1.getCiphers)()));
    return ciphers.has(algorithm);
};

},{"crypto":false}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/node/runtime/decrypt.js":[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const crypto_1 = require("crypto");
const check_iv_length_js_1 = require("../lib/check_iv_length.js");
const check_cek_length_js_1 = require("./check_cek_length.js");
const buffer_utils_js_1 = require("../lib/buffer_utils.js");
const errors_js_1 = require("../util/errors.js");
const timing_safe_equal_js_1 = require("./timing_safe_equal.js");
const cbc_tag_js_1 = require("./cbc_tag.js");
const webcrypto_js_1 = require("./webcrypto.js");
const crypto_key_js_1 = require("../lib/crypto_key.js");
const is_key_object_js_1 = require("./is_key_object.js");
const invalid_key_input_js_1 = require("../lib/invalid_key_input.js");
const ciphers_js_1 = require("./ciphers.js");
async function cbcDecrypt(enc, cek, ciphertext, iv, tag, aad) {
    const keySize = parseInt(enc.substr(1, 3), 10);
    if ((0, is_key_object_js_1.default)(cek)) {
        cek = cek.export();
    }
    const encKey = cek.subarray(keySize >> 3);
    const macKey = cek.subarray(0, keySize >> 3);
    const macSize = parseInt(enc.substr(-3), 10);
    const algorithm = `aes-${keySize}-cbc`;
    if (!(0, ciphers_js_1.default)(algorithm)) {
        throw new errors_js_1.JOSENotSupported(`alg ${enc} is not supported by your javascript runtime`);
    }
    const expectedTag = (0, cbc_tag_js_1.default)(aad, iv, ciphertext, macSize, macKey, keySize);
    let macCheckPassed;
    try {
        macCheckPassed = (0, timing_safe_equal_js_1.default)(tag, expectedTag);
    }
    catch {
    }
    if (!macCheckPassed) {
        throw new errors_js_1.JWEDecryptionFailed();
    }
    let plaintext;
    try {
        const cipher = (0, crypto_1.createDecipheriv)(algorithm, encKey, iv);
        plaintext = (0, buffer_utils_js_1.concat)(cipher.update(ciphertext), cipher.final());
    }
    catch {
    }
    if (!plaintext) {
        throw new errors_js_1.JWEDecryptionFailed();
    }
    return plaintext;
}
async function gcmDecrypt(enc, cek, ciphertext, iv, tag, aad) {
    const keySize = parseInt(enc.substr(1, 3), 10);
    const algorithm = `aes-${keySize}-gcm`;
    if (!(0, ciphers_js_1.default)(algorithm)) {
        throw new errors_js_1.JOSENotSupported(`alg ${enc} is not supported by your javascript runtime`);
    }
    try {
        const cipher = (0, crypto_1.createDecipheriv)(algorithm, cek, iv, { authTagLength: 16 });
        cipher.setAuthTag(tag);
        if (aad.byteLength) {
            cipher.setAAD(aad, { plaintextLength: ciphertext.length });
        }
        return (0, buffer_utils_js_1.concat)(cipher.update(ciphertext), cipher.final());
    }
    catch {
        throw new errors_js_1.JWEDecryptionFailed();
    }
}
const decrypt = async (enc, cek, ciphertext, iv, tag, aad) => {
    let key;
    if ((0, webcrypto_js_1.isCryptoKey)(cek)) {
        (0, crypto_key_js_1.checkEncCryptoKey)(cek, enc, 'decrypt');
        key = crypto_1.KeyObject.from(cek);
    }
    else if (cek instanceof Uint8Array || (0, is_key_object_js_1.default)(cek)) {
        key = cek;
    }
    else {
        throw new TypeError((0, invalid_key_input_js_1.default)(cek, 'KeyObject', 'CryptoKey', 'Uint8Array'));
    }
    (0, check_cek_length_js_1.default)(enc, key);
    (0, check_iv_length_js_1.default)(enc, iv);
    switch (enc) {
        case 'A128CBC-HS256':
        case 'A192CBC-HS384':
        case 'A256CBC-HS512':
            return cbcDecrypt(enc, key, ciphertext, iv, tag, aad);
        case 'A128GCM':
        case 'A192GCM':
        case 'A256GCM':
            return gcmDecrypt(enc, key, ciphertext, iv, tag, aad);
        default:
            throw new errors_js_1.JOSENotSupported('Unsupported JWE Content Encryption Algorithm');
    }
};
exports.default = decrypt;

},{"../lib/buffer_utils.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/node/lib/buffer_utils.js","../lib/check_iv_length.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/node/lib/check_iv_length.js","../lib/crypto_key.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/node/lib/crypto_key.js","../lib/invalid_key_input.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/node/lib/invalid_key_input.js","../util/errors.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/node/util/errors.js","./cbc_tag.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/node/runtime/cbc_tag.js","./check_cek_length.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/node/runtime/check_cek_length.js","./ciphers.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/node/runtime/ciphers.js","./is_key_object.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/node/runtime/is_key_object.js","./timing_safe_equal.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/node/runtime/timing_safe_equal.js","./webcrypto.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/node/runtime/webcrypto.js","crypto":false}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/node/runtime/digest.js":[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const crypto_1 = require("crypto");
const digest = (algorithm, data) => (0, crypto_1.createHash)(algorithm).update(data).digest();
exports.default = digest;

},{"crypto":false}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/node/runtime/dsa_digest.js":[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const errors_js_1 = require("../util/errors.js");
function dsaDigest(alg) {
    switch (alg) {
        case 'PS256':
        case 'RS256':
        case 'ES256':
        case 'ES256K':
            return 'sha256';
        case 'PS384':
        case 'RS384':
        case 'ES384':
            return 'sha384';
        case 'PS512':
        case 'RS512':
        case 'ES512':
            return 'sha512';
        case 'EdDSA':
            return undefined;
        default:
            throw new errors_js_1.JOSENotSupported(`alg ${alg} is not supported either by JOSE or your javascript runtime`);
    }
}
exports.default = dsaDigest;

},{"../util/errors.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/node/util/errors.js"}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/node/runtime/ecdhes.js":[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ecdhAllowed = exports.generateEpk = exports.deriveKey = void 0;
const crypto_1 = require("crypto");
const util_1 = require("util");
const get_named_curve_js_1 = require("./get_named_curve.js");
const buffer_utils_js_1 = require("../lib/buffer_utils.js");
const digest_js_1 = require("./digest.js");
const errors_js_1 = require("../util/errors.js");
const webcrypto_js_1 = require("./webcrypto.js");
const crypto_key_js_1 = require("../lib/crypto_key.js");
const is_key_object_js_1 = require("./is_key_object.js");
const invalid_key_input_js_1 = require("../lib/invalid_key_input.js");
const generateKeyPair = (0, util_1.promisify)(crypto_1.generateKeyPair);
const deriveKey = async (publicKee, privateKee, algorithm, keyLength, apu = new Uint8Array(0), apv = new Uint8Array(0)) => {
    let publicKey;
    if ((0, webcrypto_js_1.isCryptoKey)(publicKee)) {
        (0, crypto_key_js_1.checkEncCryptoKey)(publicKee, 'ECDH-ES');
        publicKey = crypto_1.KeyObject.from(publicKee);
    }
    else if ((0, is_key_object_js_1.default)(publicKee)) {
        publicKey = publicKee;
    }
    else {
        throw new TypeError((0, invalid_key_input_js_1.default)(publicKee, 'KeyObject', 'CryptoKey'));
    }
    let privateKey;
    if ((0, webcrypto_js_1.isCryptoKey)(privateKee)) {
        (0, crypto_key_js_1.checkEncCryptoKey)(privateKee, 'ECDH-ES', 'deriveBits', 'deriveKey');
        privateKey = crypto_1.KeyObject.from(privateKee);
    }
    else if ((0, is_key_object_js_1.default)(privateKee)) {
        privateKey = privateKee;
    }
    else {
        throw new TypeError((0, invalid_key_input_js_1.default)(privateKee, 'KeyObject', 'CryptoKey'));
    }
    const value = (0, buffer_utils_js_1.concat)((0, buffer_utils_js_1.lengthAndInput)(buffer_utils_js_1.encoder.encode(algorithm)), (0, buffer_utils_js_1.lengthAndInput)(apu), (0, buffer_utils_js_1.lengthAndInput)(apv), (0, buffer_utils_js_1.uint32be)(keyLength));
    const sharedSecret = (0, crypto_1.diffieHellman)({ privateKey, publicKey });
    return (0, buffer_utils_js_1.concatKdf)(digest_js_1.default, sharedSecret, keyLength, value);
};
exports.deriveKey = deriveKey;
const generateEpk = async (kee) => {
    let key;
    if ((0, webcrypto_js_1.isCryptoKey)(kee)) {
        key = crypto_1.KeyObject.from(kee);
    }
    else if ((0, is_key_object_js_1.default)(kee)) {
        key = kee;
    }
    else {
        throw new TypeError((0, invalid_key_input_js_1.default)(kee, 'KeyObject', 'CryptoKey'));
    }
    switch (key.asymmetricKeyType) {
        case 'x25519':
            return (await generateKeyPair('x25519')).privateKey;
        case 'x448': {
            return (await generateKeyPair('x448')).privateKey;
        }
        case 'ec': {
            const namedCurve = (0, get_named_curve_js_1.default)(key);
            return (await generateKeyPair('ec', { namedCurve })).privateKey;
        }
        default:
            throw new errors_js_1.JOSENotSupported('Invalid or unsupported EPK');
    }
};
exports.generateEpk = generateEpk;
const ecdhAllowed = (key) => ['P-256', 'P-384', 'P-521', 'X25519', 'X448'].includes((0, get_named_curve_js_1.default)(key));
exports.ecdhAllowed = ecdhAllowed;

},{"../lib/buffer_utils.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/node/lib/buffer_utils.js","../lib/crypto_key.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/node/lib/crypto_key.js","../lib/invalid_key_input.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/node/lib/invalid_key_input.js","../util/errors.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/node/util/errors.js","./digest.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/node/runtime/digest.js","./get_named_curve.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/node/runtime/get_named_curve.js","./is_key_object.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/node/runtime/is_key_object.js","./webcrypto.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/node/runtime/webcrypto.js","crypto":false,"util":false}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/node/runtime/encrypt.js":[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const crypto_1 = require("crypto");
const check_iv_length_js_1 = require("../lib/check_iv_length.js");
const check_cek_length_js_1 = require("./check_cek_length.js");
const buffer_utils_js_1 = require("../lib/buffer_utils.js");
const cbc_tag_js_1 = require("./cbc_tag.js");
const webcrypto_js_1 = require("./webcrypto.js");
const crypto_key_js_1 = require("../lib/crypto_key.js");
const is_key_object_js_1 = require("./is_key_object.js");
const invalid_key_input_js_1 = require("../lib/invalid_key_input.js");
const errors_js_1 = require("../util/errors.js");
const ciphers_js_1 = require("./ciphers.js");
async function cbcEncrypt(enc, plaintext, cek, iv, aad) {
    const keySize = parseInt(enc.substr(1, 3), 10);
    if ((0, is_key_object_js_1.default)(cek)) {
        cek = cek.export();
    }
    const encKey = cek.subarray(keySize >> 3);
    const macKey = cek.subarray(0, keySize >> 3);
    const algorithm = `aes-${keySize}-cbc`;
    if (!(0, ciphers_js_1.default)(algorithm)) {
        throw new errors_js_1.JOSENotSupported(`alg ${enc} is not supported by your javascript runtime`);
    }
    const cipher = (0, crypto_1.createCipheriv)(algorithm, encKey, iv);
    const ciphertext = (0, buffer_utils_js_1.concat)(cipher.update(plaintext), cipher.final());
    const macSize = parseInt(enc.substr(-3), 10);
    const tag = (0, cbc_tag_js_1.default)(aad, iv, ciphertext, macSize, macKey, keySize);
    return { ciphertext, tag };
}
async function gcmEncrypt(enc, plaintext, cek, iv, aad) {
    const keySize = parseInt(enc.substr(1, 3), 10);
    const algorithm = `aes-${keySize}-gcm`;
    if (!(0, ciphers_js_1.default)(algorithm)) {
        throw new errors_js_1.JOSENotSupported(`alg ${enc} is not supported by your javascript runtime`);
    }
    const cipher = (0, crypto_1.createCipheriv)(algorithm, cek, iv, { authTagLength: 16 });
    if (aad.byteLength) {
        cipher.setAAD(aad, { plaintextLength: plaintext.length });
    }
    const ciphertext = (0, buffer_utils_js_1.concat)(cipher.update(plaintext), cipher.final());
    const tag = cipher.getAuthTag();
    return { ciphertext, tag };
}
const encrypt = async (enc, plaintext, cek, iv, aad) => {
    let key;
    if ((0, webcrypto_js_1.isCryptoKey)(cek)) {
        (0, crypto_key_js_1.checkEncCryptoKey)(cek, enc, 'encrypt');
        key = crypto_1.KeyObject.from(cek);
    }
    else if (cek instanceof Uint8Array || (0, is_key_object_js_1.default)(cek)) {
        key = cek;
    }
    else {
        throw new TypeError((0, invalid_key_input_js_1.default)(cek, 'KeyObject', 'CryptoKey', 'Uint8Array'));
    }
    (0, check_cek_length_js_1.default)(enc, key);
    (0, check_iv_length_js_1.default)(enc, iv);
    switch (enc) {
        case 'A128CBC-HS256':
        case 'A192CBC-HS384':
        case 'A256CBC-HS512':
            return cbcEncrypt(enc, plaintext, key, iv, aad);
        case 'A128GCM':
        case 'A192GCM':
        case 'A256GCM':
            return gcmEncrypt(enc, plaintext, key, iv, aad);
        default:
            throw new errors_js_1.JOSENotSupported('Unsupported JWE Content Encryption Algorithm');
    }
};
exports.default = encrypt;

},{"../lib/buffer_utils.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/node/lib/buffer_utils.js","../lib/check_iv_length.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/node/lib/check_iv_length.js","../lib/crypto_key.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/node/lib/crypto_key.js","../lib/invalid_key_input.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/node/lib/invalid_key_input.js","../util/errors.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/node/util/errors.js","./cbc_tag.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/node/runtime/cbc_tag.js","./check_cek_length.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/node/runtime/check_cek_length.js","./ciphers.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/node/runtime/ciphers.js","./is_key_object.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/node/runtime/is_key_object.js","./webcrypto.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/node/runtime/webcrypto.js","crypto":false}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/node/runtime/fetch_jwks.js":[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const http = require("http");
const https = require("https");
const events_1 = require("events");
const errors_js_1 = require("../util/errors.js");
const buffer_utils_js_1 = require("../lib/buffer_utils.js");
const fetchJwks = async (url, timeout, options) => {
    let get;
    switch (url.protocol) {
        case 'https:':
            get = https.get;
            break;
        case 'http:':
            get = http.get;
            break;
        default:
            throw new TypeError('Unsupported URL protocol.');
    }
    const { agent } = options;
    const req = get(url.href, {
        agent,
        timeout,
    });
    const [response] = (await Promise.race([(0, events_1.once)(req, 'response'), (0, events_1.once)(req, 'timeout')]));
    if (!response) {
        req.destroy();
        throw new errors_js_1.JWKSTimeout();
    }
    if (response.statusCode !== 200) {
        throw new errors_js_1.JOSEError('Expected 200 OK from the JSON Web Key Set HTTP response');
    }
    const parts = [];
    for await (const part of response) {
        parts.push(part);
    }
    try {
        return JSON.parse(buffer_utils_js_1.decoder.decode((0, buffer_utils_js_1.concat)(...parts)));
    }
    catch {
        throw new errors_js_1.JOSEError('Failed to parse the JSON Web Key Set HTTP response as JSON');
    }
};
exports.default = fetchJwks;

},{"../lib/buffer_utils.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/node/lib/buffer_utils.js","../util/errors.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/node/util/errors.js","events":false,"http":false,"https":false}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/node/runtime/generate.js":[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.generateKeyPair = exports.generateSecret = void 0;
const crypto_1 = require("crypto");
const util_1 = require("util");
const random_js_1 = require("./random.js");
const check_modulus_length_js_1 = require("./check_modulus_length.js");
const errors_js_1 = require("../util/errors.js");
const generate = (0, util_1.promisify)(crypto_1.generateKeyPair);
async function generateSecret(alg) {
    let length;
    switch (alg) {
        case 'HS256':
        case 'HS384':
        case 'HS512':
        case 'A128CBC-HS256':
        case 'A192CBC-HS384':
        case 'A256CBC-HS512':
            length = parseInt(alg.substr(-3), 10);
            break;
        case 'A128KW':
        case 'A192KW':
        case 'A256KW':
        case 'A128GCMKW':
        case 'A192GCMKW':
        case 'A256GCMKW':
        case 'A128GCM':
        case 'A192GCM':
        case 'A256GCM':
            length = parseInt(alg.substring(1, 4), 10);
            break;
        default:
            throw new errors_js_1.JOSENotSupported('Invalid or unsupported JWK "alg" (Algorithm) Parameter value');
    }
    return (0, crypto_1.createSecretKey)((0, random_js_1.default)(new Uint8Array(length >> 3)));
}
exports.generateSecret = generateSecret;
async function generateKeyPair(alg, options) {
    var _a, _b;
    switch (alg) {
        case 'RS256':
        case 'RS384':
        case 'RS512':
        case 'PS256':
        case 'PS384':
        case 'PS512':
        case 'RSA-OAEP':
        case 'RSA-OAEP-256':
        case 'RSA-OAEP-384':
        case 'RSA-OAEP-512':
        case 'RSA1_5': {
            const modulusLength = (_a = options === null || options === void 0 ? void 0 : options.modulusLength) !== null && _a !== void 0 ? _a : 2048;
            if (typeof modulusLength !== 'number' || modulusLength < 2048) {
                throw new errors_js_1.JOSENotSupported('Invalid or unsupported modulusLength option provided, 2048 bits or larger keys must be used');
            }
            const keypair = await generate('rsa', {
                modulusLength,
                publicExponent: 0x10001,
            });
            (0, check_modulus_length_js_1.setModulusLength)(keypair.privateKey, modulusLength);
            (0, check_modulus_length_js_1.setModulusLength)(keypair.publicKey, modulusLength);
            return keypair;
        }
        case 'ES256':
            return generate('ec', { namedCurve: 'P-256' });
        case 'ES256K':
            return generate('ec', { namedCurve: 'secp256k1' });
        case 'ES384':
            return generate('ec', { namedCurve: 'P-384' });
        case 'ES512':
            return generate('ec', { namedCurve: 'P-521' });
        case 'EdDSA': {
            switch (options === null || options === void 0 ? void 0 : options.crv) {
                case undefined:
                case 'Ed25519':
                    return generate('ed25519');
                case 'Ed448':
                    return generate('ed448');
                default:
                    throw new errors_js_1.JOSENotSupported('Invalid or unsupported crv option provided, supported values are Ed25519 and Ed448');
            }
        }
        case 'ECDH-ES':
        case 'ECDH-ES+A128KW':
        case 'ECDH-ES+A192KW':
        case 'ECDH-ES+A256KW':
            switch (options === null || options === void 0 ? void 0 : options.crv) {
                case undefined:
                case 'P-256':
                case 'P-384':
                case 'P-521':
                    return generate('ec', { namedCurve: (_b = options === null || options === void 0 ? void 0 : options.crv) !== null && _b !== void 0 ? _b : 'P-256' });
                case 'X25519':
                    return generate('x25519');
                case 'X448':
                    return generate('x448');
                default:
                    throw new errors_js_1.JOSENotSupported('Invalid or unsupported crv option provided, supported values are P-256, P-384, P-521, X25519, and X448');
            }
        default:
            throw new errors_js_1.JOSENotSupported('Invalid or unsupported JWK "alg" (Algorithm) Parameter value');
    }
}
exports.generateKeyPair = generateKeyPair;

},{"../util/errors.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/node/util/errors.js","./check_modulus_length.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/node/runtime/check_modulus_length.js","./random.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/node/runtime/random.js","crypto":false,"util":false}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/node/runtime/get_named_curve.js":[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.setCurve = exports.weakMap = void 0;
const buffer_1 = require("buffer");
const crypto_1 = require("crypto");
const errors_js_1 = require("../util/errors.js");
const webcrypto_js_1 = require("./webcrypto.js");
const is_key_object_js_1 = require("./is_key_object.js");
const invalid_key_input_js_1 = require("../lib/invalid_key_input.js");
const p256 = buffer_1.Buffer.from([42, 134, 72, 206, 61, 3, 1, 7]);
const p384 = buffer_1.Buffer.from([43, 129, 4, 0, 34]);
const p521 = buffer_1.Buffer.from([43, 129, 4, 0, 35]);
const secp256k1 = buffer_1.Buffer.from([43, 129, 4, 0, 10]);
exports.weakMap = new WeakMap();
const namedCurveToJOSE = (namedCurve) => {
    switch (namedCurve) {
        case 'prime256v1':
            return 'P-256';
        case 'secp384r1':
            return 'P-384';
        case 'secp521r1':
            return 'P-521';
        case 'secp256k1':
            return 'secp256k1';
        default:
            throw new errors_js_1.JOSENotSupported('Unsupported key curve for this operation');
    }
};
const getNamedCurve = (kee, raw) => {
    var _a;
    let key;
    if ((0, webcrypto_js_1.isCryptoKey)(kee)) {
        key = crypto_1.KeyObject.from(kee);
    }
    else if ((0, is_key_object_js_1.default)(kee)) {
        key = kee;
    }
    else {
        throw new TypeError((0, invalid_key_input_js_1.default)(kee, 'KeyObject', 'CryptoKey'));
    }
    if (key.type === 'secret') {
        throw new TypeError('only "private" or "public" type keys can be used for this operation');
    }
    switch (key.asymmetricKeyType) {
        case 'ed25519':
        case 'ed448':
            return `Ed${key.asymmetricKeyType.substr(2)}`;
        case 'x25519':
        case 'x448':
            return `X${key.asymmetricKeyType.substr(1)}`;
        case 'ec': {
            if (exports.weakMap.has(key)) {
                return exports.weakMap.get(key);
            }
            let namedCurve = (_a = key.asymmetricKeyDetails) === null || _a === void 0 ? void 0 : _a.namedCurve;
            if (!namedCurve && key.type === 'private') {
                namedCurve = getNamedCurve((0, crypto_1.createPublicKey)(key), true);
            }
            else if (!namedCurve) {
                const buf = key.export({ format: 'der', type: 'spki' });
                const i = buf[1] < 128 ? 14 : 15;
                const len = buf[i];
                const curveOid = buf.slice(i + 1, i + 1 + len);
                if (curveOid.equals(p256)) {
                    namedCurve = 'prime256v1';
                }
                else if (curveOid.equals(p384)) {
                    namedCurve = 'secp384r1';
                }
                else if (curveOid.equals(p521)) {
                    namedCurve = 'secp521r1';
                }
                else if (curveOid.equals(secp256k1)) {
                    namedCurve = 'secp256k1';
                }
                else {
                    throw new errors_js_1.JOSENotSupported('Unsupported key curve for this operation');
                }
            }
            if (raw)
                return namedCurve;
            const curve = namedCurveToJOSE(namedCurve);
            exports.weakMap.set(key, curve);
            return curve;
        }
        default:
            throw new TypeError('Invalid asymmetric key type for this operation');
    }
};
function setCurve(keyObject, curve) {
    exports.weakMap.set(keyObject, curve);
}
exports.setCurve = setCurve;
exports.default = getNamedCurve;

},{"../lib/invalid_key_input.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/node/lib/invalid_key_input.js","../util/errors.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/node/util/errors.js","./is_key_object.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/node/runtime/is_key_object.js","./webcrypto.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/node/runtime/webcrypto.js","buffer":false,"crypto":false}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/node/runtime/get_sign_verify_key.js":[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const crypto_1 = require("crypto");
const webcrypto_js_1 = require("./webcrypto.js");
const crypto_key_js_1 = require("../lib/crypto_key.js");
const secret_key_js_1 = require("./secret_key.js");
const invalid_key_input_js_1 = require("../lib/invalid_key_input.js");
function getSignVerifyKey(alg, key, usage) {
    if (key instanceof Uint8Array) {
        if (!alg.startsWith('HS')) {
            throw new TypeError((0, invalid_key_input_js_1.default)(key, 'KeyObject', 'CryptoKey'));
        }
        return (0, secret_key_js_1.default)(key);
    }
    if (key instanceof crypto_1.KeyObject) {
        return key;
    }
    if ((0, webcrypto_js_1.isCryptoKey)(key)) {
        (0, crypto_key_js_1.checkSigCryptoKey)(key, alg, usage);
        return crypto_1.KeyObject.from(key);
    }
    throw new TypeError((0, invalid_key_input_js_1.default)(key, 'KeyObject', 'CryptoKey', 'Uint8Array'));
}
exports.default = getSignVerifyKey;

},{"../lib/crypto_key.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/node/lib/crypto_key.js","../lib/invalid_key_input.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/node/lib/invalid_key_input.js","./secret_key.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/node/runtime/secret_key.js","./webcrypto.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/node/runtime/webcrypto.js","crypto":false}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/node/runtime/global.js":[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.isNodeJs = exports.isCloudflareWorkers = void 0;
function isCloudflareWorkers() {
    return false;
}
exports.isCloudflareWorkers = isCloudflareWorkers;
function isNodeJs() {
    return true;
}
exports.isNodeJs = isNodeJs;

},{}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/node/runtime/hmac_digest.js":[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const errors_js_1 = require("../util/errors.js");
function hmacDigest(alg) {
    switch (alg) {
        case 'HS256':
            return 'sha256';
        case 'HS384':
            return 'sha384';
        case 'HS512':
            return 'sha512';
        default:
            throw new errors_js_1.JOSENotSupported(`alg ${alg} is not supported either by JOSE or your javascript runtime`);
    }
}
exports.default = hmacDigest;

},{"../util/errors.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/node/util/errors.js"}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/node/runtime/is_key_like.js":[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.types = void 0;
const webcrypto_js_1 = require("./webcrypto.js");
const is_key_object_js_1 = require("./is_key_object.js");
exports.default = (key) => (0, is_key_object_js_1.default)(key) || (0, webcrypto_js_1.isCryptoKey)(key);
const types = ['KeyObject'];
exports.types = types;
if (parseInt(process.versions.node) >= 16) {
    types.push('CryptoKey');
}

},{"./is_key_object.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/node/runtime/is_key_object.js","./webcrypto.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/node/runtime/webcrypto.js"}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/node/runtime/is_key_object.js":[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const crypto_1 = require("crypto");
const util = require("util");
exports.default = util.types.isKeyObject
    ? (obj) => util.types.isKeyObject(obj)
    : (obj) => obj != null && obj instanceof crypto_1.KeyObject;

},{"crypto":false,"util":false}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/node/runtime/jwk_to_key.js":[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const buffer_1 = require("buffer");
const crypto_1 = require("crypto");
const base64url_js_1 = require("./base64url.js");
const errors_js_1 = require("../util/errors.js");
const get_named_curve_js_1 = require("./get_named_curve.js");
const check_modulus_length_js_1 = require("./check_modulus_length.js");
const asn1_sequence_encoder_js_1 = require("./asn1_sequence_encoder.js");
const [major, minor] = process.version
    .substr(1)
    .split('.')
    .map((str) => parseInt(str, 10));
const jwkImportSupported = major >= 16 || (major === 15 && minor >= 12);
const parse = (jwk) => {
    if (jwkImportSupported && jwk.kty !== 'oct') {
        return jwk.d
            ? (0, crypto_1.createPrivateKey)({ format: 'jwk', key: jwk })
            : (0, crypto_1.createPublicKey)({ format: 'jwk', key: jwk });
    }
    switch (jwk.kty) {
        case 'oct': {
            return (0, crypto_1.createSecretKey)((0, base64url_js_1.decode)(jwk.k));
        }
        case 'RSA': {
            const enc = new asn1_sequence_encoder_js_1.default();
            const isPrivate = jwk.d !== undefined;
            const modulus = buffer_1.Buffer.from(jwk.n, 'base64');
            const exponent = buffer_1.Buffer.from(jwk.e, 'base64');
            if (isPrivate) {
                enc.zero();
                enc.unsignedInteger(modulus);
                enc.unsignedInteger(exponent);
                enc.unsignedInteger(buffer_1.Buffer.from(jwk.d, 'base64'));
                enc.unsignedInteger(buffer_1.Buffer.from(jwk.p, 'base64'));
                enc.unsignedInteger(buffer_1.Buffer.from(jwk.q, 'base64'));
                enc.unsignedInteger(buffer_1.Buffer.from(jwk.dp, 'base64'));
                enc.unsignedInteger(buffer_1.Buffer.from(jwk.dq, 'base64'));
                enc.unsignedInteger(buffer_1.Buffer.from(jwk.qi, 'base64'));
            }
            else {
                enc.unsignedInteger(modulus);
                enc.unsignedInteger(exponent);
            }
            const der = enc.end();
            const createInput = {
                key: der,
                format: 'der',
                type: 'pkcs1',
            };
            const keyObject = isPrivate ? (0, crypto_1.createPrivateKey)(createInput) : (0, crypto_1.createPublicKey)(createInput);
            (0, check_modulus_length_js_1.setModulusLength)(keyObject, modulus.length << 3);
            return keyObject;
        }
        case 'EC': {
            const enc = new asn1_sequence_encoder_js_1.default();
            const isPrivate = jwk.d !== undefined;
            const pub = buffer_1.Buffer.concat([
                buffer_1.Buffer.alloc(1, 4),
                buffer_1.Buffer.from(jwk.x, 'base64'),
                buffer_1.Buffer.from(jwk.y, 'base64'),
            ]);
            if (isPrivate) {
                enc.zero();
                const enc$1 = new asn1_sequence_encoder_js_1.default();
                enc$1.oidFor('ecPublicKey');
                enc$1.oidFor(jwk.crv);
                enc.add(enc$1.end());
                const enc$2 = new asn1_sequence_encoder_js_1.default();
                enc$2.one();
                enc$2.octStr(buffer_1.Buffer.from(jwk.d, 'base64'));
                const enc$3 = new asn1_sequence_encoder_js_1.default();
                enc$3.bitStr(pub);
                const f2 = enc$3.end(buffer_1.Buffer.from([0xa1]));
                enc$2.add(f2);
                const f = enc$2.end();
                const enc$4 = new asn1_sequence_encoder_js_1.default();
                enc$4.add(f);
                const f3 = enc$4.end(buffer_1.Buffer.from([0x04]));
                enc.add(f3);
                const der = enc.end();
                const keyObject = (0, crypto_1.createPrivateKey)({ key: der, format: 'der', type: 'pkcs8' });
                (0, get_named_curve_js_1.setCurve)(keyObject, jwk.crv);
                return keyObject;
            }
            const enc$1 = new asn1_sequence_encoder_js_1.default();
            enc$1.oidFor('ecPublicKey');
            enc$1.oidFor(jwk.crv);
            enc.add(enc$1.end());
            enc.bitStr(pub);
            const der = enc.end();
            const keyObject = (0, crypto_1.createPublicKey)({ key: der, format: 'der', type: 'spki' });
            (0, get_named_curve_js_1.setCurve)(keyObject, jwk.crv);
            return keyObject;
        }
        case 'OKP': {
            const enc = new asn1_sequence_encoder_js_1.default();
            const isPrivate = jwk.d !== undefined;
            if (isPrivate) {
                enc.zero();
                const enc$1 = new asn1_sequence_encoder_js_1.default();
                enc$1.oidFor(jwk.crv);
                enc.add(enc$1.end());
                const enc$2 = new asn1_sequence_encoder_js_1.default();
                enc$2.octStr(buffer_1.Buffer.from(jwk.d, 'base64'));
                const f = enc$2.end(buffer_1.Buffer.from([0x04]));
                enc.add(f);
                const der = enc.end();
                return (0, crypto_1.createPrivateKey)({ key: der, format: 'der', type: 'pkcs8' });
            }
            const enc$1 = new asn1_sequence_encoder_js_1.default();
            enc$1.oidFor(jwk.crv);
            enc.add(enc$1.end());
            enc.bitStr(buffer_1.Buffer.from(jwk.x, 'base64'));
            const der = enc.end();
            return (0, crypto_1.createPublicKey)({ key: der, format: 'der', type: 'spki' });
        }
        default:
            throw new errors_js_1.JOSENotSupported('Invalid or unsupported JWK "kty" (Key Type) Parameter value');
    }
};
exports.default = parse;

},{"../util/errors.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/node/util/errors.js","./asn1_sequence_encoder.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/node/runtime/asn1_sequence_encoder.js","./base64url.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/node/runtime/base64url.js","./check_modulus_length.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/node/runtime/check_modulus_length.js","./get_named_curve.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/node/runtime/get_named_curve.js","buffer":false,"crypto":false}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/node/runtime/key_to_jwk.js":[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const crypto_1 = require("crypto");
const base64url_js_1 = require("./base64url.js");
const asn1_sequence_decoder_js_1 = require("./asn1_sequence_decoder.js");
const errors_js_1 = require("../util/errors.js");
const get_named_curve_js_1 = require("./get_named_curve.js");
const webcrypto_js_1 = require("./webcrypto.js");
const is_key_object_js_1 = require("./is_key_object.js");
const invalid_key_input_js_1 = require("../lib/invalid_key_input.js");
const [major, minor] = process.version
    .substr(1)
    .split('.')
    .map((str) => parseInt(str, 10));
const jwkExportSupported = major >= 16 || (major === 15 && minor >= 9);
const keyToJWK = (key) => {
    let keyObject;
    if ((0, webcrypto_js_1.isCryptoKey)(key)) {
        if (!key.extractable) {
            throw new TypeError('CryptoKey is not extractable');
        }
        keyObject = crypto_1.KeyObject.from(key);
    }
    else if ((0, is_key_object_js_1.default)(key)) {
        keyObject = key;
    }
    else if (key instanceof Uint8Array) {
        return {
            kty: 'oct',
            k: (0, base64url_js_1.encode)(key),
        };
    }
    else {
        throw new TypeError((0, invalid_key_input_js_1.default)(key, 'KeyObject', 'CryptoKey', 'Uint8Array'));
    }
    if (jwkExportSupported) {
        return keyObject.export({ format: 'jwk' });
    }
    switch (keyObject.type) {
        case 'secret':
            return {
                kty: 'oct',
                k: (0, base64url_js_1.encode)(keyObject.export()),
            };
        case 'private':
        case 'public': {
            switch (keyObject.asymmetricKeyType) {
                case 'rsa': {
                    const der = keyObject.export({ format: 'der', type: 'pkcs1' });
                    const dec = new asn1_sequence_decoder_js_1.default(der);
                    if (keyObject.type === 'private') {
                        dec.unsignedInteger();
                    }
                    const n = (0, base64url_js_1.encode)(dec.unsignedInteger());
                    const e = (0, base64url_js_1.encode)(dec.unsignedInteger());
                    let jwk;
                    if (keyObject.type === 'private') {
                        jwk = {
                            d: (0, base64url_js_1.encode)(dec.unsignedInteger()),
                            p: (0, base64url_js_1.encode)(dec.unsignedInteger()),
                            q: (0, base64url_js_1.encode)(dec.unsignedInteger()),
                            dp: (0, base64url_js_1.encode)(dec.unsignedInteger()),
                            dq: (0, base64url_js_1.encode)(dec.unsignedInteger()),
                            qi: (0, base64url_js_1.encode)(dec.unsignedInteger()),
                        };
                    }
                    dec.end();
                    return { kty: 'RSA', n, e, ...jwk };
                }
                case 'ec': {
                    const crv = (0, get_named_curve_js_1.default)(keyObject);
                    let len;
                    let offset;
                    let correction;
                    switch (crv) {
                        case 'secp256k1':
                            len = 64;
                            offset = 31 + 2;
                            correction = -1;
                            break;
                        case 'P-256':
                            len = 64;
                            offset = 34 + 2;
                            correction = -1;
                            break;
                        case 'P-384':
                            len = 96;
                            offset = 33 + 2;
                            correction = -3;
                            break;
                        case 'P-521':
                            len = 132;
                            offset = 33 + 2;
                            correction = -3;
                            break;
                        default:
                            throw new errors_js_1.JOSENotSupported('Unsupported curve');
                    }
                    if (keyObject.type === 'public') {
                        const der = keyObject.export({ type: 'spki', format: 'der' });
                        return {
                            kty: 'EC',
                            crv,
                            x: (0, base64url_js_1.encode)(der.subarray(-len, -len / 2)),
                            y: (0, base64url_js_1.encode)(der.subarray(-len / 2)),
                        };
                    }
                    const der = keyObject.export({ type: 'pkcs8', format: 'der' });
                    if (der.length < 100) {
                        offset += correction;
                    }
                    return {
                        ...keyToJWK((0, crypto_1.createPublicKey)(keyObject)),
                        d: (0, base64url_js_1.encode)(der.subarray(offset, offset + len / 2)),
                    };
                }
                case 'ed25519':
                case 'x25519': {
                    const crv = (0, get_named_curve_js_1.default)(keyObject);
                    if (keyObject.type === 'public') {
                        const der = keyObject.export({ type: 'spki', format: 'der' });
                        return {
                            kty: 'OKP',
                            crv,
                            x: (0, base64url_js_1.encode)(der.subarray(-32)),
                        };
                    }
                    const der = keyObject.export({ type: 'pkcs8', format: 'der' });
                    return {
                        ...keyToJWK((0, crypto_1.createPublicKey)(keyObject)),
                        d: (0, base64url_js_1.encode)(der.subarray(-32)),
                    };
                }
                case 'ed448':
                case 'x448': {
                    const crv = (0, get_named_curve_js_1.default)(keyObject);
                    if (keyObject.type === 'public') {
                        const der = keyObject.export({ type: 'spki', format: 'der' });
                        return {
                            kty: 'OKP',
                            crv,
                            x: (0, base64url_js_1.encode)(der.subarray(crv === 'Ed448' ? -57 : -56)),
                        };
                    }
                    const der = keyObject.export({ type: 'pkcs8', format: 'der' });
                    return {
                        ...keyToJWK((0, crypto_1.createPublicKey)(keyObject)),
                        d: (0, base64url_js_1.encode)(der.subarray(crv === 'Ed448' ? -57 : -56)),
                    };
                }
                default:
                    throw new errors_js_1.JOSENotSupported('Unsupported key asymmetricKeyType');
            }
        }
        default:
            throw new errors_js_1.JOSENotSupported('Unsupported key type');
    }
};
exports.default = keyToJWK;

},{"../lib/invalid_key_input.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/node/lib/invalid_key_input.js","../util/errors.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/node/util/errors.js","./asn1_sequence_decoder.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/node/runtime/asn1_sequence_decoder.js","./base64url.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/node/runtime/base64url.js","./get_named_curve.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/node/runtime/get_named_curve.js","./is_key_object.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/node/runtime/is_key_object.js","./webcrypto.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/node/runtime/webcrypto.js","crypto":false}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/node/runtime/node_key.js":[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const crypto_1 = require("crypto");
const get_named_curve_js_1 = require("./get_named_curve.js");
const errors_js_1 = require("../util/errors.js");
const check_modulus_length_js_1 = require("./check_modulus_length.js");
const [major, minor] = process.version
    .substr(1)
    .split('.')
    .map((str) => parseInt(str, 10));
const rsaPssParams = major >= 17 || (major === 16 && minor >= 9);
const PSS = {
    padding: crypto_1.constants.RSA_PKCS1_PSS_PADDING,
    saltLength: crypto_1.constants.RSA_PSS_SALTLEN_DIGEST,
};
const ecCurveAlgMap = new Map([
    ['ES256', 'P-256'],
    ['ES256K', 'secp256k1'],
    ['ES384', 'P-384'],
    ['ES512', 'P-521'],
]);
function keyForCrypto(alg, key) {
    switch (alg) {
        case 'EdDSA':
            if (!['ed25519', 'ed448'].includes(key.asymmetricKeyType)) {
                throw new TypeError('Invalid key for this operation, its asymmetricKeyType must be ed25519 or ed448');
            }
            return key;
        case 'RS256':
        case 'RS384':
        case 'RS512':
            if (key.asymmetricKeyType !== 'rsa') {
                throw new TypeError('Invalid key for this operation, its asymmetricKeyType must be rsa');
            }
            (0, check_modulus_length_js_1.default)(key, alg);
            return key;
        case rsaPssParams && 'PS256':
        case rsaPssParams && 'PS384':
        case rsaPssParams && 'PS512':
            if (key.asymmetricKeyType === 'rsa-pss') {
                const { hashAlgorithm, mgf1HashAlgorithm, saltLength } = key.asymmetricKeyDetails;
                const length = parseInt(alg.substr(-3), 10);
                if (hashAlgorithm !== undefined &&
                    (hashAlgorithm !== `sha${length}` || mgf1HashAlgorithm !== hashAlgorithm)) {
                    throw new TypeError(`Invalid key for this operation, its RSA-PSS parameters do not meet the requirements of "alg" ${alg}`);
                }
                if (saltLength !== undefined && saltLength > length >> 3) {
                    throw new TypeError(`Invalid key for this operation, its RSA-PSS parameter saltLength does not meet the requirements of "alg" ${alg}`);
                }
            }
            else if (key.asymmetricKeyType !== 'rsa') {
                throw new TypeError('Invalid key for this operation, its asymmetricKeyType must be rsa or rsa-pss');
            }
            (0, check_modulus_length_js_1.default)(key, alg);
            return { key, ...PSS };
        case !rsaPssParams && 'PS256':
        case !rsaPssParams && 'PS384':
        case !rsaPssParams && 'PS512':
            if (key.asymmetricKeyType !== 'rsa') {
                throw new TypeError('Invalid key for this operation, its asymmetricKeyType must be rsa');
            }
            (0, check_modulus_length_js_1.default)(key, alg);
            return { key, ...PSS };
        case 'ES256':
        case 'ES256K':
        case 'ES384':
        case 'ES512': {
            if (key.asymmetricKeyType !== 'ec') {
                throw new TypeError('Invalid key for this operation, its asymmetricKeyType must be ec');
            }
            const actual = (0, get_named_curve_js_1.default)(key);
            const expected = ecCurveAlgMap.get(alg);
            if (actual !== expected) {
                throw new TypeError(`Invalid key curve for the algorithm, its curve must be ${expected}, got ${actual}`);
            }
            return { dsaEncoding: 'ieee-p1363', key };
        }
        default:
            throw new errors_js_1.JOSENotSupported(`alg ${alg} is not supported either by JOSE or your javascript runtime`);
    }
}
exports.default = keyForCrypto;

},{"../util/errors.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/node/util/errors.js","./check_modulus_length.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/node/runtime/check_modulus_length.js","./get_named_curve.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/node/runtime/get_named_curve.js","crypto":false}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/node/runtime/pbes2kw.js":[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.decrypt = exports.encrypt = void 0;
const util_1 = require("util");
const crypto_1 = require("crypto");
const random_js_1 = require("./random.js");
const buffer_utils_js_1 = require("../lib/buffer_utils.js");
const base64url_js_1 = require("./base64url.js");
const aeskw_js_1 = require("./aeskw.js");
const check_p2s_js_1 = require("../lib/check_p2s.js");
const webcrypto_js_1 = require("./webcrypto.js");
const crypto_key_js_1 = require("../lib/crypto_key.js");
const is_key_object_js_1 = require("./is_key_object.js");
const invalid_key_input_js_1 = require("../lib/invalid_key_input.js");
const pbkdf2 = (0, util_1.promisify)(crypto_1.pbkdf2);
function getPassword(key, alg) {
    if ((0, is_key_object_js_1.default)(key)) {
        return key.export();
    }
    if (key instanceof Uint8Array) {
        return key;
    }
    if ((0, webcrypto_js_1.isCryptoKey)(key)) {
        (0, crypto_key_js_1.checkEncCryptoKey)(key, alg, 'deriveBits', 'deriveKey');
        return crypto_1.KeyObject.from(key).export();
    }
    throw new TypeError((0, invalid_key_input_js_1.default)(key, 'KeyObject', 'CryptoKey', 'Uint8Array'));
}
const encrypt = async (alg, key, cek, p2c = Math.floor(Math.random() * 2049) + 2048, p2s = (0, random_js_1.default)(new Uint8Array(16))) => {
    (0, check_p2s_js_1.default)(p2s);
    const salt = (0, buffer_utils_js_1.p2s)(alg, p2s);
    const keylen = parseInt(alg.substr(13, 3), 10) >> 3;
    const password = getPassword(key, alg);
    const derivedKey = await pbkdf2(password, salt, p2c, keylen, `sha${alg.substr(8, 3)}`);
    const encryptedKey = await (0, aeskw_js_1.wrap)(alg.substr(-6), derivedKey, cek);
    return { encryptedKey, p2c, p2s: (0, base64url_js_1.encode)(p2s) };
};
exports.encrypt = encrypt;
const decrypt = async (alg, key, encryptedKey, p2c, p2s) => {
    (0, check_p2s_js_1.default)(p2s);
    const salt = (0, buffer_utils_js_1.p2s)(alg, p2s);
    const keylen = parseInt(alg.substr(13, 3), 10) >> 3;
    const password = getPassword(key, alg);
    const derivedKey = await pbkdf2(password, salt, p2c, keylen, `sha${alg.substr(8, 3)}`);
    return (0, aeskw_js_1.unwrap)(alg.substr(-6), derivedKey, encryptedKey);
};
exports.decrypt = decrypt;

},{"../lib/buffer_utils.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/node/lib/buffer_utils.js","../lib/check_p2s.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/node/lib/check_p2s.js","../lib/crypto_key.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/node/lib/crypto_key.js","../lib/invalid_key_input.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/node/lib/invalid_key_input.js","./aeskw.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/node/runtime/aeskw.js","./base64url.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/node/runtime/base64url.js","./is_key_object.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/node/runtime/is_key_object.js","./random.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/node/runtime/random.js","./webcrypto.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/node/runtime/webcrypto.js","crypto":false,"util":false}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/node/runtime/random.js":[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = void 0;
var crypto_1 = require("crypto");
Object.defineProperty(exports, "default", { enumerable: true, get: function () { return crypto_1.randomFillSync; } });

},{"crypto":false}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/node/runtime/rsaes.js":[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.decrypt = exports.encrypt = void 0;
const crypto_1 = require("crypto");
const check_modulus_length_js_1 = require("./check_modulus_length.js");
const webcrypto_js_1 = require("./webcrypto.js");
const crypto_key_js_1 = require("../lib/crypto_key.js");
const is_key_object_js_1 = require("./is_key_object.js");
const invalid_key_input_js_1 = require("../lib/invalid_key_input.js");
const checkKey = (key, alg) => {
    if (key.asymmetricKeyType !== 'rsa') {
        throw new TypeError('Invalid key for this operation, its asymmetricKeyType must be rsa');
    }
    (0, check_modulus_length_js_1.default)(key, alg);
};
const resolvePadding = (alg) => {
    switch (alg) {
        case 'RSA-OAEP':
        case 'RSA-OAEP-256':
        case 'RSA-OAEP-384':
        case 'RSA-OAEP-512':
            return crypto_1.constants.RSA_PKCS1_OAEP_PADDING;
        case 'RSA1_5':
            return crypto_1.constants.RSA_PKCS1_PADDING;
        default:
            return undefined;
    }
};
const resolveOaepHash = (alg) => {
    switch (alg) {
        case 'RSA-OAEP':
            return 'sha1';
        case 'RSA-OAEP-256':
            return 'sha256';
        case 'RSA-OAEP-384':
            return 'sha384';
        case 'RSA-OAEP-512':
            return 'sha512';
        default:
            return undefined;
    }
};
function ensureKeyObject(key, alg, ...usages) {
    if ((0, is_key_object_js_1.default)(key)) {
        return key;
    }
    if ((0, webcrypto_js_1.isCryptoKey)(key)) {
        (0, crypto_key_js_1.checkEncCryptoKey)(key, alg, ...usages);
        return crypto_1.KeyObject.from(key);
    }
    throw new TypeError((0, invalid_key_input_js_1.default)(key, 'KeyObject', 'CryptoKey'));
}
const encrypt = async (alg, key, cek) => {
    const padding = resolvePadding(alg);
    const oaepHash = resolveOaepHash(alg);
    const keyObject = ensureKeyObject(key, alg, 'wrapKey', 'encrypt');
    checkKey(keyObject, alg);
    return (0, crypto_1.publicEncrypt)({ key: keyObject, oaepHash, padding }, cek);
};
exports.encrypt = encrypt;
const decrypt = async (alg, key, encryptedKey) => {
    const padding = resolvePadding(alg);
    const oaepHash = resolveOaepHash(alg);
    const keyObject = ensureKeyObject(key, alg, 'unwrapKey', 'decrypt');
    checkKey(keyObject, alg);
    return (0, crypto_1.privateDecrypt)({ key: keyObject, oaepHash, padding }, encryptedKey);
};
exports.decrypt = decrypt;

},{"../lib/crypto_key.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/node/lib/crypto_key.js","../lib/invalid_key_input.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/node/lib/invalid_key_input.js","./check_modulus_length.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/node/runtime/check_modulus_length.js","./is_key_object.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/node/runtime/is_key_object.js","./webcrypto.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/node/runtime/webcrypto.js","crypto":false}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/node/runtime/secret_key.js":[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const crypto_1 = require("crypto");
function getSecretKey(key) {
    let keyObject;
    if (key instanceof Uint8Array) {
        keyObject = (0, crypto_1.createSecretKey)(key);
    }
    else {
        keyObject = key;
    }
    return keyObject;
}
exports.default = getSecretKey;

},{"crypto":false}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/node/runtime/sign.js":[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const crypto = require("crypto");
const util_1 = require("util");
const dsa_digest_js_1 = require("./dsa_digest.js");
const hmac_digest_js_1 = require("./hmac_digest.js");
const node_key_js_1 = require("./node_key.js");
const get_sign_verify_key_js_1 = require("./get_sign_verify_key.js");
let oneShotSign;
if (crypto.sign.length > 3) {
    oneShotSign = (0, util_1.promisify)(crypto.sign);
}
else {
    oneShotSign = crypto.sign;
}
const sign = async (alg, key, data) => {
    const keyObject = (0, get_sign_verify_key_js_1.default)(alg, key, 'sign');
    if (alg.startsWith('HS')) {
        const bitlen = parseInt(alg.substr(-3), 10);
        if (!keyObject.symmetricKeySize || keyObject.symmetricKeySize << 3 < bitlen) {
            throw new TypeError(`${alg} requires symmetric keys to be ${bitlen} bits or larger`);
        }
        const hmac = crypto.createHmac((0, hmac_digest_js_1.default)(alg), keyObject);
        hmac.update(data);
        return hmac.digest();
    }
    return oneShotSign((0, dsa_digest_js_1.default)(alg), data, (0, node_key_js_1.default)(alg, keyObject));
};
exports.default = sign;

},{"./dsa_digest.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/node/runtime/dsa_digest.js","./get_sign_verify_key.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/node/runtime/get_sign_verify_key.js","./hmac_digest.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/node/runtime/hmac_digest.js","./node_key.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/node/runtime/node_key.js","crypto":false,"util":false}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/node/runtime/timing_safe_equal.js":[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const crypto_1 = require("crypto");
const timingSafeEqual = crypto_1.timingSafeEqual;
exports.default = timingSafeEqual;

},{"crypto":false}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/node/runtime/verify.js":[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const crypto = require("crypto");
const util_1 = require("util");
const dsa_digest_js_1 = require("./dsa_digest.js");
const node_key_js_1 = require("./node_key.js");
const sign_js_1 = require("./sign.js");
const get_sign_verify_key_js_1 = require("./get_sign_verify_key.js");
const [major, minor] = process.version
    .substr(1)
    .split('.')
    .map((str) => parseInt(str, 10));
const oneShotCallbackSupported = major >= 16 || (major === 15 && minor >= 13);
let oneShotVerify;
if (crypto.verify.length > 4 && oneShotCallbackSupported) {
    oneShotVerify = (0, util_1.promisify)(crypto.verify);
}
else {
    oneShotVerify = crypto.verify;
}
const verify = async (alg, key, signature, data) => {
    const keyObject = (0, get_sign_verify_key_js_1.default)(alg, key, 'verify');
    if (alg.startsWith('HS')) {
        const expected = await (0, sign_js_1.default)(alg, keyObject, data);
        const actual = signature;
        try {
            return crypto.timingSafeEqual(actual, expected);
        }
        catch {
            return false;
        }
    }
    const algorithm = (0, dsa_digest_js_1.default)(alg);
    const keyInput = (0, node_key_js_1.default)(alg, keyObject);
    try {
        return await oneShotVerify(algorithm, data, keyInput, signature);
    }
    catch {
        return false;
    }
};
exports.default = verify;

},{"./dsa_digest.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/node/runtime/dsa_digest.js","./get_sign_verify_key.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/node/runtime/get_sign_verify_key.js","./node_key.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/node/runtime/node_key.js","./sign.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/node/runtime/sign.js","crypto":false,"util":false}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/node/runtime/webcrypto.js":[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.isCryptoKey = void 0;
const crypto = require("crypto");
const util = require("util");
const webcrypto = crypto.webcrypto;
exports.default = webcrypto;
exports.isCryptoKey = util.types.isCryptoKey
    ? (obj) => util.types.isCryptoKey(obj)
    :
        (obj) => false;

},{"crypto":false,"util":false}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/node/runtime/zlib.js":[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.deflate = exports.inflate = void 0;
const util_1 = require("util");
const zlib_1 = require("zlib");
const inflateRaw = (0, util_1.promisify)(zlib_1.inflateRaw);
const deflateRaw = (0, util_1.promisify)(zlib_1.deflateRaw);
const inflate = (input) => inflateRaw(input);
exports.inflate = inflate;
const deflate = (input) => deflateRaw(input);
exports.deflate = deflate;

},{"util":false,"zlib":false}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/node/util/base64url.js":[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.decode = exports.encode = void 0;
const base64url = require("../runtime/base64url.js");
exports.encode = base64url.encode;
exports.decode = base64url.decode;

},{"../runtime/base64url.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/node/runtime/base64url.js"}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/node/util/decode_protected_header.js":[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.decodeProtectedHeader = void 0;
const base64url_js_1 = require("./base64url.js");
const buffer_utils_js_1 = require("../lib/buffer_utils.js");
const is_object_js_1 = require("../lib/is_object.js");
function decodeProtectedHeader(token) {
    let protectedB64u;
    if (typeof token === 'string') {
        const parts = token.split('.');
        if (parts.length === 3 || parts.length === 5) {
            
            [protectedB64u] = parts;
        }
    }
    else if (typeof token === 'object' && token) {
        if ('protected' in token) {
            protectedB64u = token.protected;
        }
        else {
            throw new TypeError('Token does not contain a Protected Header');
        }
    }
    try {
        if (typeof protectedB64u !== 'string' || !protectedB64u) {
            throw new Error();
        }
        const result = JSON.parse(buffer_utils_js_1.decoder.decode((0, base64url_js_1.decode)(protectedB64u)));
        if (!(0, is_object_js_1.default)(result)) {
            throw new Error();
        }
        return result;
    }
    catch {
        throw new TypeError('Invalid Token or Protected Header formatting');
    }
}
exports.decodeProtectedHeader = decodeProtectedHeader;

},{"../lib/buffer_utils.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/node/lib/buffer_utils.js","../lib/is_object.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/node/lib/is_object.js","./base64url.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/node/util/base64url.js"}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/node/util/errors.js":[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.JWSSignatureVerificationFailed = exports.JWKSTimeout = exports.JWKSMultipleMatchingKeys = exports.JWKSNoMatchingKey = exports.JWKSInvalid = exports.JWKInvalid = exports.JWTInvalid = exports.JWSInvalid = exports.JWEInvalid = exports.JWEDecryptionFailed = exports.JOSENotSupported = exports.JOSEAlgNotAllowed = exports.JWTExpired = exports.JWTClaimValidationFailed = exports.JOSEError = void 0;
class JOSEError extends Error {
    constructor(message) {
        var _a;
        super(message);
        this.code = 'ERR_JOSE_GENERIC';
        this.name = this.constructor.name;
        (_a = Error.captureStackTrace) === null || _a === void 0 ? void 0 : _a.call(Error, this, this.constructor);
    }
    static get code() {
        return 'ERR_JOSE_GENERIC';
    }
}
exports.JOSEError = JOSEError;
class JWTClaimValidationFailed extends JOSEError {
    constructor(message, claim = 'unspecified', reason = 'unspecified') {
        super(message);
        this.code = 'ERR_JWT_CLAIM_VALIDATION_FAILED';
        this.claim = claim;
        this.reason = reason;
    }
    static get code() {
        return 'ERR_JWT_CLAIM_VALIDATION_FAILED';
    }
}
exports.JWTClaimValidationFailed = JWTClaimValidationFailed;
class JWTExpired extends JOSEError {
    constructor(message, claim = 'unspecified', reason = 'unspecified') {
        super(message);
        this.code = 'ERR_JWT_EXPIRED';
        this.claim = claim;
        this.reason = reason;
    }
    static get code() {
        return 'ERR_JWT_EXPIRED';
    }
}
exports.JWTExpired = JWTExpired;
class JOSEAlgNotAllowed extends JOSEError {
    constructor() {
        super(...arguments);
        this.code = 'ERR_JOSE_ALG_NOT_ALLOWED';
    }
    static get code() {
        return 'ERR_JOSE_ALG_NOT_ALLOWED';
    }
}
exports.JOSEAlgNotAllowed = JOSEAlgNotAllowed;
class JOSENotSupported extends JOSEError {
    constructor() {
        super(...arguments);
        this.code = 'ERR_JOSE_NOT_SUPPORTED';
    }
    static get code() {
        return 'ERR_JOSE_NOT_SUPPORTED';
    }
}
exports.JOSENotSupported = JOSENotSupported;
class JWEDecryptionFailed extends JOSEError {
    constructor() {
        super(...arguments);
        this.code = 'ERR_JWE_DECRYPTION_FAILED';
        this.message = 'decryption operation failed';
    }
    static get code() {
        return 'ERR_JWE_DECRYPTION_FAILED';
    }
}
exports.JWEDecryptionFailed = JWEDecryptionFailed;
class JWEInvalid extends JOSEError {
    constructor() {
        super(...arguments);
        this.code = 'ERR_JWE_INVALID';
    }
    static get code() {
        return 'ERR_JWE_INVALID';
    }
}
exports.JWEInvalid = JWEInvalid;
class JWSInvalid extends JOSEError {
    constructor() {
        super(...arguments);
        this.code = 'ERR_JWS_INVALID';
    }
    static get code() {
        return 'ERR_JWS_INVALID';
    }
}
exports.JWSInvalid = JWSInvalid;
class JWTInvalid extends JOSEError {
    constructor() {
        super(...arguments);
        this.code = 'ERR_JWT_INVALID';
    }
    static get code() {
        return 'ERR_JWT_INVALID';
    }
}
exports.JWTInvalid = JWTInvalid;
class JWKInvalid extends JOSEError {
    constructor() {
        super(...arguments);
        this.code = 'ERR_JWK_INVALID';
    }
    static get code() {
        return 'ERR_JWK_INVALID';
    }
}
exports.JWKInvalid = JWKInvalid;
class JWKSInvalid extends JOSEError {
    constructor() {
        super(...arguments);
        this.code = 'ERR_JWKS_INVALID';
    }
    static get code() {
        return 'ERR_JWKS_INVALID';
    }
}
exports.JWKSInvalid = JWKSInvalid;
class JWKSNoMatchingKey extends JOSEError {
    constructor() {
        super(...arguments);
        this.code = 'ERR_JWKS_NO_MATCHING_KEY';
        this.message = 'no applicable key found in the JSON Web Key Set';
    }
    static get code() {
        return 'ERR_JWKS_NO_MATCHING_KEY';
    }
}
exports.JWKSNoMatchingKey = JWKSNoMatchingKey;
class JWKSMultipleMatchingKeys extends JOSEError {
    constructor() {
        super(...arguments);
        this.code = 'ERR_JWKS_MULTIPLE_MATCHING_KEYS';
        this.message = 'multiple matching keys found in the JSON Web Key Set';
    }
    static get code() {
        return 'ERR_JWKS_MULTIPLE_MATCHING_KEYS';
    }
}
exports.JWKSMultipleMatchingKeys = JWKSMultipleMatchingKeys;
class JWKSTimeout extends JOSEError {
    constructor() {
        super(...arguments);
        this.code = 'ERR_JWKS_TIMEOUT';
        this.message = 'request timed out';
    }
    static get code() {
        return 'ERR_JWKS_TIMEOUT';
    }
}
exports.JWKSTimeout = JWKSTimeout;
class JWSSignatureVerificationFailed extends JOSEError {
    constructor() {
        super(...arguments);
        this.code = 'ERR_JWS_SIGNATURE_VERIFICATION_FAILED';
        this.message = 'signature verification failed';
    }
    static get code() {
        return 'ERR_JWS_SIGNATURE_VERIFICATION_FAILED';
    }
}
exports.JWSSignatureVerificationFailed = JWSSignatureVerificationFailed;

},{}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/js-mutual-auth-ecies/common/index.js":[function(require,module,exports){
'use strict';

const mycrypto = require('../crypto')
const crypto = require('crypto');

// Prevent benign malleability
function computeKDFInput(ephemeralPublicKey, sharedSecret) {
    return $$.Buffer.concat([ephemeralPublicKey, sharedSecret],
        ephemeralPublicKey.length + sharedSecret.length)
}

function computeSymmetricEncAndMACKeys(kdfInput, options) {
    let kdfKey = mycrypto.KDF(kdfInput, options.symmetricCipherKeySize + options.macKeySize, options.hashFunctionName, options.hashSize)
    const symmetricEncryptionKey = kdfKey.slice(0, options.symmetricCipherKeySize);
    const macKey = kdfKey.slice(options.symmetricCipherKeySize)
    return {
        symmetricEncryptionKey,
        macKey
    };
}

function getDecodedECDHPublicKeyFromEncEnvelope(encEnvelope) {
    if (encEnvelope.to_ecdh === undefined) {
        throw new Error("Receiver ECDH public key property not found in input encrypted envelope")
    }
    return mycrypto.PublicKeyDeserializer.deserializeECDHPublicKey(encEnvelope.to_ecdh)
}

function checkEncryptedEnvelopeMandatoryProperties(encryptedEnvelope) {
    const mandatoryProperties = ["to_ecdh", "r", "ct", "iv", "tag"];
    mandatoryProperties.forEach((property) => {
        if (typeof encryptedEnvelope[property] === 'undefined') {
            throw new Error("Mandatory property " + property + " is missing from input encrypted envelope");
        }
    })
}

function createEncryptedEnvelopeObject(receiverECDHPublicKey, ephemeralECDHPublicKey, ciphertext, iv, tag, options) {
    return {
        to_ecdh: mycrypto.PublicKeySerializer.serializeECDHPublicKey(receiverECDHPublicKey, options),
        r: mycrypto.PublicKeySerializer.serializeECDHPublicKey(ephemeralECDHPublicKey, options),
        ct: ciphertext.toString(options.encodingFormat),
        iv: iv.toString(options.encodingFormat),
        tag: tag.toString(options.encodingFormat)
    }
}

function checkKeyPairMandatoryProperties(keyPairObject) {
    const mandatoryProperties = ["publicKey", "privateKey"];
    mandatoryProperties.forEach((property) => {
        if (typeof keyPairObject[property] === 'undefined') {
            throw new Error("Mandatory property " + property + " is missing from input key pair object");
        }
    })
}

function convertKeysToKeyObjects(keysArray, type) {
    let createKey;
    if (!type) {
        type = "public";
    }

    if (type === "private") {
        createKey = crypto.createPrivateKey;
    }

    if (type === "public") {
        createKey = crypto.createPublicKey;
    }

    if (typeof createKey !== "function") {
        throw Error(`The specified type is invalid.`);
    }

    if (!Array.isArray(keysArray)) {
        keysArray = [keysArray];
    }

    const keyObjectsArr = keysArray.map(key => {
        if (typeof key === "string") {
            return createKey(key)
        } else {
            return key;
        }
    });

    if (keyObjectsArr.length === 1) {
        return keyObjectsArr[0];
    }

    return keyObjectsArr;
}

module.exports = {
    computeKDFInput,
    computeSymmetricEncAndMACKeys,
    getDecodedECDHPublicKeyFromEncEnvelope,
    checkEncryptedEnvelopeMandatoryProperties,
    createEncryptedEnvelopeObject,
    checkKeyPairMandatoryProperties,
    convertKeysToKeyObjects
}

},{"../crypto":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/js-mutual-auth-ecies/crypto/index.js","crypto":false}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/js-mutual-auth-ecies/config.js":[function(require,module,exports){
module.exports = {
    curveName: 'secp256k1',
    encodingFormat: 'base64',
    macAlgorithmName: 'sha256',
    macKeySize: 16,
    hashFunctionName: 'sha256',
    hashSize: 32,
    signAlgorithmName: 'sha256',
    symmetricCipherName: 'aes-128-cbc',
    symmetricCipherKeySize: 16,
    ivSize: 16,
    publicKeyFormat: 'pem',
    publicKeyType: 'spki'
};

},{}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/js-mutual-auth-ecies/crypto/cipher.js":[function(require,module,exports){
'use strict';

const crypto = require('crypto');

function symmetricEncrypt(key, plaintext, iv, options) {
    if (key.length !== options.symmetricCipherKeySize) {
        throw new Error('Invalid length of input symmetric encryption key')
    }
    if (iv === undefined) {
        iv = null
    }
    let cipher = crypto.createCipheriv(options.symmetricCipherName, key, iv);
    const firstChunk = cipher.update(plaintext);
    const secondChunk = cipher.final();
    return $$.Buffer.concat([firstChunk, secondChunk]);
}

function symmetricDecrypt(key, ciphertext, iv, options) {
    if (key.length !== options.symmetricCipherKeySize) {
        throw new Error('Invalid length of input symmetric decryption key')
    }
    if (iv === undefined) {
        iv = null
    }
    let cipher = crypto.createDecipheriv(options.symmetricCipherName, key, iv);
    const firstChunk = cipher.update(ciphertext);
    const secondChunk = cipher.final();
    return $$.Buffer.concat([firstChunk, secondChunk]);
}

module.exports = {
    symmetricEncrypt,
    symmetricDecrypt
}

},{"crypto":false}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/js-mutual-auth-ecies/crypto/digitalsig.js":[function(require,module,exports){
'use strict';

const crypto = require('crypto');
const config = require('../config');

function computeDigitalSignature(privateECSigningKey, buffer, options) {
    options = options || {};
    const defaultOpts = config;
    Object.assign(defaultOpts, options);
    options = defaultOpts;

    let encodingFormat = options.encodingFormat;
    let signObject = crypto.createSign(config.signAlgorithmName)
    signObject.update(buffer)
    signObject.end();
    return signObject.sign(privateECSigningKey, encodingFormat)

}

function verifyDigitalSignature(publicECVerificationKey, signature, buffer, options) {
    options = options || {};
    const defaultOpts = config;
    Object.assign(defaultOpts, options);
    options = defaultOpts;

    let verifyObject = crypto.createVerify(options.signAlgorithmName)
    verifyObject.update(buffer)
    verifyObject.end()
    return verifyObject.verify(publicECVerificationKey, signature)
}

module.exports = {
    computeDigitalSignature,
    verifyDigitalSignature
}

},{"../config":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/js-mutual-auth-ecies/config.js","crypto":false}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/js-mutual-auth-ecies/crypto/ecephka.js":[function(require,module,exports){
'use strict';

const crypto = require('crypto');
const config = require('../config');

class ECEphemeralKeyAgreement {

    constructor(options) {
        options = options || {};
        const defaultOpts = config;
        Object.assign(defaultOpts, options);
        options = defaultOpts;

        this.ecdh = crypto.createECDH(options.curveName);
    }

    generateEphemeralPublicKey = () => {
        return this.ecdh.generateKeys();
    }

    generateSharedSecretForPublicKey = (theirECDHPublicKey) => {
        try {
            this.ecdh.getPublicKey()
        } catch(error) {
            throw new Error('You cannot generate a shared secret for another public key without calling generateEphemeralPublicKey() first')
        }
        return this.ecdh.computeSecret(theirECDHPublicKey);
    }

    computeSharedSecretFromKeyPair = (myECDHPrivateKey, theirECDHPublicKey) => {
        this.ecdh.setPrivateKey(myECDHPrivateKey);
        return this.ecdh.computeSecret(theirECDHPublicKey);
    }
}

module.exports = ECEphemeralKeyAgreement

},{"../config":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/js-mutual-auth-ecies/config.js","crypto":false}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/js-mutual-auth-ecies/crypto/index.js":[function(require,module,exports){
'use strict';

const cipher = require('./cipher')
const kdf = require('./kdf')
const kmac = require('./kmac')
const sig = require('./digitalsig')
const crypto = require('crypto')

module.exports = {
    timingSafeEqual: function(a, b){
        const hashA = crypto.createHash("sha256");
        const digestA = hashA.update(a).digest("hex");

        const hashB = crypto.createHash("sha256");
        const digestB = hashB.update(b).digest("hex");
        return digestA === digestB;
    },
    getRandomBytes: crypto.randomBytes,
    computeDigitalSignature: sig.computeDigitalSignature,
    verifyDigitalSignature: sig.verifyDigitalSignature,
    symmetricEncrypt: cipher.symmetricEncrypt,
    symmetricDecrypt: cipher.symmetricDecrypt,
    KMAC: kmac,
    ECEphemeralKeyAgreement: require('./ecephka'),
    KDF: kdf.KDF2,
    PublicKeySerializer: require('./pkserializer'),
    PublicKeyDeserializer: require('./pkdeserializer')
}

},{"./cipher":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/js-mutual-auth-ecies/crypto/cipher.js","./digitalsig":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/js-mutual-auth-ecies/crypto/digitalsig.js","./ecephka":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/js-mutual-auth-ecies/crypto/ecephka.js","./kdf":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/js-mutual-auth-ecies/crypto/kdf.js","./kmac":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/js-mutual-auth-ecies/crypto/kmac.js","./pkdeserializer":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/js-mutual-auth-ecies/crypto/pkdeserializer.js","./pkserializer":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/js-mutual-auth-ecies/crypto/pkserializer.js","crypto":false}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/js-mutual-auth-ecies/crypto/kdf.js":[function(require,module,exports){
'use strict';

const crypto = require('crypto');
const config = require('../config')

// Implementation of KDF2 as defined in ISO/IEC 18033-2
function KDF2(x, outputByteSize, hashFunction = config.hashFunctionName, hashSize = config.hashSize) {
    if (outputByteSize < 0) {
        throw new Error("KDF output key byte size needs to be >= 0, not " + outputByteSize)
    } //silly optimization here
    else if (outputByteSize === 0) {
        return $$.Buffer.alloc(0)
    }
    let k = Math.ceil(outputByteSize / hashSize)
    k++;
    let derivedKeyBuffer = $$.Buffer.alloc(outputByteSize)
    let iBuffer = $$.Buffer.alloc(4)
    for (let i = 1; i < k; i++) {
        iBuffer.writeInt32BE(i)
        let roundInput = $$.Buffer.concat([x, iBuffer], x.length + iBuffer.length)
        let roundHash = crypto.createHash(hashFunction).update(roundInput).digest()
        roundHash.copy(derivedKeyBuffer, (i - 1) * hashSize)
    }
    return derivedKeyBuffer
}

module.exports = {
    KDF2
}

},{"../config":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/js-mutual-auth-ecies/config.js","crypto":false}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/js-mutual-auth-ecies/crypto/kmac.js":[function(require,module,exports){
'use strict';

const crypto = require('crypto');

function computeKMAC(key, data, options) {
    if (key.length !== options.macKeySize) {
        throw new Error('Invalid length of input MAC key')
    }
    return crypto.createHmac(options.hashFunctionName, key).update(data).digest();
}

function verifyKMAC(tag, key, data, options) {
    if (key.length !== options.macKeySize) {
        throw new Error('Invalid length of input MAC key')
    }
    const timingSafeEqual = require('./index').timingSafeEqual;
    const computedTag = computeKMAC(key, data, options)
    return timingSafeEqual(computedTag, tag)
}

module.exports = {
    computeKMAC,
    verifyKMAC
}

},{"./index":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/js-mutual-auth-ecies/crypto/index.js","crypto":false}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/js-mutual-auth-ecies/crypto/pkdeserializer.js":[function(require,module,exports){
'use strict';

const config = require('../config');

function PublicKeyDeserializer() {
    this.deserializeECDHPublicKey = (ecdhPublicKeySerialized, options) => {
        options = options || {};
        const defaultOpts = config;
        Object.assign(defaultOpts, options);
        options = defaultOpts;

        let encodingFormat = options.encodingFormat;
        return $$.Buffer.from(ecdhPublicKeySerialized, encodingFormat)
    }

    this.deserializeECSigVerPublicKey = (ecSigVerPublicKeySerialized, options) => {
        options = options || {};
        const defaultOpts = config;
        Object.assign(defaultOpts, options);
        options = defaultOpts;

        let encodingFormat = options.encodingFormat;
        // let publicKey = $$.Buffer.from(ecSigVerPublicKeySerialized, encodingFormat);
        const ecKeyGenerator = require("../../lib/ECKeyGenerator").createECKeyGenerator();
        const publicKey = ecKeyGenerator.convertPublicKey(ecSigVerPublicKeySerialized, {originalFormat: "der", outputFormat: "pem", encodingFormat});
        return publicKey;
    }

}

module.exports = new PublicKeyDeserializer()

},{"../../lib/ECKeyGenerator":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/lib/ECKeyGenerator.js","../config":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/js-mutual-auth-ecies/config.js"}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/js-mutual-auth-ecies/crypto/pkserializer.js":[function(require,module,exports){
const config = require('../config');

function PublicKeySerializer() {
    this.serializeECDHPublicKey = (ecdhPublicKey, options) => {
        options = options || {};
        const defaultOpts =  config;
        Object.assign(defaultOpts, options);
        options = defaultOpts;

        let encodingFormat = options.encodingFormat;
        return ecdhPublicKey.toString(encodingFormat);
    }

    this.serializeECSigVerPublicKey = (ecSigVerPublicKey, options) => {
        options = options || {};
        const defaultOpts = config;
        Object.assign(defaultOpts, options);
        options = defaultOpts;

        let encodingFormat = options.encodingFormat;
        const ecKeyGenerator = require("../../lib/ECKeyGenerator").createECKeyGenerator();
        const derPublicKey = ecKeyGenerator.convertPublicKey(ecSigVerPublicKey, {originalFormat: "pem", outputFormat: "der", encodingFormat});
        return derPublicKey.toString(encodingFormat)
    }
}

module.exports = new PublicKeySerializer()

},{"../../lib/ECKeyGenerator":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/lib/ECKeyGenerator.js","../config":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/js-mutual-auth-ecies/config.js"}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/js-mutual-auth-ecies/ecies-doa-ds/decrypt.js":[function(require,module,exports){
'use strict';

const mycrypto = require('../crypto')
const common = require('../common')
const config = require('../config')

function checkWrappedMessageMandatoryProperties(wrappedMessage) {
    const mandatoryProperties = ["from_ecsig", "msg", "sig"];
    mandatoryProperties.forEach((property) => {
        if (typeof wrappedMessage[property] === 'undefined') {
            throw new Error("Mandatory property " + property + " is missing from wrapped message");
        }
    })
}

module.exports.decrypt = function (receiverECDHPrivateKey, encEnvelope, options) {
    options = options || {};
    const defaultOpts = config;
    Object.assign(defaultOpts, options);
    options = defaultOpts;
    if (typeof encEnvelope === "string") {
        try{
            encEnvelope = JSON.parse(encEnvelope);
        }   catch (e) {
            throw Error(`Could not parse encEnvelope ${encEnvelope}`);
        }
    }

    if (typeof encEnvelope !== "object") {
        throw Error(`encEnvelope should be an object. Received ${typeof encEnvelope}`);
    }

    common.checkEncryptedEnvelopeMandatoryProperties(encEnvelope);
    const ephemeralPublicKey = $$.Buffer.from(encEnvelope.r, options.encodingFormat)

    const ephemeralKeyAgreement = new mycrypto.ECEphemeralKeyAgreement(options)
    const sharedSecret = ephemeralKeyAgreement.computeSharedSecretFromKeyPair(receiverECDHPrivateKey, ephemeralPublicKey)

    const kdfInput = common.computeKDFInput(ephemeralPublicKey, sharedSecret)
    const { symmetricEncryptionKey, macKey } = common.computeSymmetricEncAndMACKeys(kdfInput, options)

    const ciphertext = $$.Buffer.from(encEnvelope.ct, options.encodingFormat)
    const tag = $$.Buffer.from(encEnvelope.tag, options.encodingFormat)
    const iv = $$.Buffer.from(encEnvelope.iv, options.encodingFormat)

    if (!mycrypto.KMAC.verifyKMAC(tag,
        macKey,
        $$.Buffer.concat([ciphertext, iv],
            ciphertext.length + iv.length), options)
    ) {
        throw new Error("Bad MAC")
    }

    let wrappedMessageObject = JSON.parse(mycrypto.symmetricDecrypt(symmetricEncryptionKey, ciphertext, iv, options).toString())
    checkWrappedMessageMandatoryProperties(wrappedMessageObject)
    const senderECSigVerPublicKey = mycrypto.PublicKeyDeserializer.deserializeECSigVerPublicKey(wrappedMessageObject.from_ecsig)

    if (!mycrypto.verifyDigitalSignature(senderECSigVerPublicKey,
        $$.Buffer.from(wrappedMessageObject.sig, options.encodingFormat),
        sharedSecret, options)) {
        throw new Error("Bad signature")
    }
    return {
        from_ecsig: senderECSigVerPublicKey,
        message: $$.Buffer.from(wrappedMessageObject.msg, options.encodingFormat)
    };
}

},{"../common":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/js-mutual-auth-ecies/common/index.js","../config":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/js-mutual-auth-ecies/config.js","../crypto":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/js-mutual-auth-ecies/crypto/index.js"}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/js-mutual-auth-ecies/ecies-doa-ds/encrypt.js":[function(require,module,exports){
'use strict';

const mycrypto = require('../crypto')
const common = require('../common');
const config = require('../config');

function senderMessageWrapAndSerialization(senderECSigVerPublicKey, message, signature, options) {
    options = options || {};
    const defaultOpts = config;
    Object.assign(defaultOpts, options);
    options = defaultOpts;

    return JSON.stringify({
        from_ecsig: mycrypto.PublicKeySerializer.serializeECSigVerPublicKey(senderECSigVerPublicKey, options),
        msg: message.toString(options.encodingFormat),
        sig: signature.toString(options.encodingFormat)
    });
}

module.exports.encrypt = function (senderECSigningKeyPair, receiverECDHPublicKey, message, options) {
    options = options || {};
    const defaultOpts = config;
    Object.assign(defaultOpts, options);
    options = defaultOpts;

    if (typeof message === "object" && !$$.Buffer.isBuffer(message)) {
        message = JSON.stringify(message);
    }

    if (typeof message === "string") {
        message = $$.Buffer.from(message);
    }

    if (!$$.Buffer.isBuffer(message)) {
        throw new Error('Input message has to be of type Buffer');
    }

    common.checkKeyPairMandatoryProperties(senderECSigningKeyPair)

    const ephemeralKeyAgreement = new mycrypto.ECEphemeralKeyAgreement(options)
    const ephemeralPublicKey = ephemeralKeyAgreement.generateEphemeralPublicKey()
    const sharedSecret = ephemeralKeyAgreement.generateSharedSecretForPublicKey(receiverECDHPublicKey)

    const signature = mycrypto.computeDigitalSignature(senderECSigningKeyPair.privateKey, sharedSecret, options)
    const senderAuthMsgEnvelopeSerialized = senderMessageWrapAndSerialization(senderECSigningKeyPair.publicKey, message, signature, options)

    const kdfInput = common.computeKDFInput(ephemeralPublicKey, sharedSecret)
    const { symmetricEncryptionKey, macKey } = common.computeSymmetricEncAndMACKeys(kdfInput, options)

    const iv = mycrypto.getRandomBytes(options.ivSize)
    const ciphertext = mycrypto.symmetricEncrypt(symmetricEncryptionKey, senderAuthMsgEnvelopeSerialized, iv, options)
    const tag = mycrypto.KMAC.computeKMAC(macKey,
        $$.Buffer.concat([ciphertext, iv],
            ciphertext.length + iv.length), options
    )

    return common.createEncryptedEnvelopeObject(receiverECDHPublicKey, ephemeralPublicKey, ciphertext, iv, tag, options)
};

},{"../common":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/js-mutual-auth-ecies/common/index.js","../config":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/js-mutual-auth-ecies/config.js","../crypto":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/js-mutual-auth-ecies/crypto/index.js"}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/js-mutual-auth-ecies/ecies-doa-ds/index.js":[function(require,module,exports){
'use strict';

module.exports = {
  encrypt: require('./encrypt').encrypt,
  decrypt: require('./decrypt').decrypt,
  getDecodedECDHPublicKeyFromEncEnvelope: require('../common').getDecodedECDHPublicKeyFromEncEnvelope
}
},{"../common":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/js-mutual-auth-ecies/common/index.js","./decrypt":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/js-mutual-auth-ecies/ecies-doa-ds/decrypt.js","./encrypt":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/js-mutual-auth-ecies/ecies-doa-ds/encrypt.js"}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/js-mutual-auth-ecies/ecies-doa-kmac/decrypt.js":[function(require,module,exports){
'use strict';

const mycrypto = require('../crypto');
const common = require('../common')
const config = require('../config')

function checkWrappedMessageMandatoryProperties(wrappedMessage) {
    const mandatoryProperties = ["from_ecdh", "msg"];
    mandatoryProperties.forEach((property) => {
        if (typeof wrappedMessage[property] === 'undefined') {
            throw new Error("Mandatory property " + property + " is missing from wrapped message");
        }
    })
}

module.exports.decrypt = function (receiverECDHPrivateKey, encEnvelope, options) {
    options = options || {};
    const defaultOpts = config;
    Object.assign(defaultOpts, options);
    options = defaultOpts;

    if (typeof encEnvelope === "string") {
        try{
            encEnvelope = JSON.parse(encEnvelope);
        }   catch (e) {
            throw Error(`Could not parse encEnvelope ${encEnvelope}`);
        }
    }

    if (typeof encEnvelope !== "object") {
        throw Error(`encEnvelope should be an object. Received ${typeof encEnvelope}`);
    }

    common.checkEncryptedEnvelopeMandatoryProperties(encEnvelope)
    const ephemeralPublicKey = mycrypto.PublicKeyDeserializer.deserializeECDHPublicKey(encEnvelope.r, options)

    const ephemeralKeyAgreement = new mycrypto.ECEphemeralKeyAgreement(options)
    const sharedSecret = ephemeralKeyAgreement.computeSharedSecretFromKeyPair(receiverECDHPrivateKey, ephemeralPublicKey)

    const kdfInput = common.computeKDFInput(ephemeralPublicKey, sharedSecret)
    const { symmetricEncryptionKey, macKey } = common.computeSymmetricEncAndMACKeys(kdfInput, options)

    const ciphertext = $$.Buffer.from(encEnvelope.ct, options.encodingFormat)
    const tag = $$.Buffer.from(encEnvelope.tag, options.encodingFormat)
    const iv = $$.Buffer.from(encEnvelope.iv, options.encodingFormat)

    const wrappedMessageObject = JSON.parse(mycrypto.symmetricDecrypt(symmetricEncryptionKey, ciphertext, iv, options).toString())
    checkWrappedMessageMandatoryProperties(wrappedMessageObject)
    const senderPublicKey = mycrypto.PublicKeyDeserializer.deserializeECDHPublicKey(wrappedMessageObject.from_ecdh, options);

    const senderKeyAgreement = new mycrypto.ECEphemeralKeyAgreement(options)
    const senderDerivedSharedSecret = senderKeyAgreement.computeSharedSecretFromKeyPair(receiverECDHPrivateKey, senderPublicKey)
    // **TODO**: This does not seem correct, need to think about it.
    mycrypto.KMAC.verifyKMAC(tag, macKey,
        $$.Buffer.concat([ciphertext, iv, senderDerivedSharedSecret],
            ciphertext.length + iv.length + senderDerivedSharedSecret.length), options
    )

    return {
        from_ecdh: senderPublicKey,
        message: $$.Buffer.from(wrappedMessageObject.msg, options.encodingFormat)
    };
}

},{"../common":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/js-mutual-auth-ecies/common/index.js","../config":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/js-mutual-auth-ecies/config.js","../crypto":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/js-mutual-auth-ecies/crypto/index.js"}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/js-mutual-auth-ecies/ecies-doa-kmac/encrypt.js":[function(require,module,exports){
'use strict';

const mycrypto = require('../crypto');
const common = require('../common')
const config = require('../config')

function senderMessageWrapAndSerialization(senderECDHPublicKey, message) {
    return JSON.stringify({
        from_ecdh: mycrypto.PublicKeySerializer.serializeECDHPublicKey(senderECDHPublicKey),
        msg: message
    });
}

module.exports.encrypt = function (senderECDHKeyPair, receiverECDHPublicKey, message, options) {
    options = options || {};
    const defaultOpts = config;
    Object.assign(defaultOpts, options);
    options = defaultOpts;

    if (typeof message === "object" && !$$.Buffer.isBuffer(message)) {
        message = JSON.stringify(message);
    }

    if (typeof message === "string") {
        message = $$.Buffer.from(message);
    }

    if (!$$.Buffer.isBuffer(message)) {
        throw new Error('Input message has to be of type Buffer');
    }
    common.checkKeyPairMandatoryProperties(senderECDHKeyPair)
    const senderKeyAgreement = new mycrypto.ECEphemeralKeyAgreement(options)
    const senderDerivedSharedSecret = senderKeyAgreement.computeSharedSecretFromKeyPair(senderECDHKeyPair.privateKey, receiverECDHPublicKey)

    const senderAuthMsgEnvelopeSerialized = senderMessageWrapAndSerialization(senderECDHKeyPair.publicKey, message);

    const ephemeralKeyAgreement = new mycrypto.ECEphemeralKeyAgreement(options)
    const ephemeralPublicKey = ephemeralKeyAgreement.generateEphemeralPublicKey()
    const ephemeralSharedSecret = ephemeralKeyAgreement.generateSharedSecretForPublicKey(receiverECDHPublicKey)

    const kdfInput = common.computeKDFInput(ephemeralPublicKey, ephemeralSharedSecret)
    const {symmetricEncryptionKey, macKey} = common.computeSymmetricEncAndMACKeys(kdfInput, options)

    const iv = mycrypto.getRandomBytes(options.ivSize)
    const ciphertext = mycrypto.symmetricEncrypt(symmetricEncryptionKey, senderAuthMsgEnvelopeSerialized, iv, options)
    // **TODO**: This does not seem correct, need to think about it.
    const tag = mycrypto.KMAC.computeKMAC(macKey,
        $$.Buffer.concat([ciphertext, iv, senderDerivedSharedSecret],
            ciphertext.length + iv.length + senderDerivedSharedSecret.length), options
    )

    return common.createEncryptedEnvelopeObject(receiverECDHPublicKey, ephemeralPublicKey, ciphertext, iv, tag, options)
};

},{"../common":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/js-mutual-auth-ecies/common/index.js","../config":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/js-mutual-auth-ecies/config.js","../crypto":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/js-mutual-auth-ecies/crypto/index.js"}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/js-mutual-auth-ecies/ecies-doa-kmac/index.js":[function(require,module,exports){
arguments[4]["/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/js-mutual-auth-ecies/ecies-doa-ds/index.js"][0].apply(exports,arguments)
},{"../common":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/js-mutual-auth-ecies/common/index.js","./decrypt":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/js-mutual-auth-ecies/ecies-doa-kmac/decrypt.js","./encrypt":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/js-mutual-auth-ecies/ecies-doa-kmac/encrypt.js"}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/js-mutual-auth-ecies/ecies-group-encryption/ecies-ge-anon/decrypt.js":[function(require,module,exports){
'use strict';

const mycrypto = require('../../crypto')
const utils = require('../utils')
const common = require('../../common')
const config = require('../../config')

function checkEncryptedEnvelopeMandatoryProperties(encryptedEnvelope) {
    const mandatoryProperties = ["recvs", "rtag", "ct", "iv", "tag"];
    mandatoryProperties.forEach((property) => {
        if (typeof encryptedEnvelope[property] === 'undefined') {
            throw new Error("Mandatory property " + property + " is missing from input group encrypted envelope");
        }
    })
}

module.exports.decrypt = function (receiverECDHKeyPair, encEnvelope, options) {
    options = options || {};
    const defaultOpts = config;
    Object.assign(defaultOpts, options);
    options = defaultOpts;

    checkEncryptedEnvelopeMandatoryProperties(encEnvelope)
    common.checkKeyPairMandatoryProperties(receiverECDHKeyPair)
    const receiverECIESInstancesBuffer = $$.Buffer.from(encEnvelope.recvs, options.encodingFormat)

    const keyBuffer = utils.receiverMultiRecipientECIESDecrypt(receiverECDHKeyPair, receiverECIESInstancesBuffer)
    const {symmetricCipherKey, ciphertextMacKey, recvsMacKey} = utils.parseKeyBuffer(keyBuffer)

    const ciphertext = $$.Buffer.from(encEnvelope.ct, options.encodingFormat)
    const tag = $$.Buffer.from(encEnvelope.tag, options.encodingFormat)
    const iv = $$.Buffer.from(encEnvelope.iv, options.encodingFormat)
    const recvsTag = $$.Buffer.from(encEnvelope.rtag, options.encodingFormat)

    if (!mycrypto.KMAC.verifyKMAC(tag,
        ciphertextMacKey,
        $$.Buffer.concat([ciphertext, iv],
            ciphertext.length + iv.length), options)
    ) {
        throw new Error("Bad ciphertext MAC")
    }
    if (!mycrypto.KMAC.verifyKMAC(recvsTag,
        recvsMacKey,
        receiverECIESInstancesBuffer, options)
    ) {
        throw new Error("Bad recipient ECIES MAC")
    }

    return mycrypto.symmetricDecrypt(symmetricCipherKey, ciphertext, iv, options)
}

},{"../../common":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/js-mutual-auth-ecies/common/index.js","../../config":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/js-mutual-auth-ecies/config.js","../../crypto":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/js-mutual-auth-ecies/crypto/index.js","../utils":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/js-mutual-auth-ecies/ecies-group-encryption/utils/index.js"}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/js-mutual-auth-ecies/ecies-group-encryption/ecies-ge-anon/encrypt.js":[function(require,module,exports){
'use strict';

const utils = require('../utils')
const mycrypto = require('../../crypto')
const config = require('../../config')

module.exports.encrypt = function (message, ...receiverECDHPublicKeys) {
    let options;
    const lastArg = receiverECDHPublicKeys[receiverECDHPublicKeys.length - 1];
    if (typeof lastArg === "object" && !Array.isArray(lastArg) && !$$.Buffer.isBuffer(lastArg) && !(lastArg instanceof Uint8Array)) {
        options = receiverECDHPublicKeys.pop();
    } else {
        options = {};
    }

    const defaultOpts = config;
    Object.assign(defaultOpts, options);
    options = defaultOpts;

    if (typeof message === "object" && !$$.Buffer.isBuffer(message)) {
        message = JSON.stringify(message);
    }

    if (typeof message === "string") {
        message = $$.Buffer.from(message);
    }

    if (!$$.Buffer.isBuffer(message)) {
        throw new Error('Input message has to be of type Buffer');
    }

    if (receiverECDHPublicKeys.length === 0) {
        throw new Error('Need to specify at least one receiver public key')
    }

    receiverECDHPublicKeys.push(options);
    const { symmetricCipherKey, ciphertextMacKey, recvsMacKey } = utils.generateKeyBufferParams(options)
    const multiRecipientECIESBuffer = utils.senderMultiRecipientECIESEncrypt(
        $$.Buffer.concat([symmetricCipherKey, ciphertextMacKey, recvsMacKey],
            symmetricCipherKey.length + ciphertextMacKey.length + recvsMacKey.length),
        ...receiverECDHPublicKeys)

    const iv = mycrypto.getRandomBytes(options.ivSize)
    const ciphertext = mycrypto.symmetricEncrypt(symmetricCipherKey, message, iv, options)
    const tag = mycrypto.KMAC.computeKMAC(ciphertextMacKey,
        $$.Buffer.concat(
            [ciphertext, iv],
            ciphertext.length + iv.length), options
    );
    const recvsTag = mycrypto.KMAC.computeKMAC(recvsMacKey, multiRecipientECIESBuffer, options)

    return {
        recvs: multiRecipientECIESBuffer.toString(options.encodingFormat),
        rtag: recvsTag.toString(options.encodingFormat),
        ct: ciphertext.toString(options.encodingFormat),
        iv: iv.toString(options.encodingFormat),
        tag: tag.toString(options.encodingFormat)
    }
}

},{"../../config":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/js-mutual-auth-ecies/config.js","../../crypto":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/js-mutual-auth-ecies/crypto/index.js","../utils":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/js-mutual-auth-ecies/ecies-group-encryption/utils/index.js"}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/js-mutual-auth-ecies/ecies-group-encryption/ecies-ge-anon/index.js":[function(require,module,exports){
'use strict';

module.exports = {
  encrypt: require('./encrypt').encrypt,
  decrypt: require('./decrypt').decrypt,
  getRecipientECDHPublicKeysFromEncEnvelope: require('../utils').getRecipientECDHPublicKeysFromEncEnvelope
}

},{"../utils":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/js-mutual-auth-ecies/ecies-group-encryption/utils/index.js","./decrypt":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/js-mutual-auth-ecies/ecies-group-encryption/ecies-ge-anon/decrypt.js","./encrypt":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/js-mutual-auth-ecies/ecies-group-encryption/ecies-ge-anon/encrypt.js"}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/js-mutual-auth-ecies/ecies-group-encryption/ecies-ge-doa/decrypt.js":[function(require,module,exports){
'use strict';

const mycrypto = require('../../crypto')
const config = require('../../config')
const common = require('../../common')
const eciesGEAnon = require('../ecies-ge-anon')

function checkEncryptedEnvelopeMandatoryProperties(encryptedEnvelope) {
    const mandatoryProperties = ["from_ecsig", "sig"];
    mandatoryProperties.forEach((property) => {
        if (typeof encryptedEnvelope[property] === 'undefined') {
            throw new Error("Mandatory property " + property + " is missing from input encrypted envelope");
        }
    })
}

module.exports.decrypt = function (receiverECDHKeyPair, encEnvelope, options) {
    options = options || {};
    const defaultOpts = config;
    Object.assign(defaultOpts, options);
    options = defaultOpts;

    checkEncryptedEnvelopeMandatoryProperties(encEnvelope)
    common.checkKeyPairMandatoryProperties(receiverECDHKeyPair)

    let tempGEAnonEnvelope = Object.assign({}, encEnvelope)
    delete tempGEAnonEnvelope.from_ecsig;
    delete tempGEAnonEnvelope.sig;
    const message = eciesGEAnon.decrypt(receiverECDHKeyPair, tempGEAnonEnvelope, options)
    tempGEAnonEnvelope = null;

    const senderECSigVerPublicKey = mycrypto.PublicKeyDeserializer.deserializeECSigVerPublicKey(encEnvelope.from_ecsig, options)

    const recvsTagBuffer = $$.Buffer.from(encEnvelope.rtag, options.encodingFormat)
    const tagBuffer = $$.Buffer.from(encEnvelope.tag, options.encodingFormat)
    const signature = $$.Buffer.from(encEnvelope.sig, options.encodingFormat)
    if (!mycrypto.verifyDigitalSignature(senderECSigVerPublicKey,
        signature,
        $$.Buffer.concat([recvsTagBuffer, tagBuffer],
            recvsTagBuffer.length + tagBuffer.length), options)
    ) {
        throw new Error("Bad signature")
    }

    return {
        from: senderECSigVerPublicKey,
        message: message
    }
}

},{"../../common":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/js-mutual-auth-ecies/common/index.js","../../config":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/js-mutual-auth-ecies/config.js","../../crypto":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/js-mutual-auth-ecies/crypto/index.js","../ecies-ge-anon":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/js-mutual-auth-ecies/ecies-group-encryption/ecies-ge-anon/index.js"}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/js-mutual-auth-ecies/ecies-group-encryption/ecies-ge-doa/encrypt.js":[function(require,module,exports){
'use strict';

const mycrypto = require('../../crypto')
const common = require('../../common')
const config = require('../../config')
const eciesGEAnon = require('../ecies-ge-anon')

module.exports.encrypt = function (senderECSigningKeyPair, message, ...receiverECDHPublicKeys) {
    let options;
    const lastArg = receiverECDHPublicKeys[receiverECDHPublicKeys.length - 1];
    if (typeof lastArg === "object" && !Array.isArray(lastArg) && !$$.Buffer.isBuffer(lastArg) && !(lastArg instanceof Uint8Array)) {
        options = receiverECDHPublicKeys.pop();
    } else {
        options = {};
    }

    const defaultOpts = config;
    Object.assign(defaultOpts, options);
    options = defaultOpts;

    if (typeof message === "object" && !$$.Buffer.isBuffer(message)) {
        message = JSON.stringify(message);
    }

    if (typeof message === "string") {
        message = $$.Buffer.from(message);
    }

    if (!$$.Buffer.isBuffer(message)) {
        throw new Error('Input message has to be of type Buffer');
    }

    common.checkKeyPairMandatoryProperties(senderECSigningKeyPair);
    receiverECDHPublicKeys.push(options);
    let eciesGEEnvelope = eciesGEAnon.encrypt(message, ...receiverECDHPublicKeys)

    const recvsTagBuffer = $$.Buffer.from(eciesGEEnvelope.rtag, options.encodingFormat)
    const tagBuffer = $$.Buffer.from(eciesGEEnvelope.tag, options.encodingFormat)
    const signature = mycrypto.computeDigitalSignature(senderECSigningKeyPair.privateKey,
        $$.Buffer.concat([recvsTagBuffer, tagBuffer],
            recvsTagBuffer.length + tagBuffer.length), options)

    eciesGEEnvelope.sig = signature.toString(options.encodingFormat)
    eciesGEEnvelope.from_ecsig = mycrypto.PublicKeySerializer.serializeECSigVerPublicKey(senderECSigningKeyPair.publicKey, options)

    return eciesGEEnvelope;
}

},{"../../common":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/js-mutual-auth-ecies/common/index.js","../../config":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/js-mutual-auth-ecies/config.js","../../crypto":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/js-mutual-auth-ecies/crypto/index.js","../ecies-ge-anon":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/js-mutual-auth-ecies/ecies-group-encryption/ecies-ge-anon/index.js"}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/js-mutual-auth-ecies/ecies-group-encryption/ecies-ge-doa/index.js":[function(require,module,exports){
arguments[4]["/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/js-mutual-auth-ecies/ecies-group-encryption/ecies-ge-anon/index.js"][0].apply(exports,arguments)
},{"../utils":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/js-mutual-auth-ecies/ecies-group-encryption/utils/index.js","./decrypt":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/js-mutual-auth-ecies/ecies-group-encryption/ecies-ge-doa/decrypt.js","./encrypt":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/js-mutual-auth-ecies/ecies-group-encryption/ecies-ge-doa/encrypt.js"}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/js-mutual-auth-ecies/ecies-group-encryption/utils/index.js":[function(require,module,exports){
'use strict';

const sender = require('./sender')
const recipient = require('./recipient')

module.exports = {
    generateKeyBufferParams: sender.generateKeyBufferParams,
    senderMultiRecipientECIESEncrypt: sender.senderMultiRecipientECIESEncrypt,
    getRecipientECDHPublicKeysFromEncEnvelope: recipient.getRecipientECDHPublicKeysFromEncEnvelope,
    receiverMultiRecipientECIESDecrypt: recipient.receiverMultiRecipientECIESDecrypt,
    parseKeyBuffer: recipient.parseKeyBuffer
}



},{"./recipient":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/js-mutual-auth-ecies/ecies-group-encryption/utils/recipient.js","./sender":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/js-mutual-auth-ecies/ecies-group-encryption/utils/sender.js"}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/js-mutual-auth-ecies/ecies-group-encryption/utils/recipient.js":[function(require,module,exports){
'use strict';

const mycrypto = require('../../crypto')
const common = require('../../common')
const ecies = require('../../ecies')
const config = require('../../config')

module.exports.getRecipientECDHPublicKeysFromEncEnvelope = function (encEnvelope, options) {
    options = options || {};
    const defaultOpts = config;
    Object.assign(defaultOpts, options);
    options = defaultOpts;

    if (encEnvelope.recvs === undefined) {
        throw new Error('Mandatory property recvs not found in encrypted envelope')
    }
    let multiRecipientECIESEnvelopeArray = JSON.parse($$.Buffer.from(encEnvelope.recvs, options.encodingFormat))
    if (multiRecipientECIESEnvelopeArray.length === 0) {
        throw new Error('Invalid receiver array in encrypted envelope')
    }
    let recipientECDHPublicKeyArray = [];
    multiRecipientECIESEnvelopeArray.forEach(function (curRecipientECIESEnvelope) {
        common.checkEncryptedEnvelopeMandatoryProperties(curRecipientECIESEnvelope)
        let curRecipientECDHPublicKey = common.getDecodedECDHPublicKeyFromEncEnvelope(curRecipientECIESEnvelope, options)
        recipientECDHPublicKeyArray.push(curRecipientECDHPublicKey)
    })
    if (recipientECDHPublicKeyArray.length === 0) {
        throw new Error('Unable to parse any of the receivers\' ECIES instances')
    }
    return recipientECDHPublicKeyArray;
}

function isECIESEnvelopeForInputECDHPublicKey(eciesEnvelope, ecdhPublicKey, options) {
    const ecdhPublicKeyBuffer = $$.Buffer.from(mycrypto.PublicKeySerializer.serializeECDHPublicKey(ecdhPublicKey, options))
    const envelopeECDHPublicKey = $$.Buffer.from(eciesEnvelope.to_ecdh)
    return mycrypto.timingSafeEqual(envelopeECDHPublicKey, ecdhPublicKeyBuffer);
}

module.exports.receiverMultiRecipientECIESDecrypt = function(receiverECDHKeyPair, multiRecipientECIESBuffer, options) {
    options = options || {};
    const defaultOpts = config;
    Object.assign(defaultOpts, options);
    options = defaultOpts;

    let multiRecipientECIESEnvelopeArray = JSON.parse(multiRecipientECIESBuffer)
    if (multiRecipientECIESEnvelopeArray.length === 0) {
        throw new Error("Parsed an empty receivers ECIES instances array")
    }
    let myECIESInstanceFound = false;
    let message;
    multiRecipientECIESEnvelopeArray.forEach(function (curRecipientECIESEnvelope) {
        common.checkEncryptedEnvelopeMandatoryProperties(curRecipientECIESEnvelope)
        if (isECIESEnvelopeForInputECDHPublicKey(curRecipientECIESEnvelope, receiverECDHKeyPair.publicKey, options)) {
            message = ecies.decrypt(receiverECDHKeyPair.privateKey, curRecipientECIESEnvelope, options)
            myECIESInstanceFound = true;
            return;
        }
    })
    if (!myECIESInstanceFound) {
        throw new Error("Unable to decrypt input envelope with input EC key pair")
    }
    return message;
}

module.exports.parseKeyBuffer = function (keyBuffer, options) {
    options = options || {};
    const defaultOpts = config;
    Object.assign(defaultOpts, options);

    options = defaultOpts;
    if (keyBuffer.length !== (options.symmetricCipherKeySize + (2*options.macKeySize))) {
        throw new Error("Invalid length of decrypted key buffer")
    }
    const symmetricCipherKey = keyBuffer.slice(0, options.symmetricCipherKeySize)
    const ciphertextMacKey = keyBuffer.slice(options.symmetricCipherKeySize, options.symmetricCipherKeySize + options.macKeySize)
    const recvsMacKey = keyBuffer.slice(options.symmetricCipherKeySize + options.macKeySize)
    return {
        symmetricCipherKey,
        ciphertextMacKey,
        recvsMacKey
    }
}

},{"../../common":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/js-mutual-auth-ecies/common/index.js","../../config":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/js-mutual-auth-ecies/config.js","../../crypto":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/js-mutual-auth-ecies/crypto/index.js","../../ecies":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/js-mutual-auth-ecies/ecies/index.js"}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/js-mutual-auth-ecies/ecies-group-encryption/utils/sender.js":[function(require,module,exports){
'use strict';

const mycrypto = require('../../crypto')
const ecies = require('../../ecies')
const config = require('../../config')

module.exports.generateKeyBufferParams = function (options) {
    const symmetricCipherKey = mycrypto.getRandomBytes(options.symmetricCipherKeySize)
    const ciphertextMacKey = mycrypto.getRandomBytes(options.macKeySize)
    const recvsMacKey = mycrypto.getRandomBytes(options.macKeySize)
    return {
        symmetricCipherKey,
        ciphertextMacKey,
        recvsMacKey
    }
}

module.exports.senderMultiRecipientECIESEncrypt = function(message, ...receiverECDHPublicKeyArray) {
    let options;
    const lastArg = receiverECDHPublicKeyArray[receiverECDHPublicKeyArray.length - 1];
    if (typeof lastArg === "object" && !Array.isArray(lastArg) && !$$.Buffer.isBuffer(lastArg) && !(lastArg instanceof Uint8Array)) {
        options = receiverECDHPublicKeyArray.pop();
    } else {
        options = {};
    }

    const defaultOpts = config;
    Object.assign(defaultOpts, options);
    options = defaultOpts;

    let eciesInstancesArray = []
    receiverECDHPublicKeyArray.forEach(function (curReceiverECDHPublicKey) {
        eciesInstancesArray.push(ecies.encrypt(curReceiverECDHPublicKey, message, options))
    })
    return $$.Buffer.from(JSON.stringify(eciesInstancesArray))
}

},{"../../config":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/js-mutual-auth-ecies/config.js","../../crypto":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/js-mutual-auth-ecies/crypto/index.js","../../ecies":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/js-mutual-auth-ecies/ecies/index.js"}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/js-mutual-auth-ecies/ecies/decrypt.js":[function(require,module,exports){
'use strict';

const mycrypto = require('../crypto')
const common = require('../common')
const config = require('../config')


module.exports.decrypt = function (receiverECDHPrivateKey, encEnvelope, options) {
    options = options || {};
    const defaultOpts = config;
    Object.assign(defaultOpts, options);
    options = defaultOpts;

    if (typeof encEnvelope === "string") {
        try{
            encEnvelope = JSON.parse(encEnvelope);
        }   catch (e) {
            throw Error(`Could not parse encEnvelope ${encEnvelope}`);
        }
    }

    if (typeof encEnvelope !== "object") {
        throw Error(`encEnvelope should be an object. Received ${typeof encEnvelope}`);
    }

    common.checkEncryptedEnvelopeMandatoryProperties(encEnvelope)

    const ephemeralPublicKey = mycrypto.PublicKeyDeserializer.deserializeECDHPublicKey(encEnvelope.r, options)

    const ephemeralKeyAgreement = new mycrypto.ECEphemeralKeyAgreement(options)
    const sharedSecret = ephemeralKeyAgreement.computeSharedSecretFromKeyPair(receiverECDHPrivateKey, ephemeralPublicKey)

    const kdfInput = common.computeKDFInput(ephemeralPublicKey, sharedSecret)
    const { symmetricEncryptionKey, macKey } = common.computeSymmetricEncAndMACKeys(kdfInput, options)

    const ciphertext = $$.Buffer.from(encEnvelope.ct, options.encodingFormat)
    const tag = $$.Buffer.from(encEnvelope.tag, options.encodingFormat)
    const iv = $$.Buffer.from(encEnvelope.iv, options.encodingFormat)

    if (!mycrypto.KMAC.verifyKMAC(tag,
        macKey,
        $$.Buffer.concat([ciphertext, iv],
            ciphertext.length + iv.length), options)
    ) {
        throw new Error("Bad MAC")
    }

    return mycrypto.symmetricDecrypt(symmetricEncryptionKey, ciphertext, iv, options)
}

},{"../common":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/js-mutual-auth-ecies/common/index.js","../config":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/js-mutual-auth-ecies/config.js","../crypto":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/js-mutual-auth-ecies/crypto/index.js"}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/js-mutual-auth-ecies/ecies/encrypt.js":[function(require,module,exports){
'use strict';

const mycrypto = require('../crypto')
const common = require('../common')
const config = require('../config');

module.exports.encrypt = function (receiverECDHPublicKey, message, options) {
    options = options || {};
    const defaultOpts = config;
    Object.assign(defaultOpts, options);
    options = defaultOpts;

    if (typeof message === "object" && !$$.Buffer.isBuffer(message)) {
        message = JSON.stringify(message);
    }

    if (typeof message === "string") {
        message = $$.Buffer.from(message);
    }

    if (!$$.Buffer.isBuffer(message)) {
        throw new Error('Input message has to be of type Buffer');
    }

    const ephemeralKeyAgreement = new mycrypto.ECEphemeralKeyAgreement(options)
    const ephemeralPublicKey = ephemeralKeyAgreement.generateEphemeralPublicKey()
    const sharedSecret = ephemeralKeyAgreement.generateSharedSecretForPublicKey(receiverECDHPublicKey)

    const kdfInput = common.computeKDFInput(ephemeralPublicKey, sharedSecret)
    const { symmetricEncryptionKey, macKey } = common.computeSymmetricEncAndMACKeys(kdfInput, options)

    const iv = mycrypto.getRandomBytes(options.ivSize)
    const ciphertext = mycrypto.symmetricEncrypt(symmetricEncryptionKey, message, iv, options)
    const tag = mycrypto.KMAC.computeKMAC(macKey,
        $$.Buffer.concat([ciphertext, iv],
            ciphertext.length + iv.length), options
    )

    return common.createEncryptedEnvelopeObject(receiverECDHPublicKey, ephemeralPublicKey, ciphertext, iv, tag, options)
}

},{"../common":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/js-mutual-auth-ecies/common/index.js","../config":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/js-mutual-auth-ecies/config.js","../crypto":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/js-mutual-auth-ecies/crypto/index.js"}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/js-mutual-auth-ecies/ecies/index.js":[function(require,module,exports){
arguments[4]["/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/js-mutual-auth-ecies/ecies-doa-ds/index.js"][0].apply(exports,arguments)
},{"../common":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/js-mutual-auth-ecies/common/index.js","./decrypt":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/js-mutual-auth-ecies/ecies/decrypt.js","./encrypt":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/js-mutual-auth-ecies/ecies/encrypt.js"}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/js-mutual-auth-ecies/index.js":[function(require,module,exports){
module.exports = {
    ecies_encrypt: require("./ecies").encrypt,
    ecies_decrypt: require("./ecies").decrypt,
    ecies_encrypt_ds: require("./ecies-doa-ds").encrypt,
    ecies_decrypt_ds: require("./ecies-doa-ds").decrypt,
    ecies_encrypt_kmac: require("./ecies-doa-kmac").encrypt,
    ecies_decrypt_kmac: require("./ecies-doa-kmac").decrypt,
    ecies_getDecodedECDHPublicKeyFromEncEnvelope: require("./ecies/index").getDecodedECDHPublicKeyFromEncEnvelope,
    ecies_group_encrypt: require("./ecies-group-encryption/ecies-ge-anon").encrypt,
    ecies_group_decrypt: require("./ecies-group-encryption/ecies-ge-anon").decrypt,
    ecies_group_encrypt_ds: require("./ecies-group-encryption/ecies-ge-doa").encrypt,
    ecies_group_decrypt_ds: require("./ecies-group-encryption/ecies-ge-doa").decrypt,
    ecies_group_getRecipientECDHPublicKeysFromEncEnvelope: require("./ecies-group-encryption/ecies-ge-doa").getRecipientECDHPublicKeysFromEncEnvelope
}

},{"./ecies":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/js-mutual-auth-ecies/ecies/index.js","./ecies-doa-ds":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/js-mutual-auth-ecies/ecies-doa-ds/index.js","./ecies-doa-kmac":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/js-mutual-auth-ecies/ecies-doa-kmac/index.js","./ecies-group-encryption/ecies-ge-anon":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/js-mutual-auth-ecies/ecies-group-encryption/ecies-ge-anon/index.js","./ecies-group-encryption/ecies-ge-doa":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/js-mutual-auth-ecies/ecies-group-encryption/ecies-ge-doa/index.js","./ecies/index":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/js-mutual-auth-ecies/ecies/index.js"}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jsonWebToken/decode.js":[function(require,module,exports){
var jws = require('./jws');

module.exports = function (jwt, options) {
    options = options || {};
    var decoded = jws.decode(jwt, options);
    if (!decoded) { return null; }
    var payload = decoded.payload;

    //try parse the payload
    if(typeof payload === 'string') {
        try {
            var obj = JSON.parse(payload);
            if(obj !== null && typeof obj === 'object') {
                payload = obj;
            }
        } catch (e) { }
    }

    //return header if `complete` option is enabled.  header includes claims
    //such as `kid` and `alg` used to select the key within a JWKS needed to
    //verify the signature
    if (options.complete === true) {
        return {
            header: decoded.header,
            payload: payload,
            signature: decoded.signature
        };
    }
    return payload;
};
},{"./jws":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jsonWebToken/jws/index.js"}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jsonWebToken/index.js":[function(require,module,exports){
module.exports = {
    verify: require('./verify'),
    sign: require('./sign'),
};

Object.defineProperty(module.exports, 'decode', {
    enumerable: false,
    value: require('./decode'),
});

},{"./decode":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jsonWebToken/decode.js","./sign":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jsonWebToken/sign.js","./verify":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jsonWebToken/verify.js"}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jsonWebToken/jwa/ecdsa-sig-formatter.js":[function(require,module,exports){
var getParamBytesForAlg = require('./param-bytes-for-alg');

var MAX_OCTET = 0x80,
    CLASS_UNIVERSAL = 0,
    PRIMITIVE_BIT = 0x20,
    TAG_SEQ = 0x10,
    TAG_INT = 0x02,
    ENCODED_TAG_SEQ = (TAG_SEQ | PRIMITIVE_BIT) | (CLASS_UNIVERSAL << 6),
    ENCODED_TAG_INT = TAG_INT | (CLASS_UNIVERSAL << 6);

function base64Url(base64) {
    return base64
        .replace(/=/g, '')
        .replace(/\+/g, '-')
        .replace(/\//g, '_');
}

function signatureAsBuffer(signature) {
    if ($$.Buffer.isBuffer(signature)) {
        return signature;
    } else if ('string' === typeof signature) {
        return $$.Buffer.from(signature, 'base64');
    }

    throw new TypeError('ECDSA signature must be a Base64 string or a $$.Buffer');
}

function derToJose(signature, alg) {
    signature = signatureAsBuffer(signature);
    var paramBytes = getParamBytesForAlg(alg);

    // the DER encoded param should at most be the param size, plus a padding
    // zero, since due to being a signed integer
    var maxEncodedParamLength = paramBytes + 1;

    var inputLength = signature.length;

    var offset = 0;
    if (signature[offset++] !== ENCODED_TAG_SEQ) {
        throw new Error('Could not find expected "seq"');
    }

    var seqLength = signature[offset++];
    if (seqLength === (MAX_OCTET | 1)) {
        seqLength = signature[offset++];
    }

    if (inputLength - offset < seqLength) {
        throw new Error('"seq" specified length of "' + seqLength + '", only "' + (inputLength - offset) + '" remaining');
    }

    if (signature[offset++] !== ENCODED_TAG_INT) {
        throw new Error('Could not find expected "int" for "r"');
    }

    var rLength = signature[offset++];

    if (inputLength - offset - 2 < rLength) {
        throw new Error('"r" specified length of "' + rLength + '", only "' + (inputLength - offset - 2) + '" available');
    }

    if (maxEncodedParamLength < rLength) {
        throw new Error('"r" specified length of "' + rLength + '", max of "' + maxEncodedParamLength + '" is acceptable');
    }

    var rOffset = offset;
    offset += rLength;

    if (signature[offset++] !== ENCODED_TAG_INT) {
        throw new Error('Could not find expected "int" for "s"');
    }

    var sLength = signature[offset++];

    if (inputLength - offset !== sLength) {
        throw new Error('"s" specified length of "' + sLength + '", expected "' + (inputLength - offset) + '"');
    }

    if (maxEncodedParamLength < sLength) {
        throw new Error('"s" specified length of "' + sLength + '", max of "' + maxEncodedParamLength + '" is acceptable');
    }

    var sOffset = offset;
    offset += sLength;

    if (offset !== inputLength) {
        throw new Error('Expected to consume entire buffer, but "' + (inputLength - offset) + '" bytes remain');
    }

    var rPadding = paramBytes - rLength,
        sPadding = paramBytes - sLength;

    var dst = $$.Buffer.allocUnsafe(rPadding + rLength + sPadding + sLength);

    for (offset = 0; offset < rPadding; ++offset) {
        dst[offset] = 0;
    }
    signature.copy(dst, offset, rOffset + Math.max(-rPadding, 0), rOffset + rLength);

    offset = paramBytes;

    for (var o = offset; offset < o + sPadding; ++offset) {
        dst[offset] = 0;
    }
    signature.copy(dst, offset, sOffset + Math.max(-sPadding, 0), sOffset + sLength);

    dst = dst.toString('base64');
    dst = base64Url(dst);

    return dst;
}

function countPadding(buf, start, stop) {
    var padding = 0;
    while (start + padding < stop && buf[start + padding] === 0) {
        ++padding;
    }

    var needsSign = buf[start + padding] >= MAX_OCTET;
    if (needsSign) {
        --padding;
    }

    return padding;
}

function joseToDer(signature, alg) {
    signature = signatureAsBuffer(signature);
    var paramBytes = getParamBytesForAlg(alg);

    var signatureBytes = signature.length;
    if (signatureBytes !== paramBytes * 2) {
        throw new TypeError('"' + alg + '" signatures must be "' + paramBytes * 2 + '" bytes, saw "' + signatureBytes + '"');
    }

    var rPadding = countPadding(signature, 0, paramBytes);
    var sPadding = countPadding(signature, paramBytes, signature.length);
    var rLength = paramBytes - rPadding;
    var sLength = paramBytes - sPadding;

    var rsBytes = 1 + 1 + rLength + 1 + 1 + sLength;

    var shortLength = rsBytes < MAX_OCTET;

    var dst = $$.Buffer.allocUnsafe((shortLength ? 2 : 3) + rsBytes);

    var offset = 0;
    dst[offset++] = ENCODED_TAG_SEQ;
    if (shortLength) {
        // Bit 8 has value "0"
        // bits 7-1 give the length.
        dst[offset++] = rsBytes;
    } else {
        // Bit 8 of first octet has value "1"
        // bits 7-1 give the number of additional length octets.
        dst[offset++] = MAX_OCTET	| 1;
        // length, base 256
        dst[offset++] = rsBytes & 0xff;
    }
    dst[offset++] = ENCODED_TAG_INT;
    dst[offset++] = rLength;
    if (rPadding < 0) {
        dst[offset++] = 0;
        offset += signature.copy(dst, offset, 0, paramBytes);
    } else {
        offset += signature.copy(dst, offset, rPadding, paramBytes);
    }
    dst[offset++] = ENCODED_TAG_INT;
    dst[offset++] = sLength;
    if (sPadding < 0) {
        dst[offset++] = 0;
        signature.copy(dst, offset, paramBytes);
    } else {
        signature.copy(dst, offset, paramBytes + sPadding);
    }

    return dst;
}

module.exports = {
    derToJose: derToJose,
    joseToDer: joseToDer
};
},{"./param-bytes-for-alg":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jsonWebToken/jwa/param-bytes-for-alg.js"}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jsonWebToken/jwa/index.js":[function(require,module,exports){
var crypto = require('crypto');
var formatEcdsa = require('./ecdsa-sig-formatter');
var util = require('util');

var MSG_INVALID_ALGORITHM = '"%s" is not a valid algorithm.\n  Supported algorithms are:\n  "HS256", "HS384", "HS512", "RS256", "RS384", "RS512", "PS256", "PS384", "PS512", "ES256", "ES384", "ES512" and "none".'
var MSG_INVALID_SECRET = 'secret must be a string or buffer';
var MSG_INVALID_VERIFIER_KEY = 'key must be a string or a buffer';
var MSG_INVALID_SIGNER_KEY = 'key must be a string, a buffer or an object';

var supportsKeyObjects = typeof crypto.createPublicKey === 'function';
if (supportsKeyObjects) {
    MSG_INVALID_VERIFIER_KEY += ' or a KeyObject';
    MSG_INVALID_SECRET += 'or a KeyObject';
}

function checkIsPublicKey(key) {
    if ($$.Buffer.isBuffer(key)) {
        return;
    }

    if (typeof key === 'string') {
        return;
    }

    if (!supportsKeyObjects) {
        throw typeError(MSG_INVALID_VERIFIER_KEY);
    }

    if (typeof key !== 'object') {
        throw typeError(MSG_INVALID_VERIFIER_KEY);
    }

    if (typeof key.type !== 'string') {
        throw typeError(MSG_INVALID_VERIFIER_KEY);
    }

    if (typeof key.asymmetricKeyType !== 'string') {
        throw typeError(MSG_INVALID_VERIFIER_KEY);
    }

    if (typeof key.export !== 'function') {
        throw typeError(MSG_INVALID_VERIFIER_KEY);
    }
}

function checkIsPrivateKey(key) {
    if ($$.Buffer.isBuffer(key)) {
        return;
    }

    if (typeof key === 'string') {
        return;
    }

    if (typeof key === 'object') {
        return;
    }

    throw typeError(MSG_INVALID_SIGNER_KEY);
}

function checkIsSecretKey(key) {
    if ($$.Buffer.isBuffer(key)) {
        return;
    }

    if (typeof key === 'string') {
        return key;
    }

    if (!supportsKeyObjects) {
        throw typeError(MSG_INVALID_SECRET);
    }

    if (typeof key !== 'object') {
        throw typeError(MSG_INVALID_SECRET);
    }

    if (key.type !== 'secret') {
        throw typeError(MSG_INVALID_SECRET);
    }

    if (typeof key.export !== 'function') {
        throw typeError(MSG_INVALID_SECRET);
    }
}

function fromBase64(base64) {
    return base64
        .replace(/=/g, '')
        .replace(/\+/g, '-')
        .replace(/\//g, '_');
}

function toBase64(base64url) {
    base64url = base64url.toString();

    var padding = 4 - base64url.length % 4;
    if (padding !== 4) {
        for (var i = 0; i < padding; ++i) {
            base64url += '=';
        }
    }

    return base64url
        .replace(/\-/g, '+')
        .replace(/_/g, '/');
}

function typeError(template) {
    var args = [].slice.call(arguments, 1);
    var errMsg = util.format.bind(util, template).apply(null, args);
    return new TypeError(errMsg);
}

function bufferOrString(obj) {
    return $$.Buffer.isBuffer(obj) || typeof obj === 'string';
}

function normalizeInput(thing) {
    if (!bufferOrString(thing))
        thing = JSON.stringify(thing);
    return thing;
}

function createHmacSigner(bits) {
    return function sign(thing, secret) {
        checkIsSecretKey(secret);
        thing = normalizeInput(thing);
        var hmac = crypto.createHmac('sha' + bits, secret);
        var sig = (hmac.update(thing), hmac.digest('base64'))
        return fromBase64(sig);
    }
}

function createHmacVerifier(bits) {
    return function verify(thing, signature, secret) {
        var computedSig = createHmacSigner(bits)(thing, secret);
        return $$.Buffer.from(signature).equals($$.Buffer.from(computedSig));
    }
}

function createKeySigner(bits) {
    return function sign(thing, privateKey) {
        checkIsPrivateKey(privateKey);
        thing = normalizeInput(thing);
        // Even though we are specifying "RSA" here, this works with ECDSA
        // keys as well.
        var signer = crypto.createSign('RSA-SHA' + bits);
        var sig = (signer.update(thing), signer.sign(privateKey, 'base64'));
        return fromBase64(sig);
    }
}

function createKeyVerifier(bits) {
    return function verify(thing, signature, publicKey) {
        checkIsPublicKey(publicKey);
        thing = normalizeInput(thing);
        signature = toBase64(signature);
        var verifier = crypto.createVerify('RSA-SHA' + bits);
        verifier.update(thing);
        return verifier.verify(publicKey, signature, 'base64');
    }
}

function createPSSKeySigner(bits) {
    return function sign(thing, privateKey) {
        checkIsPrivateKey(privateKey);
        thing = normalizeInput(thing);
        var signer = crypto.createSign('RSA-SHA' + bits);
        var sig = (signer.update(thing), signer.sign({
            key: privateKey,
            padding: crypto.constants.RSA_PKCS1_PSS_PADDING,
            saltLength: crypto.constants.RSA_PSS_SALTLEN_DIGEST
        }, 'base64'));
        return fromBase64(sig);
    }
}

function createPSSKeyVerifier(bits) {
    return function verify(thing, signature, publicKey) {
        checkIsPublicKey(publicKey);
        thing = normalizeInput(thing);
        signature = toBase64(signature);
        var verifier = crypto.createVerify('RSA-SHA' + bits);
        verifier.update(thing);
        return verifier.verify({
            key: publicKey,
            padding: crypto.constants.RSA_PKCS1_PSS_PADDING,
            saltLength: crypto.constants.RSA_PSS_SALTLEN_DIGEST
        }, signature, 'base64');
    }
}

function createECDSASigner(bits) {
    var inner = createKeySigner(bits);
    return function sign() {
        var signature = inner.apply(null, arguments);
        signature = formatEcdsa.derToJose(signature, 'ES' + bits);
        return signature;
    };
}

function createECDSAVerifer(bits) {
    var inner = createKeyVerifier(bits);
    return function verify(thing, signature, publicKey) {
        signature = formatEcdsa.joseToDer(signature, 'ES' + bits).toString('base64');
        var result = inner(thing, signature, publicKey);
        return result;
    };
}

function createNoneSigner() {
    return function sign() {
        return '';
    }
}

function createNoneVerifier() {
    return function verify(thing, signature) {
        return signature === '';
    }
}

module.exports = function jwa(algorithm) {
    var signerFactories = {
        hs: createHmacSigner,
        rs: createKeySigner,
        ps: createPSSKeySigner,
        es: createECDSASigner,
        none: createNoneSigner,
    }
    var verifierFactories = {
        hs: createHmacVerifier,
        rs: createKeyVerifier,
        ps: createPSSKeyVerifier,
        es: createECDSAVerifer,
        none: createNoneVerifier,
    }
    var match = algorithm.match(/^(RS|PS|ES|HS)(256|384|512)$|^(none)$/);
    if (!match)
        throw typeError(MSG_INVALID_ALGORITHM, algorithm);
    var algo = (match[1] || match[3]).toLowerCase();
    var bits = match[2];

    return {
        sign: signerFactories[algo](bits),
        verify: verifierFactories[algo](bits),
    }
};
},{"./ecdsa-sig-formatter":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jsonWebToken/jwa/ecdsa-sig-formatter.js","crypto":false,"util":false}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jsonWebToken/jwa/param-bytes-for-alg.js":[function(require,module,exports){
'use strict';

function getParamSize(keySize) {
    var result = ((keySize / 8) | 0) + (keySize % 8 === 0 ? 0 : 1);
    return result;
}

var paramBytesForAlg = {
    ES256: getParamSize(256),
    ES384: getParamSize(384),
    ES512: getParamSize(521)
};

function getParamBytesForAlg(alg) {
    var paramBytes = paramBytesForAlg[alg];
    if (paramBytes) {
        return paramBytes;
    }

    throw new Error('Unknown algorithm "' + alg + '"');
}

module.exports = getParamBytesForAlg;
},{}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jsonWebToken/jwkToPemConverter/factor.js":[function(require,module,exports){
var asn = require('../../lib/asn1/asn1');
var crypto = require('crypto')
var BN = asn.bignum

var zero = new BN(0)
var one = new BN(1)
var two = new BN(2)

function rand(low, high) {
    do {
        var b = new BN(crypto.randomBytes(high.byteLength()))
    } while(b.cmp(low) <= 0 || b.cmp(high) >= 0)
    return b
}

function odd(n) {
    if (n.cmp(zero) === 0) { return zero }
    var r = n
    while (r.isEven()) {
        r = r.div(two)
    }
    return r
}

function rootOne(x, r, n) {
    var i = x.toRed(BN.red(n)).redPow(r).fromRed()
    var o = zero
    while (i.cmp(one) !== 0) {
        o = i
        i = i.mul(i).mod(n)
    }
    if (o.cmp(n.sub(one)) === 0) {
        return zero
    }
    return o
}

function factor(e, d, n) {
    var k = e.mul(d).sub(one)
    var r = odd(k)
    do {
        var y = rootOne(rand(two, n), r, n)
    } while (y.cmp(zero) === 0)

    var p = y.sub(one).gcd(n)
    return {
        p: p,
        q: n.div(p)
    }
}

module.exports = factor
},{"../../lib/asn1/asn1":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/lib/asn1/asn1.js","crypto":false}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jsonWebToken/jwkToPemConverter/index.js":[function(require,module,exports){
(function (Buffer){(function (){
var asn = require('../../lib/asn1/asn1')
var factor = require('./factor')
var one = new asn.bignum(1)

function urlize(base64) {
    return base64.replace(/\+/g, '-')
        .replace(/\//g, '_')
        .replace(/=/g, '')
}

function hex2b64url(str) {
    return urlize(Buffer.from(str, 'hex').toString('base64'))
}

function fromPEM(data) {
    var text = data.toString().split(/(\r\n|\r|\n)+/g);
    text = text.filter(function(line) {
        return line.trim().length !== 0;
    });
    text = text.slice(1, -1).join('');
    return Buffer.from(text.replace(/[^\w\d\+\/=]+/g, ''), 'base64');
}

var RSAPublicKey = asn.define('RSAPublicKey', function () {
    this.seq().obj(
        this.key('n').int(),
        this.key('e').int()
    )
})

var AlgorithmIdentifier = asn.define('AlgorithmIdentifier', function () {
    this.seq().obj(
        this.key('algorithm').objid(),
        this.key('parameters').optional().any()
    )
})

var PublicKeyInfo = asn.define('PublicKeyInfo', function () {
    this.seq().obj(
        this.key('algorithm').use(AlgorithmIdentifier),
        this.key('publicKey').bitstr()
    )
})

var Version = asn.define('Version', function () {
    this.int({
        0: 'two-prime',
        1: 'multi'
    })
})

var OtherPrimeInfos = asn.define('OtherPrimeInfos', function () {
    this.seq().obj(
        this.key('ri').int(),
        this.key('di').int(),
        this.key('ti').int()
    )
})

var RSAPrivateKey = asn.define('RSAPrivateKey', function () {
    this.seq().obj(
        this.key('version').use(Version),
        this.key('n').int(),
        this.key('e').int(),
        this.key('d').int(),
        this.key('p').int(),
        this.key('q').int(),
        this.key('dp').int(),
        this.key('dq').int(),
        this.key('qi').int(),
        this.key('other').optional().use(OtherPrimeInfos)
    )
})

var PrivateKeyInfo = asn.define('PrivateKeyInfo', function () {
    this.seq().obj(
        this.key('version').use(Version),
        this.key('algorithm').use(AlgorithmIdentifier),
        this.key('privateKey').bitstr()
    )
})

const RSA_OID = '1.2.840.113549.1.1.1'

function addExtras(obj, extras) {
    extras = extras || {}
    Object.keys(extras).forEach(
        function (key) {
            obj[key] = extras[key]
        }
    )
    return obj
}

function pad(hex) {
    return (hex.length % 2 === 1) ? '0' + hex : hex
}

function decodeRsaPublic(buffer, extras) {
    var key = RSAPublicKey.decode(buffer, 'der')
    var e = pad(key.e.toString(16))
    var jwk = {
        kty: 'RSA',
        n: bn2base64url(key.n),
        e: hex2b64url(e)
    }
    return addExtras(jwk, extras)
}

function decodeRsaPrivate(buffer, extras) {
    var key = RSAPrivateKey.decode(buffer, 'der')
    var e = pad(key.e.toString(16))
    var jwk = {
        kty: 'RSA',
        n: bn2base64url(key.n),
        e: hex2b64url(e),
        d: bn2base64url(key.d),
        p: bn2base64url(key.p),
        q: bn2base64url(key.q),
        dp: bn2base64url(key.dp),
        dq: bn2base64url(key.dq),
        qi: bn2base64url(key.qi)
    }
    return addExtras(jwk, extras)
}

function decodePublic(buffer, extras) {
    var info = PublicKeyInfo.decode(buffer, 'der')
    return decodeRsaPublic(info.publicKey.data, extras)
}

function decodePrivate(buffer, extras) {
    var info = PrivateKeyInfo.decode(buffer, 'der')
    return decodeRsaPrivate(info.privateKey.data, extras)
}

function getDecoder(header) {
    var match = /^-----BEGIN (RSA )?(PUBLIC|PRIVATE) KEY-----$/.exec(header)
    if (!match) { return null }
    var isRSA = !!(match[1])
    var isPrivate = (match[2] === 'PRIVATE')
    if (isPrivate) {
        return isRSA ? decodeRsaPrivate : decodePrivate
    }
    else {
        return isRSA ? decodeRsaPublic : decodePublic
    }
}

function pem2jwk(pem, extras) {
    var text = pem.toString().split(/(\r\n|\r|\n)+/g)
    text = text.filter(function(line) {
        return line.trim().length !== 0
    });
    var decoder = getDecoder(text[0])

    text = text.slice(1, -1).join('')
    return decoder(Buffer.from(text.replace(/[^\w\d\+\/=]+/g, ''), 'base64'), extras)
}

function recomputePrimes(jwk) {
    var pq = factor(jwk.e, jwk.d, jwk.n)
    var p = pq.p
    var q = pq.q
    var dp = jwk.d.mod(p.sub(one))
    var dq = jwk.d.mod(q.sub(one))
    var qi = q.invm(p)
    return {
        n: jwk.n,
        e: jwk.e,
        d: jwk.d,
        p: p,
        q: q,
        dp: dp,
        dq: dq,
        qi: qi
    }
}

function parse(jwk) {
    return {
        n: string2bn(jwk.n),
        e: string2bn(jwk.e),
        d: jwk.d && string2bn(jwk.d),
        p: jwk.p && string2bn(jwk.p),
        q: jwk.q && string2bn(jwk.q),
        dp: jwk.dp && string2bn(jwk.dp),
        dq: jwk.dq && string2bn(jwk.dq),
        qi: jwk.qi && string2bn(jwk.qi)
    }
}

function jwk2pem(json) {
    var jwk = parse(json)
    var isPrivate = !!(jwk.d)
    var t = isPrivate ? 'PRIVATE' : 'PUBLIC'
    var header = '-----BEGIN RSA ' + t + ' KEY-----\n'
    var footer = '\n-----END RSA ' + t + ' KEY-----\n'
    var data = null
    if (isPrivate) {
        if (!jwk.p) {
            jwk = recomputePrimes(jwk)
        }
        jwk.version = 'two-prime'
        data = RSAPrivateKey.encode(jwk, 'der')
    }
    else {
        data = RSAPublicKey.encode(jwk, 'der')
    }
    var body = data.toString('base64').match(/.{1,64}/g).join('\n')
    return header + body + footer
}

function bn2base64url(bn) {
    return hex2b64url(pad(bn.toString(16)))
}

function base64url2bn(str) {
    return new asn.bignum(Buffer.from(str, 'base64'))
}

function string2bn(str) {
    if (/^[0-9]+$/.test(str)) {
        return new asn.bignum(str, 10)
    }
    return base64url2bn(str)
}

module.exports = {
    pem2jwk: pem2jwk,
    jwk2pem: jwk2pem,
    BN: asn.bignum
}
}).call(this)}).call(this,require("buffer").Buffer)

},{"../../lib/asn1/asn1":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/lib/asn1/asn1.js","./factor":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jsonWebToken/jwkToPemConverter/factor.js","buffer":false}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jsonWebToken/jws/data-stream.js":[function(require,module,exports){
/*global module, process*/
var Stream = require('stream');
var util = require('util');

function DataStream(data) {
    this.buffer = null;
    this.writable = true;
    this.readable = true;

    // No input
    if (!data) {
        this.buffer = $$.Buffer.alloc(0);
        return this;
    }

    // Stream
    if (typeof data.pipe === 'function') {
        this.buffer = $$.Buffer.alloc(0);
        data.pipe(this);
        return this;
    }

    // $$.Buffer or String
    // or Object (assumedly a passworded key)
    if (data.length || typeof data === 'object') {
        this.buffer = data;
        this.writable = false;
        process.nextTick(function () {
            this.emit('end', data);
            this.readable = false;
            this.emit('close');
        }.bind(this));
        return this;
    }

    throw new TypeError('Unexpected data type ('+ typeof data + ')');
}
util.inherits(DataStream, Stream);

DataStream.prototype.write = function write(data) {
    this.buffer = $$.Buffer.concat([this.buffer, $$.Buffer.from(data)]);
    this.emit('data', data);
};

DataStream.prototype.end = function end(data) {
    if (data)
        this.write(data);
    this.emit('end', data);
    this.emit('close');
    this.writable = false;
    this.readable = false;
};

module.exports = DataStream;
},{"stream":false,"util":false}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jsonWebToken/jws/index.js":[function(require,module,exports){
/*global exports*/
var SignStream = require('./sign-stream');
var VerifyStream = require('./verify-stream');

var ALGORITHMS = [
    'HS256', 'HS384', 'HS512',
    'RS256', 'RS384', 'RS512',
    'PS256', 'PS384', 'PS512',
    'ES256', 'ES384', 'ES512'
];

exports.ALGORITHMS = ALGORITHMS;
exports.sign = SignStream.sign;
exports.verify = VerifyStream.verify;
exports.decode = VerifyStream.decode;
exports.isValid = VerifyStream.isValid;
exports.createSign = function createSign(opts) {
    return new SignStream(opts);
};
exports.createVerify = function createVerify(opts) {
    return new VerifyStream(opts);
};
},{"./sign-stream":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jsonWebToken/jws/sign-stream.js","./verify-stream":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jsonWebToken/jws/verify-stream.js"}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jsonWebToken/jws/sign-stream.js":[function(require,module,exports){
var DataStream = require('./data-stream');
var jwa = require('../jwa');
var Stream = require('stream');
var toString = require('./tostring');
var util = require('util');

function base64url(string, encoding) {
    return $$.Buffer
        .from(string, encoding)
        .toString('base64')
        .replace(/=/g, '')
        .replace(/\+/g, '-')
        .replace(/\//g, '_');
}

function jwsSecuredInput(header, payload, encoding) {
    encoding = encoding || 'utf8';
    var encodedHeader = base64url(toString(header), 'binary');
    var encodedPayload = base64url(toString(payload), encoding);
    return util.format('%s.%s', encodedHeader, encodedPayload);
}

function jwsSign(opts) {
    var header = opts.header;
    var payload = opts.payload;
    var secretOrKey = opts.secret || opts.privateKey;
    var encoding = opts.encoding;
    var algo = jwa(header.alg);
    var securedInput = jwsSecuredInput(header, payload, encoding);
    var signature = algo.sign(securedInput, secretOrKey);
    return util.format('%s.%s', securedInput, signature);
}

function SignStream(opts) {
    var secret = opts.secret||opts.privateKey||opts.key;
    var secretStream = new DataStream(secret);
    this.readable = true;
    this.header = opts.header;
    this.encoding = opts.encoding;
    this.secret = this.privateKey = this.key = secretStream;
    this.payload = new DataStream(opts.payload);
    this.secret.once('close', function () {
        if (!this.payload.writable && this.readable)
            this.sign();
    }.bind(this));

    this.payload.once('close', function () {
        if (!this.secret.writable && this.readable)
            this.sign();
    }.bind(this));
}
util.inherits(SignStream, Stream);

SignStream.prototype.sign = function sign() {
    try {
        var signature = jwsSign({
            header: this.header,
            payload: this.payload.buffer,
            secret: this.secret.buffer,
            encoding: this.encoding
        });
        this.emit('done', signature);
        this.emit('data', signature);
        this.emit('end');
        this.readable = false;
        return signature;
    } catch (e) {
        this.readable = false;
        this.emit('error', e);
        this.emit('close');
    }
};

SignStream.sign = jwsSign;

module.exports = SignStream;
},{"../jwa":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jsonWebToken/jwa/index.js","./data-stream":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jsonWebToken/jws/data-stream.js","./tostring":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jsonWebToken/jws/tostring.js","stream":false,"util":false}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jsonWebToken/jws/tostring.js":[function(require,module,exports){
module.exports = function toString(obj) {
    if (typeof obj === 'string')
        return obj;
    if (typeof obj === 'number' || $$.Buffer.isBuffer(obj))
        return obj.toString();
    return JSON.stringify(obj);
};
},{}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jsonWebToken/jws/verify-stream.js":[function(require,module,exports){
/*global module*/
var DataStream = require('./data-stream');
var jwa = require('../jwa');
var Stream = require('stream');
var toString = require('./tostring');
var util = require('util');
var JWS_REGEX = /^[a-zA-Z0-9\-_]+?\.[a-zA-Z0-9\-_]+?\.([a-zA-Z0-9\-_]+)?$/;

function isObject(thing) {
    return Object.prototype.toString.call(thing) === '[object Object]';
}

function safeJsonParse(thing) {
    if (isObject(thing))
        return thing;
    try { return JSON.parse(thing); }
    catch (e) { return undefined; }
}

function headerFromJWS(jwsSig) {
    var encodedHeader = jwsSig.split('.', 1)[0];
    return safeJsonParse($$.Buffer.from(encodedHeader, 'base64').toString('binary'));
}

function securedInputFromJWS(jwsSig) {
    return jwsSig.split('.', 2).join('.');
}

function signatureFromJWS(jwsSig) {
    return jwsSig.split('.')[2];
}

function payloadFromJWS(jwsSig, encoding) {
    encoding = encoding || 'utf8';
    var payload = jwsSig.split('.')[1];
    return $$.Buffer.from(payload, 'base64').toString(encoding);
}

function isValidJws(string) {
    return JWS_REGEX.test(string) && !!headerFromJWS(string);
}

function jwsVerify(jwsSig, algorithm, secretOrKey) {
    if (!algorithm) {
        var err = new Error("Missing algorithm parameter for jws.verify");
        err.code = "MISSING_ALGORITHM";
        throw err;
    }
    jwsSig = toString(jwsSig);
    var signature = signatureFromJWS(jwsSig);
    var securedInput = securedInputFromJWS(jwsSig);
    var algo = jwa(algorithm);
    return algo.verify(securedInput, signature, secretOrKey);
}

function jwsDecode(jwsSig, opts) {
    opts = opts || {};
    jwsSig = toString(jwsSig);

    if (!isValidJws(jwsSig))
        return null;

    var header = headerFromJWS(jwsSig);

    if (!header)
        return null;

    var payload = payloadFromJWS(jwsSig);
    if (header.typ === 'JWT' || opts.json)
        payload = JSON.parse(payload, opts.encoding);

    return {
        header: header,
        payload: payload,
        signature: signatureFromJWS(jwsSig)
    };
}

function VerifyStream(opts) {
    opts = opts || {};
    var secretOrKey = opts.secret||opts.publicKey||opts.key;
    var secretStream = new DataStream(secretOrKey);
    this.readable = true;
    this.algorithm = opts.algorithm;
    this.encoding = opts.encoding;
    this.secret = this.publicKey = this.key = secretStream;
    this.signature = new DataStream(opts.signature);
    this.secret.once('close', function () {
        if (!this.signature.writable && this.readable)
            this.verify();
    }.bind(this));

    this.signature.once('close', function () {
        if (!this.secret.writable && this.readable)
            this.verify();
    }.bind(this));
}
util.inherits(VerifyStream, Stream);
VerifyStream.prototype.verify = function verify() {
    try {
        var valid = jwsVerify(this.signature.buffer, this.algorithm, this.key.buffer);
        var obj = jwsDecode(this.signature.buffer, this.encoding);
        this.emit('done', valid, obj);
        this.emit('data', valid);
        this.emit('end');
        this.readable = false;
        return valid;
    } catch (e) {
        this.readable = false;
        this.emit('error', e);
        this.emit('close');
    }
};

VerifyStream.decode = jwsDecode;
VerifyStream.isValid = isValidJws;
VerifyStream.verify = jwsVerify;

module.exports = VerifyStream;
},{"../jwa":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jsonWebToken/jwa/index.js","./data-stream":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jsonWebToken/jws/data-stream.js","./tostring":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jsonWebToken/jws/tostring.js","stream":false,"util":false}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jsonWebToken/lib/JsonWebTokenError.js":[function(require,module,exports){
var JsonWebTokenError = function (message, error) {
    Error.call(this, message);
    if(Error.captureStackTrace) {
        Error.captureStackTrace(this, this.constructor);
    }
    this.name = 'JsonWebTokenError';
    this.message = message;
    if (error) this.inner = error;
};

JsonWebTokenError.prototype = Object.create(Error.prototype);
JsonWebTokenError.prototype.constructor = JsonWebTokenError;

module.exports = JsonWebTokenError;
},{}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jsonWebToken/lib/NotBeforeError.js":[function(require,module,exports){
var JsonWebTokenError = require('./JsonWebTokenError');

var NotBeforeError = function (message, date) {
    JsonWebTokenError.call(this, message);
    this.name = 'NotBeforeError';
    this.date = date;
};

NotBeforeError.prototype = Object.create(JsonWebTokenError.prototype);

NotBeforeError.prototype.constructor = NotBeforeError;

module.exports = NotBeforeError;
},{"./JsonWebTokenError":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jsonWebToken/lib/JsonWebTokenError.js"}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jsonWebToken/lib/TokenExpiredError.js":[function(require,module,exports){
var JsonWebTokenError = require('./JsonWebTokenError');

var TokenExpiredError = function (message, expiredAt) {
    JsonWebTokenError.call(this, message);
    this.name = 'TokenExpiredError';
    this.expiredAt = expiredAt;
};

TokenExpiredError.prototype = Object.create(JsonWebTokenError.prototype);

TokenExpiredError.prototype.constructor = TokenExpiredError;

module.exports = TokenExpiredError;
},{"./JsonWebTokenError":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jsonWebToken/lib/JsonWebTokenError.js"}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jsonWebToken/lib/timespan.js":[function(require,module,exports){
module.exports = function (time, iat) {
    var timestamp = iat || Math.floor(Date.now() / 1000);

    if (typeof time === 'number') {
        return timestamp + time;
    } else {
        return;
    }

};
},{}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jsonWebToken/sign.js":[function(require,module,exports){
(function (Buffer){(function (){
var timespan = require('./lib/timespan');
var jws = require('./jws');

var options_to_payload = {
    'audience': 'aud',
    'issuer': 'iss',
    'subject': 'sub',
    'jwtid': 'jti'
};

var options_for_objects = [
    'expiresIn',
    'notBefore',
    'noTimestamp',
    'audience',
    'issuer',
    'subject',
    'jwtid',
];

module.exports = function (payload, secretOrPrivateKey, options, callback) {
    if (typeof options === 'function') {
        callback = options;
        options = {};
    } else {
        options = options || {};
    }

    var isObjectPayload = typeof payload === 'object' &&
        !Buffer.isBuffer(payload);

    var header = Object.assign({
        alg: options.algorithm || 'HS256',
        typ: isObjectPayload ? 'JWT' : undefined,
        kid: options.keyid
    }, options.header);

    function failure(err) {
        if (callback) {
            return callback(err);
        }
        throw err;
    }

    if (!secretOrPrivateKey && options.algorithm !== 'none') {
        return failure(new Error('secretOrPrivateKey must have a value'));
    }

    if (typeof payload === 'undefined') {
        return failure(new Error('payload is required'));
    } else if (isObjectPayload) {
        if (!options.mutatePayload) {
            payload = Object.assign({},payload);
        }
    } else {
        var invalid_options = options_for_objects.filter(function (opt) {
            return typeof options[opt] !== 'undefined';
        });

        if (invalid_options.length > 0) {
            return failure(new Error('invalid ' + invalid_options.join(',') + ' option for ' + (typeof payload ) + ' payload'));
        }
    }

    if (typeof payload.exp !== 'undefined' && typeof options.expiresIn !== 'undefined') {
        return failure(new Error('Bad "options.expiresIn" option the payload already has an "exp" property.'));
    }

    if (typeof payload.nbf !== 'undefined' && typeof options.notBefore !== 'undefined') {
        return failure(new Error('Bad "options.notBefore" option the payload already has an "nbf" property.'));
    }

    var timestamp = payload.iat || Math.floor(Date.now() / 1000);

    if (options.noTimestamp) {
        delete payload.iat;
    } else if (isObjectPayload) {
        payload.iat = timestamp;
    }

    if (typeof options.notBefore !== 'undefined') {
        try {
            payload.nbf = timespan(options.notBefore, timestamp);
        }
        catch (err) {
            return failure(err);
        }
        if (typeof payload.nbf === 'undefined') {
            return failure(new Error('"notBefore" should be a number of seconds or string representing a timespan eg: "1d", "20h", 60'));
        }
    }

    if (typeof options.expiresIn !== 'undefined' && typeof payload === 'object') {
        try {
            payload.exp = timespan(options.expiresIn, timestamp);
        }
        catch (err) {
            return failure(err);
        }
        if (typeof payload.exp === 'undefined') {
            return failure(new Error('"expiresIn" should be a number of seconds or string representing a timespan eg: "1d", "20h", 60'));
        }
    }

    Object.keys(options_to_payload).forEach(function (key) {
        var claim = options_to_payload[key];
        if (typeof options[key] !== 'undefined') {
            if (typeof payload[claim] !== 'undefined') {
                return failure(new Error('Bad "options.' + key + '" option. The payload already has an "' + claim + '" property.'));
            }
            payload[claim] = options[key];
        }
    });

    var encoding = options.encoding || 'utf8';

    if (typeof callback === 'function') {
        jws.createSign({
            header: header,
            privateKey: secretOrPrivateKey,
            payload: payload,
            encoding: encoding
        }).once('error', callback)
            .once('done', function (signature) {
                callback(null, signature);
            });
    } else {
        return jws.sign({header: header, payload: payload, secret: secretOrPrivateKey, encoding: encoding});
    }
};
}).call(this)}).call(this,{"isBuffer":require("../../../node_modules/is-buffer/index.js")})

},{"../../../node_modules/is-buffer/index.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/node_modules/is-buffer/index.js","./jws":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jsonWebToken/jws/index.js","./lib/timespan":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jsonWebToken/lib/timespan.js"}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jsonWebToken/verify.js":[function(require,module,exports){
var JsonWebTokenError = require('./lib/JsonWebTokenError');
var NotBeforeError = require('./lib/NotBeforeError');
var TokenExpiredError = require('./lib/TokenExpiredError');
var decode = require('./decode');
var timespan = require('./lib/timespan');
const jwkToPemConverter = require("./jwkToPemConverter");
var jws = require('./jws');

var PUB_KEY_ALGS = ['RS256', 'RS384', 'RS512', 'ES256', 'ES384', 'ES512'];
var RSA_KEY_ALGS = ['RS256', 'RS384', 'RS512'];
var HS_ALGS = ['HS256', 'HS384', 'HS512'];


PUB_KEY_ALGS.splice(3, 0, 'PS256', 'PS384', 'PS512');
RSA_KEY_ALGS.splice(3, 0, 'PS256', 'PS384', 'PS512');


module.exports = function (jwtString, secretOrPublicKey, options, callback) {
    if ((typeof options === 'function') && !callback) {
        callback = options;
        options = {};
    }

    if (!options) {
        options = {};
    }

    //clone this object since we are going to mutate it.
    options = Object.assign({}, options);

    secretOrPublicKey = jwkToPemConverter.jwk2pem(secretOrPublicKey);
    var done;

    if (callback) {
        done = callback;
    } else {
        done = function (err, data) {
            if (err) throw err;
            return data;
        };
    }

    if (options.clockTimestamp && typeof options.clockTimestamp !== 'number') {
        return done(new JsonWebTokenError('clockTimestamp must be a number'));
    }

    if (options.nonce !== undefined && (typeof options.nonce !== 'string' || options.nonce.trim() === '')) {
        return done(new JsonWebTokenError('nonce must be a non-empty string'));
    }

    var clockTimestamp = options.clockTimestamp || Math.floor(Date.now() / 1000);

    if (!jwtString) {
        return done(new JsonWebTokenError('jwt must be provided'));
    }

    if (typeof jwtString !== 'string') {
        return done(new JsonWebTokenError('jwt must be a string'));
    }

    var parts = jwtString.split('.');

    if (parts.length !== 3) {
        return done(new JsonWebTokenError('jwt malformed'));
    }

    var decodedToken;

    try {
        decodedToken = decode(jwtString, {complete: true});
    } catch (err) {
        return done(err);
    }

    if (!decodedToken) {
        return done(new JsonWebTokenError('invalid token'));
    }

    var header = decodedToken.header;
    var getSecret;

    if (typeof secretOrPublicKey === 'function') {
        if (!callback) {
            return done(new JsonWebTokenError('verify must be called asynchronous if secret or public key is provided as a callback'));
        }

        getSecret = secretOrPublicKey;
    } else {
        getSecret = function (header, secretCallback) {
            return secretCallback(null, secretOrPublicKey);
        };
    }

    return getSecret(header, function (err, secretOrPublicKey) {
        if (err) {
            return done(new JsonWebTokenError('error in secret or public key callback: ' + err.message));
        }

        var hasSignature = parts[2].trim() !== '';

        if (!hasSignature && secretOrPublicKey) {
            return done(new JsonWebTokenError('jwt signature is required'));
        }

        if (hasSignature && !secretOrPublicKey) {
            return done(new JsonWebTokenError('secret or public key must be provided'));
        }

        if (!hasSignature && !options.algorithms) {
            options.algorithms = ['none'];
        }

        if (!options.algorithms) {
            options.algorithms = secretOrPublicKey.toString().includes('BEGIN CERTIFICATE') ||
            secretOrPublicKey.toString().includes('BEGIN PUBLIC KEY') ? PUB_KEY_ALGS :
                secretOrPublicKey.toString().includes('BEGIN RSA PUBLIC KEY') ? RSA_KEY_ALGS : HS_ALGS;

        }

        if (!~options.algorithms.indexOf(decodedToken.header.alg)) {
            return done(new JsonWebTokenError('invalid algorithm'));
        }

        var valid;

        try {
            valid = jws.verify(jwtString, decodedToken.header.alg, secretOrPublicKey);
        } catch (e) {
            return done(e);
        }

        if (!valid) {
            return done(new JsonWebTokenError('invalid signature'));
        }

        var payload = decodedToken.payload;

        if (typeof payload.nbf !== 'undefined' && !options.ignoreNotBefore) {
            if (typeof payload.nbf !== 'number') {
                return done(new JsonWebTokenError('invalid nbf value'));
            }
            if (payload.nbf > clockTimestamp + (options.clockTolerance || 0)) {
                return done(new NotBeforeError('jwt not active', new Date(payload.nbf * 1000)));
            }
        }

        if (typeof payload.exp !== 'undefined' && !options.ignoreExpiration) {
            if (typeof payload.exp !== 'number') {
                return done(new JsonWebTokenError('invalid exp value'));
            }
            if (clockTimestamp >= payload.exp + (options.clockTolerance || 0)) {
                return done(new TokenExpiredError('jwt expired', new Date(payload.exp * 1000)));
            }
        }

        if (options.audience) {
            var audiences = Array.isArray(options.audience) ? options.audience : [options.audience];
            var target = Array.isArray(payload.aud) ? payload.aud : [payload.aud];

            var match = target.some(function (targetAudience) {
                return audiences.some(function (audience) {
                    return audience instanceof RegExp ? audience.test(targetAudience) : audience === targetAudience;
                });
            });

            if (!match) {
                return done(new JsonWebTokenError('jwt audience invalid. expected: ' + audiences.join(' or ')));
            }
        }

        if (options.issuer) {
            var invalid_issuer =
                (typeof options.issuer === 'string' && payload.iss !== options.issuer) ||
                (Array.isArray(options.issuer) && options.issuer.indexOf(payload.iss) === -1);

            if (invalid_issuer) {
                return done(new JsonWebTokenError('jwt issuer invalid. expected: ' + options.issuer));
            }
        }

        if (options.subject) {
            if (payload.sub !== options.subject) {
                return done(new JsonWebTokenError('jwt subject invalid. expected: ' + options.subject));
            }
        }

        if (options.jwtid) {
            if (payload.jti !== options.jwtid) {
                return done(new JsonWebTokenError('jwt jwtid invalid. expected: ' + options.jwtid));
            }
        }

        if (options.nonce) {
            if (payload.nonce !== options.nonce) {
                return done(new JsonWebTokenError('jwt nonce invalid. expected: ' + options.nonce));
            }
        }

        if (options.maxAge) {
            if (typeof payload.iat !== 'number') {
                return done(new JsonWebTokenError('iat required when maxAge is specified'));
            }

            var maxAgeTimestamp = timespan(options.maxAge, payload.iat);
            if (typeof maxAgeTimestamp === 'undefined') {
                return done(new JsonWebTokenError('"maxAge" should be a number of seconds or string representing a timespan eg: "1d", "20h", 60'));
            }
            if (clockTimestamp >= maxAgeTimestamp + (options.clockTolerance || 0)) {
                return done(new TokenExpiredError('maxAge exceeded', new Date(maxAgeTimestamp * 1000)));
            }
        }

        if (options.complete === true) {
            var signature = decodedToken.signature;

            return done(null, {
                header: header,
                payload: payload,
                signature: signature
            });
        }

        return done(null, payload);
    });
};
},{"./decode":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jsonWebToken/decode.js","./jwkToPemConverter":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jsonWebToken/jwkToPemConverter/index.js","./jws":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jsonWebToken/jws/index.js","./lib/JsonWebTokenError":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jsonWebToken/lib/JsonWebTokenError.js","./lib/NotBeforeError":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jsonWebToken/lib/NotBeforeError.js","./lib/TokenExpiredError":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jsonWebToken/lib/TokenExpiredError.js","./lib/timespan":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jsonWebToken/lib/timespan.js"}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/lib/ECKeyGenerator.js":[function(require,module,exports){
function ECKeyGenerator() {
    const crypto = require('crypto');
    const KeyEncoder = require('./keyEncoder');
    const utils = require("./utils/cryptoUtils");
    this.generateKeyPair = (namedCurve, callback) => {
        if (typeof namedCurve === "undefined") {
            callback = undefined;
            namedCurve = 'secp256k1';
        } else {
            if (typeof namedCurve === "function") {
                callback = namedCurve;
                namedCurve = 'secp256k1';
            }
        }

        const ec = crypto.createECDH(namedCurve);
        const publicKey = ec.generateKeys();
        const privateKey = ec.getPrivateKey();
        if(callback) {
            callback(undefined, publicKey, privateKey);
        }
        return {publicKey, privateKey};
    };

    this.getPemKeys = (privateKey, publicKey, options) => {
        const defaultOpts = {format: 'pem', namedCurve: 'secp256k1'};
        Object.assign(defaultOpts, options);
        options = defaultOpts;

        const result = {};
        const ECPrivateKeyASN = KeyEncoder.ECPrivateKeyASN;
        const SubjectPublicKeyInfoASN = KeyEncoder.SubjectPublicKeyInfoASN;
        const keyEncoder = new KeyEncoder(options.namedCurve);

        const privateKeyObject = keyEncoder.privateKeyObject(privateKey, publicKey);
        const publicKeyObject = keyEncoder.publicKeyObject(publicKey)

        result.privateKey = ECPrivateKeyASN.encode(privateKeyObject, options.format, privateKeyObject.pemOptions);
        result.publicKey = SubjectPublicKeyInfoASN.encode(publicKeyObject, options.format, publicKeyObject.pemOptions);

        return result;
    }

    this.getPublicKey = (privateKey, namedCurve) => {
        namedCurve = namedCurve || 'secp256k1';
        const ecdh = crypto.createECDH(namedCurve);
        ecdh.setPrivateKey(privateKey);
        return ecdh.getPublicKey();
    };

    this.convertPublicKey = (publicKey, options) => {
        options = options || {};
        options = removeUndefinedPropsInOpt(options)
        const defaultOpts = {originalFormat: 'raw', outputFormat: 'pem', encodingFormat:"hex", namedCurve: 'secp256k1'};
        Object.assign(defaultOpts, options);
        options = defaultOpts;
        const keyEncoder = new KeyEncoder(options.namedCurve);
        return keyEncoder.encodePublic(publicKey, options.originalFormat, options.outputFormat, options.encodingFormat)
    };

    this.convertPrivateKey = (privateKey, options) => {
        options = options || {};
        options = removeUndefinedPropsInOpt(options)
        const defaultOpts = {originalFormat: 'raw', outputFormat: 'pem', namedCurve: 'secp256k1'};
        Object.assign(defaultOpts, options);
        options = defaultOpts;

        switch (options.outputFormat) {
            case "pem":
                return convertPrivateKeyToPem(privateKey, options);
            case "der":
                return convertPrivateKeyToDer(privateKey, options);
            case "raw":
                return convertPrivateKeyToRaw(privateKey, options);
            default:
                throw Error("Invalid private key output format");
        }

    };

    const convertPrivateKeyToPem = (privateKey, options) => {
        switch (options.originalFormat) {
            case "raw":
                const rawPublicKey = this.getPublicKey(privateKey, options.namedCurve);
                const pemPrivateKey = this.getPemKeys(privateKey, rawPublicKey, options).privateKey;
                return pemPrivateKey;
            case "der":
                const rawPrivateKey =  utils.convertDerPrivateKeyToRaw(privateKey);
                const publicKey = this.getPublicKey(privateKey, options.namedCurve);
                return this.getPemKeys(rawPrivateKey, publicKey, options).privateKey;
            case "pem":
                return privateKey;
            default:
                throw Error("Invalid private key format");
        }
    }

    const convertPrivateKeyToDer = (privateKey, options) => {
        switch (options.originalFormat) {
            case "raw":
                const rawPublicKey = this.getPublicKey(privateKey, options.namedCurve);
                const pemPrivateKey = this.getPemKeys(privateKey, rawPublicKey, options).privateKey;
                return utils.convertPemToDer(pemPrivateKey);
            case "der":
                return privateKey;
            case "pem":
                return utils.convertPemToDer(privateKey);
            default:
                throw Error("Invalid private key format");
        }
    }

    const convertPrivateKeyToRaw = (privateKey, options) => {
        switch (options.originalFormat) {
            case "der":
                return utils.convertDerPrivateKeyToRaw(privateKey);
            case "raw":
                return privateKey;
            case "pem":
                const derPrivateKey = utils.convertPemToDer(privateKey);
                return utils.convertDerPrivateKeyToRaw(derPrivateKey);
            default:
                throw Error("Invalid private key format");
        }
    }

    const removeUndefinedPropsInOpt = (options) => {
        if (options) {
            for (let prop in options) {
                if (typeof options[prop] === "undefined") {
                    delete options[prop];
                }
            }
        }

        return options;
    };
}

exports.createECKeyGenerator = () => {
    return new ECKeyGenerator();
};

},{"./keyEncoder":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/lib/keyEncoder.js","./utils/cryptoUtils":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/lib/utils/cryptoUtils.js","crypto":false}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/lib/PskCrypto.js":[function(require,module,exports){
function PskCrypto() {
    const crypto = require('crypto');
    const utils = require("./utils/cryptoUtils");
    const eth = require("./utils/eth");
    const PskEncryption = require("./PskEncryption");


    this.createPskEncryption = (algorithm) => {
        return new PskEncryption(algorithm);
    };

    this.generateKeyPair = (options, callback) => {
        return this.createKeyPairGenerator().generateKeyPair(options, callback);
    };

    this.createKeyPairGenerator = require("./ECKeyGenerator").createECKeyGenerator;

    this.sign = (algorithm, data, privateKey) => {
        if (typeof data === "string") {
            data = $$.Buffer.from(data);
        }

        const sign = crypto.createSign(algorithm);
        sign.update(data);
        sign.end();
        return sign.sign(privateKey);
    };

    this.verify = (algorithm, data, publicKey, signature) => {
        if (typeof data === "string") {
            data = $$.Buffer.from(data);
        }
        const verify = crypto.createVerify(algorithm);
        verify.update(data);
        verify.end();
        return verify.verify(publicKey, signature);
    };

    this.signETH = eth.sign;

    this.verifyETH = eth.verify;

    this.verifyDefault = (data, publicKey, signature) => {
        return this.verify('sha256', data, publicKey, signature);
    }

    this.privateEncrypt = (privateKey, data) => {
        if (typeof data === "string") {
            data = $$.Buffer.from(data);
        }

        return crypto.privateEncrypt(privateKey, data);
    };

    this.privateDecrypt = (privateKey, encryptedData) => {
        if (typeof encryptedData === "string") {
            encryptedData = $$.Buffer.from(encryptedData);
        }

        return crypto.privateDecrypt(privateKey, encryptedData);
    };

    this.publicEncrypt = (publicKey, data) => {
        if (typeof data === "string") {
            data = $$.Buffer.from(data);
        }

        return crypto.publicEncrypt(publicKey, data);
    };

    this.publicDecrypt = (publicKey, encryptedData) => {
        if (typeof encryptedData === "string") {
            encryptedData = $$.Buffer.from(encryptedData);
        }

        return crypto.publicDecrypt(publicKey, encryptedData);
    };

    this.pskHash = function (data, encoding) {
        if ($$.Buffer.isBuffer(data)) {
            return utils.createPskHash(data, encoding);
        }
        if (data instanceof Object) {
            return utils.createPskHash(JSON.stringify(data), encoding);
        }
        return utils.createPskHash(data, encoding);
    };

    this.hash = (algorithm, data, encoding) => {
        if (typeof data === "object" && !$$.Buffer.isBuffer(data)) {
            data = JSON.stringify(data);
        }
        const hash = crypto.createHash(algorithm);
        hash.update(data);
        return hash.digest(encoding);
    };

    this.objectHash = (algorithm, data, encoding) => {
        if (!$$.Buffer.isBuffer(data)) {
            const ssutils = require("../signsensusDS/ssutil");
            data = ssutils.dumpObjectForHashing(data);
        }
        return this.hash(algorithm, data, encoding);
    };

    this.pskBase58Encode = function (data) {
        return utils.base58Encode(data);
    }

    this.pskBase58Decode = function (data) {
        return utils.base58Decode(data);
    }

    this.pskHashStream = function (readStream, callback) {
        const pskHash = new utils.PskHash();

        readStream.on('data', (chunk) => {
            pskHash.update(chunk);
        });


        readStream.on('end', () => {
            callback(null, pskHash.digest());
        })
    };

    this.generateSafeUid = function (password, additionalData) {
        password = password || $$.Buffer.alloc(0);
        if (!additionalData) {
            additionalData = $$.Buffer.alloc(0);
        }

        if (!$$.Buffer.isBuffer(additionalData)) {
            additionalData = $$.Buffer.from(additionalData);
        }

        return utils.encode(this.pskHash($$.Buffer.concat([password, additionalData])));
    };

    this.deriveKey = function deriveKey(algorithm, password, iterations) {
        if (arguments.length === 2) {
            if (typeof password === "number") {
                iterations = password
                password = algorithm;
                algorithm = "aes-256-gcm";
            } else {
                iterations = 1000;
            }
        }
        if (typeof password === "undefined") {
            iterations = 1000;
            password = algorithm;
            algorithm = "aes-256-gcm";
        }

        const keylen = utils.getKeyLength(algorithm);
        const salt = utils.generateSalt(password, 32);
        return crypto.pbkdf2Sync(password, salt, iterations, keylen, 'sha256');
    };


    this.randomBytes = (len) => {
        if ($$.environmentType === "browser" /*or.constants.BROWSER_ENVIRONMENT_TYPE*/) {
            let randomArray = new Uint8Array(len);
            return window.crypto.getRandomValues(randomArray);
        } else {
            return crypto.randomBytes(len);
        }
    };

    this.randomString = (len) => {
        if ($$.environmentType === "browser" /*or.constants.BROWSER_ENVIRONMENT_TYPE*/) {
            let randomArray = new Uint8Array(len);
            return window.crypto.getRandomValues(randomArray).join();
        } else {
            return crypto.randomBytes(len);
        }
    };

    this.xorBuffers = (...args) => {
        if (args.length < 2) {
            throw Error(`The function should receive at least two arguments. Received ${args.length}`);
        }

        if (args.length === 2) {
            __xorTwoBuffers(args[0], args[1]);
            return args[1];
        }

        for (let i = 0; i < args.length - 1; i++) {
            __xorTwoBuffers(args[i], args[i + 1]);
        }

        function __xorTwoBuffers(a, b) {
            if (!$$.Buffer.isBuffer(a) || !$$.Buffer.isBuffer(b)) {
                throw Error("The argument type should be $$.Buffer.");
            }

            const length = Math.min(a.length, b.length);
            for (let i = 0; i < length; i++) {
                b[i] ^= a[i];
            }

            return b;
        }

        return args[args.length - 1];
    };
    this.decodeDerToASN1ETH = (derSignatureBuffer) => eth.decodeDERIntoASN1ETH(derSignatureBuffer);
    this.PskHash = utils.PskHash;

    const ecies = require("../js-mutual-auth-ecies/index");
    this.ecies_encrypt = ecies.ecies_encrypt;
    this.ecies_decrypt = ecies.ecies_decrypt;
    this.ecies_encrypt_kmac = ecies.ecies_encrypt_kmac;
    this.ecies_decrypt_kmac = ecies.ecies_decrypt_kmac;
    this.ecies_encrypt_ds = ecies.ecies_encrypt_ds;
    this.ecies_decrypt_ds = ecies.ecies_decrypt_ds;
    this.jsonWebTokenAPI = require("../jsonWebToken");
    this.joseAPI = require("../jose");
    this.pskBase64Encode = utils.base64Encode;
    this.pskBase64Decode = utils.base64Decode;
}

module.exports = new PskCrypto();



},{"../jose":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jose/index.js","../js-mutual-auth-ecies/index":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/js-mutual-auth-ecies/index.js","../jsonWebToken":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/jsonWebToken/index.js","../signsensusDS/ssutil":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/signsensusDS/ssutil.js","./ECKeyGenerator":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/lib/ECKeyGenerator.js","./PskEncryption":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/lib/PskEncryption.js","./utils/cryptoUtils":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/lib/utils/cryptoUtils.js","./utils/eth":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/lib/utils/eth.js","crypto":false}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/lib/PskEncryption.js":[function(require,module,exports){
function PskEncryption(algorithm) {
    const crypto = require("crypto");
    const utils = require("./utils/cryptoUtils");

    if (!algorithm) {
        throw Error("No encryption algorithm was provided");
    }

    let iv;
    let aad;
    let tag;
    let data;
    let key;

    let keylen = utils.getKeyLength(algorithm);
    let encryptionIsAuthenticated = utils.encryptionIsAuthenticated(algorithm);

    this.encrypt = (plainData, encryptionKey, options) => {
        if (typeof plainData === "string") {
            plainData = $$.Buffer.from(plainData);
        }

        if (typeof encryptionKey === "string") {
            encryptionKey = $$.Buffer.from(encryptionKey);
        }
        if(options && options.avoidRandom){
            iv = utils.generateSalt(encryptionKey, 16);
        }else{
            iv = iv || crypto.randomBytes(16);
        }

        const cipher = crypto.createCipheriv(algorithm, encryptionKey, iv, options);
        if (encryptionIsAuthenticated) {
            if(options && options.avoidRandom){
                aad = utils.generateSalt(encryptionKey, encryptionKey.length);
            }else{
                aad = crypto.randomBytes(encryptionKey.length);
            }
            cipher.setAAD(aad);
        }

        let encData = $$.Buffer.concat([cipher.update(plainData), cipher.final()]);
        if (encryptionIsAuthenticated) {
            tag = cipher.getAuthTag();
        }

        if (iv) {
            encData = $$.Buffer.concat([encData, iv]);
        }

        if (aad) {
            encData = $$.Buffer.concat([encData, aad]);
        }

        if (tag) {
            encData = $$.Buffer.concat([encData, tag]);
        }

        key = encryptionKey;
        return encData;
    };

    this.decrypt = (encryptedData, decryptionKey, authTagLength = 0, options) => {
        if (typeof encryptedData === "string") {
            encryptedData = $$.Buffer.from(encryptedData);
        }
        if (typeof decryptionKey === "string") {
            decryptionKey = $$.Buffer.from(decryptionKey);
        }
        if (!iv) {
            this.getDecryptionParameters(encryptedData, authTagLength);
        }
        const decipher = crypto.createDecipheriv(algorithm, decryptionKey, iv, options);
        if (encryptionIsAuthenticated) {
            decipher.setAAD(aad);
            decipher.setAuthTag(tag);
        }

        return $$.Buffer.concat([decipher.update(data), decipher.final()]);
    };

    this.getDecryptionParameters = (encryptedData, authTagLength = 0) => {
        let aadLen = 0;
        if (encryptionIsAuthenticated) {
            authTagLength = 16;
            aadLen = keylen;
        }

        const tagOffset = encryptedData.length - authTagLength;
        tag = encryptedData.slice(tagOffset, encryptedData.length);

        const aadOffset = tagOffset - aadLen;
        aad = encryptedData.slice(aadOffset, tagOffset);

        iv = encryptedData.slice(aadOffset - 16, aadOffset);
        data = encryptedData.slice(0, aadOffset - 16);

        return {iv, aad, tag, data};
    };

    this.generateEncryptionKey = () => {
        keylen = utils.getKeyLength(algorithm);
        return crypto.randomBytes(keylen);
    };
}

module.exports = PskEncryption;

},{"./utils/cryptoUtils":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/lib/utils/cryptoUtils.js","crypto":false}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/lib/asn1/api.js":[function(require,module,exports){
var asn1 = require('./asn1');
var inherits = require('util').inherits;

var api = exports;

api.define = function define(name, body) {
  return new Entity(name, body);
};

function Entity(name, body) {
  this.name = name;
  this.body = body;

  this.decoders = {};
  this.encoders = {};
}

Entity.prototype._createNamed = function createNamed(base) {
  var named;
  try {
    named = require('vm').runInThisContext(
      '(function ' + this.name + '(entity) {\n' +
      '  this._initNamed(entity);\n' +
      '})'
    );
  } catch (e) {
    named = function (entity) {
      this._initNamed(entity);
    };
  }
  inherits(named, base);
  named.prototype._initNamed = function initnamed(entity) {
    base.call(this, entity);
  };

  return new named(this);
};

Entity.prototype._getDecoder = function _getDecoder(enc) {
  // Lazily create decoder
  if (!this.decoders.hasOwnProperty(enc))
    this.decoders[enc] = this._createNamed(asn1.decoders[enc]);
  return this.decoders[enc];
};

Entity.prototype.decode = function decode(data, enc, options) {
  return this._getDecoder(enc).decode(data, options);
};

Entity.prototype._getEncoder = function _getEncoder(enc) {
  // Lazily create encoder
  if (!this.encoders.hasOwnProperty(enc))
    this.encoders[enc] = this._createNamed(asn1.encoders[enc]);
  return this.encoders[enc];
};

Entity.prototype.encode = function encode(data, enc, /* internal */ reporter) {
  return this._getEncoder(enc).encode(data, reporter);
};

},{"./asn1":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/lib/asn1/asn1.js","util":false,"vm":false}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/lib/asn1/asn1.js":[function(require,module,exports){
var asn1 = exports;

asn1.bignum = require('./bignum/bn');

asn1.define = require('./api').define;
asn1.base = require('./base/index');
asn1.constants = require('./constants/index');
asn1.decoders = require('./decoders/index');
asn1.encoders = require('./encoders/index');

},{"./api":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/lib/asn1/api.js","./base/index":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/lib/asn1/base/index.js","./bignum/bn":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/lib/asn1/bignum/bn.js","./constants/index":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/lib/asn1/constants/index.js","./decoders/index":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/lib/asn1/decoders/index.js","./encoders/index":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/lib/asn1/encoders/index.js"}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/lib/asn1/base/buffer.js":[function(require,module,exports){
const inherits = require('util').inherits;
const Reporter = require('../base').Reporter;

function DecoderBuffer(base, options) {
    Reporter.call(this, options);
    if (!$$.Buffer.isBuffer(base)) {
        this.error('Input not $$.Buffer');
        return;
    }

    this.base = base;
    this.offset = 0;
    this.length = base.length;
}

inherits(DecoderBuffer, Reporter);
exports.DecoderBuffer = DecoderBuffer;

DecoderBuffer.prototype.save = function save() {
    return {offset: this.offset, reporter: Reporter.prototype.save.call(this)};
};

DecoderBuffer.prototype.restore = function restore(save) {
    // Return skipped data
    const res = new DecoderBuffer(this.base);
    res.offset = save.offset;
    res.length = this.offset;

    this.offset = save.offset;
    Reporter.prototype.restore.call(this, save.reporter);

    return res;
};

DecoderBuffer.prototype.isEmpty = function isEmpty() {
    return this.offset === this.length;
};

DecoderBuffer.prototype.readUInt8 = function readUInt8(fail) {
    if (this.offset + 1 <= this.length)
        return this.base.readUInt8(this.offset++, true);
    else
        return this.error(fail || 'DecoderBuffer overrun');
}

DecoderBuffer.prototype.skip = function skip(bytes, fail) {
    if (!(this.offset + bytes <= this.length))
        return this.error(fail || 'DecoderBuffer overrun');

    const res = new DecoderBuffer(this.base);

    // Share reporter state
    res._reporterState = this._reporterState;

    res.offset = this.offset;
    res.length = this.offset + bytes;
    this.offset += bytes;
    return res;
}

DecoderBuffer.prototype.raw = function raw(save) {
    return this.base.slice(save ? save.offset : this.offset, this.length);
}

function EncoderBuffer(value, reporter) {
    if (Array.isArray(value)) {
        this.length = 0;
        this.value = value.map(function (item) {
            if (!(item instanceof EncoderBuffer))
                item = new EncoderBuffer(item, reporter);
            this.length += item.length;
            return item;
        }, this);
    } else if (typeof value === 'number') {
        if (!(0 <= value && value <= 0xff))
            return reporter.error('non-byte EncoderBuffer value');
        this.value = value;
        this.length = 1;
    } else if (typeof value === 'string') {
        this.value = value;
        this.length = $$.Buffer.byteLength(value);
    } else if ($$.Buffer.isBuffer(value)) {
        this.value = value;
        this.length = value.length;
    } else {
        return reporter.error('Unsupported type: ' + typeof value);
    }
}

exports.EncoderBuffer = EncoderBuffer;

EncoderBuffer.prototype.join = function join(out, offset) {
    if (!out)
        out = $$.Buffer.alloc(this.length);
    if (!offset)
        offset = 0;

    if (this.length === 0)
        return out;

    if (Array.isArray(this.value)) {
        this.value.forEach(function (item) {
            item.join(out, offset);
            offset += item.length;
        });
    } else {
        if (typeof this.value === 'number')
            out[offset] = this.value;
        else if (typeof this.value === 'string')
            out.write(this.value, offset);
        else if ($$.Buffer.isBuffer(this.value))
            this.value.copy(out, offset);
        offset += this.length;
    }

    return out;
};

},{"../base":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/lib/asn1/base/index.js","util":false}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/lib/asn1/base/index.js":[function(require,module,exports){
var base = exports;

base.Reporter = require('./reporter').Reporter;
base.DecoderBuffer = require('./buffer').DecoderBuffer;
base.EncoderBuffer = require('./buffer').EncoderBuffer;
base.Node = require('./node');

},{"./buffer":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/lib/asn1/base/buffer.js","./node":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/lib/asn1/base/node.js","./reporter":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/lib/asn1/base/reporter.js"}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/lib/asn1/base/node.js":[function(require,module,exports){
var Reporter = require('../base').Reporter;
var EncoderBuffer = require('../base').EncoderBuffer;
//var assert = require('double-check').assert;

// Supported tags
var tags = [
  'seq', 'seqof', 'set', 'setof', 'octstr', 'bitstr', 'objid', 'bool',
  'gentime', 'utctime', 'null_', 'enum', 'int', 'ia5str', 'utf8str'
];

// Public methods list
var methods = [
  'key', 'obj', 'use', 'optional', 'explicit', 'implicit', 'def', 'choice',
  'any'
].concat(tags);

// Overrided methods list
var overrided = [
  '_peekTag', '_decodeTag', '_use',
  '_decodeStr', '_decodeObjid', '_decodeTime',
  '_decodeNull', '_decodeInt', '_decodeBool', '_decodeList',

  '_encodeComposite', '_encodeStr', '_encodeObjid', '_encodeTime',
  '_encodeNull', '_encodeInt', '_encodeBool'
];

function Node(enc, parent) {
  var state = {};
  this._baseState = state;

  state.enc = enc;

  state.parent = parent || null;
  state.children = null;

  // State
  state.tag = null;
  state.args = null;
  state.reverseArgs = null;
  state.choice = null;
  state.optional = false;
  state.any = false;
  state.obj = false;
  state.use = null;
  state.useDecoder = null;
  state.key = null;
  state['default'] = null;
  state.explicit = null;
  state.implicit = null;

  // Should create new instance on each method
  if (!state.parent) {
    state.children = [];
    this._wrap();
  }
}
module.exports = Node;

var stateProps = [
  'enc', 'parent', 'children', 'tag', 'args', 'reverseArgs', 'choice',
  'optional', 'any', 'obj', 'use', 'alteredUse', 'key', 'default', 'explicit',
  'implicit'
];

Node.prototype.clone = function clone() {
  var state = this._baseState;
  var cstate = {};
  stateProps.forEach(function(prop) {
    cstate[prop] = state[prop];
  });
  var res = new this.constructor(cstate.parent);
  res._baseState = cstate;
  return res;
};

Node.prototype._wrap = function wrap() {
  var state = this._baseState;
  methods.forEach(function(method) {
    this[method] = function _wrappedMethod() {
      var clone = new this.constructor(this);
      state.children.push(clone);
      return clone[method].apply(clone, arguments);
    };
  }, this);
};

Node.prototype._init = function init(body) {
  var state = this._baseState;

  //assert.equal(state.parent,null,'state.parent should be null');
  body.call(this);

  // Filter children
  state.children = state.children.filter(function(child) {
    return child._baseState.parent === this;
  }, this);
  // assert.equal(state.children.length, 1, 'Root node can have only one child');
};

Node.prototype._useArgs = function useArgs(args) {
  var state = this._baseState;

  // Filter children and args
  var children = args.filter(function(arg) {
    return arg instanceof this.constructor;
  }, this);
  args = args.filter(function(arg) {
    return !(arg instanceof this.constructor);
  }, this);

  if (children.length !== 0) {
    // assert.equal(state.children, null, 'state.children should be null');
    state.children = children;

    // Replace parent to maintain backward link
    children.forEach(function(child) {
      child._baseState.parent = this;
    }, this);
  }
  if (args.length !== 0) {
    // assert.equal(state.args, null, 'state.args should be null');
    state.args = args;
    state.reverseArgs = args.map(function(arg) {
      if (typeof arg !== 'object' || arg.constructor !== Object)
        return arg;

      var res = {};
      Object.keys(arg).forEach(function(key) {
        if (key == (key | 0))
          key |= 0;
        var value = arg[key];
        res[value] = key;
      });
      return res;
    });
  }
};

//
// Overrided methods
//

overrided.forEach(function(method) {
  Node.prototype[method] = function _overrided() {
    var state = this._baseState;
    throw new Error(method + ' not implemented for encoding: ' + state.enc);
  };
});

//
// Public methods
//

tags.forEach(function(tag) {
  Node.prototype[tag] = function _tagMethod() {
    var state = this._baseState;
    var args = Array.prototype.slice.call(arguments);

    // assert.equal(state.tag, null, 'state.tag should be null');
    state.tag = tag;

    this._useArgs(args);

    return this;
  };
});

Node.prototype.use = function use(item) {
  var state = this._baseState;

  // assert.equal(state.use, null, 'state.use should be null');
  state.use = item;

  return this;
};

Node.prototype.optional = function optional() {
  var state = this._baseState;

  state.optional = true;

  return this;
};

Node.prototype.def = function def(val) {
  var state = this._baseState;

  // assert.equal(state['default'], null, "state['default'] should be null");
  state['default'] = val;
  state.optional = true;

  return this;
};

Node.prototype.explicit = function explicit(num) {
  var state = this._baseState;

  // assert.equal(state.explicit,null, 'state.explicit should be null');
  // assert.equal(state.implicit,null, 'state.implicit should be null');

  state.explicit = num;

  return this;
};

Node.prototype.implicit = function implicit(num) {
  var state = this._baseState;

    // assert.equal(state.explicit,null, 'state.explicit should be null');
    // assert.equal(state.implicit,null, 'state.implicit should be null');

    state.implicit = num;

  return this;
};

Node.prototype.obj = function obj() {
  var state = this._baseState;
  var args = Array.prototype.slice.call(arguments);

  state.obj = true;

  if (args.length !== 0)
    this._useArgs(args);

  return this;
};

Node.prototype.key = function key(newKey) {
  var state = this._baseState;

  // assert.equal(state.key, null, 'state.key should be null');
  state.key = newKey;

  return this;
};

Node.prototype.any = function any() {
  var state = this._baseState;

  state.any = true;

  return this;
};

Node.prototype.choice = function choice(obj) {
  var state = this._baseState;

  // assert.equal(state.choice, null,'state.choice should be null');
  state.choice = obj;
  this._useArgs(Object.keys(obj).map(function(key) {
    return obj[key];
  }));

  return this;
};

//
// Decoding
//

Node.prototype._decode = function decode(input) {
  var state = this._baseState;

  // Decode root node
  if (state.parent === null)
    return input.wrapResult(state.children[0]._decode(input));

  var result = state['default'];
  var present = true;

  var prevKey;
  if (state.key !== null)
    prevKey = input.enterKey(state.key);

  // Check if tag is there
  if (state.optional) {
    var tag = null;
    if (state.explicit !== null)
      tag = state.explicit;
    else if (state.implicit !== null)
      tag = state.implicit;
    else if (state.tag !== null)
      tag = state.tag;

    if (tag === null && !state.any) {
      // Trial and Error
      var save = input.save();
      try {
        if (state.choice === null)
          this._decodeGeneric(state.tag, input);
        else
          this._decodeChoice(input);
        present = true;
      } catch (e) {
        present = false;
      }
      input.restore(save);
    } else {
      present = this._peekTag(input, tag, state.any);

      if (input.isError(present))
        return present;
    }
  }

  // Push object on stack
  var prevObj;
  if (state.obj && present)
    prevObj = input.enterObject();

  if (present) {
    // Unwrap explicit values
    if (state.explicit !== null) {
      var explicit = this._decodeTag(input, state.explicit);
      if (input.isError(explicit))
        return explicit;
      input = explicit;
    }

    // Unwrap implicit and normal values
    if (state.use === null && state.choice === null) {
      if (state.any)
        save = input.save();
      var body = this._decodeTag(
        input,
        state.implicit !== null ? state.implicit : state.tag,
        state.any
      );
      if (input.isError(body))
        return body;

      if (state.any)
        result = input.raw(save);
      else
        input = body;
    }

    // Select proper method for tag
    if (state.choice === null)
      result = this._decodeGeneric(state.tag, input);
    else if(!state.any)
      result = this._decodeChoice(input);

    if (input.isError(result))
      return result;

    // Decode children
    if (!state.any && state.choice === null && state.children !== null) {
      var fail = state.children.some(function decodeChildren(child) {
        // NOTE: We are ignoring errors here, to let parser continue with other
        // parts of encoded data
        child._decode(input);
      });
      if (fail)
        return fail;
    }
  }

  // Pop object
  if (state.obj && present)
    result = input.leaveObject(prevObj);

  // Set key
  if (state.key !== null && (result !== null || present === true))
    input.leaveKey(prevKey, state.key, result);

  return result;
};

Node.prototype._decodeGeneric = function decodeGeneric(tag, input) {
  var state = this._baseState;

  if (tag === 'seq' || tag === 'set')
    return null;
  if (tag === 'seqof' || tag === 'setof')
    return this._decodeList(input, tag, state.args[0]);
  else if (tag === 'octstr' || tag === 'bitstr')
    return this._decodeStr(input, tag);
  else if (tag === 'ia5str' || tag === 'utf8str')
    return this._decodeStr(input, tag);
  else if (tag === 'objid' && state.args)
    return this._decodeObjid(input, state.args[0], state.args[1]);
  else if (tag === 'objid')
    return this._decodeObjid(input, null, null);
  else if (tag === 'gentime' || tag === 'utctime')
    return this._decodeTime(input, tag);
  else if (tag === 'null_')
    return this._decodeNull(input);
  else if (tag === 'bool')
    return this._decodeBool(input);
  else if (tag === 'int' || tag === 'enum')
    return this._decodeInt(input, state.args && state.args[0]);
  else if (state.use !== null)
    return this._getUse(state.use, input._reporterState.obj)._decode(input);
  else
    return input.error('unknown tag: ' + tag);
};

Node.prototype._getUse = function _getUse(entity, obj) {

  var state = this._baseState;
  // Create altered use decoder if implicit is set
  state.useDecoder = this._use(entity, obj);
  // assert.equal(state.useDecoder._baseState.parent, null, 'state.useDecoder._baseState.parent should be null');
  state.useDecoder = state.useDecoder._baseState.children[0];
  if (state.implicit !== state.useDecoder._baseState.implicit) {
    state.useDecoder = state.useDecoder.clone();
    state.useDecoder._baseState.implicit = state.implicit;
  }
  return state.useDecoder;
};

Node.prototype._decodeChoice = function decodeChoice(input) {
  var state = this._baseState;
  var result = null;
  var match = false;

  Object.keys(state.choice).some(function(key) {
    var save = input.save();
    var node = state.choice[key];
    try {
      var value = node._decode(input);
      if (input.isError(value))
        return false;

      result = { type: key, value: value };
      match = true;
    } catch (e) {
      input.restore(save);
      return false;
    }
    return true;
  }, this);

  if (!match)
    return input.error('Choice not matched');

  return result;
};

//
// Encoding
//

Node.prototype._createEncoderBuffer = function createEncoderBuffer(data) {
  return new EncoderBuffer(data, this.reporter);
};

Node.prototype._encode = function encode(data, reporter, parent) {
  var state = this._baseState;
  if (state['default'] !== null && state['default'] === data)
    return;

  var result = this._encodeValue(data, reporter, parent);
  if (result === undefined)
    return;

  if (this._skipDefault(result, reporter, parent))
    return;

  return result;
};

Node.prototype._encodeValue = function encode(data, reporter, parent) {
  var state = this._baseState;

  // Decode root node
  if (state.parent === null)
    return state.children[0]._encode(data, reporter || new Reporter());

  var result = null;

  // Set reporter to share it with a child class
  this.reporter = reporter;

  // Check if data is there
  if (state.optional && data === undefined) {
    if (state['default'] !== null)
      data = state['default']
    else
      return;
  }

  // Encode children first
  var content = null;
  var primitive = false;
  if (state.any) {
    // Anything that was given is translated to buffer
    result = this._createEncoderBuffer(data);
  } else if (state.choice) {
    result = this._encodeChoice(data, reporter);
  } else if (state.children) {
    content = state.children.map(function(child) {
      if (child._baseState.tag === 'null_')
        return child._encode(null, reporter, data);

      if (child._baseState.key === null)
        return reporter.error('Child should have a key');
      var prevKey = reporter.enterKey(child._baseState.key);

      if (typeof data !== 'object')
        return reporter.error('Child expected, but input is not object');

      var res = child._encode(data[child._baseState.key], reporter, data);
      reporter.leaveKey(prevKey);

      return res;
    }, this).filter(function(child) {
      return child;
    });

    content = this._createEncoderBuffer(content);
  } else {
    if (state.tag === 'seqof' || state.tag === 'setof') {
      // TODO(indutny): this should be thrown on DSL level
      if (!(state.args && state.args.length === 1))
        return reporter.error('Too many args for : ' + state.tag);

      if (!Array.isArray(data))
        return reporter.error('seqof/setof, but data is not Array');

      var child = this.clone();
      child._baseState.implicit = null;
      content = this._createEncoderBuffer(data.map(function(item) {
        var state = this._baseState;

        return this._getUse(state.args[0], data)._encode(item, reporter);
      }, child));
    } else if (state.use !== null) {
      result = this._getUse(state.use, parent)._encode(data, reporter);
    } else {
      content = this._encodePrimitive(state.tag, data);
      primitive = true;
    }
  }

  // Encode data itself
  result;
  if (!state.any && state.choice === null) {
    var tag = state.implicit !== null ? state.implicit : state.tag;
    var cls = state.implicit === null ? 'universal' : 'context';

    if (tag === null) {
      if (state.use === null)
        reporter.error('Tag could be ommited only for .use()');
    } else {
      if (state.use === null)
        result = this._encodeComposite(tag, primitive, cls, content);
    }
  }

  // Wrap in explicit
  if (state.explicit !== null)
    result = this._encodeComposite(state.explicit, false, 'context', result);

  return result;
};

Node.prototype._encodeChoice = function encodeChoice(data, reporter) {
  var state = this._baseState;

  var node = state.choice[data.type];
  // if (!node) {
  //   assert(
  //       false,
  //       data.type + ' not found in ' +
  //           JSON.stringify(Object.keys(state.choice)));
  // }
  return node._encode(data.value, reporter);
};

Node.prototype._encodePrimitive = function encodePrimitive(tag, data) {
  var state = this._baseState;

  if (tag === 'octstr' || tag === 'bitstr' || tag === 'ia5str')
    return this._encodeStr(data, tag);
  else if (tag === 'utf8str')
    return this._encodeStr(data, tag);
  else if (tag === 'objid' && state.args)
    return this._encodeObjid(data, state.reverseArgs[0], state.args[1]);
  else if (tag === 'objid')
    return this._encodeObjid(data, null, null);
  else if (tag === 'gentime' || tag === 'utctime')
    return this._encodeTime(data, tag);
  else if (tag === 'null_')
    return this._encodeNull();
  else if (tag === 'int' || tag === 'enum')
    return this._encodeInt(data, state.args && state.reverseArgs[0]);
  else if (tag === 'bool')
    return this._encodeBool(data);
  else
    throw new Error('Unsupported tag: ' + tag);
};

},{"../base":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/lib/asn1/base/index.js"}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/lib/asn1/base/reporter.js":[function(require,module,exports){
var inherits = require('util').inherits;

function Reporter(options) {
  this._reporterState = {
    obj: null,
    path: [],
    options: options || {},
    errors: []
  };
}
exports.Reporter = Reporter;

Reporter.prototype.isError = function isError(obj) {
  return obj instanceof ReporterError;
};

Reporter.prototype.save = function save() {
  var state = this._reporterState;

  return { obj: state.obj, pathLen: state.path.length };
};

Reporter.prototype.restore = function restore(data) {
  var state = this._reporterState;

  state.obj = data.obj;
  state.path = state.path.slice(0, data.pathLen);
};

Reporter.prototype.enterKey = function enterKey(key) {
  return this._reporterState.path.push(key);
};

Reporter.prototype.leaveKey = function leaveKey(index, key, value) {
  var state = this._reporterState;

  state.path = state.path.slice(0, index - 1);
  if (state.obj !== null)
    state.obj[key] = value;
};

Reporter.prototype.enterObject = function enterObject() {
  var state = this._reporterState;

  var prev = state.obj;
  state.obj = {};
  return prev;
};

Reporter.prototype.leaveObject = function leaveObject(prev) {
  var state = this._reporterState;

  var now = state.obj;
  state.obj = prev;
  return now;
};

Reporter.prototype.error = function error(msg) {
  var err;
  var state = this._reporterState;

  var inherited = msg instanceof ReporterError;
  if (inherited) {
    err = msg;
  } else {
    err = new ReporterError(state.path.map(function(elem) {
      return '[' + JSON.stringify(elem) + ']';
    }).join(''), msg.message || msg, msg.stack);
  }

  if (!state.options.partial)
    throw err;

  if (!inherited)
    state.errors.push(err);

  return err;
};

Reporter.prototype.wrapResult = function wrapResult(result) {
  var state = this._reporterState;
  if (!state.options.partial)
    return result;

  return {
    result: this.isError(result) ? null : result,
    errors: state.errors
  };
};

function ReporterError(path, msg) {
  this.path = path;
  this.rethrow(msg);
}
inherits(ReporterError, Error);

ReporterError.prototype.rethrow = function rethrow(msg) {
  this.message = msg + ' at: ' + (this.path || '(shallow)');
  Error.captureStackTrace(this, ReporterError);

  return this;
};

},{"util":false}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/lib/asn1/bignum/bn.js":[function(require,module,exports){
(function (module, exports) {

'use strict';

// Utils

function assert(val, msg) {
  if (!val)
    throw new Error(msg || 'Assertion failed');
}

// Could use `inherits` module, but don't want to move from single file
// architecture yet.
function inherits(ctor, superCtor) {
  ctor.super_ = superCtor;
  var TempCtor = function () {};
  TempCtor.prototype = superCtor.prototype;
  ctor.prototype = new TempCtor();
  ctor.prototype.constructor = ctor;
}

// BN

function BN(number, base, endian) {
  // May be `new BN(bn)` ?
  if (number !== null &&
      typeof number === 'object' &&
      Array.isArray(number.words)) {
    return number;
  }

  this.sign = false;
  this.words = null;
  this.length = 0;

  // Reduction context
  this.red = null;

  if (base === 'le' || base === 'be') {
    endian = base;
    base = 10;
  }

  if (number !== null)
    this._init(number || 0, base || 10, endian || 'be');
}
if (typeof module === 'object')
  module.exports = BN;
else
  exports.BN = BN;

BN.BN = BN;
BN.wordSize = 26;

BN.prototype._init = function init(number, base, endian) {
  if (typeof number === 'number') {
    return this._initNumber(number, base, endian);
  } else if (typeof number === 'object') {
    return this._initArray(number, base, endian);
  }
  if (base === 'hex')
    base = 16;
  assert(base === (base | 0) && base >= 2 && base <= 36);

  number = number.toString().replace(/\s+/g, '');
  var start = 0;
  if (number[0] === '-')
    start++;

  if (base === 16)
    this._parseHex(number, start);
  else
    this._parseBase(number, base, start);

  if (number[0] === '-')
    this.sign = true;

  this.strip();

  if (endian !== 'le')
    return;

  this._initArray(this.toArray(), base, endian);
};

  BN.prototype.toArrayLike = function toArrayLike (ArrayType, endian, length) {
    this.strip();

    var byteLength = this.byteLength();
    var reqLength = length || Math.max(1, byteLength);
    assert(byteLength <= reqLength, 'byte array longer than desired length');
    assert(reqLength > 0, 'Requested array length <= 0');

    var res = allocate(ArrayType, reqLength);
    var postfix = endian === 'le' ? 'LE' : 'BE';
    this['_toArrayLike' + postfix](res, byteLength);
    return res;
  };

  var allocate = function allocate (ArrayType, size) {
    if (ArrayType.allocUnsafe) {
      return ArrayType.allocUnsafe(size);
    }
    return new ArrayType(size);
  };

  BN.prototype._toArrayLikeLE = function _toArrayLikeLE (res) {
    var position = 0;
    var carry = 0;

    for (var i = 0, shift = 0; i < this.length; i++) {
      var word = (this.words[i] << shift) | carry;

      res[position++] = word & 0xff;
      if (position < res.length) {
        res[position++] = (word >> 8) & 0xff;
      }
      if (position < res.length) {
        res[position++] = (word >> 16) & 0xff;
      }

      if (shift === 6) {
        if (position < res.length) {
          res[position++] = (word >> 24) & 0xff;
        }
        carry = 0;
        shift = 0;
      } else {
        carry = word >>> 24;
        shift += 2;
      }
    }

    if (position < res.length) {
      res[position++] = carry;

      while (position < res.length) {
        res[position++] = 0;
      }
    }
  };

  BN.prototype._toArrayLikeBE = function _toArrayLikeBE (res) {
    var position = res.length - 1;
    var carry = 0;

    for (var i = 0, shift = 0; i < this.length; i++) {
      var word = (this.words[i] << shift) | carry;

      res[position--] = word & 0xff;
      if (position >= 0) {
        res[position--] = (word >> 8) & 0xff;
      }
      if (position >= 0) {
        res[position--] = (word >> 16) & 0xff;
      }

      if (shift === 6) {
        if (position >= 0) {
          res[position--] = (word >> 24) & 0xff;
        }
        carry = 0;
        shift = 0;
      } else {
        carry = word >>> 24;
        shift += 2;
      }
    }

    if (position >= 0) {
      res[position--] = carry;

      while (position >= 0) {
        res[position--] = 0;
      }
    }
  };

  if (Math.clz32) {
    BN.prototype._countBits = function _countBits (w) {
      return 32 - Math.clz32(w);
    };
  } else {
    BN.prototype._countBits = function _countBits (w) {
      var t = w;
      var r = 0;
      if (t >= 0x1000) {
        r += 13;
        t >>>= 13;
      }
      if (t >= 0x40) {
        r += 7;
        t >>>= 7;
      }
      if (t >= 0x8) {
        r += 4;
        t >>>= 4;
      }
      if (t >= 0x02) {
        r += 2;
        t >>>= 2;
      }
      return r + t;
    };
  }



BN.prototype._initNumber = function _initNumber(number, base, endian) {
  if (number < 0) {
    this.sign = true;
    number = -number;
  }
  if (number < 0x4000000) {
    this.words = [ number & 0x3ffffff ];
    this.length = 1;
  } else if (number < 0x10000000000000) {
    this.words = [
      number & 0x3ffffff,
      (number / 0x4000000) & 0x3ffffff
    ];
    this.length = 2;
  } else {
    assert(number < 0x20000000000000); // 2 ^ 53 (unsafe)
    this.words = [
      number & 0x3ffffff,
      (number / 0x4000000) & 0x3ffffff,
      1
    ];
    this.length = 3;
  }

  if (endian !== 'le')
    return;

  // Reverse the bytes
  this._initArray(this.toArray(), base, endian);
};

BN.prototype._initArray = function _initArray(number, base, endian) {
  // Perhaps a Uint8Array
  assert(typeof number.length === 'number');
  if (number.length <= 0) {
    this.words = [ 0 ];
    this.length = 1;
    return this;
  }

  this.length = Math.ceil(number.length / 3);
  this.words = new Array(this.length);
  for (var i = 0; i < this.length; i++)
    this.words[i] = 0;

  var off = 0;
  if (endian === 'be') {
    for (var i = number.length - 1, j = 0; i >= 0; i -= 3) {
      var w = number[i] | (number[i - 1] << 8) | (number[i - 2] << 16);
      this.words[j] |= (w << off) & 0x3ffffff;
      this.words[j + 1] = (w >>> (26 - off)) & 0x3ffffff;
      off += 24;
      if (off >= 26) {
        off -= 26;
        j++;
      }
    }
  } else if (endian === 'le') {
    for (var i = 0, j = 0; i < number.length; i += 3) {
      var w = number[i] | (number[i + 1] << 8) | (number[i + 2] << 16);
      this.words[j] |= (w << off) & 0x3ffffff;
      this.words[j + 1] = (w >>> (26 - off)) & 0x3ffffff;
      off += 24;
      if (off >= 26) {
        off -= 26;
        j++;
      }
    }
  }
  return this.strip();
};

function parseHex(str, start, end) {
  var r = 0;
  var len = Math.min(str.length, end);
  for (var i = start; i < len; i++) {
    var c = str.charCodeAt(i) - 48;

    r <<= 4;

    // 'a' - 'f'
    if (c >= 49 && c <= 54)
      r |= c - 49 + 0xa;

    // 'A' - 'F'
    else if (c >= 17 && c <= 22)
      r |= c - 17 + 0xa;

    // '0' - '9'
    else
      r |= c & 0xf;
  }
  return r;
}

BN.prototype._parseHex = function _parseHex(number, start) {
  // Create possibly bigger array to ensure that it fits the number
  this.length = Math.ceil((number.length - start) / 6);
  this.words = new Array(this.length);
  for (var i = 0; i < this.length; i++)
    this.words[i] = 0;

  // Scan 24-bit chunks and add them to the number
  var off = 0;
  for (var i = number.length - 6, j = 0; i >= start; i -= 6) {
    var w = parseHex(number, i, i + 6);
    this.words[j] |= (w << off) & 0x3ffffff;
    this.words[j + 1] |= w >>> (26 - off) & 0x3fffff;
    off += 24;
    if (off >= 26) {
      off -= 26;
      j++;
    }
  }
  if (i + 6 !== start) {
    var w = parseHex(number, start, i + 6);
    this.words[j] |= (w << off) & 0x3ffffff;
    this.words[j + 1] |= w >>> (26 - off) & 0x3fffff;
  }
  this.strip();
};

function parseBase(str, start, end, mul) {
  var r = 0;
  var len = Math.min(str.length, end);
  for (var i = start; i < len; i++) {
    var c = str.charCodeAt(i) - 48;

    r *= mul;

    // 'a'
    if (c >= 49)
      r += c - 49 + 0xa;

    // 'A'
    else if (c >= 17)
      r += c - 17 + 0xa;

    // '0' - '9'
    else
      r += c;
  }
  return r;
}

BN.prototype._parseBase = function _parseBase(number, base, start) {
  // Initialize as zero
  this.words = [ 0 ];
  this.length = 1;

  // Find length of limb in base
  for (var limbLen = 0, limbPow = 1; limbPow <= 0x3ffffff; limbPow *= base)
    limbLen++;
  limbLen--;
  limbPow = (limbPow / base) | 0;

  var total = number.length - start;
  var mod = total % limbLen;
  var end = Math.min(total, total - mod) + start;

  var word = 0;
  for (var i = start; i < end; i += limbLen) {
    word = parseBase(number, i, i + limbLen, base);

    this.imuln(limbPow);
    if (this.words[0] + word < 0x4000000)
      this.words[0] += word;
    else
      this._iaddn(word);
  }

  if (mod !== 0) {
    var pow = 1;
    var word = parseBase(number, i, number.length, base);

    for (var i = 0; i < mod; i++)
      pow *= base;
    this.imuln(pow);
    if (this.words[0] + word < 0x4000000)
      this.words[0] += word;
    else
      this._iaddn(word);
  }
};

BN.prototype.copy = function copy(dest) {
  dest.words = new Array(this.length);
  for (var i = 0; i < this.length; i++)
    dest.words[i] = this.words[i];
  dest.length = this.length;
  dest.sign = this.sign;
  dest.red = this.red;
};

BN.prototype.clone = function clone() {
  var r = new BN(null);
  this.copy(r);
  return r;
};

// Remove leading `0` from `this`
BN.prototype.strip = function strip() {
  while (this.length > 1 && this.words[this.length - 1] === 0)
    this.length--;
  return this._normSign();
};

BN.prototype._normSign = function _normSign() {
  // -0 = 0
  if (this.length === 1 && this.words[0] === 0)
    this.sign = false;
  return this;
};

BN.prototype.inspect = function inspect() {
  return (this.red ? '<BN-R: ' : '<BN: ') + this.toString(16) + '>';
};

/*

var zeros = [];
var groupSizes = [];
var groupBases = [];

var s = '';
var i = -1;
while (++i < BN.wordSize) {
  zeros[i] = s;
  s += '0';
}
groupSizes[0] = 0;
groupSizes[1] = 0;
groupBases[0] = 0;
groupBases[1] = 0;
var base = 2 - 1;
while (++base < 36 + 1) {
  var groupSize = 0;
  var groupBase = 1;
  while (groupBase < (1 << BN.wordSize) / base) {
    groupBase *= base;
    groupSize += 1;
  }
  groupSizes[base] = groupSize;
  groupBases[base] = groupBase;
}

*/

var zeros = [
  '',
  '0',
  '00',
  '000',
  '0000',
  '00000',
  '000000',
  '0000000',
  '00000000',
  '000000000',
  '0000000000',
  '00000000000',
  '000000000000',
  '0000000000000',
  '00000000000000',
  '000000000000000',
  '0000000000000000',
  '00000000000000000',
  '000000000000000000',
  '0000000000000000000',
  '00000000000000000000',
  '000000000000000000000',
  '0000000000000000000000',
  '00000000000000000000000',
  '000000000000000000000000',
  '0000000000000000000000000'
];

var groupSizes = [
  0, 0,
  25, 16, 12, 11, 10, 9, 8,
  8, 7, 7, 7, 7, 6, 6,
  6, 6, 6, 6, 6, 5, 5,
  5, 5, 5, 5, 5, 5, 5,
  5, 5, 5, 5, 5, 5, 5
];

var groupBases = [
  0, 0,
  33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216,
  43046721, 10000000, 19487171, 35831808, 62748517, 7529536, 11390625,
  16777216, 24137569, 34012224, 47045881, 64000000, 4084101, 5153632,
  6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149,
  24300000, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176
];

BN.prototype.toString = function toString(base, padding) {
  base = base || 10;
  if (base === 16 || base === 'hex') {
    var out = '';
    var off = 0;
    var padding = padding | 0 || 1;
    var carry = 0;
    for (var i = 0; i < this.length; i++) {
      var w = this.words[i];
      var word = (((w << off) | carry) & 0xffffff).toString(16);
      carry = (w >>> (24 - off)) & 0xffffff;
      if (carry !== 0 || i !== this.length - 1)
        out = zeros[6 - word.length] + word + out;
      else
        out = word + out;
      off += 2;
      if (off >= 26) {
        off -= 26;
        i--;
      }
    }
    if (carry !== 0)
      out = carry.toString(16) + out;
    while (out.length % padding !== 0)
      out = '0' + out;
    if (this.sign)
      out = '-' + out;
    return out;
  } else if (base === (base | 0) && base >= 2 && base <= 36) {
    // var groupSize = Math.floor(BN.wordSize * Math.LN2 / Math.log(base));
    var groupSize = groupSizes[base];
    // var groupBase = Math.pow(base, groupSize);
    var groupBase = groupBases[base];
    var out = '';
    var c = this.clone();
    c.sign = false;
    while (c.cmpn(0) !== 0) {
      var r = c.modn(groupBase).toString(base);
      c = c.idivn(groupBase);

      if (c.cmpn(0) !== 0)
        out = zeros[groupSize - r.length] + r + out;
      else
        out = r + out;
    }
    if (this.cmpn(0) === 0)
      out = '0' + out;
    if (this.sign)
      out = '-' + out;
    return out;
  } else {
    assert(false, 'Base should be between 2 and 36');
  }
};

BN.prototype.toJSON = function toJSON() {
  return this.toString(16);
};

BN.prototype.toArray = function toArray(endian) {
  this.strip();
  var res = new Array(this.byteLength());
  res[0] = 0;

  var q = this.clone();
  if (endian !== 'le') {
    // Assume big-endian
    for (var i = 0; q.cmpn(0) !== 0; i++) {
      var b = q.andln(0xff);
      q.ishrn(8);

      res[res.length - i - 1] = b;
    }
  } else {
    // Assume little-endian
    for (var i = 0; q.cmpn(0) !== 0; i++) {
      var b = q.andln(0xff);
      q.ishrn(8);

      res[i] = b;
    }
  }

  return res;
};

if (Math.clz32) {
  BN.prototype._countBits = function _countBits(w) {
    return 32 - Math.clz32(w);
  };
} else {
  BN.prototype._countBits = function _countBits(w) {
    var t = w;
    var r = 0;
    if (t >= 0x1000) {
      r += 13;
      t >>>= 13;
    }
    if (t >= 0x40) {
      r += 7;
      t >>>= 7;
    }
    if (t >= 0x8) {
      r += 4;
      t >>>= 4;
    }
    if (t >= 0x02) {
      r += 2;
      t >>>= 2;
    }
    return r + t;
  };
}

BN.prototype._zeroBits = function _zeroBits(w) {
  // Short-cut
  if (w === 0)
    return 26;

  var t = w;
  var r = 0;
  if ((t & 0x1fff) === 0) {
    r += 13;
    t >>>= 13;
  }
  if ((t & 0x7f) === 0) {
    r += 7;
    t >>>= 7;
  }
  if ((t & 0xf) === 0) {
    r += 4;
    t >>>= 4;
  }
  if ((t & 0x3) === 0) {
    r += 2;
    t >>>= 2;
  }
  if ((t & 0x1) === 0)
    r++;
  return r;
};

// Return number of used bits in a BN
BN.prototype.bitLength = function bitLength() {
  var hi = 0;
  var w = this.words[this.length - 1];
  var hi = this._countBits(w);
  return (this.length - 1) * 26 + hi;
};

// Number of trailing zero bits
BN.prototype.zeroBits = function zeroBits() {
  if (this.cmpn(0) === 0)
    return 0;

  var r = 0;
  for (var i = 0; i < this.length; i++) {
    var b = this._zeroBits(this.words[i]);
    r += b;
    if (b !== 26)
      break;
  }
  return r;
};

BN.prototype.byteLength = function byteLength() {
  return Math.ceil(this.bitLength() / 8);
};

// Return negative clone of `this`
BN.prototype.neg = function neg() {
  if (this.cmpn(0) === 0)
    return this.clone();

  var r = this.clone();
  r.sign = !this.sign;
  return r;
};


// Or `num` with `this` in-place
BN.prototype.ior = function ior(num) {
  this.sign = this.sign || num.sign;

  while (this.length < num.length)
    this.words[this.length++] = 0;

  for (var i = 0; i < num.length; i++)
    this.words[i] = this.words[i] | num.words[i];

  return this.strip();
};


// Or `num` with `this`
BN.prototype.or = function or(num) {
  if (this.length > num.length)
    return this.clone().ior(num);
  else
    return num.clone().ior(this);
};


// And `num` with `this` in-place
BN.prototype.iand = function iand(num) {
  this.sign = this.sign && num.sign;

  // b = min-length(num, this)
  var b;
  if (this.length > num.length)
    b = num;
  else
    b = this;

  for (var i = 0; i < b.length; i++)
    this.words[i] = this.words[i] & num.words[i];

  this.length = b.length;

  return this.strip();
};


// And `num` with `this`
BN.prototype.and = function and(num) {
  if (this.length > num.length)
    return this.clone().iand(num);
  else
    return num.clone().iand(this);
};


// Xor `num` with `this` in-place
BN.prototype.ixor = function ixor(num) {
  this.sign = this.sign || num.sign;

  // a.length > b.length
  var a;
  var b;
  if (this.length > num.length) {
    a = this;
    b = num;
  } else {
    a = num;
    b = this;
  }

  for (var i = 0; i < b.length; i++)
    this.words[i] = a.words[i] ^ b.words[i];

  if (this !== a)
    for (; i < a.length; i++)
      this.words[i] = a.words[i];

  this.length = a.length;

  return this.strip();
};


// Xor `num` with `this`
BN.prototype.xor = function xor(num) {
  if (this.length > num.length)
    return this.clone().ixor(num);
  else
    return num.clone().ixor(this);
};


// Set `bit` of `this`
BN.prototype.setn = function setn(bit, val) {
  assert(typeof bit === 'number' && bit >= 0);

  var off = (bit / 26) | 0;
  var wbit = bit % 26;

  while (this.length <= off)
    this.words[this.length++] = 0;

  if (val)
    this.words[off] = this.words[off] | (1 << wbit);
  else
    this.words[off] = this.words[off] & ~(1 << wbit);

  return this.strip();
};


// Add `num` to `this` in-place
BN.prototype.iadd = function iadd(num) {
  // negative + positive
  if (this.sign && !num.sign) {
    this.sign = false;
    var r = this.isub(num);
    this.sign = !this.sign;
    return this._normSign();

  // positive + negative
  } else if (!this.sign && num.sign) {
    num.sign = false;
    var r = this.isub(num);
    num.sign = true;
    return r._normSign();
  }

  // a.length > b.length
  var a;
  var b;
  if (this.length > num.length) {
    a = this;
    b = num;
  } else {
    a = num;
    b = this;
  }

  var carry = 0;
  for (var i = 0; i < b.length; i++) {
    var r = a.words[i] + b.words[i] + carry;
    this.words[i] = r & 0x3ffffff;
    carry = r >>> 26;
  }
  for (; carry !== 0 && i < a.length; i++) {
    var r = a.words[i] + carry;
    this.words[i] = r & 0x3ffffff;
    carry = r >>> 26;
  }

  this.length = a.length;
  if (carry !== 0) {
    this.words[this.length] = carry;
    this.length++;
  // Copy the rest of the words
  } else if (a !== this) {
    for (; i < a.length; i++)
      this.words[i] = a.words[i];
  }

  return this;
};

// Add `num` to `this`
BN.prototype.add = function add(num) {
  if (num.sign && !this.sign) {
    num.sign = false;
    var res = this.sub(num);
    num.sign = true;
    return res;
  } else if (!num.sign && this.sign) {
    this.sign = false;
    var res = num.sub(this);
    this.sign = true;
    return res;
  }

  if (this.length > num.length)
    return this.clone().iadd(num);
  else
    return num.clone().iadd(this);
};

// Subtract `num` from `this` in-place
BN.prototype.isub = function isub(num) {
  // this - (-num) = this + num
  if (num.sign) {
    num.sign = false;
    var r = this.iadd(num);
    num.sign = true;
    return r._normSign();

  // -this - num = -(this + num)
  } else if (this.sign) {
    this.sign = false;
    this.iadd(num);
    this.sign = true;
    return this._normSign();
  }

  // At this point both numbers are positive
  var cmp = this.cmp(num);

  // Optimization - zeroify
  if (cmp === 0) {
    this.sign = false;
    this.length = 1;
    this.words[0] = 0;
    return this;
  }

  // a > b
  var a;
  var b;
  if (cmp > 0) {
    a = this;
    b = num;
  } else {
    a = num;
    b = this;
  }

  var carry = 0;
  for (var i = 0; i < b.length; i++) {
    var r = a.words[i] - b.words[i] + carry;
    carry = r >> 26;
    this.words[i] = r & 0x3ffffff;
  }
  for (; carry !== 0 && i < a.length; i++) {
    var r = a.words[i] + carry;
    carry = r >> 26;
    this.words[i] = r & 0x3ffffff;
  }

  // Copy rest of the words
  if (carry === 0 && i < a.length && a !== this)
    for (; i < a.length; i++)
      this.words[i] = a.words[i];
  this.length = Math.max(this.length, i);

  if (a !== this)
    this.sign = true;

  return this.strip();
};

// Subtract `num` from `this`
BN.prototype.sub = function sub(num) {
  return this.clone().isub(num);
};

/*
// NOTE: This could be potentionally used to generate loop-less multiplications
function _genCombMulTo(alen, blen) {
  var len = alen + blen - 1;
  var src = [
    'var a = this.words, b = num.words, o = out.words, c = 0, w, ' +
        'mask = 0x3ffffff, shift = 0x4000000;',
    'out.length = ' + len + ';'
  ];
  for (var k = 0; k < len; k++) {
    var minJ = Math.max(0, k - alen + 1);
    var maxJ = Math.min(k, blen - 1);

    for (var j = minJ; j <= maxJ; j++) {
      var i = k - j;
      var mul = 'a[' + i + '] * b[' + j + ']';

      if (j === minJ) {
        src.push('w = ' + mul + ' + c;');
        src.push('c = (w / shift) | 0;');
      } else {
        src.push('w += ' + mul + ';');
        src.push('c += (w / shift) | 0;');
      }
      src.push('w &= mask;');
    }
    src.push('o[' + k + '] = w;');
  }
  src.push('if (c !== 0) {',
           '  o[' + k + '] = c;',
           '  out.length++;',
           '}',
           'return out;');

  return src.join('\n');
}
*/

BN.prototype._smallMulTo = function _smallMulTo(num, out) {
  out.sign = num.sign !== this.sign;
  out.length = this.length + num.length;

  var carry = 0;
  for (var k = 0; k < out.length - 1; k++) {
    // Sum all words with the same `i + j = k` and accumulate `ncarry`,
    // note that ncarry could be >= 0x3ffffff
    var ncarry = carry >>> 26;
    var rword = carry & 0x3ffffff;
    var maxJ = Math.min(k, num.length - 1);
    for (var j = Math.max(0, k - this.length + 1); j <= maxJ; j++) {
      var i = k - j;
      var a = this.words[i] | 0;
      var b = num.words[j] | 0;
      var r = a * b;

      var lo = r & 0x3ffffff;
      ncarry = (ncarry + ((r / 0x4000000) | 0)) | 0;
      lo = (lo + rword) | 0;
      rword = lo & 0x3ffffff;
      ncarry = (ncarry + (lo >>> 26)) | 0;
    }
    out.words[k] = rword;
    carry = ncarry;
  }
  if (carry !== 0) {
    out.words[k] = carry;
  } else {
    out.length--;
  }

  return out.strip();
};

BN.prototype._bigMulTo = function _bigMulTo(num, out) {
  out.sign = num.sign !== this.sign;
  out.length = this.length + num.length;

  var carry = 0;
  var hncarry = 0;
  for (var k = 0; k < out.length - 1; k++) {
    // Sum all words with the same `i + j = k` and accumulate `ncarry`,
    // note that ncarry could be >= 0x3ffffff
    var ncarry = hncarry;
    hncarry = 0;
    var rword = carry & 0x3ffffff;
    var maxJ = Math.min(k, num.length - 1);
    for (var j = Math.max(0, k - this.length + 1); j <= maxJ; j++) {
      var i = k - j;
      var a = this.words[i] | 0;
      var b = num.words[j] | 0;
      var r = a * b;

      var lo = r & 0x3ffffff;
      ncarry = (ncarry + ((r / 0x4000000) | 0)) | 0;
      lo = (lo + rword) | 0;
      rword = lo & 0x3ffffff;
      ncarry = (ncarry + (lo >>> 26)) | 0;

      hncarry += ncarry >>> 26;
      ncarry &= 0x3ffffff;
    }
    out.words[k] = rword;
    carry = ncarry;
    ncarry = hncarry;
  }
  if (carry !== 0) {
    out.words[k] = carry;
  } else {
    out.length--;
  }

  return out.strip();
};

BN.prototype.mulTo = function mulTo(num, out) {
  var res;
  if (this.length + num.length < 63)
    res = this._smallMulTo(num, out);
  else
    res = this._bigMulTo(num, out);
  return res;
};

// Multiply `this` by `num`
BN.prototype.mul = function mul(num) {
  var out = new BN(null);
  out.words = new Array(this.length + num.length);
  return this.mulTo(num, out);
};

// In-place Multiplication
BN.prototype.imul = function imul(num) {
  if (this.cmpn(0) === 0 || num.cmpn(0) === 0) {
    this.words[0] = 0;
    this.length = 1;
    return this;
  }

  var tlen = this.length;
  var nlen = num.length;

  this.sign = num.sign !== this.sign;
  this.length = this.length + num.length;
  this.words[this.length - 1] = 0;

  for (var k = this.length - 2; k >= 0; k--) {
    // Sum all words with the same `i + j = k` and accumulate `carry`,
    // note that carry could be >= 0x3ffffff
    var carry = 0;
    var rword = 0;
    var maxJ = Math.min(k, nlen - 1);
    for (var j = Math.max(0, k - tlen + 1); j <= maxJ; j++) {
      var i = k - j;
      var a = this.words[i];
      var b = num.words[j];
      var r = a * b;

      var lo = r & 0x3ffffff;
      carry += (r / 0x4000000) | 0;
      lo += rword;
      rword = lo & 0x3ffffff;
      carry += lo >>> 26;
    }
    this.words[k] = rword;
    this.words[k + 1] += carry;
    carry = 0;
  }

  // Propagate overflows
  var carry = 0;
  for (var i = 1; i < this.length; i++) {
    var w = this.words[i] + carry;
    this.words[i] = w & 0x3ffffff;
    carry = w >>> 26;
  }

  return this.strip();
};

BN.prototype.imuln = function imuln(num) {
  assert(typeof num === 'number');

  // Carry
  var carry = 0;
  for (var i = 0; i < this.length; i++) {
    var w = this.words[i] * num;
    var lo = (w & 0x3ffffff) + (carry & 0x3ffffff);
    carry >>= 26;
    carry += (w / 0x4000000) | 0;
    // NOTE: lo is 27bit maximum
    carry += lo >>> 26;
    this.words[i] = lo & 0x3ffffff;
  }

  if (carry !== 0) {
    this.words[i] = carry;
    this.length++;
  }

  return this;
};

BN.prototype.muln = function muln(num) {
  return this.clone().imuln(num);
};

// `this` * `this`
BN.prototype.sqr = function sqr() {
  return this.mul(this);
};

// `this` * `this` in-place
BN.prototype.isqr = function isqr() {
  return this.mul(this);
};

// Shift-left in-place
BN.prototype.ishln = function ishln(bits) {
  assert(typeof bits === 'number' && bits >= 0);
  var r = bits % 26;
  var s = (bits - r) / 26;
  var carryMask = (0x3ffffff >>> (26 - r)) << (26 - r);

  if (r !== 0) {
    var carry = 0;
    for (var i = 0; i < this.length; i++) {
      var newCarry = this.words[i] & carryMask;
      var c = (this.words[i] - newCarry) << r;
      this.words[i] = c | carry;
      carry = newCarry >>> (26 - r);
    }
    if (carry) {
      this.words[i] = carry;
      this.length++;
    }
  }

  if (s !== 0) {
    for (var i = this.length - 1; i >= 0; i--)
      this.words[i + s] = this.words[i];
    for (var i = 0; i < s; i++)
      this.words[i] = 0;
    this.length += s;
  }

  return this.strip();
};

// Shift-right in-place
// NOTE: `hint` is a lowest bit before trailing zeroes
// NOTE: if `extended` is present - it will be filled with destroyed bits
BN.prototype.ishrn = function ishrn(bits, hint, extended) {
  assert(typeof bits === 'number' && bits >= 0);
  var h;
  if (hint)
    h = (hint - (hint % 26)) / 26;
  else
    h = 0;

  var r = bits % 26;
  var s = Math.min((bits - r) / 26, this.length);
  var mask = 0x3ffffff ^ ((0x3ffffff >>> r) << r);
  var maskedWords = extended;

  h -= s;
  h = Math.max(0, h);

  // Extended mode, copy masked part
  if (maskedWords) {
    for (var i = 0; i < s; i++)
      maskedWords.words[i] = this.words[i];
    maskedWords.length = s;
  }

  if (s === 0) {
    // No-op, we should not move anything at all
  } else if (this.length > s) {
    this.length -= s;
    for (var i = 0; i < this.length; i++)
      this.words[i] = this.words[i + s];
  } else {
    this.words[0] = 0;
    this.length = 1;
  }

  var carry = 0;
  for (var i = this.length - 1; i >= 0 && (carry !== 0 || i >= h); i--) {
    var word = this.words[i];
    this.words[i] = (carry << (26 - r)) | (word >>> r);
    carry = word & mask;
  }

  // Push carried bits as a mask
  if (maskedWords && carry !== 0)
    maskedWords.words[maskedWords.length++] = carry;

  if (this.length === 0) {
    this.words[0] = 0;
    this.length = 1;
  }

  this.strip();

  return this;
};

// Shift-left
BN.prototype.shln = function shln(bits) {
  return this.clone().ishln(bits);
};

// Shift-right
BN.prototype.shrn = function shrn(bits) {
  return this.clone().ishrn(bits);
};

// Test if n bit is set
BN.prototype.testn = function testn(bit) {
  assert(typeof bit === 'number' && bit >= 0);
  var r = bit % 26;
  var s = (bit - r) / 26;
  var q = 1 << r;

  // Fast case: bit is much higher than all existing words
  if (this.length <= s) {
    return false;
  }

  // Check bit and return
  var w = this.words[s];

  return !!(w & q);
};

// Return only lowers bits of number (in-place)
BN.prototype.imaskn = function imaskn(bits) {
  assert(typeof bits === 'number' && bits >= 0);
  var r = bits % 26;
  var s = (bits - r) / 26;

  assert(!this.sign, 'imaskn works only with positive numbers');

  if (r !== 0)
    s++;
  this.length = Math.min(s, this.length);

  if (r !== 0) {
    var mask = 0x3ffffff ^ ((0x3ffffff >>> r) << r);
    this.words[this.length - 1] &= mask;
  }

  return this.strip();
};

// Return only lowers bits of number
BN.prototype.maskn = function maskn(bits) {
  return this.clone().imaskn(bits);
};

// Add plain number `num` to `this`
BN.prototype.iaddn = function iaddn(num) {
  assert(typeof num === 'number');
  if (num < 0)
    return this.isubn(-num);

  // Possible sign change
  if (this.sign) {
    if (this.length === 1 && this.words[0] < num) {
      this.words[0] = num - this.words[0];
      this.sign = false;
      return this;
    }

    this.sign = false;
    this.isubn(num);
    this.sign = true;
    return this;
  }

  // Add without checks
  return this._iaddn(num);
};

BN.prototype._iaddn = function _iaddn(num) {
  this.words[0] += num;

  // Carry
  for (var i = 0; i < this.length && this.words[i] >= 0x4000000; i++) {
    this.words[i] -= 0x4000000;
    if (i === this.length - 1)
      this.words[i + 1] = 1;
    else
      this.words[i + 1]++;
  }
  this.length = Math.max(this.length, i + 1);

  return this;
};

// Subtract plain number `num` from `this`
BN.prototype.isubn = function isubn(num) {
  assert(typeof num === 'number');
  if (num < 0)
    return this.iaddn(-num);

  if (this.sign) {
    this.sign = false;
    this.iaddn(num);
    this.sign = true;
    return this;
  }

  this.words[0] -= num;

  // Carry
  for (var i = 0; i < this.length && this.words[i] < 0; i++) {
    this.words[i] += 0x4000000;
    this.words[i + 1] -= 1;
  }

  return this.strip();
};

BN.prototype.addn = function addn(num) {
  return this.clone().iaddn(num);
};

BN.prototype.subn = function subn(num) {
  return this.clone().isubn(num);
};

BN.prototype.iabs = function iabs() {
  this.sign = false;

  return this;
};

BN.prototype.abs = function abs() {
  return this.clone().iabs();
};

BN.prototype._ishlnsubmul = function _ishlnsubmul(num, mul, shift) {
  // Bigger storage is needed
  var len = num.length + shift;
  var i;
  if (this.words.length < len) {
    var t = new Array(len);
    for (var i = 0; i < this.length; i++)
      t[i] = this.words[i];
    this.words = t;
  } else {
    i = this.length;
  }

  // Zeroify rest
  this.length = Math.max(this.length, len);
  for (; i < this.length; i++)
    this.words[i] = 0;

  var carry = 0;
  for (var i = 0; i < num.length; i++) {
    var w = this.words[i + shift] + carry;
    var right = num.words[i] * mul;
    w -= right & 0x3ffffff;
    carry = (w >> 26) - ((right / 0x4000000) | 0);
    this.words[i + shift] = w & 0x3ffffff;
  }
  for (; i < this.length - shift; i++) {
    var w = this.words[i + shift] + carry;
    carry = w >> 26;
    this.words[i + shift] = w & 0x3ffffff;
  }

  if (carry === 0)
    return this.strip();

  // Subtraction overflow
  assert(carry === -1);
  carry = 0;
  for (var i = 0; i < this.length; i++) {
    var w = -this.words[i] + carry;
    carry = w >> 26;
    this.words[i] = w & 0x3ffffff;
  }
  this.sign = true;

  return this.strip();
};

BN.prototype._wordDiv = function _wordDiv(num, mode) {
  var shift = this.length - num.length;

  var a = this.clone();
  var b = num;

  // Normalize
  var bhi = b.words[b.length - 1];
  var bhiBits = this._countBits(bhi);
  shift = 26 - bhiBits;
  if (shift !== 0) {
    b = b.shln(shift);
    a.ishln(shift);
    bhi = b.words[b.length - 1];
  }

  // Initialize quotient
  var m = a.length - b.length;
  var q;

  if (mode !== 'mod') {
    q = new BN(null);
    q.length = m + 1;
    q.words = new Array(q.length);
    for (var i = 0; i < q.length; i++)
      q.words[i] = 0;
  }

  var diff = a.clone()._ishlnsubmul(b, 1, m);
  if (!diff.sign) {
    a = diff;
    if (q)
      q.words[m] = 1;
  }

  for (var j = m - 1; j >= 0; j--) {
    var qj = a.words[b.length + j] * 0x4000000 + a.words[b.length + j - 1];

    // NOTE: (qj / bhi) is (0x3ffffff * 0x4000000 + 0x3ffffff) / 0x2000000 max
    // (0x7ffffff)
    qj = Math.min((qj / bhi) | 0, 0x3ffffff);

    a._ishlnsubmul(b, qj, j);
    while (a.sign) {
      qj--;
      a.sign = false;
      a._ishlnsubmul(b, 1, j);
      if (a.cmpn(0) !== 0)
        a.sign = !a.sign;
    }
    if (q)
      q.words[j] = qj;
  }
  if (q)
    q.strip();
  a.strip();

  // Denormalize
  if (mode !== 'div' && shift !== 0)
    a.ishrn(shift);
  return { div: q ? q : null, mod: a };
};

BN.prototype.divmod = function divmod(num, mode) {
  assert(num.cmpn(0) !== 0);

  if (this.sign && !num.sign) {
    var res = this.neg().divmod(num, mode);
    var div;
    var mod;
    if (mode !== 'mod')
      div = res.div.neg();
    if (mode !== 'div')
      mod = res.mod.cmpn(0) === 0 ? res.mod : num.sub(res.mod);
    return {
      div: div,
      mod: mod
    };
  } else if (!this.sign && num.sign) {
    var res = this.divmod(num.neg(), mode);
    var div;
    if (mode !== 'mod')
      div = res.div.neg();
    return { div: div, mod: res.mod };
  } else if (this.sign && num.sign) {
    return this.neg().divmod(num.neg(), mode);
  }

  // Both numbers are positive at this point

  // Strip both numbers to approximate shift value
  if (num.length > this.length || this.cmp(num) < 0)
    return { div: new BN(0), mod: this };

  // Very short reduction
  if (num.length === 1) {
    if (mode === 'div')
      return { div: this.divn(num.words[0]), mod: null };
    else if (mode === 'mod')
      return { div: null, mod: new BN(this.modn(num.words[0])) };
    return {
      div: this.divn(num.words[0]),
      mod: new BN(this.modn(num.words[0]))
    };
  }

  return this._wordDiv(num, mode);
};

// Find `this` / `num`
BN.prototype.div = function div(num) {
  return this.divmod(num, 'div').div;
};

// Find `this` % `num`
BN.prototype.mod = function mod(num) {
  return this.divmod(num, 'mod').mod;
};

// Find Round(`this` / `num`)
BN.prototype.divRound = function divRound(num) {
  var dm = this.divmod(num);

  // Fast case - exact division
  if (dm.mod.cmpn(0) === 0)
    return dm.div;

  var mod = dm.div.sign ? dm.mod.isub(num) : dm.mod;

  var half = num.shrn(1);
  var r2 = num.andln(1);
  var cmp = mod.cmp(half);

  // Round down
  if (cmp < 0 || r2 === 1 && cmp === 0)
    return dm.div;

  // Round up
  return dm.div.sign ? dm.div.isubn(1) : dm.div.iaddn(1);
};

BN.prototype.modn = function modn(num) {
  assert(num <= 0x3ffffff);
  var p = (1 << 26) % num;

  var acc = 0;
  for (var i = this.length - 1; i >= 0; i--)
    acc = (p * acc + this.words[i]) % num;

  return acc;
};

// In-place division by number
BN.prototype.idivn = function idivn(num) {
  assert(num <= 0x3ffffff);

  var carry = 0;
  for (var i = this.length - 1; i >= 0; i--) {
    var w = this.words[i] + carry * 0x4000000;
    this.words[i] = (w / num) | 0;
    carry = w % num;
  }

  return this.strip();
};

BN.prototype.divn = function divn(num) {
  return this.clone().idivn(num);
};

BN.prototype.egcd = function egcd(p) {
  assert(!p.sign);
  assert(p.cmpn(0) !== 0);

  var x = this;
  var y = p.clone();

  if (x.sign)
    x = x.mod(p);
  else
    x = x.clone();

  // A * x + B * y = x
  var A = new BN(1);
  var B = new BN(0);

  // C * x + D * y = y
  var C = new BN(0);
  var D = new BN(1);

  var g = 0;

  while (x.isEven() && y.isEven()) {
    x.ishrn(1);
    y.ishrn(1);
    ++g;
  }

  var yp = y.clone();
  var xp = x.clone();

  while (x.cmpn(0) !== 0) {
    while (x.isEven()) {
      x.ishrn(1);
      if (A.isEven() && B.isEven()) {
        A.ishrn(1);
        B.ishrn(1);
      } else {
        A.iadd(yp).ishrn(1);
        B.isub(xp).ishrn(1);
      }
    }

    while (y.isEven()) {
      y.ishrn(1);
      if (C.isEven() && D.isEven()) {
        C.ishrn(1);
        D.ishrn(1);
      } else {
        C.iadd(yp).ishrn(1);
        D.isub(xp).ishrn(1);
      }
    }

    if (x.cmp(y) >= 0) {
      x.isub(y);
      A.isub(C);
      B.isub(D);
    } else {
      y.isub(x);
      C.isub(A);
      D.isub(B);
    }
  }

  return {
    a: C,
    b: D,
    gcd: y.ishln(g)
  };
};

// This is reduced incarnation of the binary EEA
// above, designated to invert members of the
// _prime_ fields F(p) at a maximal speed
BN.prototype._invmp = function _invmp(p) {
  assert(!p.sign);
  assert(p.cmpn(0) !== 0);

  var a = this;
  var b = p.clone();

  if (a.sign)
    a = a.mod(p);
  else
    a = a.clone();

  var x1 = new BN(1);
  var x2 = new BN(0);

  var delta = b.clone();

  while (a.cmpn(1) > 0 && b.cmpn(1) > 0) {
    while (a.isEven()) {
      a.ishrn(1);
      if (x1.isEven())
        x1.ishrn(1);
      else
        x1.iadd(delta).ishrn(1);
    }
    while (b.isEven()) {
      b.ishrn(1);
      if (x2.isEven())
        x2.ishrn(1);
      else
        x2.iadd(delta).ishrn(1);
    }
    if (a.cmp(b) >= 0) {
      a.isub(b);
      x1.isub(x2);
    } else {
      b.isub(a);
      x2.isub(x1);
    }
  }
  if (a.cmpn(1) === 0)
    return x1;
  else
    return x2;
};

BN.prototype.gcd = function gcd(num) {
  if (this.cmpn(0) === 0)
    return num.clone();
  if (num.cmpn(0) === 0)
    return this.clone();

  var a = this.clone();
  var b = num.clone();
  a.sign = false;
  b.sign = false;

  // Remove common factor of two
  for (var shift = 0; a.isEven() && b.isEven(); shift++) {
    a.ishrn(1);
    b.ishrn(1);
  }

  do {
    while (a.isEven())
      a.ishrn(1);
    while (b.isEven())
      b.ishrn(1);

    var r = a.cmp(b);
    if (r < 0) {
      // Swap `a` and `b` to make `a` always bigger than `b`
      var t = a;
      a = b;
      b = t;
    } else if (r === 0 || b.cmpn(1) === 0) {
      break;
    }

    a.isub(b);
  } while (true);

  return b.ishln(shift);
};

// Invert number in the field F(num)
BN.prototype.invm = function invm(num) {
  return this.egcd(num).a.mod(num);
};

BN.prototype.isEven = function isEven() {
  return (this.words[0] & 1) === 0;
};

BN.prototype.isOdd = function isOdd() {
  return (this.words[0] & 1) === 1;
};

// And first word and num
BN.prototype.andln = function andln(num) {
  return this.words[0] & num;
};

// Increment at the bit position in-line
BN.prototype.bincn = function bincn(bit) {
  assert(typeof bit === 'number');
  var r = bit % 26;
  var s = (bit - r) / 26;
  var q = 1 << r;

  // Fast case: bit is much higher than all existing words
  if (this.length <= s) {
    for (var i = this.length; i < s + 1; i++)
      this.words[i] = 0;
    this.words[s] |= q;
    this.length = s + 1;
    return this;
  }

  // Add bit and propagate, if needed
  var carry = q;
  for (var i = s; carry !== 0 && i < this.length; i++) {
    var w = this.words[i];
    w += carry;
    carry = w >>> 26;
    w &= 0x3ffffff;
    this.words[i] = w;
  }
  if (carry !== 0) {
    this.words[i] = carry;
    this.length++;
  }
  return this;
};

BN.prototype.cmpn = function cmpn(num) {
  var sign = num < 0;
  if (sign)
    num = -num;

  if (this.sign && !sign)
    return -1;
  else if (!this.sign && sign)
    return 1;

  num &= 0x3ffffff;
  this.strip();

  var res;
  if (this.length > 1) {
    res = 1;
  } else {
    var w = this.words[0];
    res = w === num ? 0 : w < num ? -1 : 1;
  }
  if (this.sign)
    res = -res;
  return res;
};

// Compare two numbers and return:
// 1 - if `this` > `num`
// 0 - if `this` == `num`
// -1 - if `this` < `num`
BN.prototype.cmp = function cmp(num) {
  if (this.sign && !num.sign)
    return -1;
  else if (!this.sign && num.sign)
    return 1;

  var res = this.ucmp(num);
  if (this.sign)
    return -res;
  else
    return res;
};

// Unsigned comparison
BN.prototype.ucmp = function ucmp(num) {
  // At this point both numbers have the same sign
  if (this.length > num.length)
    return 1;
  else if (this.length < num.length)
    return -1;

  var res = 0;
  for (var i = this.length - 1; i >= 0; i--) {
    var a = this.words[i];
    var b = num.words[i];

    if (a === b)
      continue;
    if (a < b)
      res = -1;
    else if (a > b)
      res = 1;
    break;
  }
  return res;
};

//
// A reduce context, could be using montgomery or something better, depending
// on the `m` itself.
//
BN.red = function red(num) {
  return new Red(num);
};

BN.prototype.toRed = function toRed(ctx) {
  assert(!this.red, 'Already a number in reduction context');
  assert(!this.sign, 'red works only with positives');
  return ctx.convertTo(this)._forceRed(ctx);
};

BN.prototype.fromRed = function fromRed() {
  assert(this.red, 'fromRed works only with numbers in reduction context');
  return this.red.convertFrom(this);
};

BN.prototype._forceRed = function _forceRed(ctx) {
  this.red = ctx;
  return this;
};

BN.prototype.forceRed = function forceRed(ctx) {
  assert(!this.red, 'Already a number in reduction context');
  return this._forceRed(ctx);
};

BN.prototype.redAdd = function redAdd(num) {
  assert(this.red, 'redAdd works only with red numbers');
  return this.red.add(this, num);
};

BN.prototype.redIAdd = function redIAdd(num) {
  assert(this.red, 'redIAdd works only with red numbers');
  return this.red.iadd(this, num);
};

BN.prototype.redSub = function redSub(num) {
  assert(this.red, 'redSub works only with red numbers');
  return this.red.sub(this, num);
};

BN.prototype.redISub = function redISub(num) {
  assert(this.red, 'redISub works only with red numbers');
  return this.red.isub(this, num);
};

BN.prototype.redShl = function redShl(num) {
  assert(this.red, 'redShl works only with red numbers');
  return this.red.shl(this, num);
};

BN.prototype.redMul = function redMul(num) {
  assert(this.red, 'redMul works only with red numbers');
  this.red._verify2(this, num);
  return this.red.mul(this, num);
};

BN.prototype.redIMul = function redIMul(num) {
  assert(this.red, 'redMul works only with red numbers');
  this.red._verify2(this, num);
  return this.red.imul(this, num);
};

BN.prototype.redSqr = function redSqr() {
  assert(this.red, 'redSqr works only with red numbers');
  this.red._verify1(this);
  return this.red.sqr(this);
};

BN.prototype.redISqr = function redISqr() {
  assert(this.red, 'redISqr works only with red numbers');
  this.red._verify1(this);
  return this.red.isqr(this);
};

// Square root over p
BN.prototype.redSqrt = function redSqrt() {
  assert(this.red, 'redSqrt works only with red numbers');
  this.red._verify1(this);
  return this.red.sqrt(this);
};

BN.prototype.redInvm = function redInvm() {
  assert(this.red, 'redInvm works only with red numbers');
  this.red._verify1(this);
  return this.red.invm(this);
};

// Return negative clone of `this` % `red modulo`
BN.prototype.redNeg = function redNeg() {
  assert(this.red, 'redNeg works only with red numbers');
  this.red._verify1(this);
  return this.red.neg(this);
};

BN.prototype.redPow = function redPow(num) {
  assert(this.red && !num.red, 'redPow(normalNum)');
  this.red._verify1(this);
  return this.red.pow(this, num);
};

// Prime numbers with efficient reduction
var primes = {
  k256: null,
  p224: null,
  p192: null,
  p25519: null
};

// Pseudo-Mersenne prime
function MPrime(name, p) {
  // P = 2 ^ N - K
  this.name = name;
  this.p = new BN(p, 16);
  this.n = this.p.bitLength();
  this.k = new BN(1).ishln(this.n).isub(this.p);

  this.tmp = this._tmp();
}

MPrime.prototype._tmp = function _tmp() {
  var tmp = new BN(null);
  tmp.words = new Array(Math.ceil(this.n / 13));
  return tmp;
};

MPrime.prototype.ireduce = function ireduce(num) {
  // Assumes that `num` is less than `P^2`
  // num = HI * (2 ^ N - K) + HI * K + LO = HI * K + LO (mod P)
  var r = num;
  var rlen;

  do {
    this.split(r, this.tmp);
    r = this.imulK(r);
    r = r.iadd(this.tmp);
    rlen = r.bitLength();
  } while (rlen > this.n);

  var cmp = rlen < this.n ? -1 : r.ucmp(this.p);
  if (cmp === 0) {
    r.words[0] = 0;
    r.length = 1;
  } else if (cmp > 0) {
    r.isub(this.p);
  } else {
    r.strip();
  }

  return r;
};

MPrime.prototype.split = function split(input, out) {
  input.ishrn(this.n, 0, out);
};

MPrime.prototype.imulK = function imulK(num) {
  return num.imul(this.k);
};

function K256() {
  MPrime.call(
    this,
    'k256',
    'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f');
}
inherits(K256, MPrime);

K256.prototype.split = function split(input, output) {
  // 256 = 9 * 26 + 22
  var mask = 0x3fffff;

  var outLen = Math.min(input.length, 9);
  for (var i = 0; i < outLen; i++)
    output.words[i] = input.words[i];
  output.length = outLen;

  if (input.length <= 9) {
    input.words[0] = 0;
    input.length = 1;
    return;
  }

  // Shift by 9 limbs
  var prev = input.words[9];
  output.words[output.length++] = prev & mask;

  for (var i = 10; i < input.length; i++) {
    var next = input.words[i];
    input.words[i - 10] = ((next & mask) << 4) | (prev >>> 22);
    prev = next;
  }
  input.words[i - 10] = prev >>> 22;
  input.length -= 9;
};

K256.prototype.imulK = function imulK(num) {
  // K = 0x1000003d1 = [ 0x40, 0x3d1 ]
  num.words[num.length] = 0;
  num.words[num.length + 1] = 0;
  num.length += 2;

  // bounded at: 0x40 * 0x3ffffff + 0x3d0 = 0x100000390
  var hi;
  var lo = 0;
  for (var i = 0; i < num.length; i++) {
    var w = num.words[i];
    hi = w * 0x40;
    lo += w * 0x3d1;
    hi += (lo / 0x4000000) | 0;
    lo &= 0x3ffffff;

    num.words[i] = lo;

    lo = hi;
  }

  // Fast length reduction
  if (num.words[num.length - 1] === 0) {
    num.length--;
    if (num.words[num.length - 1] === 0)
      num.length--;
  }
  return num;
};

function P224() {
  MPrime.call(
    this,
    'p224',
    'ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001');
}
inherits(P224, MPrime);

function P192() {
  MPrime.call(
    this,
    'p192',
    'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff');
}
inherits(P192, MPrime);

function P25519() {
  // 2 ^ 255 - 19
  MPrime.call(
    this,
    '25519',
    '7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed');
}
inherits(P25519, MPrime);

P25519.prototype.imulK = function imulK(num) {
  // K = 0x13
  var carry = 0;
  for (var i = 0; i < num.length; i++) {
    var hi = num.words[i] * 0x13 + carry;
    var lo = hi & 0x3ffffff;
    hi >>>= 26;

    num.words[i] = lo;
    carry = hi;
  }
  if (carry !== 0)
    num.words[num.length++] = carry;
  return num;
};

// Exported mostly for testing purposes, use plain name instead
BN._prime = function prime(name) {
  // Cached version of prime
  if (primes[name])
    return primes[name];

  var prime;
  if (name === 'k256')
    prime = new K256();
  else if (name === 'p224')
    prime = new P224();
  else if (name === 'p192')
    prime = new P192();
  else if (name === 'p25519')
    prime = new P25519();
  else
    throw new Error('Unknown prime ' + name);
  primes[name] = prime;

  return prime;
};

//
// Base reduction engine
//
function Red(m) {
  if (typeof m === 'string') {
    var prime = BN._prime(m);
    this.m = prime.p;
    this.prime = prime;
  } else {
    this.m = m;
    this.prime = null;
  }
}

Red.prototype._verify1 = function _verify1(a) {
  assert(!a.sign, 'red works only with positives');
  assert(a.red, 'red works only with red numbers');
};

Red.prototype._verify2 = function _verify2(a, b) {
  assert(!a.sign && !b.sign, 'red works only with positives');
  assert(a.red && a.red === b.red,
         'red works only with red numbers');
};

Red.prototype.imod = function imod(a) {
  if (this.prime)
    return this.prime.ireduce(a)._forceRed(this);
  return a.mod(this.m)._forceRed(this);
};

Red.prototype.neg = function neg(a) {
  var r = a.clone();
  r.sign = !r.sign;
  return r.iadd(this.m)._forceRed(this);
};

Red.prototype.add = function add(a, b) {
  this._verify2(a, b);

  var res = a.add(b);
  if (res.cmp(this.m) >= 0)
    res.isub(this.m);
  return res._forceRed(this);
};

Red.prototype.iadd = function iadd(a, b) {
  this._verify2(a, b);

  var res = a.iadd(b);
  if (res.cmp(this.m) >= 0)
    res.isub(this.m);
  return res;
};

Red.prototype.sub = function sub(a, b) {
  this._verify2(a, b);

  var res = a.sub(b);
  if (res.cmpn(0) < 0)
    res.iadd(this.m);
  return res._forceRed(this);
};

Red.prototype.isub = function isub(a, b) {
  this._verify2(a, b);

  var res = a.isub(b);
  if (res.cmpn(0) < 0)
    res.iadd(this.m);
  return res;
};

Red.prototype.shl = function shl(a, num) {
  this._verify1(a);
  return this.imod(a.shln(num));
};

Red.prototype.imul = function imul(a, b) {
  this._verify2(a, b);
  return this.imod(a.imul(b));
};

Red.prototype.mul = function mul(a, b) {
  this._verify2(a, b);
  return this.imod(a.mul(b));
};

Red.prototype.isqr = function isqr(a) {
  return this.imul(a, a);
};

Red.prototype.sqr = function sqr(a) {
  return this.mul(a, a);
};

Red.prototype.sqrt = function sqrt(a) {
  if (a.cmpn(0) === 0)
    return a.clone();

  var mod3 = this.m.andln(3);
  assert(mod3 % 2 === 1);

  // Fast case
  if (mod3 === 3) {
    var pow = this.m.add(new BN(1)).ishrn(2);
    var r = this.pow(a, pow);
    return r;
  }

  // Tonelli-Shanks algorithm (Totally unoptimized and slow)
  //
  // Find Q and S, that Q * 2 ^ S = (P - 1)
  var q = this.m.subn(1);
  var s = 0;
  while (q.cmpn(0) !== 0 && q.andln(1) === 0) {
    s++;
    q.ishrn(1);
  }
  assert(q.cmpn(0) !== 0);

  var one = new BN(1).toRed(this);
  var nOne = one.redNeg();

  // Find quadratic non-residue
  // NOTE: Max is such because of generalized Riemann hypothesis.
  var lpow = this.m.subn(1).ishrn(1);
  var z = this.m.bitLength();
  z = new BN(2 * z * z).toRed(this);
  while (this.pow(z, lpow).cmp(nOne) !== 0)
    z.redIAdd(nOne);

  var c = this.pow(z, q);
  var r = this.pow(a, q.addn(1).ishrn(1));
  var t = this.pow(a, q);
  var m = s;
  while (t.cmp(one) !== 0) {
    var tmp = t;
    for (var i = 0; tmp.cmp(one) !== 0; i++)
      tmp = tmp.redSqr();
    assert(i < m);
    var b = this.pow(c, new BN(1).ishln(m - i - 1));

    r = r.redMul(b);
    c = b.redSqr();
    t = t.redMul(c);
    m = i;
  }

  return r;
};

Red.prototype.invm = function invm(a) {
  var inv = a._invmp(this.m);
  if (inv.sign) {
    inv.sign = false;
    return this.imod(inv).redNeg();
  } else {
    return this.imod(inv);
  }
};

Red.prototype.pow = function pow(a, num) {
  var w = [];

  if (num.cmpn(0) === 0)
    return new BN(1);

  var q = num.clone();

  while (q.cmpn(0) !== 0) {
    w.push(q.andln(1));
    q.ishrn(1);
  }

  // Skip leading zeroes
  var res = a;
  for (var i = 0; i < w.length; i++, res = this.sqr(res))
    if (w[i] !== 0)
      break;

  if (++i < w.length) {
    for (var q = this.sqr(res); i < w.length; i++, q = this.sqr(q)) {
      if (w[i] === 0)
        continue;
      res = this.mul(res, q);
    }
  }

  return res;
};

Red.prototype.convertTo = function convertTo(num) {
  var r = num.mod(this.m);
  if (r === num)
    return r.clone();
  else
    return r;
};

Red.prototype.convertFrom = function convertFrom(num) {
  var res = num.clone();
  res.red = null;
  return res;
};

//
// Montgomery method engine
//

BN.mont = function mont(num) {
  return new Mont(num);
};

function Mont(m) {
  Red.call(this, m);

  this.shift = this.m.bitLength();
  if (this.shift % 26 !== 0)
    this.shift += 26 - (this.shift % 26);
  this.r = new BN(1).ishln(this.shift);
  this.r2 = this.imod(this.r.sqr());
  this.rinv = this.r._invmp(this.m);

  this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);
  this.minv.sign = true;
  this.minv = this.minv.mod(this.r);
}
inherits(Mont, Red);

Mont.prototype.convertTo = function convertTo(num) {
  return this.imod(num.shln(this.shift));
};

Mont.prototype.convertFrom = function convertFrom(num) {
  var r = this.imod(num.mul(this.rinv));
  r.red = null;
  return r;
};

Mont.prototype.imul = function imul(a, b) {
  if (a.cmpn(0) === 0 || b.cmpn(0) === 0) {
    a.words[0] = 0;
    a.length = 1;
    return a;
  }

  var t = a.imul(b);
  var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
  var u = t.isub(c).ishrn(this.shift);
  var res = u;
  if (u.cmp(this.m) >= 0)
    res = u.isub(this.m);
  else if (u.cmpn(0) < 0)
    res = u.iadd(this.m);

  return res._forceRed(this);
};

Mont.prototype.mul = function mul(a, b) {
  if (a.cmpn(0) === 0 || b.cmpn(0) === 0)
    return new BN(0)._forceRed(this);

  var t = a.mul(b);
  var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
  var u = t.isub(c).ishrn(this.shift);
  var res = u;
  if (u.cmp(this.m) >= 0)
    res = u.isub(this.m);
  else if (u.cmpn(0) < 0)
    res = u.iadd(this.m);

  return res._forceRed(this);
};

Mont.prototype.invm = function invm(a) {
  // (AR)^-1 * R^2 = (A^-1 * R^-1) * R^2 = A^-1 * R
  var res = this.imod(a._invmp(this.m).mul(this.r2));
  return res._forceRed(this);
};

})(typeof module === 'undefined' || module, this);

},{}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/lib/asn1/constants/der.js":[function(require,module,exports){
var constants = require('../constants');

exports.tagClass = {
  0: 'universal',
  1: 'application',
  2: 'context',
  3: 'private'
};
exports.tagClassByName = constants._reverse(exports.tagClass);

exports.tag = {
  0x00: 'end',
  0x01: 'bool',
  0x02: 'int',
  0x03: 'bitstr',
  0x04: 'octstr',
  0x05: 'null_',
  0x06: 'objid',
  0x07: 'objDesc',
  0x08: 'external',
  0x09: 'real',
  0x0a: 'enum',
  0x0b: 'embed',
  0x0c: 'utf8str',
  0x0d: 'relativeOid',
  0x10: 'seq',
  0x11: 'set',
  0x12: 'numstr',
  0x13: 'printstr',
  0x14: 't61str',
  0x15: 'videostr',
  0x16: 'ia5str',
  0x17: 'utctime',
  0x18: 'gentime',
  0x19: 'graphstr',
  0x1a: 'iso646str',
  0x1b: 'genstr',
  0x1c: 'unistr',
  0x1d: 'charstr',
  0x1e: 'bmpstr'
};
exports.tagByName = constants._reverse(exports.tag);

},{"../constants":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/lib/asn1/constants/index.js"}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/lib/asn1/constants/index.js":[function(require,module,exports){
var constants = exports;

// Helper
constants._reverse = function reverse(map) {
  var res = {};

  Object.keys(map).forEach(function(key) {
    // Convert key to integer if it is stringified
    if ((key | 0) == key)
      key = key | 0;

    var value = map[key];
    res[value] = key;
  });

  return res;
};

constants.der = require('./der');

},{"./der":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/lib/asn1/constants/der.js"}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/lib/asn1/decoders/der.js":[function(require,module,exports){
var inherits = require('util').inherits;

var asn1 = require('../asn1');
var base = asn1.base;
var bignum = asn1.bignum;

// Import DER constants
var der = asn1.constants.der;

function DERDecoder(entity) {
  this.enc = 'der';
  this.name = entity.name;
  this.entity = entity;

  // Construct base tree
  this.tree = new DERNode();
  this.tree._init(entity.body);
}
module.exports = DERDecoder;

DERDecoder.prototype.decode = function decode(data, options) {
  if (!(data instanceof base.DecoderBuffer))
    data = new base.DecoderBuffer(data, options);

  return this.tree._decode(data, options);
};

// Tree methods

function DERNode(parent) {
  base.Node.call(this, 'der', parent);
}
inherits(DERNode, base.Node);

DERNode.prototype._peekTag = function peekTag(buffer, tag, any) {
  if (buffer.isEmpty())
    return false;

  var state = buffer.save();
  var decodedTag = derDecodeTag(buffer, 'Failed to peek tag: "' + tag + '"');
  if (buffer.isError(decodedTag))
    return decodedTag;

  buffer.restore(state);

  return decodedTag.tag === tag || decodedTag.tagStr === tag || any;
};

DERNode.prototype._decodeTag = function decodeTag(buffer, tag, any) {
  var decodedTag = derDecodeTag(buffer,
                                'Failed to decode tag of "' + tag + '"');
  if (buffer.isError(decodedTag))
    return decodedTag;

  var len = derDecodeLen(buffer,
                         decodedTag.primitive,
                         'Failed to get length of "' + tag + '"');

  // Failure
  if (buffer.isError(len))
    return len;

  if (!any &&
      decodedTag.tag !== tag &&
      decodedTag.tagStr !== tag &&
      decodedTag.tagStr + 'of' !== tag) {
    return buffer.error('Failed to match tag: "' + tag + '"');
  }

  if (decodedTag.primitive || len !== null)
    return buffer.skip(len, 'Failed to match body of: "' + tag + '"');

  // Indefinite length... find END tag
  var state = buffer.save();
  var res = this._skipUntilEnd(
      buffer,
      'Failed to skip indefinite length body: "' + this.tag + '"');
  if (buffer.isError(res))
    return res;

  len = buffer.offset - state.offset;
  buffer.restore(state);
  return buffer.skip(len, 'Failed to match body of: "' + tag + '"');
};

DERNode.prototype._skipUntilEnd = function skipUntilEnd(buffer, fail) {
  while (true) {
    var tag = derDecodeTag(buffer, fail);
    if (buffer.isError(tag))
      return tag;
    var len = derDecodeLen(buffer, tag.primitive, fail);
    if (buffer.isError(len))
      return len;

    var res;
    if (tag.primitive || len !== null)
      res = buffer.skip(len)
    else
      res = this._skipUntilEnd(buffer, fail);

    // Failure
    if (buffer.isError(res))
      return res;

    if (tag.tagStr === 'end')
      break;
  }
};

DERNode.prototype._decodeList = function decodeList(buffer, tag, decoder) {
  var result = [];
  while (!buffer.isEmpty()) {
    var possibleEnd = this._peekTag(buffer, 'end');
    if (buffer.isError(possibleEnd))
      return possibleEnd;

    var res = decoder.decode(buffer, 'der');
    if (buffer.isError(res) && possibleEnd)
      break;
    result.push(res);
  }
  return result;
};

DERNode.prototype._decodeStr = function decodeStr(buffer, tag) {
  if (tag === 'octstr') {
    return buffer.raw();
  } else if (tag === 'bitstr') {
    var unused = buffer.readUInt8();
    if (buffer.isError(unused))
      return unused;

    return { unused: unused, data: buffer.raw() };
  } else if (tag === 'ia5str' || tag === 'utf8str') {
    return buffer.raw().toString();
  } else {
    return this.error('Decoding of string type: ' + tag + ' unsupported');
  }
};

DERNode.prototype._decodeObjid = function decodeObjid(buffer, values, relative) {
  var identifiers = [];
  var ident = 0;
  while (!buffer.isEmpty()) {
    var subident = buffer.readUInt8();
    ident <<= 7;
    ident |= subident & 0x7f;
    if ((subident & 0x80) === 0) {
      identifiers.push(ident);
      ident = 0;
    }
  }
  if (subident & 0x80)
    identifiers.push(ident);

  var first = (identifiers[0] / 40) | 0;
  var second = identifiers[0] % 40;

  if (relative)
    result = identifiers;
  else
    result = [first, second].concat(identifiers.slice(1));

  if (values)
    result = values[result.join(' ')];

  return result;
};

DERNode.prototype._decodeTime = function decodeTime(buffer, tag) {
  var str = buffer.raw().toString();
  if (tag === 'gentime') {
    var year = str.slice(0, 4) | 0;
    var mon = str.slice(4, 6) | 0;
    var day = str.slice(6, 8) | 0;
    var hour = str.slice(8, 10) | 0;
    var min = str.slice(10, 12) | 0;
    var sec = str.slice(12, 14) | 0;
  } else if (tag === 'utctime') {
    var year = str.slice(0, 2) | 0;
    var mon = str.slice(2, 4) | 0;
    var day = str.slice(4, 6) | 0;
    var hour = str.slice(6, 8) | 0;
    var min = str.slice(8, 10) | 0;
    var sec = str.slice(10, 12) | 0;
    if (year < 70)
      year = 2000 + year;
    else
      year = 1900 + year;
  } else {
    return this.error('Decoding ' + tag + ' time is not supported yet');
  }

  return Date.UTC(year, mon - 1, day, hour, min, sec, 0);
};

DERNode.prototype._decodeNull = function decodeNull(buffer) {
  return null;
};

DERNode.prototype._decodeBool = function decodeBool(buffer) {
  var res = buffer.readUInt8();
  if (buffer.isError(res))
    return res;
  else
    return res !== 0;
};

DERNode.prototype._decodeInt = function decodeInt(buffer, values) {
  // Bigint, return as it is (assume big endian)
  var raw = buffer.raw();
  var res = new bignum(raw);

  if (values)
    res = values[res.toString(10)] || res;

  return res;
};

DERNode.prototype._use = function use(entity, obj) {
  if (typeof entity === 'function')
    entity = entity(obj);
  return entity._getDecoder('der').tree;
};

// Utility methods

function derDecodeTag(buf, fail) {
  var tag = buf.readUInt8(fail);
  if (buf.isError(tag))
    return tag;

  var cls = der.tagClass[tag >> 6];
  var primitive = (tag & 0x20) === 0;

  // Multi-octet tag - load
  if ((tag & 0x1f) === 0x1f) {
    var oct = tag;
    tag = 0;
    while ((oct & 0x80) === 0x80) {
      oct = buf.readUInt8(fail);
      if (buf.isError(oct))
        return oct;

      tag <<= 7;
      tag |= oct & 0x7f;
    }
  } else {
    tag &= 0x1f;
  }
  var tagStr = der.tag[tag];

  return {
    cls: cls,
    primitive: primitive,
    tag: tag,
    tagStr: tagStr
  };
}

function derDecodeLen(buf, primitive, fail) {
  var len = buf.readUInt8(fail);
  if (buf.isError(len))
    return len;

  // Indefinite form
  if (!primitive && len === 0x80)
    return null;

  // Definite form
  if ((len & 0x80) === 0) {
    // Short form
    return len;
  }

  // Long form
  var num = len & 0x7f;
  if (num >= 4)
    return buf.error('length octect is too long');

  len = 0;
  for (var i = 0; i < num; i++) {
    len <<= 8;
    var j = buf.readUInt8(fail);
    if (buf.isError(j))
      return j;
    len |= j;
  }

  return len;
}

},{"../asn1":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/lib/asn1/asn1.js","util":false}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/lib/asn1/decoders/index.js":[function(require,module,exports){
var decoders = exports;

decoders.der = require('./der');
decoders.pem = require('./pem');

},{"./der":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/lib/asn1/decoders/der.js","./pem":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/lib/asn1/decoders/pem.js"}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/lib/asn1/decoders/pem.js":[function(require,module,exports){
const inherits = require('util').inherits;

const DERDecoder = require('./der');

function PEMDecoder(entity) {
    DERDecoder.call(this, entity);
    this.enc = 'pem';
}
inherits(PEMDecoder, DERDecoder);
module.exports = PEMDecoder;

PEMDecoder.prototype.decode = function decode(data, options) {
    const lines = data.toString().split(/[\r\n]+/g);

    const label = options.label.toUpperCase();

    const re = /^-----(BEGIN|END) ([^-]+)-----$/;
    let start = -1;
    let end = -1;
    for (let i = 0; i < lines.length; i++) {
        const match = lines[i].match(re);
        if (match === null)
            continue;

        if (match[2] !== label)
            continue;

        if (start === -1) {
            if (match[1] !== 'BEGIN')
                break;
            start = i;
        } else {
            if (match[1] !== 'END')
                break;
            end = i;
            break;
        }
    }
    if (start === -1 || end === -1)
        throw new Error('PEM section not found for: ' + label);

    const base64 = lines.slice(start + 1, end).join('');
    // Remove excessive symbols
    base64.replace(/[^a-z0-9+/=]+/gi, '');
    const input = $$.Buffer.from(base64, 'base64');
    return DERDecoder.prototype.decode.call(this, input, options);
};

},{"./der":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/lib/asn1/decoders/der.js","util":false}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/lib/asn1/encoders/der.js":[function(require,module,exports){
const inherits = require('util').inherits;
const asn1 = require('../asn1');
const base = asn1.base;

// Import DER constants
const der = asn1.constants.der;

function DEREncoder(entity) {
    this.enc = 'der';
    this.name = entity.name;
    this.entity = entity;

    // Construct base tree
    this.tree = new DERNode();
    this.tree._init(entity.body);
}
module.exports = DEREncoder;

DEREncoder.prototype.encode = function encode(data, reporter) {
    return this.tree._encode(data, reporter).join();
};

// Tree methods

function DERNode(parent) {
    base.Node.call(this, 'der', parent);
}

inherits(DERNode, base.Node);

DERNode.prototype._encodeComposite = function encodeComposite(tag, primitive, cls, content) {
    const encodedTag = encodeTag(tag, primitive, cls, this.reporter);

    // Short form
    if (content.length < 0x80) {
        const header = $$.Buffer.alloc(2);
        header[0] = encodedTag;
        header[1] = content.length;
        return this._createEncoderBuffer([header, content]);
    }

    // Long form
    // Count octets required to store length
    let lenOctets = 1;
    for (let i = content.length; i >= 0x100; i >>= 8)
        lenOctets++;

    const header = $$.Buffer.alloc(1 + 1 + lenOctets);
    header[0] = encodedTag;
    header[1] = 0x80 | lenOctets;

    for (let i = 1 + lenOctets, j = content.length; j > 0; i--, j >>= 8)
        header[i] = j & 0xff;

    return this._createEncoderBuffer([header, content]);
};

DERNode.prototype._encodeStr = function encodeStr(str, tag) {
    if (tag === 'octstr')
        return this._createEncoderBuffer(str);
    else if (tag === 'bitstr')
        return this._createEncoderBuffer([str.unused | 0, str.data]);
    else if (tag === 'ia5str' || tag === 'utf8str')
        return this._createEncoderBuffer(str);
    return this.reporter.error('Encoding of string type: ' + tag +
        ' unsupported');
};

DERNode.prototype._encodeObjid = function encodeObjid(id, values, relative) {
    if (typeof id === 'string') {
        if (!values)
            return this.reporter.error('string objid given, but no values map found');
        if (!values.hasOwnProperty(id))
            return this.reporter.error('objid not found in values map');
        id = values[id].split(/[\s\.]+/g);
        for (let i = 0; i < id.length; i++)
            id[i] |= 0;
    } else if (Array.isArray(id)) {
        id = id.slice();
        for (let i = 0; i < id.length; i++)
            id[i] |= 0;
    }

    if (!Array.isArray(id)) {
        return this.reporter.error('objid() should be either array or string, ' +
            'got: ' + JSON.stringify(id));
    }

    if (!relative) {
        if (id[1] >= 40)
            return this.reporter.error('Second objid identifier OOB');
        id.splice(0, 2, id[0] * 40 + id[1]);
    }

    // Count number of octets
    let size = 0;
    for (let i = 0; i < id.length; i++) {
        let ident = id[i];
        for (size++; ident >= 0x80; ident >>= 7)
            size++;
    }

    const objid = $$.Buffer.alloc(size);
    let offset = objid.length - 1;
    for (let i = id.length - 1; i >= 0; i--) {
        let ident = id[i];
        objid[offset--] = ident & 0x7f;
        while ((ident >>= 7) > 0)
            objid[offset--] = 0x80 | (ident & 0x7f);
    }

    return this._createEncoderBuffer(objid);
};

function two(num) {
    if (num < 10)
        return '0' + num;
    else
        return num;
}

DERNode.prototype._encodeTime = function encodeTime(time, tag) {
    let str;
    const date = new Date(time);

    if (tag === 'gentime') {
        str = [
            two(date.getFullYear()),
            two(date.getUTCMonth() + 1),
            two(date.getUTCDate()),
            two(date.getUTCHours()),
            two(date.getUTCMinutes()),
            two(date.getUTCSeconds()),
            'Z'
        ].join('');
    } else if (tag === 'utctime') {
        str = [
            two(date.getFullYear() % 100),
            two(date.getUTCMonth() + 1),
            two(date.getUTCDate()),
            two(date.getUTCHours()),
            two(date.getUTCMinutes()),
            two(date.getUTCSeconds()),
            'Z'
        ].join('');
    } else {
        this.reporter.error('Encoding ' + tag + ' time is not supported yet');
    }

    return this._encodeStr(str, 'octstr');
};

DERNode.prototype._encodeNull = function encodeNull() {
    return this._createEncoderBuffer('');
};

DERNode.prototype._encodeInt = function encodeInt(num, values) {
    if (typeof num === 'string') {
        if (!values)
            return this.reporter.error('String int or enum given, but no values map');
        if (!values.hasOwnProperty(num)) {
            return this.reporter.error('Values map doesn\'t contain: ' +
                JSON.stringify(num));
        }
        num = values[num];
    }

    // Bignum, assume big endian
    if (typeof num !== 'number' && !$$.Buffer.isBuffer(num)) {
        const numArray = num.toArray();
        if (num.sign === false && numArray[0] & 0x80) {
            numArray.unshift(0);
        }
        num = $$.Buffer.from(numArray);
    }

    if ($$.Buffer.isBuffer(num)) {
        let size = num.length;
        if (num.length === 0)
            size++;

        const out = $$.Buffer.alloc(size);
        num.copy(out);
        if (num.length === 0)
            out[0] = 0
        return this._createEncoderBuffer(out);
    }

    if (num < 0x80)
        return this._createEncoderBuffer(num);

    if (num < 0x100)
        return this._createEncoderBuffer([0, num]);

    let size = 1;
    for (let i = num; i >= 0x100; i >>= 8)
        size++;

    const out = new Array(size);
    for (let i = out.length - 1; i >= 0; i--) {
        out[i] = num & 0xff;
        num >>= 8;
    }
    if (out[0] & 0x80) {
        out.unshift(0);
    }

    return this._createEncoderBuffer($$.Buffer.from(out));
};

DERNode.prototype._encodeBool = function encodeBool(value) {
    return this._createEncoderBuffer(value ? 0xff : 0);
};

DERNode.prototype._use = function use(entity, obj) {
    if (typeof entity === 'function')
        entity = entity(obj);
    return entity._getEncoder('der').tree;
};

DERNode.prototype._skipDefault = function skipDefault(dataBuffer, reporter, parent) {
    const state = this._baseState;
    let i;
    if (state['default'] === null)
        return false;

    const data = dataBuffer.join();
    if (state.defaultBuffer === undefined)
        state.defaultBuffer = this._encodeValue(state['default'], reporter, parent).join();

    if (data.length !== state.defaultBuffer.length)
        return false;

    for (i = 0; i < data.length; i++)
        if (data[i] !== state.defaultBuffer[i])
            return false;

    return true;
};

// Utility methods

function encodeTag(tag, primitive, cls, reporter) {
    let res;

    if (tag === 'seqof')
        tag = 'seq';
    else if (tag === 'setof')
        tag = 'set';

    if (der.tagByName.hasOwnProperty(tag))
        res = der.tagByName[tag];
    else if (typeof tag === 'number' && (tag | 0) === tag)
        res = tag;
    else
        return reporter.error('Unknown tag: ' + tag);

    if (res >= 0x1f)
        return reporter.error('Multi-octet tag encoding unsupported');

    if (!primitive)
        res |= 0x20;

    res |= (der.tagClassByName[cls || 'universal'] << 6);

    return res;
}

},{"../asn1":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/lib/asn1/asn1.js","util":false}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/lib/asn1/encoders/index.js":[function(require,module,exports){
var encoders = exports;

encoders.der = require('./der');
encoders.pem = require('./pem');

},{"./der":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/lib/asn1/encoders/der.js","./pem":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/lib/asn1/encoders/pem.js"}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/lib/asn1/encoders/pem.js":[function(require,module,exports){
var inherits = require('util').inherits;

var DEREncoder = require('./der');

function PEMEncoder(entity) {
  DEREncoder.call(this, entity);
  this.enc = 'pem';
}
inherits(PEMEncoder, DEREncoder);
module.exports = PEMEncoder;

PEMEncoder.prototype.encode = function encode(data, options) {
  var buf = DEREncoder.prototype.encode.call(this, data);

  var p = buf.toString('base64');
  var out = [ '-----BEGIN ' + options.label + '-----' ];
  for (var i = 0; i < p.length; i += 64)
    out.push(p.slice(i, i + 64));
  out.push('-----END ' + options.label + '-----');
  return out.join('\n');
};

},{"./der":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/lib/asn1/encoders/der.js","util":false}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/lib/keyEncoder.js":[function(require,module,exports){
'use strict'

const asn1 = require('./asn1/asn1');
const BN = require('./asn1/bignum/bn');

const ECPrivateKeyASN = asn1.define('ECPrivateKey', function () {
    this.seq().obj(
        this.key('version').int(),
        this.key('privateKey').octstr(),
        this.key('parameters').explicit(0).objid().optional(),
        this.key('publicKey').explicit(1).bitstr().optional()
    )
})

const SubjectPublicKeyInfoASN = asn1.define('SubjectPublicKeyInfo', function () {
    this.seq().obj(
        this.key('algorithm').seq().obj(
            this.key("id").objid(),
            this.key("curve").objid()
        ),
        this.key('pub').bitstr()
    )
})

const ECDSASignature = asn1.define('ECDSASignature', function () {
    return this.seq().obj(
        this.key('r').int(),
        this.key('s').int()
    );
});

const curves = {
    secp256k1: {
        curveParameters: [1, 3, 132, 0, 10],
        privatePEMOptions: {label: 'EC PRIVATE KEY'},
        publicPEMOptions: {label: 'PUBLIC KEY'}
    }
}

function assert(val, msg) {
    if (!val) {
        throw new Error(msg || 'Assertion failed')
    }
}

function KeyEncoder(options) {
    if (typeof options === 'string') {
        assert(curves.hasOwnProperty(options), 'Unknown curve ' + options);
        options = curves[options]
    }
    this.options = options;
    this.algorithmID = [1, 2, 840, 10045, 2, 1]
}

KeyEncoder.ECPrivateKeyASN = ECPrivateKeyASN;
KeyEncoder.SubjectPublicKeyInfoASN = SubjectPublicKeyInfoASN;
KeyEncoder.ECDSASignature = ECDSASignature;

KeyEncoder.prototype.privateKeyObject = function (rawPrivateKey, rawPublicKey, encodingFormat = "hex") {
    const privateKeyObject = {
        version: new BN(1),
        privateKey: $$.Buffer.from(rawPrivateKey, encodingFormat),
        parameters: this.options.curveParameters,
        pemOptions: {label: "EC PRIVATE KEY"}
    };

    if (rawPublicKey) {
        privateKeyObject.publicKey = {
            unused: 0,
            data: $$.Buffer.from(rawPublicKey, encodingFormat)
        }
    }

    return privateKeyObject
};

KeyEncoder.prototype.publicKeyObject = function (rawPublicKey) {
    return {
        algorithm: {
            id: this.algorithmID,
            curve: this.options.curveParameters
        },
        pub: {
            unused: 0,
            data: rawPublicKey
        },
        pemOptions: {label: "PUBLIC KEY"}
    }
}

KeyEncoder.prototype.encodePrivate = function (privateKey, originalFormat, destinationFormat, encodingFormat = "hex") {
    let privateKeyObject;

    /* Parse the incoming private key and convert it to a private key object */
    if (originalFormat === 'raw') {
        if (!$$.Buffer.isBuffer(privateKey)) {
            throw Error('private key must be a buffer');
        }
        let privateKeyObject = this.options.curve.keyFromPrivate(privateKey, encodingFormat),
            rawPublicKey = privateKeyObject.getPublic(encodingFormat)
        privateKeyObject = this.privateKeyObject(privateKey, rawPublicKey)
    } else if (originalFormat === 'der') {
        if ($$.Buffer.isBuffer(privateKey)) {
            // do nothing
        } else if (typeof privateKey === 'string') {
            privateKey = $$.Buffer.from(privateKey, encodingFormat);
        } else {
            throw Error('private key must be a buffer or a string');
        }
        privateKeyObject = ECPrivateKeyASN.decode(privateKey, 'der')
    } else if (originalFormat === 'pem') {
        if (typeof privateKey !== 'string') {
            throw Error('private key must be a string');
        }
        privateKeyObject = ECPrivateKeyASN.decode(privateKey, 'pem', this.options.privatePEMOptions)
    } else {
        throw Error('invalid private key format');
    }

    /* Export the private key object to the desired format */
    if (destinationFormat === 'raw') {
        return privateKeyObject.privateKey;
    } else if (destinationFormat === 'der') {
        return ECPrivateKeyASN.encode(privateKeyObject, 'der').toString(encodingFormat)
    } else if (destinationFormat === 'pem') {
        return ECPrivateKeyASN.encode(privateKeyObject, 'pem', this.options.privatePEMOptions)
    } else {
        throw Error('invalid destination format for private key');
    }
}

KeyEncoder.prototype.encodePublic = function (publicKey, originalFormat, destinationFormat, encodingFormat = "hex") {
    let publicKeyObject;

    /* Parse the incoming public key and convert it to a public key object */
    if (originalFormat === 'raw') {
        if (!$$.Buffer.isBuffer(publicKey)) {
            throw Error('public key must be a buffer');
        }
        publicKeyObject = this.publicKeyObject(publicKey)
    } else if (originalFormat === 'der') {
        if ($$.Buffer.isBuffer(publicKey)) {
            // do nothing
        } else if (typeof publicKey === 'string') {
            publicKey = $$.Buffer.from(publicKey, encodingFormat)
        } else {
            throw Error('public key must be a buffer or a string');
        }
        publicKeyObject = SubjectPublicKeyInfoASN.decode(publicKey, 'der')
    } else if (originalFormat === 'pem') {
        if (!(typeof publicKey === 'string')) {
            throw Error('public key must be a string');
        }
        publicKeyObject = SubjectPublicKeyInfoASN.decode(publicKey, 'pem', this.options.publicPEMOptions)
    } else {
        throw Error('invalid public key format');
    }

    /* Export the private key object to the desired format */
    if (destinationFormat === 'raw') {
        return publicKeyObject.pub.data;
    } else if (destinationFormat === 'der') {
        return SubjectPublicKeyInfoASN.encode(publicKeyObject, 'der').toString(encodingFormat)
    } else if (destinationFormat === 'pem') {
        return SubjectPublicKeyInfoASN.encode(publicKeyObject, 'pem', this.options.publicPEMOptions)
    } else {
        throw Error('invalid destination format for public key');
    }
}

module.exports = KeyEncoder;

},{"./asn1/asn1":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/lib/asn1/asn1.js","./asn1/bignum/bn":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/lib/asn1/bignum/bn.js"}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/lib/utils/DuplexStream.js":[function(require,module,exports){
const stream = require('stream');
const util = require('util');

const Duplex = stream.Duplex;

function DuplexStream(options) {
	if (!(this instanceof DuplexStream)) {
		return new DuplexStream(options);
	}
	Duplex.call(this, options);
}
util.inherits(DuplexStream, Duplex);

DuplexStream.prototype._write = function (chunk, enc, cb) {
	this.push(chunk);
	cb();
};


DuplexStream.prototype._read = function (n) {

};

module.exports = DuplexStream;
},{"stream":false,"util":false}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/lib/utils/base58.js":[function(require,module,exports){
const ALPHABET = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
const BASE = ALPHABET.length;
const LEADER = ALPHABET.charAt(0);
const FACTOR = Math.log(BASE) / Math.log(256); // log(BASE) / log(256), rounded up
const iFACTOR = Math.log(256) / Math.log(BASE); // log(256) / log(BASE), rounded up

const BASE_MAP = $$.Buffer.alloc(256);
for (let j = 0; j < BASE_MAP.length; j++) {
    BASE_MAP[j] = 255
}
for (let i = 0; i < ALPHABET.length; i++) {
    let x = ALPHABET.charAt(i);
    let xc = x.charCodeAt(0);
    if (BASE_MAP[xc] !== 255) {
        throw new TypeError(x + ' is ambiguous');
    }
    BASE_MAP[xc] = i;
}

function encode(source) {
    if (Array.isArray(source) || source instanceof Uint8Array || typeof source === "string") {
        source = $$.Buffer.from(source);
    }
    if (!$$.Buffer.isBuffer(source)) {
        throw new TypeError('Expected $$.Buffer');
    }
    if (source.length === 0) {
        return '';
    }
    // Skip & count leading zeroes.
    let zeroes = 0;
    let length = 0;
    let pbegin = 0;
    const pend = source.length;
    while (pbegin !== pend && source[pbegin] === 0) {
        pbegin++;
        zeroes++;
    }
    // Allocate enough space in big-endian base58 representation.
    const size = ((pend - pbegin) * iFACTOR + 1) >>> 0;
    const b58 = $$.Buffer.alloc(size);
    // Process the bytes.
    while (pbegin !== pend) {
        let carry = source[pbegin];
        // Apply "b58 = b58 * 256 + ch".
        let i = 0;
        for (let it1 = size - 1; (carry !== 0 || i < length) && (it1 !== -1); it1--, i++) {
            carry += (256 * b58[it1]) >>> 0;
            b58[it1] = (carry % BASE) >>> 0;
            carry = (carry / BASE) >>> 0;
        }
        if (carry !== 0) {
            throw new Error('Non-zero carry');
        }
        length = i;
        pbegin++;
    }
    // Skip leading zeroes in base58 result.
    let it2 = size - length;
    while (it2 !== size && b58[it2] === 0) {
        it2++;
    }
    // Translate the result into a string.
    let str = LEADER.repeat(zeroes);
    for (; it2 < size; ++it2) {
        str += ALPHABET.charAt(b58[it2]);
    }
    return str;
}

function decode(source) {
    if (typeof source !== 'string') {
        throw new TypeError('Expected String');
    }
    if (source.length === 0) {
        return $$.Buffer.alloc(0);
    }
    let psz = 0;
    // Skip leading spaces.
    if (source[psz] === ' ') {
        return;
    }
    // Skip and count leading '1's.
    let zeroes = 0;
    let length = 0;
    while (source[psz] === LEADER) {
        zeroes++;
        psz++;
    }
    // Allocate enough space in big-endian base256 representation.
    const size = (((source.length - psz) * FACTOR) + 1) >>> 0; // log(58) / log(256), rounded up.
    const b256 = $$.Buffer.alloc(size);
    // Process the characters.
    while (source[psz]) {
        // Decode character
        let carry = BASE_MAP[source.charCodeAt(psz)];
        // Invalid character
        if (carry === 255) {
            return;
        }
        let i = 0;
        for (let it3 = size - 1; (carry !== 0 || i < length) && (it3 !== -1); it3--, i++) {
            carry += (BASE * b256[it3]) >>> 0;
            b256[it3] = (carry % 256) >>> 0;
            carry = (carry / 256) >>> 0;
        }
        if (carry !== 0) {
            throw new Error('Non-zero carry');
        }
        length = i;
        psz++;
    }
    // Skip trailing spaces.
    if (source[psz] === ' ') {
        return;
    }
    // Skip leading zeroes in b256.
    let it4 = size - length;
    while (it4 !== size && b256[it4] === 0) {
        it4++;
    }
    const vch = $$.Buffer.alloc(zeroes + (size - it4));
    vch.fill(0x00, 0, zeroes);
    let j = zeroes;
    while (it4 !== size) {
        vch[j++] = b256[it4++];
    }
    return vch;
}

module.exports = {
    encode,
    decode
};
},{}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/lib/utils/base64.js":[function(require,module,exports){
(function (Buffer){(function (){
const ALPHABET = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
const BASE_MAP = {};
for (let i = 0; i < ALPHABET.length; i++) {
    BASE_MAP[ALPHABET[i]] = i;
}

function encodeBase64(data) {
    if (!Buffer.isBuffer(data)) {
        data = Buffer.from(data);
    }

    return data.toString("base64");
}

function decodeBase64(data) {
    if (!Buffer.isBuffer(data)) {
        data = Buffer.from(data);
    }

    return Buffer.from(data.toString(), "base64");
}

module.exports = {
    encode: encodeBase64,
    decode: decodeBase64
}
}).call(this)}).call(this,require("buffer").Buffer)

},{"buffer":false}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/lib/utils/cryptoUtils.js":[function(require,module,exports){
const base58 = require('./base58');
const base64 = require('./base64');

const keySizes = [128, 192, 256];
const authenticationModes = ["ocb", "ccm", "gcm"];

function encode(buffer) {
    return buffer.toString('base64')
        .replace(/\+/g, '')
        .replace(/\//g, '')
        .replace(/=+$/, '');
}

function createPskHash(data, encoding) {
    const pskHash = new PskHash();
    pskHash.update(data);
    return pskHash.digest(encoding);
}

function PskHash() {
    const crypto = require('crypto');

    const sha512 = crypto.createHash('sha512');
    const sha256 = crypto.createHash('sha256');

    function update(data) {
        sha512.update(data);
    }

    function digest(encoding) {
        sha256.update(sha512.digest());
        return sha256.digest(encoding);
    }

    return {
        update, digest
    }
}


function generateSalt(inputData, saltLen) {
    const crypto = require('crypto');
    const hash = crypto.createHash('sha512');
    hash.update(inputData);
    const digest = $$.Buffer.from(hash.digest('hex'), 'binary');

    return digest.slice(0, saltLen);
}

function encryptionIsAuthenticated(algorithm) {
    for (const mode of authenticationModes) {
        if (algorithm.includes(mode)) {
            return true;
        }
    }

    return false;
}

function getKeyLength(algorithm) {
    for (const len of keySizes) {
        if (algorithm.includes(len.toString())) {
            return len / 8;
        }
    }

    throw new Error("Invalid encryption algorithm.");
}

function base58Encode(data) {
    return base58.encode(data);
}

function base58Decode(data) {
    return base58.decode(data);
}

function base64Encode(data) {
    return base64.encode(data);
}

function base64Decode(data) {
    return base64.decode(data);
}

const PEM_TYPES = ["PRIVATE KEY", "PUBLIC KEY", "CERTIFICATE"];
const isPemEncoded = (key) => {
    if (typeof key !== "string") {
        return false;
    }

    for (let i = 0; i < PEM_TYPES.length; i++) {
        if (key.includes(PEM_TYPES[i])) {
            return true;
        }
    }

    return false;
}

const convertPemToDer = (str) => {
    const SEP = "-----";
    const slicedValue = str.slice(SEP.length, str.length - SEP.length);
    const firstIndex = slicedValue.indexOf(SEP) + SEP.length;
    const lastIndex = slicedValue.lastIndexOf(SEP);
    return $$.Buffer.from(slicedValue.slice(firstIndex, lastIndex), "base64");
}

const convertDerPrivateKeyToRaw = (privateKey) => {
    const keyEncoder = require("../keyEncoder");
    const asn1PrivateKey = keyEncoder.ECPrivateKeyASN.decode(privateKey, "der");
    return asn1PrivateKey.privateKey;
};

const convertPemPrivateKeyToRaw = (privateKey) => {
    const derPrivateKey = convertPemToDer(privateKey);
    return convertDerPrivateKeyToRaw(derPrivateKey);
};

module.exports = {
    createPskHash,
    encode,
    generateSalt,
    PskHash,
    base58Encode,
    base58Decode,
    getKeyLength,
    encryptionIsAuthenticated,
    base64Encode,
    base64Decode,
    isPemEncoded,
    convertPemToDer,
    convertDerPrivateKeyToRaw,
    convertPemPrivateKeyToRaw
};


},{"../keyEncoder":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/lib/keyEncoder.js","./base58":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/lib/utils/base58.js","./base64":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/lib/utils/base64.js","crypto":false}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/lib/utils/eth.js":[function(require,module,exports){
(function (Buffer){(function (){
const keyEncoder = require("../keyEncoder");
const BN = require('../asn1/bignum/bn');
const ECKeyGenerator = require("../ECKeyGenerator");
const utils = require("../utils/cryptoUtils");

function bnToBuffer(bn) {
    return stripZeros($$.Buffer.from(padToEven(bn.toString(16)), 'hex'));
}

function padToEven(str) {
    return str.length % 2 ? '0' + str : str;
}

function padToLength(buff, len) {
    const buffer = Buffer.alloc(len);

    buffer.fill(0);
    const offset = len - buff.length;
    for (let i = 0; i < len - offset; i++) {
        buffer[i + offset] = buff[i]
    }
    return buffer;
}

function stripZeros(buffer) {
    var i = 0; // eslint-disable-line
    for (i = 0; i < buffer.length; i++) {
        if (buffer[i] !== 0) {
            break;
        }
    }
    return i > 0 ? buffer.slice(i) : buffer;
}

function decodeDERIntoASN1ETH(derSignatureBuffer) {
    const rsSig = keyEncoder.ECDSASignature.decode(derSignatureBuffer, 'der');
    let rBuffer = padToLength(bnToBuffer(rsSig.r), 32);
    let sBuffer = padToLength(bnToBuffer(rsSig.s), 32);
    //build signature
    return '0x' + $$.Buffer.concat([rBuffer, sBuffer]).toString('hex');
}

function getRSFromSignature(signature) {
    const rsSig = keyEncoder.ECDSASignature.decode(signature, 'der');
    let r = padToLength(bnToBuffer(rsSig.r), 32);
    let s = padToLength(bnToBuffer(rsSig.s), 32);
    return {r, s}
}

function convertRSSignatureToDer(rsvSignature) {
    const r = new BN(rsvSignature.slice(0, 32).toString("hex"), 16);
    const s = new BN(rsvSignature.slice(32).toString("hex"), 16);
    const derEncodedSignature = keyEncoder.ECDSASignature.encode({r, s}, "der");
    return derEncodedSignature;
}

function sign(data, privateKey) {
    const keyPairGenerator = ECKeyGenerator.createECKeyGenerator();
    const pemPrivateKey = keyPairGenerator.convertPrivateKey(privateKey);
    const pskcrypto = require("../PskCrypto");
    const signature = pskcrypto.sign("sha256", data, pemPrivateKey);
    const {r, s} = getRSFromSignature(signature);
    return $$.Buffer.concat([r, s]);
}

function verify(data, signature, publicKey) {
    if (!$$.Buffer.isBuffer(data)) {
        data = $$.Buffer.from(data);
    }

    const keyPairGenerator = ECKeyGenerator.createECKeyGenerator();
    const pskcrypto = require("../PskCrypto");

    const derSignature = convertRSSignatureToDer(signature);
    let pemPublicKey;
    if (utils.isPemEncoded(publicKey)) {
        pemPublicKey = publicKey;
    } else {
        pemPublicKey = keyPairGenerator.convertPublicKey(publicKey);
    }
    return pskcrypto.verify("sha256", data, pemPublicKey, derSignature);
}

module.exports = {
    decodeDERIntoASN1ETH,
    sign,
    verify
};

}).call(this)}).call(this,require("buffer").Buffer)

},{"../ECKeyGenerator":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/lib/ECKeyGenerator.js","../PskCrypto":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/lib/PskCrypto.js","../asn1/bignum/bn":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/lib/asn1/bignum/bn.js","../keyEncoder":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/lib/keyEncoder.js","../utils/cryptoUtils":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/lib/utils/cryptoUtils.js","buffer":false}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/lib/utils/isStream.js":[function(require,module,exports){
const stream = require('stream');


function isStream (obj) {
	return obj instanceof stream.Stream || obj instanceof stream.Duplex;
}


function isReadable (obj) {
	return isStream(obj) && typeof obj._read === 'function' && typeof obj._readableState === 'object'
}


function isWritable (obj) {
	return isStream(obj) && typeof obj._write === 'function' && typeof obj._writableState === 'object'
}


function isDuplex (obj) {
	return isReadable(obj) && isWritable(obj)
}


module.exports            = isStream;
module.exports.isReadable = isReadable;
module.exports.isWritable = isWritable;
module.exports.isDuplex   = isDuplex;
},{"stream":false}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/signsensusDS/ssutil.js":[function(require,module,exports){
/*
 SignSens helper functions
 */
exports.wipeOutsidePayload = function wipeOutsidePayload(hashStringHexa, pos, size){
    var result;
    var sz = hashStringHexa.length;

    var end = (pos + size) % sz;

    if(pos < end){
        result = '0'.repeat(pos) +  hashStringHexa.substring(pos, end) + '0'.repeat(sz - end);
    }
    else {
        result = hashStringHexa.substring(0, end) + '0'.repeat(pos - end) + hashStringHexa.substring(pos, sz);
    }
    return result;
}



exports.extractPayload = function extractPayload(hashStringHexa, pos, size){
    var result;

    var sz = hashStringHexa.length;
    var end = (pos + size) % sz;

    if( pos < end){
        result = hashStringHexa.substring(pos, pos + size);
    } else{

        if(0 != end){
            result = hashStringHexa.substring(0, end)
        }  else {
            result = "";
        }
        result += hashStringHexa.substring(pos, sz);
    }
    return result;
}



exports.fillPayload = function fillPayload(payload, pos, size){
    var sz = 64;
    var result = "";

    var end = (pos + size) % sz;

    if( pos < end){
        result = '0'.repeat(pos) + payload + '0'.repeat(sz - end);
    } else{
        result = payload.substring(0,end);
        result += '0'.repeat(pos - end);
        result += payload.substring(end);
    }
    return result;
}



exports.generatePosHashXTimes = function generatePosHashXTimes(buffer, pos, size, count){ //generate positional hash
    var result  = buffer.toString("hex");

    /*if(pos != -1 )
        result[pos] = 0; */
    const crypto = require('crypto');
    for(var i = 0; i < count; i++){
        var hash = crypto.createHash('sha256');
        result = exports.wipeOutsidePayload(result, pos, size);
        hash.update(result);
        result = hash.digest('hex');
    }
    return exports.wipeOutsidePayload(result, pos, size);
}

exports.hashStringArray = function (counter, arr, payloadSize){
    const crypto = require('crypto');
    const hash = crypto.createHash('sha256');
    var result = counter.toString(16);

    for(var i = 0 ; i < 64; i++){
        result += exports.extractPayload(arr[i],i, payloadSize);
    }

    hash.update(result);
    result = hash.digest('hex');
    return result;
}






function dumpMember(obj){
    var type = Array.isArray(obj) ? "array" : typeof obj;
    if(obj === null){
        return "null";
    }
    if(obj === undefined){
        return "undefined";
    }

    switch(type){
        case "number":
        case "string":return obj.toString();
        case "object": return exports.dumpObjectForHashing(obj);
        case "boolean": return  obj? "true": "false";
        case "array":
            var result = "";
            for(var i=0; i < obj.length; i++){
                result += exports.dumpObjectForHashing(obj[i]);
            }
            return result;
        default:
            throw new Error("Type " +  type + " cannot be cryptographically digested");
    }

}


exports.dumpObjectForHashing = function(obj){
    var result = "";

    if(obj === null){
        return "null";
    }
    if(obj === undefined){
        return "undefined";
    }

    var basicTypes = {
        "array"     : true,
        "number"    : true,
        "boolean"   : true,
        "string"    : true,
        "object"    : false
    }

    var type = Array.isArray(obj) ? "array" : typeof obj;
    if( basicTypes[type]){
        return dumpMember(obj);
    }

    var keys = Object.keys(obj);
    keys.sort();


    for(var i=0; i < keys.length; i++){
        result += dumpMember(keys[i]);
        result += dumpMember(obj[keys[i]]);
    }

    return result;
}


exports.hashValues  = function (values){
    const crypto = require('crypto');
    const hash = crypto.createHash('sha256');
    var result = exports.dumpObjectForHashing(values);
    hash.update(result);
    return hash.digest('hex');
};

exports.getJSONFromSignature = function getJSONFromSignature(signature, size){
    var result = {
        proof:[]
    };
    var a = signature.split(":");
    result.agent        = a[0];
    result.counter      =  parseInt(a[1], "hex");
    result.nextPublic   =  a[2];

    var proof = a[3]


    if(proof.length/size != 64) {
        throw new Error("Invalid signature " + proof);
    }

    for(var i = 0; i < 64; i++){
        result.proof.push(exports.fillPayload(proof.substring(i * size,(i+1) * size ), i, size))
    }

    return result;
}

exports.createSignature = function (agent,counter, nextPublic, arr, size){
    var result = "";

    for(var i = 0; i < arr.length; i++){
        result += exports.extractPayload(arr[i], i , size);
    }

    return agent + ":" + counter + ":" + nextPublic + ":" + result;
}
},{"crypto":false}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/soundpubsub/lib/soundPubSub.js":[function(require,module,exports){
/*
Initial License: (c) Axiologic Research & Alboaie Sînică.
Contributors: Axiologic Research , PrivateSky project
Code License: LGPL or MIT.
*/


/**
 *   Usually an event could cause execution of other callback events . We say that is a level 1 event if is causeed by a level 0 event and so on
 *
 *      SoundPubSub provides intuitive results regarding to asynchronous calls of callbacks and computed values/expressions:
 *   we prevent immediate execution of event callbacks to ensure the intuitive final result is guaranteed as level 0 execution
 *   we guarantee that any callback function is "re-entrant"
 *   we are also trying to reduce the number of callback execution by looking in queues at new messages published by
 *   trying to compact those messages (removing duplicate messages, modifying messages, or adding in the history of another event ,etc)
 *
 *      Example of what can be wrong without non-sound asynchronous calls:
 *
 *  Step 0: Initial state:
 *   a = 0;
 *   b = 0;
 *
 *  Step 1: Initial operations:
 *   a = 1;
 *   b = -1;
 *
 *  // an observer reacts to changes in a and b and compute CORRECT like this:
 *   if( a + b == 0) {
 *       CORRECT = false;
 *       notify(...); // act or send a notification somewhere..
 *   } else {
 *      CORRECT = false;
 *   }
 *
 *    Notice that: CORRECT will be true in the end , but meantime, after a notification was sent and CORRECT was wrongly, temporarily false!
 *    soundPubSub guarantee that this does not happen because the syncronous call will before any observer (bot asignation on a and b)
 *
 *   More:
 *   you can use blockCallBacks and releaseCallBacks in a function that change a lot a collection or bindable objects and all
 *   the notifications will be sent compacted and properly
 */

// TODO: optimisation!? use a more efficient queue instead of arrays with push and shift!?
// TODO: see how big those queues can be in real applications
// for a few hundreds items, queues made from array should be enough
//*   Potential TODOs:
//    *     prevent any form of problem by calling callbacks in the expected order !?
//*     preventing infinite loops execution cause by events!?
//*
//*
// TODO: detect infinite loops (or very deep propagation) It is possible!?

const Queue = require('queue');

function SoundPubSub(){

	let subscriberCbkRefHandler = new SubscriberCallbackReferenceHandler();

	/**
	 * publish
	 *      Publish a message {Object} to a list of subscribers on a specific topic
	 *
	 * @params {String|Number} target,  {Object} message
	 * @return number of channel subscribers that will be notified
	 */
	this.publish = function(target, message){
		if(!invalidChannelName(target) && !invalidMessageType(message) && (typeof channelSubscribers[target] != 'undefined')){
			compactAndStore(target, message);
			setTimeout(dispatchNext, 0);
			return channelSubscribers[target].length;
		} else{
			return null;
		}
	};

	/**
	 * subscribe
	 *      Subscribe / add a {Function} callBack on a {String|Number}target channel subscribers list in order to receive
	 *      messages published if the conditions defined by {Function}waitForMore and {Function}filter are passed.
	 *
	 * @params {String|Number}target, {Function}callBack, {Function}waitForMore, {Function}filter
	 *
	 *          target      - channel name to subscribe
	 *          callback    - function to be called when a message was published on the channel
	 *          waitForMore - a intermediary function that will be called after a successfuly message delivery in order
	 *                          to decide if a new messages is expected...
	 *          filter      - a function that receives the message before invocation of callback function in order to allow
	 *                          relevant message before entering in normal callback flow
	 * @return
	 */
	this.subscribe = function(target, callBack, waitForMore, filter){
		if(!invalidChannelName(target) && !invalidFunction(callBack)){
			let subscriber = {"waitForMore": waitForMore, "filter": filter};
			if(typeof channelSubscribers[target] === 'undefined'){
				channelSubscribers[target] = [];
			}
			subscriberCbkRefHandler.setSubscriberCallback(subscriber, target, callBack);
			channelSubscribers[target].push(subscriber);
		}
	};

	/**
	 * unsubscribe
	 *      Unsubscribe/remove {Function} callBack from the list of subscribers of the {String|Number} target channel
	 *
	 * @params {String|Number} target, {Function} callBack, {Function} filter
	 *
	 *          target      - channel name to unsubscribe
	 *          callback    - reference of the original function that was used as subscribe
	 *          filter      - reference of the original filter function
	 * @return
	 */
	this.unsubscribe = function(target, callBack, filter){
		if(!invalidFunction(callBack)){
			//let gotIt = false;
			if(channelSubscribers[target]){
				for(let i = 0; i < channelSubscribers[target].length;i++){
					let subscriber =  channelSubscribers[target][i];
					let callback = subscriberCbkRefHandler.getSubscriberCallback(subscriber);

					if(callback === callBack && ( typeof filter === 'undefined' || subscriber.filter === filter )){
						//gotIt = true;
						subscriber.forDelete = true;
						subscriber.callBack = undefined;
						subscriber.filter = undefined;
					}
				}
			}
			//not valid always since we introduced WeakRef. A subscriber callback could not exists
			// if(!gotIt){
			// 	console.log("Unable to unsubscribe a callback that was not subscribed!");
			// }
		}
	};

	/**
	 * blockCallBacks
	 *
	 * @params
	 * @return
	 */
	this.blockCallBacks = function(){
		level++;
	};

	/**
	 * releaseCallBacks
	 *
	 * @params
	 * @return
	 */
	this.releaseCallBacks = function(){
		level--;
		//hack/optimisation to not fill the stack in extreme cases (many events caused by loops in collections,etc)
		while(level === 0 && dispatchNext(true)){
			//nothing
		}

		while(level === 0 && callAfterAllEvents()){
            //nothing
		}
	};

	/**
	 * afterAllEvents
	 *
	 * @params {Function} callback
	 *
	 *          callback - function that needs to be invoked once all events are delivered
	 * @return
	 */
	this.afterAllEvents = function(callBack){
		if(!invalidFunction(callBack)){
			afterEventsCalls.push(callBack);
		}
		this.blockCallBacks();
		this.releaseCallBacks();
	};

	/**
	 * hasChannel
	 *
	 * @params {String|Number} channel
	 *
	 *          channel - name of the channel that need to be tested if present
	 * @return
	 */
	this.hasChannel = function(channel){
		return !invalidChannelName(channel) && (typeof channelSubscribers[channel] != 'undefined') ? true : false;
	};

	/**
	 * addChannel
	 *
	 * @params {String} channel
	 *
	 *          channel - name of a channel that needs to be created and added to soundpubsub repository
	 * @return
	 */
	this.addChannel = function(channel){
		if(!invalidChannelName(channel) && !this.hasChannel(channel)){
			channelSubscribers[channel] = [];
		}
	};

	/* ---------------------------------------- protected stuff ---------------------------------------- */
	var self = this;
	// map channelName (object local id) -> array with subscribers
	var channelSubscribers = {};

	// map channelName (object local id) -> queue with waiting messages
	var channelsStorage = {};

	// object
	var typeCompactor = {};

	// channel names
	var executionQueue = new Queue();
	var level = 0;



	/**
	 * registerCompactor
	 *
	 *       An compactor takes a newEvent and and oldEvent and return the one that survives (oldEvent if
	 *  it can compact the new one or the newEvent if can't be compacted)
	 *
	 * @params {String} type, {Function} callBack
	 *
	 *          type        - channel name to unsubscribe
	 *          callBack    - handler function for that specific event type
	 * @return
	 */
	this.registerCompactor = function(type, callBack) {
		if(!invalidFunction(callBack)){
			typeCompactor[type] = callBack;
		}
	};

	/**
	 * dispatchNext
	 *
	 * @param fromReleaseCallBacks: hack to prevent too many recursive calls on releaseCallBacks
	 * @return {Boolean}
	 */
	function dispatchNext(fromReleaseCallBacks){
		if(level > 0) {
			return false;
		}
		const channelName = executionQueue.front();
		if(typeof channelName != 'undefined'){
			self.blockCallBacks();
			try{
				let message;
				if(!channelsStorage[channelName].isEmpty()) {
					message = channelsStorage[channelName].front();
				}
				if(typeof message == 'undefined'){
					if(!channelsStorage[channelName].isEmpty()){
						console.log("Can't use as message in a pub/sub channel this object: " + message);
					}
					executionQueue.pop();
				} else {
					if(typeof message.__transmisionIndex == 'undefined'){
						message.__transmisionIndex = 0;
						for(var i = channelSubscribers[channelName].length-1; i >= 0 ; i--){
							var subscriber =  channelSubscribers[channelName][i];
							if(subscriber.forDelete === true){
								channelSubscribers[channelName].splice(i,1);
							}
						}
					} else{
						message.__transmisionIndex++;
					}
					//TODO: for immutable objects it will not work also, fix for shape models
					if(typeof message.__transmisionIndex == 'undefined'){
						console.log("Can't use as message in a pub/sub channel this object: " + message);
					}
					subscriber = channelSubscribers[channelName][message.__transmisionIndex];
					if(typeof subscriber == 'undefined'){
						delete message.__transmisionIndex;
						channelsStorage[channelName].pop();
					} else{
						if(subscriber.filter === null || typeof subscriber.filter === "undefined" || (!invalidFunction(subscriber.filter) && subscriber.filter(message))){
							if (!subscriber.forDelete) {
								let callback = subscriberCbkRefHandler.getSubscriberCallback(subscriber);
								if (typeof callback === "undefined") {
									subscriber.forDelete = true;
								} else {
									callback(message);
									if (subscriber.waitForMore && !invalidFunction(subscriber.waitForMore) && !subscriber.waitForMore(message)) {
										subscriber.forDelete = true;
									}
								}
							}
						}
					}
				}
			} catch(err){
				console.log("Event callback failed: "+ subscriber.callBack +"error: " + err.stack);
			}
			//
			if(fromReleaseCallBacks){
				level--;
			} else{
				self.releaseCallBacks();
			}
			return true;
		} else{
			return false;
		}
	}

	function compactAndStore(target, message){
		var gotCompacted = false;
		var arr = channelsStorage[target];
		if(typeof arr == 'undefined'){
			arr = new Queue();
			channelsStorage[target] = arr;
		}

		if(message && typeof message.type != 'undefined'){
			var typeCompactorCallBack = typeCompactor[message.type];

			if(typeof typeCompactorCallBack != 'undefined'){
				for(let channel of arr) {
					if(typeCompactorCallBack(message, channel) === channel) {
						if(typeof channel.__transmisionIndex == 'undefined') {
							gotCompacted = true;
							break;
						}
					}
				}
			}
		}

		if(!gotCompacted && message){
			arr.push(message);
			executionQueue.push(target);
		}
	}

	var afterEventsCalls = new Queue();
	function callAfterAllEvents (){
		if(!afterEventsCalls.isEmpty()){
			var callBack = afterEventsCalls.pop();
			//do not catch exceptions here..
			callBack();
		}
		return !afterEventsCalls.isEmpty();
	}

	function invalidChannelName(name){
		var result = false;
		if(!name || (typeof name != "string" && typeof name != "number")){
			result = true;
			console.log("Invalid channel name: " + name);
		}

		return result;
	}

	function invalidMessageType(message){
		var result = false;
		if(!message || typeof message != "object"){
			result = true;
			console.log("Invalid messages types: " + message);
		}
		return result;
	}

	function invalidFunction(callback){
		var result = false;
		if(!callback || typeof callback != "function"){
			result = true;
			console.log("Expected to be function but is: " + callback);
		}
		return result;
	}

	//weak references are not supported by all browsers
	function SubscriberCallbackReferenceHandler(){
		let finalizationRegistry;
		let hasWeakReferenceSupport = weakReferencesAreSupported();


		if (hasWeakReferenceSupport) {
			finalizationRegistry = new FinalizationRegistry((heldValue) => {
		   		//console.log(`Cleanup ${heldValue}`);
			});
		}

		this.setSubscriberCallback  = function (subscriber, target, callback){
			if(hasWeakReferenceSupport){
				subscriber.callBack = new WeakRef(callback);
				finalizationRegistry.register(subscriber.callBack, target);
			}
			else{
				subscriber.callBack = callback;
			}
		}

		this.getSubscriberCallback = function (subscriber){
			if(hasWeakReferenceSupport){
				if(subscriber.callBack){
					return subscriber.callBack.deref();
				}
				return undefined;

			}
			return subscriber.callBack;
		}

		function weakReferencesAreSupported() {
			return typeof FinalizationRegistry === "function" && typeof WeakRef === "function";
		}
	}


}

exports.soundPubSub = new SoundPubSub();

},{"queue":"queue"}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/swarmutils/lib/Combos.js":[function(require,module,exports){
function product(args) {
    if(!args.length){
        return [ [] ];
    }
    var prod = product(args.slice(1)), r = [];
    args[0].forEach(function(x) {
        prod.forEach(function(p) {
            r.push([ x ].concat(p));
        });
    });
    return r;
}

function objectProduct(obj) {
    var keys = Object.keys(obj),
        values = keys.map(function(x) { return obj[x]; });

    return product(values).map(function(p) {
        var e = {};
        keys.forEach(function(k, n) { e[k] = p[n]; });
        return e;
    });
}

module.exports = objectProduct;
},{}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/swarmutils/lib/OwM.js":[function(require,module,exports){
var meta = "meta";

function OwM(serialized){

    if(serialized){
        return OwM.prototype.convert(serialized);
    }

    Object.defineProperty(this, meta, {
        writable: false,
        enumerable: true,
        value: {}
    });

    Object.defineProperty(this, "setMeta", {
        writable: false,
        enumerable: false,
        configurable:false,
        value: function(prop, value){
            if(typeof prop == "object" && typeof value == "undefined"){
                for(var p in prop){
                    this[meta][p] = prop[p];
                }
                return prop;
            }
            this[meta][prop] = value;
            return value;
        }
    });

    Object.defineProperty(this, "getMeta", {
        writable: false,
        value: function(prop){
            return this[meta][prop];
        }
    });
}

function testOwMSerialization(obj){
    let res = false;

    if(obj){
        res = typeof obj[meta] != "undefined" && !(obj instanceof OwM);
    }

    return res;
}

OwM.prototype.convert = function(serialized){
    const owm = new OwM();

    for(var metaProp in serialized.meta){
        if(!testOwMSerialization(serialized[metaProp])) {
            owm.setMeta(metaProp, serialized.meta[metaProp]);
        }else{
            owm.setMeta(metaProp, OwM.prototype.convert(serialized.meta[metaProp]));
        }
    }

    for(var simpleProp in serialized){
        if(simpleProp === meta) {
            continue;
        }

        if(!testOwMSerialization(serialized[simpleProp])){
            owm[simpleProp] = serialized[simpleProp];
        }else{
            owm[simpleProp] = OwM.prototype.convert(serialized[simpleProp]);
        }
    }

    return owm;
};

OwM.prototype.getMetaFrom = function(obj, name){
    var res;
    if(!name){
        res = obj[meta];
    }else{
        res = obj[meta][name];
    }
    return res;
};

OwM.prototype.setMetaFor = function(obj, name, value){
    obj[meta][name] = value;
    return obj[meta][name];
};

module.exports = OwM;
},{}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/swarmutils/lib/Queue.js":[function(require,module,exports){
function QueueElement(content) {
	this.content = content;
	this.next = null;
}

function Queue() {
	this.head = null;
	this.tail = null;
	this.length = 0;
	this.push = function (value) {
		const newElement = new QueueElement(value);
		if (!this.head) {
			this.head = newElement;
			this.tail = newElement;
		} else {
			this.tail.next = newElement;
			this.tail = newElement;
		}
		this.length++;
	};

	this.pop = function () {
		if (!this.head) {
			return null;
		}
		const headCopy = this.head;
		this.head = this.head.next;
		this.length--;

		//fix???????
		if(this.length === 0){
            this.tail = null;
		}

		return headCopy.content;
	};

	this.front = function () {
		return this.head ? this.head.content : undefined;
	};

	this.isEmpty = function () {
		return this.head === null;
	};

    this.remove = function (el) {
        if (this.length === 1 && el === this.front()) {
            this.head = this.tail = null;
            this.length--;
            return;
        }

        if (el === this.front()) {
            this.pop();
            return;
        }

        let head = this.head;
        let prev = null;
        while (head !== null) {
            if (head.content !== el) {
                prev = head;
                head = head.next;
                continue;
            }

            prev.next = head.next;
            this.length--;

            if (head === this.tail) {
                this.tail = prev;
            }
            return;
        }

    }

	this[Symbol.iterator] = function* () {
		let head = this.head;
		while(head !== null) {
			yield head.content;
			head = head.next;
		}
	}.bind(this);
}

Queue.prototype.toString = function () {
	let stringifiedQueue = '';
	let iterator = this.head;
	while (iterator) {
		stringifiedQueue += `${JSON.stringify(iterator.content)} `;
		iterator = iterator.next;
	}
	return stringifiedQueue;
};

Queue.prototype.inspect = Queue.prototype.toString;

module.exports = Queue;

},{}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/swarmutils/lib/SwarmPacker.js":[function(require,module,exports){
const HEADER_SIZE_RESEARVED = 4;

function SwarmPacker(){
}

function copyStringtoArrayBuffer(str, buffer){
    if(typeof str !== "string"){
        throw new Error("Wrong param type received");
    }
    for(var i = 0; i < str.length; i++) {
        buffer[i] = str.charCodeAt(i);
    }
    return buffer;
}

function copyFromBuffer(target, source){
    for(let i=0; i<source.length; i++){
        target[i] = source[i];
    }
    return target;
}

let serializers = {};

SwarmPacker.registerSerializer = function(name, implementation){
    if(serializers[name]){
        throw new Error("Serializer name already exists");
    }
    serializers[name] = implementation;
};

function getSerializer(name){
    return serializers[name];
}

SwarmPacker.getSerializer = getSerializer;

Object.defineProperty(SwarmPacker.prototype, "JSON", {value: "json"});
Object.defineProperty(SwarmPacker.prototype, "MSGPACK", {value: "msgpack"});

SwarmPacker.registerSerializer(SwarmPacker.prototype.JSON, {
    serialize: JSON.stringify,
    deserialize: (serialization)=>{
        if(typeof serialization !== "string"){
            serialization = String.fromCharCode.apply(null, serialization);
        }
        return JSON.parse(serialization);
    },
    getType: ()=>{
        return SwarmPacker.prototype.JSON;
    }
});

function registerMsgPackSerializer(){
    const mp = '@msgpack/msgpack';
    let msgpack;

    try{
        msgpack = require(mp);
        if (typeof msgpack === "undefined") {
            throw new Error("msgpack is unavailable.")
        }
    }catch(err){
        console.log("msgpack not available. If you need msgpack serialization include msgpack in one of your bundles");
        //preventing msgPack serializer being register if msgPack dep is not found.
        return;
    }

    SwarmPacker.registerSerializer(SwarmPacker.prototype.MSGPACK, {
        serialize: msgpack.encode,
        deserialize: msgpack.decode,
        getType: ()=>{
            return SwarmPacker.prototype.MSGPACK;
        }
    });
}

registerMsgPackSerializer();

SwarmPacker.pack = function(swarm, serializer){

    let jsonSerializer = getSerializer(SwarmPacker.prototype.JSON);
    if(typeof serializer === "undefined"){
        serializer = jsonSerializer;
    }

    let swarmSerialization = serializer.serialize(swarm);

    let header = {
        command: swarm.getMeta("command"),
        swarmId : swarm.getMeta("swarmId"),
        swarmTypeName: swarm.getMeta("swarmTypeName"),
        swarmTarget: swarm.getMeta("target"),
        serializationType: serializer.getType()
    };

    header = serializer.serialize(header);

    if(header.length >= Math.pow(2, 32)){
        throw new Error("Swarm serialization too big.");
    }

    //arraybuffer construction
    let size = HEADER_SIZE_RESEARVED + header.length + swarmSerialization.length;
    let pack = new ArrayBuffer(size);

    let sizeHeaderView = new DataView(pack, 0);
    sizeHeaderView.setUint32(0, header.length);

    let headerView = new Uint8Array(pack, HEADER_SIZE_RESEARVED);
    copyStringtoArrayBuffer(header, headerView);

    let serializationView = new Uint8Array(pack, HEADER_SIZE_RESEARVED+header.length);
    if(typeof swarmSerialization === "string"){
        copyStringtoArrayBuffer(swarmSerialization, serializationView);
    }else{
        copyFromBuffer(serializationView, swarmSerialization);
    }

    return pack;
};

SwarmPacker.unpack = function(pack){
    let jsonSerialiser = SwarmPacker.getSerializer(SwarmPacker.prototype.JSON);
    let headerSerialization = getHeaderSerializationFromPack(pack);
    let header = jsonSerialiser.deserialize(headerSerialization);

    let serializer = SwarmPacker.getSerializer(header.serializationType);
    let messageView = new Uint8Array(pack, HEADER_SIZE_RESEARVED+headerSerialization.length);

    let swarm = serializer.deserialize(messageView);
    return swarm;
};

function getHeaderSerializationFromPack(pack){
    let headerSize = new DataView(pack).getUint32(0);

    let headerView = new Uint8Array(pack, HEADER_SIZE_RESEARVED, headerSize);
    return headerView;
}

SwarmPacker.getHeader = function(pack){
    let jsonSerialiser = SwarmPacker.getSerializer(SwarmPacker.prototype.JSON);
    let header = jsonSerialiser.deserialize(getHeaderSerializationFromPack(pack));

    return header;
};
module.exports = SwarmPacker;
},{}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/swarmutils/lib/TaskCounter.js":[function(require,module,exports){

function TaskCounter(finalCallback) {
	let results = [];
	let errors = [];

	let started = 0;

	function decrement(err, res) {
		if(err) {
			errors.push(err);
		}

		if(arguments.length > 2) {
			arguments[0] = undefined;
			res = arguments;
		}

		if(typeof res !== "undefined") {
			results.push(res);
		}

		if(--started <= 0) {
            return callCallback();
		}
	}

	function increment(amount = 1) {
		started += amount;
	}

	function callCallback() {
		if(errors && errors.length === 0) {
			errors = undefined;
		}

		if(results && results.length === 0) {
			results = undefined;
		}

		finalCallback(errors, results);
    }

	return {
		increment,
		decrement
	};
}

module.exports = TaskCounter;
},{}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/swarmutils/lib/beesHealer.js":[function(require,module,exports){
const OwM = require("./OwM");

/*
    Prepare the state of a swarm to be serialised
*/

exports.asJSON = function(valueObj, phaseName, args, callback){

        let valueObject = valueObj.valueOf();
        let res = new OwM();
        res.publicVars          = valueObject.publicVars;
        res.privateVars         = valueObject.privateVars;

        res.setMeta("COMMAND_ARGS",        OwM.prototype.getMetaFrom(valueObject, "COMMAND_ARGS"));
        res.setMeta("SecurityParadigm",        OwM.prototype.getMetaFrom(valueObject, "SecurityParadigm"));
        res.setMeta("swarmTypeName", OwM.prototype.getMetaFrom(valueObject, "swarmTypeName"));
        res.setMeta("swarmId",       OwM.prototype.getMetaFrom(valueObject, "swarmId"));
        res.setMeta("target",        OwM.prototype.getMetaFrom(valueObject, "target"));
        res.setMeta("homeSecurityContext",        OwM.prototype.getMetaFrom(valueObject, "homeSecurityContext"));
        res.setMeta("requestId",        OwM.prototype.getMetaFrom(valueObject, "requestId"));


        if(!phaseName){
            res.setMeta("command", "stored");
        } else {
            res.setMeta("phaseName", phaseName);
            res.setMeta("phaseId", $$.uidGenerator.safe_uuid());
            res.setMeta("args", args);
            res.setMeta("command", OwM.prototype.getMetaFrom(valueObject, "command") || "executeSwarmPhase");
        }

        res.setMeta("waitStack", valueObject.meta.waitStack); //TODO: think if is not better to be deep cloned and not referenced!!!

        if(callback){
            return callback(null, res);
        }
        //console.log("asJSON:", res, valueObject);
        return res;
};

exports.jsonToNative = function(serialisedValues, result){

    for(let v in serialisedValues.publicVars){
        result.publicVars[v] = serialisedValues.publicVars[v];

    }
    for(let l in serialisedValues.privateVars){
        result.privateVars[l] = serialisedValues.privateVars[l];
    }

    for(let i in OwM.prototype.getMetaFrom(serialisedValues)){
        OwM.prototype.setMetaFor(result, i, OwM.prototype.getMetaFrom(serialisedValues, i));
    }

};
},{"./OwM":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/swarmutils/lib/OwM.js"}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/swarmutils/lib/path.js":[function(require,module,exports){
function replaceAll(str, search, replacement) {
    return str.split(search).join(replacement);
}

function resolvePath(pth) {
    let pathSegments = pth.split("/");
    let makeAbsolute = pathSegments[0] === "" ? true : false;
    for (let i = 0; i < pathSegments.length; i++) {
        let segment = pathSegments[i];
        if (segment === "..") {
            let j = 1;
            if (i > 0) {
                j = j + 1;
            }
            // else {
            //     makeAbsolute = true;
            // }
            pathSegments.splice(i + 1 - j, j);
            i = i - j;
        }
    }
    let res = pathSegments.join("/");
    if (makeAbsolute && res !== "") {
        res = __ensureIsAbsolute(res);
    }
    return res;
}

function normalize(pth) {
    if (typeof pth !== "string") {
        throw new TypeError();
    }
    pth = replaceAll(pth, "\\", "/");
    pth = replaceAll(pth, /[/]+/, "/");

    return resolvePath(pth);
}

function join(...args) {
    let pth = "";
    for (let i = 0; i < args.length; i++) {
        if (i !== 0 && args[i - 1] !== "") {
            pth += "/";
        }

        pth += args[i];
    }

    return normalize(pth);
}

function __ensureIsAbsolute(pth) {
    if (pth[0] !== "/") {
        pth = "/" + pth;
    }
    return pth;
}

function isAbsolute(pth) {
    pth = normalize(pth);
    //on windows ":" is used as separator after partition ID
    if (pth[0] !== "/" && pth[1] !== ":") {
        return false;
    }

    return true;
}

function ensureIsAbsolute(pth) {
    pth = normalize(pth);
    return __ensureIsAbsolute(pth);
}

function isSubpath(path, subPath) {
    path = normalize(path);
    subPath = normalize(subPath);
    let result = false;
    if (path.indexOf(subPath) === 0) {
        let char = path[subPath.length];
        if (char === "" || char === "/" || subPath === "/") {
            result = true;
        }
    }

    return result;
}

function dirname(path) {
    if (path === "/") {
        return path;
    }
    const pathSegments = path.split("/");
    pathSegments.pop();
    return ensureIsAbsolute(pathSegments.join("/"));
}

function basename(path) {
    if (path === "/") {
        return path;
    }
    return path.split("/").pop;
}

function relative(from, to) {
    from = normalize(from);
    to = normalize(to);

    const fromSegments = from.split("/");
    const toSegments = to.split("/");
    let splitIndex;
    for (let i = 0; i < fromSegments.length; i++) {
        if (fromSegments[i] !== toSegments[i]) {
            break;
        }
        splitIndex = i;
    }

    if (typeof splitIndex === "undefined") {
        throw Error(`The paths <${from}> and <${to}> have nothing in common`);
    }

    splitIndex++;
    let relativePath = [];
    for (let i = splitIndex; i < fromSegments.length; i++) {
        relativePath.push("..");
    }
    for (let i = splitIndex; i < toSegments.length; i++) {
        relativePath.push(toSegments[i]);
    }

    return relativePath.join("/");
}

function resolve(...pathArr) {
    function __resolvePathRecursively(currentPath) {
        let lastSegment = pathArr.pop();
        if (typeof currentPath === "undefined") {
            currentPath = lastSegment;
        } else {
            currentPath = join(lastSegment, currentPath);
        }
        if (isAbsolute(currentPath)) {
            return currentPath;
        }

        if (pathArr.length === 0) {
            let cwd;
            try {
                cwd = process.cwd();
            } catch (e) {
                cwd = "/";
            }

            return join(cwd, currentPath);
        }

        return __resolvePathRecursively(currentPath);
    }

    return __resolvePathRecursively();
}

function extname(path){
    path = resolvePath(path);
    let ext = path.match(/\.[0-9a-z]+$/i);
    if (Array.isArray(ext)) {
        ext = ext[0];
    } else {
        ext = "";
    }
    return ext;
}

module.exports = {
    normalize,
    join,
    isAbsolute,
    ensureIsAbsolute,
    isSubpath,
    dirname,
    basename,
    relative,
    resolve,
    extname
};

},{}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/swarmutils/lib/pingpongFork.js":[function(require,module,exports){
const PING = "PING";
const PONG = "PONG";

module.exports.fork = function pingPongFork(modulePath, args, options){
    const child_process = require("child_process");
    const defaultStdio = ["inherit", "inherit", "inherit", "ipc"];

    if(!options){
        options = {stdio: defaultStdio};
    }else{
        if(typeof options.stdio === "undefined"){
            options.stdio = defaultStdio;
        }

        let stdio = options.stdio;
        if(stdio.length<3){
            for(let i=stdio.length; i<4; i++){
                stdio.push("inherit");
            }
            stdio.push("ipc");
        }
    }

    let child = child_process.fork(modulePath, args, options);

    child.on("message", (message)=>{
        if(message === PING){
            child.send(PONG);
        }
    });

    return child;
};

module.exports.enableLifeLine = function(timeout){

    if(typeof process.send === "undefined"){
        console.log("\"process.send\" not found. LifeLine mechanism disabled!");
        return;
    }

    let lastConfirmationTime;
    const interval = timeout || 2000;

    // this is needed because new Date().getTime() has reduced precision to mitigate timer based attacks
    // for more information see: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/getTime
    const roundingError = 101;

    function sendPing(){
        try {
            process.send(PING);
        } catch (e) {
            console.log('Parent is not available, shutting down');
            exit(1)
        }
    }

    process.on("message", function (message){
        if(message === PONG){
            lastConfirmationTime = new Date().getTime();
        }
    });

    function exit(code){
        setTimeout(()=>{
            process.exit(code);
        }, 0);
    }

    const exceptionEvents = ["SIGINT", "SIGUSR1", "SIGUSR2", "uncaughtException", "SIGTERM", "SIGHUP"];
    let killingSignal = false;
    for(let i=0; i<exceptionEvents.length; i++){
        process.on(exceptionEvents[i], (event, code)=>{
            killingSignal = true;
            clearInterval(timeoutInterval);
            console.log(`Caught event type [${exceptionEvents[i]}]. Shutting down...`, code, event);
            exit(code);
        });
    }

    const timeoutInterval = setInterval(function(){
        const currentTime = new Date().getTime();

        if(typeof lastConfirmationTime === "undefined" || currentTime - lastConfirmationTime < interval + roundingError && !killingSignal){
            sendPing();
        }else{
            console.log("Parent process did not answer. Shutting down...", process.argv, killingSignal);
            exit(1);
        }
    }, interval);
};
},{"child_process":false}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/swarmutils/lib/pskconsole.js":[function(require,module,exports){
var commands = {};
var commands_help = {};

//global function addCommand
addCommand = function addCommand(verb, adverbe, funct, helpLine){
    var cmdId;
    if(!helpLine){
        helpLine = " ";
    } else {
        helpLine = " " + helpLine;
    }
    if(adverbe){
        cmdId = verb + " " +  adverbe;
        helpLine = verb + " " +  adverbe + helpLine;
    } else {
        cmdId = verb;
        helpLine = verb + helpLine;
    }
    commands[cmdId] = funct;
        commands_help[cmdId] = helpLine;
};

function doHelp(){
    console.log("List of commands:");
    for(var l in commands_help){
        console.log("\t", commands_help[l]);
    }
}

addCommand("-h", null, doHelp, "\t\t\t\t\t\t |just print the help");
addCommand("/?", null, doHelp, "\t\t\t\t\t\t |just print the help");
addCommand("help", null, doHelp, "\t\t\t\t\t\t |just print the help");


function runCommand(){
  var argv = Object.assign([], process.argv);
  var cmdId = null;
  var cmd = null;
  argv.shift();
  argv.shift();

  if(argv.length >=1){
      cmdId = argv[0];
      cmd = commands[cmdId];
      argv.shift();
  }


  if(!cmd && argv.length >=1){
      cmdId = cmdId + " " + argv[0];
      cmd = commands[cmdId];
      argv.shift();
  }

  if(!cmd){
    if(cmdId){
        console.log("Unknown command: ", cmdId);
    }
    cmd = doHelp;
  }

  cmd.apply(null,argv);

}

module.exports = {
    runCommand
};


},{}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/swarmutils/lib/removeDir.js":[function(require,module,exports){
const removeDir = (...args) => {
    const fs = require("fs");
    if (typeof fs.rm !== "function") {
        return fs.rmdir(...args);
    }
    return fs.rm(...args);
}

const removeDirSync = (...args) => {
    const fs = require("fs");
    if (typeof fs.rmSync !== "function") {
        return fs.rmdirSync(...args);
    }
    return fs.rmSync(...args);
}

module.exports = {
    removeDirSync,
    removeDir
}
},{"fs":false}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/swarmutils/lib/safe-uuid.js":[function(require,module,exports){

function encode(buffer) {
    return buffer.toString('base64')
        .replace(/\+/g, '')
        .replace(/\//g, '')
        .replace(/=+$/, '');
}

function stampWithTime(buf, salt, msalt){
    if(!salt){
        salt = 1;
    }
    if(!msalt){
        msalt = 1;
    }
    var date = new Date;
    var ct = Math.floor(date.getTime() / salt);
    var counter = 0;
    while(ct > 0 ){
        //console.log("Counter", counter, ct);
        buf[counter*msalt] = Math.floor(ct % 256);
        ct = Math.floor(ct / 256);
        counter++;
    }
}

/*
    The uid contains around 256 bits of randomness and are unique at the level of seconds. This UUID should by cryptographically safe (can not be guessed)

    We generate a safe UID that is guaranteed unique (by usage of a PRNG to geneate 256 bits) and time stamping with the number of seconds at the moment when is generated
    This method should be safe to use at the level of very large distributed systems.
    The UUID is stamped with time (seconds): does it open a way to guess the UUID? It depends how safe is "crypto" PRNG, but it should be no problem...

 */

var generateUid = null;

exports.init = function(externalGenerator){
    generateUid = externalGenerator.generateUid;
    return module.exports;
};

exports.safe_uuid = function() {
    var buf = generateUid(32);
    stampWithTime(buf, 1000, 3);
    return encode(buf);
};



/*
    Try to generate a small UID that is unique against chance in the same millisecond second and in a specific context (eg in the same choreography execution)
    The id contains around 6*8 = 48  bits of randomness and are unique at the level of milliseconds
    This method is safe on a single computer but should be used with care otherwise
    This UUID is not cryptographically safe (can be guessed)
 */
exports.short_uuid = function(callback) {
    require('crypto').randomBytes(12, function (err, buf) {
        if (err) {
            callback(err);
            return;
        }
        stampWithTime(buf,1,2);
        callback(null, encode(buf));
    });
};
},{"crypto":false}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/swarmutils/lib/uidGenerator.js":[function(require,module,exports){
function UidGenerator(minBuffers, buffersSize) {
    const Queue = require("./Queue");
    var PSKBuffer = typeof $$ !== "undefined" && $$.PSKBuffer ? $$.PSKBuffer : $$.Buffer;

    var buffers = new Queue();
    var lowLimit = .2;

    function fillBuffers(size) {
        //notifyObserver();
        const sz = size || minBuffers;
        if (buffers.length < Math.floor(minBuffers * lowLimit)) {
            for (var i = buffers.length; i < sz; i++) {
                generateOneBuffer(null);
            }
        }
    }

    fillBuffers();

    function generateOneBuffer(b) {
        if (!b) {
            b = PSKBuffer.alloc(0);
        }
        const sz = buffersSize - b.length;
        /*crypto.randomBytes(sz, function (err, res) {
            buffers.push($$.Buffer.concat([res, b]));
            notifyObserver();
        });*/
        buffers.push(PSKBuffer.concat([require('crypto').randomBytes(sz), b]));
        notifyObserver();
    }

    function extractN(n) {
        var sz = Math.floor(n / buffersSize);
        var ret = [];

        for (var i = 0; i < sz; i++) {
            ret.push(buffers.pop());
            setTimeout(generateOneBuffer, 1);
        }


        var remainder = n % buffersSize;
        if (remainder > 0) {
            var front = buffers.pop();
            ret.push(front.slice(0, remainder));
            //generateOneBuffer(front.slice(remainder));
            setTimeout(function () {
                generateOneBuffer(front.slice(remainder));
            }, 1);
        }

        //setTimeout(fillBuffers, 1);

        return $$.Buffer.concat(ret);
    }

    var fillInProgress = false;

    this.generateUid = function (n) {
        var totalSize = buffers.length * buffersSize;
        if (n <= totalSize) {
            return extractN(n);
        } else {
            if (!fillInProgress) {
                fillInProgress = true;
                setTimeout(function () {
                    fillBuffers(Math.floor(minBuffers * 2.5));
                    fillInProgress = false;
                }, 1);
            }
            return require('crypto').randomBytes(n);
        }
    };

    var observer;
    this.registerObserver = function (obs) {
        if (observer) {
            console.error(new Error("One observer allowed!"));
        } else {
            if (typeof obs == "function") {
                observer = obs;
                //notifyObserver();
            }
        }
    };

    function notifyObserver() {
        if (observer) {
            var valueToReport = buffers.length * buffersSize;
            setTimeout(function () {
                observer(null, {"size": valueToReport});
            }, 10);
        }
    }
}

module.exports.createUidGenerator = function (minBuffers, bufferSize) {
    return new UidGenerator(minBuffers, bufferSize);
};

},{"./Queue":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/swarmutils/lib/Queue.js","crypto":false}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/syndicate/lib/AbstractPool.js":[function(require,module,exports){
(function (setImmediate){(function (){
const {assert} = require('./utils');
const util = require('util');
const {EventEmitter} = require('events');

const PoolEvents = {
    RELEASED_WORKER: 'releasedWorker'
};

/** @param {PoolConfig&PoolConfigStorage} options */
function AbstractPool(options) {
    EventEmitter.call(this);

    let pool = [];
    let currentPoolSize = 0;

    /** @returns {Worker|null} */
    this.getAvailableWorker = function () {
        // find first free worker
        const freeWorkerIndex = pool.findIndex(el => !el.isWorking);

        let worker = null;

        // if no free worker is available, try creating one
        if (freeWorkerIndex === -1) {
            _createNewWorker();
            return null;
        } else {
            worker = pool[freeWorkerIndex];
        }

        if (worker === null) {
            return null;
        }

        // if free worker exists, set its state to working
        worker.isWorking = true;
        return worker.workerInstance;
    };

    /** @param {Worker} worker */
    this.returnWorker = function (worker) {
        // find worker that matches one in the pool
        const freeWorkerIndex = pool.findIndex(el => el.workerInstance === worker);

        if (freeWorkerIndex === -1) {
            console.error('Tried to return a worker that is not owned by the pool');
            return;
        }

        // if worker is found, set its state to not working
        pool[freeWorkerIndex].isWorking = false;
        this.emit(PoolEvents.RELEASED_WORKER);
    };

    /** @param {Worker} worker */
    this.removeWorker = function (worker) {
        const localPoolSize = pool.length;

        pool = pool.filter(poolWorker => poolWorker.workerInstance !== worker); // keep elements that are not equal to worker
        currentPoolSize = pool.length;

        assert(currentPoolSize === localPoolSize - 1, {ifFails: `Tried returning a worker that could not be found`});
    };

    this.createNewWorker = function () {
        throw new Error('Not implemented! Overwrite this in subclass.');
    };

    const _createNewWorker = () => {
        // using currentPoolSize instead of pool.length because the creation of workers can be asynchronous
        // and the pool will increase only after the worker is creating, this can cause a situation where
        // more workers are created than the maximumNumberOfWorkers
        if (currentPoolSize >= options.maximumNumberOfWorkers) {
            return;
        }

        currentPoolSize += 1;

        this.createNewWorker((err, newWorker) => {
            if (err) {
                currentPoolSize -= 1;
                console.error('Error creating a new worker', err);
                return;
            }

            const workerObj = {
                isWorking: false,
                workerInstance: newWorker
            };

            pool.push(workerObj);

            // createNewWorker can be synchronous (even though it uses a callback),
            // in that case it will cause scheduling problems if not delayed
            setImmediate(() => {
                this.emit(PoolEvents.RELEASED_WORKER);
            });
        });
    };

}

util.inherits(AbstractPool, EventEmitter);
AbstractPool.prototype.events = PoolEvents;


module.exports = AbstractPool;

}).call(this)}).call(this,require("timers").setImmediate)

},{"./utils":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/syndicate/lib/utils.js","events":false,"timers":false,"util":false}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/syndicate/lib/Pool-Isolates.js":[function(require,module,exports){
const AbstractPool = require('./AbstractPool');
const util = require('util');
/**
 * @param {PoolConfig&PoolConfigStorage} options
 * @param workerCreateHelper
 * @mixes AbstractPool
 */
function PoolIsolates(options, workerCreateHelper) {
    AbstractPool.call(this, options);

    this.createNewWorker = function (callback) {
        const workerOptions = options.workerOptions;

        const getIsolatesWorker = options.bootScript;

        getIsolatesWorker(workerOptions)
            .then((newWorker) => {

                if (typeof workerCreateHelper === "function") {
                    workerCreateHelper(newWorker);
                }

                callback(undefined, newWorker)
            })
            .catch(err => {
                callback(err);
            });
    };

}

util.inherits(PoolIsolates, AbstractPool);

module.exports = PoolIsolates;

},{"./AbstractPool":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/syndicate/lib/AbstractPool.js","util":false}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/syndicate/lib/Pool-Threads.js":[function(require,module,exports){
const AbstractPool = require('./AbstractPool');
const util = require('util');

/**
 * @param {PoolConfig&PoolConfigStorage} options
 * @param {function} workerCreateHelper
 * @mixes AbstractPool
 */
function PoolThreads(options, workerCreateHelper) {
    AbstractPool.call(this, options);

    this.createNewWorker = function (callback) {
        const worker_threads ='worker_threads';
        const {Worker} = require(worker_threads);

        const newWorker = new Worker(options.bootScript, options.workerOptions);

        if (typeof workerCreateHelper === "function") {
            workerCreateHelper(newWorker);
        }

        const callbackWrapper = (...args) => {
            removeListeners();
            callback(...args);
        };

        function onMessage(msg) {
            if(msg !== 'ready') {
                callbackWrapper(new Error('Build script did not respond accordingly, it might be incompatible with current version'));
                return;
            }

            callbackWrapper(undefined, newWorker);
        }

        function removeListeners() {
            newWorker.removeListener('message', onMessage);
            newWorker.removeListener('error', callbackWrapper);
            newWorker.removeListener('exit', callbackWrapper);
        }

        newWorker.on('message', onMessage);
        newWorker.on('error', callbackWrapper);
        newWorker.on('exit', callbackWrapper);
    };

}

util.inherits(PoolThreads, AbstractPool);

module.exports = PoolThreads;

},{"./AbstractPool":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/syndicate/lib/AbstractPool.js","util":false}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/syndicate/lib/Pool-Web-Workers.js":[function(require,module,exports){
const AbstractPool = require('./AbstractPool');
const util = require('util');

/**
 * @param {PoolConfig&PoolConfigStorage} options
 * @param {function} workerCreateHelper
 * @mixes AbstractPool
 */
function PoolWebWorkers(options, workerCreateHelper) {
    AbstractPool.call(this, options);

    this.createNewWorker = function (callback) {

        const envTypes = require("overwrite-require").constants;
        if($$.environmentType !== envTypes.BROWSER_ENVIRONMENT_TYPE){
            return callback(new Error(`Web Worker is not available into current environment type <${$$.environmentType}>`));
        }

        const newWorker = new Worker(options.bootScript, options.workerOptions);

        if (typeof workerCreateHelper === "function") {
            workerCreateHelper(newWorker);
        }

        const callbackWrapper = (...args) => {
            removeListeners();
            callback(...args);
        };

        function onMessage(msg) {
            if(msg.data !== 'ready') {
                callbackWrapper(new Error('Build script did not respond accordingly, it might be incompatible with current version'));
                return;
            }

            callbackWrapper(undefined, newWorker);
        }

        function removeListeners() {
            newWorker.removeEventListener('message', onMessage);
            newWorker.removeEventListener('messageerror', callbackWrapper);
        }

        newWorker.addEventListener('message', onMessage);
        newWorker.addEventListener('messageerror', callbackWrapper);
    };

}

util.inherits(PoolWebWorkers, AbstractPool);

module.exports = PoolWebWorkers;

},{"./AbstractPool":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/syndicate/lib/AbstractPool.js","overwrite-require":"overwrite-require","util":false}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/syndicate/lib/PoolConfig.js":[function(require,module,exports){
const os = require('os');
const util = require('util');
const WorkerStrategies = require('./WorkerStrategies');

function PoolConfigStorage() {
    this.bootScript = ``;
    this.maximumNumberOfWorkers = os.cpus().length;
    this.workerStrategy = WorkerStrategies.THREADS;
    this.workerOptions = {
        eval: false
    };
}

/**
 * This just provides validation for properties on config
 * Substituting this class to PoolConfigStorage should behave exactly the same effect if the config is valid
 * @constructor
 */
function PoolConfig() {
    const storage = new PoolConfigStorage();

    return {
        get bootScript() {
            return storage.bootScript;
        },
        set bootScript(value) {
            storage.bootScript = value;
        },

        get maximumNumberOfWorkers() {
            return storage.maximumNumberOfWorkers;
        },
        set maximumNumberOfWorkers(value) {
            if (!Number.isFinite(value)) {
                throw new TypeError(`Attribute maximumNumberOfWorkers should be a finite number, got ${typeof value}`);
            }

            if (value <= 0) {
                throw new RangeError(`Attribute maximumNumberOfWorkers should have a value bigger than 0, got ${value}`);
            }

            storage.maximumNumberOfWorkers = value;
        },

        get workerStrategy() {
            return storage.workerStrategy
        },
        set workerStrategy(value) {
            if (!Object.values(WorkerStrategies).includes(value)) {
                throw new TypeError(`Value ${value} not allowed for workerStrategy attribute`);
            }

            storage.workerStrategy = value;
        },

        get workerOptions() {
            return storage.workerOptions;
        },
        set workerOptions(value) {
            storage.workerOptions = value;
        },

        toJSON: function () {
            return JSON.stringify(storage);
        },
        [Symbol.toStringTag]: function () {
            return storage.toString()
        },
        [util.inspect.custom]: function () {
            return util.inspect(storage, {colors: true});
        }
    }
}

/**
 * This utility merges a new config to a default one. It is easier to use if you want to overwrite only a subset
 * of properties of the config.
 * @returns {PoolConfig&PoolConfigStorage}
 */
PoolConfig.createByOverwritingDefaults = function (config = {}, options = {allowNewKeys: true, allowUndefined: true}) {
    const defaultConfig = new PoolConfig();

    Object.keys(config).forEach(key => {

        if (!options.allowNewKeys && !defaultConfig.hasOwnProperty(key)) {
            throw new Error(`Tried overwriting property ${key} that does not exist on PoolConfig. ` +
                `If this is intentional, set in options argument "allowNewKeys" to true'`);
        }

        if (!options.allowUndefined && typeof config[key] === 'undefined') {
            throw new Error(`Tried setting value of ${key} to undefined. ` +
                'If this is intentional, set in options argument "allowUndefined" to true');
        }

        defaultConfig[key] = config[key];
    });

    return defaultConfig;
};

module.exports = PoolConfig;
},{"./WorkerStrategies":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/syndicate/lib/WorkerStrategies.js","os":false,"util":false}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/syndicate/lib/QueueShim.js":[function(require,module,exports){
function Queue() {
    const backingStorage = [];

    Object.defineProperty(this, 'length', {
        get() {
            return backingStorage.length
        },
        set(value) {
            backingStorage.length = value;
        }
    });

    Object.defineProperty(this, 'head', {
        get: () => {
            if (backingStorage.length > 0) {
                return backingStorage[0];
            }

            return null;
        }
    });

    Object.defineProperty(this, 'tail', {
        get: () => {
            const length = backingStorage.length;
            if (length > 0) {
                return backingStorage[length - 1];
            }

            return null;
        }
    });


    this.push = (value) => {
        backingStorage.push(value);
    };

    this.pop = () => {
        return backingStorage.shift();
    };

    this.front = function () {
        return this.head;
    };

    this.isEmpty = function () {
        return backingStorage.length === 0;
    };

    this[Symbol.iterator] = backingStorage[Symbol.iterator];

    this.toString = backingStorage.toString;
    this[Symbol.for('nodejs.util.inspect.custom')] = function() {
        return JSON.stringify(backingStorage);
    }

}

module.exports = Queue;

},{}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/syndicate/lib/WorkerPool.js":[function(require,module,exports){
/** @param pool {AbstractPool} */
function WorkerPool(pool) {
    const { assert } = require("./utils");
    let Queue;

    try {
        Queue = require("swarmutils").Queue;
    } catch (e) {
        Queue = require("./QueueShim.js");
    }

    const PoolEvents = pool.events;
    const taskQueue = new Queue();

    this.addTask = function (task, callback) {
        const taskAccepted = this.runTaskImmediately(task, callback);

        if (!taskAccepted) {
            taskQueue.push({ task, callback });
            return false;
        }

        return true;
    };

    /**
     * Tries to run task if a worker is available, if it is not it will simply discard the task
     * @returns {boolean} - True if the task was given to a worker, false if no worker was available for this task
     */
    this.runTaskImmediately = function (task, callback) {
        const worker = pool.getAvailableWorker();

        if (!worker) {
            return false;
        }

        addWorkerListeners(worker, callback);

        worker.postMessage(task);
        return true;
    };

    pool.on(PoolEvents.RELEASED_WORKER, () => {
        if (taskQueue.isEmpty()) {
            return;
        }

        const taskSize = taskQueue.length;
        const nextTask = taskQueue.front();

        const taskWasAcceptedByAWorker = this.runTaskImmediately(nextTask.task, nextTask.callback);

        if (taskWasAcceptedByAWorker) {
            taskQueue.pop();
            const newTaskSize = taskQueue.length;
            assert(newTaskSize === taskSize - 1, {
                ifFails: `The task queue size did not decrease, expected to be ${taskSize - 1} but is ${newTaskSize}`,
            });
        } else {
            const newTaskSize = taskQueue.length;
            assert(newTaskSize === taskSize, {
                ifFails: `The task queue size modified when it shouldn't, expected to be equal but got pair (old: ${taskSize}, new: ${newTaskSize})`,
            });
            // events are propagates synchronously as mentioned in documentation (https://nodejs.org/api/events.html#events_asynchronous_vs_synchronous)
            // one reason why this can happen is if the worker is not properly marked as "not working"
            // another one is that the queue contains a worker that is free but can't accept tasks (it might have been terminated)
            console.error(`This should never happen and it's most likely a bug`);
        }
    });

    /**
     * @param {Worker} worker
     * @param {function} callbackForListeners
     */
    function addWorkerListeners(worker, callbackForListeners) {
        function callbackWrapper(...args) {
            removeListeners();
            if (args[0] instanceof Error) {
                pool.removeWorker(worker);
            } else {
                pool.returnWorker(worker);
            }
            callbackForListeners(...args);
        }

        function onMessage(...args) {
            if (args[0] instanceof Error) {
                callbackWrapper(...args);
            } else {
                callbackWrapper(undefined, ...args);
            }
        }

        function onError(err) {
            callbackWrapper(err);
        }

        function onExit(code) {
            if (code !== 0) {
                callbackWrapper(new Error(`Worker exited unexpectedly with code ${code}`));
            }
        }

        // ensure consistent API across supported workers
        if (!worker.removeListener) {
            worker.removeListener = worker.removeEventListener.bind(worker);
        }

        // ensure consistent API across supported workers
        if (!worker.once) {
            worker.once = (event, callback) => {
                const listener = (...args) => {
                    worker.removeListener(event, listener);
                    callback(...args);
                };
                worker.addEventListener(event, listener);
            };
        }

        worker.once("message", onMessage);
        worker.once("error", onError);
        worker.once("exit", onExit);

        function removeListeners() {
            worker.removeListener("message", onMessage);
            worker.removeListener("error", onError);
            worker.removeListener("exit", onExit);
        }
    }
}

module.exports = WorkerPool;

},{"./QueueShim.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/syndicate/lib/QueueShim.js","./utils":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/syndicate/lib/utils.js","swarmutils":"swarmutils"}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/syndicate/lib/WorkerStrategies.js":[function(require,module,exports){
const WorkerStrategies = {
    THREADS: 'threads',
    ISOLATES: 'isolates',
    WEB_WORKERS: 'web-workers'
};

module.exports = Object.freeze(WorkerStrategies);

},{}],"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/syndicate/lib/utils.js":[function(require,module,exports){
function assert(condition, {ifFails}) {
    if (condition === false) {
        console.error(ifFails);
    }
}

module.exports = {
    assert
};

},{}],"/home/runner/work/opendsu-sdk/opendsu-sdk/node_modules/is-buffer/index.js":[function(require,module,exports){
/*!
 * Determine if an object is a Buffer
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */

// The _isBuffer check is for Safari 5-7 support, because it's missing
// Object.prototype.constructor. Remove this eventually
module.exports = function (obj) {
  return obj != null && (isBuffer(obj) || isSlowBuffer(obj) || !!obj._isBuffer)
}

function isBuffer (obj) {
  return !!obj.constructor && typeof obj.constructor.isBuffer === 'function' && obj.constructor.isBuffer(obj)
}

// For Node v0.10 support. Remove this eventually.
function isSlowBuffer (obj) {
  return typeof obj.readFloatLE === 'function' && typeof obj.slice === 'function' && isBuffer(obj.slice(0, 0))
}

},{}],"acl-magic":[function(require,module,exports){

var persist  = require("./lib/persistence.js");
var cache    = require("./lib/cache.js");

module.exports.createEnclavePersistence = function(enclave, cache, type){
    if(!cache){
        cache = module.exports.createCache();
    }
    return persist.createEnclavePersistence(enclave, cache, type);
}

module.exports.createMemoryPersistence = function(){
    return persist.createMemoryPersistence();
};

module.exports.createCache = function(timeOut){
    return cache.createCache(timeOut); /* somethink like 60*1000 or more*/
};


function lazyAsyncDeepTreeChecker(root, getChildren, checkFunction, returnCallBack){
    var intermediateGenerators = [];
    intermediateGenerators.push(root);
    var waitingAsyncCall = 0;

    function checkNextNode(){
        if(!intermediateGenerators){
            return ;
        }

        var currentNode = intermediateGenerators.shift();
        if(!currentNode){
            if(waitingAsyncCall == 0){
                intermediateGenerators = null;
                returnCallBack(null, false);
            } else {
                return ; //will be triggered again from other call
            }
        }
        waitingAsyncCall++;
        getChildren(currentNode, function(err,arr){
            if(intermediateGenerators){
                waitingAsyncCall--;
                arr.map(function(n){
                    intermediateGenerators.push(n);
                });
                if(waitingAsyncCall == 0){
                    checkNextNode(); //just in case the main checking chain is already stopped because getChildren was slower than the checkFunction
                }
            }
        });

        waitingAsyncCall++;
        checkFunction(currentNode, function(err,res){
            waitingAsyncCall--;
            if(res){
                intermediateGenerators = null;
                returnCallBack(null, true);
            } else {
                checkNextNode();
            }
        })
    }
    checkNextNode();
}

function Concern(concernName, persistence, exceptionalRulesFunction, afterCheckFunction){
    this.grant = function(zoneId, resourceId, callback){
        persistence.grant(concernName,zoneId, resourceId, callback);
    }

    this.ungrant = function(zoneId, resourceId, callback){
        persistence.ungrant(concernName,zoneId, resourceId, callback);
    }

    this.addResourceParent = function(resourcesUID, parentUid, callback){
        persistence.addResourceParent(resourcesUID, parentUid, callback);
    }

    this.addZoneParent = function(zoneId, parentZoneId, callback){
        persistence.addZoneParent(zoneId, parentZoneId, callback);
    }

    /*
        allow return by calling callback(null,true) or callback(null,false). It should return only once.
     */

    this.allow1 = function(zoneId, resourceId, callback){
        var allParentZones = persistence.loadZoneParents.async(zoneId);
        var exceptionAllow;
        if(exceptionalRulesFunction){
            exceptionAllow = exceptionalRulesFunction.async(zoneId, resourceId);
        } else {
            exceptionAllow = false;
        }

        (function(allParentZones, exceptionAllow){
            if(exceptionAllow) {
                intermediateReturnCallback(null, true);
            } else {
                lazyAsyncDeepTreeChecker(resourceId,
                    function(node, callback){ //get children
                        var parents = persistence.loadResourceDirectParents.async(node);
                        (function(parents){
                            callback(null,parents);
                        }).wait(parents);
                    },
                    function(node, callback){ //checkFunction
                        var resourceGrants = persistence.loadResourceDirectGrants.async(concernName, node);
                        (function(resourceGrants){
                            if(notDisjoint(resourceGrants, allParentZones)){
                                callback(null, true);
                            }
                            else {
                                callback(null, false);
                            }
                        }).wait(resourceGrants);
                    },
                    intermediateReturnCallback  //pass the result callback to report success (true) on first successful check or false at the end
                );
            }
        }).wait(allParentZones, exceptionAllow);

        function notDisjoint(arr1, arr2){
            var o = {};
            for(var i = 0, l = arr1.length; i<l; i++ ){
                o[arr1[i]] = true;
            }

            for(i = 0, l = arr2.length; i<l; i++ ){
                if(o[arr2[i]]) {
                    return true;
                }
            }
            return false;
        }


        function intermediateReturnCallback(err, res){
            if(afterCheckFunction){
                afterCheckFunction(zoneId, resourceId,function(err,afterCheckAllow){
                    if(err){
                        callback(err);
                    }else if(afterCheckAllow){
                        callback(undefined,afterCheckAllow);
                    }else{
                        callback(undefined,res);
                    }
                });
            }else{
                callback(undefined,res);
            }
        }


    }

    this.allow = function(zoneId, resourceId, callback){
        if(exceptionalRulesFunction){
            exceptionalRulesFunction(zoneId,resourceId,function(err,favorableException){
                if(err){
                    callback(err);
                }else if(favorableException===true){
                    intermediateReturnCallback(undefined,true);
                }else{
                    checkTree();
                }
            })
        }else{
            checkTree();
        }

        function checkTree(){
            persistence.loadZoneParents(zoneId,function(err,allParentZones){
                if(err){
                    callback(err);
                }else{
                    lazyAsyncDeepTreeChecker(resourceId,
                        function(node, callback){ //get children
                            process.nextTick(function() {
                                persistence.loadResourceDirectParents(node, function (err, parents) {
                                    if (err) {
                                        callback(err);
                                    } else {
                                        callback(null, parents);
                                    }
                                });
                            })
                        },
                        function(node, callback){ //checkFunction
                            persistence.loadResourceDirectGrants(concernName, node,function(err,resourceGrants){
                                if(err){
                                    callback(err);
                                }else if(notDisjoint(resourceGrants, allParentZones)){
                                    callback(null, true);
                                }else {
                                    callback(null, false);
                                }
                            })
                        },
                        intermediateReturnCallback  //pass the result callback to report success (true) on first successful check or false at the end
                    );
                }
            })
        }

        function notDisjoint(arr1, arr2){
            var o = {};
            for(var i = 0, l = arr1.length; i<l; i++ ){
                o[arr1[i]] = true;
            }

            for(i = 0, l = arr2.length; i<l; i++ ){
                if(o[arr2[i]]) {
                    return true;
                }
            }
            return false;
        }

        function intermediateReturnCallback(err, res){
            if(afterCheckFunction){
                afterCheckFunction(zoneId, resourceId,function(err,afterCheckAllow){
                    if(err){
                        callback(err);
                    }else if(afterCheckAllow){
                        callback(undefined,afterCheckAllow);
                    }else{
                        callback(undefined,res);
                    }
                });
            }else{
                callback(undefined,res);
            }
        }
    }
}

module.exports.createConcern = function(concernName, persistence, exceptionalRulesFunction, afterCheckFunction){
    return new Concern(concernName, persistence, exceptionalRulesFunction, afterCheckFunction);
}

},{"./lib/cache.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/acl-magic/lib/cache.js","./lib/persistence.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/acl-magic/lib/persistence.js"}],"apihub":[function(require,module,exports){
const logger = $$.getLogger("HttpServer", "apihub");

process.on('uncaughtException', err => {
    logger.critical('There was an uncaught error', err, err.message, err.stack);
});

process.on('SIGTERM', (signal) => {
    process.shuttingDown = true;
    logger.info('Received signal:', signal, ". Activating the gracefulTerminationWatcher.");
});

const httpWrapper = require('./libs/http-wrapper');
const Server = httpWrapper.Server;

const CHECK_FOR_RESTART_COMMAND_FILE_INTERVAL = 500;

(function loadDefaultComponents() {
    //next require lines are only for browserify build purpose
    // Remove mock
    require('./components/admin');
    require('./components/config');
    require('./components/bricking');
    require('./components/anchoring');
    require('./components/bdns');
    /*require('./components/fileManager');
    require('./components/bricksFabric');*/
    require('./components/staticServer');
    require('./components/keySsiNotifications');
    require('./components/debugLogger');
    require('./components/mqHub');
    require('./components/secrets');
    require('./components/mainDSU');
    require('./components/cloudWallet');
    require('./components/versionlessDSU');
    require('./components/stream');
    require('./components/requestForwarder');
    require('./components/lightDBEnclave');
    require("./components/activeComponents");
    //end
})();

function HttpServer({listeningPort, rootFolder, sslConfig, dynamicPort, restartIntervalCheck, retryTimeout}, callback) {
    if (typeof restartIntervalCheck === "undefined") {
        restartIntervalCheck = CHECK_FOR_RESTART_COMMAND_FILE_INTERVAL;
    }
    let port = listeningPort || 8080;
    const conf = require('./config').getConfig();
    const server = new Server(sslConfig);
    server.config = conf;
    server.rootFolder = rootFolder;
    server.timeout = conf.timeout || (60 * 1000) + 1000;
    server.requestTimeout = conf.requestTimeout || 300 * 1000;

    server.keepAliveTimeout = conf.keepAliveTimeout || (60 * 1000) + 1000;

    server.getHeadHandler = function (handler) {
        return function (req, res, next) {
            res.write = function () {

            }
            let originalEnd = res.end;
            res.end = function () {
                originalEnd.call(res);
            }

            handler(req, res, next);
        }
    }

    let permanentWarnings = [];
    server.registerPermanentWarning = (componentName, error) => {
        permanentWarnings.push({componentName, error});
    }

    let displayPermanentWarnings = function () {
        for (let warning of permanentWarnings) {
            let {error, componentName} = warning;
            logger.warning(`Component ${componentName} has an permanent warning!`, error);
        }
    }

    server.use((req, res, next) => {
        if (permanentWarnings.length) {
            logger.warning("The server seems to be in a wrong state!", `${permanentWarnings.length} warning(s):`);
            displayPermanentWarnings();
        }
        next();
    });

    let listenCallback = (err) => {
        if (err) {
            if (!dynamicPort && callback) {
                return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to listen on port <${port}>`, err));
            }
            if (dynamicPort && err.code === 'EADDRINUSE') {
                logger.debug(`Port ${port} is already in use. Trying to find another one...`);

                function getRandomPort() {
                    const min = 9000;
                    const max = 65535;
                    return Math.floor(Math.random() * (max - min) + min);
                }

                port = getRandomPort();
                if (Number.isInteger(dynamicPort)) {
                    dynamicPort -= 1;
                }
                let timeValue = retryTimeout || CHECK_FOR_RESTART_COMMAND_FILE_INTERVAL;
                setTimeout(bootup, timeValue);
            } else {
                logger.error(err);
            }
        }
    };

    function bootup() {
        logger.debug(`Trying to listen on port ${port}`);
        server.listen(port, conf.host, listenCallback);
    }

    bootup();

    if (restartIntervalCheck) {
        setInterval(function () {
            let restartServerFile = server.rootFolder + '/needServerRestart';
            const fsname = "fs";
            const fs = require(fsname);
            fs.readFile(restartServerFile, function (error, content) {
                if (!error && content.toString() !== "") {
                    logger.debug(`### Preparing to restart because of the request done by file: <${restartServerFile}> File content: ${content}`);
                    server.close();
                    server.listen(port, conf.host, () => {
                        fs.writeFile(restartServerFile, "", function () {
                            //we don't care about this file.. we just clear it's content the prevent recursive restarts
                            logger.debug(`### Restart operation finished.`);
                        });
                    });
                }
            });
        }, restartIntervalCheck);
    }

    server.on('listening', bindFinished);
    server.on('error', listenCallback);

    let accessControlAllowHeaders = new Set();
    accessControlAllowHeaders.add("Content-Type");
    accessControlAllowHeaders.add("Content-Length");
    accessControlAllowHeaders.add("X-Content-Length");
    accessControlAllowHeaders.add("Access-Control-Allow-Origin");
    accessControlAllowHeaders.add("User-Agent");
    accessControlAllowHeaders.add("Authorization");
    accessControlAllowHeaders.add("ETag");

    server.registerAccessControlAllowHeaders = function (headers) {
        if (headers) {
            if (Array.isArray(headers)) {
                for (let i = 0; i < headers.length; i++) {
                    accessControlAllowHeaders.add(headers[i]);
                }
            } else {
                accessControlAllowHeaders.add(headers);
            }
        }
    }

    server.getAccessControlAllowHeadersAsString = function () {
        let headers = "";
        let notFirst = false;
        for (let header of accessControlAllowHeaders) {
            if (notFirst) {
                headers += ", ";
            }
            notFirst = true;
            headers += header;
        }
        return headers;
    }

    function bindFinished(err) {
        if (err) {
            logger.error(err);
            if (callback) {
                return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to bind on port <${port}>`, err));
            }
            return;
        }

        registerEndpoints(callback);
    }

    let endpointsAlreadyRegistered = false;

    function registerEndpoints(callback) {
        //The purpose of this flag is to prevent endpoints registering again
        //in case of a restart requested by file needServerRestart present in rootFolder
        if (endpointsAlreadyRegistered) {
            return;
        }
        endpointsAlreadyRegistered = true;
        server.use(function (req, res, next) {
            res.setHeader('Access-Control-Allow-Origin', req.headers.origin || req.headers.host || "*");
            res.setHeader('Access-Control-Allow-Methods', 'GET, POST, PUT, DELETE, OPTIONS');
            res.setHeader('Access-Control-Allow-Headers', server.getAccessControlAllowHeadersAsString());
            res.setHeader('Access-Control-Allow-Credentials', true);
            next();
        });

        server.options('/*', function (req, res) {
            const headers = {};
            //origin header maybe missing (eg. Postman call or proxy that doesn't forward the origin header etc.)
            if (req.headers.origin) {
                headers['Access-Control-Allow-Origin'] = req.headers.origin;
            } else {
                headers['Access-Control-Allow-Origin'] = '*';
            }
            headers['Access-Control-Allow-Methods'] = 'POST, GET, PUT, DELETE, OPTIONS';
            headers['Access-Control-Allow-Credentials'] = true;
            headers['Access-Control-Max-Age'] = '3600'; //one hour
            headers['Access-Control-Allow-Headers'] = server.getAccessControlAllowHeadersAsString();

            if (conf.CORS) {
                logger.debug("Applying custom CORS headers");
                for (let prop in conf.CORS) {
                    headers[prop] = conf.CORS[prop];
                }
            }

            res.writeHead(200, headers);
            res.end();
        });

        function addRootMiddlewares() {
            const LoggerMiddleware = require('./middlewares/logger');
            const ReadOnly = require("./middlewares/readOnly");
            const AuthorisationMiddleware = require('./middlewares/authorisation');
            const Throttler = require('./middlewares/throttler');
            const OAuth = require('./middlewares/oauth');
            const ClientCredentialsOAuth = require('./middlewares/clientCredentialsOauth');
            const SimpleAuth = require('./middlewares/simpleAuth');
            const APIKeyAuthorisation = require('./middlewares/apiKeyAuth');
            const FixedUrls = require('./middlewares/fixedUrls');
            const SimpleLock = require('./middlewares/SimpleLock');
            const ResponseHeaderMiddleware = require('./middlewares/responseHeader');
            const genericErrorMiddleware = require('./middlewares/genericErrorMiddleware');
            const requestEnhancements = require('./middlewares/requestEnhancements');

            server.use(function gracefulTerminationWatcher(req, res, next) {
                const allowedUrls = [/*"/installation-details", "/ready-probe"*/];
                if (process.shuttingDown && allowedUrls.indexOf(req.url) === -1) {
                    //uncaught exception was caught so server is shutting down gracefully and not accepting any requests
                    res.statusCode = 503;
                    logger.log(0x02, `Rejecting ${req.url} with status code ${res.statusCode} because process is shutting down.`);
                    res.end();
                    return;
                }
                //if the url is allowed or shuttingDown flag not present, we let the request go on...
                next();
            });

            if (conf.enableRequestLogger) {
                new LoggerMiddleware(server);
            }

            if (conf.enableReadOnlyMechanism) {
                ReadOnly(server);
            }

            if (conf.enableErrorCloaking) {
                genericErrorMiddleware(server);
            }
            requestEnhancements(server);
            Throttler(server);
            FixedUrls(server);
            SimpleLock(server);

            if (conf.enableJWTAuthorisation) {
                new AuthorisationMiddleware(server);
            }

            APIKeyAuthorisation(server);

            if (conf.enableClientCredentialsOauth) {
                ClientCredentialsOAuth(server);
            }

            if (conf.enableSimpleAuth && process.env.ENABLE_SSO !== "false") {
                SimpleAuth(server);
            }

            if (conf.enableOAuth && process.env.ENABLE_SSO !== "false") {
                new OAuth(server);
            }

            if (conf.responseHeaders) {
                new ResponseHeaderMiddleware(server);
            }

            if (conf.enableInstallationDetails) {
                const enableInstallationDetails = require("./components/installation-details");
                enableInstallationDetails(server);
            }
        }

        function addComponent(componentName, componentConfig, callback) {
            const path = require("swarmutils").path;

            let componentPath = componentConfig.module;
            if (componentPath.startsWith('.') && !conf.isDefaultComponent(componentName)) {
                componentPath = path.resolve(path.join(process.env.PSK_ROOT_INSTALATION_FOLDER, componentPath));
            }
            logger.debug(`Preparing to register middleware from path ${componentPath}`);

            let middlewareImplementation;
            try {
                middlewareImplementation = require(componentPath);
            } catch (e) {
                server.registerPermanentWarning(componentName, e);
                if (callback) {
                    callback();
                }
                return;
            }
            let asyncLoadingComponent = false;
            const calledByAsyncLoadingComponent = () => {
                asyncLoadingComponent = true;
                //if the component calls before returning this function means that needs more time, is doing async calls etc.
            }

            let args = [server];

            if (callback) {
                args.push(calledByAsyncLoadingComponent);
                args.push(callback);
            }

            try {
                if (typeof componentConfig.function !== 'undefined') {
                    middlewareImplementation[componentConfig.function](...args);
                } else {
                    middlewareImplementation(...args);
                }
            } catch (err) {
                server.registerPermanentWarning(componentName, err);
                if (callback) {
                    callback();
                }
                return;
            }

            if (!asyncLoadingComponent && callback) {
                callback();
            }
        }

        function addComponents(cb) {
            const requiredComponentNames = ["config"];
            //addComponent("config", {module: "./components/config"});
            addComponent("activeComponents", {module: "./components/activeComponents"});

            // take only the components that have configurations and that are not part of the required components
            const middlewareList = [...conf.activeComponents]
                .filter(activeComponentName => {
                    let include = conf.componentsConfig[activeComponentName];
                    if (!include) {
                        logger.debug(`Not able to find config for component called < ${activeComponentName} >. Excluding it from the active components list!`);
                    }
                    return include;
                })
                .filter(activeComponentName => !requiredComponentNames.includes(activeComponentName));

            const addRequiredComponent = (componentName) => {
                if (!middlewareList.includes(`${componentName}`)) {
                    logger.warn(`WARNING: ${componentName} component is not configured inside activeComponents!`)
                    logger.warn(`WARNING: temporary adding ${componentName} component to activeComponents! Please make sure to include ${componentName} component inside activeComponents!`)

                    const addComponentToComponentList = (list) => {
                        const indexOfStaticServer = list.indexOf("staticServer");
                        if (indexOfStaticServer !== -1) {
                            // staticServer needs to load last
                            list.splice(indexOfStaticServer, 0, componentName);
                        } else {
                            list.push(componentName);
                        }
                    }

                    addComponentToComponentList(middlewareList);
                    // need to also register to defaultComponents in order to be able to load the module correctly
                    addComponentToComponentList(conf.defaultComponents);
                }
            }

            addRequiredComponent("cloudWallet");
            addRequiredComponent("mainDSU");
            addRequiredComponent("lightDBEnclave");

            function installNextComponent(componentList) {
                const componentName = componentList[0];
                const componentConfig = conf.componentsConfig[componentName];
                addComponent(componentName, componentConfig, () => {
                    componentList.shift();
                    if (componentList.length > 0) {
                        return installNextComponent(componentList);
                    }
                    if (cb) {
                        cb();
                    }
                });
            }

            if (middlewareList.indexOf("staticServer") === -1) {
                middlewareList.push("staticServer");
            }

            installNextComponent(middlewareList);
        }

        addRootMiddlewares();
        addComponents(() => {
            //at this point all components were installed and we need to register the fallback handler
            logger.debug("Registering the fallback handler. Any endpoint registered after this one will have zero changes to be executed.");
            server.use(function (req, res) {
                logger.debug("Response handled by fallback handler.");
                res.statusCode = 404;
                res.end();
            });
            if (callback) {
                return callback();
            }
        });
    }

    return server;
}

module.exports.createInstance = function (port, folder, sslConfig, callback) {
    if (typeof sslConfig === 'function') {
        callback = sslConfig;
        sslConfig = undefined;
    }

    return new HttpServer({listeningPort: port, rootFolder: folder, sslConfig}, callback);
};

module.exports.start = function (options, callback) {
    return new HttpServer(options, callback);
}

module.exports.getHttpWrapper = function () {
    return require('./libs/http-wrapper');
};

module.exports.getServerConfig = function () {
    logger.debug(`apihub.getServerConfig() method is deprecated, please use server.config to retrieve necessary info.`);
    const config = require('./config');
    return config.getConfig();
};

module.exports.getDomainConfig = function (domain, ...configKeys) {
    logger.debug(`apihub.getServerConfig() method is deprecated, please use server.config.getDomainConfig(...) to retrieve necessary info.`);
    const config = require('./config');
    return config.getDomainConfig(domain, ...configKeys);
};

module.exports.middlewares = {
    ReadOnly: require("./middlewares/readOnly")
}

module.exports.getSecretsServiceInstanceAsync = require("./components/secrets/SecretsService").getSecretsServiceInstanceAsync;

module.exports.anchoringStrategies = require("./components/anchoring/strategies");

module.exports.TokenBucket = require("./libs/TokenBucket");
},{"./components/activeComponents":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/apihub/components/activeComponents/index.js","./components/admin":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/apihub/components/admin/index.js","./components/anchoring":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/apihub/components/anchoring/index.js","./components/anchoring/strategies":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/apihub/components/anchoring/strategies/index.js","./components/bdns":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/apihub/components/bdns/index.js","./components/bricking":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/apihub/components/bricking/index.js","./components/cloudWallet":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/apihub/components/cloudWallet/index.js","./components/config":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/apihub/components/config/index.js","./components/debugLogger":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/apihub/components/debugLogger/index.js","./components/installation-details":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/apihub/components/installation-details/index.js","./components/keySsiNotifications":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/apihub/components/keySsiNotifications/index.js","./components/lightDBEnclave":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/apihub/components/lightDBEnclave/index.js","./components/mainDSU":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/apihub/components/mainDSU/index.js","./components/mqHub":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/apihub/components/mqHub/index.js","./components/requestForwarder":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/apihub/components/requestForwarder/index.js","./components/secrets":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/apihub/components/secrets/index.js","./components/secrets/SecretsService":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/apihub/components/secrets/SecretsService.js","./components/staticServer":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/apihub/components/staticServer/index.js","./components/stream":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/apihub/components/stream/index.js","./components/versionlessDSU":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/apihub/components/versionlessDSU/index.js","./config":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/apihub/config/index.js","./libs/TokenBucket":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/apihub/libs/TokenBucket.js","./libs/http-wrapper":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/apihub/libs/http-wrapper/src/index.js","./middlewares/SimpleLock":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/apihub/middlewares/SimpleLock/index.js","./middlewares/apiKeyAuth":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/apihub/middlewares/apiKeyAuth/index.js","./middlewares/authorisation":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/apihub/middlewares/authorisation/index.js","./middlewares/clientCredentialsOauth":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/apihub/middlewares/clientCredentialsOauth/index.js","./middlewares/fixedUrls":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/apihub/middlewares/fixedUrls/index.js","./middlewares/genericErrorMiddleware":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/apihub/middlewares/genericErrorMiddleware/index.js","./middlewares/logger":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/apihub/middlewares/logger/index.js","./middlewares/oauth":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/apihub/middlewares/oauth/index.js","./middlewares/readOnly":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/apihub/middlewares/readOnly/index.js","./middlewares/requestEnhancements":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/apihub/middlewares/requestEnhancements/index.js","./middlewares/responseHeader":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/apihub/middlewares/responseHeader/index.js","./middlewares/simpleAuth":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/apihub/middlewares/simpleAuth/index.js","./middlewares/throttler":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/apihub/middlewares/throttler/index.js","swarmutils":"swarmutils"}],"bar-fs-adapter":[function(require,module,exports){
module.exports.createFsAdapter = () => {
    const FsAdapter = require("./lib/FsAdapter");
    return new FsAdapter();
};
},{"./lib/FsAdapter":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/bar-fs-adapter/lib/FsAdapter.js"}],"bar":[function(require,module,exports){

const ArchiveConfigurator = require("./lib/ArchiveConfigurator");
const createFolderBrickStorage = require("./lib/obsolete/FolderBrickStorage").createFolderBrickStorage;
const createFileBrickStorage = require("./lib/obsolete/FileBrickStorage").createFileBrickStorage;
const BrickStorageService = require('./lib/BrickStorageService').Service;
const BrickMapController = require('./lib/BrickMapController');

ArchiveConfigurator.prototype.registerStorageProvider("FolderBrickStorage", createFolderBrickStorage);
ArchiveConfigurator.prototype.registerStorageProvider("FileBrickStorage", createFileBrickStorage);

module.exports.ArchiveConfigurator = ArchiveConfigurator;
module.exports.createBrick = (config) => {
    const Brick = require("./lib/Brick");
    return new Brick(config);
};

module.exports.createArchive = (archiveConfigurator) => {
    const Archive = require("./lib/Archive");
    return new Archive(archiveConfigurator);
};
module.exports.createArchiveConfigurator = () => {
    return new ArchiveConfigurator();
};

module.exports.createBrickMap = (header) => {
    const BrickMap = require("./lib/BrickMap");
    return new BrickMap(header);
};

module.exports.isArchive = (archive) => {
    const Archive = require('./lib/Archive');
    return archive instanceof Archive;
}

module.exports.BrickMapDiff = require('./lib/BrickMapDiff');
module.exports.BrickMapStrategyFactory = require('./lib/BrickMapStrategy');
module.exports.BrickMapStrategyMixin = require('./lib/BrickMapStrategy/BrickMapStrategyMixin');
module.exports.createFolderBrickStorage = createFolderBrickStorage;
module.exports.createFileBrickStorage = createFileBrickStorage;

module.exports.createBrickStorageService = (archiveConfigurator, keySSI) => {
    const brickStorageService = new BrickStorageService({
        cache: archiveConfigurator.getCache(),
        bufferSize: archiveConfigurator.getBufferSize(),
        keySSI,

        brickFactoryFunction: (encrypt) => {
            const Brick = require("./lib/Brick");
            encrypt = (typeof encrypt === 'undefined') ? true : !!encrypt;
            // Strip the encryption key from the SeedSSI
            return new Brick({templateKeySSI: keySSI, encrypt});
        },

        brickDataExtractorCallback: (brickMeta, brick, callback) => {
            brick.setTemplateKeySSI(keySSI);

            function extractData() {
                const brickEncryptionKeySSI = brickMapController.getBrickEncryptionKeySSI(brickMeta);
                brick.setKeySSI(brickEncryptionKeySSI);
                brick.getRawData(callback);
            }

            extractData();
        },

        fsAdapter: archiveConfigurator.getFsAdapter()
    });
    const brickMapController = new BrickMapController({
        config: archiveConfigurator,
        brickStorageService,
        keySSI
    });

    return brickStorageService;
};
},{"./lib/Archive":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/bar/lib/Archive.js","./lib/ArchiveConfigurator":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/bar/lib/ArchiveConfigurator.js","./lib/Brick":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/bar/lib/Brick.js","./lib/BrickMap":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/bar/lib/BrickMap.js","./lib/BrickMapController":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/bar/lib/BrickMapController.js","./lib/BrickMapDiff":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/bar/lib/BrickMapDiff.js","./lib/BrickMapStrategy":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/bar/lib/BrickMapStrategy/index.js","./lib/BrickMapStrategy/BrickMapStrategyMixin":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/bar/lib/BrickMapStrategy/BrickMapStrategyMixin.js","./lib/BrickStorageService":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/bar/lib/BrickStorageService/index.js","./lib/obsolete/FileBrickStorage":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/bar/lib/obsolete/FileBrickStorage.js","./lib/obsolete/FolderBrickStorage":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/bar/lib/obsolete/FolderBrickStorage.js"}],"buffer-crc32":[function(require,module,exports){

var CRC_TABLE = [
  0x00000000, 0x77073096, 0xee0e612c, 0x990951ba, 0x076dc419,
  0x706af48f, 0xe963a535, 0x9e6495a3, 0x0edb8832, 0x79dcb8a4,
  0xe0d5e91e, 0x97d2d988, 0x09b64c2b, 0x7eb17cbd, 0xe7b82d07,
  0x90bf1d91, 0x1db71064, 0x6ab020f2, 0xf3b97148, 0x84be41de,
  0x1adad47d, 0x6ddde4eb, 0xf4d4b551, 0x83d385c7, 0x136c9856,
  0x646ba8c0, 0xfd62f97a, 0x8a65c9ec, 0x14015c4f, 0x63066cd9,
  0xfa0f3d63, 0x8d080df5, 0x3b6e20c8, 0x4c69105e, 0xd56041e4,
  0xa2677172, 0x3c03e4d1, 0x4b04d447, 0xd20d85fd, 0xa50ab56b,
  0x35b5a8fa, 0x42b2986c, 0xdbbbc9d6, 0xacbcf940, 0x32d86ce3,
  0x45df5c75, 0xdcd60dcf, 0xabd13d59, 0x26d930ac, 0x51de003a,
  0xc8d75180, 0xbfd06116, 0x21b4f4b5, 0x56b3c423, 0xcfba9599,
  0xb8bda50f, 0x2802b89e, 0x5f058808, 0xc60cd9b2, 0xb10be924,
  0x2f6f7c87, 0x58684c11, 0xc1611dab, 0xb6662d3d, 0x76dc4190,
  0x01db7106, 0x98d220bc, 0xefd5102a, 0x71b18589, 0x06b6b51f,
  0x9fbfe4a5, 0xe8b8d433, 0x7807c9a2, 0x0f00f934, 0x9609a88e,
  0xe10e9818, 0x7f6a0dbb, 0x086d3d2d, 0x91646c97, 0xe6635c01,
  0x6b6b51f4, 0x1c6c6162, 0x856530d8, 0xf262004e, 0x6c0695ed,
  0x1b01a57b, 0x8208f4c1, 0xf50fc457, 0x65b0d9c6, 0x12b7e950,
  0x8bbeb8ea, 0xfcb9887c, 0x62dd1ddf, 0x15da2d49, 0x8cd37cf3,
  0xfbd44c65, 0x4db26158, 0x3ab551ce, 0xa3bc0074, 0xd4bb30e2,
  0x4adfa541, 0x3dd895d7, 0xa4d1c46d, 0xd3d6f4fb, 0x4369e96a,
  0x346ed9fc, 0xad678846, 0xda60b8d0, 0x44042d73, 0x33031de5,
  0xaa0a4c5f, 0xdd0d7cc9, 0x5005713c, 0x270241aa, 0xbe0b1010,
  0xc90c2086, 0x5768b525, 0x206f85b3, 0xb966d409, 0xce61e49f,
  0x5edef90e, 0x29d9c998, 0xb0d09822, 0xc7d7a8b4, 0x59b33d17,
  0x2eb40d81, 0xb7bd5c3b, 0xc0ba6cad, 0xedb88320, 0x9abfb3b6,
  0x03b6e20c, 0x74b1d29a, 0xead54739, 0x9dd277af, 0x04db2615,
  0x73dc1683, 0xe3630b12, 0x94643b84, 0x0d6d6a3e, 0x7a6a5aa8,
  0xe40ecf0b, 0x9309ff9d, 0x0a00ae27, 0x7d079eb1, 0xf00f9344,
  0x8708a3d2, 0x1e01f268, 0x6906c2fe, 0xf762575d, 0x806567cb,
  0x196c3671, 0x6e6b06e7, 0xfed41b76, 0x89d32be0, 0x10da7a5a,
  0x67dd4acc, 0xf9b9df6f, 0x8ebeeff9, 0x17b7be43, 0x60b08ed5,
  0xd6d6a3e8, 0xa1d1937e, 0x38d8c2c4, 0x4fdff252, 0xd1bb67f1,
  0xa6bc5767, 0x3fb506dd, 0x48b2364b, 0xd80d2bda, 0xaf0a1b4c,
  0x36034af6, 0x41047a60, 0xdf60efc3, 0xa867df55, 0x316e8eef,
  0x4669be79, 0xcb61b38c, 0xbc66831a, 0x256fd2a0, 0x5268e236,
  0xcc0c7795, 0xbb0b4703, 0x220216b9, 0x5505262f, 0xc5ba3bbe,
  0xb2bd0b28, 0x2bb45a92, 0x5cb36a04, 0xc2d7ffa7, 0xb5d0cf31,
  0x2cd99e8b, 0x5bdeae1d, 0x9b64c2b0, 0xec63f226, 0x756aa39c,
  0x026d930a, 0x9c0906a9, 0xeb0e363f, 0x72076785, 0x05005713,
  0x95bf4a82, 0xe2b87a14, 0x7bb12bae, 0x0cb61b38, 0x92d28e9b,
  0xe5d5be0d, 0x7cdcefb7, 0x0bdbdf21, 0x86d3d2d4, 0xf1d4e242,
  0x68ddb3f8, 0x1fda836e, 0x81be16cd, 0xf6b9265b, 0x6fb077e1,
  0x18b74777, 0x88085ae6, 0xff0f6a70, 0x66063bca, 0x11010b5c,
  0x8f659eff, 0xf862ae69, 0x616bffd3, 0x166ccf45, 0xa00ae278,
  0xd70dd2ee, 0x4e048354, 0x3903b3c2, 0xa7672661, 0xd06016f7,
  0x4969474d, 0x3e6e77db, 0xaed16a4a, 0xd9d65adc, 0x40df0b66,
  0x37d83bf0, 0xa9bcae53, 0xdebb9ec5, 0x47b2cf7f, 0x30b5ffe9,
  0xbdbdf21c, 0xcabac28a, 0x53b39330, 0x24b4a3a6, 0xbad03605,
  0xcdd70693, 0x54de5729, 0x23d967bf, 0xb3667a2e, 0xc4614ab8,
  0x5d681b02, 0x2a6f2b94, 0xb40bbe37, 0xc30c8ea1, 0x5a05df1b,
  0x2d02ef8d
];

if (typeof Int32Array !== 'undefined') {
  CRC_TABLE = new Int32Array(CRC_TABLE);
}

function newEmptyBuffer(length) {
  var buffer = new $$.Buffer(length);
  buffer.fill(0x00);
  return buffer;
}

function ensureBuffer(input) {
  if ($$.Buffer.isBuffer(input)) {
    return input;
  }

  var hasNewBufferAPI =
      typeof $$.Buffer.alloc === "function" &&
      typeof $$.Buffer.from === "function";

  if (typeof input === "number") {
    return hasNewBufferAPI ? $$.Buffer.alloc(input) : newEmptyBuffer(input);
  }
  else if (typeof input === "string") {
    return hasNewBufferAPI ? $$.Buffer.from(input) : new $$.Buffer(input);
  }
  else {
    throw new Error("input must be buffer, number, or string, received " +
                    typeof input);
  }
}

function bufferizeInt(num) {
  var tmp = ensureBuffer(4);
  tmp.writeInt32BE(num, 0);
  return tmp;
}

function _crc32(buf, previous) {
  buf = ensureBuffer(buf);
  if ($$.Buffer.isBuffer(previous)) {
    previous = previous.readUInt32BE(0);
  }
  var crc = ~~previous ^ -1;
  for (var n = 0; n < buf.length; n++) {
    crc = CRC_TABLE[(crc ^ buf[n]) & 0xff] ^ (crc >>> 8);
  }
  return (crc ^ -1);
}

function crc32() {
  return bufferizeInt(_crc32.apply(null, arguments));
}
crc32.signed = function () {
  return _crc32.apply(null, arguments);
};
crc32.unsigned = function () {
  return _crc32.apply(null, arguments) >>> 0;
};

module.exports = crc32;

},{}],"cloud-enclave":[function(require,module,exports){
function CloudEnclaveServer(config) {
    config = config || {};
    const {CloudEnclaveBootService} = require("./src/CloudEnclaveBootService");
    let defaultConfig = require("./src/config");
    defaultConfig = Object.assign(defaultConfig, config);
    config = defaultConfig;
    const openDSU = require("opendsu");
    const utils = openDSU.loadAPI("utils");
    const ObservableMixin = utils.ObservableMixin;
    this.serverConfig = config;
    this.initialised = false;
    this.enclaveHandler = new CloudEnclaveBootService(this);
    ObservableMixin(this);

    this.start = () => {
        this.enclaveHandler.bootEnclaves();
    }

    this.isInitialised = () => {
        return this.initialised;
    }
}

const createInstance = (config) => {
    return new CloudEnclaveServer(config);
}

module.exports = {
    createInstance
}
},{"./src/CloudEnclaveBootService":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/cloud-enclave/src/CloudEnclaveBootService.js","./src/config":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/cloud-enclave/src/config.js","opendsu":"opendsu"}],"fast-svd":[function(require,module,exports){
module.exports = {
    FastSVD: require("./src/index"),
};
},{"./src/index":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/fast-svd/src/index.js"}],"key-ssi-resolver":[function(require,module,exports){
const KeySSIResolver = require('./lib/KeySSIResolver');
const DSUFactory = require("./lib/DSUFactoryRegistry");

/**
 * Create a new KeySSIResolver instance and append it to
 * global object $$
 *
 * @param {object} options
 */
function initialize(options) {
    options = options || {};


    const BrickMapStrategyFactory = require("bar").BrickMapStrategyFactory;

    const brickMapStrategyFactory = new BrickMapStrategyFactory();
    const keySSIFactory = require('./lib/KeySSIs/KeySSIFactory');

    options.dsuFactory =  new DSUFactory({
        brickMapStrategyFactory,
        keySSIFactory
    });

    const keySSIResolver = new KeySSIResolver(options);

    return keySSIResolver;
}

module.exports = {
    initialize,
    KeySSIFactory: require('./lib/KeySSIs/KeySSIFactory'),
    CryptoAlgorithmsRegistry: require('./lib/CryptoAlgorithms/CryptoAlgorithmsRegistry'),
    CryptoFunctionTypes: require('./lib/CryptoAlgorithms/CryptoFunctionTypes'),
    SSITypes: require("./lib/KeySSIs/SSITypes"),
    SSIFamilies: require("./lib/KeySSIs/SSIFamilies"),
    DSUTypes: require("./lib/DSUFactoryRegistry/DSUTypes"),
    DSUFactory: require("./lib/DSUFactoryRegistry"),
    KeySSIMixin: require('./lib/KeySSIs/KeySSIMixin'),
    CryptoAlgorithmsMixin: require('./lib/CryptoAlgorithms/CryptoAlgorithmsMixin')
};

},{"./lib/CryptoAlgorithms/CryptoAlgorithmsMixin":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/key-ssi-resolver/lib/CryptoAlgorithms/CryptoAlgorithmsMixin.js","./lib/CryptoAlgorithms/CryptoAlgorithmsRegistry":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/key-ssi-resolver/lib/CryptoAlgorithms/CryptoAlgorithmsRegistry.js","./lib/CryptoAlgorithms/CryptoFunctionTypes":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/key-ssi-resolver/lib/CryptoAlgorithms/CryptoFunctionTypes.js","./lib/DSUFactoryRegistry":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/key-ssi-resolver/lib/DSUFactoryRegistry/index.js","./lib/DSUFactoryRegistry/DSUTypes":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/key-ssi-resolver/lib/DSUFactoryRegistry/DSUTypes.js","./lib/KeySSIResolver":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/key-ssi-resolver/lib/KeySSIResolver.js","./lib/KeySSIs/KeySSIFactory":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/key-ssi-resolver/lib/KeySSIs/KeySSIFactory.js","./lib/KeySSIs/KeySSIMixin":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/key-ssi-resolver/lib/KeySSIs/KeySSIMixin.js","./lib/KeySSIs/SSIFamilies":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/key-ssi-resolver/lib/KeySSIs/SSIFamilies.js","./lib/KeySSIs/SSITypes":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/key-ssi-resolver/lib/KeySSIs/SSITypes.js","bar":"bar"}],"loki-enclave-facade":[function(require,module,exports){
const LightDBServer = require("./LightDBServer");
const LokiEnclaveFacade = require("./LokiEnclaveFacade");

const createLokiEnclaveFacadeInstance = (storage, autoSaveInterval, adaptorConstructorFunction) => {
    return new LokiEnclaveFacade(storage, autoSaveInterval, adaptorConstructorFunction);
}

const createLightDBServerInstance = (config, callback) => {
    return new LightDBServer(config, callback);
}

module.exports = {
    createLokiEnclaveFacadeInstance,
    createLightDBServerInstance,
    Adaptors: require("./adaptors")
}

},{"./LightDBServer":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/loki-enclave-facade/LightDBServer.js","./LokiEnclaveFacade":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/loki-enclave-facade/LokiEnclaveFacade.js","./adaptors":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/loki-enclave-facade/adaptors.js"}],"node-fd-slicer":[function(require,module,exports){
(function (setImmediate){(function (){
var fs = require('fs');
var util = require('util');
var stream = require('stream');
var Readable = stream.Readable;
var Writable = stream.Writable;
var PassThrough = stream.PassThrough;
var Pend = require('./modules/node-pend');
var EventEmitter = require('events').EventEmitter;

exports.createFromBuffer = createFromBuffer;
exports.createFromFd = createFromFd;
exports.BufferSlicer = BufferSlicer;
exports.FdSlicer = FdSlicer;

util.inherits(FdSlicer, EventEmitter);
function FdSlicer(fd, options) {
  options = options || {};
  EventEmitter.call(this);

  this.fd = fd;
  this.pend = new Pend();
  this.pend.max = 1;
  this.refCount = 0;
  this.autoClose = !!options.autoClose;
}

FdSlicer.prototype.read = function(buffer, offset, length, position, callback) {
  var self = this;
  self.pend.go(function(cb) {
    fs.read(self.fd, buffer, offset, length, position, function(err, bytesRead, buffer) {
      cb();
      callback(err, bytesRead, buffer);
    });
  });
};

FdSlicer.prototype.write = function(buffer, offset, length, position, callback) {
  var self = this;
  self.pend.go(function(cb) {
    fs.write(self.fd, buffer, offset, length, position, function(err, written, buffer) {
      cb();
      callback(err, written, buffer);
    });
  });
};

FdSlicer.prototype.createReadStream = function(options) {
  return new ReadStream(this, options);
};

FdSlicer.prototype.createWriteStream = function(options) {
  return new WriteStream(this, options);
};

FdSlicer.prototype.ref = function() {
  this.refCount += 1;
};

FdSlicer.prototype.unref = function() {
  var self = this;
  self.refCount -= 1;

  if (self.refCount > 0) return;
  if (self.refCount < 0) throw new Error("invalid unref");

  if (self.autoClose) {
    fs.close(self.fd, onCloseDone);
  }

  function onCloseDone(err) {
    if (err) {
      self.emit('error', err);
    } else {
      self.emit('close');
    }
  }
};

util.inherits(ReadStream, Readable);
function ReadStream(context, options) {
  options = options || {};
  Readable.call(this, options);

  this.context = context;
  this.context.ref();

  this.start = options.start || 0;
  this.endOffset = options.end;
  this.pos = this.start;
  this.destroyed = false;
}

ReadStream.prototype._read = function(n) {
  var self = this;
  if (self.destroyed) return;

  var toRead = Math.min(self._readableState.highWaterMark, n);
  if (self.endOffset != null) {
    toRead = Math.min(toRead, self.endOffset - self.pos);
  }
  if (toRead <= 0) {
    self.destroyed = true;
    self.push(null);
    self.context.unref();
    return;
  }
  self.context.pend.go(function(cb) {
    if (self.destroyed) return cb();
    var buffer = new $$.Buffer(toRead);
    fs.read(self.context.fd, buffer, 0, toRead, self.pos, function(err, bytesRead) {
      if (err) {
        self.destroy(err);
      } else if (bytesRead === 0) {
        self.destroyed = true;
        self.push(null);
        self.context.unref();
      } else {
        self.pos += bytesRead;
        self.push(buffer.slice(0, bytesRead));
      }
      cb();
    });
  });
};

ReadStream.prototype.destroy = function(err) {
  if (this.destroyed) return;
  err = err || new Error("stream destroyed");
  this.destroyed = true;
  this.emit('error', err);
  this.context.unref();
};

util.inherits(WriteStream, Writable);
function WriteStream(context, options) {
  options = options || {};
  Writable.call(this, options);

  this.context = context;
  this.context.ref();

  this.start = options.start || 0;
  this.endOffset = (options.end == null) ? Infinity : +options.end;
  this.bytesWritten = 0;
  this.pos = this.start;
  this.destroyed = false;

  this.on('finish', this.destroy.bind(this));
}

WriteStream.prototype._write = function(buffer, encoding, callback) {
  var self = this;
  if (self.destroyed) return;

  if (self.pos + buffer.length > self.endOffset) {
    var err = new Error("maximum file length exceeded");
    err.code = 'ETOOBIG';
    self.destroy();
    callback(err);
    return;
  }
  self.context.pend.go(function(cb) {
    if (self.destroyed) return cb();
    fs.write(self.context.fd, buffer, 0, buffer.length, self.pos, function(err, bytes) {
      if (err) {
        self.destroy();
        cb();
        callback(err);
      } else {
        self.bytesWritten += bytes;
        self.pos += bytes;
        self.emit('progress');
        cb();
        callback();
      }
    });
  });
};

WriteStream.prototype.destroy = function() {
  if (this.destroyed) return;
  this.destroyed = true;
  this.context.unref();
};

util.inherits(BufferSlicer, EventEmitter);
function BufferSlicer(buffer, options) {
  EventEmitter.call(this);

  options = options || {};
  this.refCount = 0;
  this.buffer = buffer;
  this.maxChunkSize = options.maxChunkSize || Number.MAX_SAFE_INTEGER;
}

BufferSlicer.prototype.read = function(buffer, offset, length, position, callback) {
  var end = position + length;
  var delta = end - this.buffer.length;
  var written = (delta > 0) ? delta : length;
  this.buffer.copy(buffer, offset, position, end);
  setImmediate(function() {
    callback(null, written);
  });
};

BufferSlicer.prototype.write = function(buffer, offset, length, position, callback) {
  buffer.copy(this.buffer, position, offset, offset + length);
  setImmediate(function() {
    callback(null, length, buffer);
  });
};

BufferSlicer.prototype.createReadStream = function(options) {
  options = options || {};
  var readStream = new PassThrough(options);
  readStream.destroyed = false;
  readStream.start = options.start || 0;
  readStream.endOffset = options.end;
  // by the time this function returns, we'll be done.
  readStream.pos = readStream.endOffset || this.buffer.length;

  // respect the maxChunkSize option to slice up the chunk into smaller pieces.
  var entireSlice = this.buffer.slice(readStream.start, readStream.pos);
  var offset = 0;
  while (true) {
    var nextOffset = offset + this.maxChunkSize;
    if (nextOffset >= entireSlice.length) {
      // last chunk
      if (offset < entireSlice.length) {
        readStream.write(entireSlice.slice(offset, entireSlice.length));
      }
      break;
    }
    readStream.write(entireSlice.slice(offset, nextOffset));
    offset = nextOffset;
  }

  readStream.end();
  readStream.destroy = function() {
    readStream.destroyed = true;
  };
  return readStream;
};

BufferSlicer.prototype.createWriteStream = function(options) {
  var bufferSlicer = this;
  options = options || {};
  var writeStream = new Writable(options);
  writeStream.start = options.start || 0;
  writeStream.endOffset = (options.end == null) ? this.buffer.length : +options.end;
  writeStream.bytesWritten = 0;
  writeStream.pos = writeStream.start;
  writeStream.destroyed = false;
  writeStream._write = function(buffer, encoding, callback) {
    if (writeStream.destroyed) return;

    var end = writeStream.pos + buffer.length;
    if (end > writeStream.endOffset) {
      var err = new Error("maximum file length exceeded");
      err.code = 'ETOOBIG';
      writeStream.destroyed = true;
      callback(err);
      return;
    }
    buffer.copy(bufferSlicer.buffer, writeStream.pos, 0, buffer.length);

    writeStream.bytesWritten += buffer.length;
    writeStream.pos = end;
    writeStream.emit('progress');
    callback();
  };
  writeStream.destroy = function() {
    writeStream.destroyed = true;
  };
  return writeStream;
};

BufferSlicer.prototype.ref = function() {
  this.refCount += 1;
};

BufferSlicer.prototype.unref = function() {
  this.refCount -= 1;

  if (this.refCount < 0) {
    throw new Error("invalid unref");
  }
};

function createFromBuffer(buffer, options) {
  return new BufferSlicer(buffer, options);
}

function createFromFd(fd, options) {
  return new FdSlicer(fd, options);
}

}).call(this)}).call(this,require("timers").setImmediate)

},{"./modules/node-pend":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/node-fd-slicer/modules/node-pend/index.js","events":false,"fs":false,"stream":false,"timers":false,"util":false}],"opendsu":[function(require,module,exports){
(function (global,setImmediate){(function (){
/*
html API space
*/

let constants = require("./moduleConstants.js");


switch ($$.environmentType) {
    case constants.ENVIRONMENT_TYPES.WEB_WORKER_ENVIRONMENT_TYPE:
    case constants.ENVIRONMENT_TYPES.SERVICE_WORKER_ENVIRONMENT_TYPE:
        if (typeof self !== "undefined") {
            if(!self.PREVENT_DOUBLE_LOADING_OF_OPENDSU) {
                self.PREVENT_DOUBLE_LOADING_OF_OPENDSU = {}
            }
        }
        break;
    case constants.ENVIRONMENT_TYPES.BROWSER_ENVIRONMENT_TYPE:
        if (typeof window !== "undefined") {
            if(!window.PREVENT_DOUBLE_LOADING_OF_OPENDSU){
                window.PREVENT_DOUBLE_LOADING_OF_OPENDSU = {}
            }
        }
        break;
    case constants.ENVIRONMENT_TYPES.NODEJS_ENVIRONMENT_TYPE:
    default:
        if (typeof global !== "undefined") {
            if(!global.PREVENT_DOUBLE_LOADING_OF_OPENDSU){
                global.PREVENT_DOUBLE_LOADING_OF_OPENDSU = {}
            }
            setImmediate(function(){
                require("./w3cdid").initSystemDID();
            })
        }
}

if(!PREVENT_DOUBLE_LOADING_OF_OPENDSU.INITIALISED){
    PREVENT_DOUBLE_LOADING_OF_OPENDSU.INITIALISED = true;
    function loadApi(apiSpaceName){
        switch (apiSpaceName) {
            case "http":return require("./http"); 
            case "crypto":return require("./crypto"); 
            case "apiKey":return require("./apiKey"); 
            case "anchoring":return require("./anchoring"); 
            case "contracts":return require("./contracts"); 
            case "bricking":return require("./bricking"); 
            case "bdns":return require("./bdns"); 
            case "boot":return require("./boot"); 
            case "dc":return require("./dc"); 
            case "dt":return require("./dt"); 
            case "enclave":return require("./enclave"); 
            case "keyssi":return require("./keyssi"); 
            case "mq":return require("./mq/mqClient"); 
            case "notifications":return require("./notifications"); 
            case "oauth":return require("./oauth"); 
            case "resolver":return require("./resolver"); 
            case "sc":return require("./sc"); 
            case "cache":return require("./cache"); 
            case "config":return require("./config"); 
            case "system":return require("./system"); 
            case "utils":return require("./utils"); 
            case "db":return require("./db"); 
            case "w3cdid":return require("./w3cdid"); 
            case "error":return require("./error"); 
            case "m2dsu":return require("./m2dsu"); 
            case "workers":return require("./workers"); 
            case "storage": return require("./storage"); 
            case "credentials": return require("./credentials"); 
            case "lock": return require("./lock"); 
            case "svd": return require("./svd"); 
            default: throw new Error("Unknown API space " + apiSpaceName);
        }
    }

     function setGlobalVariable(name, value){
        switch ($$.environmentType) {
            case constants.ENVIRONMENT_TYPES.WEB_WORKER_ENVIRONMENT_TYPE:
            case constants.ENVIRONMENT_TYPES.SERVICE_WORKER_ENVIRONMENT_TYPE:
                if (typeof self !== "undefined") {
                    self[name] = value;
                } else {
                    reportUserRelevantError("self not defined in Service Workers");
                }
                break;
            case constants.ENVIRONMENT_TYPES.BROWSER_ENVIRONMENT_TYPE:
                if (typeof window !== "undefined") {
                    window[name] = value;
                } else {
                    reportUserRelevantError("window not defined in browser environment");
                }
                break;
            case constants.ENVIRONMENT_TYPES.NODEJS_ENVIRONMENT_TYPE:
            default:
                if (typeof global !== "undefined") {
                    global[name] = value;
                } else {
                    reportUserRelevantError("global not defined in nodejs environment");
                }
        }
    }

    function getGlobalVariable(name){
        switch ($$.environmentType) {
            case constants.ENVIRONMENT_TYPES.WEB_WORKER_ENVIRONMENT_TYPE:
            case constants.ENVIRONMENT_TYPES.SERVICE_WORKER_ENVIRONMENT_TYPE:
                return self[name];
            case constants.ENVIRONMENT_TYPES.BROWSER_ENVIRONMENT_TYPE:
                return window[name];
            case constants.ENVIRONMENT_TYPES.NODEJS_ENVIRONMENT_TYPE:
            default:
                return global[name];
        }
    }

    function globalVariableExists(name){
        switch ($$.environmentType) {
            case constants.ENVIRONMENT_TYPES.WEB_WORKER_ENVIRONMENT_TYPE:
            case constants.ENVIRONMENT_TYPES.SERVICE_WORKER_ENVIRONMENT_TYPE:
                return typeof self[name] != "undefined";
            case constants.ENVIRONMENT_TYPES.BROWSER_ENVIRONMENT_TYPE:
                return typeof window[name] != "undefined";
            case constants.ENVIRONMENT_TYPES.NODEJS_ENVIRONMENT_TYPE:
            default:
                return typeof global[name] != "undefined";
        }
    }

    PREVENT_DOUBLE_LOADING_OF_OPENDSU.loadApi = loadApi;
    PREVENT_DOUBLE_LOADING_OF_OPENDSU.loadAPI = loadApi; //upper case version just
    PREVENT_DOUBLE_LOADING_OF_OPENDSU.globalVariableExists = setGlobalVariable;
    PREVENT_DOUBLE_LOADING_OF_OPENDSU.setGlobalVariable = setGlobalVariable;
    PREVENT_DOUBLE_LOADING_OF_OPENDSU.getGlobalVariable = getGlobalVariable;
    PREVENT_DOUBLE_LOADING_OF_OPENDSU.constants = constants;
    setGlobalVariable("setGlobalVariable",setGlobalVariable);
    setGlobalVariable("getGlobalVariable",getGlobalVariable);
    setGlobalVariable("globalVariableExists",globalVariableExists);
    require("./config/autoConfig");
}
module.exports = PREVENT_DOUBLE_LOADING_OF_OPENDSU;


}).call(this)}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("timers").setImmediate)

},{"./anchoring":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/anchoring/index.js","./apiKey":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/apiKey/index.js","./bdns":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/bdns/index.js","./boot":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/boot/index.js","./bricking":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/bricking/index.js","./cache":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/cache/index.js","./config":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/config/index.js","./config/autoConfig":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/config/autoConfig.js","./contracts":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/contracts/index.js","./credentials":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/credentials/index.js","./crypto":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/crypto/index.js","./db":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/db/index.js","./dc":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/dc/index.js","./dt":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/dt/index.js","./enclave":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/enclave/index.js","./error":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/error/index.js","./http":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/http/index.js","./keyssi":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/keyssi/index.js","./lock":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/lock/index.js","./m2dsu":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/m2dsu/index.js","./moduleConstants.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/moduleConstants.js","./mq/mqClient":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/mq/mqClient.js","./notifications":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/notifications/index.js","./oauth":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/oauth/index.js","./resolver":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/resolver/index.js","./sc":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/sc/index.js","./storage":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/storage/index.js","./svd":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/svd/index.js","./system":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/system/index.js","./utils":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/utils/index.js","./w3cdid":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/w3cdid/index.js","./workers":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/opendsu/workers/index.js","timers":false}],"overwrite-require":[function(require,module,exports){
(function (global){(function (){
/*
 require and $$.require are overwriting the node.js defaults in loading modules for increasing security, speed and making it work to the privatesky runtime build with browserify.
 The privatesky code for domains should work in node and browsers.
 */
function enableForEnvironment(envType) {

    const moduleConstants = require("./src/moduleConstants");

    /**
     * Used to provide autocomplete for $$ variables
     * @classdesc Interface for $$ object
     *
     * @name $$
     * @class
     *
     */

    switch (envType) {
        case moduleConstants.BROWSER_ENVIRONMENT_TYPE :
            global = window;
            break;
        case moduleConstants.WEB_WORKER_ENVIRONMENT_TYPE:
        case moduleConstants.SERVICE_WORKER_ENVIRONMENT_TYPE:
            global = self;
            break;
        default:
            Error.stackTraceLimit = Infinity;
    }

    if (typeof (global.$$) == "undefined") {
        /**
         * Used to provide autocomplete for $$ variables
         * @type {$$}
         */
        global.$$ = {};
    }

    if (typeof ($$.__global) == "undefined") {
        $$.__global = {};
    }

    if (typeof global.wprint === "undefined") {
        global.wprint = console.warn;
    }
    Object.defineProperty($$, "environmentType", {
        get: function () {
            return envType;
        },
        set: function (value) {
            throw Error(`Trying to set env value: ${value}. Environment type already set!`);
        }
    });


    if (typeof ($$.__global.requireLibrariesNames) == "undefined") {
        $$.__global.currentLibraryName = null;
        $$.__global.requireLibrariesNames = {};
    }


    if (typeof ($$.__runtimeModules) == "undefined") {
        $$.__runtimeModules = {};
    }


    if (typeof (global.functionUndefined) == "undefined") {
        global.functionUndefined = function () {
            console.log("Called of an undefined function!!!!");
            throw new Error("Called of an undefined function");
        };
    }

    const pastRequests = {};

    function preventRecursiveRequire(request) {
        if (pastRequests[request]) {
            const err = new Error("Preventing recursive require for " + request);
            err.type = "PSKIgnorableError";
            throw err;
        }

    }

    function disableRequire(request) {
        pastRequests[request] = true;
    }

    function enableRequire(request) {
        pastRequests[request] = false;
    }

    function requireFromCache(request) {
        return $$.__runtimeModules[request];
    }

    $$.__registerModule = function (name, module) {
        $$.__runtimeModules[name] = module;
    }

    function wrapStep(callbackName) {
        const callback = global[callbackName];

        if (callback === undefined) {
            return null;
        }

        if (callback === global.functionUndefined) {
            return null;
        }

        return function (request) {
            const result = callback(request);
            $$.__runtimeModules[request] = result;
            return result;
        }
    }


    function tryRequireSequence(originalRequire, request) {
        let arr;
        if (originalRequire) {
            arr = $$.__requireFunctionsChain.slice();
            arr.push(originalRequire);
        } else {
            arr = $$.__requireFunctionsChain;
        }

        preventRecursiveRequire(request);
        disableRequire(request);
        let result;
        const previousRequire = $$.__global.currentLibraryName;
        let previousRequireChanged = false;

        if (!previousRequire) {
            // console.log("Loading library for require", request);
            $$.__global.currentLibraryName = request;

            if (typeof $$.__global.requireLibrariesNames[request] == "undefined") {
                $$.__global.requireLibrariesNames[request] = {};
                //$$.__global.requireLibrariesDescriptions[request]   = {};
            }
            previousRequireChanged = true;
        }
        for (let i = 0; i < arr.length; i++) {
            const func = arr[i];
            try {

                if (func === global.functionUndefined) continue;
                result = func(request);

                if (result) {
                    break;
                }

            } catch (err) {
                if (err.type !== "PSKIgnorableError") {
                    if (err instanceof SyntaxError) {
                        console.error(err);
                    } else {
                        if (request === 'zeromq') {
                            console.warn("Failed to load module ", request, " with error:", err.message);
                        } else {
                            console.error("Failed to load module ", request, " with error:", err);
                        }
                    }
                    //$$.err("Require encountered an error while loading ", request, "\nCause:\n", err.stack);
                }
            }
        }

        if (!result) {
            throw Error(`Failed to load module ${request}`);
        }

        enableRequire(request);
        if (previousRequireChanged) {
            //console.log("End loading library for require", request, $$.__global.requireLibrariesNames[request]);
            $$.__global.currentLibraryName = null;
        }
        return result;
    }

    function makeBrowserRequire() {
        console.log("Defining global require in browser");


        global.require = function (request) {

            ///*[requireFromCache, wrapStep(webshimsRequire), , wrapStep(pskruntimeRequire), wrapStep(domainRequire)*]
            return tryRequireSequence(null, request);
        }
    }

    function makeIsolateRequire() {
        // require should be provided when code is loaded in browserify
        //const bundleRequire = require;

        $$.requireBundle('sandboxBase');
        // this should be set up by sandbox prior to
        const sandboxRequire = global.require;
        const cryptoModuleName = 'crypto';
        global.crypto = require(cryptoModuleName);

        function newLoader(request) {
            // console.log("newLoader:", request);
            //preventRecursiveRequire(request);
            const self = this;

            // console.log('trying to load ', request);

            function tryBundleRequire(...args) {
                //return $$.__originalRequire.apply(self,args);
                //return Module._load.apply(self,args)
                let res;
                try {
                    res = sandboxRequire.apply(self, args);
                } catch (err) {
                    if (err.code === "MODULE_NOT_FOUND") {
                        const p = path.join(process.cwd(), request);
                        res = sandboxRequire.apply(self, [p]);
                        request = p;
                    } else {
                        throw err;
                    }
                }
                return res;
            }

            let res;


            res = tryRequireSequence(tryBundleRequire, request);


            return res;
        }

        global.require = newLoader;
    }

    function makeNodeJSRequire() {
        const pathModuleName = 'path';
        const path = require(pathModuleName);
        const cryptoModuleName = 'crypto';
        const utilModuleName = 'util';
        $$.__runtimeModules["crypto"] = require(cryptoModuleName);
        $$.__runtimeModules["util"] = require(utilModuleName);

        const moduleModuleName = 'module';
        const Module = require(moduleModuleName);
        $$.__runtimeModules["module"] = Module;

        console.log("Redefining require for node");

        $$.__originalRequire = Module._load;
        const moduleOriginalRequire = Module.prototype.require;

        function newLoader(request) {
            // console.log("newLoader:", request);
            //preventRecursiveRequire(request);
            const self = this;

            function originalRequire(...args) {
                //return $$.__originalRequire.apply(self,args);
                //return Module._load.apply(self,args)
                let res;
                try {
                    res = moduleOriginalRequire.apply(self, args);
                } catch (err) {
                    if (err.code === "MODULE_NOT_FOUND") {
                        let pathOrName = request;
                        if (pathOrName.startsWith('/') || pathOrName.startsWith('./') || pathOrName.startsWith('../')) {
                            pathOrName = path.join(process.cwd(), request);
                        }
                        res = moduleOriginalRequire.call(self, pathOrName);
                        request = pathOrName;
                    } else {
                        throw err;
                    }
                }
                return res;
            }

            //[requireFromCache, wrapStep(pskruntimeRequire), wrapStep(domainRequire), originalRequire]
            return tryRequireSequence(originalRequire, request);
        }

        Module.prototype.require = newLoader;
        return newLoader;
    }

    require("./src/standardGlobalSymbols.js");

    if (typeof ($$.require) == "undefined") {

        $$.__requireList = ["webshimsRequire"];
        $$.__requireFunctionsChain = [];

        $$.requireBundle = function (name) {
            name += "Require";
            $$.__requireList.push(name);
            const arr = [requireFromCache];
            $$.__requireList.forEach(function (item) {
                const callback = wrapStep(item);
                if (callback) {
                    arr.push(callback);
                }
            });

            $$.__requireFunctionsChain = arr;
        };

        $$.requireBundle("init");

        switch ($$.environmentType) {
            case moduleConstants.BROWSER_ENVIRONMENT_TYPE:
                makeBrowserRequire();
                $$.require = require;
                let possibleRedirects = [301, 302];
                $$.httpUnknownResponseGlobalHandler = function (res) {
                    console.log("Global handler for unknown http errors was called", res.status, res);
                    if (res.status && possibleRedirects.indexOf(res.status) !== -1) {
                        window.location = "/";
                        return;
                    }
                };
                break;
            case moduleConstants.WEB_WORKER_ENVIRONMENT_TYPE:
                makeBrowserRequire();
                $$.require = require;
                break;
            case moduleConstants.SERVICE_WORKER_ENVIRONMENT_TYPE:
                makeBrowserRequire();
                $$.require = require;
                break;
            case moduleConstants.ISOLATE_ENVIRONMENT_TYPE:
                makeIsolateRequire();
                $$.require = require;
                break;
            default:
                $$.require = makeNodeJSRequire();
        }

    }

    $$.promisify = function promisify(fn, instance) {
        const promisifiedFn = function (...args) {
            return new Promise((resolve, reject) => {
                if (instance) {
                    fn = fn.bind(instance);
                }
                fn(...args, (err, ...res) => {
                    if (err) {
                        reject(err);
                    } else {
                        resolve(...res);
                    }
                });
            });
        };
        if (promisifiedFn.toString() === fn.toString()) {
            console.log("Function already promisified");
            return fn;
        }
        return promisifiedFn;
    };

    $$.callAsync = async function (func, ...args) {
        let error, result;
        try {
            result = await func(...args);
        } catch (err) {
            error = err
        }
        return [error, result];
    }

    $$.call = async function (func, ...args) {
        let asyncFunc = $$.promisify(func);
        return $$.callAsync(asyncFunc, ...args);
    }

    $$.makeSaneCallback = function makeSaneCallback(fn) {
        let alreadyCalled = false;
        let prevErr;
        if (fn.alreadyWrapped) {
            return fn;
        }

        const newFn = (err, res, ...args) => {
            if (alreadyCalled) {
                if (err) {
                    console.log('Sane callback error:', err);
                }

                throw new Error(`Callback called 2 times! Second call was stopped. Function code:\n${fn.toString()}\n` + (prevErr ? `Previous error stack ${prevErr.toString()}` : ''));
            }
            alreadyCalled = true;
            if (err) {
                prevErr = err;
            }
            return fn(err, res, ...args);
        };

        newFn.alreadyWrapped = true;
        return newFn;
    };

    function DebugHelper() {
        let debugEnabled = false;
        let debugEvents = [];
        let eventsStack = [];

        function getStackTrace() {
            return new Error().stack;
        }

        this.start = function () {
            debugEnabled = true;
        }

        this.resume = this.start;

        this.reset = function () {
            debugEnabled = true;
            let debugEvents = [];
            let eventsStack = [];
        }

        this.stop = function () {
            debugEnabled = false;
        }

        this.logDSUEvent = function (dsu, ...args) {
            if (!debugEnabled) return;

            let anchorID, dsuInstanceUID;
            try {
                anchorID = dsu.getAnchorIdSync();
                anchorID = anchorID.substring(4, 27) + "...";
            } catch (err) {
                anchorID = "N/A";
            }

            try {
                dsuInstanceUID = dsu.getInstanceUID();
            } catch (err) {
                dsuInstanceUID = "N/A";
            }
            this.log(`[${anchorID}][${dsuInstanceUID}]`, ...args);
        }

        this.log = function (...args) {
            console.debug(...args);
            if (!debugEnabled) return;
            debugEvents.push(`Log #${debugEvents.length}` + [...args].join(" "));
            eventsStack.push(getStackTrace());
        }

        this.logs = function () {
            console.log(`${debugEvents.length} events logged`);
            console.log(debugEvents.join("\n"));
        }

        this.context = function (eventNumber) {
            let realNumber = eventNumber;
            if (typeof eventNumber == "string") {
                eventNumber = eventNumber.slice(1);
                realNumber = parseInt(eventNumber);
            }
            return console.log(`Event ${debugEvents[eventNumber]}:\n`, eventsStack[realNumber], "\n");
        }

        const errorCodesForStdout = new Set();

        this.useStdoutOnceForErrorWithCode = function (code) {
            errorCodesForStdout.add(code);
        }

        this.useStderrForErrorWithCode = function (code) {
            if (errorCodesForStdout.has(code)) {
                errorCodesForStdout.delete(code);
            }
        }

        this.errorWithCodeShouldBeRedirectedToStdout = function (code) {
            if (errorCodesForStdout.has(code)) {
                return true;
            }

            return false;
        }

        let verbosityLevel;
        this.verbosity = function (level) {
            verbosityLevel = level;
        }

        this.getVerbosityLevel = function () {
            return verbosityLevel;
        }
    }

    $$.debug = new DebugHelper();
    $$.getLogger = require("./src/Logger").getLogger;
}


module.exports = {
    enableForEnvironment,
    constants: require("./src/moduleConstants")
};

}).call(this)}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./src/Logger":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/overwrite-require/src/Logger.js","./src/moduleConstants":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/overwrite-require/src/moduleConstants.js","./src/standardGlobalSymbols.js":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/overwrite-require/src/standardGlobalSymbols.js"}],"psk-cache":[function(require,module,exports){
const Cache = require("./lib/Cache")
let cacheInstance;

module.exports = {

    /**
     * Create a new cache instance
     *
     * @param {object} options
     * @param {Number} options.maxLevels Number of storage levels. Defaults to 3
     * @param {Number} options.limit Number of max items the cache can store per level.
     *                               Defaults to 1000
     * @return {Cache}
     */
    factory: function (options) {
        return new Cache(options);
    },

    /**
     * Get a reference to a singleton cache instance
     *
     * @param {object} options
     * @param {Number} options.maxLevels Number of storage levels. Defaults to 3
     * @param {Number} options.limit Number of max items the cache can store per level.
     *                               Defaults to 1000
     * @return {Cache}
     */
    getDefaultInstance: function (options) {
        if (!cacheInstance) {
            cacheInstance = new Cache(options);
        }

        return cacheInstance;
    }
};

},{"./lib/Cache":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/psk-cache/lib/Cache.js"}],"psk-http-client":[function(require,module,exports){
//to look nice the requireModule on Node
require("./lib/psk-abstract-client");
const or = require('overwrite-require');
if ($$.environmentType === or.constants.BROWSER_ENVIRONMENT_TYPE) {
	require("./lib/psk-browser-client");
} else {
	require("./lib/psk-node-client");
}
},{"./lib/psk-abstract-client":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/psk-http-client/lib/psk-abstract-client.js","./lib/psk-browser-client":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/psk-http-client/lib/psk-browser-client.js","./lib/psk-node-client":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/psk-http-client/lib/psk-node-client.js","overwrite-require":"overwrite-require"}],"pskcrypto":[function(require,module,exports){
const PskCrypto = require("./lib/PskCrypto");
const ssutil = require("./signsensusDS/ssutil");

module.exports = PskCrypto;

module.exports.hashValues = ssutil.hashValues;

module.exports.DuplexStream = require("./lib/utils/DuplexStream");

module.exports.isStream = require("./lib/utils/isStream");
},{"./lib/PskCrypto":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/lib/PskCrypto.js","./lib/utils/DuplexStream":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/lib/utils/DuplexStream.js","./lib/utils/isStream":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/lib/utils/isStream.js","./signsensusDS/ssutil":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/pskcrypto/signsensusDS/ssutil.js"}],"queue":[function(require,module,exports){
function QueueElement(content) {
	this.content = content;
	this.next = null;
}

function Queue() {
	this.head = null;
	this.tail = null;
	this.length = 0;
	this.push = function (value) {
		const newElement = new QueueElement(value);
		if (!this.head) {
			this.head = newElement;
			this.tail = newElement;
		} else {
			this.tail.next = newElement;
			this.tail = newElement;
		}
		this.length++;
	};

	this.pop = function () {
		if (!this.head) {
			return null;
		}
		const headCopy = this.head;
		this.head = this.head.next;
		this.length--;

		//fix???????
		if(this.length === 0){
            this.tail = null;
		}

		return headCopy.content;
	};

	this.front = function () {
		return this.head ? this.head.content : undefined;
	};

	this.isEmpty = function () {
		return this.head === null;
	};

	this[Symbol.iterator] = function* () {
		let head = this.head;
		while(head !== null) {
			yield head.content;
			head = head.next;
		}
	}.bind(this);
}

Queue.prototype.toString = function () {
	let stringifiedQueue = '';
	let iterator = this.head;
	while (iterator) {
		stringifiedQueue += `${JSON.stringify(iterator.content)} `;
		iterator = iterator.next;
	}
	return stringifiedQueue;
};

Queue.prototype.inspect = Queue.prototype.toString;

module.exports = Queue;

},{}],"soundpubsub":[function(require,module,exports){
module.exports = {
					soundPubSub: require("./lib/soundPubSub").soundPubSub
};
},{"./lib/soundPubSub":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/soundpubsub/lib/soundPubSub.js"}],"swarmutils":[function(require,module,exports){

let cachedUIDGenerator = undefined;
let cachedSafeUid = undefined;

function initCache(){
    if(cachedUIDGenerator === undefined){
        cachedUIDGenerator = require("./lib/uidGenerator").createUidGenerator(200, 32);
        let  sfuid = require("./lib/safe-uuid");
        sfuid.init(cachedUIDGenerator);
        cachedSafeUid = sfuid.safe_uuid;
    }
}

module.exports = {
    get generateUid(){
        initCache();
        return cachedUIDGenerator.generateUid;
    },
     safe_uuid: function(){
         initCache();
         return cachedSafeUid();
    }
};

module.exports.OwM = require("./lib/OwM");
module.exports.beesHealer = require("./lib/beesHealer");
module.exports.Queue = require("./lib/Queue");
module.exports.combos = require("./lib/Combos");
module.exports.TaskCounter = require("./lib/TaskCounter");
module.exports.SwarmPacker = require("./lib/SwarmPacker");
module.exports.path = require("./lib/path");
module.exports.createPskConsole = function () {
    return require('./lib/pskconsole');
};

module.exports.pingPongFork = require('./lib/pingpongFork');


module.exports.ensureIsBuffer = function (data) {
    if ($$.Buffer.isBuffer(data)) {
        return data;
    }
    let buffer;
    if (ArrayBuffer.isView(data)) {
        buffer = $$.Buffer.from(data.buffer)
    } else {
        buffer = $$.Buffer.from(data);
    }
    return buffer;
}

module.exports.removeDir = require("./lib/removeDir").removeDir;
module.exports.removeDirSync = require("./lib/removeDir").removeDirSync;

},{"./lib/Combos":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/swarmutils/lib/Combos.js","./lib/OwM":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/swarmutils/lib/OwM.js","./lib/Queue":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/swarmutils/lib/Queue.js","./lib/SwarmPacker":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/swarmutils/lib/SwarmPacker.js","./lib/TaskCounter":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/swarmutils/lib/TaskCounter.js","./lib/beesHealer":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/swarmutils/lib/beesHealer.js","./lib/path":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/swarmutils/lib/path.js","./lib/pingpongFork":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/swarmutils/lib/pingpongFork.js","./lib/pskconsole":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/swarmutils/lib/pskconsole.js","./lib/removeDir":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/swarmutils/lib/removeDir.js","./lib/safe-uuid":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/swarmutils/lib/safe-uuid.js","./lib/uidGenerator":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/swarmutils/lib/uidGenerator.js"}],"syndicate":[function(require,module,exports){
const PoolConfig = require('./lib/PoolConfig');
const WorkerPool = require('./lib/WorkerPool');
const WorkerStrategies = require('./lib/WorkerStrategies');

let registry = {};
function registerWorkerStrategy(strategyName, constructor){
    registry[strategyName] = constructor;
}

function getWorkerStrategy(strategyName){
    return registry[strategyName];
}

/**
 * @throws if config is invalid, if config tries to set properties to undefined or add new properties (check PoolConfig to see solutions)
 * @throws if providing a working dir that does not exist, the directory should be created externally
 * @throws if trying to use a strategy that does not exist
 */
function createWorkerPool(poolConfig, workerCreateHelper) {
    const newPoolConfig = PoolConfig.createByOverwritingDefaults(poolConfig);
    /*
    TODO: why do we need to check this here? :-??

    const fs = require('fs');
    const path = require('path');
    if (newPoolConfig.workerOptions && newPoolConfig.workerOptions.cwd && !fs.existsSync(newPoolConfig.workerOptions.cwd)) {
        throw new Error(`The provided working directory does not exists ${config.workingDir}`);
    }*/

    let workerStrategy = getWorkerStrategy(newPoolConfig.workerStrategy);
    if(typeof workerStrategy === "undefined"){
        throw new TypeError(`Could not find a implementation for worker strategy "${newPoolConfig.workerStrategy}"`);
    }

    let concretePool = new workerStrategy(newPoolConfig, workerCreateHelper);

    return new WorkerPool(concretePool);
}

const PoolIsolates = require('./lib/Pool-Isolates');
registerWorkerStrategy(WorkerStrategies.ISOLATES, PoolIsolates);

const PoolThreads = require('./lib/Pool-Threads');
registerWorkerStrategy(WorkerStrategies.THREADS, PoolThreads);

const PoolWebWorkers = require('./lib/Pool-Web-Workers');
registerWorkerStrategy(WorkerStrategies.WEB_WORKERS, PoolWebWorkers);

module.exports = {
    createWorkerPool,
    PoolConfig,
    WorkerStrategies,
    registerWorkerStrategy
};

},{"./lib/Pool-Isolates":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/syndicate/lib/Pool-Isolates.js","./lib/Pool-Threads":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/syndicate/lib/Pool-Threads.js","./lib/Pool-Web-Workers":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/syndicate/lib/Pool-Web-Workers.js","./lib/PoolConfig":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/syndicate/lib/PoolConfig.js","./lib/WorkerPool":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/syndicate/lib/WorkerPool.js","./lib/WorkerStrategies":"/home/runner/work/opendsu-sdk/opendsu-sdk/modules/syndicate/lib/WorkerStrategies.js"}]},{},["/home/runner/work/opendsu-sdk/opendsu-sdk/builds/tmp/pskWebServer.js"])
                    ;(function(global) {
                        global.bundlePaths = {"pskWebServer":"builds/output/pskWebServer.js","openDSU":"builds/output/openDSU.js","nodeBoot":"builds/output/nodeBoot.js","loaderBoot":"builds/output/loaderBoot.js","testsRuntime":"builds/output/testsRuntime.js","bindableModel":"builds/output/bindableModel.js","iframeBoot":"builds/output/iframeBoot.js","versionLessBoot":"builds/output/versionLessBoot.js","testRunnerBoot":"builds/output/testRunnerBoot.js"};
                    })(typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {});
                
testsRuntimeRequire=(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/builds/tmp/testsRuntime.js":[function(require,module,exports){
const or = require('overwrite-require');
or.enableForEnvironment(or.constants.NODEJS_ENVIRONMENT_TYPE);
require("./testsRuntime_intermediar");
require("double-check");
},{"./testsRuntime_intermediar":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/builds/tmp/testsRuntime_intermediar.js","double-check":"double-check","overwrite-require":"overwrite-require"}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/builds/tmp/testsRuntime_intermediar.js":[function(require,module,exports){
(function (global){(function (){
global.testsRuntimeLoadModules = function(){ 

	if(typeof $$.__runtimeModules["overwrite-require"] === "undefined"){
		$$.__runtimeModules["overwrite-require"] = require("overwrite-require");
	}

	if(typeof $$.__runtimeModules["opendsu"] === "undefined"){
		$$.__runtimeModules["opendsu"] = require("opendsu");
	}

	if(typeof $$.__runtimeModules["pskcrypto"] === "undefined"){
		$$.__runtimeModules["pskcrypto"] = require("pskcrypto");
	}

	if(typeof $$.__runtimeModules["psk-cache"] === "undefined"){
		$$.__runtimeModules["psk-cache"] = require("psk-cache");
	}

	if(typeof $$.__runtimeModules["double-check"] === "undefined"){
		$$.__runtimeModules["double-check"] = require("double-check");
	}

	if(typeof $$.__runtimeModules["blockchain"] === "undefined"){
		$$.__runtimeModules["blockchain"] = require("blockchain");
	}

	if(typeof $$.__runtimeModules["swarmutils"] === "undefined"){
		$$.__runtimeModules["swarmutils"] = require("swarmutils");
	}

	if(typeof $$.__runtimeModules["queue"] === "undefined"){
		$$.__runtimeModules["queue"] = require("queue");
	}

	if(typeof $$.__runtimeModules["soundpubsub"] === "undefined"){
		$$.__runtimeModules["soundpubsub"] = require("soundpubsub");
	}

	if(typeof $$.__runtimeModules["dossier"] === "undefined"){
		$$.__runtimeModules["dossier"] = require("dossier");
	}

	if(typeof $$.__runtimeModules["swarm-engine"] === "undefined"){
		$$.__runtimeModules["swarm-engine"] = require("swarm-engine");
	}

	if(typeof $$.__runtimeModules["key-ssi-resolver"] === "undefined"){
		$$.__runtimeModules["key-ssi-resolver"] = require("key-ssi-resolver");
	}

	if(typeof $$.__runtimeModules["buffer-crc32"] === "undefined"){
		$$.__runtimeModules["buffer-crc32"] = require("buffer-crc32");
	}

	if(typeof $$.__runtimeModules["bar"] === "undefined"){
		$$.__runtimeModules["bar"] = require("bar");
	}

	if(typeof $$.__runtimeModules["bar-fs-adapter"] === "undefined"){
		$$.__runtimeModules["bar-fs-adapter"] = require("bar-fs-adapter");
	}

	if(typeof $$.__runtimeModules["callflow"] === "undefined"){
		$$.__runtimeModules["callflow"] = require("callflow");
	}

	if(typeof $$.__runtimeModules["blockchain"] === "undefined"){
		$$.__runtimeModules["blockchain"] = require("blockchain");
	}

	if(typeof $$.__runtimeModules["syndicate"] === "undefined"){
		$$.__runtimeModules["syndicate"] = require("syndicate");
	}

	if(typeof $$.__runtimeModules["apihub"] === "undefined"){
		$$.__runtimeModules["apihub"] = require("apihub");
	}

	if(typeof $$.__runtimeModules["bricksledger"] === "undefined"){
		$$.__runtimeModules["bricksledger"] = require("bricksledger");
	}

	if(typeof $$.__runtimeModules["dsu-wizard"] === "undefined"){
		$$.__runtimeModules["dsu-wizard"] = require("dsu-wizard");
	}

	if(typeof $$.__runtimeModules["loki-enclave-facade"] === "undefined"){
		$$.__runtimeModules["loki-enclave-facade"] = require("loki-enclave-facade");
	}
};
if (false) {
	testsRuntimeLoadModules();
}
global.testsRuntimeRequire = require;
if (typeof $$ !== "undefined") {
	$$.requireBundle("testsRuntime");
}

}).call(this)}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"apihub":"apihub","bar":"bar","bar-fs-adapter":"bar-fs-adapter","blockchain":"blockchain","bricksledger":"bricksledger","buffer-crc32":"buffer-crc32","callflow":"callflow","dossier":"dossier","double-check":"double-check","dsu-wizard":"dsu-wizard","key-ssi-resolver":"key-ssi-resolver","loki-enclave-facade":"loki-enclave-facade","opendsu":"opendsu","overwrite-require":"overwrite-require","psk-cache":"psk-cache","pskcrypto":"pskcrypto","queue":"queue","soundpubsub":"soundpubsub","swarm-engine":"swarm-engine","swarmutils":"swarmutils","syndicate":"syndicate"}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/apihub/components/admin/index.js":[function(require,module,exports){
const DATABASE_NAME = "adminEnclave";

const DOMAINS_TABLE = "domains";
const ADMINS_TABLE = "admins";
const VARIABLES_TABLE = "variables";
const TEMPLATES_TABLE = "templates";

const DID_replacement = "";

let internalServerRef;

function getStorageFolder() {
    const config = internalServerRef.config;

    return require("path").join(internalServerRef.rootFolder, config.componentsConfig.admin.storageFolder);
}

function getMainDomainStorageFile() {
    const storageFolder = getStorageFolder();
    return require("path").join(storageFolder, "mainDomain");
}

function getEnclave() {
    const storageFolder = require("path").join(getStorageFolder(), DATABASE_NAME);
    const Enclave = require("loki-enclave-facade");
    return new Enclave(storageFolder);
}

function getMainDomain(callback) {
    const FS = "fs";
    const fs = require(FS);
    fs.readFile(getMainDomainStorageFile(), callback);
}

function saveMainDomain(domain, callback) {
    getMainDomain((err, mainDomain) => {
        if (err || !mainDomain) {
            const FS = "fs";
            const fs = require(FS);
            fs.mkdir(getStorageFolder(), {recursive: true}, (err) => {
                if (err) {
                    return callback(err);
                }
                fs.writeFile(getMainDomainStorageFile(), domain, {}, callback);
            });
        } else {
            return callback(`There is a domain set as mainDomain. Not able to save <${domain}> as main domain.`);
        }
    });
}

function isMainDomain(domain, callback) {
    getMainDomain((err, mainDomain) => {
        if (err || !mainDomain) {
            return saveMainDomain(domain, (err) => {
                if (err) {
                    return callback(err);
                }
                callback(undefined, true);
            });
        }
        return callback(undefined, mainDomain.toString() === domain);
    });
}

function AdminComponentHandler(server) {

    internalServerRef = server;

    let adminService = new AdminService(true);

    async function enforceMainDomainMiddleware(req, res, next) {
        let {mainDomain} = req.params;
        let testIfMainDomain = $$.promisify(isMainDomain);
        try {
            let isMain = await testIfMainDomain(mainDomain);
            if (!isMain) {
                res.statusCode = 403;
                return res.end();
            }
        } catch (err) {
            res.statusCode = 500;
            return res.end();
        }
        next();
    }

    async function addDomain(req, res) {
        let {domainName, timestamp, signature, cloneFromDomain} = req.body;

        if (!cloneFromDomain) {
            res.statusCode = 403;
            res.end();
        }

        try {
            await adminService.addDomainAsync(domainName, cloneFromDomain, timestamp, signature);
        } catch (err) {
            res.statusCode = 500;
            return res.end();
        }

        res.statusCode = 200;
        res.end();
    }

    async function disableDomain(req, res) {
        let {domainName, timestamp, signature} = req.body;
        try {
            await adminService.disableDomainAsync(domainName, timestamp, signature);
        } catch (err) {
            res.statusCode = 500;
            return res.end();
        }

        res.statusCode = 200;
        res.end();
    }

    async function addAdmin(req, res) {
        let {did, timestamp, signature} = req.body;

        try {
            await adminService.registerAdminAsync(did, timestamp, signature);
        } catch (err) {
            res.statusCode = 500;
            return res.end();
        }

        res.statusCode = 200;
        res.end();
    }

    async function addDomainAdmin(req, res) {
        let {domain, did, timestamp, signature} = req.body;

        try {
            await adminService.registerDomainAdminAsync(domain, did, timestamp, signature);
        } catch (err) {
            res.statusCode = 500;
            return res.end();
        }

        res.statusCode = 200;
        res.end();
    }

    async function registerTemplate(req, res) {
        let {path, content, timestamp, signature} = req.body;
        try {
            await adminService.registerTemplateAsync(path, content, timestamp, signature);
        } catch (err) {
            res.statusCode = 500;
            return res.end();
        }

        res.statusCode = 200;
        res.end();
    }

    async function setVariable(req, res) {
        let {dnsDomain, variableName, variableContent, timestamp, signature} = req.body;

        try {
            await adminService.registerVariableAsync(dnsDomain, variableName, variableContent, timestamp, signature);
        } catch (err) {
            res.statusCode = 500;
            return res.end();
        }

        res.statusCode = 200;
        res.end();
    }

    server.use("/admin/:mainDomain/*", enforceMainDomainMiddleware);

    server.use("/admin/*", require("./../../utils/middlewares/index").requestBodyJSONMiddleware);

    server.post("/admin/:mainDomain/addDomain", addDomain);
    server.post("/admin/:mainDomain/disableDomain", disableDomain);
    server.post("/admin/:mainDomain/addAdmin", addAdmin);
    server.post("/admin/:mainDomain/addDomainAdmin", addDomainAdmin);
    server.post("/admin/:mainDomain/storeVariable", setVariable);
    server.post("/admin/:mainDomain/registerTemplate", registerTemplate);
}

function AdminService(exposeAllApis) {
    const enclave = getEnclave();

    this.getDomains = function (callback) {
        enclave.getAllRecords(DID_replacement, DOMAINS_TABLE, callback);
    }

    this.getDomainInfo = function (domainName, callback) {
        enclave.getRecord(DID_replacement, DOMAINS_TABLE, domainName, (err, domainInfo) => {
            //cleanup domain obj before returning it
            return callback(err, domainInfo);
        });
    }

    this.getMainDomain = getMainDomain;

    this.checkForTemplate = function (path, callback) {
        enclave.getRecord(DID_replacement, TEMPLATES_TABLE, path, (err, template) => {
            //cleanup template obj before returning it
            return callback(err, template);
        });
    }

    this.checkIfAdmin = function (did, callback) {
        enclave.getRecord(DID_replacement, ADMINS_TABLE, did, (err, admin) => {
            if (err || !admin) {
                return callback(undefined, false);
            }
            return callback(undefined, true);
        });
    }

    this.checkIfDomainAdmin = function (domainName, did, callback) {
        enclave.getRecord(DID_replacement, DOMAINS_TABLE, domainName, (err, domain) => {
            if (err || !domain || !domain.admins || domain.admins.indexOf(did) === -1) {
                return callback(undefined, false);
            }

            return callback(undefined, true);
        });
    }

    this.getDomainSpecificVariables = function (dnsDomainName, callback) {
        enclave.getRecord(DID_replacement, VARIABLES_TABLE, dnsDomainName, (err, entry) => {
            if (err) {
                return callback(err);
            }

            if (!entry) {
                return callback(`Not able to find domain ${dnsDomainName}.`);
            }

            return callback(undefined, entry.variables || {});
        });
    }

    //from this line down there are only methods that change the state of the enclave.
    if (exposeAllApis) {
        this.addDomain = async function (domainName, cloneFromDomain, timestamp, signature, callback) {
            enclave.insertRecord(DID_replacement, DOMAINS_TABLE, domainName, {
                name: domainName,
                active: true,
                cloneFromDomain
            }, callback);
        }

        this.addDomainAsync = $$.promisify(this.addDomain);

        this.disableDomain = async function (domainName, timestamp, signature, callback) {
            enclave.updateRecord(DID_replacement, DOMAINS_TABLE, domainName, {
                name: domainName,
                active: false
            }, callback);
        }

        this.disableDomainAsync = $$.promisify(this.disableDomain);

        this.registerAdmin = function (did, timestamp, signature, callback) {
            enclave.insertRecord(DID_replacement, ADMINS_TABLE, did, {did, active: true}, callback);
        }

        this.registerAdminAsync = $$.promisify(this.registerAdmin);

        this.registerDomainAdmin = function (domainName, did, timestamp, signature, callback) {
            enclave.getRecord(DID_replacement, DOMAINS_TABLE, domainName, (err, domain) => {
                if (err) {
                    return callback(err);
                }

                if (!domain.admins) {
                    domain.admins = [];
                }
                domain.admins.push(did);

                enclave.updateRecord(DID_replacement, DOMAINS_TABLE, domainName, domain, callback);
            });
        }

        this.registerDomainAdminAsync = $$.promisify(this.registerDomainAdmin);

        this.registerVariable = function (dnsDomain, variableName, variableContent, timestamp, signature, callback) {
            enclave.getRecord(DID_replacement, VARIABLES_TABLE, dnsDomain, (err, entry) => {
                if (err || !entry) {
                    entry = {
                        variables: {}
                    };
                    entry.variables[variableName] = variableContent;
                    enclave.insertRecord(DID_replacement, VARIABLES_TABLE, dnsDomain, entry, callback);
                }

                if (!entry.variables) {
                    entry.variables = {};
                }

                entry.variables[variableName] = variableContent;

                enclave.updateRecord(DID_replacement, VARIABLES_TABLE, dnsDomain, entry, callback);
            });
        }
        this.registerVariableAsync = $$.promisify(this.registerVariable);

        this.registerTemplate = function (path, content, timestamp, signature, callback) {
            enclave.getRecord(DID_replacement, TEMPLATES_TABLE, path, (err, template) => {
                if (err || !template) {
                    return enclave.insertRecord(DID_replacement, TEMPLATES_TABLE, path, {content}, callback);
                }
                enclave.updateRecord(DID_replacement, TEMPLATES_TABLE, path, {content}, callback);
            })
        }

        this.registerTemplateAsync = $$.promisify(this.registerTemplate);
    }

    return this;
}

function getAdminService() {
    if (!internalServerRef) {
        throw new Error("AdminComponentHandler is not enabled!");
    }

    return new AdminService();
}

module.exports = {
    AdminComponentHandler,
    getAdminService
};
},{"./../../utils/middlewares/index":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/apihub/utils/middlewares/index.js","loki-enclave-facade":"loki-enclave-facade","path":false}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/apihub/components/anchoring/controllers/index.js":[function(require,module,exports){
const {ALIAS_SYNC_ERR_CODE} = require("../utils");
const utils = require("../utils");
const anchoringStrategies = require("../strategies");
const logger = $$.getLogger("apihub", "anchoring");
const getStrategy = async (request) => {
    let receivedDomain;
    let domainConfig;
    if (request.params.anchorId && request.params.domain) {
        try {
            receivedDomain = utils.getDomainFromKeySSI(request.params.anchorId);
        } catch (e) {
            throw Error(`[Anchoring] Unable to parse anchor id`);
        }

        if (receivedDomain !== request.params.domain) {
            throw Error(`[Anchoring] Domain mismatch: '${receivedDomain}' != '${request.params.domain}'`);
        }

        domainConfig = await utils.getAnchoringDomainConfig(receivedDomain);
        if (!domainConfig) {
            throw Error(`[Anchoring] Domain '${receivedDomain}' not found`);
        }
    } else {
        throw Error(`[Anchoring] AnchorId or domain is missing from request.params`);
    }

    const StrategyClass = anchoringStrategies[domainConfig.type];
    if (!StrategyClass) {
        throw Error(`[Anchoring] Strategy for anchoring domain '${domainConfig.type}' not found`);
    }

    let strategy;
    try {
        strategy = new StrategyClass(request.server, domainConfig, request.params.anchorId, request.params.anchorValue, request.body);
    } catch (e) {
        throw Error(`[Anchoring] Unable to initialize anchoring strategy`);
    }

    return strategy;
}

function getWritingHandler(response) {
    return (err) => {
        if (err) {
            const errorMessage = typeof err === "string" ? err : err.message;
            if (err.code === "EACCES") {
                return response.send(409, errorMessage);
            } else if (err.code === ALIAS_SYNC_ERR_CODE || err.statusCode === 428) {
                // see: https://tools.ietf.org/html/rfc6585#section-3
                return response.send(428, errorMessage);
            } else if (err.code === 403) {
                return response.send(403, errorMessage);
            }
            logger.error("Caught an error", JSON.stringify(err));
            return response.send(500, errorMessage);
        }

        response.send(201);
    };
}

async function updateAnchor(action, request, response) {
    let strategy;
    try {
        strategy = await getStrategy(request);
    } catch (e) {
        logger.info(0x01, `Failed to get anchoring strategy`, e);
        return response.send(500, e);
    }
    strategy[action](getWritingHandler(response));
}


function getReadingHandler(response) {
    return (err, result) => {
        if (err) {
            return response.send(500, "Could not retrieve anchor");
        }

        if (!result) {
            logger.info(0x01, `Anchor not found`);
            return response.send(404);
        }

        if (typeof result === "object") {
            response.setHeader("Content-Type", "application/json");
        }

        response.send(200, result);
    }
}

async function readDataForAnchor(action, request, response) {
    let strategy;
    try {
        strategy = await getStrategy(request);
    } catch (e) {
        logger.info(0x01, `Failed to get anchoring strategy`, e);
        return response.send(500, e);
    }
    strategy[action](getReadingHandler(response));
}


function createAnchor(request, response) {
    updateAnchor("createAnchor", request, response);
}

function appendToAnchor(request, response) {
    updateAnchor("appendAnchor", request, response);
}

function createOrUpdateMultipleAnchors(request, response) {
    updateAnchor("createOrUpdateMultipleAnchors", request, response);
}

function getAllVersions(request, response) {
    readDataForAnchor("getAllVersions", request, response);
}

function getLastVersion(request, response) {
    readDataForAnchor("getLastVersion", request, response);
}

function totalNumberOfAnchors(request, response) {
    readDataForAnchor("totalNumberOfAnchors", request, response);
}

function dumpAnchors(request, response) {
    readDataForAnchor("dumpAnchors", request, response);
}


module.exports = {
    createAnchor,
    appendToAnchor,
    createOrUpdateMultipleAnchors,
    getAllVersions,
    getLastVersion,
    totalNumberOfAnchors,
    dumpAnchors
};

},{"../strategies":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/apihub/components/anchoring/strategies/index.js","../utils":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/apihub/components/anchoring/utils/index.js"}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/apihub/components/anchoring/index.js":[function(require,module,exports){

function Anchoring(server) {
    function requestServerMiddleware(request, response, next) {
        request.server = server;
        next();
    }

    const {
        createAnchor,
        appendToAnchor,
        createOrUpdateMultipleAnchors,
        getAllVersions,
        getLastVersion,
        totalNumberOfAnchors,
        dumpAnchors
    } = require("./controllers");

    const {responseModifierMiddleware, requestBodyJSONMiddleware} = require("../../utils/middlewares");
    const {getEthereumSyncServiceSingleton} = require("./strategies/oba/ethereumSyncService");

    const ethSyncService = getEthereumSyncServiceSingleton(server);
    ethSyncService.synchronize();

    server.use(`/anchor/:domain/*`, requestServerMiddleware);
    server.use(`/anchor/:domain/*`, responseModifierMiddleware);

    server.put(`/anchor/:domain/create-anchor/:anchorId`, requestBodyJSONMiddleware);
    server.put(`/anchor/:domain/create-anchor/:anchorId/:anchorValue`, createAnchor);

    server.put(`/anchor/:domain/append-to-anchor/:anchorId`, requestBodyJSONMiddleware);
    server.put(`/anchor/:domain/append-to-anchor/:anchorId/:anchorValue`, appendToAnchor);

    server.put(`/anchor/:domain/create-or-update-multiple-anchors`, requestBodyJSONMiddleware);
    server.put(`/anchor/:domain/create-or-update-multiple-anchors`, createOrUpdateMultipleAnchors);

    server.get(`/anchor/:domain/get-all-versions/:anchorId`, getAllVersions);

    server.get(`/anchor/:domain/get-last-version/:anchorId`, getLastVersion);
}

module.exports = Anchoring;

},{"../../utils/middlewares":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/apihub/utils/middlewares/index.js","./controllers":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/apihub/components/anchoring/controllers/index.js","./strategies/oba/ethereumSyncService":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/apihub/components/anchoring/strategies/oba/ethereumSyncService.js"}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/apihub/components/anchoring/strategies/contract/index.js":[function(require,module,exports){
const { getDomainFromKeySSI } = require("../../utils");

class Contract {
    constructor(server, domainConfig, anchorId, jsonData) {
        this.server = server;
        const domainName = getDomainFromKeySSI(anchorId);
        this.commandData = {};
        this.commandData.option = domainConfig.option;
        this.commandData.domain = domainName;
        this.commandData.anchorId = anchorId;
        this.commandData.jsonData = jsonData || {};
    }

    createAnchor(callback) {
        const { anchorId } = this.commandData;
        this._makeLocalContractRequest("createAnchor", [anchorId], callback);
    }

    createNFT(callback) {
        const { anchorId } = this.commandData;
        this._makeLocalContractRequest("createNFT", [anchorId], callback);
    }

    appendToAnchor(callback) {
        const {
            anchorId,
            jsonData: { hashLinkIds, digitalProof, zkp },
        } = this.commandData;
        this._makeLocalContractRequest("appendToAnchor", [anchorId, hashLinkIds, digitalProof, zkp], callback);
    }

    getAllVersions(callback) {
        const { anchorId } = this.commandData;
        this._makeLocalContractRequest("getAllVersions", [anchorId], callback);
    }

    getLatestVersion(callback) {
        const { anchorId } = this.commandData;
        this._makeLocalContractRequest("getLatestVersion", [anchorId], callback);
    }

    async _makeLocalContractRequest(methodName, methodParams, callback) {
        const { domain } = this.commandData;

        if (typeof methodParams === "function") {
            callback = methodParams;
            methodParams = null;
        }

        const requestMethod = "POST";
        const url = `/contracts/${domain}/safe-command`;
        const contractCommand = JSON.stringify({
            domain,
            contractName: "anchoring",
            methodName,
            params: methodParams,
        });
        const requestHeaders = {
            "Content-Type": "application/json",
            "Content-Length": contractCommand.length,
        };

        try {
            const makeLocalRequest = $$.promisify(this.server.makeLocalRequest.bind(this.server));
            let response = await makeLocalRequest(requestMethod, url, contractCommand, requestHeaders);

            if (response) {
                try {
                    response = JSON.parse(response);
                } catch (error) {
                    // the response isn't a JSON so we keep it as it is
                }

                if (response.optimisticResult) {
                    try {
                        response.optimisticResult = JSON.parse(response.optimisticResult);
                    } catch (error) {
                        // the response isn't a JSON so we keep it as it is
                    }

                    return callback(null, response.optimisticResult);
                }
            }

            callback(null, response);
        } catch (err) {
            console.warn(`[Anchoring] Failed to call method '${method}' for contract 'anchoring' for domain '${domain}'`);
            callback(err);
        }
    }
}

module.exports = Contract;

},{"../../utils":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/apihub/components/anchoring/utils/index.js"}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/apihub/components/anchoring/strategies/eth/index.js":[function(require,module,exports){
const {ALIAS_SYNC_ERR_CODE} = require("../../utils");

function ETH(server, domainConfig, anchorId, newAnchorValue, jsonData) {
    const openDSU = require("opendsu");
    const http = openDSU.loadAPI("http");
    const logger = $$.getLogger("Eth", "apihub/anchoring");
    const createEndpoint = (action) => {
        let endpoint = domainConfig.option.endpoint;

        if (endpoint.endsWith("/")) {
            endpoint = endpoint.slice(0, endpoint.length - 1);
        }
        endpoint = `${endpoint}/${action}`;
        if (anchorId) {
            endpoint = `${endpoint}/${anchorId}`;
        }

        if (newAnchorValue) {
            endpoint = `${endpoint}/${newAnchorValue}`;
        }

        return endpoint;
    }

    const writeToBlockchain = (action, callback) => {
        let options = {};
        let bodyData = "";
        if (jsonData) {
            bodyData = JSON.stringify(jsonData);
            options = {
                headers: {
                    "Content-Type": "application/json", "Content-Length": bodyData.length
                }
            }
        }

        if (domainConfig && domainConfig.useProxy) {
            options.useProxy = domainConfig.useProxy;
        }

        const endpoint = createEndpoint(action);
        http.doPut(endpoint, bodyData, options, (err, result) => {
            if (err) {
                if (err.statusCode === 428) {
                    const error = Error("Unable to add alias: versions out of sync");
                    error.code = ALIAS_SYNC_ERR_CODE;
                    return callback(error);
                }
                logger.error(err);
                callback(err);
                return;
            }
            callback(null, result);
        });
    }

    const readJSONFromBlockchain = (action, callback)=>{
        const endpoint = createEndpoint(action);
        let headers;
        let body = "";
        if (jsonData) {
            body = JSON.stringify(jsonData);
            headers = {
                "Content-Type": "application/json", "Content-Length": body.length
            }
        }
        http.fetch(endpoint, {
            method: 'GET',
            headers, body
        })
            .then(res => res.json())
            .then(data => callback(undefined, data))
            .catch(e => {
                return callback(e);
            });
    }

    const readFromBlockchain = (action, callback) => {
        const endpoint = createEndpoint(action);
        http.fetch(endpoint, {
            method: 'GET'
        })
            .then(res => res.text())
            .then(data => callback(undefined, data))
            .catch(e => {
                return callback(e);
            })
    }

    this.createAnchor = (callback) => {
        writeToBlockchain("createAnchor", callback);
    }

    this.appendAnchor = (callback) => {
        writeToBlockchain("appendAnchor", callback);
    }

    this.createOrUpdateMultipleAnchors = (callback) => {
        writeToBlockchain("createOrUpdateMultipleAnchors", callback);
    }

    this.getAllVersions = (callback) => {
        readJSONFromBlockchain("getAllVersions", callback);
    }

    this.getLastVersion = (callback) => {
        readFromBlockchain("getLastVersion", callback);
    }

    this.totalNumberOfAnchors = (callback) => {
        readFromBlockchain("totalNumberOfAnchors", callback);
    }

    this.dumpAnchors = (callback) => {
        readJSONFromBlockchain("dumpAnchors", callback);
    }
}

module.exports = ETH;
},{"../../utils":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/apihub/components/anchoring/utils/index.js","opendsu":"opendsu"}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/apihub/components/anchoring/strategies/fs/filePersistence.js":[function(require,module,exports){
function FilePersistenceStrategy(rootFolder, configuredPath) {
    const self = this;
    const fileOperations = new FileOperations();
    const FSLock = require("../utils/FSLock");
    const AnchorPathResolver = require("../utils/AnchorPathResolver");
    const anchorPathResolver = new AnchorPathResolver(rootFolder, configuredPath);
    fileOperations.InitializeFolderStructure(rootFolder, configuredPath);

    const fsLocks = {};
    self.prepareAnchoring = (anchorId, callback) => {
        const anchorPath = anchorPathResolver.getAnchorPath(anchorId);
        const fsLock = new FSLock(anchorPath);
        fsLocks[anchorId] = fsLock;
        fsLock.acquireLock(err => {
            if (err) {
                return callback({code: 428, message: "Versions out of sync"})
            }

            callback();
        });
    }

    self.getLastVersion = function (anchorId, callback) {
        fileOperations.isFileNameValid(anchorId, (err) => {
            if (err) {
                return callback(err);
            }
            fileOperations.fileExist(anchorId, (err, exists) => {
                if (err) {
                    return callback(undefined, null);
                }
                if (!exists) {
                    return callback(undefined, null);
                }
                //read the last hashlink for anchorId
                return fileOperations.getlastVersion(anchorId, callback);
            })
        });
    }
    self.getAllVersions = function (anchorId, callback) {
        // read all hashlinks for anchorId
        fileOperations.isFileNameValid(anchorId, (err) => {
            if (err) {
                return callback(err);
            }
            fileOperations.fileExist(anchorId, (err, exists) => {
                if (err) {
                    return callback(undefined, []);
                }
                if (!exists) {
                    return callback(undefined, []);
                }
                //read the last hashlink for anchorId
                return fileOperations.getAllVersions(anchorId, callback);
            })
        });
    }
    self.createAnchor = function (anchorId, anchorValueSSI, callback) {
        fileOperations.isFileNameValid(anchorId, (err) => {
            if (err) {
                return callback(err);
            }
            fileOperations.fileExist(anchorId, (err, exists) => {
                if (err) {
                    return callback(err);
                }
                if (!exists) {
                    //file doesnt exist
                    return fileOperations.createAnchor(anchorId, anchorValueSSI, callback);
                }
                //if anchor exist, return error
                return callback(Error(`anchor ${anchorId} already exist`));
            })
        });
    }
    self.appendAnchor = function (anchorId, anchorValueSSI, callback) {
        const anchorPath = anchorPathResolver.getAnchorPath(anchorId);
        const fsLock = fsLocks[anchorId]
        fsLock.isMyLock((err, isMyLock) => {
            if (err) {
                return callback(err);
            }

            if (!isMyLock) {
                return callback(Error(`File ${anchorPath} is locked by another process.`))
            }

            fileOperations.isFileNameValid(anchorId, (err) => {
                if (err) {
                    return callback(err);
                }
                fileOperations.fileExist(anchorId, (err, exists) => {
                    if (err) {
                        return callback(err);
                    }
                    if (!exists) {
                        return callback(new Error(`Anchor ${anchorId} doesn't exist`));
                    }
                    return fileOperations.appendAnchor(anchorId, anchorValueSSI, err => {
                        if (err) {
                            return callback(err);
                        }

                        fsLock.releaseLock(callback);
                    });
                })
            });
        })
    }
}


function FileOperations() {
    const self = this;
    const fs = require('fs');
    const path = require('path');
    let anchoringFolder;
    const endOfLine = require("os").EOL;
    const logger = $$.getLogger("FileOperations", "apihub/anchoring");
    self.InitializeFolderStructure = function (rootFolder, configuredPath) {
        let storageFolder = path.join(rootFolder, configuredPath);
        anchoringFolder = path.resolve(storageFolder);
        try {
            if (!fs.existsSync(anchoringFolder)) {
                fs.mkdirSync(anchoringFolder, {recursive: true});
            }
        } catch (e) {
            logger.error("error creating anchoring folder", e);
            throw new Error(`Failed to create folder ${anchoringFolder}`);
        }
    }

    self.isFileNameValid = function (anchorId, callback) {
        if (!anchorId || typeof anchorId !== "string") {
            return callback(new Error("No fileId specified."));
        }

        let forbiddenCharacters = new RegExp(/[~`!#$%\^&*+=\-\[\]\\';,/{}|\\":<>\?]/g);
        if (forbiddenCharacters.test(anchorId)) {
            logger.error(`Found forbidden characters in anchorId ${anchorId}`);
            return callback(new Error(`anchorId ${anchorId} contains forbidden characters`));
        }
        return callback(undefined);
    }

    self.fileExist = function (anchorId, callback) {
        const filePath = path.join(anchoringFolder, anchorId);
        fs.stat(filePath, (err) => {
            if (err) {
                if (err.code === "ENOENT") {
                    return callback(undefined, false);
                }
                return callback(err, false);
            }
            return callback(undefined, true);
        });
    }

    self.getlastVersion = function (anchorId, callback) {
        self.getAllVersions(anchorId, (err, allVersions) => {
            if (err) {
                return callback(err);
            }
            if (allVersions.length === 0) {
                return callback(undefined, null);
            }
            return callback(undefined, allVersions[allVersions.length - 1]);
        });
    }

    self.getAllVersions = function (anchorId, callback) {
        const filePath = path.join(anchoringFolder, anchorId);
        fs.readFile(filePath, (err, fileHashes) => {
            if (err) {
                return callback(new Error(`Failed to read file <${filePath}>`));
            }
            const fileContent = fileHashes.toString().trimEnd();
            const versions = fileContent ? fileContent.split(endOfLine) : [];
            callback(undefined, versions);
        });
    }

    self.createAnchor = function (anchorId, anchorValueSSI, callback) {
        const fileContent = anchorValueSSI + endOfLine;
        const filePath = path.join(anchoringFolder, anchorId);
        fs.writeFile(filePath, fileContent, callback);
    }

    self.appendAnchor = function (anchorId, anchorValueSSI, callback) {
        const fileContent = anchorValueSSI + endOfLine;
        const filePath = path.join(anchoringFolder, anchorId);
        fs.appendFile(filePath, fileContent, callback);
    }
}


module.exports = {
    FilePersistenceStrategy
}

},{"../utils/AnchorPathResolver":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/apihub/components/anchoring/strategies/utils/AnchorPathResolver.js","../utils/FSLock":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/apihub/components/anchoring/strategies/utils/FSLock.js","fs":false,"os":false,"path":false}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/apihub/components/anchoring/strategies/fs/index.js":[function(require,module,exports){

const openDSU = require("opendsu");

class FS{
    constructor(server, domainConfig, anchorId, anchorValue, jsonData) {
        this.commandData = {};
        this.commandData.option = domainConfig.option;
        this.commandData.anchorId = anchorId;
        this.commandData.anchorValue = anchorValue;
        this.commandData.jsonData = jsonData || {};
        const FilePersistence = require('./filePersistence').FilePersistenceStrategy;
        this.fps = new FilePersistence(server.rootFolder,domainConfig.option.path);
        this.anchoringBehaviour = openDSU.loadApi("anchoring").getAnchoringBehaviour(this.fps);
    }

    createAnchor(callback){
        this.anchoringBehaviour.createAnchor(this.commandData.anchorId, this.commandData.anchorValue, callback);
    }

    appendAnchor(callback){
        this.anchoringBehaviour.appendAnchor(this.commandData.anchorId, this.commandData.anchorValue, callback);
    }

    getAllVersions(callback){
        this.anchoringBehaviour.getAllVersions(this.commandData.anchorId, (err, anchorValues)=>{
            if (err) {
                return callback(err);
            }
            if (anchorValues.length === 0) {
                return callback(anchorValues);
            }

            callback(undefined, anchorValues.map(el => el.getIdentifier()));
        });
    }

    getLastVersion(callback){
        this.anchoringBehaviour.getLastVersion(this.commandData.anchorId, (err, anchorValue)=>{
            if (err) {
                return callback(err);
            }

            if (anchorValue) {
                return callback(undefined, anchorValue.getIdentifier());
            }

            callback();
        });
    }
}

module.exports = FS;

},{"./filePersistence":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/apihub/components/anchoring/strategies/fs/filePersistence.js","opendsu":"opendsu"}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/apihub/components/anchoring/strategies/index.js":[function(require,module,exports){
module.exports = {
    FS: require("./fs"),
    ETH: require("./eth"),
    Contract: require("./contract"),
    OBA: require("./oba")
};

},{"./contract":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/apihub/components/anchoring/strategies/contract/index.js","./eth":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/apihub/components/anchoring/strategies/eth/index.js","./fs":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/apihub/components/anchoring/strategies/fs/index.js","./oba":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/apihub/components/anchoring/strategies/oba/index.js"}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/apihub/components/anchoring/strategies/oba/ethereumSyncService.js":[function(require,module,exports){
const {ALIAS_SYNC_ERR_CODE, ANCHOR_ALREADY_EXISTS_ERR_CODE} = require("../../utils");
const {getLokiEnclaveFacade} = require("./lokiEnclaveFacadeSingleton");
const {getLogFilePath} = require("./getLogFilePath");
const {getDBFilePath} = require("./getDBFilePath");

function EthereumSyncService(server, config) {
    const defaultConfig = {
        scheduleInterval: 10000,
        sendInterval: 17000,
        burstSize: 100,
        maxNumberOfRetries: 100
    }
    Object.assign(defaultConfig, config);
    config = defaultConfig;

    const DB_STORAGE_FILE = getDBFilePath(server);
    const logger = $$.getLogger("OBA", "EthereumSyncService", getLogFilePath(server));

    const openDSU = require("opendsu");
    const utils = openDSU.loadAPI("utils");
    const TaskCounter = require("swarmutils").TaskCounter;
    let lokiEnclaveFacade = getLokiEnclaveFacade(DB_STORAGE_FILE);
    const ANCHORS_TABLE_NAME = "anchors_table";
    let syncInProgress = false;
    const {ETH} = require("../index");

    const init = () => {
        syncInProgress = false;
        const taskCounter = new TaskCounter(() => {
            this.finishInitialisation();
        })

        lokiEnclaveFacade.filter(undefined, ANCHORS_TABLE_NAME, (err, anchors) => {
            if (err) {
                this.finishInitialisation();
                return;
            }

            if (typeof anchors === "undefined" || anchors.length === 0) {
                return this.finishInitialisation();
            }

            taskCounter.increment(anchors.length);
            anchors.forEach(anchor => {
                anchor.scheduled = null;
                anchor.tc = 1;
                lokiEnclaveFacade.updateRecord(undefined, ANCHORS_TABLE_NAME, anchor.pk, anchor, err => {
                    if (err) {
                        logger.debug(`Failed to update anchor ${anchor.pk} in db: ${err}`);
                    }

                    taskCounter.decrement();
                })
            })
        })
    }

    function sendAnchorToBlockchain(anchor) {
        const ethHandler = new ETH(server, anchor.domainConfig, anchor.anchorId, anchor.anchorValue);
        logger.info(0x101, `Anchoring for anchor ${anchor.anchorId} started.`);
        ethHandler[anchor.anchorUpdateOperation]((err, transactionHash) => {
            if (err) {
                if (err.code === ANCHOR_ALREADY_EXISTS_ERR_CODE || err.code === ALIAS_SYNC_ERR_CODE) {
                    logger.critical(0x101, `Anchoring for ${anchor.anchorId} failed to sync with blockchain`)

                    lokiEnclaveFacade.deleteRecord(undefined, ANCHORS_TABLE_NAME, anchor.pk, err => {
                        if (err) {
                            logger.debug(`Failed to delete anchor ${anchor.anchorId} from db: ${err}`);
                        }
                    });
                    return;
                }
                anchor.scheduled = null;
                anchor.tc++;
                if (anchor.tc === config.maxNumberOfRetries) {
                    logger.warn(0x01, `Anchoring Synchronization for ${anchor.anchorId} retried ${config.maxNumberOfRetries} without success`);
                }
                lokiEnclaveFacade.updateRecord(undefined, ANCHORS_TABLE_NAME, anchor.pk, anchor, err => {
                    if (err) {
                        logger.debug(`Failed to update anchor ${anchor.pk}: ${err}`);
                    }
                });
                return;
            }

            logger.info(0x102, `Anchoring for anchor ${anchor.anchorId} committed in blockchain: ${transactionHash}`);
            lokiEnclaveFacade.deleteRecord(undefined, ANCHORS_TABLE_NAME, anchor.pk, err => {
                if (err) {
                    logger.debug(`Failed to delete anchor ${anchor.anchorId} from db: ${err}`);
                }
            })
        })
    }

    this.storeAnchor = (anchorUpdateOperation, anchorId, anchorValue, domainConfig, callback) => {
        lokiEnclaveFacade.addInQueue(undefined, ANCHORS_TABLE_NAME, {
            anchorId,
            anchorValue,
            anchorUpdateOperation,
            domainConfig,
            scheduled: null,
            tc: 1
        }, callback);
    }

    const scheduleAnchors = () => {
        lokiEnclaveFacade.filter(undefined, ANCHORS_TABLE_NAME, ["scheduled == null"], "asc", (err, anchors) => {
            if (err) {
                if (err.code !== 404) {
                    logger.debug(`Failed to get anchors from db: ${err}`);
                }
                return;
            }
            anchors.forEach(anchor => {
                anchor.scheduled = Date.now() + (anchor.tc > 100 ? 100 : anchor.tc) * config.scheduleInterval;
                lokiEnclaveFacade.updateRecord(undefined, ANCHORS_TABLE_NAME, anchor.pk, anchor, err => {
                    if (err) {
                        logger.debug(`Failed to update anchor ${anchor.pk} in db: ${err}`);
                    }
                })
            })
        })
    }

    const sendAnchorsToBlockchain = () => {
        lokiEnclaveFacade.filter(undefined, ANCHORS_TABLE_NAME, ["scheduled != null", "scheduled != sent", `scheduled < ${Date.now()}`], "asc", config.burstSize, (err, anchors) => {
            if (err) {
                if (err.code !== 404) {
                    logger.debug(`Failed to get anchors from db: ${err}`);
                }
                return;
            }

            anchors.forEach(anchor => {
                anchor.scheduled = "sent";
                lokiEnclaveFacade.updateRecord(undefined, ANCHORS_TABLE_NAME, anchor.pk, anchor, err => {
                    if (err) {
                        logger.debug(`Failed to update anchor ${anchor.pk} in db: ${err}`);
                        return;
                    }

                    sendAnchorToBlockchain(anchor);
                })
            })
        })
    }

    this.synchronize = () => {
        if (!syncInProgress) {
            setInterval(scheduleAnchors, config.scheduleInterval);
            setInterval(sendAnchorsToBlockchain, config.sendInterval);
            syncInProgress = true;
        }
    };

    utils.bindAutoPendingFunctions(this);
    init();
}

const getEthereumSyncServiceSingleton = (server) => {
    if (typeof $$.ethereumSyncService === "undefined") {
        $$.ethereumSyncService = new EthereumSyncService(server);
    }

    return $$.ethereumSyncService;
}
module.exports = {
    getEthereumSyncServiceSingleton
}
},{"../../utils":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/apihub/components/anchoring/utils/index.js","../index":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/apihub/components/anchoring/strategies/index.js","./getDBFilePath":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/apihub/components/anchoring/strategies/oba/getDBFilePath.js","./getLogFilePath":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/apihub/components/anchoring/strategies/oba/getLogFilePath.js","./lokiEnclaveFacadeSingleton":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/apihub/components/anchoring/strategies/oba/lokiEnclaveFacadeSingleton.js","opendsu":"opendsu","swarmutils":"swarmutils"}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/apihub/components/anchoring/strategies/oba/getDBFilePath.js":[function(require,module,exports){
const path = require("path");

const getDBFilePath = (server) => {
    const BASE_FOLDER = path.join(server.rootFolder, "external-volume", "oba");
    const storageFilePath = path.join(BASE_FOLDER, "pendingAnchors");

    return storageFilePath;
}

module.exports = {
    getDBFilePath
}
},{"path":false}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/apihub/components/anchoring/strategies/oba/getLogFilePath.js":[function(require,module,exports){
const path = require("path");

const getLogFilePath = (server) => {
    const BASE_FOLDER = path.join(server.rootFolder, "external-volume", "oba");
    const LOG_FILE = path.join(BASE_FOLDER, "oba.log");

    return LOG_FILE;
}

module.exports = {
    getLogFilePath
}
},{"path":false}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/apihub/components/anchoring/strategies/oba/index.js":[function(require,module,exports){
const {getEthereumSyncServiceSingleton} = require("./ethereumSyncService");
const {getLogFilePath} = require("./getLogFilePath");

function OBA(server, domainConfig, anchorId, anchorValue, ...args) {
    let {FS, ETH} = require("../index");
    const fsHandler = new FS(server, domainConfig, anchorId, anchorValue, ...args);
    const ethHandler = new ETH(server, domainConfig, anchorId, anchorValue, ...args);
    const ethSyncService = getEthereumSyncServiceSingleton(server);
    const logger = $$.getLogger("OBA", "apihub/anchoring", getLogFilePath(server));

    this.createAnchor = function (callback) {
        logger.debug(1, `Anchoring for ${anchorId} started`);
        fsHandler.createAnchor((err, res) => {
            if (err) {
                return callback(err);
            }
            logger.debug(`Optimistic create anchor ended with success.`);

            ethSyncService.storeAnchor("createAnchor", anchorId, anchorValue, domainConfig,(err) => {
                if (err) {
                    logger.error(`Failed to store anchor ${fsHandler.commandData.anchorId} in db.`);
                    return;
                }

                logger.debug(`Anchor ${fsHandler.commandData.anchorId} stored in db successfully.`);
                return callback(undefined, res);
            })
        });
    }

    this.appendAnchor = function (callback) {
        logger.debug(1, `Anchoring for ${anchorId} started`);
        fsHandler.appendAnchor((err, res) => {
            if (err) {
                return callback(err);
            }
            logger.debug(`Optimistic append anchor ended with success.`);
            ethSyncService.storeAnchor("appendAnchor", anchorId, anchorValue, domainConfig, (err) => {
                if (err) {
                    logger.error(`failed to store anchor ${fsHandler.commandData.anchorId} in db.`);
                    return;
                }

                logger.debug(`Anchor ${fsHandler.commandData.anchorId} stored in db successfully.`);
                return callback(undefined, res);

            })
        });
    }

    function readAllVersionsFromBlockchain(callback) {
        logger.debug(`Preparing to read info about anchorId ${fsHandler.commandData.anchorId} from the blockchain...`);
        ethHandler.getAllVersions((err, anchorVersions) => {
            if (err) {
                logger.error(`AnchorId ${fsHandler.commandData.anchorId} syncing blockchain failed. ${err}`);
                return callback(err);
            }

            let history = "";
            for (let i = 0; i < anchorVersions.length; i++) {
                history += anchorVersions[i];
                if (i + 1 < anchorVersions.length) {
                    history += require("os").EOL;
                }
            }

            if (history === "") {
                logger.debug(`AnchorId ${fsHandler.commandData.anchorId} synced but no history found.`);
                //if we don't retrieve info from blockchain we exit
                return callback(undefined, anchorVersions);
            }

            logger.debug(`Found info about anchorId ${fsHandler.commandData.anchorId} in blockchain.`);

            //storing locally the history of the anchorId read from the blockchain
            fsHandler.fps.createAnchor(anchorId, history, (err) => {
                if (err) {
                    logger.error(`Failed to store info about anchorId ${fsHandler.commandData.anchorId} on local because of ${err}`);
                    return callback(err);
                }
                logger.debug(`AnchorId ${fsHandler.commandData.anchorId} fully synced.`);
                //even if we read all the versions of anchorId we return only the last one
                return callback(undefined, anchorVersions);
            });
        });
    }

    this.getAllVersions = function (callback) {
        fsHandler.getAllVersions((error, res) => {
            if (error || !res) {
                return readAllVersionsFromBlockchain((err, allVersions) => {
                    if (err) {
                        //we return the error from FS because we were not able to read any from blockchain.
                        return callback(error);
                    }
                    return callback(undefined, allVersions);
                });
            }
            return callback(undefined, res);
        });
    }

    this.getLastVersion = function (callback) {
        fsHandler.getLastVersion((error, res) => {
            if (error || !res) {
                return readAllVersionsFromBlockchain((err, allVersions) => {
                    if (err) {
                        //we return the error from FS because we were not able to read any from blockchain.
                        return callback(error);
                    }
                    return callback(undefined, allVersions.pop());
                });
            }
            return callback(undefined, res);
        });
    }
}

module.exports = OBA;

},{"../index":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/apihub/components/anchoring/strategies/index.js","./ethereumSyncService":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/apihub/components/anchoring/strategies/oba/ethereumSyncService.js","./getLogFilePath":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/apihub/components/anchoring/strategies/oba/getLogFilePath.js","os":false}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/apihub/components/anchoring/strategies/oba/lokiEnclaveFacadeSingleton.js":[function(require,module,exports){
const fs = require("fs");
const path = require("path");

const getLokiEnclaveFacade = (storageFile) => {
    if(typeof $$.lokiEnclaveFacade === "undefined") {
        try {
            fs.accessSync(path.dirname(storageFile));
        } catch (e) {
            fs.mkdirSync(path.dirname(storageFile), {recursive: true});
        }
        const LokiEnclaveFacade = require("loki-enclave-facade");
        $$.lokiEnclaveFacade = new LokiEnclaveFacade(storageFile);
    }

    return $$.lokiEnclaveFacade;
}

module.exports = {
    getLokiEnclaveFacade
}

},{"fs":false,"loki-enclave-facade":"loki-enclave-facade","path":false}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/apihub/components/anchoring/strategies/utils/AnchorPathResolver.js":[function(require,module,exports){
function AnchorPathResolver(rootFolder, configPath) {
    const path = require("path");
    const anchoringFolder = path.resolve(path.join(rootFolder, configPath));

    this.getAnchorPath = (anchorId) => {
        return path.join(anchoringFolder, anchorId);
    }
}

module.exports = AnchorPathResolver;
},{"path":false}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/apihub/components/anchoring/strategies/utils/FSLock.js":[function(require,module,exports){
const fs = require("fs");

function FSLock(filePath, maxTimeMilliSeconds, forcedLockDelay) {
    maxTimeMilliSeconds = maxTimeMilliSeconds || 5000;
    forcedLockDelay = forcedLockDelay || 10000;
    let lockCreationTime;
    const removeDir = require("swarmutils").removeDir;
    this.acquireLock = (callback) => {
        fs.mkdir(getLockPath(), async err => {
            if (err) {
                if (await lockIsExpired()) {
                   return attemptToReacquireExpiredLock(callback);
                }

                return callback(Error(`File ${filePath} is being updated by another process.`));
            }

            lockCreationTime = await getLockCreationTime();
            callback();
        })
    }

    this.releaseLock = (callback) => {
        this.isMyLock((err, isMyLock) => {
            if (err) {
                return callback(err);
            }
            if (isMyLock) {
                return removeDir(getLockPath(filePath), {recursive: true}, callback);
            }

            callback(Error(`The lock is owned by another instance.`));
        })
    }

    this.isMyLock = (callback) => {
        getLockCreationTime(filePath).then(creationTime => {
            let isOwnLock = false;
            if (creationTime === lockCreationTime) {
                isOwnLock = true;
            }
            callback(undefined, isOwnLock);
        });
    }

    const lockIsExpired = async () => {
        const lockStartingTime = await getLockCreationTime();
        if (Date.now() - lockStartingTime > maxTimeMilliSeconds) {
            return true;
        }

        return false;
    };


    const releaseExpiredLock = (callback)=>{
        return setTimeout(() => {
            removeDir(getLockPath(), {recursive: true}, (err)=>{
                if (err) {
                    return callback(err);
                }

                callback();
            });
        }, forcedLockDelay);
    }

    const attemptToReacquireExpiredLock = (callback)=>{
        releaseExpiredLock(err=>{
            if (err) {
                return callback(err);
            }

            this.acquireLock(callback);
        })
    }

    const getLockCreationTime = async () => {
        let stats;
        try {
            stats = await $$.promisify(fs.stat)(getLockPath());
        } catch (e) {
            return 0;
        }
        return stats.birthtimeMs;
    }

    const getLockPath = () => {
        return `${filePath}.lock`;
    }
}

module.exports = FSLock;
},{"fs":false,"swarmutils":"swarmutils"}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/apihub/components/anchoring/utils/index.js":[function(require,module,exports){
const { clone } = require("../../../utils");

const getAnchoringDomainConfig = async (domain) => {
    const config = require("../../../config");
    let domainConfiguration = await config.getSafeDomainConfig(domain);

    if (!domainConfiguration) {
        return;
    }

    let domainConfig = domainConfiguration.anchoring;

    if (!domainConfig) {
        // try to get the anchoring strategy based on the anchoring component config
        const anchoringConfig = config.getConfig("componentsConfig", "anchoring");

        if (anchoringConfig) {
            const { anchoringStrategy } = anchoringConfig;
            domainConfig = {
                type: anchoringStrategy,
            };
        } else {
            return;
        }
    }

    domainConfig = clone(domainConfig || {});
    domainConfig.option = domainConfig.option || {};
    domainConfig.option.path = require("path").join(config.getConfig("externalStorage"), `domains/${domain}/anchors`);

    return domainConfig;
};

const getDomainFromKeySSI = function (ssiString) {
    const openDSU = require("opendsu");
    const keySSISpace = openDSU.loadApi("keyssi");
    const keySSI = keySSISpace.parse(ssiString);
    return keySSI.getDLDomain();
};

const ALIAS_SYNC_ERR_CODE = "sync-error";
const ANCHOR_ALREADY_EXISTS_ERR_CODE = "anchor-already-exists";

module.exports = { getAnchoringDomainConfig, getDomainFromKeySSI, ALIAS_SYNC_ERR_CODE, ANCHOR_ALREADY_EXISTS_ERR_CODE };

},{"../../../config":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/apihub/config/index.js","../../../utils":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/apihub/utils/index.js","opendsu":"opendsu","path":false}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/apihub/components/bdns/index.js":[function(require,module,exports){
function BDNS(server) {
    const logger = $$.getLogger("BDNS", "apihub/bdns");

    const DOMAIN_TEMPLATE = {
        "replicas": [],
        "brickStorages": [
            "$ORIGIN"
        ],
        "anchoringServices": [
            "$ORIGIN"
        ],
        "notifications": [
            "$ORIGIN"
        ]
    };
    const URL_PREFIX = "/bdns";
    const {headersMiddleware} = require('../../utils/middlewares');

    let bdnsCache;
    const config = require("../../config");
    const bdnsConfig = config.getConfig("componentsConfig", "bdns");

    async function getBDNSHostsFromURL(url) {
        const http = require("opendsu").loadAPI("http");
        const bdnsHosts = await http.fetch(url).then(res => res.json());
        return bdnsHosts
    }

    let init_process_runned = false;

    async function initialize() {
        if (init_process_runned) {
            return true;
        }
        init_process_runned = true;
        const fs = require("fs");
        const path = require("path");

        const bdnsHostsPath = path.join(process.env.PSK_CONFIG_LOCATION, "bdns.hosts");

        bdnsCache = fs.readFileSync(bdnsHostsPath).toString();

        if (bdnsConfig && bdnsConfig.url) {
            try {
                const bdnsExtensions = await getBDNSHostsFromURL(bdnsConfig.url);
                let newRegistry = JSON.parse(bdnsCache);
                Object.assign(newRegistry, bdnsExtensions);
                bdnsCache = JSON.stringify(newRegistry);
            } catch (e) {
                logger.error(`Failed to get bdns hosts from url`, e);
            }
        }

        try {
            logger.debug("Testing to see if admin component is active and can be used to expand BDNS configuration.");
            let adminService = require("./../admin").getAdminService();
            let getDomains = $$.promisify(adminService.getDomains);
            let domains = await getDomains();
            if (domains) {
                let bdnsExtensions = {};
                for (let i = 0; i < domains.length; i++) {
                    let domain = domains[i];
                    if (domain.active) {
                        bdnsExtensions[domain.name] = DOMAIN_TEMPLATE;
                    }
                }
                let newRegistry = JSON.parse(bdnsCache);
                Object.assign(newRegistry, bdnsExtensions);
                bdnsCache = JSON.stringify(newRegistry);
            }
            logger.debug("BDNS configuration was updated accordingly to information retrieved from admin service");
        } catch (err) {
            logger.debug("Admin service not available, skipping the process of loading dynamic configured domains. This is not a problem, it's a configuration.");
        }
    }

    async function bdnsHandler(request, response, next) {
        try {
            await initialize();
        } catch (e) {
            response.statusCode = 500;
            logger.error('Failed to initialize BDNS', e);
            return response.end('Failed to initialize BDNS');
        }

        if (typeof bdnsCache !== "undefined") {
            response.setHeader('content-type', 'application/json');
            response.statusCode = 200;
            response.end(bdnsCache);
        } else {
            logger.debug("Bdns config not available at this moment. A 404 response will be sent.");
            response.statusCode = 404;
            logger.error('BDNS hosts not found');
            return response.end('BDNS hosts not found');
        }
    }

    server.use(`${URL_PREFIX}/*`, headersMiddleware);
    server.get(URL_PREFIX, bdnsHandler);
}

module.exports = BDNS;

},{"../../config":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/apihub/config/index.js","../../utils/middlewares":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/apihub/utils/middlewares/index.js","./../admin":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/apihub/components/admin/index.js","fs":false,"opendsu":"opendsu","path":false}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/apihub/components/bricking/controllers.js":[function(require,module,exports){
const { getBrickWithExternalProvidersFallbackAsync } = require("./utils");
const logger = $$.getLogger("apihub", "bricking");

async function getBrick(request, response) {
    response.setHeader("content-type", "application/octet-stream");
    response.setHeader("Cache-control", "max-age=31536000"); // set brick cache to expire in 1 year

    const {domain, hashLink} = request.params;
    try {
        const brick = await getBrickWithExternalProvidersFallbackAsync(request, domain, hashLink, request.fsBrickStorage);
        response.write(brick);
        return response.send(200);
    } catch (error) {
        logger.info(0x02, `Brick <${hashLink}> was not found`);
        return response.send(404, "Brick not found");
    }
}

function putBrick(request, response) {
    const utils = require("./utils");
    utils.convertReadableStreamToBuffer(request, (error, brickData) => {
        if (error) {
            logger.info(0x02, `Fail to convert Stream to Buffer!`, error.message);
            logger.error("Fail to convert Stream to Buffer!", error.message);
            return response.send(500);
        }

        request.fsBrickStorage.addBrick(brickData, (error, brickHash) => {
            if (error) {
                logger.info(0x02, `Fail to manage current brick!`, error.message);
                return response.send(error.code === "EACCES" ? 409 : 500);
            }

            return response.send(201, brickHash);
        });
    });
}

function downloadMultipleBricks(request, response) {
    response.setHeader("content-type", "application/octet-stream");
    response.setHeader("Cache-control", "max-age=31536000"); // set brick cache to expire in 1 year

    const { domain } = request.params;
    let { hashes } = request.query;

    if (!Array.isArray(hashes)) {
        hashes = [hashes];
    }

    const responses = hashes.map((hash) =>
        getBrickWithExternalProvidersFallbackAsync(request, domain, hash, request.fsBrickStorage)
    );
    Promise.all(responses)
        .then((bricks) => {
            const data = bricks.map((brick) => brick.toString());
            return response.send(200, data);
        })
        .catch((error) => {
            logger.info(0x02, `Fail to get multiple bricks`, error.message);
            return response.send(500);
        });
}

module.exports = {
    getBrick,
    putBrick,
    downloadMultipleBricks,
};

},{"./utils":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/apihub/components/bricking/utils.js"}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/apihub/components/bricking/index.js":[function(require,module,exports){
function Bricks(server) {
    function requestServerMiddleware(request, response, next) {
        request.server = server;
        next();
    }

    const { headersMiddleware, responseModifierMiddleware } = require('../../utils/middlewares');

    const { requestFSBrickStorageMiddleware } = require('./middlewares');

    const { getBrick, putBrick, downloadMultipleBricks } = require('./controllers');

    server.use(`/bricking/:domain/*`, headersMiddleware);
    server.use(`/bricking/:domain/*`, responseModifierMiddleware);
    server.use(`/bricking/:domain/*`, requestServerMiddleware); // request.server
    server.use(`/bricking/:domain/*`, requestFSBrickStorageMiddleware); // request.fsBrickStorage

    server.put(`/bricking/:domain/put-brick`, putBrick);

    server.get(`/bricking/:domain/get-brick/:hashLink`, getBrick);

    server.get(`/bricking/:domain/downloadMultipleBricks`, downloadMultipleBricks);
}

module.exports = Bricks;

},{"../../utils/middlewares":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/apihub/utils/middlewares/index.js","./controllers":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/apihub/components/bricking/controllers.js","./middlewares":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/apihub/components/bricking/middlewares.js"}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/apihub/components/bricking/middlewares.js":[function(require,module,exports){
async function requestFSBrickStorageMiddleware(request, response, next) {
    const { domain: domainName } = request.params;
    const logger = $$.getLogger("requestFSBrickStorageMiddleware", "apihub/bricking");

    const domainConfig = await require("./utils").getBricksDomainConfig(domainName);
    if (!domainConfig || !domainConfig.path) {
        const message = `[Bricking] Domain '${domainName}' not found!`;
        logger.error(message);
        return response.send(404, message);
    }

    request.fsBrickStorage = require("bricksledger").createFSBrickStorage(
        domainName,
        domainConfig.path,
        request.server.rootFolder
    );

    next();
}

module.exports = {
    requestFSBrickStorageMiddleware
};

},{"./utils":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/apihub/components/bricking/utils.js","bricksledger":"bricksledger"}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/apihub/components/bricking/utils.js":[function(require,module,exports){
const { clone } = require("../../utils");
const { getLocalBdnsEntryListExcludingSelfAsync, getHeadersWithExcludedProvidersIncludingSelf } = require("../../utils/request-utils");
const logger = $$.getLogger("bricking", "apihub/bricking")
function convertReadableStreamToBuffer(readStream, callback) {
    let buffers = [];

    readStream.on("data", (chunk) => buffers.push(chunk));

    readStream.on("error", (error) => callback(error));

    readStream.on("end", () => callback(undefined, $$.Buffer.concat(buffers)));
}

async function getBricksDomainConfig(domain) {
    logger.debug("Looking for domain", domain);
    const config = require("../../config");
    let domainConfiguration = await config.getSafeDomainConfig(domain);

    if (!domainConfiguration) {
        return;
    }

    let domainConfig = domainConfiguration.bricking;

    domainConfig = clone(domainConfig || {});
    domainConfig.path = require("path").join(config.getConfig("externalStorage"), `domains/${domain}/brick-storage`);

    return domainConfig;
}

async function getBrickFromExternalProvidersAsync(request, domain, hashLink) {
    let brickingProviders = await getLocalBdnsEntryListExcludingSelfAsync(request, domain, "brickStorages");

    if (!brickingProviders || !brickingProviders.length) {
        throw new Error(`[Bricking] Found no fallback bricking providers!`);
    }

    const http = require("opendsu").loadApi("http");
    for (let i = 0; i < brickingProviders.length; i++) {
        const providerUrl = brickingProviders[i];
        try {
            const brickUrl = `${providerUrl}/bricking/${domain}/get-brick/${hashLink}`;
            let providerResponse = await http.fetch(brickUrl, {
                headers: getHeadersWithExcludedProvidersIncludingSelf(request),
            });
            providerResponse = await providerResponse.text();
            return providerResponse;
        } catch (error) {
            // logger.warn(`[Bricking] Failed to get brick ${hashLink} from ${providerUrl}!`, error);
        }
    }

    throw new Error(`[Bricking] Could not load brick ${hashLink} from external providers`);
}

async function getBrickWithExternalProvidersFallbackAsync(request, domain, hashLink, fsBrickStorage) {
    try {
        const brick = await fsBrickStorage.getBrickAsync(hashLink);
        if (brick) {
            return brick;
        }
    } catch (error) {
        logger.warn(`[Bricking] Brick ${hashLink} not found. Trying to fallback to other providers...`);
    }

    try {
        const externalBrick = await getBrickFromExternalProvidersAsync(request, domain, hashLink);

        // saving the brick in the next cycle in order to not block the get brick request
        setTimeout(async () => {
            try {
                console.info(`[Bricking] Saving external brick ${hashLink} to own storage...`);
                await fsBrickStorage.addBrickAsync(externalBrick);
                console.info(`[Bricking] Saved external brick ${hashLink} to own storage`);
            } catch (error) {
                logger.warn("[Bricking] Fail to manage external brick saving!", error);
            }
        });

        return externalBrick;
    } catch (error) {
        logger.warn(`[Bricking] Error while trying to get missing brick from fallback providers!`, error);
        throw error;
    }
}

module.exports = {
    convertReadableStreamToBuffer,
    getBricksDomainConfig,
    getBrickWithExternalProvidersFallbackAsync,
};

},{"../../config":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/apihub/config/index.js","../../utils":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/apihub/utils/index.js","../../utils/request-utils":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/apihub/utils/request-utils.js","opendsu":"opendsu","path":false}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/apihub/components/bricksFabric/constants.js":[function(require,module,exports){
const URL_PREFIX='/bricksFabric';

module.exports = {URL_PREFIX};
},{}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/apihub/components/bricksFabric/controllers.js":[function(require,module,exports){

function createHandler(flow, server) {

    return function storeTransaction (request, response, next) {

        //strategy is already booted up
        flow.storeData(request.body, server, (err, result) => {
            if (err) {
                return response.send(500,"Failed to store transaction."+ err.toString());
            }
            response.send(201, result);
        });

    }
}


module.exports = createHandler;
},{}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/apihub/components/bricksFabric/index.js":[function(require,module,exports){
(function (global){(function (){


function AutoSavePendingTransactions (flow, timeout, server) {
    flow.completeBlock(server);
    setTimeout (  () => {
         AutoSavePendingTransactions(flow, timeout, server);
    }, timeout);

}


function BricksFabric(server) {
    const logger = $$.getLogger("BricksFabric", "apihub/bricksFabric");

    require('./strategies/BrickStorage.js');

    const bricksFabricStrategy = require('./utils').getBricksFabricStrategy();
    if (!bricksFabricStrategy) {
        logger.error("Unable to initialized 'bricksFabrick' component. Strategy not found!");
        return;
    }
    const rootFolder = require('./utils').getRootFolder();
    //options
    const noOfTran = bricksFabricStrategy.option.transactionsPerBlock;
    const strategyType = bricksFabricStrategy.name;

    //init strategy
    let flow = new global[strategyType];
    flow.init(rootFolder,noOfTran);

    //resume if necessary
    flow.bootUp();

    const timeout = bricksFabricStrategy.option.timeout;
    setTimeout (  () => {
        //start forever loop starting in timeout
        AutoSavePendingTransactions(flow, timeout, server);
    }, timeout);

    const { URL_PREFIX } = require('./constants.js');
    const { responseModifierMiddleware, requestBodyJSONMiddleware } = require('../../utils/middlewares');
    const  storeTransaction  = require('./controllers')(flow, server);

    server.use(`${URL_PREFIX}/*`, responseModifierMiddleware);
    // request.body is populated with what data needs to be stored
    server.put(`${URL_PREFIX}/add`, requestBodyJSONMiddleware);

    server.put(`${URL_PREFIX}/add`, storeTransaction);
};






module.exports = BricksFabric;

}).call(this)}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../../utils/middlewares":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/apihub/utils/middlewares/index.js","./constants.js":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/apihub/components/bricksFabric/constants.js","./controllers":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/apihub/components/bricksFabric/controllers.js","./strategies/BrickStorage.js":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/apihub/components/bricksFabric/strategies/BrickStorage.js","./utils":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/apihub/components/bricksFabric/utils/index.js"}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/apihub/components/bricksFabric/strategies/BrickStorage.js":[function(require,module,exports){
(function (global){(function (){
const fs = require('fs');
const path = require('swarmutils').path;
const BRICKSFABRIC_ERROR_CODE = 'bricks fabric error';


function BrickStorage() {
    const logger = $$.getLogger("BrickStorage", "apihub/bricksFabric");

    this.init = function (brickFabricRootFolder,noOfTransactionsPerBlock) {
        this.rootFolder = brickFabricRootFolder;
        this.transactionsPerBlock = noOfTransactionsPerBlock;
        this.hashlinkfile = 'lasthashlink';
        this.lastBlockHashLink = undefined;
        this.pendingTransactions = [];
        this.pendingBuffer = [];
        this.isCommitingBlock = false;
    }

    this.bootUp = function(){
      //get latest hashlink
        const hashlinkpath = path.join(this.rootFolder,this.hashlinkfile);
        if (fs.existsSync(hashlinkpath))
        {
            this.lastBlockHashLink = fs.readFileSync(hashlinkpath).toString();
        }
    }

    function __storeLastHashLink() {
        const hashlinkpath = path.join(this.rootFolder,this.hashlinkfile);
        fs.writeFileSync(hashlinkpath,this.lastBlockHashLink);
    }

    this.completeBlock = function (server, callback) {
        if (callback === undefined)
        {
            callback = (err, result) => {
                // Autosave callback.
            };
        }

        if (this.pendingTransactions.length === 0)
        {
            //No pending transactions
            return;
        }

        //build block
        const blockId = $$.uidGenerator.safe_uuid();
        const block = {
            'blockId' : blockId,
            'previousBlockHashLink' : this.lastBlockHashLink,
            'transactions' : []

        };

        for (let i = 0; i < this.pendingTransactions.length; i++) {
            block.transactions.push(this.pendingTransactions[i])
        }

        __SaveBlockToBrickStorage(JSON.stringify(block), server, callback);
    }
    function __SaveBlockToBrickStorage(data, server, callback){

        const blockHeaders = {
            'Content-Type': 'application/json',
            'Content-Length': data.length
        };
        const blockPath = "/bricking/default/put-brick";
        const blockMethod = "PUT";
        this.isCommitingBlock = true;

        try {
            server.makeLocalRequest(blockMethod, blockPath, data, blockHeaders, (err, result) => {
                if (err) {
                    logger.error(err);
                    __pushBuffer();
                    this.isCommitingBlock = false;
                    callback(err, undefined);
                }

                if (result) {
                    this.lastBlockHashLink = JSON.parse(result).message;
                    __storeLastHashLink();
                    this.pendingTransactions.splice(0, this.pendingTransactions.length);
                    __pushBuffer();
                    this.isCommitingBlock = false;

                    callback(undefined, result);
                }


            });
        } catch (err)
        {
            logger.error("bricks fabric", err);
        }
    }
    function __pushBuffer(){
        if (this.pendingBuffer.length > 0)
        {
            for (let i = 0; i < this.pendingBuffer.length; i++) {
                this.pendingTransactions.push(this.pendingBuffer[i]);
            }
            this.pendingBuffer.splice(0, this.pendingBuffer.length);
        }
    }
    this.storeData = function(anchorData, server, callback) {
        if (this.isCommitingBlock === true)
        {
            logger.debug("transaction cached");
            this.pendingBuffer.push(anchorData);
            callback(undefined,"Transaction was added to the block.");
            return;
        }
        logger.debug("transaction pushed to pending block");
        this.pendingTransactions.push(anchorData);
        if (this.pendingTransactions.length >= this.transactionsPerBlock)
        {
           // logger.debug("commit block callback");
           this.completeBlock(server, callback);
        }else {
            //logger.debug("pending callback");
            callback(undefined,"Transaction was added to the block.");
        }
    }
}
global["BrickStorage"] = BrickStorage;
module.exports = { BRICKSFABRIC_ERROR_CODE};
}).call(this)}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"fs":false,"swarmutils":"swarmutils"}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/apihub/components/bricksFabric/utils/index.js":[function(require,module,exports){
const { clone } = require("../../../utils");

const getBricksFabricStrategy = () => {
    const config = require("../../../config");
    const domainConfiguration = config.getDomainConfig("default");
    if (!domainConfiguration) {
        return;
    }

    let domainConfig = domainConfiguration.bricksFabric;

    if (!domainConfig) {
        // try to get the bricks strategy based on the bricksFabric component config
        const bricksFabricConfig = config.getConfig("componentsConfig", "bricksFabric");
        if (bricksFabricConfig) {
            const { bricksFabricStrategy, bricksFabricStrategyOption } = bricksFabricConfig;
            domainConfig = {
                name: bricksFabricStrategy,
                option: bricksFabricStrategyOption,
            };
        } else {
            return;
        }
    }
    domainConfig = clone(domainConfig || {});
    return domainConfig;
};

const getRootFolder = () => {
    // temporary location where we store the last hashlink
    const config = require("../../../config");
    return config.getConfig("componentsConfig", "bricksFabric").path;
};

module.exports.getBricksFabricStrategy = getBricksFabricStrategy;
module.exports.getRootFolder = getRootFolder;

},{"../../../config":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/apihub/config/index.js","../../../utils":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/apihub/utils/index.js"}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/apihub/components/cloudWallet/controller.js":[function(require,module,exports){
const http = require("http");
const crypto = require("crypto");
const worker_threads = "worker_threads";
const { Worker } = require(worker_threads);
const config = require("../../config");
const { parseCookies, stringifyCookies } = require("../../utils/cookie-utils");
const path = require("swarmutils").path;
const logger = $$.getLogger("CloudWallet", "apihub/cloudWallet");
let dsuBootPath;
const dsuWorkers = {};

let cacheContainerPath;

const SSAPP_TOKEN_COOKIE_NAME = "SSAPP-TOKEN";

const getElapsedTime = (timer) => {
    const elapsed = process.hrtime(timer)[1] / 1000000;
    return `${elapsed.toFixed(3)} ms`;
};

const INVALID_DSU_HTML_RESPONSE = `
    <html>
    <body>
        <p>
            The application has encountered an unexpected error. <br/>
            If you have network issues please use the following to refresh the application.
        </p>
        <button id="refresh">Refresh</button>
        <script>
            document.getElementById("refresh").addEventListener("click", function() {
                window.top.location.reload();
            });
        </script>
    </body>
    </html>
`;

function addDsuWorker(seed, walletAnchorId, cookie) {
    const workerStartTime = process.hrtime();
    const dsuWorker = {
        port: null,
        authorizationKey: null,
        resolver: new Promise((resolve, reject) => {
            crypto.randomBytes(64, (err, randomBuffer) => {
                if (err) {
                    logger.error("Error while generating worker authorizationKey", err);
                    return reject(err);
                }

                const authorizationKey = randomBuffer.toString("hex");
                dsuWorker.authorizationKey = authorizationKey;
                logger.debug(`Starting worker for handling seed ${seed}`);
                const worker = new Worker(dsuBootPath, {
                    workerData: {
                        seed,
                        authorizationKey,
                        cookie,
                        cacheContainerPath,
                        walletAnchorId
                    },
                });

                worker.on("message", (message) => {
                    if (message.error) {
                        dsuWorkers[seed] = null;
                        return reject(message.error);
                    }
                    if (message.port) {
                        logger.debug(
                            `Running worker on PORT ${message.port} for seed ${seed}. Startup took ${getElapsedTime(
                                workerStartTime
                            )}`
                        );
                        dsuWorker.port = message.port;
                        resolve(worker);
                    }
                });
                worker.on("error", (error) => {
                    logger.error("worker error", error);
                });
                worker.on("exit", (code) => {
                    if (code !== 0) {
                        logger.debug(`Worker stopped with exit code ${code}`);
                        // remove the worker from list in order to be recreated when needed
                        delete dsuWorkers[seed];
                    }
                });

                dsuWorker.terminate = function () {
                    worker.terminate();
                };
            });
        }),
    };
    dsuWorkers[seed] = dsuWorker;
    return dsuWorker;
}

function forwardRequestToWorker(dsuWorker, req, res) {
    const method = req.method;
    const { keySSI } = req.params;
    let requestedPath = req.url.substr(req.url.indexOf(keySSI) + keySSI.length);
    if (!requestedPath) {
        requestedPath = "/";
    }
    if (!requestedPath.startsWith("/")) {
        requestedPath = `/${requestedPath}`;
    }

    const options = {
        hostname: "127.0.0.1",
        port: dsuWorker.port,
        path: requestedPath,
        method,
        headers: {
            authorization: dsuWorker.authorizationKey,
        },
    };

    if (req.headers.cookie) {
        options.headers.cookie = req.headers.cookie;
    }

    if (req.headers["content-type"]) {
        options.headers["content-type"] = req.headers["content-type"];
    }

    const workerRequest = http.request(options, (response) => {
        const { statusCode, headers } = response;
        res.statusCode = statusCode;
        const contentType = headers ? headers["content-type"] : null;
        res.setHeader("Content-Type", contentType || "text/html");

        if (statusCode < 200 || statusCode >= 300) {
            return res.end();
        }

        let data = [];
        response.on("data", (chunk) => {
            data.push(chunk);
        });

        response.on("end", () => {
            try {
                const bodyContent = $$.Buffer.concat(data);
                res.statusCode = statusCode;
                res.end(bodyContent);
            } catch (err) {
                logger.error("worker response error", err);
                res.statusCode = 500;
                res.end();
            }
        });
    });
    workerRequest.on("error", (err) => {
        logger.error("worker request error", err);
        res.statusCode = 500;
        res.end();
    });

    if (method === "POST" || method === "PUT") {
        let data = [];
        req.on("data", (chunk) => {
            logger.debug("data.push(chunk);", chunk);
            data.push(chunk);
        });

        req.on("end", () => {
            try {
                const bodyContent = $$.Buffer.concat(data);
                workerRequest.write(bodyContent);
                workerRequest.end();
            } catch (err) {
                logger.error("worker response error", err);
                res.statusCode = 500;
                res.end();
            }
        });
        return;
    }
    workerRequest.end();
}

function init(server) {
    logger.debug(`Registering CloudWallet component`);

    dsuBootPath = config.getConfig("componentsConfig", "cloudWallet", "dsuBootPath");

    if (dsuBootPath.startsWith(".")) {
        dsuBootPath = path.resolve(path.join(process.env.PSK_ROOT_INSTALATION_FOLDER, dsuBootPath));
    }

    logger.debug(`Using boot script for worker: ${dsuBootPath}`);

    cacheContainerPath = require("path").join(server.rootFolder, config.getConfig("externalStorage"), `cache`);

    //if a listening event is fired from this point on...
    //it means that a restart was triggered
    server.on("listening", () => {
        logger.debug(`Restarting process in progress...`);
        logger.debug(`Stopping a number of ${Object.keys(dsuWorkers).length} thread workers`);
        for (let seed in dsuWorkers) {
            let worker = dsuWorkers[seed];
            if (worker && worker.terminate) {
                worker.terminate();
            }
        }
    });
}

function handleCloudWalletRequest(request, response) {
    // use the keySSI set from the token middleware first (if present)
    const keySSI = request.keySSI || request.params.keySSI;

    let dsuWorker = dsuWorkers[keySSI];
    if (!dsuWorker) {
        dsuWorker = addDsuWorker(keySSI, request.walletAnchorId, request.headers.cookie);
    }

    dsuWorker.resolver
        .then(() => {
            forwardRequestToWorker(dsuWorker, request, response);
        })
        .catch((error) => {
            logger.error("worker resolver error", error);
            response.setHeader("Content-Type", "text/html");
            response.statusCode = 400;
            response.end(INVALID_DSU_HTML_RESPONSE);
        });
}

function getSSappTokenCookieValue(request) {
    const cookies = parseCookies(request.headers.cookie);
    let ssappTokenCookieValue = {};
    if (cookies[SSAPP_TOKEN_COOKIE_NAME]) {
        try {
            ssappTokenCookieValue = JSON.parse(cookies[SSAPP_TOKEN_COOKIE_NAME]);
            if (typeof ssappTokenCookieValue !== "object") {
                logger.error(
                    `Detected invalid ${SSAPP_TOKEN_COOKIE_NAME} cookie value (${cookies[SSAPP_TOKEN_COOKIE_NAME]}) parsed content`,
                    ssappTokenCookieValue
                );
                ssappTokenCookieValue = {};
            }
        } catch (error) {
            logger.error(`Failed to parse ${SSAPP_TOKEN_COOKIE_NAME} cookie value (${cookies[SSAPP_TOKEN_COOKIE_NAME]})`, error);
            // reset cookie value since it has an invalid JSON content
            ssappTokenCookieValue = {};
        }
    }
    return ssappTokenCookieValue;
}

function setRequestKeySSIFromSSAppToken(request, response, next) {
    const { keySSI } = request.params;
    const ssappTokenCookieValue = getSSappTokenCookieValue(request);
    if (ssappTokenCookieValue[keySSI]) {
        logger.info(`Found match for walletAnchorId ${keySSI}`);
        request.keySSI = ssappTokenCookieValue[keySSI];
        request.walletAnchorId = keySSI;
    }
    next();
}

function handleSetSSAppTokenRequest(request, response) {
    const { walletAnchorId } = request.params;
    const { sReadSSI } = request.body;

    if (!sReadSSI) {
        logger.error("Required sReadSSI body field not present");
        response.statusCode = 400;
        response.end();
    }

    const ssappTokenCookieValue = getSSappTokenCookieValue(request);
    ssappTokenCookieValue[walletAnchorId] = sReadSSI;

    const updatedTokenCookie = stringifyCookies({
        name: SSAPP_TOKEN_COOKIE_NAME,
        value: JSON.stringify(ssappTokenCookieValue),
        httpOnly: true,
        path: "/",
        maxAge: 2147483647, // (2038-01-19 04:14:07) maximum value to avoid integer overflow on older browsers
    });
    response.setHeader("Set-Cookie", updatedTokenCookie);
    response.statusCode = 200;
    response.end();
}

module.exports = {
    init,
    handleCloudWalletRequest,
    setRequestKeySSIFromSSAppToken,
    handleSetSSAppTokenRequest,
};

},{"../../config":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/apihub/config/index.js","../../utils/cookie-utils":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/apihub/utils/cookie-utils.js","crypto":false,"http":false,"path":false,"swarmutils":"swarmutils"}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/apihub/components/cloudWallet/index.js":[function(require,module,exports){
function Iframe(server) {
    const {
        init,
        setRequestKeySSIFromSSAppToken,
        handleSetSSAppTokenRequest,
        handleCloudWalletRequest,
    } = require("./controller");
    const { requestBodyJSONMiddleware } = require("../../utils/middlewares");

    init(server);

    server.put(`/cloud-wallet/setSSAPPToken/:walletAnchorId`, requestBodyJSONMiddleware);
    server.put(`/cloud-wallet/setSSAPPToken/:walletAnchorId`, handleSetSSAppTokenRequest);

    server.use(`/cloud-wallet/:keySSI/*`, setRequestKeySSIFromSSAppToken);
    server.use(`/cloud-wallet/:keySSI/*`, handleCloudWalletRequest);
    server.use(`/:walletName/loader/cloud-wallet/:keySSI/*`, setRequestKeySSIFromSSAppToken);
    server.use(`/:walletName/loader/cloud-wallet/:keySSI/*`, handleCloudWalletRequest);

    // keep old URl style
    server.put(`/iframe/setSSAPPToken/:walletAnchorId`, requestBodyJSONMiddleware);
    server.put(`/iframe/setSSAPPToken/:walletAnchorId`, handleSetSSAppTokenRequest);

    server.use(`/iframe/:keySSI/*`, setRequestKeySSIFromSSAppToken);
    server.use(`/iframe/:keySSI/*`, handleCloudWalletRequest);
    server.use(`/:walletName/loader/iframe/:keySSI/*`, setRequestKeySSIFromSSAppToken);
    server.use(`/:walletName/loader/iframe/:keySSI/*`, handleCloudWalletRequest);
}

module.exports = Iframe;

},{"../../utils/middlewares":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/apihub/utils/middlewares/index.js","./controller":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/apihub/components/cloudWallet/controller.js"}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/apihub/components/config/index.js":[function(require,module,exports){
const config = require("../../config");

function Config(server) {
    const { requestBodyJSONMiddleware, responseModifierMiddleware } = require("../../utils/middlewares");

    function getDomainConfig(request, response) {
        const { domain } = request.params;
        const domainConfig = config.getDomainConfig(domain);

        if (!domainConfig) {
            return response.send(404, "Domain not found");
        }
        response.send(200, domainConfig);
    }

    function getDomainKeySSI(request, response) {
        const { domain } = request.params;
        const domainConfig = config.getDomainConfig(domain);
        const domainKeySSI = domainConfig && domainConfig.contracts ? domainConfig.contracts.constitution : null;
        response.send(200, domainKeySSI);
    }

    function validateDomainConfigInput(request, response, next) {
        if (!request.body || typeof request.body !== "object") {
            return response(400, "Invalid domain config specified");
        }
        next();
    }

    function updateDomainConfig(request, response) {
        const { domain } = request.params;
        const domainConfig = request.body;
        config.updateDomainConfig(domain, domainConfig, (error) => {
            if (error) {
                return response.send(500, error);
            }
            response.send(200);
        });
    }

    server.use(`/config/:domain/*`, responseModifierMiddleware);

    server.get(`/config/:domain`, getDomainConfig);
    server.get(`/config/:domain/keyssi`, getDomainKeySSI);

    server.put(`/config/:domain`, requestBodyJSONMiddleware);
    server.put(`/config/:domain`, validateDomainConfigInput);
    server.put(`/config/:domain`, updateDomainConfig);
}

module.exports = Config;

},{"../../config":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/apihub/config/index.js","../../utils/middlewares":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/apihub/utils/middlewares/index.js"}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/apihub/components/contracts/boot.js":[function(require,module,exports){
async function boot(validatorDID, serverUrl, domain, domainConfig, rootFolder, storageFolder) {
    const logger = $$.getLogger("boot", "apihub/contracts");
    const logPrefix = `[contract-worker][${validatorDID}][domain]`;
    logger.debug(
        `${logPrefix} Booting contracts for domain ${domain} and domainConfig ${JSON.stringify(domainConfig)} booting...`,
        domainConfig
    );

    const worker_threads = "worker_threads";
    const { parentPort } = require(worker_threads);
    const bricksledger = require("bricksledger");

    try {
        const initiliseBrickLedger = await $$.promisify(bricksledger.initiliseBrickLedger);
        const bricksledgerInstance = await initiliseBrickLedger(
            validatorDID,
            serverUrl,
            domain,
            domainConfig,
            rootFolder,
            storageFolder
        );

        const handleCommand = async (command, callback) => {
            const params = command.params || [];

            if (command.type === "latestBlockInfo") {
                return bricksledgerInstance.getLatestBlockInfo(callback);
            }
            if (command.type === "validatePBlockFromNetwork") {
                return bricksledgerInstance.validatePBlockFromNetwork(...params, callback);
            }
            if (command.type === "setValidatorNonInclusion") {
                return bricksledgerInstance.setValidatorNonInclusion(...params, callback);
            }

            const commandExecutionCallback = async (error, commandExecution) => {
                if (error) {
                    return callback(error);
                }

                const promises = [commandExecution.requireConsensus(), commandExecution.getOptimisticExecutionResult()];

                try {
                    let [requireConsensus, optimisticExecutionResult] = await Promise.all(promises);
                    // in order to ensure result serializability we JSON.stringify it if isn't a Buffer
                    if (!$$.Buffer.isBuffer(optimisticExecutionResult)) {
                        optimisticExecutionResult = JSON.stringify(optimisticExecutionResult);
                    }

                    const result = {
                        requireConsensus,
                        optimisticResult: optimisticExecutionResult,
                        validatedResult: requireConsensus ? optimisticExecutionResult : null,
                    };
                    callback(null, result);
                } catch (error) {
                    callback(error);
                }
            };

            if (command.type === "safe") {
                return bricksledgerInstance.executeSafeCommand(command, commandExecutionCallback);
            }
            if (command.type === "nonced") {
                return bricksledgerInstance.executeNoncedCommand(command, commandExecutionCallback);
            }
            return callback(`Unknown command type '${type}' specified`);
        };

        parentPort.on("message", (message) => {
            if (!message) {
                return callback(`${logPrefix} Received empty message!`);
            }

            const command = bricksledger.createCommand(message);
            handleCommand(command, (error, result) => {
                parentPort.postMessage({ error, result });
            });
        });

        logger.debug(`${logPrefix} ready`);
        parentPort.postMessage("ready");
    } catch (error) {
        parentPort.postMessage({ error });
        throw error;
    }

    process.on("uncaughtException", (err) => {
        logger.error(`${logPrefix} unchaughtException inside worker`, err);
        setTimeout(() => {
            process.exit(1);
        }, 100);
    });
}

module.exports = boot;

},{"bricksledger":"bricksledger"}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/apihub/components/contracts/index.js":[function(require,module,exports){
(function (Buffer){(function (){
const {
    ensureContractConstitutionIsPresent,
    getNodeWorkerBootScript,
    validateCommandInput,
    validatePostCommandInput,
} = require("./utils");

function Contract(server) {
    const logger = $$.getLogger("Contract", "apihub/contracts");
    const config = require("../../config");

    const serverUrl = `${server.protocol}://${config.getConfig("host")}:${config.getConfig("port")}`;

    const syndicate = require("syndicate");
    const { requestBodyJSONMiddleware, responseModifierMiddleware } = require("../../utils/middlewares");

    const allDomainsWorkerPools = {};

    const isWorkerPoolRunningForDomain = (domain) => allDomainsWorkerPools[domain] && allDomainsWorkerPools[domain].isRunning;

    const getDomainWorkerPool = async (domain, callback) => {
        if (allDomainsWorkerPools[domain]) {
            return callback(null, allDomainsWorkerPools[domain].pool);
        }

        let domainConfig = config.getDomainConfig(domain);
        if (!domainConfig) {
            return callback(new Error('Domain is not configured'));
        }

        domainConfig = { ...domainConfig }
        ensureContractConstitutionIsPresent(domain, domainConfig);
        if (!domainConfig.contracts.constitution) {
            return callback(`[Contracts] Cannot boot worker for domain '${domain}' due to missing constitution`);
        }

        const validatorDID = config.getConfig("validatorDID");
        if (!validatorDID) {
            return callback(`[Contracts] Cannot boot worker for domain '${domain}' due to missing validatorDID`);
        }

        logger.debug(`[Contracts] Starting contract handler for domain '${domain}'...`, domainConfig);

        const { rootFolder } = server;
        const externalStorageFolder = require("path").join(rootFolder, config.getConfig("externalStorage"));
        const script = getNodeWorkerBootScript(validatorDID, domain, domainConfig, rootFolder, externalStorageFolder, serverUrl);
        const pool = syndicate.createWorkerPool({
            bootScript: script,
            maximumNumberOfWorkers: 1,
            workerOptions: {
                eval: true,
            },
        });
        allDomainsWorkerPools[domain] = {
            pool,
            isRunning: false,
        };

        callback(null, pool);
    };
    
    const responseError = (err) => {
        let resError = err;
        if (err instanceof Error) {
            resError = {
                message: err.message,
            };
            
            if (err.debug_message) {
                resError.debugMessage = err.debug_message;
            }
            
            if (err.stack) {
                resError.stack = err.stack;
            }
            
            if (err.previousError) {
                resError.previousError = responseError(err.previousError);
            }
        }
        
        resError = JSON.stringify(resError);
        return resError;
    }

    const sendCommandToWorker = (command, response, mapSuccessResponse) => {
        getDomainWorkerPool(command.domain, (err, workerPool) => {
            if (err) {
                return response.send(400, responseError(err));
            }

            workerPool.addTask(command, (err, message) => {
                allDomainsWorkerPools[command.domain].isRunning = true;

                if (err) {
                    return response.send(500, responseError(err));
                }

                let { error, result } = message;

                if (error) {
                    return response.send(500, responseError(error));
                }

                if (result && result.optimisticResult) {
                    if (result.optimisticResult instanceof Uint8Array) {
                        // convert Buffers to String to that the result could be send correctly
                        result.optimisticResult = Buffer.from(result.optimisticResult).toString("utf-8");
                    } else {
                        try {
                            result.optimisticResult = JSON.parse(result.optimisticResult);
                        } catch (error) {
                            // the response isn't a JSON so we keep it as it is
                        }
                    }
                }

                if (typeof mapSuccessResponse === "function") {
                    result = mapSuccessResponse(result);
                }

                return response.send(200, result);
            });
        });
    };

    const sendGetBdnsEntryToWorker = (request, response) => {
        const { domain, entry } = request.params;
        if (!entry || typeof entry !== "string") {
            return response.send(400, "Invalid entry specified");
        }
        if (!isWorkerPoolRunningForDomain(domain)) {
            return response.send(500, "Contracts not booted");
        }

        const command = {
            domain,
            contractName: "bdns",
            methodName: "getDomainEntry",
            params: [entry],
            type: "safe",
        };
        const mapSuccessResponse = (result) => (result ? result.optimisticResult : null);
        sendCommandToWorker(command, response, mapSuccessResponse);
    };

    const sendLatestBlockInfoCommandToWorker = (request, response) => {
        const { domain } = request.params;
        const command = { domain, type: "latestBlockInfo" };
        sendCommandToWorker(command, response);
    };

    const sendSafeCommandToWorker = (request, response) => {
        const { domain } = request.params;
        const command = { ...request.body, domain, type: "safe" };
        sendCommandToWorker(command, response);
    };

    const sendNoncedCommandToWorker = (request, response) => {
        const { domain } = request.params;
        const command = { ...request.body, domain, type: "nonced" };
        sendCommandToWorker(command, response);
    };

    const sendPBlockToValidateToWorker = (request, response) => {
        const { domain } = request.params;
        const message = request.body;
        const command = { domain, type: "validatePBlockFromNetwork", params: [message] };
        sendCommandToWorker(command, response);
    };

    const sendValidatorNonInclusionToWorker = (request, response) => {
        const { domain } = request.params;
        const message = request.body;
        const command = { domain, type: "setValidatorNonInclusion", params: [message] };
        sendCommandToWorker(command, response);
    };

    server.use(`/contracts/:domain/*`, responseModifierMiddleware);
    server.use(`/contracts/:domain/*`, requestBodyJSONMiddleware);
    server.use(`/contracts/:domain/*`, validateCommandInput);
    server.post(`/contracts/:domain/*`, validatePostCommandInput);

    server.get(`/contracts/:domain/bdns-entries/:entry`, sendGetBdnsEntryToWorker);
    server.get(`/contracts/:domain/latest-block-info`, sendLatestBlockInfoCommandToWorker);
    server.post(`/contracts/:domain/safe-command`, sendSafeCommandToWorker);
    server.post(`/contracts/:domain/nonced-command`, sendNoncedCommandToWorker);
    server.post(`/contracts/:domain/pblock-added`, sendPBlockToValidateToWorker);
    server.post(`/contracts/:domain/validator-non-inclusion`, sendValidatorNonInclusionToWorker);
}

module.exports = Contract;

}).call(this)}).call(this,require("buffer").Buffer)

},{"../../config":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/apihub/config/index.js","../../utils/middlewares":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/apihub/utils/middlewares/index.js","./utils":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/apihub/components/contracts/utils.js","buffer":false,"path":false,"syndicate":"syndicate"}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/apihub/components/contracts/utils.js":[function(require,module,exports){
(function (global,__dirname){(function (){
const logger = $$.getLogger("utils", "contracts");

function escapePath(path) {
    return path ? path.replace(/\\/g, "\\\\").replace(".js", "") : "";
}

function ensureContractConstitutionIsPresent(domain, domainConfig) {
    if (!domainConfig.contracts) {
        domainConfig.contracts = {};
    }

    const contractsConfig = domainConfig.contracts;
    if (!contractsConfig.constitution) {
        // ensure we have the SSI for the contracts DSU speficied inside domainConfig.contracts.constitution
        if (process.env.PSK_APIHUB_DEFAULT_CONTRACTS_DOMAIN_SSI) {
            contractsConfig.constitution = process.env.PSK_APIHUB_DEFAULT_CONTRACTS_DOMAIN_SSI;
            logger.debug(
                `[Contracts] no constitution found for domain ${domain}. Found process.env.PSK_APIHUB_DEFAULT_CONTRACTS_DOMAIN_SSI: ${contractsConfig.constitution}`
            );
        } else {
            const pathName = "path";
            const path = require(pathName);
            const fsName = "fs";
            const fs = require(fsName);

            const pskFolder = process.env.PSK_ROOT_INSTALATION_FOLDER || path.resolve("." + __dirname + "/../../../..");
            const defaultDomainSeedPath = path.join(pskFolder, "modules/apihub-contracts/domain-seed");

            logger.debug(
                `[Contracts] no constitution found for domain ${domain}. Trying to load constitution at ${defaultDomainSeedPath}...`
            );

            try {
                fs.accessSync(defaultDomainSeedPath, fs.F_OK);
                const defaultDomainSeedData = fs.readFileSync(defaultDomainSeedPath);
                contractsConfig.constitution = defaultDomainSeedData.toString();
            } catch (error) {
                logger.error(`Cannot access default domain-seed at: ${defaultDomainSeedPath}`);
            }
        }
    }
}

function getNodeWorkerBootScript(validatorDID, domain, domainConfig, rootFolder, externalStorageFolder, serverUrl) {
    const apihubBundleScriptPath = escapePath(global.bundlePaths.pskWebServer);
    const rootFolderPath = escapePath(rootFolder);
    const externalStorageFolderPath = escapePath(externalStorageFolder);
    serverUrl = escapePath(serverUrl);
    domainConfig = JSON.stringify(domainConfig);

    const script = `
        require("${apihubBundleScriptPath}");
        (${require("./boot").toString()})('${validatorDID}', '${serverUrl}', '${domain}', ${domainConfig}, '${rootFolderPath}', '${externalStorageFolderPath}');
    `;
    return script;
}

const validateCommandInput = (request, response, next) => {
    const { domain } = request.params;
    if (!domain || typeof domain !== "string") {
        return response.send(400, "Invalid domain specified");
    }

    const config = require("../../config");
    const configuredDomains = config.getConfiguredDomains();
    if (!configuredDomains.includes(domain)) {
        return response.send(404, `Unsupported domain '${domain}' specified`);
    }

    next();
};

const validatePostCommandInput = (request, response, next) => {
    if (!request.body) {
        return response.send(400, "Missing required body");
    }

    next();
};

module.exports = {
    ensureContractConstitutionIsPresent,
    getNodeWorkerBootScript,
    validateCommandInput,
    validatePostCommandInput,
};

}).call(this)}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},"/modules/apihub/components/contracts")

},{"../../config":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/apihub/config/index.js","./boot":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/apihub/components/contracts/boot.js"}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/apihub/components/debugLogger/controllers.js":[function(require,module,exports){
const url = require('url');
const fs = require('fs');
const path = require('swarmutils').path;
const API_HUB = require('apihub');

let config = API_HUB.getServerConfig();
const rootFolder = arguments.rootFolder || path.resolve(config.storage);

const levels = {
  error: 'error',
  warning: 'warning',
  info: 'info',
  debug: 'debug',
};

const logger = $$.getLogger("debugLogger", "apihub/debugLogger");

function createHandlerAppendToLog(server) {
  return function appendToLog(request, response) {
    if (!request.body || !request.body.message) {
      response.send(400);
      return;
    }
    const message = request.body && request.body.message;
    const anchorID = request.params.anchorID;
    const logLevel = levels[request.params.logLevel] || levels['info'];

    let data;

    if (message && typeof message === 'string') {
      data = { date: new Date().toISOString(), level: logLevel, anchorID: anchorID, message: message };
    } else {
      response.send(400);
      return;
    }

    try {
      const today = new Date().toISOString().split('T')[0];
      const fileName = `${rootFolder}/${today}.json`;

      const exists = fs.existsSync(fileName);

      if (exists) {
        const existingData = fs.readFileSync(fileName);
        const json = JSON.parse(existingData);
        json.push(data);
        fs.writeFile(fileName, JSON.stringify(json), (err) => {
          if (err) {
            response.send(500);
            logger.error(err);
            logger.error(err);

          } else {
            response.send(200, data);

          }
        });
      } else {
        fs.writeFile(fileName, JSON.stringify([data]), (err) => {
          if (err) {
            response.send(500);
            logger.error(err);

          } else {
            response.send(200, data);

          }
        });
      }
    } catch (err) {
      logger.error(err);
      logger.error('Error writing file to disk');
    }
  };
}

function createHandlerReadFromLog(server) {
  return function readFromLog(request, response) {
    logger.debug('running');
    const today = new Date().toISOString().split('T')[0];
    const anchorID = request.params.anchorID;
    const queryObject = url.parse(request.url, true).query;
    const logLevel = levels[queryObject.logLevel] || levels['info'];

    let fromDate = queryObject.from ? Date.parse(queryObject.from) : Date.parse(today);
    const toDate = queryObject.to ? Date.parse(queryObject.to) : Date.parse(today);
    const oneDay = 1000 * 60 * 60 * 24;

    let promises = [];

    for (fromDate; fromDate <= toDate; fromDate += oneDay) {
      const date = new Date(fromDate).toISOString().split('T')[0];
      const fileName = `${rootFolder}/${date}.json`;
      const exists = fs.existsSync(fileName);

      if (!exists) {
        continue;
      }

      promises.push(
        new Promise((resolve, reject) => {
          fs.readFile(fileName, (err, data) => {
            if (err) {
              reject(err);
            }
            data = JSON.parse(data);
            data = data.filter((log) => log.anchorID === anchorID);
            data = data.filter((log) =>
              logLevel === levels['debug']
                ? log.level === levels['info'] ||
                  log.level === levels['error'] ||
                  log.level === levels['warning'] ||
                  log.level === levels['debug']
                : logLevel === levels['error']
                ? log.level === levels['info'] || log.level === levels['error'] || log.level === levels['warning']
                : logLevel === levels['warning']
                ? log.level === levels['info'] || log.level === levels['warning']
                : log.level === levels['info']
            );

            resolve(data);
          });
        })
      );
    }

    Promise.all(promises).then((result) => {
      response.send(200, result.flat());
    });
  };
}

module.exports = { createHandlerAppendToLog, createHandlerReadFromLog };

},{"apihub":"apihub","fs":false,"swarmutils":"swarmutils","url":false}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/apihub/components/debugLogger/index.js":[function(require,module,exports){
function DebugLogger(server) {
  const { responseModifierMiddleware, requestBodyJSONMiddleware } = require('../../utils/middlewares');
  const { createHandlerAppendToLog, createHandlerReadFromLog } = require('./controllers');

  const appendToLog = createHandlerAppendToLog(server);
  const readFromLog = createHandlerReadFromLog(server);

  server.use(`/log/*`, responseModifierMiddleware);
  server.use(`/log/*`, requestBodyJSONMiddleware);

  server.post(`/log/add/:anchorID/:logLevel`, appendToLog);
  server.get(`/log/get/:anchorID`, readFromLog);
}

module.exports = DebugLogger;

},{"../../utils/middlewares":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/apihub/utils/middlewares/index.js","./controllers":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/apihub/components/debugLogger/controllers.js"}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/apihub/components/enclave/commands/LokiEnclaveFacade.js":[function(require,module,exports){
const getLokiEnclaveFacade = (storageFolder) => {
    if (!$$.LokiEnclaveFacade) {
        const LokiEnclaveFacade = require("loki-enclave-facade");
        $$.LokiEnclaveFacade = new LokiEnclaveFacade(storageFolder)
    }

    return $$.LokiEnclaveFacade;
}

module.exports = {
    getLokiEnclaveFacade
}
},{"loki-enclave-facade":"loki-enclave-facade"}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/apihub/components/enclave/index.js":[function(require,module,exports){

const openDSU = require("opendsu");
const { getLokiEnclaveFacade } = require("./commands/LokiEnclaveFacade");
const w3cDID = openDSU.loadAPI("w3cdid");
const path = require("path");

function LokiEnclaveFacade(server) {
    const logger = $$.getLogger("LokiEnclaveFacade", "apihub/enclave");
    let didDocument;

    w3cDID.createIdentity("key", undefined, process.env.REMOTE_ENCLAVE_SECRET, (err, didDoc) => {
        didDocument = didDoc;
        
        didDocument.waitForMessages(async (err, res) => {
            if (err) {
                logger.error(err);
                return
            }

            try {
                processCommand(JSON.parse(res));
            }
            catch (err) {
                logger.error(err);
            }
        });
    });

    async function processCommand(resObj) {
        const clientDID = resObj.params.pop();
        const lokiAdaptor = getLokiEnclaveFacade(getStorageFolder());

        const result = await executeCommand(resObj, lokiAdaptor);
        sendResult(didDocument, result, clientDID);
    }

    async function executeCommand(resObj, lokiAdaptor) {
        try {
            const command = resObj.commandName;
            const params = resObj.params;
            let dbResult = await $$.promisify(lokiAdaptor[command]).apply(lokiAdaptor, params) ?? {};
            return JSON.stringify({ "commandResult": dbResult, "commandID": resObj.commandID })
        }
        catch (err) {
            logger.error(err);
            return err;
        }
    }

    function sendResult(didDocument, result, clientDID) {
        didDocument.sendMessage(result, clientDID, (err, res) => {
            if (err) {
                logger.error(err);
            }
        })
    }

    function getStorageFolder() {
        const enclavePath = server.config.componentsConfig.enclave.storageFolder ?? path.join("external-volume", "enclave");
        return path.join(server.rootFolder, enclavePath);
    }

}

module.exports = {
    LokiEnclaveFacade
};

},{"./commands/LokiEnclaveFacade":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/apihub/components/enclave/commands/LokiEnclaveFacade.js","opendsu":"opendsu","path":false}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/apihub/components/fileManager/controllers/downloadFile.js":[function(require,module,exports){
function sendResult(resHandler, resultStream) {
    resHandler.statusCode = 200;
    resultStream.pipe(resHandler);

    resultStream.on('finish', () => {
        resHandler.end();
    });
}

function downloadFile(req, res) {
    download(req, res, (err, result) => {
        if (err) {
            res.statusCode = 404;
            res.end();
        } else {
            sendResult(res, result);
        }
    });
}

function download(req, res, callback) {
    const fs = require('fs');
    const path = require("swarmutils").path;
    const config = require('../../../config');

    const readFileStream = req;
    if (!readFileStream || !readFileStream.pipe || typeof readFileStream.pipe !== "function") {
        callback(new Error("Something wrong happened"));
        return;
    }

    const folder = $$.Buffer.from(req.params.filepath, 'base64').toString().replace('\n', '');
    const completeFolderPath = path.join(config.getConfig('storage'), folder);

    if (folder.includes('..')) {
        return callback(new Error("invalidPath"));
    }

    if (fs.existsSync(completeFolderPath)) {
        const fileToSend = fs.createReadStream(completeFolderPath);
        res.setHeader('Content-Type', `image/${folder.split('.')[1]}`);
        return callback(null, fileToSend);
    }

    return callback(new Error("PathNotFound"));
}

module.exports = downloadFile;

},{"../../../config":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/apihub/config/index.js","fs":false,"swarmutils":"swarmutils"}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/apihub/components/fileManager/controllers/uploadFile.js":[function(require,module,exports){
function guid() {
    function s4() {
        return Math.floor((1 + Math.random()) * 0x10000)
            .toString(16)
            .substring(1);
    }

    return `${s4()}${s4()}-${s4()}-${s4()}-${s4()}-${s4()}${s4()}${s4()}`;
}

function uploadFile(req, res) {
    upload(req, (err, result) => {
        if (err) {
            res.statusCode = 500;
            res.end();
        } else {
            res.statusCode = 200;
            res.end(JSON.stringify(result));
        }
    })
};

function upload(req, callback) {
    const fs = require('fs');
    const path = require("swarmutils").path;
    const config = require('../../../config');

    const readFileStream = req;
    if (!readFileStream || !readFileStream.pipe || typeof readFileStream.pipe !== "function") {
        return callback(new Error("Something wrong happened"));
    }

    const folder = $$.Buffer.from(req.params.folder, 'base64').toString().replace('\n', '');

    if (folder.includes('..')) {
        return callback('err');
    }

    let filename = guid();

    if (filename.split('.').length > 1) {
        return callback('err');
    }

    const completeFolderPath = path.join(config.getConfig('storage'), folder);

    const contentType = req.headers['content-type'].split('/');

    if (contentType[0] === 'image' || (contentType[0] === 'application' && contentType[1] === 'pdf')) {
        filename += '.' + contentType[1];
    } else {
        return callback('err');
    }

    try {
        fs.mkdirSync(completeFolderPath, { recursive: true });
    } catch (e) {
        return callback(e);
    }

    const writeStream = fs.createWriteStream(path.join(completeFolderPath, filename));

    writeStream.on('finish', () => {
        writeStream.close();
        return callback(null, { 'path': path.join(folder, filename) });
    });

    writeStream.on('error', (err) => {
        writeStream.close();
        return callback(err);
    });

    req.pipe(writeStream);
}

module.exports =  uploadFile;

},{"../../../config":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/apihub/config/index.js","fs":false,"swarmutils":"swarmutils"}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/apihub/components/fileManager/index.js":[function(require,module,exports){
function filesManager(server) {

	const uploadFile = require('./controllers/uploadFile');
	const downloadFile = require('./controllers/downloadFile');

	server.post('/files/upload/:folder', uploadFile);
	server.get('/files/download/:filepath', downloadFile);
}

module.exports = filesManager;
},{"./controllers/downloadFile":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/apihub/components/fileManager/controllers/downloadFile.js","./controllers/uploadFile":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/apihub/components/fileManager/controllers/uploadFile.js"}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/apihub/components/installation-details/index.js":[function(require,module,exports){
function InstallationDetails(server){

	function getLog(targetPath, callback){
		const child_process = require("child_process");
		const path = require("path");

		const basicProcOptions = {cwd: path.resolve(targetPath), stdio: [0, "pipe", "pipe"]};
		child_process.exec(" git log -n 1  --pretty=oneline", basicProcOptions, function (err, stdout, stderr) {
			if (err) {
				return callback(err);
			}
			let sep = " ";
			let fragments = stdout.split(sep);
			let details = {
				commitNo: fragments.shift(),
				commitMessage: fragments.join(sep)
			};
			return callback(undefined, details);
		});
	}

	function sendSummary(res, summary){
		res.setHeader('Content-Type', 'application/json');
		res.write(JSON.stringify(summary));
		res.end();
	}

	function detailsHandler(req, res){
		const path = require("path");
		//targetPath = the workspace folder
		let targetPath = path.resolve("..");
		let summary = {};
		summary.resourceUsage = getProcessResourceUsage();
		getLog(targetPath, (err, log)=>{
			if(err){
				return sendSummary(res, {err});
			}
			summary[path.basename(targetPath)] = log;

			//targetPath = the privatesky folder
			let tPath = path.resolve(".");
			getLog(tPath, (err, log)=>{
				if(err){
					return sendSummary(res, {err, summary});
				}
				summary[path.basename(tPath)] = log;
				return sendSummary(res, summary);
			});
		});
	}
	
	function getProcessResourceUsage() {
		const resourceUsage = process.resourceUsage();
		resourceUsage.uptime = process.uptime();
		return resourceUsage;
	}

	server.get("/installation-details", detailsHandler);
}

module.exports = InstallationDetails;
},{"child_process":false,"path":false}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/apihub/components/keySsiNotifications/constants.js":[function(require,module,exports){
const URL_PREFIX = '/notifications';

module.exports = { URL_PREFIX };
},{}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/apihub/components/keySsiNotifications/index.js":[function(require,module,exports){
function KeySSINotifications(server) {
	const logger = $$.getLogger("KeySSINotifications", "apihub/keySsiNotifications");
	let notificationManager;
	const utils = require('../../utils');
	const readBody = utils.streams.readStringFromStream;
	const config = require('../../config');
	const { responseModifierMiddleware } = require('./../../utils/middlewares');
	const { URL_PREFIX } = require('./constants');
	const path = require("path");
	const workingDirPath = path.join(server.rootFolder, config.getConfig('componentsConfig', 'notifications', 'workingDirPath'));
    const QUEUED_MESSAGE_LIFETIME = 500; // (ms) Delete undelivered messages after this timeout

	function publish(request, response) {
		let anchorId = request.params.anchorId;

		readBody(request, (err, message) => {
			if (err) {
				return response.send(400);
			}

			notificationManager.createQueue(anchorId, function (err) {
				if (err) {
					if (err.statusCode) {
						if (err.statusCode !== 409) {
							return response.send(err.statusCode);
						}
					} else {
						return response.send(500);
					}
				}

				notificationManager.sendMessage(anchorId, message, QUEUED_MESSAGE_LIFETIME, function (err, counter) {
					if (err) {
						return response.send(500);
					}

					let message;

					if (counter > 0) {
						message = `Message delivered to ${counter} subscribers.`;
					} else {
						message = `Message was added to queue and will be delivered later.`;
					}

					return response.send(200, message);
				});
			});
		});
	}

	function subscribe(request, response) {
		let anchorId = request.params.anchorId;

		notificationManager.createQueue(anchorId, function (err) {
			if (err) {
				if (err.statusCode) {
					if (err.statusCode !== 409) {
						return response.send(err.statusCode);
					}
				} else {
					return response.send(500);
				}
			}

			notificationManager.readMessage(anchorId, function (err, message) {
				try {
					if (err) {
						return response.send(err.statusCode || 500, message);
					}

					response.send(200, message);
				} catch (err) {
					//here we expect to get errors when a connection has reached timeout
					logger.error(err);
					response.send(400, 'opps');
				}
			});
		});
	}

	function unsubscribe(request, response) {
		//to be implemented later
		response.send(503);
	}

	require('./../../libs/Notifications').getManagerInstance(workingDirPath, (err, instance) => {
		if (err) {
			return logger.error(err);
		}

		notificationManager = instance;
		server.use(`${URL_PREFIX}/*`, responseModifierMiddleware)

		server.post(`${URL_PREFIX}/subscribe/:anchorId`, subscribe);
		server.delete(`${URL_PREFIX}/unsubscribe/:anchorId`, unsubscribe);
		server.put(`${URL_PREFIX}/publish/:anchorId`, publish);
	});
}

module.exports = KeySSINotifications;

},{"../../config":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/apihub/config/index.js","../../utils":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/apihub/utils/index.js","./../../libs/Notifications":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/apihub/libs/Notifications.js","./../../utils/middlewares":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/apihub/utils/middlewares/index.js","./constants":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/apihub/components/keySsiNotifications/constants.js","path":false}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/apihub/components/mainDSU/controller.js":[function(require,module,exports){
const path = require("path");
const fs = require("fs");
const config = require("../../config");
const { parseCookies, stringifyCookies } = require("../../utils/cookie-utils");

const logger = $$.getLogger("controller", "apihub/mainDSU");

const MAIN_DSU_VALUE_COOKIE_NAME = "MAIN-DSU-VALUE";
const MAIN_DSU_VALUE_COOKIE_DEFAULT = "default";

// keep already loaded main DSUs KeySSI
const cachedMainDSUSeedSSIs = {};

let rootFolderPath;
let mainDSUSeedSSIFolderPath;

async function init(server) {
    logger.debug(`[MainDSU] Registering MainDSU component`);
    rootFolderPath = server.rootFolder;
    mainDSUSeedSSIFolderPath = path.join(server.rootFolder, config.getConfig("externalStorage"), "maindsu");
    logger.debug(`[MainDSU] Ensuring MainDSU seedSSI folder (${mainDSUSeedSSIFolderPath}) is created`);
    try {
        await $$.promisify(fs.mkdir)(mainDSUSeedSSIFolderPath, { recursive: true });
    } catch (error) {
        logger.error("[MainDSU] Failed to create MainDSU seedSSI folder", error);
    }
}

function sendMainDSUSeedSSI(mainDSUFileName, response) {
    response.statusCode = 200;
    response.write(cachedMainDSUSeedSSIs[mainDSUFileName].getIdentifier());
    response.end();
}

function getMainDSUFileNameForRequest(request) {
    const cookies = request.headers ? parseCookies(request.headers.cookie) : {};
    const valueCookie = cookies[MAIN_DSU_VALUE_COOKIE_NAME];
    if (valueCookie) {
        const crypto = require("pskcrypto");
        // we need to ensure some filename limit due to some OS filename size restrictions
        const valueCookieHash = crypto.pskHash(valueCookie, "hex");
        return valueCookieHash;
    }
    return MAIN_DSU_VALUE_COOKIE_DEFAULT;
}

async function handleSetSSIForMainDSUCookie(request, response) {
    const { value } = request.body;

    if (value == null) {
        logger.error("Required value body field not present");
        response.statusCode = 400;
        response.end();
    }

    const cookie = stringifyCookies({
        name: MAIN_DSU_VALUE_COOKIE_NAME,
        value: value,
        httpOnly: true,
        path: "/",
        maxAge: 2147483647, // (2038-01-19 04:14:07) maximum value to avoid integer overflow on older browsers
    });
    response.setHeader("Set-Cookie", cookie);
    response.statusCode = 200;
    response.end();
}

async function handleDefaultMainDSURequest(request, response) {
    const mainDSUFileName = getMainDSUFileNameForRequest(request);

    if (cachedMainDSUSeedSSIs[mainDSUFileName]) {
        return sendMainDSUSeedSSI(mainDSUFileName, response);
    }

    const mainDSUSeedSSIFilePath = path.join(mainDSUSeedSSIFolderPath, mainDSUFileName);

    const fs = require("fs");
    const keySSISpace = require("opendsu").loadApi("keyssi");
    const resolver = require("opendsu").loadApi("resolver");
    let mainDSUSeedSSI;
    let mainDSUAnchorId;
    try {
        const fileContent = await $$.promisify(fs.readFile)(mainDSUSeedSSIFilePath, { encoding: "utf-8" });
        mainDSUSeedSSI = keySSISpace.parse(fileContent);
        cachedMainDSUSeedSSIs[mainDSUFileName] = mainDSUSeedSSI;
        mainDSUAnchorId = await $$.promisify(mainDSUSeedSSI.getAnchorId)();
        logger.debug(`[MainDSU] Read existing mainDSU from ${mainDSUSeedSSIFilePath}: ${mainDSUAnchorId}`);
        return sendMainDSUSeedSSI(mainDSUFileName, response);
    } catch (error) {
        logger.error(`[MainDSU] Failed to read/parse keySSI from ${mainDSUSeedSSIFilePath}. Generating new keySSI...`, error);
    }

    try {
        const environmentJsPath = require("path").join(rootFolderPath, "environment.js");
        logger.debug(`[MainDSU] Loading environment.js config file from: ${environmentJsPath}`);

        const environmentConfig = require(environmentJsPath);

        const seedSSI = await $$.promisify(keySSISpace.createSeedSSI)(environmentConfig.vaultDomain);
        const mainDSU = await $$.promisify(resolver.createDSUForExistingSSI)(seedSSI);

        logger.debug(`[MainDSU] Settings config for seed ${await $$.promisify(seedSSI.getAnchorId)()}`, environmentConfig);
        await $$.promisify(mainDSU.writeFile)("/environment.json", JSON.stringify(environmentConfig));

        mainDSUSeedSSI = seedSSI;
        cachedMainDSUSeedSSIs[mainDSUFileName] = mainDSUSeedSSI;
        mainDSUAnchorId = await $$.promisify(mainDSUSeedSSI.getAnchorId)();
        logger.debug("[MainDSU] Generated mainDSUSeedSSI: ", mainDSUAnchorId, mainDSUSeedSSI);

        logger.debug(`[MainDSU] Writing generated mainDSU to ${mainDSUSeedSSIFilePath}: ${mainDSUAnchorId}`);
        await $$.promisify(fs.writeFile)(mainDSUSeedSSIFilePath, mainDSUSeedSSI.getIdentifier(), "utf-8");

        sendMainDSUSeedSSI(mainDSUFileName, response);
    } catch (error) {
        logger.error("[MainDSU] Failed to create seedSSI", error);
        response.statusCode = 500;
        response.setHeader("Content-Type", "text/html");
        response.end("Failed to create seedSSI");
    }
}

module.exports = {
    init,
    handleSetSSIForMainDSUCookie,
    handleDefaultMainDSURequest,
};

},{"../../config":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/apihub/config/index.js","../../utils/cookie-utils":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/apihub/utils/cookie-utils.js","fs":false,"opendsu":"opendsu","path":false,"pskcrypto":"pskcrypto"}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/apihub/components/mainDSU/index.js":[function(require,module,exports){
function MainDSU(server) {
    const { init, handleSetSSIForMainDSUCookie, handleDefaultMainDSURequest } = require("./controller");
    const { requestBodyJSONMiddleware } = require("../../utils/middlewares");

    init(server);

    server.put("/setSSIForMainDSUCookie", requestBodyJSONMiddleware);
    server.put("/setSSIForMainDSUCookie", handleSetSSIForMainDSUCookie);

    // for mobile app, when it includes the expanded DSU content instead of the actual DSU;
    // this will return a static DSU in order to set it as a main context
    server.use("/getSSIForMainDSU", handleDefaultMainDSURequest);
}

module.exports = MainDSU;

},{"../../utils/middlewares":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/apihub/utils/middlewares/index.js","./controller":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/apihub/components/mainDSU/controller.js"}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/apihub/components/mqHub/adapters/localMQAdapter.js":[function(require,module,exports){
(function (Buffer){(function (){
function LocalMQAdapter(server, prefix, domain, configuration) {
	const logger = $$.getLogger("LocalMQAdapter", "apihub/mqHub");
	const subscribers = {};
	const config = require("../../../config");
	const utils = require('./../../../utils');
	const swarmUtils = require('swarmutils');
	let path = swarmUtils.path;
	const readBody = utils.streams.readStringFromStream;
	const FILENAME_DELIMITER = "_special_mqs_delimiter_";

	let storage = config.getConfig('componentsConfig', 'mqs', 'storage');
	if (typeof storage === "undefined") {
		storage = path.join(server.rootFolder, "external-volume", "mqs", domain);
	} else {
		storage = path.join(path.resolve(storage), domain);
	}

	const settings = {
		mq_fsStrategyStorageFolder: storage,
		mq_fsMessageMaxSize: 10 * 1024,
		mq_fsQueueLength: 100
	};

	Object.assign(settings, configuration);

	function getQueueStoragePath(queueName) {
		const opendsu = require("opendsu");
		const crypto = opendsu.loadAPI('crypto');
		if (queueName.indexOf(':') !== -1) {
			queueName = crypto.encodeBase58(queueName);
		}
		return path.join(settings.mq_fsStrategyStorageFolder, queueName);
	}

	function checkQueueLoad(queueName, callback) {
		loadQueue(queueName, (err, files) => {
			if (err) {
				return callback(err);
			}
			callback(undefined, files.length);
		});
	}

	function sanitizeFileName(filename){
		if(filename.indexOf(FILENAME_DELIMITER)!==-1){
			//if we find filename_delimiter in filename then we need to remove the delimiter in order to be able to sort the queue
			filename = filename.split(FILENAME_DELIMITER)[0];
		}
		return filename;
	}

	function loadQueue(queueName, callback) {
		require('fs').readdir(getQueueStoragePath(queueName), (err, files) => {
			if (err) {
				if(err.code !== "ENOENT"){
					return callback(err);
				}
				//storage folder for the queue doesn't exist => empty queue
				return callback(undefined, []);
			}
			let messages = files.filter(fileNamesAsTimestamp => {
				fileNamesAsTimestamp = sanitizeFileName(fileNamesAsTimestamp);
				let valid = (new Date(Number(fileNamesAsTimestamp))).getTime() > 0;
				if (!valid) {
					logger.debug(`Found garbage in queue ${queueName} (file: ${fileNamesAsTimestamp}). Ignoring it!`);
				}
				return valid;
			});

			messages.sort(function (a, b) {
				a = sanitizeFileName(a);
				b = sanitizeFileName(b);
				return (new Date(Number(a))).getTime() - (new Date(Number(b))).getTime();
			});
			return callback(undefined, messages);
		});
	}

	function constructFileName(proposedFileName, callback) {
		let finalName = proposedFileName;
		let filename = sanitizeFileName(finalName);
		let counter = -1;

		let FS = require('fs');

		if(filename!==finalName){
			counter = Number(finalName.replace(filename+FILENAME_DELIMITER, ""));
		}

		let exists = FS.statSync(finalName, {throwIfNoEntry: false});
		if(!exists){
			try{
				FS.writeFileSync(finalName, "");
			}catch (e){
				//we ignore this e on purpose
			}
            callback(undefined, finalName);
        }else{
			counter++;
			finalName = filename+FILENAME_DELIMITER+counter;
			constructFileName(finalName, callback);
		}
	}

	function storeMessage(queueName, message, callback) {
		const queueDir = getQueueStoragePath(queueName);
		require('fs').mkdir(queueDir, {recursive: true}, (err)=>{
			if (err) {
				return callback(err);
			}

			let fileName = path.join(getQueueStoragePath(queueName), new Date().getTime());
			let FS = require('fs');
			constructFileName(fileName, (err, finalName)=>{
				FS.writeFile(finalName, message, (err) => {
					if (err) {
						return callback(err);
					}
					return callback(undefined, finalName);
				});
			});
		});
	}

	function getMessagePath(queueName, messageId) {
		return path.join(getQueueStoragePath(queueName), messageId);
	}

	function getMessage(queueName, messageId, callback) {
		let fileName = getMessagePath(queueName, messageId);
		require('fs').readFile(fileName, (err, message) => {
			if (err) {
				return callback(err);
			}
			return callback(undefined, {message:message.toString(), messageId});
		});
	}

	function deleteMessage(queueName, messageId, callback) {
		let fileName = getMessagePath(queueName, messageId);
		require('fs').unlink(fileName, callback);
	}

	function _readMessage(queueName, messageId, callback) {
		if (typeof messageId === "function") {
			callback = messageId;
			messageId = undefined;
		}
		loadQueue(queueName, (err, messageIds) => {
			if (err) {
				return callback(err);
			}

			if (typeof messageId !== "undefined") {
				if (messageIds.indexOf(messageId) !== -1) {
					return callback(Error("Message not found."));
				}
			} else {
				messageId = messageIds[0];
			}
			return getMessage(queueName, messageId, callback);
		});
	}

	function deliverMessage(subs, message, callback) {
		let counter = 0;
		while (subs.length > 0) {
			let sub = subs.pop();
			try {
				sub(undefined, message);
				counter++;
			} catch (err) {
				//if something happens during message delivery we will catch the error here
			}
		}
		callback(undefined, counter);
	}

	function putMessage(queueName, message, callback) {
		checkQueueLoad(queueName, (err, capacity) => {
			if (err) {
				return callback(err);
			}

			if (typeof subscribers[queueName] === 'undefined') {
				subscribers[queueName] = [];
			}

			const capacityLimit = Number(settings.mq_fsQueueLength);

			if(capacity > capacityLimit){
				const err = new Error("Queue size exceeded!");
				err.sendToUser = true;
				return callback(err);
			}

			if (capacity > 0) {
				return storeMessage(queueName, message, callback);
			}

			//if queue is empty we should try to deliver the message to a potential subscriber that waits
			const subs = subscribers[queueName];
			storeMessage(queueName, message, (err)=>{
				if (err) {
					return callback(err);
				}
				return _readMessage(queueName, (err, _message) => {
					if (err) {
						return callback(err);
					}
					deliverMessage(subs, _message, callback);
				});
			})
		});
	}

	function readMessage(queueName, callback) {
		checkQueueLoad(queueName, (err, capacity) => {
			if (err) {
				return callback(err);
			}

			if (typeof subscribers[queueName] === 'undefined') {
				subscribers[queueName] = [];
			}

			const subs = subscribers[queueName];
			subs.push(callback);

			if (capacity) {
				return _readMessage(queueName, (err, message) => {
					deliverMessage(subs, message, (err, successCount) => {
						if (err) {
							logger.error(err);
						}

						logger.debug(`Successfully sent message to a number of ${successCount} subs.`);
					});
				});
			} else {
				//no message available in queue
			}
		});
	}

	function send(res, statusCode, message, headers) {
		res.statusCode = statusCode;

		if (headers) {
			for (let prop in headers) {
				try {
                    res.setHeader(prop, headers[prop]);
				} catch (e) {
                    logger.error(`Failed to set headers after end() was called.`, e);
                    return;
				}
			}
		}

		if (message) {
			res.write(message);
		}
		res.end();
	}

	function putMessageHandler(request, response) {
		let queueName = request.params.queueName;
		readBody(request, (err, message) => {
			if (err) {
				logger.error(`Caught an error during body reading from put message request`, err);
				return send(response, 500);
			}

			if(typeof settings.mq_fsMessageMaxSize !== "undefined"){
				const messageMaxSize = Number(settings.mq_fsMessageMaxSize);
				try{
					let messageAsBuffer = Buffer.from(message);
					if(messageAsBuffer.length > messageMaxSize){
						send(response, 403, "Message size exceeds domain specific limit.");
						return;
					}
				}catch(err){
					logger.error("Not able to confirm message size. Going on with the flow...");
				}
			}

			putMessage(queueName, message, (err) => {
				if (err) {
					logger.error(`Caught an error during adding message to queue`, err);
					return send(response, 500, err.sendToUser ? err.message : undefined);
				}
				send(response, 200);
			});
		});
	}

	function getMessageHandler(request, response) {
		let queueName = request.params.queueName;
		let wasCalled = false;
		const readMessageCallback = (err, message) => {
			if (wasCalled) {
				return;
			}
			wasCalled = true;
			if (err) {
				send(response, 500);
				return;
			}
			send(response, 200, JSON.stringify(message), {'Content-Type': 'application/json'});
		};

		const mqConfig = config.getConfig("componentsConfig", "mq");
		if (mqConfig && mqConfig.connectionTimeout) {
			setTimeout(() => {
				if (!wasCalled) {
					const fnRefIndex = subscribers[queueName].findIndex(fn => fn === readMessageCallback);
					if (fnRefIndex >= 0) {
						subscribers[queueName].splice(fnRefIndex, 1);
					}
					response.statusCode = 204;
					response.end();
				}
			}, mqConfig.connectionTimeout);
		}

		readMessage(queueName, readMessageCallback);
	}

	function deleteMessageHandler(request, response) {
		let {queueName, messageId} = request.params;
		deleteMessage(queueName, messageId, (err) => {
			if (err) {
				logger.error(`Caught an error during deleting message ${messageId} from queue ${queueName}`, err);
			}
			send(response, err ? 500 : 200);
		});
	}

	function takeMessageHandler(request, response) {
		const queueName = request.params.queueName;
		readMessage(queueName, (err, message) => {
			if (err) {
				logger.error(`Caught an error during message reading from ${queueName}`, err);
				send(response, 500);
				return;
			}
			deleteMessage(queueName, message.messageId, (err) => {
				if (err) {
					logger.error(`Caught an error during message deletion from ${queueName} on the take handler`, err);
					return send(response, 500);
				}

				return send(response, 200, JSON.stringify(message), {'Content-Type': 'application/json'});
			});
		});
	}

	logger.debug(`Loading Local MQ Adapter for domain: ${domain}`);

	server.put(`${prefix}/${domain}/put/:queueName`, putMessageHandler); //< message

	server.get(`${prefix}/${domain}/get/:queueName/:signature_of_did`, getMessageHandler); //  > {message}
	server.delete(`${prefix}/${domain}/delete/:queueName/:messageId/:signature_of_did`, deleteMessageHandler);

	server.get(`${prefix}/${domain}/take/:queueName/:signature_of_did`, takeMessageHandler); //  > message
}


module.exports = LocalMQAdapter;
}).call(this)}).call(this,require("buffer").Buffer)

},{"../../../config":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/apihub/config/index.js","./../../../utils":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/apihub/utils/index.js","buffer":false,"fs":false,"opendsu":"opendsu","swarmutils":"swarmutils"}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/apihub/components/mqHub/adapters/solaceMQAdapter.js":[function(require,module,exports){
function SolaceMQAdapter(configuration){
	throw new Error("Not Implemented!!!");
}

module.exports = SolaceMQAdapter;
},{}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/apihub/components/mqHub/auth/JWTIssuer.js":[function(require,module,exports){
const DOMAIN_NAME = "MQ_DOMAIN";
const SEEDER_FILE_NAME = "mq_JWT_Auth_Seeder";

const defaultSettings = {
	//todo: implement them later!!!
	mq_nonce_from_smart_contract: false,
	mq_nonce_from_expiring_uuid: true,

	mq_nonce_expiration_time: 10 * 1000//sec
}

function JWTIssuer(workingDir) {
	const logger = $$.getLogger("JWTIssuer", "apihub/mqHub");
	let seeder;
	const config = require("./../../../config");

	function getDomainSpecificConfig(domainName){
		let domainSpecificConfig = JSON.parse(JSON.stringify(defaultSettings));
		Object.assign(domainSpecificConfig, config.getDomainConfig(domainName));
		return domainSpecificConfig;
	}

	function getSeederFilePath(){
		return require("path").join(workingDir, config.getConfig("externalStorage"), SEEDER_FILE_NAME);
	}

	async function init() {
		const fs = require("fs");
		const opendsu = require("opendsu");
		const keyssiApi = opendsu.loadApi("keyssi");

		try {
			seeder = await $$.promisify(fs.readFile)(getSeederFilePath());
		} catch (err) {
			if (err.code !== "ENOENT") {
				logger.error("Not able to read the Issuer persistence file needed by JWT Auth Support layer!", err);
			}
		}

		if (seeder) {
			try {
				seeder = keyssiApi.parse(seeder.toString());
				logger.debug("MQ JWT AUTH Issuer loaded.");
				return;
			} catch (err) {
				logger.error("Failed to load MQ JWT AUTH Issuer info. Creating a new Issuer!",
					"\nPrevious tokens will not be valid anymore!!!");
			}
		}

		//TODO: what happens if it fails to generate and write to file?

		seeder = await $$.promisify(keyssiApi.createSeedSSI)(DOMAIN_NAME);
		await $$.promisify(fs.writeFile)(getSeederFilePath(), seeder.getIdentifier());
		logger.debug("New MQ JWT AUTH Issuer created and saved for later use.");
	}

	this.createToken = function (domain, options, callback) {
		if (typeof options === "function") {
			callback = options;
			options = {};
		}

		function createToken() {
			const opendsu = require("opendsu");
			const crypto = opendsu.loadApi("crypto");
			const keyssiApi = opendsu.loadApi("keyssi");
			const scope = "/mq";
			const credentials = options.credentials || [];

			keyssiApi.createTemplateSeedSSI(domain, (err, subject) => {
				if (err) {
					return callback(err);
				}
				options.subject = subject;
				const cfg = getDomainSpecificConfig(domain);
				//setting the JWT token valid period based on the config
				options.valability = cfg.mq_nonce_expiration_time;

				return crypto.createJWT(seeder, scope, credentials, options, (err, token)=>{
					if(err){
						return callback(err);
					}
					crypto.parseJWTSegments(token, (err, segments)=>{
						if(err){
							return callback(err);
						}
						return callback(undefined, {token, expires: segments.body.exp*1000});
					});
				});
			});
		}

		if (!seeder) {
			init().then(createToken);
			return;
		}

		createToken();
	}

	this.validateToken = function (token, callback) {
		function validateToken() {
			const opendsu = require("opendsu");
			const crypto = opendsu.loadApi("crypto");
			return crypto.verifyJWT(token, null, callback);
		}

		if (!seeder) {
			init().then(validateToken);
			return;
		}

		validateToken();
	}

	this.isOwner = function (token, resource, callback) {
		this.validateToken(token, (err, valid) => {
			if (err || !valid) {
				return callback(err || new Error("Invalid token"));
			}

			const opendsu = require("opendsu");
			const crypto = opendsu.loadApi("crypto");
			return crypto.parseJWTSegments(token, (err, segments) => {
				if (err) {
					return callback(err);
				}
				const valid = segments && segments.body && Array.isArray(segments.body.credentials) && segments.body.credentials.indexOf(resource) !== -1;
				return callback(undefined, valid);
			});
		});
	}
}

module.exports = JWTIssuer;
},{"./../../../config":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/apihub/config/index.js","fs":false,"opendsu":"opendsu","path":false}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/apihub/components/mqHub/index.js":[function(require,module,exports){
const config = require("../../config");
const URL_PREFIX = "/mq";
//known implementations for the MQ adapters
const adapterImpls = {
	local: require("./adapters/localMQAdapter.js"),
	solace: require("./adapters/solaceMQAdapter.js")
};

//just to expose the possibility to add new implementations for the adapters
function registerMQAdapterImpl(adapterName, adapterImpl) {
	adapterImpls[adapterName] = adapterImpl;
}

const defaultSettings = {
	// normally there are gateways timeouts of 30seconds
	mq_client_timeout: 60 * 1000,//sec
	// not sure about the response.setTimeout(msecs[, callback]) available on nodejs docs

	mq_throttling: 2, //2 per second
	mq_allow_unregistered_did: false
}

async function MQHub(server, signalAsyncLoading, doneLoading) {

	server.registerAccessControlAllowHeaders(["token", "authorization"]);

	const logger = $$.getLogger("MQHub", "apihub/mqHub");

	signalAsyncLoading();

	const config = require("./../../config/index");

	const JWTIssuer = require("./auth/JWTIssuer");
	const issuer = new JWTIssuer(server.rootFolder);

	let domains = []; //config.getConfiguredDomains();

	function getTokenHandler(request, response) {
		const domain = request.params.domain;
		issuer.createToken(domain, {credentials: request.params.hashDID}, (err, tokenObj) => {
			if (err) {
				logger.info(0x03, "Not able to create a new token.", err);
				response.statusCode = 500;
				return response.end();
			}

			const mqConfig = config.getConfig("componentsConfig", "mq");
			if (mqConfig && mqConfig.connectionTimeout) {
				response.writeHead(200, {
					"connection-timeout": mqConfig.connectionTimeout
				});
			} else {
				response.statusCode = 200;
			}

			response.write(JSON.stringify(tokenObj));
			response.end();
		});
	}

	async function allowUnregisteredDID(domainName){
		const domainConfig = await config.getSafeDomainConfig(domainName);
		let allowUnregisteredDID = defaultSettings.mq_allow_unregistered_did;
		if(domainConfig && typeof domainConfig.mq_allow_unregistered_did !== "undefined"){
			allowUnregisteredDID = !!domainConfig.mq_allow_unregistered_did;
		}
		return allowUnregisteredDID;
	}

	async function putMessageHandler(request, response, next) {
		const domainName = request.params.domain;
		if (domains.indexOf(domainName) === -1) {
			logger.info(0x03, `Caught an request to the MQs for domain ${domainName}. Looks like the domain doesn't have mq component enabled.`);
			response.statusCode = 405;
			response.end();
			return;
		}

		let token = request.headers['authorization'];

		if(! await allowUnregisteredDID(domainName) && !token){
			logger.info(0x03, `No token was available on the request and the domain ${domainName} configuration prohibits unregisteredDIDs to use the MQ api.`);
			response.statusCode = 403;
			response.end();
			return;
		}

		issuer.validateToken(token, (err, valid) => {
			let errorMsg = "Not able to validate token: ";
			if (!valid) {
				errorMsg = "Token not valid: ";
			}
			if (err || !valid) {
				logger.info(0x03, `${errorMsg} < ${token} >`, err ? err : "");
				response.statusCode = 403;
				response.end();
				return;
			}

			//all good continue to the domain specific mq handler
			return next();
		});
	}

	async function getMessageHandler(request, response, next) {
		const domainName = request.params.domain;
		if (domains.indexOf(domainName) === -1) {
			logger.info(0x03, `Caught an request to the MQs for domain ${domainName}. Looks like the domain doesn't have mq component enabled.`);
			response.statusCode = 405;
			response.end();
			return;
		}

		let token = request.headers['authorization'];

		if(! await allowUnregisteredDID(domainName) && !token){
			logger.info(0x03, `No token was available on the request and the domain ${domainName} configuration prohibits unregisteredDIDs to use the MQ api.`);
			response.statusCode = 403;
			response.end();
			return;
		}

		issuer.isOwner(token, request.params.hashDID, (err, isOwner) => {
			let errorMsg = "Not able to validate authorization token: ";
			if (!isOwner) {
				errorMsg = "Ownership not confirmed based on token: ";
			}
			if (err || !isOwner) {
				logger.info(0x03, `${errorMsg} < ${token} >`, err ? err : "");
				response.statusCode = 403;
				response.end();
				return;
			}

			//all good continue to the domain specific mq handler
			return next();
		});
	}

	function deleteMessageHandler(request, response, next) {
		getMessageHandler(request, response, next);
	}

	function takeMessageHandler(request, response, next) {
		getMessageHandler(request, response, next);
	}

	server.get(`${URL_PREFIX}/:domain/:hashDID/token`, getTokenHandler); //> JWT Token

	server.put(`${URL_PREFIX}/:domain/put/:hashDID`, putMessageHandler); //< message

	server.get(`${URL_PREFIX}/:domain/get/:hashDID/:signature_of_did`, getMessageHandler); //  > {message}
	server.delete(`${URL_PREFIX}/:domain/delete/:hashDID/:messageID/:signature_of_did`, deleteMessageHandler);

	server.get(`${URL_PREFIX}/:domain/take/:hashDID/:signature_of_did`, takeMessageHandler); //  > message

	function testIfMQEnabled(domain, domainToBeUsedByAdapter){
		let domainConfig = config.getDomainConfig(domain);

		if (domainConfig && domainConfig.enable && domainConfig.enable.indexOf("mq") !== -1) {
			const adapterTypeName = domainConfig["mq_type"] || "local";
			const adapter = adapterImpls[adapterTypeName];
			if (!adapter) {
				logger.info(0x03, `Not able to recognize the mq_type < ${adapterTypeName} > from the domain < ${domain} > config.`);
				return;
			}

			try {
				logger.debug(`Preparing to register mq endpoints for domain < ${domain} > ... `);
				adapter(server, URL_PREFIX, domainToBeUsedByAdapter || domain, domainConfig);
			} catch (err) {
				logger.info(0x03, `Caught an error during initialization process of the mq for domain < ${domain} >`, err);
				return;
			}

			return true;
		}
	}

	async function setupDomainSpecificHandlers() {
		let confDomains = typeof config.getConfiguredDomains !== "undefined" ? config.getConfiguredDomains() : ["default"];
		try{
			let adminService = require("./../../components/admin").getAdminService();
			let getDomains = $$.promisify(adminService.getDomains);
			let virtualDomains = await getDomains();
			for(let i=0; i<virtualDomains.length; i++){
				let domainInfo = virtualDomains[i];
				if(domainInfo && domainInfo.active && domainInfo.cloneFromDomain){
					if(testIfMQEnabled(domainInfo.cloneFromDomain, domainInfo.pk)){
						logger.debug(`Successfully register mq endpoints for virtual domain < ${domainInfo.pk} >.`);
						domains.push(domainInfo.pk);
					}
				}
			}
		}catch(err){
			//we ignore any errors;
		}

		for (let i = 0; i < confDomains.length; i++) {
			let domain = confDomains[i];
			if(testIfMQEnabled(domain)){
				logger.debug(`Successfully register mq endpoints for domain < ${domain} >.`);
				domains.push(domain);
			}
		}
	}

	await setupDomainSpecificHandlers();
	doneLoading();
}

module.exports = {
	MQHub
};

},{"../../config":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/apihub/config/index.js","./../../components/admin":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/apihub/components/admin/index.js","./../../config/index":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/apihub/config/index.js","./adapters/localMQAdapter.js":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/apihub/components/mqHub/adapters/localMQAdapter.js","./adapters/solaceMQAdapter.js":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/apihub/components/mqHub/adapters/solaceMQAdapter.js","./auth/JWTIssuer":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/apihub/components/mqHub/auth/JWTIssuer.js"}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/apihub/components/requestForwarder/index.js":[function(require,module,exports){
const registeredUrl = "/forwardRequestForAuthenticatedClient";
const logger = $$.getLogger("requestForwarder", "apihub/requestForwarder");
module.exports = function(server){
    server.post(registeredUrl, require("./../../utils/middlewares/index").requestBodyJSONMiddleware);

    server.post(registeredUrl, function(req, res, next){
        let url = req.body.url;

        if(!url){
            res.statusCode = 400;
            return res.end();
        }

        let body = req.body.body || "";
        let options = req.body.options || {method: "POST"};

        let http = require("http");
        if(url.startsWith("https://")){
            http = require("https");
        }

        logger.debug(`Forwarding request ${options.method} to url ${url}`);
        try {

          let request = http.request(url, options, (response) => {
            res.statusCode = response.statusCode;
            if (res.statusCode > 300) {
              res.end();
            }
            response.on("data", res.write);
            response.on('end', res.end);
          });

          request.on("error", (err) => {
            res.statusCode = 500;
            res.end();
          });

          request.write(body);
          request.end();
        } catch (e) {
          logger.error("Error on request: ", e);
          res.statusCode = 500;
          res.end();
        }
    });
}

},{"./../../utils/middlewares/index":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/apihub/utils/middlewares/index.js","http":false,"https":false}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/apihub/components/secrets/SecretsService.js":[function(require,module,exports){
const fs = require("fs");
const path = require("path");
const config = require("../../config");

function SecretsService(serverRootFolder) {
    const logger = $$.getLogger("secrets", "apihub/secrets");
    const crypto = require("opendsu").loadAPI("crypto");
    const createError = (code, message) => {
        const err = Error(message);
        err.code = code

        return err;
    }

    const encryptSecret = (secret) => {
        const encryptionKeys = process.env.SSO_SECRETS_ENCRYPTION_KEY.split(",");
        let latestEncryptionKey = encryptionKeys[0];
        if (!$$.Buffer.isBuffer(latestEncryptionKey)) {
            latestEncryptionKey = $$.Buffer.from(latestEncryptionKey, "base64");
        }

        return crypto.encrypt(secret, latestEncryptionKey);
    }

    const writeSecrets = (appName, secrets, callback) => {
        if (typeof secrets === "object") {
            secrets = JSON.stringify(secrets);
        }
        const encryptedSecrets = encryptSecret(secrets);
        fs.writeFile(getSecretFilePath(appName), encryptedSecrets, callback);
    }

    const ensureFolderExists = (folderPath, callback) => {
        fs.access(folderPath, (err) => {
            if (err) {
                fs.mkdir(folderPath, {recursive: true}, callback);
                return;
            }

            callback();
        })
    }

    const getStorageFolderPath = () => {
        return path.join(serverRootFolder, config.getConfig("externalStorage"), "secrets");
    }

    const getSecretFilePath = (appName) => {
        const folderPath = getStorageFolderPath(appName);
        return path.join(folderPath, `${appName}.secret`);
    }

    const decryptSecret = (appName, encryptedSecret, callback) => {
        const encryptionKeys = process.env.SSO_SECRETS_ENCRYPTION_KEY.split(",");
        const latestEncryptionKey = encryptionKeys[0].trim();
        let decryptedSecret;
        const _decryptSecretRecursively = (index) => {
            const encryptionKey = encryptionKeys[index].trim();
            if (typeof encryptionKey === "undefined") {
                logger.error(`Failed to decrypt secret. Invalid encryptionKey.`);
                callback(createError(500, `Failed to decrypt secret`));
                return;
            }
            let bufferEncryptionKey = encryptionKey;
            if (!$$.Buffer.isBuffer(bufferEncryptionKey)) {
                bufferEncryptionKey = $$.Buffer.from(bufferEncryptionKey, "base64");
            }

            try {
                decryptedSecret = crypto.decrypt(encryptedSecret, bufferEncryptionKey);
            } catch (e) {
                _decryptSecretRecursively(index + 1);
                return;
            }

            if (latestEncryptionKey !== encryptionKey) {
                logger.info(0x501, "Secrets Encryption Key rotation detected");
                writeSecrets(appName, decryptedSecret.toString(), err => {
                    if (err) {
                        logger.info(0x501, `Re-encrypting Recovery Passphases on disk file ${getSecretFilePath(appName)} failed due to error: ${err}`);
                        return callback(err);
                    }
                    logger.info(0x501, `Re-encrypting Recovery Passphases on disk file ${getSecretFilePath(appName)} completed`)
                    callback(undefined, decryptedSecret);
                });

                return;
            }

            callback(undefined, decryptedSecret);
        }

        _decryptSecretRecursively(0);
    }

    const getDecryptedSecrets = (appName, callback) => {
        const filePath = getSecretFilePath(appName);
        fs.readFile(filePath, (err, secrets) => {
            if (err) {
                logger.error(`Failed to read file ${filePath}`);
                return callback(createError(500, `Failed to read file ${filePath}`));
            }

            decryptSecret(appName, secrets, (err, decryptedSecrets) => {
                if (err) {
                    return callback(err);
                }

                try {
                    decryptedSecrets = JSON.parse(decryptedSecrets.toString());
                } catch (e) {
                    logger.error(`Failed to parse secrets`);
                    return callback(createError(500, `Failed to parse secrets`));
                }

                callback(undefined, decryptedSecrets);
            })
        });
    }

    this.putSecret = (appName, userId, secret, callback) => {
        if (typeof process.env.SSO_SECRETS_ENCRYPTION_KEY === "undefined") {
            logger.warn(`The SSO_SECRETS_ENCRYPTION_KEY is missing from environment.`);
            return callback(createError(500, `The SSO_SECRETS_ENCRYPTION_KEY is missing from environment.`));
        }
        const folderPath = getStorageFolderPath();
        ensureFolderExists(folderPath, err => {
            if (err) {
                return callback(createError(500, `Failed to store secret for user ${userId}`));
            }

            getDecryptedSecrets(appName, (err, decryptedSecrets) => {
                if (err) {
                    decryptedSecrets = {};
                }

                decryptedSecrets[userId] = secret;
                writeSecrets(appName, decryptedSecrets, callback);
            })
        })
    }

    this.getSecret = (appName, userId, callback) => {
        getDecryptedSecrets(appName, (err, decryptedSecrets) => {
            if (err) {
                return callback(err);
            }

            const secret = decryptedSecrets[userId];
            if (typeof secret === "undefined") {
                return callback(createError(404, `Secret for user ${userId} not found`));
            }

            callback(undefined, JSON.stringify({secret}));
        })
    }

    this.deleteSecret = (appName, userId, callback) => {
        getDecryptedSecrets(appName, (err, decryptedSecrets) => {
            if (err) {
                return callback(err);
            }

            delete decryptedSecrets[userId];
            writeSecrets(appName, decryptedSecrets, callback);
        })
    }
}

module.exports = SecretsService;

},{"../../config":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/apihub/config/index.js","fs":false,"opendsu":"opendsu","path":false}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/apihub/components/secrets/index.js":[function(require,module,exports){

function secrets(server) {
    const logger = $$.getLogger("secrets", "apihub/secrets");
    const httpUtils = require("../../libs/http-wrapper/src/httpUtils");
    const SecretsService = require("./SecretsService");
    const secretsService = new SecretsService(server.rootFolder);

    const getSSOSecret = (request, response) => {
        let userId = request.headers["user-id"];
        let appName = request.params.appName;
        secretsService.getSecret(appName, userId, (err, secret)=>{
            if (err) {
                response.statusCode = err.code;
                response.end(err.message);
                return;
            }

            response.statusCode = 200;
            response.end(secret);
        })
    }

    const putSSOSecret = (request, response) => {
        let userId = request.headers["user-id"];
        let appName = request.params.appName;
        let secret;
        try {
            secret = JSON.parse(request.body).secret;
        } catch (e) {
            logger.error("Failed to parse body", request.body);
            response.statusCode = 500;
            response.end(e);
            return;
        }

        secretsService.putSecret(appName, userId, secret, err => {
            if (err) {
                response.statusCode = err.code;
                response.end(err.message);
                return;
            }

            response.statusCode = 200;
            response.end();
        });
    };

    const getUserIdFromDID = (did, appName) => {
        const crypto = require("opendsu").loadAPI("crypto");
        const decodedDID = crypto.decodeBase58(did);
        const splitDecodedDID = decodedDID.split(":");
        let name = splitDecodedDID.slice(3).join(":");
        let userId = name.slice(appName.length + 1);
        return userId;
    }

    const deleteSSOSecret = (request, response) => {
        let did = request.params.did;
        let appName = request.params.appName;
        let userId = getUserIdFromDID(did, appName);

        secretsService.deleteSecret(appName, userId, err => {
            if (err) {
                response.statusCode = err.code;
                response.end(err.message);
                return;
            }

            response.statusCode = 200;
            response.end();
        });
    }
    
    const logEncryptionTest = () => {
        const key = "presetEncryptionKeyForInitialLog";
        const text = "TheQuickBrownFoxJumpedOverTheLazyDog";

        logger.info(0x500, "Recovery Passphrase Encryption Check\nPlain text: " + text);
        logger.info(0x500, "Preset encryption key: " + key);

        const filePath = require("path").join(server.rootFolder, "initialEncryptionTest");
        const encryptedText = require("opendsu").loadAPI("crypto").encrypt(text, key).toString("hex");

        logger.info(0x500, "Writing encrypted file on disk: " + filePath);
        logger.info(0x500, "Cipher text(file contents): " + encryptedText);

        require("fs").writeFile(filePath, encryptedText, (err) => {
            if (err) {
                logger.info(0x500, "Failed to write file: " + filePath + " Error: " + err);
            }
        });
    }

    logEncryptionTest();
    server.put('/putSSOSecret/*', httpUtils.bodyParser);
    server.get("/getSSOSecret/:appName", getSSOSecret);
    server.put('/putSSOSecret/:appName', putSSOSecret);
    server.delete("/deactivateSSOSecret/:appName/:did", deleteSSOSecret);
    server.delete("/removeSSOSecret/:appName/:did", deleteSSOSecret);
}

module.exports = secrets;

},{"../../libs/http-wrapper/src/httpUtils":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/apihub/libs/http-wrapper/src/httpUtils.js","./SecretsService":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/apihub/components/secrets/SecretsService.js","fs":false,"opendsu":"opendsu","path":false}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/apihub/components/staticServer/index.js":[function(require,module,exports){
function StaticServer(server) {
    const fs = require("fs");
    const path = require('swarmutils').path;
    const utils = require("../../utils");
    const config = require("../../config");
    let componentsConfig = config.getConfig("componentsConfig");
    const logger = $$.getLogger("StaticServer", "apihub/staticServer");
    let excludedFilesRegex;
    if (componentsConfig && componentsConfig.staticServer && componentsConfig.staticServer.excludedFiles) {
        excludedFilesRegex = componentsConfig.staticServer.excludedFiles.map(str => new RegExp(str));
    }
    function sendFiles(req, res, next) {
        const prefix = "/directory-summary/";
        requestValidation(req, "GET", prefix, function (notOurResponsibility, targetPath) {
            if (notOurResponsibility) {
                return next();
            }
            targetPath = targetPath.replace(prefix, "");
            serverTarget(targetPath);
        });

        function serverTarget(targetPath) {
            logger.debug("Serving summary for dir:", targetPath);
            fs.stat(targetPath, function (err, stats) {
                if (err) {
                    logger.info(0x04, `Path <${targetPath}> was not found`)
                    res.statusCode = 404;
                    res.end();
                    return;
                }
                if (!stats.isDirectory()) {
                    logger.info(0x04, `<${targetPath}> is not a directory`)
                    res.statusCode = 403;
                    res.end();
                    return;
                }

                function send() {
                    res.statusCode = 200;
                    res.setHeader('Content-Type', "application/json");
                    //let's clean some empty objects
                    for (let prop in summary) {
                        if (Object.keys(summary[prop]).length === 0) {
                            delete summary[prop];
                        }
                    }

                    res.write(JSON.stringify(summary));
                    res.end();
                }

                let summary = {};
                let directories = {};

                function extractContent(currentPath) {
                    directories[currentPath] = -1;
                    let summaryId = currentPath.replace(targetPath, "");
                    summaryId = summaryId.split(path.sep).join("/");
                    if (summaryId === "") {
                        summaryId = "/";
                    }
                    //summaryId = path.basename(summaryId);
                    summary[summaryId] = {};

                    fs.readdir(currentPath, function (err, files) {
                        if (err) {
                            return markAsFinish(currentPath);
                        }
                        directories[currentPath] = files.length;
                        //directory empty test
                        if (files.length === 0) {
                            return markAsFinish(currentPath);
                        } else {
                            for (let i = 0; i < files.length; i++) {
                                let file = files[i];
                                const fileName = path.join(currentPath, file);
                                if (fs.statSync(fileName).isDirectory()) {
                                    extractContent(fileName);
                                } else {
                                    let fileContent = fs.readFileSync(fileName);
                                    let fileExtension = fileName.substring(fileName.lastIndexOf(".") + 1);
                                    let mimeType = utils.getMimeTypeFromExtension(fileExtension);
                                    if (mimeType.binary) {
                                        summary[summaryId][file] = Array.from(fileContent);
                                    } else {
                                        summary[summaryId][file] = fileContent.toString();
                                    }

                                }
                                directories[currentPath]--;
                            }
                            return markAsFinish(currentPath);
                        }
                    });
                }

                function markAsFinish(targetPath) {
                    if (directories [targetPath] > 0) {
                        return;
                    }
                    delete directories [targetPath];
                    const dirsLeftToProcess = Object.keys(directories);
                    //if there are no other directories left to process
                    if (dirsLeftToProcess.length === 0) {
                        send();
                    }
                }

                extractContent(targetPath);
            })
        }

    }

    function tryToCreateAtRuntimeFromTemplates(req, callback){

        let adminService;
        try{
            adminService = require("./../admin").getAdminService();
        }catch(err){
            //logger.error("Caught an error durring admin service initialization", err);
            return callback(err);
        }

        adminService.checkForTemplate(req.url, (err, template)=>{
            if(err){
                //logger.error("Not able to find template for", req.url);
                //console.trace(err);
                return callback(err);
            }
            if(template){
                let fileContent = template.content;
                const urlObject = new URL(req.url, `http://${req.headers.host}`);
                let hostname = urlObject.hostname;
                return adminService.getDomainSpecificVariables(hostname, (err, variables)=>{
                    if(err || !variables){
                        return callback(err);
                    }
                    let domainVariables = Object.keys(variables);
                    for(let i=0; i<domainVariables.length; i++){
                        let variableName = domainVariables[i];
                        let variableValue = variables[variableName];

                        const lookupFor = "${"+variableName+"}";
                        fileContent = fileContent.split(lookupFor).join(variableValue);
                    }

                    return callback(undefined, fileContent);
                });
            }else{
                return callback(new Error(`No template found for ${req.url}`));
            }
        });
    }

    function resolveFileAndSend(req, res, file){
        tryToCreateAtRuntimeFromTemplates(req,(err, content)=>{
            if(err){
                //console.trace(err);
                //if any error... we fallback to normal sendFile method
                return sendFile(res, file);
            }
            logger.debug("Responding with template instead of file.");
            res.statusCode = 200;

            setMimeTypeOnResponse(req.url, res);

            res.setHeader('Cache-Control', 'no-store');
            res.end(content);
        });
    }

    function setMimeTypeOnResponse(file, res){
        let ext = path.extname(file);

        if (ext !== "") {
            ext = ext.replace(".", "");
            res.setHeader('Content-Type', utils.getMimeTypeFromExtension(ext).name);
        } else {
            res.setHeader('Content-Type', "application/octet-stream");
        }
    }

    function sendFile(res, file) {
        if (excludedFilesRegex) {
            let index = excludedFilesRegex.findIndex(regExp => file.match(regExp) !== null);
            if (index >= 0) {
                res.statusCode = 403;
                res.end();
                return;
            }
        }
        let stream = fs.createReadStream(file);
        setMimeTypeOnResponse(file, res);


        // instruct to not store response into cache
        res.setHeader('Cache-Control', 'no-store');
        res.statusCode = 200;
        stream.pipe(res);
        stream.on('finish', () => {
            res.end();
        });
    }

    function requestValidation(req, method, urlPrefix, callback) {
        if (typeof urlPrefix === "function") {
            callback = urlPrefix;
            urlPrefix = undefined;
        }

        if (req.method !== method) {
            //we resolve only GET requests
            return callback(true);
        }

        if (typeof urlPrefix !== "undefined") {
            if (req.url.indexOf(urlPrefix) !== 0) {
                return callback(true);
            }
        }

        const rootFolder = server.rootFolder;
        const path = require("swarmutils").path;
        let requestedUrl = new URL(req.url, `http://${req.headers.host}`);
        let requestedUrlPathname = requestedUrl.pathname;
        if (urlPrefix) {
            requestedUrlPathname = requestedUrlPathname.replace(urlPrefix, "");
        }
        let targetPath = path.resolve(path.join(rootFolder, requestedUrlPathname));
        //if we detect tricks that tries to make us go above our rootFolder to don't resolve it!!!!

        if (targetPath.indexOf(rootFolder) !== 0) {
            return callback(true);
        }

        callback(false, targetPath);
    }

    function redirect(req, res, next) {
        requestValidation(req, "GET", function (notOurResponsibility, targetPath) {
            if (notOurResponsibility) {
                return next();
            }
            //from now on we mean to resolve the url
            //remove existing query params
            fs.stat(targetPath, function (err, stats) {
                if (err) {
                    return tryToCreateAtRuntimeFromTemplates(req,(err, content)=>{
                        if(err){
                            //if any error... we have to return 404
                            logger.info(0x04, `Failed to create from templates`)
                            res.statusCode = 404;
                            res.end();
                            return;
                        }
                        res.statusCode = 200;
                        res.setHeader('Cache-Control', 'no-store');
                        res.end(content);
                    });
                }

                if (stats.isDirectory()) {

                    let protocol = req.socket.encrypted ? "https" : "http";
                    let url = new URL(req.url, `${protocol}://${req.headers.host}`);

                    if (url.pathname[url.pathname.length - 1] !== "/") {
                        res.writeHead(302, {
                            'Location': url.pathname + "/" + url.search
                        });
                        res.end();
                        return;
                    }

                    const defaultFileName = "index.html";
                    const defaultPath = path.join(targetPath, defaultFileName);
                    fs.stat(defaultPath, function (err) {
                        if (err) {
                            logger.info(0x04, `Path <${defaultPath}> was not found`)
                            res.statusCode = 403;
                            res.end();
                            return;
                        }

                        return resolveFileAndSend(req, res, defaultPath);
                    });
                } else {
                    return resolveFileAndSend(req, res, targetPath);
                }
            });
        });
    }

    server.use("*", sendFiles);
    server.use("*", redirect);
}

module.exports = StaticServer;

},{"../../config":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/apihub/config/index.js","../../utils":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/apihub/utils/index.js","./../admin":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/apihub/components/admin/index.js","fs":false,"swarmutils":"swarmutils"}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/apihub/components/stream/controller.js":[function(require,module,exports){
(function (global){(function (){
const syndicate = require("syndicate");
const logger = $$.getLogger("stream", "apihub/stream");

const dsuWorkers = {};

function getNodeWorkerBootScript() {
    const openDSUScriptPath = global.bundlePaths.openDSU.replace(/\\/g, "\\\\").replace(".js", "");
    return `
        require("${openDSUScriptPath}");
        (${require("./worker-script").toString()})();
    `;
}

async function handleCreateWallet(request, response) {
    try {
        const { domain, userId } = request.params;
        const keySSISpace = require("opendsu").loadApi("keyssi");
        const resolver = require("opendsu").loadApi("resolver");

        const crypto = require("pskcrypto");
        const credential = crypto.randomBytes(64).toString("hex");

        const walletSSI = keySSISpace.createTemplateWalletSSI(domain, credential);
        const seedSSI = await $$.promisify(keySSISpace.createSeedSSI)(domain);

        logger.debug(`[Stream] Creating wallet ${walletSSI.getIdentifier()} for user ${userId}...`);
        const walletDSU = await $$.promisify(resolver.createDSUForExistingSSI)(walletSSI, { dsuTypeSSI: seedSSI });

        const writableDSU = walletDSU.getWritableDSU();

        const enclaveKeySSIObject = await $$.promisify(resolver.createSeedDSU)(domain);
        const enclaveKeySSI = await $$.promisify(enclaveKeySSIObject.getKeySSIAsString)();

        const sharedEnclaveKeySSIObject = await $$.promisify(resolver.createSeedDSU)(domain);
        const sharedEnclaveKeySSI = await $$.promisify(sharedEnclaveKeySSIObject.getKeySSIAsString)();

        const constants = require("opendsu").constants;
        const environmentConfig = {
            vaultDomain: domain,
            didDomain: domain,
            enclaveType: constants.ENCLAVE_TYPES.WALLET_DB_ENCLAVE,
            enclaveKeySSI,
            sharedEnclaveType: constants.ENCLAVE_TYPES.WALLET_DB_ENCLAVE,
            sharedEnclaveKeySSI,
        };

        logger.debug(`[Stream] Settings config for wallet ${await $$.promisify(walletSSI.getAnchorId)()}`, environmentConfig);
        await $$.promisify(writableDSU.writeFile)("/environment.json", JSON.stringify(environmentConfig));

        await $$.promisify(writableDSU.writeFile)("/metadata.json", JSON.stringify({ userId }));

        response.statusCode = 200;
        return response.end(walletSSI.getIdentifier());
    } catch (error) {
        logger.error("[Stream] Error", error);
        response.statusCode = 500;
        return response.end(error);
    }
}

async function handleStreamRequest(request, response) {
    const { keySSI } = request.params;
    let requestedPath = request.url.substr(request.url.indexOf(keySSI) + keySSI.length);
    if (!requestedPath) {
        requestedPath = "/";
    }
    if (!requestedPath.startsWith("/")) {
        requestedPath = `/${requestedPath}`;
    }

    let range = request.headers.range;
    if (!range) {
        response.statusCode = 400;
        return response.end("Requires Range header");
    }

    let dsuWorker = dsuWorkers[keySSI];
    if (!dsuWorker) {
        dsuWorker = syndicate.createWorkerPool({
            bootScript: getNodeWorkerBootScript(),
            maximumNumberOfWorkers: 1,
            workerOptions: {
                eval: true,
                workerData: {
                    keySSI,
                },
            },
        });
        dsuWorkers[keySSI] = dsuWorker;
    }

    const sendTaskToWorker = (task, callback) => {
        dsuWorker.addTask(task, (err, message) => {
            if (err) {
                return callback(err);
            }

            let { error, result } = typeof Event !== "undefined" && message instanceof Event ? message.data : message;

            if (error) {
                return callback(error);
            }

            if (result && result.buffer && result.buffer instanceof Uint8Array) {
                result.buffer = $$.Buffer.from(result.buffer);
            }

            callback(error, result);
        });
    };

    const task = {
        requestedPath,
        range,
    };

    try {
        const taskResult = await $$.promisify(sendTaskToWorker)(task);
        response.writeHead(206, taskResult.headers);
        response.end(taskResult.buffer);
    } catch (error) {
        logger.error("[Stream] error", error);
        response.statusCode = 500;
        return response.end(error);
    }
}

module.exports = {
    handleCreateWallet,
    handleStreamRequest,
};

}).call(this)}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./worker-script":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/apihub/components/stream/worker-script.js","opendsu":"opendsu","pskcrypto":"pskcrypto","syndicate":"syndicate"}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/apihub/components/stream/index.js":[function(require,module,exports){
function Iframe(server) {
    const { handleCreateWallet, handleStreamRequest } = require("./controller");
    server.put(`/stream/:domain/create-wallet/:userId`, handleCreateWallet);
    server.get(`/stream/:keySSI/*`, handleStreamRequest);
}

module.exports = Iframe;

},{"./controller":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/apihub/components/stream/controller.js"}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/apihub/components/stream/worker-script.js":[function(require,module,exports){
(function (Buffer){(function (){
module.exports = async () => {
    const logger = $$.getLogger("worker-script", "apihub/stream");
    //we inject a supplementary tag in order make it more clear the source of the log

    const worker_threads = "worker_threads";
    const { parentPort, workerData } = require(worker_threads);
    logger.debug(`Node worker started for: `, workerData);

    const resolver = require("opendsu").loadApi("resolver");
    const dsu = await $$.promisify(resolver.loadDSU)(workerData.keySSI);

    parentPort.postMessage("ready");

    const CHUNK_SIZE = 1024 * 1024;

    parentPort.on("message", async (task) => {
        logger.debug("Handling task", task);
        const { requestedPath } = task;
        let { range } = task;

        try {
            let start;
            let end;

            if (range.indexOf("=") !== -1) {
                range = range.split("=")[1];
            }
            if (range.indexOf("-") !== -1) {
                parts = range.split("-");
                start = parseInt(parts[0], 10);
                if (parts[1]) {
                    end = parseInt(parts[1], 10);
                } else {
                    end = start + CHUNK_SIZE;
                }
            } else {
                start = parseInt(range, 10);
                end = start + CHUNK_SIZE;
            }
            await $$.promisify(dsu.refresh)();

            const streamRange = { start, end };
            const { totalSize, stream } = await $$.promisify(dsu.createBigFileReadStreamWithRange)(requestedPath, streamRange);
            const actualEnd = Math.min(end, totalSize - 1);
            const contentLength = actualEnd - start + 1;
            const headers = {
                "Content-Range": `bytes ${start}-${actualEnd}/${totalSize}`,
                "Accept-Ranges": "bytes",
                "Content-Length": contentLength,
                "Content-Type": "video/mp4",
            };

            function streamToBuffer(stream) {
                const chunks = [];
                return new Promise((resolve, reject) => {
                    stream.on("data", (chunk) => chunks.push(Buffer.from(chunk)));
                    stream.on("error", (err) => reject(err));
                    stream.on("end", () => resolve(Buffer.concat(chunks)));
                });
            }
            const buffer = await streamToBuffer(stream);

            parentPort.postMessage({ result: { headers, buffer } });
        } catch (error) {
            parentPort.postMessage({ error });
        }
    });

    process.on("uncaughtException", (error) => {
        logger.error("[StreamHandler] uncaughtException inside node worker", error);

        setTimeout(() => process.exit(1), 100);
    });
};

}).call(this)}).call(this,require("buffer").Buffer)

},{"buffer":false,"opendsu":"opendsu"}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/apihub/config/config-migrator.js":[function(require,module,exports){
const logger = $$.getLogger("config-migrator", "apihub/config");

function removeConfigComponent(config) {
    if (config.componentsConfig && config.componentsConfig.config) {
        delete config.componentsConfig.config;
    }
}

function traverseObjectProvidedPrimitiveValues(item, onItemTraversal) {
    if (Array.isArray(item)) {
        item.forEach((element) => traversePrimitiveItemValues(element, onItemTraversal));
    } else if (typeof item === "object" && item != null) {
        Object.values(item)
            .filter((key) => item[key])
            .forEach((key) => {
                const value = item[key];
                if (isArray(value) || typeof item === "object") {
                    traverseObjectProvidedPrimitiveValues(value, onItemTraversal);
                } else {
                    onItemTraversal(item, key);
                }
            });
    }
}

function replaceInternalVolumePathsWithExternalVolume(config) {
    traverseObjectProvidedPrimitiveValues(config, (item, key) => {
        let value = item[key];
        if (key === "path" && typeof value === "string" && value.indexOf("internal-volume") !== -1) {
            item[key] = value.replace("internal-volume", "external-volume");
        }
    });
}

function removeBrickingPathConfig(config) {
    if (config.componentsConfig && config.componentsConfig.bricking && config.componentsConfig.bricking.domains) {
        const brickingDomains = config.componentsConfig.bricking.domains;
        Object.keys(brickingDomains).forEach((domain) => {
            delete brickingDomains[domain].path;
        });
    }
}

function removeAnchoringPathConfig(config) {
    if (config.componentsConfig && config.componentsConfig.anchoring && config.componentsConfig.anchoring.domainStrategies) {
        const anchoringDomains = config.componentsConfig.anchoring.domainStrategies;
        Object.keys(anchoringDomains).forEach((domain) => {
            const domainConfig = anchoringDomains[domain];
            if (domainConfig.type === "FS" && domainConfig.option) {
                delete domainConfig.option.path;
            }
        });
    }
}

function extractDomainConfigsAndRemoveThemFromConfig(config) {
    const domainConfigs = {};

    const { componentsConfig } = config;
    if (componentsConfig) {
        const { bricking, anchoring, bricksFabric } = componentsConfig;

        if (bricking) {
            // remove the domains property from bricking since the only used config is "path" which is constructed by convention
            delete bricking.domains;
        }

        if (anchoring && anchoring.domainStrategies) {
            const { domainStrategies } = anchoring;
            Object.keys(domainStrategies).forEach((domain) => {
                if (!domainConfigs[domain]) {
                    domainConfigs[domain] = {};
                }
                const domainConfig = domainConfigs[domain];
                domainConfig.anchoring = {
                    ...domainStrategies[domain],
                };

                if (domainConfig.anchoring.option) {
                    // remove the "path" config which is constructed by convention
                    delete domainConfig.anchoring.option.path;
                }
            });

            delete anchoring.domainStrategies;
        }

        if (bricksFabric && bricksFabric.domainStrategies) {
            const { domainStrategies } = bricksFabric;
            Object.keys(domainStrategies).forEach((domain) => {
                if (!domainConfigs[domain]) {
                    domainConfigs[domain] = {};
                }
                const domainConfig = domainConfigs[domain];
                domainConfig.bricksFabric = {
                    ...domainStrategies[domain],
                };
            });

            delete bricksFabric.domainStrategies;
        }
    }

    return domainConfigs;
}

function migrate(oldConfig, configFolderPath) {
    // create a clone in order to not influence config from outside of the migrator
    oldConfig = JSON.parse(JSON.stringify(oldConfig));

    const { storage, sslFolder, port, host, preventRateLimit, tokenBucket } = oldConfig;
    const { enableInstallationDetails, enableRequestLogger, enableLocalhostAuthorization } = oldConfig;
    const config = {
        storage,
        sslFolder,
        port,
        host,
        preventRateLimit,
        activeComponents: oldConfig.activeEndpoints,
        componentsConfig: oldConfig.endpointsConfig,
        tokenBucket,
        enableInstallationDetails,
        enableRequestLogger,
        enableJWTAuthorisation: oldConfig.enableAuthorisation,
        enableLocalhostAuthorization,
        skipJWTAuthorisation: oldConfig.skipAuthorisation,
    };

    removeConfigComponent(config);
    replaceInternalVolumePathsWithExternalVolume(config);
    removeBrickingPathConfig(config);
    removeAnchoringPathConfig(config);

    const domainConfigs = extractDomainConfigsAndRemoveThemFromConfig(config);

    const path = require("path");
    const fs = require("fs");
    const apihubJsonConfigPath = path.join(configFolderPath, "apihub.json");
    logger.debug(`Generating apihub.json config file at ${apihubJsonConfigPath}...`);

    if (!fs.existsSync(configFolderPath)) {
        fs.mkdirSync(configFolderPath, { recursive: true });
    }
    fs.writeFileSync(apihubJsonConfigPath, JSON.stringify(config, null, 2));

    const domainConfigsFolderPath = path.join(configFolderPath, "domains");
    if (!fs.existsSync(domainConfigsFolderPath)) {
        fs.mkdirSync(domainConfigsFolderPath, { recursive: true });
    }

    Object.keys(domainConfigs).forEach((domain) => {
        const domainConfig = domainConfigs[domain];
        const domainConfigPath = path.join(domainConfigsFolderPath, `${domain}.json`);
        logger.debug(`Generating config file for domain '${domain}' at ${domainConfigPath}...`);
        fs.writeFileSync(domainConfigPath, JSON.stringify(domainConfig, null, 2));
    });

    try {
        const serverJsonConfigPath = path.join(configFolderPath, "server.json");
        fs.unlinkSync(serverJsonConfigPath);
    } catch (error) {
        //We ignore this error because is not relevant.
        //Until now most of the implementations for sure switched from server.json to apihub.json
    }
}

module.exports = {
    migrate,
};

},{"fs":false,"path":false}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/apihub/config/default.js":[function(require,module,exports){

const defaultConfig = {
    "storage":  require("swarmutils").path.join(process.env.PSK_ROOT_INSTALATION_FOLDER, "tmp"),
    "externalStorage": "./external-volume",
    "sslFolder":  require("swarmutils").path.join(process.env.PSK_ROOT_INSTALATION_FOLDER, "conf", "ssl"),
    "port": 8080,
    "host": "0.0.0.0",
    "zeromqForwardAddress": "tcp://127.0.0.1:5001",
    "preventRateLimit": false,
    // staticServer needs to load last
    "activeComponents": ["config", "mq", "enclave","secrets", "notifications", "filesManager", "bdns", "bricking", "anchoring", "bricksFabric", "contracts", "dsu-wizard", 'debugLogger', "mainDSU", "cloudWallet", "stream", "staticServer"],
    "componentsConfig": {
        "mq":{
            "module": "./components/mqHub",
            "function": "MQHub",
            "connectionTimeout": 10000
        },
        "enclave":{
            "module": "./components/enclave",
            "function": "LokiEnclaveFacade",
            "storageFolder": './external-volume/config/enclave'
        },
        "secrets":{
            "module": "./components/secrets"
        },
        "notifications": {
            "module": "./components/keySsiNotifications",
            "workingDirPath": "./external-volume/notifications"
        },
        "dsu-wizard": {
            "module": "dsu-wizard",
            "function": "initWizard",
            "storage": "./external-volume/dsu-wizard/transactions",
            "workers": 5,
            "bundle": "./../opendsu-sdk/psknode/bundles/openDSU.js"
        },
        "bdns": {
            "module": "./components/bdns",
        },
        "bricking": {
            "module": "./components/bricking",
        },
        "filesManager": {
            "module": "./components/fileManager"
        },
        "bricksFabric": {
            "module": "./components/bricksFabric",
            "path": "./",
            "bricksFabricStrategy": "BrickStorage",
            "bricksFabricStrategyOption": {
                "timeout": 15000,
                "transactionsPerBlock": 5
            }
        },
        "anchoring": {
            "module": "./components/anchoring",
            "anchoringStrategy": "FS"
        },
        "debugLogger": {
            "module": './components/debugLogger',
            "workingDirPath": './external-volume/debug-logger',
            "storageDirPath": './external-volume/debug-logger/storage',
        },
        "staticServer": {
            "module": "./components/staticServer"
        },
        "contracts": {
            "module": "./components/contracts",
            "domainsPath": "/external-volume/domains"
        },
        "admin": {
            "module": "./components/admin",
            "function": "AdminComponentHandler",
            "storageFolder": './external-volume/config/admin'
        },
        "mainDSU": {
            "module": "./components/mainDSU"
        },
        "cloudWallet": {
            "module": "./components/cloudWallet",
            "dsuBootPath": "./psknode/bundles/nodeBoot.js"
        },
        "stream": {
            "module": "./components/stream"
        },
        "requestForwarder":{
            "module": "./components/requestForwarder"
        },
        "requestLogger":{
            "comment": "this is a standard middleware but its config is here to make it as uniform as possible",
            "statusLogInterval": 3000,
            "longRequests":["/mq/"]
        }
    },
    "tokenBucket": {
        "cost": {
            "low": 10,
            "medium": 100,
            "high": 500
        },
        "error": {
            "limitExceeded": "error_limit_exceeded",
            "badArgument": "error_bad_argument"
        },
        "startTokens": 6000,
        "tokenValuePerTime": 10,
        "unitOfTime": 100
    },
    "enableInstallationDetails": true,
    "enableRequestLogger": true,
    "enableJWTAuthorisation": false,
    "enableLocalhostAuthorization": false,
    "enableErrorCloaking": false,
    "skipJWTAuthorisation": [
        "/leaflet-wallet",
        "/config",
        "/anchor",
        "/bricking",
        "/bricksFabric",
        "/create-channel",
        "/send-message",
        "/receive-message",
        "/files",
        "/notifications",
        "/mq",
        "/enclave",
        "/secrets",
        "/logs"
    ]
};

module.exports = Object.freeze(defaultConfig);

},{"swarmutils":"swarmutils"}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/apihub/config/index.js":[function(require,module,exports){
let apihubConfig;
let tokenIssuers;
let domainConfigs = {};
const logger = $$.getLogger("index", "apihub/config");

function checkIfFileExists(filePath) {
    try {
        const fs = require("fs");
        fs.accessSync(filePath);
        return true;
    } catch (error) {
        logger.error(`File ${filePath} doesn't exists or no access is possible!`);
    }
    return false;
}

function loadAllDomainConfigs(configFolderPath) {
    const path = require("swarmutils").path;
    const fs = require("fs");
    const domainsFolderPath = path.join(configFolderPath, 'domains');
    if(checkIfFileExists(domainsFolderPath)) {
        try {
            fs.readdirSync(domainsFolderPath)
                .filter((domainFile) => domainFile.endsWith(".json"))
                .forEach((domainFile) => {
                    const domain = domainFile.substring(0, domainFile.lastIndexOf("."));
                    logger.debug(`Loading config for domain '${domain}'`);

                    try {
                        const domainConfig = fs.readFileSync(path.join(domainsFolderPath, domainFile));
                        domainConfigs[domain] = JSON.parse(domainConfig);
                    } catch (error) {
                        logger.error(`Could not read config for domain '${domain}'`, error);
                    }
                });
        } catch (error) {
            logger.error(`Could not read domain configs at ${domainsFolderPath}`, error);
        }
    } else {
        logger.error(`Domain configs folder not found at ${domainsFolderPath}`);
    }
}

function ensureConfigsAreLoaded() {
    const path = require("swarmutils").path;

    if(!apihubConfig) {
        let apihubJson;
        if (typeof process.env.PSK_CONFIG_LOCATION === "undefined") {
            logger.debug("PSK_CONFIG_LOCATION env variable not set. Not able to load any external config. Using default configuration.")
            apihubJson = {};
        } else {
            const fs = require("fs");
            const configFolderPath = path.resolve(process.env.PSK_CONFIG_LOCATION);
            logger.debug("Trying to read the apihub.json file from the location pointed by PSK_CONFIG_LOCATION env variable.");
            const apihubConfigPath = path.join(configFolderPath, 'apihub.json');

            if(!checkIfFileExists(apihubConfigPath)) {
                logger.debug("Trying to read the server.json file from the location pointed by PSK_CONFIG_LOCATION env variable.");
                const serverJsonConfigPath = path.join(configFolderPath, 'server.json');

                let serverJson;
                if(checkIfFileExists(serverJsonConfigPath)) {
                    serverJson = JSON.parse(fs.readFileSync(serverJsonConfigPath));
                } else {
                    serverJson = {};
                }

                // migrate server.json to apihub.json
                const configMigrator = require("./config-migrator");
                configMigrator.migrate(serverJson, configFolderPath);
            }

            apihubJson = JSON.parse(fs.readFileSync(apihubConfigPath));
            loadAllDomainConfigs(configFolderPath);
        }

        apihubJson = apihubJson || {};
        apihubConfig = new ApihubConfig(apihubJson);
    }
}

function getConfig(...keys) {
    ensureConfigsAreLoaded();

    if (keys.length === 0) {
        return apihubConfig;
    }

    return getSource(keys, apihubConfig);
}

function ApihubConfig(conf) {
    const defaultConf = require('./default');

    function createConfig(config, defaultConfig) {
        if (typeof config === "undefined") {
            return defaultConfig;
        }
    
        //ensure that the config object will contain all the necessary keys for server configuration
        for (let mandatoryKey in defaultConfig) {
            if (typeof config[mandatoryKey] === "undefined") {
                config[mandatoryKey] = defaultConfig[mandatoryKey];
            }
        }
        return __createConfigRecursively(conf, defaultConf);
    
        function __createConfigRecursively(config, defaultConfig) {
            for (let prop in defaultConfig) {
                if (typeof config[prop] === "object" && !Array.isArray(config[prop])) {
                    __createConfigRecursively(config[prop], defaultConfig[prop]);
                } else {
                    if (typeof config[prop] === "undefined") {
                        config[prop] = defaultConfig[prop];
                        __createConfigRecursively(config[prop], defaultConfig[prop]);
                    }
                }
            }
            return config;
        }
    }

    conf = createConfig(conf, defaultConf);
    conf.defaultComponents = defaultConf.activeComponents;
    if(conf.isDefaultComponent){
        logger.debug("\n\nBe aware that there is a method on the config called isDefaultComponent. You need to check and change your config name.\n\n");
    }
    conf.isDefaultComponent = function(componentName) {
        return defaultConf.activeComponents.indexOf(componentName) !== -1 || defaultConf.componentsConfig[componentName];
    }
    return conf;
}

function getSource(arrayKeys, source) {
    if (!arrayKeys.length || source === undefined) {
        return source;
    }

    return getSource(arrayKeys, source[arrayKeys.shift()]);
}

function getTokenIssuers(callback) {
    const fs = require("fs");
    const path = require("swarmutils").path;

    if (tokenIssuers) {
        return callback(null, tokenIssuers);
    }

    if (typeof process.env.PSK_CONFIG_LOCATION === "undefined") {
        tokenIssuers = [];
        return callback(null, tokenIssuers);
    }

    const filePath = path.join(path.resolve(process.env.PSK_CONFIG_LOCATION), "issuers-public-identities");
    logger.debug(
        `Trying to read the token-issuers.txt file from the location pointed by PSK_CONFIG_LOCATION env variable: ${filePath}`
    );

    fs.access(filePath, fs.F_OK, (err) => {
        if (err) {
            logger.debug(`${filePath} doesn't exist so skipping it`);
            tokenIssuers = [];
            callback(null, tokenIssuers);
        }

        fs.readFile(filePath, "utf8", function (err, data) {
            if (err) {
                logger.error(`Cannot load ${filePath}`, err);
                return;
            }

            const openDSU = require("opendsu");
            const crypto = openDSU.loadApi("crypto");

            tokenIssuers = data.split(/\s+/g).filter((issuer) => issuer).map(issuer => crypto.getReadableSSI(issuer));

            callback(null, tokenIssuers);
        });
    });
}

function getDomainConfigFilePath(domain) {
    const path = require("swarmutils").path;
    const domainConfigPath = path.join(path.resolve(process.env.PSK_CONFIG_LOCATION), `domains/${domain}.json`);
    return domainConfigPath;
}

function getConfiguredDomains() {
    ensureConfigsAreLoaded();
    return Object.keys(domainConfigs);
}

async function getSafeDomainConfig(domain, ...configKeys){
    let domainConfig = getDomainConfig(domain);
    if(!domainConfig){
        try{
            let adminService = require("./../components/admin").getAdminService();
            const getDomainInfo = $$.promisify(adminService.getDomainInfo);
            let domainInfo = await getDomainInfo(domain);
            if(domainInfo && domainInfo.active && domainInfo.cloneFromDomain){
                logger.debug(`Config for domain '${domain}' was loaded from admin service.`);
                return getDomainConfig(domainInfo.cloneFromDomain);
            }
        }catch(err){
            //we ignore any errors in this try-catch block because admin component may be disabled
        }
    }
    return getDomainConfig(domain, ...configKeys);
}

function getDomainConfig(domain, ...configKeys) {
    ensureConfigsAreLoaded();
    if(!domain) {
        return {};
    }

    const getConfigResult = (config) => {
        if(!configKeys) {
            configKeys = [];
        }
        let configResult = config ? getSource(configKeys, config) : null;
        return configResult;
    }

    const loadedDomainConfig = domainConfigs[domain];
    if(typeof loadedDomainConfig !== 'undefined') {
        return getConfigResult(loadedDomainConfig);
    }

    if (typeof process.env.PSK_CONFIG_LOCATION === "undefined") {
        logger.debug('PSK_CONFIG_LOCATION env variable not set. Not able to load domain config. Using default configuration.')
        return getConfigResult({});
    }

    const domainConfigPath = getDomainConfigFilePath(domain);
    logger.debug(`Trying to read the config for domain '${domain}' at location: ${domainConfigPath}`);

    try {
        const fsName = "fs";
        const domainConfigContent = require(fsName).readFileSync(domainConfigPath);
        const domainConfig = JSON.parse(domainConfigContent);
        domainConfigs[domain] = domainConfig;
        return getConfigResult(domainConfig);
    } catch (error) {
        logger.error(`Config for domain '${domain}' cannot be loaded from location: ${domainConfigPath}.`);
        domainConfigs[domain] = null;
        return domainConfigs[domain];
    }
}

function updateDomainConfig(domain, config, callback) {
    ensureConfigsAreLoaded();
    const domainConfigPath = getDomainConfigFilePath(domain);
    const fsName = "fs";
    require(fsName).writeFile(domainConfigPath, JSON.stringify(config), (error) => {
        if(error) {
            return callback(error);
        }

        // update the domain config cache
        domainConfigs[domain] = config;
        callback();
    })
}

module.exports = {getConfig, getTokenIssuers, getConfiguredDomains, getDomainConfig, getSafeDomainConfig, updateDomainConfig};

},{"./../components/admin":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/apihub/components/admin/index.js","./config-migrator":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/apihub/config/config-migrator.js","./default":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/apihub/config/default.js","fs":false,"opendsu":"opendsu","swarmutils":"swarmutils"}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/apihub/libs/Notifications.js":[function(require,module,exports){
const stateStorageFileName = 'queues.json';

function NotificationsManager(workingFolderPath, storageFolderPath) {
	const queues = {};
	const subscribers = {};
	const swarmUtils = require('swarmutils');
	const logger = $$.getLogger("NotificationsManager", "apihub/libs");

	this.createQueue = function (queueName, callback) {
		if (typeof queues[queueName] !== "undefined") {
			return callback({ message: 'Queue already exists.', statusCode: 409 });
		}

		createQueue(queueName, (err) => {
			if (err) {
				return callback(err);
			}

			try {
				if (typeof storageFolderPath !== 'undefined') {
					require('fs').mkdirSync(getQueueStoragePath(queueName), { recursive: true });
				}
			} catch (err) {
				return callback(err);
			}

			return callback();
		});
	}

	function createQueue(name, callback) {
		queues[name] = new swarmUtils.Queue();
		if (callback) {
			saveState(callback);
		}
	}

	function getQueueStoragePath(queueName) {
		let path = swarmUtils.path;
		const opendsu = require("opendsu");
		const crypto = opendsu.loadAPI('crypto');
		if (queueName.indexOf(':') !== -1) {
			queueName = crypto.encodeBase58(queueName);
		}
		return path.join(storageFolderPath, queueName);
	}

	function deliverMessage(subs, message, callback) {
		let counter = 0;
		while (subs.length > 0) {
			let sub = subs.pop();
			try {
				sub(undefined, message);
				counter++;
			} catch (err) {
				//if something happens durring message delivery we will catch the error here
			}
		}
		callback(undefined, counter);
	}

	function storeMessage(queueName, message, callback) {
		let path = swarmUtils.path;
		let fileName = path.join(getQueueStoragePath(queueName), new Date().getTime());
		require('fs').writeFile(fileName, message, (err) => {
			if (err) {
				return callback(err);
			}
			return callback(undefined, fileName);
		});
	}

	function buildNotification(message, timestamp, filename, ttl) {
		return {
			filename,
			message,
			timestamp: timestamp ? timestamp : new Date().getTime(),
			ttl
		};
	}

	function addMessageToQueue(queueName, message, messageTTL, callback) {
		if (typeof messageTTL === 'function') {
			callback = messageTTL;
			messageTTL = undefined;
		}
		const notificationObject = buildNotification(message, undefined, undefined, messageTTL);

		if(typeof queues[queueName] === "undefined"){
			return callback(new Error(`There is no queue called ${queueName}`));
		}

		queues[queueName].push(notificationObject);

		if (typeof storageFolderPath !== 'undefined') {
			return storeMessage(queueName, message, (err, fileName) => {
				if (fileName) {
					notificationObject.filename = fileName;
				}
				callback(err);
			});
		}
        callback();
	}

	this.sendMessage = function (queueName, message, messageTTL, callback) {
		if (typeof messageTTL === 'function') {
			callback = messageTTL;
			messageTTL = undefined;
		}

		let subs = subscribers[queueName];
		if (typeof subs !== 'undefined' && subs.length > 0) {
			return deliverMessage(subs, message, (err, counter)=>{
				if(err || counter === 0){
					return addMessageToQueue(queueName, message, messageTTL, callback);
				}
				return callback(err, counter);
			});
		}

		return addMessageToQueue(queueName, message, messageTTL, callback);
	}

	this.readMessage = function (queueName, callback) {
		if (typeof subscribers[queueName] === 'undefined') {
			subscribers[queueName] = [];
		}

		const subs = subscribers[queueName];
		subs.push(callback);
		
		if(typeof queues[queueName] === "undefined"){
			return callback("Not able to find the queue.");
		}
		
		const notificationObject = queues[queueName].pop();

		if (typeof notificationObject !== 'undefined' && notificationObject !== null) {
			deliverMessage(subs, notificationObject.message, (err, counter) => {
				if (counter > 0) {
					//message delivered... let's remove from storage if it was persisted
					if (typeof notificationObject.filename !== 'undefined') {
						try {
							require('fs').unlinkSync(notificationObject.filename);
						} catch (err) {
							logger.error(err);
						}
					}
				}
			});
		}
	}

	function loadState(callback) {
		let state;

		try {
			const path = require("path");
			const fs = require("fs");
			const fileLocation = path.join(workingFolderPath, stateStorageFileName);
			if(!fs.existsSync(fileLocation)){
				throw `${fileLocation} not found. No previous state available.`;
			}
			state = require(fileLocation);
		} catch (err) {
			//if the storage file does not exist or invalid json file we will catch an error here
			return callback();
		}

		if (typeof state !== 'undefined') {
			for (let i = 0; i < state.queues.length; i++) {
				let queueName = state.queues[i];
				createQueue(queueName);
			}
		}

		callback(undefined, state);
	}

	function saveState(callback) {
		let state = {
			queues: Object.keys(queues)
		}

		let fs = require('fs');
		let path = swarmUtils.path;

		fs.writeFile(path.join(workingFolderPath, stateStorageFileName), JSON.stringify(state, null, 4), callback);
	}

	/**
	 * Remove expired queued notifications
	 * Do async cleanup in batches in order to
	 * prevent hogging the event loop
	 */
	function startMQCleanup() {
		const batchCleanup = (startIndex, subBatchSize, msgBatchSize, done) => {
			const keys = Object.keys(queues);
			const now = new Date().getTime();
			if (!keys.length) {
				return done(0);
			}
			let i = startIndex;
			let max = i + subBatchSize;
			for (i; i < max; i++) {
				let key = keys[i];
				if (!key) {
					break;
				}
				const queue = queues[key];
				if (!queue.length) {
					continue;
				}

				let counter = 0;
				let totalCount = 0;
				for (const msg of queue) {
					if (++counter > msgBatchSize) {
						break;
					}
					if (!msg.ttl) {
						continue;
					}
					const elapsed = now - msg.timestamp;
					// Remove expired message
					if (elapsed >= msg.ttl) {
						queue.remove(msg);
						totalCount++;
					}
				}
			}

			let resumeIndex = i;
			if (i >= keys.length - 1) {
				resumeIndex = 0;
			}
			done(resumeIndex);
		}


		const runCleanup = (startIndex = 0) => {
			setTimeout(() => {
				batchCleanup(startIndex, 10, 100, (resumeIndex) => {
					runCleanup(resumeIndex);
				})
			}, 250);
		}

		runCleanup();
	}

	this.initialize = function (callback) {
		let fs = require('fs');
		let path = swarmUtils.path;

		//if it's the first time we need to ensure that the working folder exists
		if (!fs.existsSync(workingFolderPath)) {
			fs.mkdirSync(workingFolderPath, { recursive: true });
		}

		startMQCleanup();

		loadState((err, state) => {
			if (typeof storageFolderPath === 'undefined') {
				return callback();
			}

			//if it's the first time we need to ensure that the storage folder exists
			if (!fs.existsSync(storageFolderPath)) {
				fs.mkdirSync(storageFolderPath, { recursive: true });
			}

			//if is our first boot using a specific folder there is no state to be loaded
			if (typeof state === 'undefined') {
				return callback();
			}

			for (let i = 0; i < state.queues.length; i++) {
				let queueName = state.queues[i];
				let queueStoragePath = getQueueStoragePath(queueName);
				fs.readdir(queueStoragePath, (err, messages) => {
					if (err) {
						return callback(err);
					}

					messages.sort(function (a, b) {
						return Number(a) - Number(b);
					});

					for (let i = 0; i < messages.length; i++) {
						let messageTimestamp = messages[i];
						let messageStoragePath = path.join(queueStoragePath, messageTimestamp);
						queues[queueName].push(buildNotification(fs.readFileSync(messageStoragePath), messageTimestamp, messageStoragePath));
					}
				});
			}
			callback();
		});
	}
}

module.exports = {
	getManagerInstance: function (workingFolderPath, storageFolderPath, callback) {
		if (typeof storageFolderPath === 'function') {
			callback = storageFolderPath;
			storageFolderPath = undefined;
		}

		let manager = new NotificationsManager(workingFolderPath, storageFolderPath);
		manager.initialize((err) => {
			callback(err, manager);
		});
	}
};

},{"fs":false,"opendsu":"opendsu","path":false,"swarmutils":"swarmutils"}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/apihub/libs/TokenBucket.js":[function(require,module,exports){
/**
 * An implementation of the Token bucket algorithm
 * @param startTokens - maximum number of tokens possible to obtain and the default starting value
 * @param tokenValuePerTime - number of tokens given back for each "unitOfTime"
 * @param unitOfTime - for each "unitOfTime" (in milliseconds) passed "tokenValuePerTime" amount of tokens will be given back
 * @constructor
 */
const config = require('./../config');

function TokenBucket(startTokens = config.getConfig('tokenBucket', 'startTokens'),
    tokenValuePerTime = config.getConfig('tokenBucket', 'tokenValuePerTime'),
    unitOfTime = config.getConfig('tokenBucket', 'unitOfTime')) {

    if (typeof startTokens !== 'number' || typeof tokenValuePerTime !== 'number' || typeof unitOfTime !== 'number') {
        throw new Error('All parameters must be of type number');
    }

    if (isNaN(startTokens) || isNaN(tokenValuePerTime) || isNaN(unitOfTime)) {
        throw new Error('All parameters must not be NaN');
    }

    if (startTokens <= 0 || tokenValuePerTime <= 0 || unitOfTime <= 0) {
        throw new Error('All parameters must be bigger than 0');
    }

    TokenBucket.prototype.COST_LOW = config.getConfig('tokenBucket', 'cost', 'low');  // equivalent to 10op/s with default values
    TokenBucket.prototype.COST_MEDIUM = config.getConfig('tokenBucket', 'cost', 'medium'); // equivalent to 1op/s with default values
    TokenBucket.prototype.COST_HIGH = config.getConfig('tokenBucket', 'cost', 'high'); // equivalent to 12op/minute with default values

    TokenBucket.ERROR_LIMIT_EXCEEDED = config.getConfig('tokenBucket', 'error', 'limitExceeded');
    TokenBucket.ERROR_BAD_ARGUMENT = config.getConfig('tokenBucket', 'error', 'badArgument');

    const limits = {};

    function takeToken(userKey, cost, callback = () => { }) {
        if (typeof cost !== 'number' || isNaN(cost) || cost <= 0 || cost === Infinity) {
            callback(TokenBucket.ERROR_BAD_ARGUMENT);
            return;
        }

        const userBucket = limits[userKey];

        if (userBucket) {
            userBucket.tokens += calculateReturnTokens(userBucket.timestamp);
            userBucket.tokens -= cost;

            userBucket.timestamp = Date.now();

            if (userBucket.tokens < 0) {
                userBucket.tokens = 0;
                callback(TokenBucket.ERROR_LIMIT_EXCEEDED, 0);
                return;
            }

            return callback(undefined, userBucket.tokens);
        } else {
            limits[userKey] = new Limit(startTokens, Date.now());
            takeToken(userKey, cost, callback);
        }
    }

    function getLimitByCost(cost) {
        if (startTokens === 0 || cost === 0) {
            return 0;
        }

        return Math.floor(startTokens / cost);
    }

    function getRemainingTokenByCost(tokens, cost) {
        if (tokens === 0 || cost === 0) {
            return 0;
        }

        return Math.floor(tokens / cost);
    }

    function Limit(maximumTokens, timestamp) {
        this.tokens = maximumTokens;
        this.timestamp = timestamp;

        const self = this;

        return {
            set tokens(numberOfTokens) {
                if (numberOfTokens < 0) {
                    numberOfTokens = -1;
                }

                if (numberOfTokens > maximumTokens) {
                    numberOfTokens = maximumTokens;
                }

                self.tokens = numberOfTokens;
            },
            get tokens() {
                return self.tokens;
            },
            timestamp
        };
    }


    function calculateReturnTokens(timestamp) {
        const currentTime = Date.now();

        const elapsedTime = Math.floor((currentTime - timestamp) / unitOfTime);

        return elapsedTime * tokenValuePerTime;
    }

    this.takeToken = takeToken;
    this.getLimitByCost = getLimitByCost;
    this.getRemainingTokenByCost = getRemainingTokenByCost;
}

module.exports = TokenBucket;

},{"./../config":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/apihub/config/index.js"}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/apihub/libs/http-wrapper/src/classes/Client.js":[function(require,module,exports){
const http = require('http');
const url = require('url');
const stream = require('stream');

/**
 * Wraps a request and augments it with a "do" method to modify it in a "fluent builder" style
 * @param {string} url
 * @param {*} body
 * @constructor
 */
function Request(url, body) {
    this.request = {
        options: url,
        body
    };

    this.do = function (modifier) {
        modifier(this.request);
        return this;
    };

    this.getHttpRequest = function () {
        return this.request;
    };
}


/**
 * Modifies request.options to contain the url parsed instead of as string
 * @param {Object} request - Object that contains options and body
 */
function urlToOptions(request) {
    const parsedUrl = url.parse(request.options);

    // TODO: movie headers declaration from here
    request.options = {
        host: parsedUrl.hostname,
        port: parsedUrl.port,
        path: parsedUrl.pathname,
        headers: {}
    };
}


/**
 * Transforms the request.body in a type that can be sent through network if it is needed
 * @param {Object} request - Object that contains options and body
 */
function serializeBody(request) {
    if (!request.body) {
        return;
    }

    const handler = {
        get: function (target, name) {
            return name in target ? target[name] : (data) => data;
        }
    };

    const bodySerializationMapping = new Proxy({
        'Object': (data) => JSON.stringify(data),
    }, handler);

    request.body = bodySerializationMapping[request.body.constructor.name](request.body);
}

/**
 *
 * @param {Object} request - Object that contains options and body
 */
function bodyContentLength(request) {
    if (!request.body) {
        return;
    }

    if (request.body.constructor.name in [ 'String', '$$.Buffer', 'ArrayBuffer' ]) {
        request.options.headers['Content-Length'] = $$.Buffer.byteLength(request.body);
    }
}


function Client() {
    /**
     *
     * @param {Request} customRequest
     * @param modifiers - array of functions that modify the request
     * @returns {Object} - with url and body properties
     */
    function request(customRequest, modifiers) {
        for (let i = 0; i < modifiers.length; ++i) {
            customRequest.do(modifiers[i]);
        }

        return customRequest.getHttpRequest();
    }

    function getReq(url, config, callback) {
        const modifiers = [
            urlToOptions,
            (request) => {request.options.headers = config.headers || {};}
        ];

        const packedRequest = request(new Request(url, config.body), modifiers);
        const httpRequest = http.request(packedRequest.options, callback);
        httpRequest.end();

        return httpRequest;
    }

    function postReq(url, config, callback) {
        const modifiers = [
            urlToOptions,
            (request) => {request.options.method = 'POST'; },
            (request) => {request.options.headers = config.headers || {}; },
            serializeBody,
            bodyContentLength
        ];

        const packedRequest = request(new Request(url, config.body), modifiers);
        const httpRequest = http.request(packedRequest.options, callback);

        if (config.body instanceof stream.Readable) {
            config.body.pipe(httpRequest);
        }
        else {
            httpRequest.end(packedRequest.body, config.encoding || 'utf8');
        }
        return httpRequest;
    }

    function deleteReq(url, config, callback) {
        const modifiers = [
            urlToOptions,
            (request) => {request.options.method = 'DELETE';},
            (request) => {request.options.headers = config.headers || {};},
        ];

        const packedRequest = request(new Request(url, config.body), modifiers);
        const httpRequest = http.request(packedRequest.options, callback);
        httpRequest.end();

        return httpRequest;
    }

    this.get = getReq;
    this.post = postReq;
    this.delete = deleteReq;
}

/**
 * Swap third and second parameter if only two are provided and converts arguments to array
 * @param {Object} params
 * @returns {Array} - arguments as array
 */
function parametersPreProcessing(params) {
    const res = [];

    if (typeof params[0] !== 'string') {
        throw new Error('First parameter must be a string (url)');
    }

    const parsedUrl = url.parse(params[0]);

    if (!parsedUrl.hostname) {
        throw new Error('First argument (url) is not valid');
    }

    if (params.length >= 3) {
        if (typeof params[1] !== 'object' || !params[1]) {
            throw new Error('When 3 parameters are provided the second parameter must be a not null object');
        }

        if (typeof params[2] !== 'function') {
            throw new Error('When 3 parameters are provided the third parameter must be a function');
        }
    }

    if (params.length === 2) {
        if (typeof params[1] !== 'function') {
            throw new Error('When 2 parameters are provided the second one must be a function');
        }

        params[2] = params[1];
        params[1] = {};
    }

    const properties = Object.keys(params);
    for(let i = 0, len = properties.length; i < len; ++i) {
        res.push(params[properties[i]]);
    }

    return res;
}

const logger = $$.getLogger("Client", "apihub/http-wrapper");

const handler = {
    get(target, propName) {
        if (!target[propName]) {
            logger.error(propName, "Not implemented!");
        } else {
            return function () {
                const args = parametersPreProcessing(arguments);
                return target[propName].apply(target, args);
            };
        }
    }
};

module.exports = function () {
    return new Proxy(new Client(), handler);
};
},{"http":false,"stream":false,"url":false}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/apihub/libs/http-wrapper/src/classes/MiddlewareRegistry.js":[function(require,module,exports){
const querystring = require('querystring');
const logger = $$.getLogger("http-wrapper", "apihub/libs");

function matchUrl(pattern, url) {
	const result = {
		match: true,
		params: {},
		query: {}
	};

	const queryParametersStartIndex = url.indexOf('?');
	if(queryParametersStartIndex !== -1) {
		const urlQueryString = url.substr(queryParametersStartIndex + 1); // + 1 to ignore the '?'
		result.query = querystring.parse(urlQueryString);
		url = url.substr(0, queryParametersStartIndex);
	}

    const patternTokens = pattern.split('/');
    const urlTokens = url.split('/');

    if(urlTokens[urlTokens.length - 1] === '') {
        urlTokens.pop();
    }

    if (patternTokens.length !== urlTokens.length) {
        result.match = false;
    }

    if(patternTokens[patternTokens.length - 1] === '*') {
        result.match = true;
        patternTokens.pop();
    }

    for (let i = 0; i < patternTokens.length && result.match; ++i) {
        if (patternTokens[i].startsWith(':')) {
            result.params[patternTokens[i].substring(1)] = urlTokens[i];
        } else if (patternTokens[i] !== urlTokens[i]) {
            result.match = false;
        }
    }

    return result;
}

function isTruthy(value) {
    return !!value;

}

function methodMatch(pattern, method) {
    if (!pattern || !method) {
        return true;
    }

    return pattern === method;
}

function MiddlewareRegistry() {
    const registeredMiddlewareFunctions = [];

    function use(method, url, fn) {
        method = method ? method.toLowerCase() : undefined;
        registeredMiddlewareFunctions.push({method, url, fn});
    }

    this.use = function (...params) {
	    let args = [ undefined, undefined, undefined ];

	    switch (params.length) {
            case 0:
				throw Error('Use method needs at least one argument.');
				
            case 1:
                if (typeof params[0] !== 'function') {
                    throw Error('If only one argument is provided it must be a function');
                }

                args[2] = params[0];

                break;
            case 2:
                if (typeof params[0] !== 'string' || typeof params[1] !== 'function') {
                    throw Error('If two arguments are provided the first one must be a string (url) and the second a function');
                }

                args[1]=params[0];
                args[2]=params[1];

                break;
            default:
                if (typeof params[0] !== 'string' || typeof params[1] !== 'string' || typeof params[2] !== 'function') {
                    throw Error('If three or more arguments are provided the first one must be a string (HTTP verb), the second a string (url) and the third a function');
                }

                if (!([ 'get', 'post', 'put', 'delete', 'patch', 'head', 'connect', 'options', 'trace' ].includes(params[0].toLowerCase()))) {
                    throw new Error('If three or more arguments are provided the first one must be a HTTP verb but none could be matched');
                }

                args = params;

                break;
        }

        use.apply(this, args);
    };


    /**
     * Starts execution from the first registered middleware function
     * @param {Object} req
     * @param {Object} res
     */
    this.go = function go(req, res) {
        try {
            execute(0, req.method.toLowerCase(), req.url, req, res);
        } catch (e) {
            logger.error(e);
            res.statusCode = 500;
            res.end("Internal server error");
        }
    };

    /**
     * Executes a middleware if it passes the method and url validation and calls the next one when necessary
     * @param index
     * @param method
     * @param url
     * @param params
     */
    function execute(index, method, url, ...params) {
        if (!registeredMiddlewareFunctions[index]) {
            if(index===0){
                logger.error("No handlers registered yet!");
            }
            return;
        }

	    const registeredMethod = registeredMiddlewareFunctions[index].method;
	    const registeredUrl = registeredMiddlewareFunctions[index].url;
	    const fn = registeredMiddlewareFunctions[index].fn;

	    if (!methodMatch(registeredMethod, method)) {
            execute(++index, method, url, ...params);
            return;
        }

        if (isTruthy(registeredUrl)) {
            const urlMatch = matchUrl(registeredUrl, url);

            if (!urlMatch.match) {
                execute(++index, method, url, ...params);
                return;
            }

            if (params[0]) {
                params[0].params = urlMatch.params;
                params[0].query  = urlMatch.query;
            }
        }

        let counter = 0;

        fn(...params, (err) => {
            counter++;
            if (counter > 1) {
                logger.warn('You called next multiple times, only the first one will be executed');
                return;
            }

            if (err) {
                logger.error(err);
                return;
            }

            execute(++index, method, url, ...params);
        });
    }
}

module.exports = MiddlewareRegistry;

},{"querystring":false}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/apihub/libs/http-wrapper/src/classes/Router.js":[function(require,module,exports){
function Router(server) {
    this.use = function use(url, callback) {
        callback(serverWrapper(url, server));
    };
}

function serverWrapper(baseUrl, server) {
    if (baseUrl.endsWith('/')) {
        baseUrl = baseUrl.substring(0, baseUrl.length - 1);
    }

    return {
        use(url, reqResolver) {
            server.use(baseUrl + url, reqResolver);
        },
        get(url, reqResolver) {
            server.get(baseUrl + url, reqResolver);
        },
        post(url, reqResolver) {
            server.post(baseUrl + url, reqResolver);
        },
        put(url, reqResolver) {
            server.put(baseUrl + url, reqResolver);
        },
        delete(url, reqResolver) {
            server.delete(baseUrl + url, reqResolver);
        },
        options(url, reqResolver) {
            server.options(baseUrl + url, reqResolver);
        }
    };
}

module.exports = Router;

},{}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/apihub/libs/http-wrapper/src/classes/Server.js":[function(require,module,exports){
const MiddlewareRegistry = require('./MiddlewareRegistry');
const http = require('http');
const https = require('https');


function Server(sslOptions) {
    const middleware = new MiddlewareRegistry();
    const server = _initServer(sslOptions);


    this.use = function use(url, callback) {
        //TODO: find a better way
        if (arguments.length >= 2) {
            middleware.use(url, callback);
        } else if (arguments.length === 1) {
            callback = url;
            middleware.use(callback);
        }

    };


    this.get = function getReq(reqUrl, reqResolver) {
        middleware.use("GET", reqUrl, reqResolver);
    };

    this.post = function postReq(reqUrl, reqResolver) {
        middleware.use("POST", reqUrl, reqResolver);
    };

    this.put = function putReq(reqUrl, reqResolver) {
        middleware.use("PUT", reqUrl, reqResolver);
    };

    this.delete = function deleteReq(reqUrl, reqResolver) {
        middleware.use("DELETE", reqUrl, reqResolver);
    };

    this.options = function optionsReq(reqUrl, reqResolver) {
        middleware.use("OPTIONS", reqUrl, reqResolver);
    };
    this.makeLocalRequest = function (method,path, body,headers, callback)
    {
        if (typeof headers === "function")
        {
            callback = headers;
            headers = undefined;
        }

        if (typeof body === "function")
        {
            callback = body;
            headers = undefined;
            body = undefined;
        }

        const protocol =  require(this.protocol);

        let hostName = "127.0.0.1";
        if(process.env.BDNS_ROOT_HOSTS){
            let hostUrl = new URL(process.env.BDNS_ROOT_HOSTS);
            hostName = hostUrl.hostname;
        }

        const options = {
            hostname : '127.0.0.1',
            port : server.address().port,
            path,
            method,
            headers
        };
        const req = protocol.request(options, response => {

            if (response.statusCode < 200 || response.statusCode >= 300) {

                return callback(new Error("Failed to execute command. StatusCode " + response.statusCode));
            }
            let data = [];
            response.on('data', chunk => {
                data.push(chunk);
            });

            response.on('end', () => {
                try {
                    const bodyContent = $$.Buffer.concat(data).toString();
                    //console.log('resolve will be called. bodyContent received : ', bodyContent);
                    return callback(undefined,bodyContent);
                } catch (err) {
                    return callback(err);
                }
            });
        });

        req.on('error', err => {
            return callback(err);
        });

        if(body) {
            req.write(body);
        }
        req.end();
    };

    this.makeLocalRequestAsync = async function(method, path, body, headers) {
        try {
            const makeLocalRequest = $$.promisify(this.makeLocalRequest.bind(this));
            let response = await makeLocalRequest(method, path, body, headers);
    
            if (response) {
                try {
                    response = JSON.parse(response);
                } catch (error) {
                    // the response isn't a JSON so we keep it as it is
                }           
            }
    
            return response;
        } catch (error) {
            // console.warn(`Failed to call ${method} on '${path}'`, error);
            throw error;
        }
    }

    /* INTERNAL METHODS */

    function _initServer(sslConfig) {
        let server;
        if (sslConfig) {
             server = https.createServer(sslConfig, middleware.go);
             server.protocol = "https";
        } else {
            server = http.createServer(middleware.go);
            server.protocol = "http";
        }

        return server;
    }

    return new Proxy(this, {
       get(target, prop, receiver) {
           if(typeof target[prop] !== "undefined") {
               return target[prop];
           }

           if(typeof server[prop] === "function") {
               return function(...args) {
                   server[prop](...args);
               }
           } else {
               return server[prop];
           }
       }
    });
}

module.exports = Server;
},{"./MiddlewareRegistry":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/apihub/libs/http-wrapper/src/classes/MiddlewareRegistry.js","http":false,"https":false}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/apihub/libs/http-wrapper/src/httpUtils.js":[function(require,module,exports){
const logger = $$.getLogger("http-wrapper", "apihub/libs");

function setDataHandler(request, callback) {
    let bodyContent = '';

    request.on('data', function (dataChunk) {
        bodyContent += dataChunk;
    });

    request.on('end', function () {
        callback(undefined, bodyContent);
    });

    request.on('error', callback);
}

function setDataHandlerMiddleware(request, response, next) {
    if (request.headers['content-type'] !== 'application/octet-stream') {
        setDataHandler(request, function (error, bodyContent) {
            request.body = bodyContent;
            next(error);
        });
    } else {
        return next();
    }
}

function sendErrorResponse(error, response, statusCode) {
    logger.error(error);
    response.statusCode = statusCode;
    response.end();
}

function bodyParser(req, res, next) {
    let bodyContent = '';

    req.on('data', function (dataChunk) {
        bodyContent += dataChunk;
    });

    req.on('end', function () {
        req.body = bodyContent;
        next();
    });

    req.on('error', function (err) {
        next(err);
    });
}

function serveStaticFile(baseFolder, ignorePath) {
    return function (req, res) {
        const fs = require('fs');
        const path = require("swarmutils").path;

        const url = req.url.substring(ignorePath.length);
        const filePath = path.join(baseFolder, url);
        fs.stat(filePath, (err) => {
            if (err) {
                res.statusCode = 404;
                res.end();
                return;
            }

            if (url.endsWith('.html')) {
                res.contentType = 'text/html';
            } else if (url.endsWith('.css')) {
                res.contentType = 'text/css';
            } else if (url.endsWith('.js')) {
                res.contentType = 'text/javascript';
            }

            const fileStream = fs.createReadStream(filePath);
            fileStream.pipe(res);

        });
    };
}

module.exports = {setDataHandler, setDataHandlerMiddleware, sendErrorResponse, bodyParser, serveStaticFile};

},{"fs":false,"swarmutils":"swarmutils"}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/apihub/libs/http-wrapper/src/index.js":[function(require,module,exports){
const Client = require('./classes/Client');
const Server = require('./classes/Server');
const httpUtils = require('./httpUtils');
const Router = require('./classes/Router');

module.exports = {Server, Client, httpUtils, Router};


},{"./classes/Client":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/apihub/libs/http-wrapper/src/classes/Client.js","./classes/Router":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/apihub/libs/http-wrapper/src/classes/Router.js","./classes/Server":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/apihub/libs/http-wrapper/src/classes/Server.js","./httpUtils":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/apihub/libs/http-wrapper/src/httpUtils.js"}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/apihub/middlewares/authorisation/index.js":[function(require,module,exports){
const openDSU = require("opendsu");
const crypto = openDSU.loadApi("crypto");

const {sendUnauthorizedResponse} = require("../../utils/middlewares");

function Authorisation(server) {
  const logger = $$.getLogger("Authorisation", "apihub/authorisation");

  logger.debug(`Registering Authorisation middleware`);

  const config = require("../../config");
  const skipJWTAuthorisation = config.getConfig("skipJWTAuthorisation");

  const urlsToSkip = skipJWTAuthorisation && Array.isArray(skipJWTAuthorisation) ? skipJWTAuthorisation : [];

  server.use(function (req, res, next) {
    let { url } = req;
    let jwt = req.headers['authorization'];

    const canSkipJWTAuthorisation = urlsToSkip.some((urlToSkip) => url.indexOf(urlToSkip) === 0);
    if (url === "/" || canSkipJWTAuthorisation) {
      next();
      return;
    }

    if (!config.getConfig("enableLocalhostAuthorization") && req.headers.host.indexOf("localhost") === 0) {
      next();
      return;
    }

    if (!jwt) {
      return sendUnauthorizedResponse(req, res, "Missing required Authorization header");
    }

    config.getTokenIssuers((err, tokenIssuers) => {
      if (err) {
        return sendUnauthorizedResponse(req, res, "error while getting token issuers", err);
      }

      jwt = jwt.replace("Bearer ", "");
      crypto.verifyAuthToken(jwt, tokenIssuers, (error, isValid) => {
        if (error || !isValid) {
          return sendUnauthorizedResponse(req, res, "JWT could not be verified", error);
        }

        next();
      });
    });
  });
}

module.exports = Authorisation;

},{"../../config":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/apihub/config/index.js","../../utils/middlewares":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/apihub/utils/middlewares/index.js","opendsu":"opendsu"}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/apihub/middlewares/fixedUrls/index.js":[function(require,module,exports){
(function (Buffer){(function (){
const REQUEST_IDENTIFIER = "fixedurlrequest";
const INTERVAL_TIME = 1 * 1000; //ms aka 1 sec
const DEFAULT_MAX_AGE = 10; //seconds aka 10 sec
const TASKS_TABLE = "tasks";
const HISTORY_TABLE = "history";
const DATABASE = "FixedUrls.db";

const LokiDatabase = require("loki-enclave-facade");
const fsname = "fs";
const fs = require(fsname);
const pathname = "path";
const path = require(pathname);

module.exports = function (server) {

    const workingDir = path.join(server.rootFolder, "external-volume", "fixed-urls");
    const storage = path.join(workingDir, "storage");
    const databasePersistence = path.join(workingDir, DATABASE);
    let database;

    let watchedUrls = [];
    //we inject a helper function that can be called by different components or middleware to signal that their requests
    // can be watched by us
    server.allowFixedUrl = function (url) {
        if (!url) {
            throw new Error("Expected an Array of strings or single string representing url prefix");
        }
        if (Array.isArray(url)) {
            watchedUrls = watchedUrls.concat(url);
            return;
        }
        watchedUrls.push(url);
    }

    function ensureURLUniformity(req) {
        let base = "https://non.relevant.url.com";
        //we add the base to get a valid url
        let converter = new URL(base + req.url);
        //we ensure that the searchParams are sorted
        converter.searchParams.sort();
        //we remove our artificial base
        let newString = converter.toString().replaceAll(base, "");
        return newString;
    }

    function respond(res, content) {
        res.statusCode = 200;
        const fixedURLExpiry = server.config.fixedURLExpiry || DEFAULT_MAX_AGE;
        res.setHeader("cache-control", `max-age=${fixedURLExpiry}`);
        res.write(content);
        res.end();
    }

    function getIdentifier(fixedUrl){
        return Buffer.from(fixedUrl).toString("base64");
    }

    const indexer = {
        getFileName: function (fixedUrl) {
            return path.join(storage, getIdentifier(fixedUrl));
        },
        persist:function(fixedUrl, content, callback){
            fs.writeFile(indexer.getFileName(fixedUrl), content, callback);
        },
        get:function(fixedUrl, callback){
            fs.readFile(indexer.getFileName(fixedUrl), callback);
        },
        clean:function(fixedUrl, callback){
            fs.unlink(indexer.getFileName(fixedUrl), callback);
        }
    };

    const taskRegistry = {
        inProgress:{},
        createModel:function(fixedUrl){
            return {url: fixedUrl, pk: getIdentifier(fixedUrl)};
        },
        register:function(task, callback){
            let newRecord = taskRegistry.createModel(task);
            database.getRecord(undefined, HISTORY_TABLE, newRecord.pk, function (err, record){
                if(err || !record){
                    database.insertRecord(undefined, HISTORY_TABLE, newRecord.pk, newRecord, callback);
                }
                return callback(undefined);
            });
        },
        add:function(task, callback){
            let newRecord = taskRegistry.createModel(task);
            database.getRecord(undefined, TASKS_TABLE, newRecord.pk, function (err, record){
                if(err || !record){
                    database.insertRecord(undefined, TASKS_TABLE, newRecord.pk, newRecord, callback);
                }
                return callback(undefined);
            });
        },
        remove:function(task, callback){
            let toBeRemoved = taskRegistry.createModel(task);
            database.getRecord(undefined, TASKS_TABLE, toBeRemoved.pk, function(err, record){
                if(err || !record){
                    return callback(undefined);
                }
                database.deleteRecord(undefined, TASKS_TABLE, toBeRemoved.pk, callback);
            });
        },
        getOneTask:function(callback){
            database.filter(undefined, TASKS_TABLE, "__timestamp > 0", "asc", 1, function(err, task){
                if(err){
                    return callback(err);
                }
                if(task.length === 0){
                    return callback(undefined);
                }
                task = task[0];
                if(taskRegistry.inProgress[task.url]){
                    //we already have this task in progress, we need to wait
                    return callback(undefined);
                }
                taskRegistry.inProgress[task.url] = true;
                callback(undefined, task);
            });
        },
        isInProgress:function(task){
            return !!taskRegistry.inProgress[task];
        },
        markAsDone:function(task, callback){
            taskRegistry.inProgress[task] = undefined;
            delete taskRegistry.inProgress[task];
            taskRegistry.remove(task, callback);
        },
        isKnown:function(task, callback){
            let target = taskRegistry.createModel(task);
            database.getRecord(undefined, HISTORY_TABLE, target.pk, callback);
        },
        schedule:function(criteria, callback){
            database.filter(undefined, HISTORY_TABLE, criteria, function(err, records){
                if(err){
                    return callback(err);
                }

                function createTask(){
                    if(records.length === 0){
                        return callback(undefined);
                    }

                    let record = records.pop();
                    taskRegistry.add(record.url, function (err){
                        if(err){
                            return callback(err);
                        }
                        createTask();
                    });
                }

                createTask();
            });
        },
        cancel:function(criteria, callback){
            database.filter(undefined, TASKS_TABLE, criteria, async function(err, tasks){
                if(err){
                    if(err.code === 404){
                        return callback();
                    }
                    return callback(err);
                }

                try{
                    let markAsDone = $$.promisify(taskRegistry.markAsDone);
                    let clean = $$.promisify(indexer.clean);
                    for(let task of tasks){
                        let url = task.url;
                        //by marking it as done the task is removed from pending and database also
                        await markAsDone(url);
                        try{
                            await clean(url);
                        }catch(err){
                            //we ignore any errors related to file not found...
                            if(err.code !== "ENOENT"){
                                throw err;
                            }
                        }
                    }
                }catch(err){
                    return callback(err);
                }

                callback(undefined);
            });
        }
    };
    const taskRunner = {
        execute:function(){
            taskRegistry.getOneTask(function(err, task){
                if(err || !task){
                    return;
                }

                console.info("Executing task for url", task.url);
                const fixedUrl = task.url;
                //we need to do the request and save the result into the cache
                let urlBase = `http://127.0.0.1`;
                let url = urlBase;
                if (!fixedUrl.startsWith("/")) {
                    url += "/";
                }
                url += fixedUrl;

                //let's create an url object from our string
                let converter = new URL(url);
                //we inject the request identifier
                converter.searchParams.append(REQUEST_IDENTIFIER, "true");
                //this new url will contain our flag that prevents resolving in our middleware
                url = converter.toString().replace(urlBase, "");

                //executing the request

                server.makeLocalRequest("GET", url, "", {}, function (err, result) {
                    if (err) {
                        console.error("caught an error during fetching fixedUrl", err.message, err.code, err);
                        return taskRegistry.markAsDone(task.url, (err)=>{
                            if (err) {
                                console.log("Failed to remove a task that we weren't able to resolve");
                                return;
                            }
                            //if failed we add the task back to the end of the queue...
                            setTimeout(()=>{
                                taskRegistry.add(task.url,(err)=>{
                                    if(err){
                                        console.log("Failed to reschedule the task", task.url, err.message, err.code, err);
                                    }
                                });
                            }, 100);
                        })
                    }
                    //got result... we need to store it for future requests, and we need to resolve any pending request waiting for it
                    if (result) {
                        //let's resolve as fast as possible any pending request for the current task
                        taskRunner.resolvePendingReq(task.url, result);

                        if(!taskRegistry.isInProgress(task.url)){
                            console.info("Looks that somebody canceled the task before we were able to resolve.");
                            //if somebody canceled the task before we finished the request we stop!
                            return ;
                        }

                        indexer.persist(task.url, result, function (err) {
                            if (err) {
                                console.log("Not able to persist fixed url", task);
                            }

                            taskRegistry.markAsDone(task.url, (err) => {
                                if (err) {
                                    console.log("May be not really important, but ... Not able to mark as done task ", task);
                                }
                            });

                            //let's test if we have other tasks that need to be executed...
                            taskRunner.execute();
                        });
                    }
                });
            })
        },
        pendingRequests:{},
        registerReq: function(url, req, res){
            if(!taskRunner.pendingRequests[url]){
                taskRunner.pendingRequests[url] = [];
            }
            taskRunner.pendingRequests[url].push({req, res});
        },
        resolvePendingReq: function(url, content){
            let pending = taskRunner.pendingRequests[url];
            if(!pending){
                return;
            }
            while(pending.length>0){
                let delayed = pending.shift();
                try{
                    respond(delayed.res, content);
                }catch(err){
                    //we ignore any errors at this stage... timeouts, client aborts etc.
                }
            }
        }
    };

    fs.mkdir(storage, {recursive: true}, (err) => {
        if (err) {
            console.log("Failed to ensure folder structure due to", err);
        }
        database = new LokiDatabase(databasePersistence, INTERVAL_TIME);

        setInterval(taskRunner.execute, INTERVAL_TIME);
    });

    server.put("/registerFixedURLs", require("./../../utils/middlewares").bodyReaderMiddleware);
    server.put("/registerFixedURLs", function register(req, res, next){
        if(!database){
            return setTimeout(()=>{
                register(req, res, next);
            }, 100);
        }
        let body = req.body;
        try{
            body = JSON.parse(body);
        }catch(err){
            console.log(err);
        }

        if(!Array.isArray(body)){
            body = [body];
        }

        function recursiveRegistry(){
            if(body.length === 0){
                res.statusCode = 200;
                res.end();
                return;
            }
            let fixedUrl = body.pop();
            taskRegistry.register(fixedUrl, function(err){
                if(err){
                    res.statusCode = 500;
                    return res.end(err.message);
                }
                recursiveRegistry();
            });
        }

        recursiveRegistry();
    });

    server.put("/activateFixedURL", require("./../../utils/middlewares").bodyReaderMiddleware);
    server.put("/activateFixedURL", function activate(req, res, next){
        if(!database){
            return setTimeout(()=>{
                activate(req, res, next);
            }, 100);
        }
        taskRegistry.schedule(req.body.toString(), function (err){
            if(err){
                console.log(err);
                res.statusCode = 500;
                return res.end();
            }
            res.statusCode = 200;
            res.end();
        });
    });

    server.put("/deactivateFixedURL", require("./../../utils/middlewares").bodyReaderMiddleware);
    server.put("/deactivateFixedURL", function deactivate(req, res, next){
        if(!database){
            return setTimeout(()=>{
                deactivate(req, res, next);
            }, 100);
        }
        taskRegistry.cancel(req.body.toString(), function (err){
            if(err){
                console.log(err);
                res.statusCode = 500;
                return res.end();
            }
            res.statusCode = 200;
            res.end();
        });
    });

    //register a middleware to intercept all the requests
    server.use("*", function (req, res, next) {

        if (req.method !== "GET") {
            //not our responsibility... for the moment we resolve only GET methods that have query params...
            return next();
        }

        let possibleFixedUrl = false;
        for (let url of watchedUrls) {
            if (req.url.startsWith(url)) {
                possibleFixedUrl = true;
            }
        }

        if (!possibleFixedUrl) {
            //not our responsibility
            return next();
        }

        if (req.query && req.query[REQUEST_IDENTIFIER]) {
            //this REQUEST_IDENTIFIER query param is set by our runner, and we should let this request to be executed
            return next();
        }

        //if we reached this line of code means that we need to do our "thing"
        let fixedUrl = ensureURLUniformity(req);
        if(taskRegistry.isInProgress(fixedUrl)){
            //there is a task for it... let's wait
            return taskRunner.registerReq(fixedUrl, req, res);
        }

        taskRegistry.isKnown(fixedUrl, (err, known) => {
            if (known) {
                //there is no task in progress for this url... let's test even more...
                return indexer.get(fixedUrl, (err, content) => {
                    if (err) {
                        //no current task and no cache... let's move on to resolving the req
                        return next();
                    }
                    //known fixed url let's respond to the client
                    respond(res, content);
                });
            }
            next();
        });
    });
}
}).call(this)}).call(this,require("buffer").Buffer)

},{"./../../utils/middlewares":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/apihub/utils/middlewares/index.js","buffer":false,"loki-enclave-facade":"loki-enclave-facade"}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/apihub/middlewares/genericErrorMiddleware/index.js":[function(require,module,exports){
function setupGenericErrorMiddleware(server) {
    const constants = require("./../../moduleConstants");
    const logger = $$.getLogger("setupGenericErrorMiddleware", "apihub/genericErrorMiddleware");

	server.use(function (req, res, next) {
        const capturedWrites = [];

        const originalResWrite = res.write;
        const originalResEnd = res.end;

        res.write = function(chunk, encoding, callback){
            if(typeof callback === "function" || typeof encoding === "function"){
                logger.debug(`${constants.LOG_IDENTIFIER}`,
                    "Generic Error Middleware is running and has detected that a callback was used for response.write method call.",
                    "Be aware that this middleware can generate undesired behaviour in this case.", new Error());
            }
            capturedWrites.push([chunk, encoding, callback]);
        }

        res.end = function(data, encoding, callback){
            if(res.statusCode < 400){
                for(let i=0; i<capturedWrites.length; i++){
                    originalResWrite.call(res, ...capturedWrites[i]);
                }
                originalResEnd.call(res, data, encoding, callback);
            }else{
                if(req.log){
                    for(let i=0; i<capturedWrites.length; i++){
                        req.log("Generic Error Middleware prevented message to be sent on response.write", ...capturedWrites[i]);
                    }
                    if(data){
                        req.log("Generic Error Middleware prevented message to be sent on response.end", data);
                    }
                }
                originalResWrite.call(res, "Error");
                originalResEnd.call(res, undefined, encoding, callback);
            }
        }

		next();
	});

    logger.debug(`${constants.LOG_IDENTIFIER}`, "generic error middleware was loaded. This middleware will prevent any error to leak when sending a >=400 response to the client.");
}

module.exports = setupGenericErrorMiddleware;

},{"./../../moduleConstants":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/apihub/moduleConstants.js"}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/apihub/middlewares/logger/index.js":[function(require,module,exports){
function Logger(server) {
    const LOG_IDENTIFIER = "Logger";
    const logger = $$.getLogger(LOG_IDENTIFIER, "apihub/logger");
    logger.debug(`Registering Logger middleware`);

    const getRequestDuration = (start) => {
        const diff = process.hrtime(start);
        return (diff[0] * 1e9 + diff[1]) / 1e6;
    };

    let ms = 3000;
    let longRequests = [];
    const config = server.config.componentsConfig;
    if (config.requestLogger) {
        if (config.requestLogger.statusLogInterval) {
            ms = config.requestLogger.statusLogInterval;
            logger.debug(`Requests that will take longer than ${ms} ms will be logged as in progress`);
        }

        if (config.requestLogger.longRequests) {
            if (!Array.isArray(config.requestLogger.longRequests)) {
                logger.error("longRequests config is expected to be an Array of strings! Check config to make it apply!");
            } else {
                longRequests = config.requestLogger.longRequests;
                logger.debug("the following filter will be used to acknowledge longer time resolve urls", JSON.stringify(longRequests));
            }
        }
    }

    server.use(function (req, res, next) {
        const {
            method,
            url
        } = req;

        const start = process.hrtime();

        let timer;
        let quickReq = true;
        for(let longReq of longRequests){
            if(url.indexOf(longReq)!==-1){
                quickReq = false;
            }
        }

        if(quickReq){
            //we don't want to log requests that have a big time to leave like (TLL) in case of http poll requests
            timer = setInterval(() => {
                logger.info(`Request progress ${method}:${url}`);
            }, ms);
        }

        let durationInMilliseconds;

        //let's add a safety net and log
        res.on('error', (error) => {
            if (error) {
                //may be redundant to check the argument but still ...
                logger.info(`Error while sending response for ${method}:${url}`, error.code, error.message);
            }
        });

        res.on('finish', () => {
            //clearing the timer
            if (timer) {
                clearInterval(timer);
            }

            const {statusCode} = res;
            durationInMilliseconds = getRequestDuration(start);
            let log = `${method}:${url} ${statusCode} ${durationInMilliseconds.toLocaleString()}ms`;
            logger.log(log);
            if (req.getLogs) {
                const visualIndex = "\t";
                const requestLogs = req.getLogs();
                if (requestLogs.length > 0) {
                    logger.debug("Request logs:");
                    for (let i = 0; i < requestLogs.length; i++) {
                        if (Array.isArray(requestLogs)) {
                            logger.log(visualIndex, ...requestLogs[i]);
                        } else {
                            logger.log(visualIndex, requestLogs[i]);
                        }
                    }
                    logger.log("\n");
                }
            }
        });

        next();
    });
}

module.exports = Logger;

},{}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/apihub/middlewares/oauth/index.js":[function(require,module,exports){
const config = require("../../config");

const serverAuthentication = config.getConfig("serverAuthentication")
if (serverAuthentication) {
    module.exports = require("./lib/OauthMiddleware");
} else {
    module.exports = require("./lib/AccessTokenValidator");
}


},{"../../config":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/apihub/config/index.js","./lib/AccessTokenValidator":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/apihub/middlewares/oauth/lib/AccessTokenValidator.js","./lib/OauthMiddleware":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/apihub/middlewares/oauth/lib/OauthMiddleware.js"}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/apihub/middlewares/oauth/lib/AccessTokenValidator.js":[function(require,module,exports){
const {sendUnauthorizedResponse} = require("../../../utils/middlewares");
const util = require("./util");
const config = require("../../../config");

function AccessTokenValidator(server) {
    const logger = $$.getLogger("AccessTokenValidator", "apihub/oauth");

    logger.debug(`Registering AccessTokenValidator middleware`);
    const urlsToSkip = util.getUrlsToSkip();

    server.use(function (req, res, next) {
        let {url} = req;
        let cookies = util.parseCookies(req.headers.cookie);
        const authorisation = cookies.authorization;
        const canSkipOAuth = urlsToSkip.some((urlToSkip) => url.indexOf(urlToSkip) === 0);
        if (url === "/" || canSkipOAuth) {
            next();
            return;
        }

        if (!config.getConfig("enableLocalhostAuthorization") && req.headers.host.indexOf("localhost") === 0) {
            next();
            return;
        }

        if (!authorisation) {
            res.writeHead(301, {Location: "/"});
            res.end();
            return;
        }

        const jwksEndpoint = config.getConfig("oauthJWKSEndpoint");
        util.validateAccessToken(jwksEndpoint, authorisation,  (err) => {
            if (err) {
                return sendUnauthorizedResponse(req, res, "Failed to validate token");
            }

            next();
        })
    });
}

module.exports = AccessTokenValidator;
},{"../../../config":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/apihub/config/index.js","../../../utils/middlewares":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/apihub/utils/middlewares/index.js","./util":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/apihub/middlewares/oauth/lib/util.js"}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/apihub/middlewares/oauth/lib/OauthMiddleware.js":[function(require,module,exports){
const {sendUnauthorizedResponse} = require("../../../utils/middlewares");
const util = require("./util");
const urlModule = require("url");

function OAuthMiddleware(server) {
  const logger = $$.getLogger("OAuthMiddleware", "apihub/oauth");

  logger.debug(`Registering OAuthMiddleware`);
  const config = require("../../../config");
  const oauthConfig = config.getConfig("oauthConfig");
  const path = require("path");
  const ENCRYPTION_KEYS_LOCATION = oauthConfig.encryptionKeysLocation || path.join(server.rootFolder, "external-volume", "encryption-keys");
  const urlsToSkip = util.getUrlsToSkip();

  const WebClient = require("./WebClient");
  const webClient = new WebClient(oauthConfig);
  const errorMessages = require("./errorMessages");

  //we let KeyManager to boot and prepare ...
  util.initializeKeyManager(ENCRYPTION_KEYS_LOCATION, oauthConfig.keyTTL);

  function startAuthFlow(req, res) {
    printDebugLog("Starting authentication flow");
    const loginContext = webClient.getLoginInfo(oauthConfig);
    printDebugLog("Login info", JSON.stringify(loginContext));
    util.encryptLoginInfo(loginContext, (err, encryptedContext) => {
      if (err) {
        return sendUnauthorizedResponse(req, res, "Unable to encrypt login info");
      }

      res.writeHead(301, {
        Location: loginContext.redirect,
        "Set-Cookie": `loginContextCookie=${encryptedContext}`,
        "Cache-Control": "no-store, no-cache, must-revalidate, post-check=0, pre-check=0"
      });
      res.end();
    })
  }

  function loginCallbackRoute(req, res) {
    printDebugLog("Entered login callback");
    let cbUrl = req.url;
    let query = urlModule.parse(cbUrl, true).query;
    const {loginContextCookie} = util.parseCookies(req.headers.cookie);
    if (!loginContextCookie) {
      printDebugLog("Logout because loginContextCookie is missing.")
      return logout(res);
    }
    util.decryptLoginInfo(loginContextCookie, (err, loginContext) => {
      if (err) {
        return sendUnauthorizedResponse(req, res, "Unable to decrypt login info", err);
      }

      if (Date.now() - loginContext.date > oauthConfig.sessionTimeout) {
        printDebugLog("Logout because loginContextCookie is expired.")
        return logout(res);
      }

      const queryCode = query['code'];
      const queryState = query['state'];
      const context = {
        clientState: loginContext.state,
        clientFingerprint: loginContext.fingerprint,
        clientCode: loginContext.codeVerifier,
        queryCode,
        queryState,
        origin: req.headers.host,
      };

      printDebugLog("Requesting token set");
      printDebugLog("context", JSON.stringify(context));
      webClient.loginCallback(context, (err, tokenSet) => {
        if (err) {
          return sendUnauthorizedResponse(req, res, "Unable to get token set", err);
        }

        printDebugLog("Access token", tokenSet.access_token);
        util.encryptTokenSet(tokenSet, (err, encryptedTokenSet) => {
          if (err) {
            return sendUnauthorizedResponse(req, res, "Unable to encrypt access token", err);
          }

          const {payload} = util.parseAccessToken(tokenSet.access_token);
          printDebugLog("Access token payload", payload);
          const SSODetectedId = util.getSSODetectedIdFromDecryptedToken(tokenSet.access_token);
          printDebugLog("SSODetectedId", SSODetectedId);
          res.writeHead(301, {
            Location: "/",
            "Set-Cookie": [`accessTokenCookie=${encryptedTokenSet.encryptedAccessToken}`, "isActiveSession=true", `refreshTokenCookie=${encryptedTokenSet.encryptedRefreshToken}`, `SSOUserId = ${payload.sub}`, `SSODetectedId = ${SSODetectedId}`, `loginContextCookie=; Max-Age=0`],
            "Cache-Control": "no-store, no-cache, must-revalidate, post-check=0, pre-check=0"
          });
          res.end();
        })
      });
    });
  }

  function logout(res) {
    const urlModule = require("url");
    const logoutUrl = urlModule.parse(oauthConfig.client.logoutUrl);

    logoutUrl.query = {
      post_logout_redirect_uri: oauthConfig.client.postLogoutRedirectUrl,
      client_id: oauthConfig.client.clientId,
    };
    res.writeHead(301, {
      Location: urlModule.format(logoutUrl),
      "Set-Cookie": `sessionExpiryTime=; Path=/`
    });
    res.end();
  }


  function printDebugLog(...args) {
    if (oauthConfig.debugLogEnabled) {
      logger.debug(...args);
    }
  }

  server.use(function (req, res, next) {
    let {url} = req;

    function isCallbackPhaseActive() {
      const redirectUrlObj = new urlModule.URL(oauthConfig.client.redirectPath);
      const redirectPath = oauthConfig.client.redirectPath.slice(redirectUrlObj.origin.length);
      return !!url.includes(redirectPath) || !!url.includes("code=");
    }

    function isPostLogoutPhaseActive() {
      const postLogoutRedirectUrlObj = new urlModule.URL(oauthConfig.client.postLogoutRedirectUrl);
      const postLogoutRedirectPath = oauthConfig.client.postLogoutRedirectUrl.slice(postLogoutRedirectUrlObj.origin.length);
      return !!url.includes(postLogoutRedirectPath);
    }

    function startLogoutPhase(res) {
      res.writeHead(301, {
        Location: "/logout",
        "Set-Cookie": ["accessTokenCookie=; Max-Age=0", "isActiveSession=; Max-Age=0", "refreshTokenCookie=; Max-Age=0", "loginContextCookie=; Max-Age=0"],
        "Cache-Control": "no-store, no-cache, must-revalidate, post-check=0, pre-check=0"
      });
      res.end();
    }

    function isLogoutPhaseActive() {
      return url === "/logout";
    }

    const canSkipOAuth = urlsToSkip.some((urlToSkip) => url.indexOf(urlToSkip) === 0);
    if (canSkipOAuth) {
      next();
      return;
    }

    if (!config.getConfig("enableLocalhostAuthorization") && req.headers.host.indexOf("localhost") === 0) {
      next();
      return;
    }

    //this if is meant to help debugging "special" situation of wrong localhost req being checked with sso even if localhostAuthorization is disabled
    if (!config.getConfig("enableLocalhostAuthorization") && req.headers.host.indexOf("localhost") !== -1){
      logger.debug("SSO verification activated on 'local' request", "host header", req.headers.headers.host, JSON.stringify(req.headers));
    }

    if (isCallbackPhaseActive()) {
      return loginCallbackRoute(req, res);
    }

    if (isLogoutPhaseActive()) {
      return logout(res);
    }

    if (isPostLogoutPhaseActive()) {
      return startAuthFlow(req, res);
    }

    let {accessTokenCookie, refreshTokenCookie, isActiveSession} = util.parseCookies(req.headers.cookie);

    if (!accessTokenCookie) {
      if (!isActiveSession) {
        printDebugLog("Redirect to start authentication flow because accessTokenCookie and isActiveSession are missing.")
        return startAuthFlow(req, res);
      } else {
        printDebugLog("Logout because accessTokenCookie is missing and isActiveSession is present.")
        return startLogoutPhase(res);
      }
    }

    const jwksEndpoint = config.getConfig("oauthJWKSEndpoint");
    util.validateEncryptedAccessToken(jwksEndpoint, accessTokenCookie, oauthConfig.sessionTimeout, (err) => {
      if (err) {
        if (err.message === errorMessages.ACCESS_TOKEN_DECRYPTION_FAILED || err.message === errorMessages.SESSION_EXPIRED) {
          printDebugLog("Logout because accessTokenCookie decryption failed or session has expired.")
          return startLogoutPhase(res);
        }

        return webClient.refreshToken(refreshTokenCookie, (err, tokenSet) => {
          if (err) {
            if (err.message === errorMessages.REFRESH_TOKEN_DECRYPTION_FAILED || err.message === errorMessages.SESSION_EXPIRED) {
              printDebugLog("Logout because refreshTokenCookie decryption failed or session has expired.")
              return startLogoutPhase(res);
            }
            return sendUnauthorizedResponse(req, res, "Unable to refresh token");
          }

          const cookies = [`accessTokenCookie=${tokenSet.encryptedAccessToken}`, `refreshTokenCookie=${tokenSet.encryptedRefreshToken}`];
          res.writeHead(301, {Location: "/", "Set-Cookie": cookies});
          res.end();
        })
      }

      util.getSSODetectedIdFromEncryptedToken(accessTokenCookie, (err, SSODetectedId)=>{
        if (err) {
            printDebugLog("Logout because accessTokenCookie decryption failed or session has expired.")
            return startLogoutPhase(res);
        }

        printDebugLog("SSODetectedId", SSODetectedId);
        req.headers["user-id"] = SSODetectedId;
        if (url.includes("/mq/")) {
          return next();
        }
        util.updateAccessTokenExpiration(accessTokenCookie, (err, encryptedAccessToken)=>{
          if (err) {
            printDebugLog("Logout because accessTokenCookie decryption failed.")
            return startLogoutPhase(res);
          }

          const sessionExpiryTime = Date.now() + oauthConfig.sessionTimeout;
          const cookies = [`sessionExpiryTime=${sessionExpiryTime}; Path=/`, `accessTokenCookie=${encryptedAccessToken}; Path=/`]
          res.setHeader("Set-Cookie", cookies);
          next();
        })
      })
    })
  });
}

module.exports = OAuthMiddleware;

},{"../../../config":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/apihub/config/index.js","../../../utils/middlewares":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/apihub/utils/middlewares/index.js","./WebClient":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/apihub/middlewares/oauth/lib/WebClient.js","./errorMessages":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/apihub/middlewares/oauth/lib/errorMessages.js","./util":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/apihub/middlewares/oauth/lib/util.js","path":false,"url":false}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/apihub/middlewares/oauth/lib/WebClient.js":[function(require,module,exports){
(function (Buffer){(function (){
const url = require('url');
const util = require("./util");
const openDSU = require("opendsu");
const http = openDSU.loadAPI("http");
const crypto = openDSU.loadAPI("crypto");
const errorMessages = require("./errorMessages");

function WebClient(oauthConfig) {
    this.getLoginInfo = () => {
        const fingerprint = crypto.generateRandom(32).toString('hex');//User-agent IP
        const state = crypto.generateRandom(32).toString('hex');
        const pkce = util.pkce();
        const authorizeUrl = url.parse(oauthConfig.issuer.authorizationEndpoint);
        authorizeUrl.query = {
            client_id: oauthConfig.client.clientId,
            redirect_uri: oauthConfig.client.redirectPath,
            response_type: 'code',
            scope: oauthConfig.client.scope,
            code_challenge_method: 'S256',
            code_challenge: pkce.codeChallenge,
            state
        };
        return {
            state,
            fingerprint,
            codeVerifier: pkce.codeVerifier,
            redirect: url.format(authorizeUrl),
            date: Date.now()
        }
    }


    this.loginCallback = (context, callback) => {
        //fingerprint virification
        if (context.clientState !== context.queryState) {
            return callback(new Error('Invalid state'));
        }

        let body = {
            'grant_type': 'authorization_code',
            'client_id': oauthConfig.client.clientId,
            'client_secret': oauthConfig.client.clientSecret,
            'redirect_uri': oauthConfig.client.redirectPath,
            'code': context.queryCode,
            'code_verifier': context.clientCode
        }

        const postData = util.urlEncodeForm(body);

        const options = {
            method: "POST",
            headers: {
                'Content-Type': 'application/x-www-form-urlencoded',
                'Content-Length': postData.length
            }
        };

        http.doPost(oauthConfig.issuer.tokenEndpoint, util.urlEncodeForm(body), options, (err, tokenSet) => {
            if (err) {
                return callback(err);
            }

            try {
                tokenSet = JSON.parse(tokenSet);
            } catch (e) {
                return callback(e);
            }

            callback(undefined, tokenSet);
        });
    }

    this.refreshToken = function refreshToken(currentEncryptionKeyPath, previousEncryptionKeyPath, refreshTokenCookie, callback) {
        util.decryptRefreshTokenCookie(currentEncryptionKeyPath, previousEncryptionKeyPath, refreshTokenCookie, (err, refreshToken) => {
            if (err) {
                return callback(err);
            }

            if ( Date.now() - refreshToken.date > oauthConfig.sessionTimeout) {
                return callback(Error(errorMessages.SESSION_EXPIRED))
            }

            const body = {
                'grant_type': 'refresh_token',
                'client_id': oauthConfig.client.clientId,
                'redirect_uri': oauthConfig.client.redirectPath,
                'refresh_token': refreshToken,
                'client_secret': oauthConfig.client.clientSecret
            };
            const postData = util.urlEncodeForm(body);
            const options = {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/x-www-form-urlencoded',
                    'Content-Length': Buffer.byteLength(postData)
                }
            }

            http.doPost(oauthConfig.issuer.tokenEndpoint, postData, options, (err, tokenSet) => {
                if (err) {
                    return callback(err);
                }

                try {
                    tokenSet = JSON.parse(tokenSet);
                } catch (e) {
                    return callback(e);
                }
                util.encryptTokenSet(currentEncryptionKeyPath, tokenSet, callback);
            });
        });
    }
}


module.exports = WebClient;
}).call(this)}).call(this,require("buffer").Buffer)

},{"./errorMessages":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/apihub/middlewares/oauth/lib/errorMessages.js","./util":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/apihub/middlewares/oauth/lib/util.js","buffer":false,"opendsu":"opendsu","url":false}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/apihub/middlewares/oauth/lib/errorMessages.js":[function(require,module,exports){
module.exports = {
    ACCESS_TOKEN_DECRYPTION_FAILED: "Failed to decrypt accessTokenCookie",
    REFRESH_TOKEN_DECRYPTION_FAILED: "Failed to decrypt refreshTokenCookie",
    REFRESH_TOKEN_UNDEFINED: "refreshTokenCookie is undefined",
    SESSION_EXPIRED:"Session expired"
}
},{}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/apihub/middlewares/oauth/lib/util.js":[function(require,module,exports){
const openDSU = require("opendsu");
const crypto = openDSU.loadAPI("crypto");
const http = openDSU.loadAPI("http");
const fs = require("fs");
const errorMessages = require("./errorMessages");

let publicKey;

const PREVIOUS_ENCRYPTION_KEY_FILE = "previousEncryptionKey.secret";
const CURRENT_ENCRYPTION_KEY_FILE = "currentEncryptionKey.secret";

function KeyManager(storage, rotationInterval){
    let current;
    let previous;

    const logger = $$.getLogger("OAuthMiddleware", "oauth/keyManager");

    function getPath(filename){
        const path = require("path");
        return path.join(storage, filename);
    }

    function persist(filename, key, callback){
        logger.debug("Writing", filename);
        fs.writeFile(getPath(filename), key, callback);
    }

    function getAge(lastModificationTime){
        let timestamp = new Date().getTime();
        let converted = new Date(lastModificationTime).getTime();
        let age = timestamp - converted;
        //logger.debug("age seems to be", age);
        return age;
    }

    function checkIfExpired(lastModificationTime){
        let res = getAge(lastModificationTime) > rotationInterval;
        logger.debug("expired", res);
        return res;
    }

    let self = this;
    function tic(){
        fs.stat(getPath(CURRENT_ENCRYPTION_KEY_FILE), (err, stats)=>{
            if(stats && checkIfExpired(stats.mtime)){
                self.rotate();
            }

            if(err || !stats){
                //for any error we try as soon as possible again
                setTimeout(tic, 0);
            }
        });
    }

    function generateKey(){
        logger.debug("generating new key");
        return crypto.generateRandom(32);
    }

    this.init = ()=>{
        let stats;
        try {
            stats = fs.statSync(getPath(CURRENT_ENCRYPTION_KEY_FILE));
            if(stats){
                logger.debug("mtime of current encryption key is", stats.mtime);
                if(checkIfExpired(stats.mtime)){
                    throw new Error("Current key is to old");
                }
                logger.info("Loading encryption keys");
                current = fs.readFileSync(getPath(CURRENT_ENCRYPTION_KEY_FILE));
                try{
                    previous = fs.readFileSync(getPath(PREVIOUS_ENCRYPTION_KEY_FILE));
                }catch(e){
                    logger.debug("Caught an error during previous key loading. This could mean that a restart was performed before any rotation and the previous key file doesn't exit.", e.message, e.code);
                }

                // let's schedule a quick check of key age
                setTimeout(tic, getAge(stats.mtime));
            }else{
                logger.info("Initializing...");
                throw new Error("Initialization required");
            }
        } catch (e) {
            logger.debug(e.message);
            //for any reason we try to ensure folder structure...
            fs.mkdirSync(storage, {recursive: true});

            this.rotate();
        }

        //we split the "big" interval in smaller intervals
        setInterval(tic, Math.round(rotationInterval/12));
    }

    this.getCurrentEncryptionKey = ()=>{
        return current;
    }

    this.getPreviousEncryptionKey = ()=>{
        return previous;
    }

    this.rotate = ()=>{
        if(!current && !previous){
            logger.info("No current or previous key, there we generate current ant persist");
            current = generateKey();
            return persist(CURRENT_ENCRYPTION_KEY_FILE, current, (err)=>{
                if(err){
                    logger.error("Failed to persist key");
                }
            });
        }
        logger.debug("saving current key as previous");
        previous = current;
        current = generateKey();

        function saveState(lastGeneratedKey){
            if(lastGeneratedKey !== current){
                logger.error("Unable to persist keys until a new rotation time achieved");
                //we weren't able to save the state until a new rotation
                return;
            }
            persist(PREVIOUS_ENCRYPTION_KEY_FILE, previous, (err)=>{
                if(err){
                    logger.debug("Caught error during key rotation", err);
                    return saveState(lastGeneratedKey);
                }
                persist(CURRENT_ENCRYPTION_KEY_FILE, current, (err)=>{
                    if(err){
                        logger.debug("Caught error during key rotation", err);
                        saveState(lastGeneratedKey);
                    }
                    logger.info("Successful key rotation");
                });
            });
        }

        saveState(current);
    }

    this.init();
    return this;
}

let keyManager;
function initializeKeyManager(storage, rotationInterval){
    if(!keyManager){
        keyManager =  new KeyManager(storage, rotationInterval);
    }
}

function pkce() {
    const codeVerifier = crypto.generateRandom(32).toString('hex');
    const codeChallenge = pkceChallenge(codeVerifier);
    return {codeVerifier, codeChallenge};
}

function pkceChallenge(codeVerifier) {
    return crypto.sha256JOSE(codeVerifier).toString("base64").replace(/=/g, "")
        .replace(/\+/g, "-")
        .replace(/\//g, "_");
}

function urlEncodeForm(obj) {
    let encodedStr = "";
    for (let prop in obj) {
        encodedStr += `${encodeURIComponent(prop)}=${encodeURIComponent(obj[prop])}&`;
    }
    if (encodedStr[encodedStr.length - 1] === "&") {
        encodedStr = encodedStr.slice(0, -1);
    }

    return encodedStr;
}

function encodeCookie(cookie) {
    if (typeof cookie === "string") {
        cookie = $$.Buffer.from(cookie);
    }
    return encodeURIComponent(cookie.toString("base64"));
}

function decodeCookie(cookie) {
    return $$.Buffer.from(decodeURIComponent(cookie), "base64");
}

function parseCookies(cookies) {
    const parsedCookies = {};
    if (!cookies) {
        return parsedCookies;
    }
    let splitCookies = cookies.split(";");
    splitCookies = splitCookies.map(splitCookie => splitCookie.trim());
    splitCookies.forEach(cookie => {
        const cookieComponents = cookie.split("=");
        const cookieName = cookieComponents[0].trim();
        let cookieValue = cookieComponents[1].trim();
        if (cookieValue === "null") {
            cookieValue = undefined;
        }
        parsedCookies[cookieName] = cookieValue;
    })

    return parsedCookies;
}

function parseAccessToken(rawAccessToken) {
    let [header, payload, signature] = rawAccessToken.split(".");
    header = JSON.parse($$.Buffer.from(header, "base64").toString())
    payload = JSON.parse($$.Buffer.from(payload, "base64").toString())
    return {
        header, payload, signature
    }
}

function getCurrentEncryptionKey(callback) {
    if(!keyManager){
        return callback(new Error("keyManager not instantiated"));
    }

    return callback(undefined, keyManager.getCurrentEncryptionKey());
}

function getPreviousEncryptionKey(callback) {
    if(!keyManager){
        return callback(new Error("keyManager not instantiated"));
    }

    return callback(undefined, keyManager.getPreviousEncryptionKey());
}

function encryptTokenSet(tokenSet, callback) {
    const accessTokenPayload = {
        date: Date.now(),
        token: tokenSet.access_token
    }

    const refreshTokenPayload = {
        date: Date.now(),
        token: tokenSet.refresh_token
    }


    getCurrentEncryptionKey((err, encryptionKey) => {
        if (err) {
            return callback(err);
        }

        let encryptedTokenSet;
        try {
            let encryptedAccessToken = crypto.encrypt(JSON.stringify(accessTokenPayload), encryptionKey);
            let encryptedRefreshToken = crypto.encrypt(JSON.stringify(refreshTokenPayload), encryptionKey);
            encryptedTokenSet = {
                encryptedAccessToken: encodeCookie(encryptedAccessToken),
                encryptedRefreshToken: encodeCookie(encryptedRefreshToken)
            }
        } catch (e) {
            return callback(e);
        }
        callback(undefined, encryptedTokenSet);
    })
}

function encryptLoginInfo(loginInfo, callback) {
    getCurrentEncryptionKey((err, encryptionKey) => {
        if (err) {
            return callback(err);
        }

        let encryptedContext;
        try {
            encryptedContext = crypto.encrypt(JSON.stringify(loginInfo), encryptionKey);
            encryptedContext = encodeCookie(encryptedContext);
        } catch (e) {
            return callback(e);
        }
        callback(undefined, encryptedContext);
    })
}

function encryptAccessToken(accessToken, callback) {
    const accessTokenTimestamp = Date.now();
    const accessTokenPayload = {
        date: accessTokenTimestamp, token: accessToken
    }

    getCurrentEncryptionKey((err, currentEncryptionKey) => {
        if (err) {
            return callback(err);
        }

        let encryptedAccessToken;
        try {
            encryptedAccessToken = crypto.encrypt(JSON.stringify(accessTokenPayload), currentEncryptionKey);
            encryptedAccessToken = encodeCookie(encryptedAccessToken);
        } catch (e) {
            return callback(e);
        }
        callback(undefined, encryptedAccessToken);
    });
}

function decryptData(encryptedData, encryptionKey, callback) {
    let plainData;
    try {
        plainData = crypto.decrypt(encryptedData, encryptionKey);
    } catch (e) {
        return callback(e);
    }

    callback(undefined, plainData);
}

function decryptDataWithCurrentKey(encryptedData, callback) {
    getCurrentEncryptionKey((err, currentEncryptionKey) => {
        if (err) {
            return callback(err);
        }

        decryptData(encryptedData, currentEncryptionKey, callback);
    })
}

function decryptDataWithPreviousKey(encryptedData, callback) {
    getPreviousEncryptionKey((err, previousEncryptionKey) => {
        if (err) {
            return callback(err);
        }

        decryptData(encryptedData, previousEncryptionKey, callback);
    })
}

function decryptAccessTokenCookie(accessTokenCookie, callback) {
    function parseAccessTokenCookie(accessTokenCookie, callback) {
        let parsedAccessTokenCookie;
        try {
            parsedAccessTokenCookie = JSON.parse(accessTokenCookie.toString());
        } catch (e) {
            return callback(e);
        }

        callback(undefined, parsedAccessTokenCookie);
    }

    decryptDataWithCurrentKey(decodeCookie(accessTokenCookie), (err, plainAccessTokenCookie) => {
        if (err) {
            decryptDataWithPreviousKey(decodeCookie(accessTokenCookie), (err, plainAccessTokenCookie) => {
                if (err) {
                    return callback(err);
                }

                parseAccessTokenCookie(plainAccessTokenCookie, callback);
            })

            return;
        }


        parseAccessTokenCookie(plainAccessTokenCookie, callback);
    })
}

function getDecryptedAccessToken(accessTokenCookie, callback) {
    decryptAccessTokenCookie(accessTokenCookie, (err, decryptedAccessTokenCookie) => {
        if (err) {
            return callback(err);
        }

        callback(undefined, decryptedAccessTokenCookie.token);
    })
}

function getSSOUserIdFromDecryptedToken(decryptedToken) {
    const {payload} = parseAccessToken(decryptedToken);
    return payload.sub;
}

function getSSODetectedIdFromDecryptedToken(decryptedToken) {
    const {payload} = parseAccessToken(decryptedToken);
    const SSODetectedId = payload.email || payload.preferred_username || payload.upn || payload.sub;
    return SSODetectedId;
}

function getSSODetectedIdFromEncryptedToken( accessTokenCookie, callback) {
    getDecryptedAccessToken(accessTokenCookie, (err, token) => {
        if (err) {
            return callback(err);
        }

        return callback(undefined, getSSODetectedIdFromDecryptedToken(token));
    })
}

function decryptRefreshTokenCookie(encryptedRefreshToken, callback) {
    if (!encryptedRefreshToken) {
        return callback(Error(errorMessages.REFRESH_TOKEN_UNDEFINED));
    }

    decryptDataWithCurrentKey(encryptedRefreshToken, (err, refreshToken) => {
        if (err) {
            decryptDataWithPreviousKey(encryptedRefreshToken, (err, refreshToken) => {
                if (err) {
                    err.message = errorMessages.REFRESH_TOKEN_DECRYPTION_FAILED;
                    return callback(err);
                }

                callback(undefined, refreshToken.toString());
            });
            return
        }

        callback(undefined, refreshToken.toString());
    });
}

function getPublicKey(jwksEndpoint, rawAccessToken, callback) {
    if (publicKey) {
        return callback(undefined, publicKey);
    }

    http.doGet(jwksEndpoint, (err, rawData) => {
        if (err) {
            return callback(err);
        }
        try {
            const parsedData = JSON.parse(rawData);
            const accessToken = parseAccessToken(rawAccessToken);
            publicKey = parsedData.keys.find(key => key.use === "sig" && key.kid === accessToken.header.kid);
            if (!publicKey) {
                return callback(Error(`Could not get private key for the provided token's signature verification.`))
            }
        } catch (e) {
            return callback(e);
        }

        callback(undefined, publicKey);
    })
}

function validateAccessToken(jwksEndpoint, accessToken, callback) {
    getPublicKey(jwksEndpoint, accessToken, (err, publicKey) => {
        if (err) {
            return callback(err);
        }

        crypto.joseAPI.verify(accessToken, publicKey, callback);
    })
}

function validateEncryptedAccessToken(jwksEndpoint, accessTokenCookie, sessionTimeout, callback) {
    decryptAccessTokenCookie(accessTokenCookie, (err, decryptedAccessTokenCookie) => {
        if (err) {
            return callback(Error(errorMessages.ACCESS_TOKEN_DECRYPTION_FAILED));
        }

        if (Date.now() - decryptedAccessTokenCookie.date > sessionTimeout) {
            return callback(Error(errorMessages.SESSION_EXPIRED));
        }
        validateAccessToken(jwksEndpoint, decryptedAccessTokenCookie.token, callback);
    })
}

function decryptLoginInfo(encryptedLoginInfo, callback) {
    decryptDataWithCurrentKey(decodeCookie(encryptedLoginInfo), (err, loginContext) => {
        function parseLoginContext(loginContext, callback) {
            let parsedLoginContext;
            try {
                parsedLoginContext = JSON.parse(loginContext.toString());
            } catch (e) {
                return callback(e);
            }

            callback(undefined, parsedLoginContext);
        }

        if (err) {
            decryptDataWithPreviousKey(decodeCookie(encryptedLoginInfo), (err, loginContext) => {
                if (err) {
                    return callback(err);
                }

                parseLoginContext(loginContext, callback);
            })

            return;
        }

        parseLoginContext(loginContext, callback);
    })
}

function getUrlsToSkip() {
    const config = require("../../../config");
    const skipOAuth = config.getConfig("skipOAuth");
    let urlsToSkip = skipOAuth && Array.isArray(skipOAuth) ? skipOAuth : [];
    const configuredDomains = config.getConfiguredDomains();
    configuredDomains.forEach(domain => {
        const domainConfig = config.getDomainConfig(domain);
        if (domainConfig.skipOAuth) {
            urlsToSkip = urlsToSkip.concat(domainConfig.skipOAuth);
        }
    })

    return urlsToSkip;
}

function updateAccessTokenExpiration(accessTokenCookie, callback) {
    decryptAccessTokenCookie(accessTokenCookie, (err, decryptedTokenCookie)=>{
        if (err) {
            return callback(err);
        }

        encryptAccessToken(decryptedTokenCookie.token, callback);
    })
}

module.exports = {
    pkce,
    pkceChallenge,
    urlEncodeForm,
    encodeCookie,
    decodeCookie,
    parseCookies,
    initializeKeyManager,
    parseAccessToken,
    encryptTokenSet,
    encryptAccessToken,
    encryptLoginInfo,
    decryptLoginInfo,
    decryptAccessTokenCookie,
    decryptRefreshTokenCookie,
    getPublicKey,
    validateAccessToken,
    validateEncryptedAccessToken,
    getUrlsToSkip,
    getSSODetectedIdFromDecryptedToken,
    getSSODetectedIdFromEncryptedToken,
    getSSOUserIdFromDecryptedToken,
    updateAccessTokenExpiration
}

},{"../../../config":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/apihub/config/index.js","./errorMessages":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/apihub/middlewares/oauth/lib/errorMessages.js","fs":false,"opendsu":"opendsu","path":false}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/apihub/middlewares/requestEnhancements/index.js":[function(require,module,exports){
function setupRequestEnhancements(server) {
    const logger = $$.getLogger("setupRequestEnhancements", "apihub/requestEnhancements");

    const constants = require("./../../moduleConstants");

	server.use(function (req, res, next) {
	    const logs = [];
        req.log = function(...args){
            logs.push(args);
        };

        req.getLogs = function(){
            return logs;
        }

		next();
	});

    logger.debug(`${constants.LOG_IDENTIFIER}`, "Request API enhancements were set up.");
}

module.exports = setupRequestEnhancements;

},{"./../../moduleConstants":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/apihub/moduleConstants.js"}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/apihub/middlewares/responseHeader/index.js":[function(require,module,exports){
function ResponseHeaders(server) {
    const logger = $$.getLogger("ResponseHeaders", "apihub/responseHeaders");

    logger.debug(`Registering Response Headers middleware`);

    const config = require("../../config");
    const responseHeaders = config.getConfig("responseHeaders");

    server.use(function (req, res, next) {
        if (!responseHeaders) {
            return next();
        }
        for (let header in responseHeaders) {
            res.setHeader(header, responseHeaders[header]);
        }

        next();
    });
}

module.exports = ResponseHeaders;

},{"../../config":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/apihub/config/index.js"}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/apihub/middlewares/throttler/index.js":[function(require,module,exports){
const TokenBucket = require("../../libs/TokenBucket");

function Throttler(server){
	const logger = $$.getLogger("Throttler", "apihub");
	const START_TOKENS = 6000000;
	const tokenBucket = new TokenBucket(START_TOKENS, 1, 10);
	let remainingTokens = START_TOKENS;
	const conf =  require('../../config').getConfig();
	 function throttlerHandler(req, res, next) {
		 const ip = res.socket.remoteAddress;
		 tokenBucket.takeToken(ip, tokenBucket.COST_MEDIUM, function (err, remainedTokens) {
			 res.setHeader('X-RateLimit-Limit', tokenBucket.getLimitByCost(tokenBucket.COST_MEDIUM));
			 res.setHeader('X-RateLimit-Remaining', tokenBucket.getRemainingTokenByCost(remainedTokens, tokenBucket.COST_MEDIUM));
			 remainingTokens = remainedTokens;
			 if (err) {
				 if (err === TokenBucket.ERROR_LIMIT_EXCEEDED) {
					 res.statusCode = 429;
				 } else {
					 res.statusCode = 500;
				 }

				 res.end();
				 return;
			 }

			 next();
		 });
	 }

	 function readyProbeHandler(req, res) {
		 const stats = {
			 remainingTokens: tokenBucket.getRemainingTokenByCost(remainingTokens, tokenBucket.COST_MEDIUM),
			 tokenLimit: tokenBucket.getLimitByCost(tokenBucket.COST_MEDIUM)
		 }

		 res.setHeader('Content-Type', 'application/json');
		 res.statusCode = 200;
		 res.write(JSON.stringify(stats));
		 res.end();
	 }

	if (conf.preventRateLimit !== true) {
		server.use(throttlerHandler);
		server.get("/ready-probe", readyProbeHandler);
	} else {
		logger.debug(`Rate limit mechanism disabled!`);
		server.get("/ready-probe", function (req, res) {
			res.statusCode = 200;
			res.write("Server ready");
			res.end();
		});
	}
}

module.exports = Throttler;
},{"../../config":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/apihub/config/index.js","../../libs/TokenBucket":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/apihub/libs/TokenBucket.js"}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/apihub/moduleConstants.js":[function(require,module,exports){
module.exports = {
	LOG_IDENTIFIER: "[API-HUB]"
};
},{}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/apihub/utils/cookie-utils.js":[function(require,module,exports){
const COOKIE_REGEX = /([^;=\s]*)=([^;]*)/g;

function parseCookies(str) {
    let cookies = {};
    if (!str) {
        return cookies;
    }
    for (let m; (m = COOKIE_REGEX.exec(str)); ) {
        cookies[m[1]] = decodeURIComponent(m[2]);
    }
    return cookies;
}

/**
 * @param {Object} options
 * @param {string} [options.name='']
 * @param {string} [options.value='']
 * @param {Date} [options.expires]
 * @param {number} [options.maxAge]
 * @param {string} [options.domain]
 * @param {string} [options.path]
 * @param {boolean} [options.secure]
 * @param {boolean} [options.httpOnly]
 * @param {'Strict'|'Lax'|'None'} [options.sameSite]
 * @return {string}
 */
function createSetCookieEntry(options) {
    return (
        `${options.name || ""}=${encodeURIComponent(options.value || "")}` +
        (options.expires != null ? `; Expires=${options.expires.toUTCString()}` : "") +
        (options.maxAge != null ? `; Max-Age=${options.maxAge}` : "") +
        (options.domain != null ? `; Domain=${options.domain}` : "") +
        (options.path != null ? `; Path=${options.path}` : "") +
        (options.secure ? "; Secure" : "") +
        (options.httpOnly ? "; HttpOnly" : "") +
        (options.sameSite != null ? `; SameSite=${options.sameSite}` : "")
    );
}

function stringifyCookies(cookies) {
    if (!Array.isArray(cookies)) {
        cookies = [cookies];
    }

    return cookies.map(createSetCookieEntry).join("; ");
}

module.exports = {
    parseCookies,
    stringifyCookies,
};

},{}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/apihub/utils/index.js":[function(require,module,exports){
module.exports.clone = function(data) {
    return JSON.parse(JSON.stringify(data));
}

module.exports.streams = require("./streams");
module.exports.requests = require("./requests");
module.exports.responseWrapper = require("./responseWrapper");
module.exports.getMimeTypeFromExtension = require("./mimeType");
},{"./mimeType":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/apihub/utils/mimeType.js","./requests":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/apihub/utils/requests.js","./responseWrapper":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/apihub/utils/responseWrapper.js","./streams":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/apihub/utils/streams.js"}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/apihub/utils/middlewares/index.js":[function(require,module,exports){
(function (Buffer){(function (){
const responseWrapper = require('../responseWrapper');
const logger = $$.getLogger("middlewares", "apihub/utils");

function requestBodyJSONMiddleware(request, response, next) {
    /**
     * Prepare headers for response
     */
    response.setHeader('Content-Type', 'application/json');

    const data = [];

    request.on('data', (chunk) => {
        data.push(chunk);
    });

    request.on('end', () => {
        if (!data.length) {
            request.body = {};
            return next();
        }

        let body;

        try {
            body = JSON.parse(data);
        } catch (e) {
            response.statusCode = 500;
            return response.end("Unable to decode JSON request body");
        }
        request.body = body;
        next();
    });
}

function responseModifierMiddleware(request, response, next) {
    if (!response.hasOwnProperty('send')) {
        response.send = function (statusCode, body, callback = response.end) {
            response.statusCode = statusCode;

            if (body) {
                response.write(responseWrapper(body));
            }

            callback.call(response);
            // callback();
        };
    }

    next();
}

function headersMiddleware(req, res, next) {
    res.setHeader('Access-Control-Allow-Origin', '*');

    // Request methods you wish to allow
    res.setHeader('Access-Control-Allow-Methods', 'GET, POST, OPTIONS, PUT, PATCH, DELETE');

    // Request headers you wish to allow
    res.setHeader('Access-Control-Allow-Headers', 'X-Requested-With, Content-Type, Content-Length, X-Content-Length');
    next();
}

function bodyReaderMiddleware(req, res, next) {
    const data = [];

    req.on('data', (chunk) => {
        data.push(chunk);
    });

    req.on('end', () => {
        req.body = Buffer.concat(data);
        next();
    });
}

function sendUnauthorizedResponse(req, res, reason, error) {
    logger.error(`[Auth] [${req.method}] ${req.url} blocked: ${reason}`, error);
    res.statusCode = 403;
    res.end();
}

module.exports = { requestBodyJSONMiddleware, responseModifierMiddleware, headersMiddleware , bodyReaderMiddleware, sendUnauthorizedResponse};

}).call(this)}).call(this,require("buffer").Buffer)

},{"../responseWrapper":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/apihub/utils/responseWrapper.js","buffer":false}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/apihub/utils/mimeType.js":[function(require,module,exports){
const extensionsMimeTypes = {
    "aac": {
        name: "audio/aac",
        binary: true
    },
    "abw": {
        name: "application/x-abiword",
        binary: true
    },
    "arc": {
        name: "application/x-freearc",
        binary: true
    },
    "avi": {
        name: "video/x-msvideo",
        binary: true
    },
    "azw": {
        name: "application/vnd.amazon.ebook",
        binary: true
    },
    "bin": {
        name: "application/octet-stream",
        binary: true
    }, "bmp": {
        name: "image/bmp",
        binary: true
    }, "bz": {
        name: "application/x-bzip",
        binary: true
    }, "bz2": {
        name: "application/x-bzip2",
        binary: true
    }, "csh": {
        name: "application/x-csh",
        binary: false
    }, "css": {
        name: "text/css",
        binary: false
    }, "csv": {
        name: "text/csv",
        binary: false
    }, "doc": {
        name: "application/msword",
        binary: true
    }, "docx": {
        name: "application/vnd.openxmlformats-officedocument.wordprocessingml.document",
        binary: true
    }, "eot": {
        name: "application/vnd.ms-fontobject",
        binary: true
    }, "epub": {
        name: "application/epub+zip",
        binary: true
    }, "gz": {
        name: "application/gzip",
        binary: true
    }, "gif": {
        name: "image/gif",
        binary: true
    }, "htm": {
        name: "text/html",
        binary: false
    }, "html": {
        name: "text/html",
        binary: false
    }, "ico": {
        name: "image/vnd.microsoft.icon",
        binary: true
    }, "ics": {
        name: "text/calendar",
        binary: false
    }, "jpeg": {
        name: "image/jpeg",
        binary: true
    }, "jpg": {
        name: "image/jpeg",
        binary: true
    }, "js": {
        name: "text/javascript",
        binary: false
    }, "json": {
        name: "application/json",
        binary: false
    }, "jsonld": {
        name: "application/ld+json",
        binary: false
    }, "mid": {
        name: "audio/midi",
        binary: true
    }, "midi": {
        name: "audio/midi",
        binary: true
    }, "mjs": {
        name: "text/javascript",
        binary: false
    }, "mp3": {
        name: "audio/mpeg",
        binary: true
    }, "mpeg": {
        name: "video/mpeg",
        binary: true
    }, "mpkg": {
        name: "application/vnd.apple.installer+xm",
        binary: true
    }, "odp": {
        name: "application/vnd.oasis.opendocument.presentation",
        binary: true
    }, "ods": {
        name: "application/vnd.oasis.opendocument.spreadsheet",
        binary: true
    }, "odt": {
        name: "application/vnd.oasis.opendocument.text",
        binary: true
    }, "oga": {
        name: "audio/ogg",
        binary: true
    },
    "ogv": {
        name: "video/ogg",
        binary: true
    },
    "ogx": {
        name: "application/ogg",
        binary: true
    },
    "opus": {
        name: "audio/opus",
        binary: true
    },
    "otf": {
        name: "font/otf",
        binary: true
    },
    "png": {
        name: "image/png",
        binary: true
    },
    "pdf": {
        name: "application/pdf",
        binary: true
    },
    "php": {
        name: "application/php",
        binary: false
    },
    "ppt": {
        name: "application/vnd.ms-powerpoint",
        binary: true
    },
    "pptx": {
        name: "application/vnd.openxmlformats-officedocument.presentationml.presentation",
        binary: true
    },
    "rtf": {
        name: "application/rtf",
        binary: true
    },
    "sh": {
        name: "application/x-sh",
        binary: false
    },
    "svg": {
        name: "image/svg+xml",
        binary: false
    },
    "swf": {
        name: "application/x-shockwave-flash",
        binary: true
    },
    "tar": {
        name: "application/x-tar",
        binary: true
    },
    "tif": {
        name: "image/tiff",
        binary: true
    },
    "tiff": {
        name: "image/tiff",
        binary: true
    },
    "ts": {
        name: "video/mp2t",
        binary: true
    },
    "ttf": {
        name: "font/ttf",
        binary: true
    },
    "txt": {
        name: "text/plain",
        binary: false
    },
    "vsd": {
        name: "application/vnd.visio",
        binary: true
    },
    "wav": {
        name: "audio/wav",
        binary: true
    },
    "weba": {
        name: "audio/webm",
        binary: true
    },
    "webm": {
        name: "video/webm",
        binary: true
    },
    "webp": {
        name: "image/webp",
        binary: true
    },
    "woff": {
        name: "font/woff",
        binary: true
    },
    "woff2": {
        name: "font/woff2",
        binary: true
    },
    "xhtml": {
        name: "application/xhtml+xml",
        binary: false
    },
    "xls": {
        name: "application/vnd.ms-excel",
        binary: true
    },
    "xlsx": {
        name: "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
        binary: true
    },
    "xml": {
        name: "text/xml",
        binary: false
    },
    "xul": {
        name: "application/vnd.mozilla.xul+xml",
        binary: true
    },
    "zip": {
        name: "application/zip",
        binary: true
    },
    "3gp": {
        name: "video/3gpp",
        binary: true
    },
    "3g2": {
        name: "video/3gpp2",
        binary: true
    },
    "7z": {
        name: "application/x-7z-compressed",
        binary: true
    }
};

const defaultMimeType = {
    name: "text/plain",
    binary: false
};
module.exports = function (extension) {
    if (typeof extensionsMimeTypes[extension] !== "undefined") {
        return extensionsMimeTypes[extension];
    }
    return defaultMimeType;
};
},{}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/apihub/utils/request-utils.js":[function(require,module,exports){
const logger = $$.getLogger("request-utils", "apihub/utils");

function getCurrentApiHubUrl(server) {
    const config = require("../config");
    const currentApiHubUrl = `${server.protocol}://${config.getConfig("host")}:${config.getConfig("port")}`;
    return currentApiHubUrl;
}

function getExcludedProvidersFromRequest(request) {
    let excludedProviders = request.headers["excluded-providers"];
    if (!excludedProviders) {
        return [];
    }

    excludedProviders = excludedProviders
        .split(",")
        .map((provider) => provider.trim())
        .filter((provider) => provider);
    return excludedProviders;
}

function getHeadersWithExcludedProvidersIncludingSelf(request) {
    let excludedProviders = request.headers["excluded-providers"] || "";
    if (excludedProviders) {
        excludedProviders += ",";
    }
    const currentApiHubUrl = getCurrentApiHubUrl(request.server);
    excludedProviders = `${excludedProviders}${currentApiHubUrl}`;

    return {
        "Excluded-Providers": excludedProviders,
    };
}

async function getLocalBdnsEntryListExcludingSelfAsync(request, domain, entryName) {
    const { server } = request;
    let entries;

    try {
        // trying to get the entries via contract call
        const entriesUrl = `/contracts/${domain}/bdns-entries/anchoringServices`;
        entries = await server.makeLocalRequestAsync("GET", entriesUrl);
    } catch (error) {
        logger.error(`[${entryName}] Failed to call contract to get ${entryName}. Falling back to local bdns check`);

        try {
            const bdnsUrl = `/bdns`;
            const bdns = await server.makeLocalRequestAsync("GET", bdnsUrl);
            if (bdns && bdns[domain]) {
                entries = bdns[domain][entryName];
            }
        } catch (error) {
            logger.error(`[${entryName}] Failed to call BDNS to get ${entryName}`);
        }
    }

    if (entries && Array.isArray(entries)) {
        // remove self url from the list
        const currentApiHubUrl = getCurrentApiHubUrl(server);
        entries = entries.filter((url) => url && url.indexOf(currentApiHubUrl) === -1);

        // remove providers specified in the Excluded-Providers headers in order to avoid cyclic calls
        const excludedProviders = getExcludedProvidersFromRequest(request);
        if (excludedProviders.length) {
            entries = entries.filter(
                (provider) => !excludedProviders.some((excludedProvider) => excludedProvider.indexOf(provider) !== -1)
            );
        }
    }

    return entries;
}

module.exports = {
    getLocalBdnsEntryListExcludingSelfAsync,
    getHeadersWithExcludedProvidersIncludingSelf,
};

},{"../config":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/apihub/config/index.js"}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/apihub/utils/requests.js":[function(require,module,exports){

const http = require("http");
const https = require("https");

function makeRequest(url, method = 'GET', requestData, requestOptions = {}) {
    return new Promise((resolve, reject) => {
        const myURL = new URL(url);

        const options = {
            hostname: myURL.hostname,
            path: myURL.pathname,
            protocol: myURL.protocol,
            port: myURL.port,
            method: method,
            headers: getHeaders(requestData, requestOptions.headers)
        };

        const request = (options.protocol === 'https:' ? https : http).request(options, (response) => {
            let data = [];

            response.on('data', (chunk) => {
                data.push(chunk);
            });

            response.on('end', () => {
                const stringData = $$.Buffer.concat(data).toString();

                return resolve({
                    statusCode: response.statusCode,
                    body: isJSON(stringData) ? JSON.parse(stringData) : stringData
                });
            });
        }).on("error", (err) => {
            return reject({
                statusCode: err.statusCode,
                body: err.message || 'Internal error'
            });
        });

        if ((method === 'POST' || method === 'PUT') && requestData) {
            request.write(typeof requestData === 'object' ? JSON.stringify(requestData) : requestData);
        }

        request.end();
    })
}

function isJSON(data) {
    try {
        JSON.parse(data)
    } catch (err) {
        return false;
    }

    return true;
}

function getHeaders(data, headers) {
    const dataString = data ? JSON.stringify(data) : null;
    return Object.assign({}, { 'Content-Type': 'application/json' }, dataString ? { 'Content-Length': dataString.length } : null, headers);
};

module.exports = makeRequest;

},{"http":false,"https":false}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/apihub/utils/responseWrapper.js":[function(require,module,exports){

function responseWrapper(body) {
    if (typeof body === 'string') {
        return JSON.stringify({ message: body });
    }

    return JSON.stringify(body);
}

module.exports = responseWrapper;

},{}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/apihub/utils/streams.js":[function(require,module,exports){
function readStringFromStream(stream, callback){
    let data = "";
    stream.on("data", (messagePart)=>{
        data += messagePart;
    });

    stream.on("end", ()=>{
        callback(null, data);
    });

    stream.on("error", (err)=>{
        callback(err);
    });
}

function readMessageBufferFromHTTPStream(reqORres, callback) {
    const contentType = reqORres.headers['content-type'];

    if (contentType === 'application/octet-stream') {
        const contentLength = Number.parseInt(reqORres.headers['content-length'], 10);

        if (Number.isNaN(contentLength)) {
            return callback(new Error("Wrong content length header received!"));
        }

        streamToBuffer(reqORres, contentLength, (err, bodyAsBuffer) => {
            if (err) {
                return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to convert stream to buffer`, err));
            }
            callback(undefined, bodyAsBuffer);
        });
    } else {
        callback(new Error("Wrong message format received!"));
    }

    function streamToBuffer(stream, bufferSize, callback) {
        const buffer = $$.Buffer.alloc(bufferSize);
        let currentOffset = 0;

        stream.on('data', function (chunk) {
            const chunkSize = chunk.length;
            const nextOffset = chunkSize + currentOffset;

            if (currentOffset > bufferSize - 1) {
                stream.close();
                return callback(new Error('Stream is bigger than reported size'));
            }

            write2Buffer(buffer, chunk, currentOffset);
            currentOffset = nextOffset;
            

        });
        stream.on('end', function () {
            callback(undefined, buffer);
        });
        stream.on('error', callback);
    }

    function write2Buffer(buffer, dataToAppend, offset) {
        const dataSize = dataToAppend.length;

        for (let i = 0; i < dataSize; i++) {
            buffer[offset++] = dataToAppend[i];
        }
    }
}

module.exports = {
    readStringFromStream,
    readMessageBufferFromHTTPStream
}

},{}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/bar-fs-adapter/lib/FsAdapter.js":[function(require,module,exports){
function FsAdapter() {
    const fsModule = "fs";
    const fs = require(fsModule);
    const pathModule = "path";
    const path = require(pathModule);
    const PathAsyncIterator = require('./PathAsyncIterator');

    this.getFileSize = function (filePath, callback) {
        fs.stat(filePath, (err, stats) => {
            if (err) {
                return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper("Failed to get file size", err));
            }

            callback(undefined, stats.size);
        });
    };

    this.readBlockFromFile = function (filePath, blockStart, blockEnd, callback) {
        const readStream = fs.createReadStream(filePath, {
            start: blockStart,
            end: blockEnd
        });

        let data = $$.Buffer.alloc(0);

        readStream.on("data", (chunk) => {
            data = $$.Buffer.concat([data, chunk]);
        });

        readStream.on("error", (err) => {
            return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper("Failed to read data from file " + filePath, err));
        });

        readStream.on("end", () => {
            callback(undefined, data);
        });
    };

    this.getFilesIterator = function (inputPath) {
        return new PathAsyncIterator(inputPath);
    };

    this.appendBlockToFile = function (filePath, data, callback) {
        fs.access(filePath, (err) => {
            if (err) {
                fs.mkdir(path.dirname(filePath), {recursive: true}, (err) => {
                    if (err && err.code !== "EEXIST") {
                        return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper("Failed to append block to file "+ filePath, err));
                    }

                    fs.appendFile(filePath, data, callback);
                });
            } else {
                fs.appendFile(filePath, data, callback);
            }
        });
    };
}

module.exports = FsAdapter;
},{"./PathAsyncIterator":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/bar-fs-adapter/lib/PathAsyncIterator.js"}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/bar-fs-adapter/lib/PathAsyncIterator.js":[function(require,module,exports){
function PathAsyncIterator(inputPath) {
    const fsModule = "fs";
    const fs = require(fsModule);
    const pathModule = "path";
    const path = require(pathModule);
    const TaskCounter = require("swarmutils").TaskCounter;

    inputPath = path.normalize(inputPath);
    let removablePathLen;
    const fileList = [];
    const folderList = [];
    let isFirstCall = true;
    let pathIsFolder;

    this.next = function (callback) {
        if (isFirstCall === true) {
            isDir(inputPath, (err, status) => {
                if (err) {
                    return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to check if <${inputPath}> is directory`, err));
                }

                isFirstCall = false;
                pathIsFolder = status;
                if (status === true) {
                    if(!inputPath.endsWith(path.sep)) {
                        inputPath += path.sep;
                    }

                    removablePathLen = inputPath.length;
                    folderList.push(inputPath);
                    getNextFileFromFolder(callback);
                } else {
                    const fileName = path.basename(inputPath);
                    const fileParentFolder = path.dirname(inputPath);
                    callback(undefined, fileName, fileParentFolder);
                }
            });
        } else if (pathIsFolder) {
            getNextFileFromFolder(callback);
        } else {
            callback();
        }
    };

    function walkFolder(folderPath, callback) {
        const taskCounter = new TaskCounter((errors, results) => {
            if (fileList.length > 0) {
                const fileName = fileList.shift();
                return callback(undefined, fileName, inputPath);
            }

            if (folderList.length > 0) {
                const folderName = folderList.shift();
                return walkFolder(folderName, callback);
            }

            return callback();
        });

        fs.readdir(folderPath, (err, files) => {
            if (err) {
                return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to read dir  <${folderPath}>`, err));
            }

            if (files.length === 0 && folderList.length === 0) {
                return callback();
            }

            if (files.length === 0) {
                walkFolder(folderList.shift(), callback);
            }
            taskCounter.increment(files.length);

            files.forEach(file => {
                let filePath = path.join(folderPath, file);
                isDir(filePath, (err, status) => {
                    if (err) {
                        return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to check if <${filePath}> is directory`, err));
                    }

                    if (status) {
                        folderList.push(filePath);
                    } else {
                        fileList.push(filePath.substring(removablePathLen));
                    }

                    taskCounter.decrement();
                });
            });
        });
    }

    function isDir(filePath, callback) {
        fs.stat(filePath, (err, stats) => {
            if (err) {
                return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to get stats for file <${filePath}>`, err));
            }

            return callback(undefined, stats.isDirectory());
        });
    }

    function getNextFileFromFolder(callback) {
        if (fileList.length === 0 && folderList.length === 0) {
            return callback();
        }

        if (fileList.length > 0) {
            const fileName = fileList.shift();
            return callback(undefined, fileName, inputPath);
        }

        const folder = folderList.shift();
        walkFolder(folder, (err, file) => {
            if (err) {
                return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to walk folder  <${folder}>`, err));
            }

            callback(undefined, file, inputPath);
        });
    }
}

module.exports = PathAsyncIterator;
},{"swarmutils":"swarmutils"}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/bar/lib/AnchorValidator.js":[function(require,module,exports){
'use strict'

/**
 * 
 * @param {object} options 
 * @param {object} options.rules
 * @param {object} options.rules.preWrite
 * @param {object} options.rules.afterLoad
 */
function AnchorValidator(options) {
    options = options || {};

    let validationRules = options.rules || {};

    ////////////////////////////////////////////////////////////
    // Public methods
    ////////////////////////////////////////////////////////////

    /**
     * @param {string} stage The validation stage (afterLoad, preWrite, ...)
     * @param {...} args
     */
    this.validate = (stage, ...args) => {
        const callback = args[args.length - 1];
        if (typeof validationRules[stage] !== 'object') {
            return callback();
        }

        const stageValidation = validationRules[stage];
        if (typeof stageValidation.validate !== 'function') {
            return callback(new Error('Validation rules invalid. Missing the `validate` method'));
        }
        stageValidation.validate(...args);
    }

    /**
     * @param {object} rules
     * @param {object} rules.preWrite
     * @param {object} rules.afterLoad
     */
    this.setRules = (rules) => {
        validationRules = rules;
    }
}

module.exports = AnchorValidator;
},{}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/bar/lib/Archive.js":[function(require,module,exports){
const Brick = require('./Brick');
const stream = require('stream');
const BrickStorageService = require('./BrickStorageService').Service;
const BrickMapController = require('./BrickMapController');
const Manifest = require("./Manifest");

/**
 * @param {ArchiveConfigurator} archiveConfigurator
 */
function Archive(archiveConfigurator) {
    const swarmutils = require("swarmutils");
    const TaskCounter = swarmutils.TaskCounter;
    const pskPth = swarmutils.path;
    const openDSU = require("opendsu");
    const anchoring = openDSU.loadAPI("anchoring");
    const anchoringx = anchoring.getAnchoringX();
    const notifications = openDSU.loadAPI("notifications");

    const mountedArchivesForBatchOperations = [];

    let brickMapController;
    let brickStorageService;
    let manifestHandler;
    let batchOperationsInProgress = false;
    let refreshInProgress = false;
    let refreshPromise = Promise.resolve();
    let prevAnchoringDecisionFn;
    let prevConflictResolutionFunction;

    let publishAnchoringNotifications = false;
    let publishOptions = null;

    let autoSyncStatus = false;
    let autoSyncOptions = null;
    let dsuObsHandler = null;

    ////////////////////////////////////////////////////////////
    // Private methods
    ////////////////////////////////////////////////////////////
    const initialize = (callback) => {
        archiveConfigurator.getKeySSI((err, keySSI) => {
            if (err) {
                return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper("Failed to retrieve keySSI", err));
            }

            brickStorageService = buildBrickStorageServiceInstance(keySSI);
            brickMapController = new BrickMapController({
                config: archiveConfigurator,
                brickStorageService,
                keySSI,
                ...archiveConfigurator.getOptions()
            });

            callback();
        });
    }

    /**
     * Create and configure the BrickStorageService
     *
     * @param {object} storageProvider
     * @return {BrickStorageService}
     */
    function buildBrickStorageServiceInstance(keySSI) {
        const instance = new BrickStorageService({
            cache: archiveConfigurator.getCache(),
            bufferSize: archiveConfigurator.getBufferSize(),
            keySSI,

            brickFactoryFunction: (encrypt) => {
                encrypt = (typeof encrypt === 'undefined') ? true : !!encrypt;
                // Strip the encryption key from the SeedSSI
                return new Brick({templateKeySSI: keySSI, encrypt});
            },

            brickDataExtractorCallback: (brickMeta, brick, callback) => {
                brick.setTemplateKeySSI(keySSI);

                function extractData() {
                    const brickEncryptionKeySSI = brickMapController.getBrickEncryptionKeySSI(brickMeta);
                    brick.setKeySSI(brickEncryptionKeySSI);
                    brick.getRawData(callback);
                }

                if (refreshInProgress) {
                    return waitIfDSUIsRefreshing(() => {
                        extractData();
                    })
                }
                extractData();
            },

            fsAdapter: archiveConfigurator.getFsAdapter()
        });

        return instance;
    }

    const cancelBatchesInMountedArchives = (callback) => {
        const cancelBatch = (dossierContext) => {
            if (!dossierContext) {
                return callback();
            }

            dossierContext.archive.cancelBatch((err) => {
                if (err) {
                    return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper("Failed to cancel batch operation", err));
                }

                cancelBatch(mountedArchivesForBatchOperations.pop());
            })
        }

        cancelBatch(mountedArchivesForBatchOperations.pop());
    }

    const commitBatchesInMountedArchives = (onConflict, callback) => {
        const results = [];

        const commitBatch = (dossierContext) => {
            if (!dossierContext) {
                return callback(undefined, results);
            }

            dossierContext.archive.commitBatch(onConflict, (err, result) => {
                if (err) {
                    return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper("Failed to commit batch", err));
                }

                results.push(result);
                commitBatch(mountedArchivesForBatchOperations.pop());
            });
        }

        commitBatch(mountedArchivesForBatchOperations.pop());
    }

    /**
     * This function waits for an existing "refresh" operation to finish
     * before executing the `callback`.
     * If no refresh operation is in progress, the `callback` is executed
     * immediately.
     * This function is called by the public methods in order to prevent
     * calling methods on an uninitialized brickMapController instance
     *
     * @param {function} callback
     */
    const waitIfDSUIsRefreshing = (callback) => {
        if (refreshInProgress === false) {
            return callback();
        }

        refreshPromise.then(() => {
            callback();
        })
    }

    const getArchiveForBatchOperations = (manifestHandler, path, callback) => {
        manifestHandler.getArchiveForPath(path, (err, result) => {
            if (err) {
                return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to load DSU instance mounted at path ${path}`, err));
            }

            if (result.archive === this) {
                return callback(undefined, result);
            }

            result.archive.getKeySSIAsString((err, keySSI) => {
                if (err) {
                    return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper("Failed to retrieve keySSI", err));
                }

                const cachedArchive = mountedArchivesForBatchOperations.find((archive) => {
                    return archive.identifier === keySSI;
                });

                if (cachedArchive) {
                    cachedArchive.relativePath = result.relativePath;
                    return callback(undefined, cachedArchive);
                }

                result.identifier = keySSI;
                result.archive.beginBatch();
                mountedArchivesForBatchOperations.push(result);

                if (!publishAnchoringNotifications || publishOptions.ignoreMounts) {
                    return callback(undefined, result);
                }

                result.archive.enableAnchoringNotifications(publishAnchoringNotifications, publishOptions, (err) => {
                    if (err) {
                        return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to toggle anchoring notification publishing for mount point: ${mountPoint}`, err));
                    }

                    callback(undefined, result);
                })
            });
        });
    };

    ////////////////////////////////////////////////////////////
    // Public methods
    ////////////////////////////////////////////////////////////
    /**
     * @param {callback} callback
     */
    this.init = (callback) => {
        initialize((err) => {
            if (err) {
                return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper("Failed to initialize DSU", err));
            }

            brickMapController.init(callback);
        });
    }

    /**
     * @param {callback} callback
     */
    this.load = (callback) => {
        initialize((err) => {
            if (err) {
                return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper("Failed to initialise DSU", err));
            }

            brickMapController.load(callback);
        });
    };

    this.loadVersion = (versionHash, callback) => {
        initialize((err) => {
            if (err) {
                return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper("Failed to initialise DSU", err));
            }
            brickMapController.loadVersion(versionHash, callback);
        });
    };

    this.getBrickMapController = () => {
        return brickMapController;
    }
    /**
     * @param {callback} callback
     */
    this.refresh = (callback) => {
        waitIfDSUIsRefreshing(() => {
            refreshInProgress = true;
            refreshPromise = refreshPromise.then(() => {
                return new Promise((resolve) => {
                    this.load((err) => {
                        if (err) {
                            refreshInProgress = false;
                            return resolve(OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper("Failed to load DSU", err)));
                        }

                        // Restore auto sync settings if the archive was refreshed
                        this.enableAnchoringNotifications(publishAnchoringNotifications, publishOptions, (err) => {
                            if (err) {
                                refreshInProgress = false;
                                return resolve(OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to toggle anchoring notification publishing for mount point: ${mountPoint}`, err)));
                            }
                            this.enableAutoSync(autoSyncStatus, autoSyncOptions, (err) => {
                                refreshInProgress = false;
                                if (err) {
                                    return resolve(OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper("Failed to enable auto sync for DSU", err)));
                                }
                                resolve(callback());
                            });
                        });
                    });
                }).catch((e) => {
                    console.trace("This shouldn't happen. Refresh errors should have been already caught");
                })
            })
        })
    }

    /**
     * Returns the latest anchor
     *
     * @param {callback} function
     * @return {HashLinkSSI}
     */
    this.getLastHashLinkSSI = (callback) => {
        console.log("This method is obsolete. Please use `dsu.getLatestAnchoredHashLink()` instead.");
        return this.getLatestAnchoredHashLink(callback);
    };

    /**
     * Returns the latest anchored Hashlink
     *
     * @param {callback} function
     * @return {HashLinkSSI}
     */
    this.getLatestAnchoredHashLink = (callback) => {
        archiveConfigurator.getKeySSI((err, keySSI) => {
            if (err) {
                return callback(createOpenDSUErrorWrapper("Failed to get KeySSI", err));
            }
            anchoringx.getLastVersion(keySSI, (err, latestHashLink) => {
                if (err || !latestHashLink) {
                    return callback(createOpenDSUErrorWrapper("Failed to get the list of hashlinks", err));
                }

                const keySSISpace = require("opendsu").loadAPI("keyssi");
                if (typeof latestHashLink === "string") {
                    try {
                        latestHashLink = keySSISpace.parse(latestHashLink);
                    } catch (e) {
                        return callback(createOpenDSUErrorWrapper("Failed to get the list of hashlinks", e));
                    }
                }
                return callback(undefined, latestHashLink)
            })
        })
    }

    /**
     * Returns the current anchor
     *
     * @return {HashLinkSSI}
     */
    this.getCurrentAnchoredHashLink = (callback) => {
        return waitIfDSUIsRefreshing(() => {
            return callback(undefined, brickMapController.getCurrentAnchoredHashLink());
        })
    }

    /**
     * @return {string}
     */
    this.getKeySSI = (keySSIType, callback) => {
        console.trace("Obsolete function: use getKeySSIAsString or getKeySSIAsObject Instead");
        if (typeof keySSIType === "function") {
            callback = keySSIType;
            keySSIType = undefined;
        }
        archiveConfigurator.getKeySSI(keySSIType, ((err, keySSI) => callback(err, keySSI.getIdentifier())));
    }

    /**
     * @return {string}
     */
    this.getKeySSIAsObject = (keySSIType, callback) => {
        if (typeof keySSIType === "function") {
            callback = keySSIType;
            keySSIType = undefined;
        }
        archiveConfigurator.getKeySSI(keySSIType, callback);
    }

    /**
     * @return {string}
     */
    this.getKeySSIAsString = (keySSIType, callback) => {
        if (typeof keySSIType === "function") {
            callback = keySSIType;
            keySSIType = undefined;
        }
        archiveConfigurator.getKeySSI(keySSIType, ((err, keySSI) => callback(err, keySSI.getIdentifier())));
    }

    /**
     * @return {string}
     */
    this.getCreationSSI = (plain) => {
        return archiveConfigurator.getCreationSSI(plain);
    }

    const _fileIsEmbedded = (barPath, callback) => {
        brickMapController.fileIsEmbedded(barPath, callback);
    };

    const _ingestData = (barPath, data, options, callback) => {
        brickStorageService.ingestData(data, options, callback)
    }

    const _embedFile = (barPath, data, options, callback) => {
        brickStorageService.createEmbedSSIFromData(data, options, (err, result) => {
            if (err) {
                return callback(createOpenDSUErrorWrapper(`Failed to embed file ${barPath}`, err));
            }

            brickMapController.addFile(barPath, result, callback);
        })
    }

    const embedOrCreateBricks = (barPath, data, options, callback) => {
        if (options.embed) {
            return brickMapController.embedData(barPath, data, options, callback);
        }

        _fileIsEmbedded(barPath, (err, fileIsEmbedded) => {
            if (err) {
                return callback(err);
            }

            if (fileIsEmbedded) {
                return brickMapController.embedData(barPath, data, options, callback);
            }

            _ingestData(barPath, data, options, callback);
        });
    }

    /**
     * @param {string} barPath
     * @param {string|$$.Buffer|stream.ReadableStream} data
     * @param {object} options
     * @param {callback} callback
     */
    const _writeFile = (barPath, data, options, callback) => {
        barPath = pskPth.normalize(barPath);

        if (typeof data === "undefined") {
            return _createFile(barPath, callback);
        }

        if (options.embed) {
            return brickMapController.embedData(barPath, data, options, callback);
        }

        _fileIsEmbedded(barPath, (err, fileIsEmbedded) => {
            if (err) {
                return callback(err);
            }

            if (fileIsEmbedded) {
                return brickMapController.embedData(barPath, data, options, callback);
            }

            _ingestData(barPath, data, options, (err, result) => {
                if (err) {
                    return callback(err);
                }
                brickMapController.addFile(barPath, result, callback);

            });
        });
    };

    const _appendToFile = (barPath, data, options, callback) => {
        barPath = pskPth.normalize(barPath);

        if (options.embed) {
            return brickMapController.appendToEmbeddedFile(barPath, data, options, callback);
        }

        _fileIsEmbedded(barPath, (err, fileIsEmbedded) => {
            if (err) {
                return callback(err);
            }

            if (fileIsEmbedded) {
                return brickMapController.appendToEmbeddedFile(barPath, data, options, callback);
            }

            _ingestData(barPath, data, options, (err, result) => {
                if (err) {
                    return callback(err);
                }

                brickMapController.appendToFile(barPath, result, callback);
            });
        });
    };

    /**
     * @param {string} barPath
     * @param {object[]} bricks
     * @param {callback} callback
     */
    const _writeFileFromBricks = (barPath, bricks, callback) => {
        barPath = pskPth.normalize(barPath);
        brickMapController.addFile(barPath, bricks, callback);
    };

    /**
     * @param {sizeSSI} sizeSSI
     */
    const _isAvailableSpaceInLastBrick = (sizeSSI) => {
        if (typeof sizeSSI === "string") {
            const keySSISpace = require("opendsu").loadAPI("keyssi");
            sizeSSI = keySSISpace.parse(sizeSSI);
        }
        const totalSize = sizeSSI.getTotalSize();
        const bufferSize = sizeSSI.getBufferSize();
        return totalSize % bufferSize !== 0;
    };

    /**
     * @param {string} barPath
     * @param {object} newSizeSSI
     * @param {object} brick
     * @param {callback} callback
     */
    const _appendBigFileBrick = (barPath, newSizeSSI, brick, callback) => {
        _getBigFileBricksMeta(barPath, (error, bricksMeta) => {
            if (error) {
                return callback(error);
            }

            if (!_isSizeSSIPresentInBricksMetaAndIsValid(bricksMeta)) {
                return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Provided path ${barPath} is not a BigFile`));
            }

            // check using the current sizeSSI if there is available space inside the last brick
            if (_isAvailableSpaceInLastBrick(bricksMeta[0].size)) {
                return brickMapController.updateBigFileLastBrick(barPath, newSizeSSI, brick, callback);
            }
            return brickMapController.appendBigFile(barPath, newSizeSSI, brick, callback);
        });
    };

    /**
     * @param {string} barPath
     * @param {callback} callback
     */
    const _getBigFileBricksMeta = (barPath, callback) => {
        barPath = pskPth.normalize(barPath);
        try {
            const bricksMeta = brickMapController.getBricksMeta(barPath);
            callback(null, bricksMeta);
        } catch (err) {
            return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper("Failed to find any info for path " + barPath, err));
        }
    };

    /**
     * @param {object} bricksMeta
     */
    const _isSizeSSIPresentInBricksMeta = (bricksMeta) => {
        return !!bricksMeta && !!bricksMeta[0] && !!bricksMeta[0].size;
    }

    const _isSizeSSIValid = (sizeSSI) => {
        try {
            const keySSISpace = require("opendsu").loadAPI("keyssi");
            keySSISpace.parse(sizeSSI);
            return true;
        } catch (error) {
            return false;
        }
    }

    const _isSizeSSIPresentInBricksMetaAndIsValid = (bricksMeta) => {
        if (!_isSizeSSIPresentInBricksMeta(bricksMeta)) {
            return false;
        }

        return _isSizeSSIValid(bricksMeta[0].size);
    }

    /**
     * @param {string} barPath
     * @param {callback} callback
     */
    const _readFile = (barPath, callback) => {
        barPath = pskPth.normalize(barPath);

        let bricksMeta;
        let embeddedData;
        try {
            embeddedData = brickMapController.getEmbeddedFile(barPath);
        } catch (e) {
            return callback(e);
        }

        if (typeof embeddedData !== "undefined") {
            return callback(undefined, embeddedData);
        }

        try {
            bricksMeta = brickMapController.getBricksMeta(barPath);
        } catch (err) {
            return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper("Failed to find any info for path " + barPath + " in brickmap", err));
        }

        if (_isSizeSSIPresentInBricksMeta(bricksMeta)) {
            return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to read big file as normal file for path ${barPath}`));
        }

        brickStorageService.createBufferFromBricks(bricksMeta, (err, buffer) => {
            if (err) {
                return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper("Failed to create buffer from bricks", err));
            }

            callback(undefined, buffer);
        });
    };

    /**
     * @param {string} barPath
     * @param {callback} callback
     */
    const _createReadStream = (barPath, callback) => {
        barPath = pskPth.normalize(barPath);

        let bricksMeta;
        try {
            bricksMeta = brickMapController.getBricksMeta(barPath);
        } catch (err) {
            return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper("Failed to find any info for path " + barPath, err));
        }

        if (_isSizeSSIPresentInBricksMeta(bricksMeta)) {
            return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to read big file as normal file for path ${barPath}`));
        }

        brickStorageService.createStreamFromBricks(bricksMeta, (err, stream) => {
            if (err) {
                return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper("Failed to create stream from bricks", err));
            }

            callback(undefined, stream);
        });
    };

    /**
     * @param {string} barPath
     * @param {callback} callback
     */
    const _createBigFileReadStreamWithRange = (barPath, range, callback) => {
        barPath = pskPth.normalize(barPath);

        let bricksMeta;
        try {
            bricksMeta = brickMapController.getBricksMeta(barPath);
        } catch (err) {
            return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper("Failed to find any info for path " + barPath, err));
        }

        if (!bricksMeta || !bricksMeta.length) {
            return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper("Failed to find any info for path " + barPath, err));
        }

        if (!bricksMeta[0].size) {
            return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Cannot stream path ${barPath} since it's not a BigFile`));
        }

        let sizeSSI;
        try {
            const keySSISpace = require("opendsu").loadAPI("keyssi");
            sizeSSI = keySSISpace.parse(bricksMeta[0].size);
        } catch (e) {
            return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`The provided keyssi is not a valid SSI string.`, e));
        }

        let canCreateStream = !!sizeSSI && !!sizeSSI.isSizeSSI && sizeSSI.isSizeSSI();
        if (!canCreateStream) {
            return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Cannot stream path ${barPath} since it's not a BigFile`));
        }

        bricksMeta = bricksMeta.slice(1); // remove SizeSSI from bricksMeta
        brickStorageService.createStreamFromBricksWithRange(sizeSSI, bricksMeta, range, (err, stream) => {
            if (err) {
                return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper("Failed to create stream from bricks", err));
            }

            callback(undefined, {totalSize: sizeSSI.getTotalSize(), stream});
        });
    };

    /**
     * @param {string} fsFilePath
     * @param {string} barPath
     * @param {object} options
     * @param {callback} callback
     */
    const _addFile = (fsFilePath, barPath, options, callback) => {
        if (typeof options === "function") {
            callback = options;
            options = {
                encrypt: true
            }
        }

        barPath = pskPth.normalize(barPath);

        brickStorageService.ingestFile(fsFilePath, options, (err, result) => {
            if (err) {
                return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper("Failed to ingest data into bricks storage", err));
            }

            brickMapController.addFile(barPath, result, callback);
        })
    };

    /**
     * @param {string} files
     * @param {string} barPath
     * @param {object} options
     * @param {callback} callback
     */
    const _addFiles = (files, barPath, options, callback) => {
        if (typeof options === "function") {
            callback = options;
            options = {
                encrypt: true,
                embedded: false
            };
        }

        barPath = pskPth.normalize(barPath);

        const filesArray = files.slice();

        const ingestionMethod = (!options.embedded) ? 'ingestFiles' : 'createBrickFromFiles';

        brickStorageService[ingestionMethod](filesArray, options, (err, result) => {
            if (err) {
                return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper("Failed to add files at path " + barPath, err));
            }

            brickMapController.addFiles(barPath, result, callback);
        });
    };

    this.addFiles = (files, barPath, options, callback) => {
        waitIfDSUIsRefreshing(() => {
            if (typeof options === "function") {
                callback = options;
                options = {
                    encrypt: true,
                    ignoreMounts: false,
                    embedded: false
                };
            }

            if (options.ignoreMounts === true) {
                _addFiles(files, barPath, options, callback);
            } else {
                this.getArchiveForPath(barPath, (err, dossierContext) => {
                    if (err) {
                        return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to load DSU instance mounted at path ${barPath}`, err));
                    }

                    options.ignoreMounts = true;
                    dossierContext.archive.addFiles(files, dossierContext.relativePath, options, callback);
                });
            }
        })
    }

    /**
     * @param {string} fsFilePath
     * @param {string} barPath
     * @param {callback} callback
     */
    const _extractFile = (fsFilePath, barPath, callback) => {
        if (typeof barPath === "function") {
            callback = barPath;
            barPath = pskPth.normalize(fsFilePath);
        }

        let bricksMeta;

        try {
            bricksMeta = brickMapController.getBricksMeta(barPath);
        } catch (err) {
            return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper("Failed to any information for path " + barPath, err));
        }


        brickStorageService.createFileFromBricks(fsFilePath, bricksMeta, callback);
    };

    /**
     * @param {string} barPath
     * @param {string|$$.Buffer|stream.ReadableStream} data
     * @param {callback} callback
     */
    this.appendToFile = (barPath, data, options, callback) => {
        waitIfDSUIsRefreshing(() => {
            const defaultOpts = {encrypt: true, ignoreMounts: false};
            if (typeof options === "function") {
                callback = options;
                options = {};
            }

            Object.assign(defaultOpts, options);
            options = defaultOpts;

            if (options.ignoreMounts) {
                barPath = pskPth.normalize(barPath);
                _appendToFile(barPath, data, options, callback);
            } else {
                this.getArchiveForPath(barPath, (err, dossierContext) => {
                    if (err) {
                        return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to load DSU instance mounted at path ${barPath}`, err));
                    }
                    if (dossierContext.readonly === true) {
                        return callback(Error("Tried to write in a readonly mounted RawDossier"));
                    }

                    options.ignoreMounts = true;
                    dossierContext.archive.appendToFile(dossierContext.relativePath, data, options, callback);
                });
            }
        })
    };


    this.dsuLog = (message, callback) => {
        waitIfDSUIsRefreshing(() => {
            this.appendToFile("/dsu-metadata-log", message + "\n", {ignoreMissing: true}, callback);
        })
    }
    /**
     * @param {string} fsFolderPath
     * @param {string} barPath
     * @param {object} options
     * @param {callback} callback
     */
    const _addFolder = (fsFolderPath, barPath, options, callback) => {
        if (typeof options === "function") {
            callback = options;
            options = {
                encrypt: true,
                embedded: false
            };
        }
        barPath = pskPth.normalize(barPath);

        const ingestionMethod = (!options.embedded) ? 'ingestFolder' : 'createBrickFromFolder';

        brickStorageService[ingestionMethod](fsFolderPath, options, (err, result) => {
            if (err) {
                return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to add folder ${fsFolderPath} to  ${barPath}`, err));
            }

            brickMapController.addFiles(barPath, result, callback);
        });
    };

    /**
     * @param {string} fsFolderPath
     * @param {string} barPath
     * @param {callback} callback
     */
    const _extractFolder = (fsFolderPath, barPath, callback) => {
        if (typeof barPath === "function") {
            callback = barPath;
            barPath = pskPth.normalize(fsFolderPath);
        }

        const filePaths = brickMapController.getFileList(barPath);
        const taskCounter = new TaskCounter(() => {
            callback();
        });
        taskCounter.increment(filePaths.length);
        filePaths.forEach(filePath => {
            let actualPath;
            if (fsFolderPath) {
                if (fsFolderPath.includes(filePath)) {
                    actualPath = fsFolderPath;
                } else {
                    actualPath = require("path").join(fsFolderPath, filePath);
                }
            } else {
                actualPath = filePath;
            }

            this.extractFile(actualPath, filePath, (err) => {
                if (err) {
                    return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to extract file ${actualPath} to ${filePath}`, err));
                }

                taskCounter.decrement();
            });
        });
    };

    /**
     * @param {string} barPath
     * @param {callback} callback
     */
    const _delete = (barPath, callback) => {
        brickMapController.deleteFile(barPath, callback);
        //this resets the state in case a folder gets removed and under the same path are other dsu mounted.
        manifestHandler = undefined;
    };

    /**
     * @param {string} srcPath
     * @param {dstPath} dstPath
     */

    const _rename = (srcPath, dstPath, callback) => {
        srcPath = pskPth.normalize(srcPath);
        dstPath = pskPth.normalize(dstPath);

        brickMapController.renameFile(srcPath, dstPath, callback);
    }

    /**
     * @param {string} folderBarPath
     * @param {object} options
     * @param {callback} callback
     */
    const _listFiles = (folderBarPath, options, callback) => {
        if (typeof options === "function") {
            callback = options;
            options = {recursive: true};
        } else if (typeof folderBarPath === "function") {
            callback = folderBarPath;
            options = {recursive: true};
            folderBarPath = "/";
        }

        let fileList;
        let error;
        try {
            fileList = brickMapController.getFileList(folderBarPath, options.recursive);
        } catch (e) {
            error = e;
        }

        setTimeout(() => {
            callback(error, fileList);
        }, 0)
    };

    const _listMountedFiles = (mountPoints, result, callback) => {
        if (typeof result === 'function') {
            callback = result;
            result = [];
        }
        let mountPoint = mountPoints.shift();

        if (!mountPoint) {
            return callback(undefined, result)
        }

        mountPoint = pskPth.normalize(mountPoint);

        this.listFiles(mountPoint, {
            recursive: true,
            ignoreMounts: false
        }, (err, files) => {
            if (err) {
                return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to list files at path ${mountPoint}`, err));
            }

            result.push(files.map((file) => {
                let prefix = mountPoint;
                if (prefix[0] === '/') {
                    prefix = prefix.substring(1);
                }

                return pskPth.normalize(`${prefix}/${file}`);
            }));

            _listMountedFiles(mountPoints, result, callback);
        });
    };

    /**
     * @param {string} folderBarPath
     * @param {object} options
     * @param {boolean} options.recursive
     * @param {callback} callback
     */
    const _listFolders = (folderBarPath, options, callback) => {
        if (typeof options === "function") {
            callback = options;
            options = {recursive: true};
        }

        callback(undefined, brickMapController.getFolderList(folderBarPath, options.recursive));
    };

    const _listMountedFolders = (mountPoints, result, callback) => {
        if (typeof result === 'function') {
            callback = result;
            result = [];
        }

        let mountPoint = mountPoints.shift();
        if (!mountPoint) {
            return callback(undefined, result);
        }

        mountPoint = pskPth.normalize(mountPoint);

        this.listFolders(mountPoint, {
            recursive: true,
            ignoreMounts: false
        }, (err, folders) => {
            if (err) {
                return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to list mounted folders at path ${mountPoint}`, err));
            }

            result.push((folders.map((folder) => {
                let prefix = mountPoint;
                if (prefix[0] === '/') {
                    prefix = prefix.substring(1);
                }

                return pskPth.normalize(`${prefix}/${folder}`);
            })));

            _listMountedFolders(mountPoints, result, callback);
        })
    };

    /**
     * @param {string} barPath
     * @param {callback} callback
     */
    const _createFolder = (barPath, callback) => {
        brickMapController.createDirectory(barPath, callback);
    };

    const _createFile = (barPath, callback) => {
        brickMapController.createEmptyFile(barPath, callback);
    };

    /**
     * @param {object} rules
     * @param {object} rules.preWrite
     * @param {object} rules.afterLoad
     */
    this.setValidationRules = (rules) => {
        brickMapController.setValidationRules(rules);
    }

    /**
     * @param {callback} listener
     */
    this.setAnchoringEventListener = (listener) => {
        this.getAnchoringStrategy().setAnchoringEventListener(listener);
    }

    /**
     * @param {callback} callback
     */
    this.setDecisionCallback = (callback) => {
        this.getAnchoringStrategy().setDecisionCallback(callback);
    }

    /**
     * @return {AnchoringStrategy}
     */
    this.getAnchoringStrategy = () => {
        return archiveConfigurator.getBrickMapStrategy();
    }

    /**
     * Manually anchor any changes
     */
    this.doAnchoring = (callback) => {
        const strategy = this.getAnchoringStrategy();
        const anchoringEventListener = strategy.getAnchoringEventListener() || callback;
        if (typeof anchoringEventListener !== 'function') {
            throw new Error('An anchoring event listener is required');
        }

        brickMapController.anchorChanges(anchoringEventListener);
    }

    const getManifest = (callback) => {
        if (typeof manifestHandler === "undefined") {
            const options = {
                skipCache: archiveConfigurator.dsuCachingEnabled()
            };
            Manifest.getManifest(this, options, (err, handler) => {
                if (err) {
                    return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to get manifest handler`, err));
                }

                manifestHandler = handler;
                return callback(undefined, manifestHandler);
            });
        } else {
            return callback(undefined, manifestHandler);
        }
    }

    this.getSSIForMount = (mountPoint, callback) => {
        getManifest((err, manifestHandler) => {
            if (err) {
                return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper("Failed to load manifest for " + mountPoint, err));
            }
            manifestHandler.getArchiveIdentifier(mountPoint, callback);
        });
    }

    this.addFolder = (fsFolderPath, barPath, options, callback) => {
        waitIfDSUIsRefreshing(() => {
            const defaultOpts = {encrypt: true, ignoreMounts: false, embedded: false};
            if (typeof options === "function") {
                callback = options;
                options = {};
            }
            callback = $$.makeSaneCallback(callback);
            Object.assign(defaultOpts, options);
            options = defaultOpts;


            if (options.ignoreMounts === true) {
                _addFolder(fsFolderPath, barPath, options, callback);
            } else {
                this.getArchiveForPath(barPath, (err, result) => {
                    if (err) {
                        return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to load DSU instance mounted at path ${barPath}`, err));
                    }

                    options.ignoreMounts = true;
                    result.archive.addFolder(fsFolderPath, result.relativePath, options, callback);
                });
            }

        })
    };

    this.addFile = (fsFilePath, barPath, options, callback) => {
        waitIfDSUIsRefreshing(() => {
            const defaultOpts = {encrypt: true, ignoreMounts: false};
            if (typeof options === "function") {
                callback = options;
                options = {};
            }

            callback = $$.makeSaneCallback(callback);
            Object.assign(defaultOpts, options);
            options = defaultOpts;

            if (options.ignoreMounts === true) {
                _addFile(fsFilePath, barPath, options, callback);
            } else {
                this.getArchiveForPath(barPath, (err, result) => {
                    if (err) {
                        return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to load DSU instance mounted at path ${barPath}`, err));
                    }

                    options.ignoreMounts = true;
                    result.archive.addFile(fsFilePath, result.relativePath, options, callback);
                });
            }
        })
    };

    this.readFile = (fileBarPath, options, callback) => {
        waitIfDSUIsRefreshing(() => {
            const defaultOpts = {ignoreMounts: false};
            if (typeof options === "function") {
                callback = options;
                options = {};
            }

            callback = $$.makeSaneCallback(callback);
            Object.assign(defaultOpts, options);
            options = defaultOpts;
            if (options.ignoreMounts === true) {
                _readFile(fileBarPath, callback);
            } else {
                this.getArchiveForPath(fileBarPath, (err, result) => {
                    if (err) {
                        return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to load DSU instance mounted at path ${fileBarPath}`, err));
                    }

                    options.ignoreMounts = true
                    result.archive.readFile(result.relativePath, options, callback);
                });
            }
        })
    };

    this.createReadStream = (fileBarPath, options, callback) => {
        waitIfDSUIsRefreshing(() => {
            const defaultOpts = {encrypt: true, ignoreMounts: false};
            if (typeof options === "function") {
                callback = options;
                options = {};
            }

            callback = $$.makeSaneCallback(callback);
            Object.assign(defaultOpts, options);
            options = defaultOpts;
            if (options.ignoreMounts === true) {
                _createReadStream(fileBarPath, callback);
            } else {
                this.getArchiveForPath(fileBarPath, (err, result) => {
                    if (err) {
                        return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to load DSU instance mounted at path ${fileBarPath}`, err));
                    }

                    options.ignoreMounts = true;
                    result.archive.createReadStream(result.relativePath, options, callback);
                });
            }
        })
    };

    this.createBigFileReadStreamWithRange = (fileBarPath, range, options, callback) => {
        waitIfDSUIsRefreshing(() => {
            const defaultOpts = {encrypt: true, ignoreMounts: false};
            if (typeof options === "function") {
                callback = options;
                options = {};
            }
            if (typeof range === "function") {
                callback = range;
                range = {start: 0};
                options = {};
            }

            callback = $$.makeSaneCallback(callback);
            Object.assign(defaultOpts, options);
            options = defaultOpts;
            if (options.ignoreMounts === true) {
                _createBigFileReadStreamWithRange(fileBarPath, range, callback);
            } else {
                this.getArchiveForPath(fileBarPath, (err, result) => {
                    if (err) {
                        return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to load DSU instance mounted at path ${fileBarPath}`, err));
                    }

                    options.ignoreMounts = true;
                    result.archive.createBigFileReadStreamWithRange(result.relativePath, range, options, callback);
                });
            }
        })
    };

    this.extractFolder = (fsFolderPath, barPath, options, callback) => {
        waitIfDSUIsRefreshing(() => {
            const defaultOpts = {ignoreMounts: false};
            if (typeof options === "function") {
                callback = options;
                options = {};
            }

            callback = $$.makeSaneCallback(callback);
            Object.assign(defaultOpts, options);
            options = defaultOpts;
            if (options.ignoreMounts === true) {
                _extractFolder(fsFolderPath, barPath, callback);
            } else {
                this.getArchiveForPath(barPath, (err, result) => {
                    if (err) {
                        return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to load DSU instance mounted at path ${barPath}`, err));
                    }

                    options.ignoreMounts = true;
                    result.archive.extractFolder(fsFolderPath, result.relativePath, options, callback);
                });
            }
        })
    };

    this.extractFile = (fsFilePath, barPath, options, callback) => {
        waitIfDSUIsRefreshing(() => {
            const defaultOpts = {ignoreMounts: false};
            if (typeof options === "function") {
                callback = options;
                options = {};
            }

            callback = $$.makeSaneCallback(callback);
            Object.assign(defaultOpts, options);
            options = defaultOpts;

            if (options.ignoreMounts === true) {
                _extractFile(fsFilePath, barPath, callback);
            } else {
                this.getArchiveForPath(barPath, (err, result) => {
                    if (err) {
                        return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to load DSU instance mounted at path ${barPath}`, err));
                    }

                    options.ignoreMounts = true;
                    result.archive.extractFile(fsFilePath, result.relativePath, options, callback);
                });
            }
        })
    };

    this.writeFile = (path, data, options, callback) => {
        waitIfDSUIsRefreshing(() => {
            const defaultOpts = {encrypt: true, ignoreMounts: false, embed: false};
            if (typeof data === "function") {
                callback = data;
                data = undefined;
                options = undefined;
            }
            if (typeof options === "function") {
                callback = options;
                options = defaultOpts;
            }
            if (typeof options === "undefined") {
                options = defaultOpts;
            }

            callback = $$.makeSaneCallback(callback);

            Object.assign(defaultOpts, options);
            options = defaultOpts;
            if (options.embed) {
                options.encrypt = false;
            }

            if (options.ignoreMounts === true) {
                _writeFile(path, data, options, callback);
            } else {
                this.getArchiveForPath(path, (err, dossierContext) => {
                    if (err) {
                        return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to load DSU instance mounted at path ${path}`, err));
                    }
                    if (dossierContext.readonly === true) {
                        return callback(Error("Tried to write in a readonly mounted RawDossier"));
                    }

                    options.ignoreMounts = true;
                    dossierContext.archive.writeFile(dossierContext.relativePath, data, options, callback);
                });
            }
        })
    };

    this.embedFile = (path, data, options, callback) => {
        waitIfDSUIsRefreshing(() => {
            const defaultOpts = {encrypt: true, ignoreMounts: false};
            if (typeof data === "function") {
                callback = data;
                data = undefined;
                options = undefined;
            }
            if (typeof options === "function") {
                callback = options;
                options = {
                    encrypt: true
                };
            }
            if (typeof options === "undefined") {
                options = {
                    encrypt: true
                };
            }

            callback = $$.makeSaneCallback(callback);

            Object.assign(defaultOpts, options);
            options = defaultOpts;

            if (options.ignoreMounts === true) {
                _embedFile(path, data, options, callback);
            } else {
                this.getArchiveForPath(path, (err, dossierContext) => {
                    if (err) {
                        return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to load DSU instance mounted at path ${path}`, err));
                    }
                    if (dossierContext.readonly === true) {
                        return callback(Error("Tried to write in a readonly mounted RawDossier"));
                    }

                    options.ignoreMounts = true;
                    dossierContext.archive.embedFile(dossierContext.relativePath, data, options, callback);
                });
            }
        })
    };

    this.writeFileFromBricks = (path, bricks, options, callback) => {
        waitIfDSUIsRefreshing(() => {
            const defaultOpts = {ignoreMounts: false};
            if (typeof options === "function") {
                callback = options;
                options = {};
            }
            if (typeof options === "undefined") {
                options = {};
            }

            callback = $$.makeSaneCallback(callback);
            if (typeof path !== "string") {
                return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper("Provided path for writeFileFromBricks must be a string"));
            }
            if (!Array.isArray(bricks) || !_isSizeSSIPresentInBricksMetaAndIsValid(bricks)) {
                return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper("Provided bricks for writeFileFromBricks must be an array of a single sizeSSI and multiple hashlinks"));
            }

            Object.assign(defaultOpts, options);
            options = defaultOpts;

            if (options.ignoreMounts === true) {
                _writeFileFromBricks(path, bricks, callback);
            } else {
                this.getArchiveForPath(path, (err, dossierContext) => {
                    if (err) {
                        return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to load DSU instance mounted at path ${path}`, err));
                    }
                    if (dossierContext.readonly === true) {
                        return callback(Error("Tried to write in a readonly mounted RawDossier"));
                    }

                    options.ignoreMounts = true;
                    dossierContext.archive.writeFileFromBricks(dossierContext.relativePath, bricks, options, callback);
                });
            }
        });
    }

    this.appendBigFileBrick = (path, newSizeSSI, brick, options, callback) => {
        waitIfDSUIsRefreshing(() => {
            const defaultOpts = {ignoreMounts: false};
            if (typeof options === "function") {
                callback = options;
                options = {};
            }
            if (typeof options === "undefined") {
                options = {};
            }

            callback = $$.makeSaneCallback(callback);
            if (typeof path !== "string") {
                return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper("Provided path for appendBigFileBrick must be a string"));
            }
            if (!newSizeSSI || !_isSizeSSIValid(newSizeSSI)) {
                return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper("Provided newSizeSSI is not a valid sizeSSI"));
            }

            Object.assign(defaultOpts, options);
            options = defaultOpts;

            if (options.ignoreMounts === true) {
                _appendBigFileBrick(path, newSizeSSI, brick, callback);
            } else {
                this.getArchiveForPath(path, (err, dossierContext) => {
                    if (err) {
                        return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to load DSU instance mounted at path ${path}`, err));
                    }
                    if (dossierContext.readonly === true) {
                        return callback(Error("Tried to write in a readonly mounted RawDossier"));
                    }

                    options.ignoreMounts = true;
                    dossierContext.archive.appendBigFileBrick(dossierContext.relativePath, newSizeSSI, brick, options, callback);
                });
            }
        });
    }

    this.getBigFileBricksMeta = (path, options, callback) => {
        waitIfDSUIsRefreshing(() => {
            const defaultOpts = {ignoreMounts: false};
            if (typeof options === "function") {
                callback = options;
                options = {};
            }
            if (typeof options === "undefined") {
                options = {};
            }

            callback = $$.makeSaneCallback(callback);
            if (typeof path !== "string") {
                return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper("Provided path for writeFileFromBricks must be a string"));
            }

            Object.assign(defaultOpts, options);
            options = defaultOpts;

            if (options.ignoreMounts === true) {
                _getBigFileBricksMeta(path, callback);
            } else {
                this.getArchiveForPath(path, (err, dossierContext) => {
                    if (err) {
                        return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to load DSU instance mounted at path ${path}`, err));
                    }
                    if (dossierContext.readonly === true) {
                        return callback(Error("Tried to write in a readonly mounted RawDossier"));
                    }

                    options.ignoreMounts = true;
                    dossierContext.archive.getBigFileBricksMeta(dossierContext.relativePath, options, callback);
                });
            }
        });
    }

    this.delete = (path, options, callback) => {
        waitIfDSUIsRefreshing(() => {
            const defaultOpts = {ignoreMounts: false, ignoreError: false};
            if (typeof options === 'function') {
                callback = options;
                options = {};
            }
            callback = $$.makeSaneCallback(callback);

            Object.assign(defaultOpts, options);
            options = defaultOpts;

            if (options.ignoreMounts) {
                return _delete(path, err => {
                    if (!err || (err && options.ignoreError)) {
                        return callback();
                    }

                    callback(err);
                });
            }

            this.getArchiveForPath(path, (err, dossierContext) => {
                if (err) {
                    return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to load DSU instance mounted at path ${path}`, err));
                }

                if (dossierContext.readonly === true) {
                    return callback(Error("Tried to delete in a readonly mounted RawDossier"));
                }

                options.ignoreMounts = true;
                dossierContext.archive.delete(dossierContext.relativePath, options, callback);
            });
        })
    };

    this.rename = (srcPath, dstPath, options, callback) => {
        waitIfDSUIsRefreshing(() => {
            const defaultOpts = {ignoreMounts: false};
            if (typeof options === 'function') {
                callback = options;
                options = {};
            }

            callback = $$.makeSaneCallback(callback);
            Object.assign(defaultOpts, options);
            options = defaultOpts;

            if (options.ignoreMounts) {
                _rename(srcPath, dstPath, callback);
                return;
            }

            this.getArchiveForPath(srcPath, (err, dossierContext) => {
                if (err) {
                    return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to load DSU instance mounted at path ${srcPath}`, err));
                }
                if (dossierContext.readonly === true) {
                    return callback(Error("Tried to rename in a readonly mounted RawDossier"));
                }

                const relativeSrcPath = dossierContext.relativePath;
                this.getArchiveForPath(dstPath, (err, dstDossierContext) => {
                    if (err) {
                        return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to load DSU instance mounted at path ${dstPath}`, err));
                    }

                    if (dstDossierContext.prefixPath !== dossierContext.prefixPath) {
                        return callback(Error('Destination is invalid. Renaming must be done in the scope of the same dossier'));
                    }

                    options.ignoreMounts = true;
                    dossierContext.archive.rename(relativeSrcPath, dstDossierContext.relativePath, options, callback);
                })
            });
        })
    };

    this.listFiles = (path, options, callback) => {
        waitIfDSUIsRefreshing(() => {
            const defaultOpts = {ignoreMounts: false, recursive: true};
            if (typeof options === 'function') {
                callback = options;
                options = {};
            }

            callback = $$.makeSaneCallback(callback);
            Object.assign(defaultOpts, options);
            options = defaultOpts;
            if (options.ignoreMounts === true) {
                if (!options.recursive) {
                    return _listFiles(path, options, callback);
                }

                return _listFiles(path, options, (err, files) => {
                    if (err) {
                        return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to list files at path ${path}`, err));
                    }

                    getManifest((err, manifest) => {
                        if (err) {
                            return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to get manifest`, err));
                        }

                        const mountPoints = manifest.getMountPoints();
                        if (!mountPoints.length) {
                            return callback(undefined, files);
                        }

                        _listMountedFiles(mountPoints, (err, mountedFiles) => {
                            if (err) {
                                return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to list mounted files at mountPoints ${mountPoints}`, err));
                            }

                            files = files.concat(...mountedFiles);
                            return callback(undefined, files);
                        });
                    })
                })
            }

            this.getArchiveForPath(path, (err, result) => {
                if (err) {
                    return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to load DSU instance mounted at path ${path}`, err));
                }

                options.ignoreMounts = true;
                result.archive.listFiles(result.relativePath, options, callback);
            });
        })
    };

    this.listFolders = (path, options, callback) => {
        waitIfDSUIsRefreshing(() => {
            const defaultOpts = {ignoreMounts: false, recursive: false};
            if (typeof options === 'function') {
                callback = options;
                options = {};
            }

            callback = $$.makeSaneCallback(callback);
            Object.assign(defaultOpts, options);
            options = defaultOpts;

            if (options.ignoreMounts === true) {
                if (!options.recursive) {
                    return _listFolders(path, options, callback);
                }

                return _listFolders(path, options, (err, folders) => {
                    if (err) {
                        return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to list folders at path ${path}`, err));
                    }

                    getManifest((err, manifest) => {
                        if (err) {
                            return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to get manifest`, err));
                        }

                        const mountPoints = manifest.getMountPoints();
                        if (!mountPoints.length) {
                            return callback(undefined, folders);
                        }

                        _listMountedFolders(mountPoints, (err, mountedFolders) => {
                            if (err) {
                                return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to list mounted folders at mountPoints ${mountPoints}`, err));
                            }

                            folders = folders.concat(...mountedFolders);
                            return callback(undefined, folders);
                        });
                    })
                })
            }

            this.getArchiveForPath(path, (err, result) => {
                if (err) {
                    return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to load DSU instance mounted at path ${path}`, err));
                }

                options.ignoreMounts = true;
                result.archive.listFolders(result.relativePath, options, callback);
            });
        })
    };

    this.createFolder = (barPath, options, callback) => {
        waitIfDSUIsRefreshing(() => {
            const defaultOpts = {ignoreMounts: false, encrypt: true};
            if (typeof options === "function") {
                callback = options;
                options = {};
            }

            callback = $$.makeSaneCallback(callback);
            Object.assign(defaultOpts, options);
            options = defaultOpts;

            if (options.ignoreMounts === true) {
                _createFolder(barPath, callback);
            } else {
                this.getArchiveForPath(barPath, (err, dossierContext) => {
                    if (err) {
                        return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to load DSU instance mounted at path ${barPath}`, err));
                    }
                    if (dossierContext.readonly === true) {
                        return callback(Error("Tried to write in a readonly mounted RawDossier"));
                    }

                    options.ignoreMounts = true;
                    dossierContext.archive.createFolder(dossierContext.relativePath, options, callback);
                });
            }
        })
    };

    this.readDir = (folderPath, options, callback) => {
        waitIfDSUIsRefreshing(() => {
            if (typeof options === "function") {
                callback = options;
                options = {
                    withFileTypes: false
                };
            }

            callback = $$.makeSaneCallback(callback);
            const entries = {};
            this.getArchiveForPath(folderPath, (err, result) => {
                if (err) {
                    return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to load DSU instance mounted at path ${folderPath}`, err));
                }

                result.archive.listFiles(result.relativePath, {recursive: false, ignoreMounts: true}, (err, files) => {
                    if (err) {
                        return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to list files at path ${result.relativePath}`, err));
                    }

                    entries.files = files;

                    result.archive.listFolders(result.relativePath, {
                        recursive: false,
                        ignoreMounts: true
                    }, (err, folders) => {
                        if (err) {
                            return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to list folders at path ${result.relativePath}`, err));
                        }

                        if (options.withFileTypes) {
                            entries.folders = folders;
                        } else {
                            entries.files = [...entries.files, ...folders];
                        }
                        if (result.archive === this) {
                            getManifest(listMounts);
                        } else {
                            Manifest.getManifest(result.archive, listMounts);
                        }

                        function listMounts(err, handler) {
                            if (err) {
                                return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to list mounts`, err));
                            }

                            handler.getMountedDossiers(result.relativePath, (err, mounts) => {
                                if (err) {
                                    return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to get mounted DSUs at path ${result.relativePath}`, err));
                                }
                                let mountPaths = mounts.map(mount => mount.path);
                                let folders = mountPaths.filter(mountPath => mountPath.split('/').length >= 2);
                                folders = folders.map(mountPath => mountPath.split('/').shift());
                                let mountedDossiers = mountPaths.filter(mountPath => mountPath.split('/').length === 1);
                                mountedDossiers = mountedDossiers.map(mountPath => mountPath.split('/').shift());
                                if (options.withFileTypes) {
                                    entries.mounts = mountedDossiers;
                                    entries.folders = Array.from(new Set([...entries.folders, ...folders]));
                                    entries.mounts = entries.mounts.filter(mount => entries.folders.indexOf(mount) === -1);
                                    return callback(undefined, entries);
                                }
                                entries.files = Array.from(new Set([...entries.files, ...mounts, ...folders]));
                                return callback(undefined, entries.files);
                            });
                        }
                    });
                });
            });
        })
    };

    this.cloneFolder = (srcPath, destPath, options, callback) => {
        waitIfDSUIsRefreshing(() => {
            const defaultOpts = {ignoreMounts: false};
            if (typeof options === 'function') {
                callback = options;
                options = {};
            }

            callback = $$.makeSaneCallback(callback);
            Object.assign(defaultOpts, options);
            options = defaultOpts;

            if (options.ignoreMounts) {
                brickMapController.cloneFolder(srcPath, destPath, callback);
                return;
            }

            this.getArchiveForPath(srcPath, (err, dossierContext) => {
                if (err) {
                    return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to load DSU instance mounted at path ${srcPath}`, err));
                }
                if (dossierContext.readonly === true) {
                    return callback(Error("Tried to rename in a readonly mounted RawDossier"));
                }

                this.getArchiveForPath(destPath, (err, dstDossierContext) => {
                    if (err) {
                        return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to load DSU instance mounted at path ${dstPath}`, err));
                    }

                    if (dstDossierContext.prefixPath !== dossierContext.prefixPath) {
                        return callback(Error('Destination is invalid. Renaming must be done in the scope of the same dossier'));
                    }

                    options.ignoreMounts = true;
                    dossierContext.archive.cloneFolder(dossierContext.relativePath, dstDossierContext.relativePath, options, callback);
                })
            });
        })
    }

    this.mount = (path, archiveSSI, options, callback) => {
        waitIfDSUIsRefreshing(() => {
            if (typeof options === "function") {
                callback = options;
                options = undefined;
            }

            callback = $$.makeSaneCallback(callback);

            const keySSISpace = require("opendsu").loadAPI("keyssi");

            if (typeof archiveSSI === "string") {
                try {
                    archiveSSI = keySSISpace.parse(archiveSSI);
                } catch (e) {
                    return callback(createOpenDSUErrorWrapper(`The provided archiveSSI is not a valid SSI string.`, e));
                }
            }

            if (typeof archiveSSI === "object") {
                try {
                    archiveSSI = archiveSSI.getIdentifier();
                } catch (e) {
                    return callback(createOpenDSUErrorWrapper(`The provided archiveSSI is not a valid SSI instance`));
                }
            } else {
                return callback(createOpenDSUErrorWrapper(`The provided archiveSSI is neither a string nor a valid SSI instance`));
            }

            function internalMount() {
                _listFiles(path, (err, files) => {
                    if (!err && files.length > 0) {
                        return callback(Error("Tried to mount in a non-empty folder"));
                    }
                    getManifest((err, manifestHandler) => {
                        if (err) {
                            return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to get manifest handler`, err));
                        }

                        manifestHandler.mount(path, archiveSSI, options, callback);
                    });
                });
            }

            this.getArchiveForPath(path, (err, result) => {
                if (err) {
                    return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to load DSU instance mounted at path ${path}`, err));
                }
                if (result.relativePath === path) {
                    internalMount()
                } else {
                    result.archive.mount(result.relativePath, archiveSSI, options, callback)
                }
            });
        })
    };

    this.unmount = (path, callback) => {
        waitIfDSUIsRefreshing(() => {
            callback = $$.makeSaneCallback(callback);

            getManifest((err, manifestHandler) => {
                if (err) {
                    return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to get manifest handler`, err));
                }

                manifestHandler.unmount(path, callback);
            });
        })
    };

    this.listMountedDossiers = (path, callback) => {
        waitIfDSUIsRefreshing(() => {
            callback = $$.makeSaneCallback(callback);

            this.getArchiveForPath(path, (err, result) => {
                if (err) {
                    return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to load DSU instance mounted at path ${path}`, err));
                }

                if (result.archive === this) {
                    getManifest(listMounts);
                } else {
                    Manifest.getManifest(result.archive, listMounts);
                }

                function listMounts(err, handler) {
                    if (err) {
                        return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to list mounts`, err));
                    }

                    handler.getMountedDossiers(result.relativePath, callback);
                }
            });
        })
    };

    this.listMountedDSUs = this.listMountedDossiers;

    this.hasUnanchoredChanges = (callback) => {
        const detectChangesInMountedDSU = (callback, changesExist = false, dsuIndex = 0) => {
            if (dsuIndex >= mountedArchivesForBatchOperations.length) {
                return callback(undefined, changesExist);
            }

            const context = mountedArchivesForBatchOperations[dsuIndex++];
            context.archive.hasUnanchoredChanges((err, result) => {
                if (err) {
                    return callback(err);
                }

                detectChangesInMountedDSU(callback, result || changesExist, dsuIndex);
            })
        }

        waitIfDSUIsRefreshing(() => {
            detectChangesInMountedDSU((err, changesExist) => {
                if (err) {
                    return callback(err);
                }

                callback(undefined, brickMapController.hasUnanchoredChanges() || changesExist);
            })
        });
    };

    this.getArchiveForPath = (path, callback) => {
        waitIfDSUIsRefreshing(() => {
            callback = $$.makeSaneCallback(callback);

            getManifest((err, handler) => {
                if (err) {
                    return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to get manifest handler`, err));
                }

                if (this.batchInProgress()) {
                    return getArchiveForBatchOperations(handler, path, callback);
                }


                handler.getArchiveForPath(path, (err, result) => {
                    if (err) {
                        return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to load DSU instance mounted at path ${path}`, err));
                    }


                    if (result.archive === this || (!publishAnchoringNotifications || publishOptions.ignoreMounts)) {
                        return callback(undefined, result);
                    }

                    result.archive.enableAnchoringNotifications(publishAnchoringNotifications, publishOptions, (err) => {
                        if (err) {
                            return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to toggle anchoring notification publishing for mount point: ${mountPoint}`, err));
                        }

                        callback(undefined, result);
                    })
                });
            });
        })
    };

    /**
     * Start a batch of operations
     * This will force the anchoring when the
     * batch is commited
     */
    this.beginBatch = () => {
        if (batchOperationsInProgress) {
            throw new Error("Another anchoring transaction is already in progress. Cancel the previous batch and try again.");
        }

        batchOperationsInProgress = true;

        // Save the previous decision function
        const anchoringStrategy = this.getAnchoringStrategy();
        prevAnchoringDecisionFn = anchoringStrategy.getDecisionFunction();

        // Prevent anchoring after each operation
        anchoringStrategy.setDecisionFunction((brickMap, callback) => {
            return callback(undefined, false);
        })
    };

    /**
     * @return {boolean}
     */
    this.batchInProgress = () => {
        return batchOperationsInProgress;
    }

    /**
     * Anchor batch of changes
     * @param {callback} onConflict If defined it will be called if a conflict occurs
     * @param {callback} callback
     */
    this.commitBatch = (onConflict, callback) => {
        if (typeof callback === 'undefined') {
            callback = onConflict;
            onConflict = undefined;
        }
        if (!batchOperationsInProgress) {
            return callback(new Error("No batch operations have been scheduled"))
        }

        let usesOnConflictCallback = false;

        const anchoringStrategy = this.getAnchoringStrategy();
        if (!anchoringStrategy.getConflictResolutionFunction() && typeof onConflict !== 'undefined') {
            prevConflictResolutionFunction = anchoringStrategy.getConflictResolutionFunction();
            // Set 'onConflict' callback
            anchoringStrategy.setConflictResolutionFunction(onConflict);
            usesOnConflictCallback = true;
        }

        commitBatchesInMountedArchives(onConflict, (err) => {
            if (err) {
                batchOperationsInProgress = false;
                return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to anchor`, err));
            }

            this.doAnchoring((err, result) => {
                anchoringStrategy.setDecisionFunction(prevAnchoringDecisionFn);
                if (usesOnConflictCallback) {
                    // Restore the 'conflictResolutionFn'
                    anchoringStrategy.setConflictResolutionFunction(prevConflictResolutionFunction);
                }

                if (err) {
                    batchOperationsInProgress = false;
                    return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to anchor`, err));
                }

                batchOperationsInProgress = false;
                callback(undefined, result);
                // this.refresh((err) => {
                //     batchOperationsInProgress = false;
                //
                //     if (err) {
                //         return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to reload current DSU`, err));
                //     }
                //     callback(undefined, result);
                // })
            });
        });
    };

    /**
     * Cancel the current anchoring batch
     */
    this.cancelBatch = (callback) => {
        if (!batchOperationsInProgress) {
            return callback(new Error("No batch operations have been scheduled"))
        }

        cancelBatchesInMountedArchives((err) => {
            if (err) {
                return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to cancel batches in mounted archive`, err));
            }

            batchOperationsInProgress = false;
            this.getAnchoringStrategy().setDecisionFunction(prevAnchoringDecisionFn);
            this.load((err) => {
                if (err) {
                    return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to load current DSU`, err));
                }
                callback();
            })
        });
    };

    /**
     * Execute a batch of operations
     * then anchor the changes
     *
     * @param {function} batch
     * @param {callback} callback
     */
    this.batch = (batch, callback) => {
        this.beginBatch();
        batch((err) => {
            if (err) {
                return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to execute batch operations`, err));
            }

            this.commitBatch(callback);
        });
    }

    /**
     * @param {function} handler
     */
    this.setMergeConflictsHandler = (handler) => {
        this.getAnchoringStrategy().setConflictResolutionFunction(handler);
    }

    /**
     * Toggle notifications publishing for new anchors
     *
     * @param {boolean} status When `true` the DSU will publish a notification
     *                         after each successful anchoring
     * @param {object} options
     * @param {boolean} options.ignoreMounts Default `true`. If `false` enable publishing for all mount points
     * @param {function} callback
     */
    this.enableAnchoringNotifications = (status, options, callback) => {
        if (status === brickMapController.anchoringNotificationsEnabled()) {
            return callback();
        }
        options = options || {};

        if (typeof options === 'function') {
            callback = options;
            options = {};
        }

        const defaultOptions = {
            ignoreMounts: true
        };
        options = {
            ...defaultOptions,
            ...options
        };

        const prevOptions = publishOptions;

        publishAnchoringNotifications = status;
        publishOptions = (status) ? options : null;

        if (publishAnchoringNotifications && options.ignoreMounts) {
            // No need to recurse in mount points
            brickMapController.enableAnchoringNotifications(status);
            return callback();
        }

        // If the notificatios were enabled with ignoring mount
        // points there's no need to recurse in the mounted archives
        if (!status && (!prevOptions || prevOptions.ignoreMounts)) {
            brickMapController.enableAnchoringNotifications(status);
            return callback();
        }

        let mountPoints = [];

        // Recurse in all mount points and set the anchoring notifications settings
        const propagateNotificationSettings = (manifest, callback) => {
            if (!mountPoints.length) {
                return callback();
            }

            const mountPoint = mountPoints.pop();

            manifest.getArchiveForPath(mountPoint, (err, result) => {
                if (err) {
                    return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to load DSU instance mounted at path ${mountPoint}`, err));
                }

                result.archive.enableAnchoringNotifications(publishAnchoringNotifications, publishOptions, (err) => {
                    if (err) {
                        return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to toggle anchoring notification publishing for mount point: ${mountPoint}`, err));
                    }

                    propagateNotificationSettings(manifest, callback);
                })
            });
        }

        getManifest((err, manifest) => {
            if (err) {
                return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to get manifest handler`, err));
            }

            mountPoints = manifest.getMountPoints();

            propagateNotificationSettings(manifest, (err) => {
                if (err) {
                    return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper("Unable to toggle anchoring notifications publishing for mounted DSUs", err));
                }

                brickMapController.enableAnchoringNotifications(status);
                callback();
            })
        });
    }

    /**
     * Toggle subscribing to anchor notifications
     * and auto merging upstream changes
     *
     * @param {boolean} status
     * @param {object} options
     * @param {function} options.onError((err) => {}) Error listener
     * @param {function} options.onSync(() => {}) Sync listener
     * @param {boolean} options.ignoreMounts Default `true`. If `false` enable auto sync for all mount points
     * @param {function} callback
     */
    this.enableAutoSync = (status, options, callback) => {
        options = options || {};
        if (typeof options === 'function') {
            callback = options;
            options = {};
        }

        if (status === autoSyncStatus && dsuObsHandler) {
            return callback();
        }

        const defaultOptions = {
            onError: () => {
            },
            onSync: () => {
            },
            ignoreMounts: true
        }

        options = {
            ...defaultOptions,
            ...options
        };

        const subscribe = (options, callback) => {
            archiveConfigurator.getKeySSI(undefined, (err, keySSI) => {
                if (err) {
                    return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper("Failed to retrieve keySSI", err));
                }

                dsuObsHandler = notifications.getObservableHandler(keySSI);
                dsuObsHandler.on('error', (err) => {
                    options.onError(err);
                });

                dsuObsHandler.on('message', async (message) => {
                    if (!message.ok) {
                        options.onError(new Error(`Unable to fetch notification. Code: ${message.statusCode}. Message: ${message.statusMessage}`));
                        return;
                    }

                    try {
                        message = await message.json();
                        message = JSON.parse(message.message);
                    } catch (e) {
                        options.onError(e);
                    }

                    if (typeof message !== 'object' || message.event !== 'dsu:newAnchor') {
                        // We're interested only in new anchors
                        return;
                    }

                    brickMapController.getCurrentAnchoredHashLink().getAnchorId((err, anchorId) => {
                        if (err) {
                            return options.onError(err);
                        }

                        if (anchorId === message.payload) {
                            return;
                        }

                        // Load and try to merge the latest changes
                        brickMapController.mergeUpstreamChanges((err, result) => {
                            if (err) {
                                return options.onError(err);
                            }
                            options.onSync(result);
                        })
                    })
                })

                callback();
            })
        };

        const unsubscribe = (callback) => {
            dsuObsHandler && notifications.unsubscribe(dsuObsHandler);
            dsuObsHandler = null;
            callback();
        }

        const prevOptions = autoSyncOptions;

        autoSyncStatus = status;
        autoSyncOptions = (status) ? options : null;

        if (options.ignoreMounts) {
            if (autoSyncStatus) {
                return subscribe(autoSyncOptions, callback);
            }

            // When unsubscribing make sure that the previous
            // subscription ignored mounts as well, else continue
            // and unsubscribe recursively
            if (!autoSyncStatus && (!prevOptions || prevOptions.ignoreMounts)) {
                return unsubscribe(callback)
            }
        }

        let mountPoints = [];

        // Recurse in all mount points and set the auto sync settings
        const propagateAutoSyncSettings = (manifest, callback) => {
            if (!mountPoints.length) {
                return callback();
            }

            const mountPoint = mountPoints.pop();

            manifest.getArchiveForPath(mountPoint, (err, result) => {
                if (err) {
                    return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to load DSU instance mounted at path ${mountPoint}`, err));
                }

                result.archive.enableAutoSync(autoSyncStatus, autoSyncOptions, (err) => {
                    if (err) {
                        return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to toggle auto sync for mount point: ${mountPoint}`, err));
                    }

                    propagateAutoSyncSettings(manifest, callback);
                })
            });
        }

        getManifest((err, manifest) => {
            if (err) {
                return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to get manifest handler`, err));
            }

            mountPoints = manifest.getMountPoints();

            propagateAutoSyncSettings(manifest, (err) => {
                if (err) {
                    return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper("Unable to toggle auto sync for mounted DSUs", err));
                }

                autoSyncStatus ? subscribe(autoSyncOptions, callback)
                    : unsubscribe(callback);
            })
        });
    }

    this.stat = (path, callback) => {
        waitIfDSUIsRefreshing(() => {
            callback = $$.makeSaneCallback(callback);

            this.getArchiveForPath(path, (err, res) => {
                if (err) {
                    callback(undefined, {type: undefined})
                }

                if (res.archive === this) {
                    let stats;
                    try {
                        stats = brickMapController.stat(path);
                    } catch (e) {
                        return callback(undefined, {type: undefined})
                    }

                    callback(undefined, stats);
                } else {
                    res.archive.stat(res.relativePath, callback);
                }
            });
        })
    };
}

module.exports = Archive;

},{"./Brick":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/bar/lib/Brick.js","./BrickMapController":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/bar/lib/BrickMapController.js","./BrickStorageService":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/bar/lib/BrickStorageService/index.js","./Manifest":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/bar/lib/Manifest.js","opendsu":"opendsu","path":false,"stream":false,"swarmutils":"swarmutils"}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/bar/lib/ArchiveConfigurator.js":[function(require,module,exports){
const storageProviders = {};
const fsAdapters = {};

function ArchiveConfigurator(options) {
    const config = {};
    let dsuCaching = true;
    let cache;
    let keySSI;

    this.getCreationSSI = function (plain) {
        return config.keySSI.getIdentifier(plain);
    }

    this.setBufferSize = (bufferSize) => {
        if (bufferSize < 65535) {
            throw Error(`Brick size should be equal to or greater than 65535. The provided brick size is ${bufferSize}`);
        }
        config.bufferSize = bufferSize;
    };

    this.setKeySSI = (keySSI) => {
        config.keySSI = keySSI;
    };

    this.getKeySSI = (keySSIType, callback) => {
        if (typeof keySSIType === "undefined") {
            return callback(undefined, config.keySSI);
        }
        if (typeof keySSIType === "function") {
            callback = keySSIType;
            return callback(undefined, config.keySSI);
        }

        config.keySSI.getDerivedType(keySSIType, callback);
    }

    this.getDLDomain = () => {
        if (!config.keySSI) {
            return;
        }

        keySSI = config.keySSI;
        return keySSI.getDLDomain();
    }

    this.getBufferSize = () => {
        return config.bufferSize;
    };

    this.setFsAdapter = (fsAdapterName, ...args) => {
        config.fsAdapter = fsAdapters[fsAdapterName](...args);
    };

    this.getFsAdapter = () => {
        return config.fsAdapter;
    };

    this.setEncryptionAlgorithm = (algorithm) => {
        if (!config.encryption) {
            config.encryption = {};
        }

        config.encryption.algorithm = algorithm;
    };

    this.getEncryptionAlgorithm = () => {
        if (!config.encryption) {
            return;
        }
        return config.encryption.algorithm;
    };

    this.setEncryptionOptions = (options) => {
        if (!config.encryption) {
            config.encryption = {};
        }

        config.encryption.encOptions = options;
    };

    this.getEncryptionOptions = () => {
        if (!config.encryption) {
            return;
        }
        return config.encryption.encOptions;
    };

    this.setCompressionAlgorithm = (algorithm) => {
        if (!config.compression) {
            config.compression = {};
        }

        config.compression.algorithm = algorithm;
    };

    this.getCompressionAlgorithm = () => {
        if (!config.compression) {
            return;
        }

        return config.compression.algorithm;

    };

    this.setCompressionOptions = (options) => {
        if (!config.compression) {
            config.compression = {};
        }

        config.compression.options = options;
    };

    this.getCompressionOptions = () => {
        if (!config.compression) {
            return;
        }
        return config.compression.options;
    };

    this.setAuthTagLength = (authTagLength = 16) => {
        const encOptions = this.getEncryptionOptions();
        if (!encOptions) {
            config.encryption.encOptions = {};
        }

        config.encryption.encOptions.authTagLength = authTagLength;
    };

    this.getAuthTagLength = () => {
        if (!config.encryption || !config.encryption.encOptions) {
            return;
        }

        return config.encryption.encOptions.authTagLength;
    };

    this.setBrickMapStrategy = (strategy) => {
        config.brickMapStrategy = strategy;
    }

    this.getBrickMapStrategy = () => {
        return config.brickMapStrategy;
    }

    this.setValidationRules = (rules) => {
        config.validationRules = rules;
    }

    this.getValidationRules = () => {
        return config.validationRules;
    }

    this.getKey = (key) => {
        if (config.keySSI) {
            return config.keySSI.getKeyHash();
        }

        // @TODO: obsolete
        return this.getSeedKey();
    };

    this.getMapEncryptionKey = () => {
        if (!config.encryption) {
            return;
        }
        if (config.keySSI) {
            return config.keySSI.getEncryptionKey();
        }
    };


    this.setCache = (cacheInstance) => {
        cache = cacheInstance;
    };

    this.getCache = () => {
        return cache;
    };

    this.disableDSUCaching = () => {
        dsuCaching = false;
    }

    this.dsuCachingEnabled = () => {
        return dsuCaching;
    }

    this.getOptions = () => {
        return options;
    }
}

// @TODO: obsolete
ArchiveConfigurator.prototype.registerStorageProvider = (storageProviderName, factory) => {
    storageProviders[storageProviderName] = factory;
};

ArchiveConfigurator.prototype.registerFsAdapter = (fsAdapterName, factory) => {
    fsAdapters[fsAdapterName] = factory;
};

module.exports = ArchiveConfigurator;

},{}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/bar/lib/Brick.js":[function(require,module,exports){
const openDSU = require("opendsu");
const crypto = openDSU.loadApi("crypto");
const keySSISpace = openDSU.loadApi("keyssi");
const brickTransforms = require("./brick-transforms");

function Brick(options) {
    options = options || {};
    if (typeof options.encrypt === "undefined") {
        options.encrypt = true;
    }
    let rawData;
    let transformedData;
    let hashLink;
    let transform;
    let keySSI;

    this.setTemplateKeySSI = (templateKeySSI) => {
        options.templateKeySSI = templateKeySSI;
    };

    this.setKeySSI = (_keySSI) => {
        if (typeof _keySSI === "string") {
            _keySSI = keySSISpace.parse(_keySSI);
        }
        keySSI = _keySSI;
    };

    this.getKeySSI = () => {
        if (typeof keySSI !== "undefined") {
            return keySSI;
        }

        return generateBrickKeySSI(options);
    };

    this.getHashLink = (callback) => {
        if (typeof hashLink !== "undefined") {
            return callback(undefined, hashLink);
        }

        this.getTransformedData((err, _transformedData) => {
            if (err) {
                return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to get transformed data`, err));
            }

            const hashFn = crypto.getCryptoFunctionForKeySSI(options.templateKeySSI, "hash");
            const _hash = hashFn(_transformedData);

            hashLink = keySSISpace.createHashLinkSSI(options.templateKeySSI.getBricksDomain(), _hash, options.templateKeySSI.getVn(), options.templateKeySSI.getHint());
            callback(undefined, hashLink);
        });
    };

    this.getAdler32 = (callback) => {
        this.getTransformedData((err, _transformedData) => {
            if (err) {
                return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to get transformed data`, err));
            }

            callback(undefined, adler32.sum(_transformedData));
        });
    };

    this.setRawData = (data) => {
        rawData = data;
    };

    this.getRawData = (callback) => {
        if (typeof rawData !== "undefined") {
            return callback(undefined, rawData);
        }

        if (!keySSI) {
            rawData = transformedData;
            return this.getRawData(callback);
        }

        if (transformedData) {
            transform = brickTransforms.createBrickTransformation(options);
            return transform.undo(keySSI, transformedData, (err, _rawData) => {
                if (err) {
                    return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to apply inverse transform`, err));
                }

                rawData = _rawData;
                callback(undefined, _rawData);
            });
        }

        callback(Error("The brick does not contain any data."));
    };

    this.setTransformedData = (data) => {
        transformedData = data;
    };

    this.getTransformedData = (callback) => {
        if (typeof transformedData !== "undefined") {
            return callback(undefined, transformedData);
        }

        if (!options.templateKeySSI.getSpecificString()) {
            transformedData = rawData;
            return this.getTransformedData(callback);
        }

        transformData((err, _transformedData) => {
            if (err) {
                return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to transform data`, err));
            }

            if (typeof transformedData === "undefined") {
                if (typeof rawData !== "undefined") {
                    callback(undefined, rawData);
                } else {
                    callback(Error("The brick does not contain any data."));
                }
            } else {
                callback(undefined, transformedData);
            }
        });
    };

    this.getTransformedSize = () => {
        if (!transformedData) {
            return rawData.length;
        }

        return transformedData.length;
    };

    this.getSummary = (callback) => {
        let keySSIIdentifier = keySSI;
        if (typeof keySSIIdentifier === "object") {
            keySSIIdentifier = keySSI.getIdentifier();
        }
        const summary = {
            encryptionKey: keySSIIdentifier
        };

        this.getHashLink((err, _hashLink) => {
            if (err) {
                return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to get hash link`, err));
            }

            summary.hashLink = _hashLink.getIdentifier();
            callback(undefined, summary);
        });
    }

//----------------------------------------------- internal methods -----------------------------------------------------
    function transformData(callback) {
        transform = brickTransforms.createBrickTransformation(options);
        if (rawData) {
            keySSI = generateBrickKeySSI(options);
            if (typeof keySSI === "undefined") {
                transformedData = rawData;
                return callback(undefined, rawData)
            }
            transform.do(keySSI, rawData, (err, _transformedData) => {
                if (err) {
                    return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to apply direct transform`, err));
                }

                if (typeof _transformedData === "undefined") {
                    transformedData = rawData;
                } else {
                    transformedData = _transformedData;
                }

                callback(undefined, transformedData);
            });
        } else {
            callback();
        }
    }

    function generateBrickKeySSI(options) {
        if (typeof options.templateKeySSI === "undefined") {
            throw Error('A template keySSI should be provided when generating a keySSI used for brick encryption.')
        }
        const keySSISpace = require("opendsu").loadAPI("keyssi");
        if (options.encrypt && !options.brickMap) {
            keySSI = keySSISpace.createTemplateSymmetricalEncryptionSSI(options.templateKeySSI.getDLDomain(), undefined, '', options.templateKeySSI.getVn());
        } else {
            if (options.brickMap && options.encrypt === false) {
                keySSI = keySSISpace.createTemplateSeedSSI(options.templateKeySSI.getDLDomain(), undefined, options.templateKeySSI.getControlString(), options.templateKeySSI.getVn());
            } else if (options.brickMap && options.encrypt) {
                keySSI = options.templateKeySSI;
            } else {
                keySSI = undefined;
            }
        }

        return keySSI;
    }
}

module.exports = Brick;

},{"./brick-transforms":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/bar/lib/brick-transforms/index.js","opendsu":"opendsu"}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/bar/lib/BrickMap.js":[function(require,module,exports){
const BrickMapMixin = require('./BrickMapMixin');

/**
 * Maps file paths to bricks and metadata
 *
 * The state of the BrickMap has the following structure
 *
 * header: {
 *  metadata: {
 *      createdAt: 'utc timestamp string'
 *  },
 *  items: {
 *      folder1: {
 *          metadata: {
 *              createdAt: 'utc timestamp string'
 *          },
 *          items: {
 *              file.txt: {
 *                  metadata: {
 *                      createdAt: 'utc timestamp string',
 *                      updatedAt: 'utc timestamp string'
 *                  },
 *                  hashes: [... list of bricks hashes and check sums ...]
 *              }
 *          }
 *
 *      },
 *
 *      file2.txt: {
 *          metadata: {
 *              createdAt: 'utc timestamp string',
 *              updatedAt: 'utc timestamp string'
 *          },
 *          hashes: [... list of bricks hashes and check sums ...]
 *      }
 *  }
 * }
 *
 * @param {object|undefined} header
 */

function BrickMap(header, options) {
    Object.assign(this, BrickMapMixin);
    this.initialize(header, options);

    /**
     * Clone object/array
     */
    const clone = (obj) => {
        const cloned = Object.keys(obj).reduce((acc, key) => {
            if (typeof obj[key] === 'object' && !Array.isArray(obj[key])) {
                acc[key] = clone(obj[key]);
                return acc;
            }

            if (Array.isArray(obj[key])) {
                acc[key] = [];
                for (const i in obj[key]) {
                    if (typeof obj[key][i] === 'object' || Array.isArray(obj[key][i])) {
                        acc[key][i] = clone(obj[key][i]);
                        continue;
                    }

                    acc[key][i] = obj[key][i];
                }

                return acc;
            }

            acc[key] = obj[key];
            return acc;
        }, {});
        return cloned;
    };

    /**
     * Compare two BrickMap paths for changes
     */
    const pathChanged = (src, dst) => {
        if (this.nodeIsDirectory(src) !== this.nodeIsDirectory(dst)) {
            return true;
        }

        // Compare directories
        if (this.nodeIsDirectory(src)) {
            const srcFiles = Object.keys(src.items).sort();
            const dstFiles = Object.keys(dst.items).sort();

            if (srcFiles.length !== dstFiles.length) {
                return true;
            }

            const max = Math.max(srcFiles.length, dstFiles.length);

            for (let i = 0; i < max; i++) {
                const srcKey = srcFiles[i];
                const dstKey = dstFiles[i];


                if (srcKey !== dstKey) {
                    return true;
                }

                if (pathChanged(src.items[srcKey], dst.items[dstKey])) {
                    return true;
                }
            }
            return false;
        }

        // Compare files
        if (src.hashLinks.length !== dst.hashLinks.length) {
            return true;
        }

        const max = Math.max(src.hashLinks.length, dst.hashLinks.length);
        for (let i = 0; i < max; i++) {
            const srcHashLink = src.hashLinks[i];
            const dstHashLink = dst.hashLinks[i];

            if (typeof srcHashLink !== typeof dstHashLink) {
                return true;
            }

            const srcKeys = Object.keys(srcHashLink).sort();
            const dstKeys = Object.keys(dstHashLink).sort();
            const max = Math.max(srcKeys.length, dstKeys.length);

            for (let i = 0; i < max; i++) {
                if (srcKeys[i] !== dstKeys[i]) {
                    return true;
                }

                if (srcHashLink[srcKeys[i]] !== dstHashLink[dstKeys[i]]) {
                    return true;
                }
            }
        }

        return false;
    };


    /**
     * Merge `brickMap` items into
     * this instance
     * @param {BrickMap} brickMap
     */
    this.merge = function (brickMap) {
        const changes = this.diff(brickMap);

        if (!changes.hasItems()) {
            return;
        }

        const merge = (target, source) => {
            for (const key in source) {
                if (typeof source[key] === 'object' && !Array.isArray(source[key])) {
                    if (typeof target[key] !== 'object' || Array.isArray(target[key])) {
                        target[key] = {};
                    }
                    merge(target[key], source[key]);
                    continue;
                }

                if (Array.isArray(source[key])) {
                    target[key] = [];
                    for (let i = 0; i < source[key].length; i++) {
                        if (typeof source[key][i] === 'object') {
                            target[key][i] = {}
                            merge(target[key][i], source[key][i])
                            continue;
                        }
                        target[key][i] = source[key][i];
                    }
                    continue;
                }

                target[key] = source[key];
            }
        };
        merge(this.header.items, changes.header.items);
        merge(this.header.embedded, changes.header.embedded);
        this.updateTimeMetadata('/', 'updatedAt', this.getTimestamp());
    }

    /**
     * Return all items that changed in `brickMap`
     * compared to our version
     * @param {BrickMap} brickMap
     */
    this.diff = function (brickMap) {
        const dst = brickMap.header.items;
        const dstKeys = Object.keys(dst)
                              .filter(item => item !== 'dsu-metadata-log')
                              .sort();

        const src = this.header.items;
        const changes = {};
        for (const key of dstKeys) {
            // New items
            if (typeof src[key] === 'undefined') {
                changes[key] = clone(dst[key]);
                continue;
            }

            // Existing items
            if (pathChanged(src[key], dst[key])) {
                changes[key] = clone(dst[key]);
                continue;
            }
        }

        let embedClone = {};
        if(brickMap.header.embedded){
            embedClone = JSON.parse(JSON.stringify(brickMap.header.embedded));
            let embeddedSrc = this.header.embedded;
            for (let f in embeddedSrc) {
                if (embedClone[f] === embeddedSrc[f]) {
                    delete embedClone[f];
                }
            }
        }


        const brickMapDiff = new this.constructor({
            metadata: {
                createdAt: this.getTimestamp()
            },
            items: changes,
            embedded: embedClone
        });
        return brickMapDiff;
    }

    /**
     * @param {object} operation
     * @param {string} operation.op
     * @param {string} operation.path
     * @param {string} operation.timestamp UTC string timestamp
     * @param {*} operation.data
     * @throws {Error}
     */
    this.replayOperation = function (operation) {
        const {op, path, timestamp, data} = operation;

        switch (op) {
            case 'add':
                this.appendBricksToFile(path, data);
                this.updateTimeMetadata(path, 'updatedAt', timestamp);
                break;
            case 'truncate':
                this.emptyList(path);
                this.updateTimeMetadata(path, 'updatedAt', timestamp);
                break;
            case 'delete':
                this.delete(path);
                this.updateTimeMetadata(path, 'deletedAt', timestamp);
                break;
            case 'copy':
                const dstPath = data;
                this.copy(path, dstPath);
                this.updateTimeMetadata(dstPath, 'createdAt', timestamp);
                break;
            case 'createFolder':
                this.createFolder(path);
                this.updateTimeMetadata(path, 'createdAt', timestamp);
                break;
            case 'createFile':
                this.createFile(path);
                this.updateTimeMetadata(path, 'createdAt', timestamp);
                break;
            case 'replaceFirstBrick':
                this.replaceFirstBrick(path, data);
                this.updateTimeMetadata(path, 'updatedAt', timestamp);
                break;
            case 'replaceLastBrick':
                this.replaceLastBrick(path, data);
                this.updateTimeMetadata(path, 'updatedAt', timestamp);
                break;
            case 'embed':
                this.putEmbeddedFile(path, data);
                break;
            case 'appendToEmbed':
                this.appendToEmbedded(path, data);
                break;
            default:
                throw new Error(`Unknown operation <${JSON.stringify(operation)}>`);
        }
    }

    /**
     * @param {BrickMap} brickMap
     * @throws {Error}
     */
    this.applyDiff = function (brickMap) {
        if (brickMap.constructor === BrickMap) {
            // This is not a BrickMapDiff so we need to merge the changes from a regular BrickMap instance
            this.merge(brickMap);
            return;
        }

        const metadata = brickMap.getMetadata('/');
        const operationsLog = metadata.log;

        if (!Array.isArray(operationsLog)) {
            throw new Error('Invalid BrickMapDiff. No replay log found');
        }

        if (!operationsLog.length) {
            return;
        }

        for (const operation of operationsLog) {
            this.replayOperation(operation, brickMap);
        }
        this.updateTimeMetadata('/', 'updatedAt', this.getTimestamp());
        this.header.metadata.prevDiffHashLink = metadata.prevDiffHashLink;
    }

    /**
     * Check for same path conflicts
     * @param {Array<BrickMapDiff>} localChangesList
     * @return {object}
     */
    this.detectMergeConflicts = function (changes) {
        const conflicts = changes.reduce((acc, changeSet) => {
            const metadata = changeSet.getMetadata('/');
            const operationsLog = metadata.log;

            if (!Array.isArray(operationsLog)) {
                return acc;
            }

            if (!operationsLog.length) {
                return acc;
            }

            for (const operation of operationsLog) {
                switch (operation.op) {
                    case 'add':
                    case 'createFolder':
                    case 'createFile':
                    case 'truncate':
                        if (this.fileExists(operation.path)) {
                            acc[operation.path] = {
                                error: 'LOCAL_OVERWRITE',
                                message: `Path ${operation.path} will overwrite a previously anchored file or directory`,
                            }
                        }
                        break;

                    case 'copy':
                        if (this.fileDeleted(operation.path)) {
                            acc[operation.path] = {
                                error: 'REMOTE_DELETE',
                                message: `Unable to copy ${operation.path} to ${operation.data}. Source was previously deleted`
                            };
                        }

                        if (this.fileExists(operation.data)) {
                            acc[operation.data] = {
                                error: 'LOCAL_OVERWRITE',
                                message: `Unable to copy ${operation.path} to ${operation.data}. The destination path will overwrite a previously anchored file or directory`,
                            };
                        }
                        break;

                    case 'delete':
                        if (this.fileExists(operation.path)) {
                            acc[operation.path] = {
                                error: 'LOCAL_DELETE',
                                message: `Unable to delete ${operation.path}. This will delete a previously anchored file.`
                            }
                        }
                        break;

                }
            }

            return acc;
        }, {});

        if (!Object.keys(conflicts).length) {
            return;
        }
        return conflicts;
    }
}
module.exports = BrickMap;

},{"./BrickMapMixin":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/bar/lib/BrickMapMixin.js"}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/bar/lib/BrickMapController.js":[function(require,module,exports){
'use strict';

// HTTP error code returned by the anchoring middleware
// when trying to anchor outdated changes
const {anchoringStatus} = require("./constants");
const ALIAS_SYNC_ERR_CODE = 428;


/**
 * The current state of the BrickMapController
 */
function State() {
    const brickMap = {
        // The latest anchored BrickMap
        anchored: undefined,
        // The current BrickMap, cloned from `anchored`. Contains un-anchored changes
        dirty: undefined,
    };
    const diffs = {
        inAnchoring: [], // BrickMapDiff objects which are in the process of anchoring
        new: [], // BrickMapDiff objects which haven't been scheduled for anchoring
        current: undefined, // A reference to the current BrickMapDiff
        latestHash: undefined // Used for chaining multiple BrickMapDiff objects
    };
    let currentAnchoredHashLink = undefined;

    this.init = (anchoredBrickMap, latestHashLink, callback) => {
        if (typeof latestHashLink === 'function') {
            callback = latestHashLink;
            latestHashLink = undefined;
        }

        brickMap.anchored = anchoredBrickMap;
        this.cloneAnchoredBrickMap((err, clone) => {
            if (err) {
                return callback(err);
            }
            brickMap.dirty = clone;
            currentAnchoredHashLink = latestHashLink;
            diffs.inAnchoring = [];
            diffs.new = [];
            diffs.current = undefined;
            diffs.latestHash = latestHashLink;
            callback();
        });
    }

    /**
     * @return {boolean}
     */
    this.canBeAnchored = () => {
        return this.hasNewDiffs() || this.hasDiffsForAnchoring();
    }

    /**
     * @return {Array<BrickMapDiff>}
     */
    this.getDiffsForAnchoring = () => {
        return diffs.inAnchoring;
    }

    /**
     * @param {BrickMap} anchoredBrickMap
     */
    this.setAnchoredBrickMap = (anchoredBrickMap) => {
        brickMap.anchored = anchoredBrickMap;
    }

    /**
     * @return {BrickMap}
     */
    this.getAnchoredBrickMap = () => {
        return brickMap.anchored;
    }

    /**
     * @return {BrickMapDiff}
     */
    this.getCurrentDiff = () => {
        return diffs.current;
    }

    /**
     * @param {BrickMapDiff} diff
     */
    this.setCurrentDiff = (diff) => {
        diffs.current = diff;
    }

    /**
     * Returns the BrickMap containing un-anchored changes
     * @return {BrickMap}
     */
    this.getDirtyBrickMap = () => {
        return brickMap.dirty;
    }

    /**
     * @param {BrickMap} dirtyBrickMap
     */
    this.setDirtyBrickMap = (dirtyBrickMap) => {
        brickMap.dirty = dirtyBrickMap;
    }

    /**
     * Returns the latest BrickMapDiff in the "new" list
     * @return {BrickMapDiff}
     */
    this.getLastestNewDiff = () => {
        const newDiffsLength = diffs.new.length;
        return diffs.new[newDiffsLength - 1];
    }

    /**
     * @param {BrickMapDiff} diff
     */
    this.pushNewDiff = (diff) => {
        diffs.new.push(diff);
    }

    this.getCurrentAnchoredHashLink = () => {
        return currentAnchoredHashLink;
    }

    this.setCurrentAnchoredHashLink = (hashLink) => {
        currentAnchoredHashLink = hashLink;
    }

    this.getLatestDiffHashLink = () => {
        return diffs.latestHash;
    }

    this.setLatestDiffHashLink = (hashLink) => {
        diffs.latestHash = hashLink;
    }

    /**
     * @return {boolean}
     */
    this.hasNewDiffs = () => {
        return diffs.new.length > 0;
    }

    /**
     * @return {boolean}
     */
    this.hasDiffsForAnchoring = () => {
        return diffs.inAnchoring.length > 0;
    }

    /**
     * Moves the BrickMapDiffs from the 'new' array to the 'inAnchoring' array
     * @param {function} callback
     */
    this.prepareNewChangesForAnchoring = (callback) => {
        if (!this.hasNewDiffs()) {
            return callback();
        }

        const diff = diffs.new.shift();
        diff.getHashLink((err, lastDiffHashLink) => {
            if (err) {
                return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to get hashLink`, err));
            }

            diffs.latestHash = lastDiffHashLink;
            diffs.inAnchoring.push(diff);
            this.prepareNewChangesForAnchoring(callback);
        });
    }

    this.rollback = (mergedDiffs) => {
        diffs.inAnchoring.unshift(...mergedDiffs);
    }

    /**
     * Clone the anchored brickmap
     * @param {function} callback
     */
    this.cloneAnchoredBrickMap = (callback) => {
        brickMap.anchored.clone((err, brickMap) => {
            if (err) {
                return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to clone BrickMap`, err));
            }
            callback(undefined, brickMap);
        })
    }
}

/**
 * BrickMap Proxy
 *
 * Handles loading and anchoring a BrickMap using the provided BrickMapStrategy
 * in the ArchiveConfigurator
 *
 * BrickMap write operations are proxied to a copy of a valid BrickMap and to a BrickMapDiff
 * used later for anchoring. The reason for that is to preserve read consistency during
 * a session. Writing only to a BrickMapDiff object will cause subsequent reads to fail;
 * in order to simplify the implementation the same "write" operation is written to the
 * "dirty" BrickMap and to the BrickMapDiff object (only this object will be anchored). Any
 * read operations will go directly to the "dirty" BrickMap.
 *
 * After anchoring any changes, the anchored BrickMap is updated with the changes stored in BrickMapDiff
 * thus being in sync with the "dirty" copy
 *
 * @param {object} options
 * @param {ArchiveConfigurator} options.config
 * @param {BrickStorageService} options.brickStorageService
 */
function BrickMapController(options) {
    const swarmutils = require("swarmutils");
    const BrickMap = require('./BrickMap');
    const Brick = require('./Brick');
    const AnchorValidator = require('./AnchorValidator');
    const pskPth = swarmutils.path;
    const BrickMapDiff = require('./BrickMapDiff');
    const BrickMapStrategyFactory = require('./BrickMapStrategy');
    const anchoringStatus = require('./constants').anchoringStatus;
    const openDSU = require("opendsu");
    const bricking = openDSU.loadAPI("bricking");
    const anchoring = openDSU.loadAPI("anchoring");
    const anchoringx = anchoring.getAnchoringX();

    const notifications = openDSU.loadAPI("notifications");
    options = options || {};

    const config = options.config;
    const keySSI = options.keySSI;
    const brickStorageService = options.brickStorageService;
    const keySSISpace = openDSU.loadApi("keyssi");
    if (!config) {
        throw new Error('An ArchiveConfigurator is required!');
    }

    if (!brickStorageService) {
        throw new Error('BrickStorageService is required');
    }

    let anchoringInProgress = false;

    let publishAnchoringNotifications = false;
    let autoSync = false;
    let dsuObsHandler;
    let autoSyncOptions = {};

    let strategy = config.getBrickMapStrategy();
    let validator = new AnchorValidator({
        rules: config.getValidationRules()
    });
    const state = new State();


    ////////////////////////////////////////////////////////////
    // Private methods
    ////////////////////////////////////////////////////////////

    /**
     * Configure the strategy and create
     * proxy methods for BrickMap
     */
    const initialize = () => {
        if (!strategy) {
            strategy = getDefaultStrategy();
        }
        strategy.setCache(config.getCache());
        strategy.setBrickMapController(this);
        strategy.setBrickMapState(state);
        strategy.setValidator(validator);

        const brickMap = new BrickMap(undefined, options);
        const brickMapProperties = Object.getOwnPropertyNames(brickMap);
        for (const propertyName of brickMapProperties) {
            if (typeof brickMap[propertyName] !== 'function' || propertyName === 'load') {
                continue;
            }
            // Proxy method calls to BrickMap through BrickMapController
            const method = propertyName;
            this[propertyName] = new Proxy(function () {
            }, {
                apply: (...args) => {
                    const targetHandlerName = `${method}ProxyHandler`;

                    if (typeof this[targetHandlerName] === 'function') {
                        return this[targetHandlerName](...args.pop());
                    }

                    const dirtyBrickMap = state.getDirtyBrickMap();
                    return dirtyBrickMap[method].apply(dirtyBrickMap, args.pop());
                }
            });
        }
    }

    this.getStrategy = () => {
        return strategy;
    };
    /**
     * @return {BrickMapStrategyMixin}
     */
    const getDefaultStrategy = () => {
        const factory = new BrickMapStrategyFactory();
        const strategy = factory.create();

        return strategy;
    }

    const createBrickMapDiff = (data, callback) => {
        if (typeof data === 'function') {
            callback = data;
            data = undefined;
        }

        const brickMapDiff = new BrickMapDiff(data);
        if (typeof data !== 'undefined') {
            return this.configureBrickMap(brickMapDiff, (err) => {
                if (err) {
                    return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to configure brickMap`, err));
                }
                callback(undefined, brickMapDiff);
            });
        }
        brickMapDiff.initialize((err) => {
            if (err) {
                return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to initialize brickMapDiff`, err));
            }

            brickMapDiff.setPrevDiffHashLink(state.getLatestDiffHashLink());
            this.configureBrickMap(brickMapDiff, (err) => {
                if (err) {
                    return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to configure brickMap`, err));
                }
                callback(undefined, brickMapDiff);
            });
        });
    }

    /**
     * Returns the latest BrickMapDiff that
     * hasn't been scheduled for anchoring
     *
     * Write operations will be added into this object
     *
     * If no such object exists, a new object is created
     * and push into the list
     *
     * @return {BrickMapDiff}
     */
    const getCurrentDiffBrickMap = (callback) => {
        let brickMapDiff = state.getLastestNewDiff();
        if (!brickMapDiff) {
            return createBrickMapDiff((err, brickMapDiff) => {
                if (err) {
                    return callback(err);
                }

                state.setCurrentDiff(brickMapDiff);
                state.pushNewDiff(brickMapDiff);
                callback(undefined, brickMapDiff);
            })
        }

        state.setCurrentDiff(brickMapDiff);
        callback(undefined, brickMapDiff);
    }

    const notifySubscribers = (hashLink, callback) => {
        hashLink.getAnchorId((err, anchorId) => {
            if (err) {
                return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to get anchor id for hashlink ${hashLink.getIdentifier()}`, err));
            }

            const message = {
                event: "dsu:newAnchor",
                payload: anchorId
            };

            notifications.publish(keySSI, message, 0, (err) => {
                if (err) {
                    return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to publish anchoring notification`, err));
                }

                callback();
            });
        })
    }

    /**
     * Release the "anchoringInProgress" lock
     * and notify the anchoring listener of
     * the status and data of the current anchoring process
     *
     * To preserve backwards compatibility with the existing
     * code, the listener is called in the same way as
     *  the classic NodeJS callback convention: callback(err, result)
     *
     * If the anchoring status is OK, the listener is called as: listener(undefined, anchoringResult)
     * If the anchoring process has failed, the `status` parameter will contain
     * the error type (string) and the `data` parameter will contain
     * the actual error object. The error type is added as a property
     * tot the error object and the listener will be called as: listener(err)
     *
     * @param {callback} listener
     * @param {number} status
     * @param {*} data
     */
    const endAnchoring = (listener, status, data) => {
        anchoringInProgress = false;

        if (status === anchoringStatus.OK) {
            if (!publishAnchoringNotifications) {
                return listener(undefined, data);
            }

            return notifySubscribers(data, (err) => {
                if (err) {
                    console.warn("Unable to publish anchoring notification");
                    console.error(err);
                }

                return listener(undefined, data);
            });
        }

        if (status === anchoringStatus.BRICKMAP_RECONCILIATION_HANDOFF) {
            return listener(undefined, data);
        }

        const error = data;
        error.type = status;
        listener(error);
    }

    /**
     * Returns true if any BrickMapDiff objects
     * exist in the pending state.
     *
     * This function is used to determine if a new anchoring
     * process should be started after the current one has ended
     *
     * @return {boolean}
     */
    const anchoringRequestExists = () => {
        return state.hasDiffsForAnchoring();
    }

    /**
     * Returns true if the anchoring service returned an 'out of sync' error
     * @return {boolean}
     */
    const isAliasSyncError = (err) => {
        let error = err;
        do {
            if (error.statusCode === ALIAS_SYNC_ERR_CODE) {
                return true;
            }

            error = error.previousError;
        } while (error && (error.previousError || error.statusCode));
        return false;
    }

    ////////////////////////////////////////////////////////////
    // Public methods
    ////////////////////////////////////////////////////////////

    /**
     * Create an empty BrickMap
     */
    this.init = (callback) => {
        this.createBrickMap((err, brickMap) => {
            if (err) {
                return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to create new brickMap`, err));
            }

            state.init(brickMap, callback);
        });
    }

    /**
     * Load an existing BrickMap using the BrickMap strategy
     */
    this.load = (callback) => {
        strategy.load(keySSI, (err, brickMap) => {
            if (err) {
                return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to load brickMap`, err));
            }


            state.init(brickMap, strategy.getCurrentHashLink(), callback);
        });
    }

    this.loadVersion = (versionHash, callback) => {
        strategy.loadVersion(keySSI, versionHash, (err, brickMap) => {
            if (err) {
                return callback(err);
            }

            state.init(brickMap, versionHash, callback);
        });
    }

    /**
     * @param {string} path
     * @param {Array<object>} bricksData
     * @param {callback} callback
     */
    this.addFile = (path, bricksData, callback) => {
        validator.validate('preWrite', state.getDirtyBrickMap(), 'addFile', path, {
            bricksData
        }, (err) => {
            if (err) {
                return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to validate addFile operation`, err));
            }

            getCurrentDiffBrickMap((err, _brickMap) => {
                if (err) {
                    return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to retrieve current diffBrickMap`, err));
                }

                this.addFileEntry(path, bricksData);
                this.attemptAnchoring(callback);
            });
        })
    }

    /**
     * @param {string} srcPath
     * @param {string} dstPath
     * @param {callback} callback
     */
    this.renameFile = (srcPath, dstPath, callback) => {
        validator.validate('preWrite', state.getDirtyBrickMap(), 'rename', srcPath, {
            dstPath
        }, (err) => {
            if (err) {
                return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to validate rename operation`, err));
            }

            getCurrentDiffBrickMap((err, _brickMap) => {
                if (err) {
                    return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to retrieve current diffBrickMap`, err));
                }
                try {
                    this.copy(srcPath, dstPath);
                } catch (e) {
                    return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to copy`, e));
                }
                this.delete(srcPath);
                this.attemptAnchoring(callback);
            })
        })
    }
    /**
     * @param {string} srcPath
     * @param {string} dstPath
     * @param {callback} callback
     */
    this.cloneFolder = (srcPath, dstPath, callback) => {
        validator.validate('preWrite', state.getDirtyBrickMap(), 'clone', srcPath, {
            dstPath
        }, (err) => {
            if (err) {
                return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to validate copy operation`, err));
            }

            getCurrentDiffBrickMap((err, _brickMap) => {
                if (err) {
                    return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to retrieve current diffBrickMap`, err));
                }
                try {
                    this.copy(srcPath, dstPath);
                } catch (e) {
                    return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to copy`, e));
                }

                this.attemptAnchoring(callback);
            })
        })
    }

    /**
     * @param {string} path
     * @param {Array<object>} bricksData
     * @param {callback} callback
     */
    this.appendToFile = (path, bricksData, callback) => {
        validator.validate('preWrite', state.getDirtyBrickMap(), 'appendToFile', path, {
            bricksData
        }, (err) => {
            if (err) {
                return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to validate appendToFile operation`, err));
            }

            getCurrentDiffBrickMap((err, _brickMap) => {
                if (err) {
                    return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to retrieve current diffBrickMap`, err));
                }

                this.appendBricksToFile(path, bricksData);
                this.attemptAnchoring(callback);
            })
        })
    }

    /**
     * @param {string} path
     * @param {Array<object>} filesBricksData
     * @param {callback} callback
     */
    this.addFiles = (path, filesBricksData, callback) => {
        validator.validate('preWrite', state.getDirtyBrickMap(), 'addFiles', path, {
            filesBricksData
        }, (err) => {
            if (err) {
                return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to validate addFiles operation`, err));
            }

            getCurrentDiffBrickMap((err, _brickMap) => {
                if (err) {
                    return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to retrieve current diffBrickMap`, err));
                }

                for (const filePath in filesBricksData) {
                    const bricks = filesBricksData[filePath];
                    this.addFileEntry(pskPth.join(path, filePath), bricks);
                }
                this.attemptAnchoring(callback);
            })
        })
    }

    /**
     * @param {string} path
     * @param {Array<object>} bricksData
     * @param {callback} callback
     */
    this.updateBigFileLastBrick = (path, sizeSSI, brick, callback) => {
        validator.validate('preWrite', state.getDirtyBrickMap(), 'updateBigFile', path, {
            sizeSSI,
            brick
        }, (err) => {
            if (err) {
                return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to validate updateBigFile operation`, err));
            }

            getCurrentDiffBrickMap((err, _brickMap) => {
                if (err) {
                    return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to retrieve current diffBrickMap`, err));
                }

                this.replaceFirstBrick(path, {size: sizeSSI});
                this.replaceLastBrick(path, brick);
                this.attemptAnchoring(callback);
            })
        })
    }

    /**
     * @param {string} path
     * @param {Array<object>} bricksData
     * @param {callback} callback
     */
    this.appendBigFile = (path, sizeSSI, brick, callback) => {
        validator.validate('preWrite', state.getDirtyBrickMap(), 'appendBigFile', path, {
            sizeSSI,
            brick
        }, (err) => {
            if (err) {
                return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to validate appendBigFile operation`, err));
            }

            getCurrentDiffBrickMap((err, _brickMap) => {
                if (err) {
                    return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to retrieve current diffBrickMap`, err));
                }

                this.replaceFirstBrick(path, {size: sizeSSI});
                this.appendBricksToFile(path, [brick]);
                this.attemptAnchoring(callback);
            })
        })
    }

    /**
     * @param {string} path
     * @param {callback} callback
     */
    this.deleteFile = (path, callback) => {
        validator.validate('preWrite', state.getDirtyBrickMap(), 'deleteFile', path, (err) => {
            if (err) {
                return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to validate deleteFile operation`, err));
            }

            getCurrentDiffBrickMap((err, _brickMap) => {
                if (err) {
                    return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to retrieve current diffBrickMap`, err));
                }

                try {
                    this.delete(path);
                } catch (e) {
                    return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to delete`, e));
                }
                this.attemptAnchoring(callback);
            })
        })
    }

    /**
     * @param {string} path
     * @param {callback} callback
     */
    this.createDirectory = (path, callback) => {
        validator.validate('preWrite', state.getDirtyBrickMap(), 'createFolder', path, (err) => {
            if (err) {
                return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to validate createFolder operation`, err));
            }

            getCurrentDiffBrickMap((err, _brickMap) => {
                if (err) {
                    return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to retrieve current diffBrickMap`, err));
                }

                try {
                    this.createFolder(path);
                } catch (e) {
                    return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to create folder ${path}`, e));
                }
                this.attemptAnchoring(callback);
            })
        })
    }

    /**
     * @param {string} path
     * @param {callback} callback
     */
    this.createEmptyFile = (path, callback) => {
        validator.validate('preWrite', state.getDirtyBrickMap(), 'createFile', path, (err) => {
            if (err) {
                return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to validate createFile operation`, err));
            }

            getCurrentDiffBrickMap((err, _brickMap) => {
                if (err) {
                    return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to retrieve current diffBrickMap`, err));
                }

                try {
                    this.createFile(path);
                } catch (e) {
                    return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to create file ${path}`, e));
                }
                this.attemptAnchoring(callback);
            })
        })
    }

    this.fileIsEmbedded = (path, callback) => {
        getCurrentDiffBrickMap((err, _brickMap) => {
            if (err) {
                return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to retrieve current diffBrickMap`, err));
            }

            const embeddedFile = this.getEmbeddedFile(path);
            callback(undefined, !!embeddedFile);
        })
    }

    this.embedData = (path, data, options, callback) => {
        getCurrentDiffBrickMap((err, _brickMap) => {
            if (err) {
                return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to retrieve current diffBrickMap`, err));
            }

            try {
                this.putEmbeddedFile(path, data);
            } catch (e) {
                return callback(e);
            }

            this.attemptAnchoring(callback);
        });
    }

    this.appendToEmbeddedFile = (path, data, options, callback) => {
        getCurrentDiffBrickMap((err, _brickMap) => {
            if (err) {
                return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to retrieve current diffBrickMap`, err));
            }
            try {
                this.appendToEmbedded(path, data);
            } catch (e) {
                return callback(e);
            }

            this.attemptAnchoring(callback);
        });
    }

    /**
     * Proxy for BatMap.addFileEntry()
     *
     * @param {string} path
     * @param {Array<object>} bricks
     * @throws {Error}
     */
    this.addFileEntryProxyHandler = (path, bricks) => {
        const dirtyBrickMap = state.getDirtyBrickMap();
        let truncateFileIfExists = false;
        if (!dirtyBrickMap.isEmpty(path)) {
            truncateFileIfExists = true;
        }

        dirtyBrickMap.addFileEntry(path, bricks);
        if (truncateFileIfExists) {
            state.getCurrentDiff().emptyList(path);
        }
        state.getCurrentDiff().addFileEntry(path, bricks);
    }

    /**
     * Proxy for BrickMap.appendBricksToFile()
     *
     * @param {string} path
     * @param {Array<object>} bricks
     * @throws {Error}
     */
    this.appendBricksToFileProxyHandler = (path, bricks) => {
        const dirtyBrickMap = state.getDirtyBrickMap();
        dirtyBrickMap.appendBricksToFile(path, bricks);
        state.getCurrentDiff().appendBricksToFile(path, bricks);
    }

    /**
     * Proxy for BrickMap.replaceFirstBrick()
     *
     * @param {string} path
     * @param {Array<object>} bricks
     * @throws {Error}
     */
    this.replaceFirstBrickProxyHandler = (path, brick) => {
        const dirtyBrickMap = state.getDirtyBrickMap();
        dirtyBrickMap.replaceFirstBrick(path, brick);
        state.getCurrentDiff().replaceFirstBrick(path, brick);
    }

    /**
     * Proxy for BrickMap.replaceLastBrick()
     *
     * @param {string} path
     * @param {Array<object>} bricks
     * @throws {Error}
     */
    this.replaceLastBrickProxyHandler = (path, brick) => {
        const dirtyBrickMap = state.getDirtyBrickMap();
        dirtyBrickMap.replaceLastBrick(path, brick);
        state.getCurrentDiff().replaceLastBrick(path, brick);
    }

    /**
     * Proxy for BrickMap.delete();
     *
     * @param {string} path
     * @throws {Error}
     */
    this.deleteProxyHandler = (path) => {
        const dirtyBrickMap = state.getDirtyBrickMap();
        dirtyBrickMap.delete(path);
        state.getCurrentDiff().delete(path);
    }

    /**
     * Proxy for BrickMap.copy()
     *
     * @param {string} srcPath
     * @param {string} dstPath
     * @throws {Error}
     */
    this.copyProxyHandler = (srcPath, dstPath) => {
        const dirtyBrickMap = state.getDirtyBrickMap();
        dirtyBrickMap.copy(srcPath, dstPath);
        state.getCurrentDiff().copy(srcPath, dstPath);
    }

    /**
     * Proxy for BrickMap.createFolder()
     *
     * @param {string} path
     */
    this.createFolderProxyHandler = (path) => {
        const dirtyBrickMap = state.getDirtyBrickMap();
        dirtyBrickMap.createFolder(path);
        state.getCurrentDiff().createFolder(path);
    }

    /**
     * Proxy for BrickMap.createFile()
     *
     * @param {string} path
     */
    this.createFileProxyHandler = (path) => {
        const dirtyBrickMap = state.getDirtyBrickMap();
        dirtyBrickMap.createFile(path);
        state.getCurrentDiff().createFile(path);
    }

    /**
     * Proxy for BrickMap.putEmbeddedFile()
     *
     * @param {string} path
     * @param {string} data
     */
    this.putEmbeddedFileProxyHandler = (path, data) => {
        const dirtyBrickMap = state.getDirtyBrickMap();
        dirtyBrickMap.putEmbeddedFile(path, data);
        state.getCurrentDiff().putEmbeddedFile(path, data);
    }

    /**
     * Proxy for BrickMap.appendToEmbedded()
     *
     * @param {string} path
     * @param {string} data
     */
    this.appendToEmbeddedProxyHandler = (path, data) => {
        const dirtyBrickMap = state.getDirtyBrickMap();
        dirtyBrickMap.appendToEmbedded(path, data);
        state.getCurrentDiff().appendToEmbedded(path, data);
    }

    /**
     * Persists a BrickMap Brick
     *
     * @param {BrickMap} brickMap
     * @param {callback} callback
     */
    this.saveBrickMap = (domain, brickMap, callback) => {
        const brickMapBrick = brickMap.toBrick();

        brickMapBrick.setKeySSI(brickMap.getBrickEncryptionKeySSI());
        brickMapBrick.getTransformedData((err, brickData) => {
            if (err) {
                return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to get brickMap brick's transformed data`, err));
            }

            bricking.putBrick(domain, brickData, callback);
        });
    }

    /**
     * @param {Brick|undefined} brick
     * @param {function} callback
     */
    this.createBrickMap = (brick, callback) => {
        if (typeof brick === "function") {
            callback = brick;
            brick = undefined;
        }

        const brickMap = new BrickMap(brick, options);
        this.configureBrickMap(brickMap, (err => callback(err, brickMap)));
    }

    /**
     * @param {Brick|undefined} brick
     * @return {function} callback
     */
    this.createBrickMapDiff = (brick, callback) => {
        return createBrickMapDiff(brick, callback);
    }

    /**
     * @param {BrickMap} brickMap
     * @param callback
     */
    this.configureBrickMap = (brickMap, callback) => {
        if (!brickMap.getTemplateKeySSI()) {
            brickMap.setKeySSI(keySSI);
        }

        brickMap.load(callback);
    }

    /**
     * @param {object} rules
     * @param {object} rules.preWrite
     * @param {object} rules.afterLoad
     */
    this.setValidationRules = (rules) => {
        validator.setRules(rules);
    }

    /**
     * Start the anchoring process only
     * if the BrickMapStrategy decides it's time
     *
     * @param {callback} callback
     */
    this.attemptAnchoring = (callback) => {
        const dirtyBrickMap = state.getDirtyBrickMap();
        strategy.ifChangesShouldBeAnchored(dirtyBrickMap, (err, shouldBeAnchored) => {
            if (err) {
                return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to determine if changes should be anchored`, err));
            }

            if (!shouldBeAnchored) {
                return callback();
            }

            // In order to preserve backwards compatibility
            // with the existing code, if no "anchoring event listener"
            // is set, use the `callback` as a listener
            const anchoringEventListener = strategy.getAnchoringEventListener(callback);
            if (anchoringEventListener !== callback) {
                // Resume execution and perform the anchoring in the background
                // When anchoring has been done the `anchoringEventListener` will be notified
                callback();
            }

            this.anchorChanges(anchoringEventListener);
        });
    }

    /**
     * @param {callback} listener
     * @param {BrickMap|undefined} brickMap
     */
    this.anchorChanges = (listener, brickMap) => {
        if (anchoringInProgress || (!state.canBeAnchored() && !brickMap)) {
            return listener();
        }

        anchoringInProgress = true;

        // Use the strategy to compact/merge any BrickMapDiff objects into a single
        // BrickMap instance
        strategy.compactDiffs(brickMap, (err, result) => {
            if (err) {
                return OpenDSUSafeCallback(listener)(createOpenDSUErrorWrapper(`Failed to compact diffs`, err));
            }

            const [brickMap, mergedDiffs] = result;
            const bricksDomain = keySSI.getBricksDomain();
            this.saveBrickMap(bricksDomain, brickMap, (err, hash) => {
                if (err) {
                    state.rollback(mergedDiffs);
                    return endAnchoring(listener, anchoringStatus.PERSIST_BRICKMAP_ERR, err);
                }

                keySSI.getAnchorId((err, anchorId) => {
                    if (err) {
                        return OpenDSUSafeCallback(listener)(createOpenDSUErrorWrapper(`Failed to get anchorId for keySSI ${keySSI.getIdentifier()}`, err));
                    }

                    const __storeAnchor = (anchorValue) => {
                        //signedHashLink should not contain any hint because is not trusted

                        const updateAnchorCallback = (err) => {
                            if (err) {
                                // In case of any errors, the compacted BrickMapDiff objects
                                // are put back into the "pending anchoring" state in case
                                // we need to retry the anchoring process
                                state.rollback(mergedDiffs);

                                // The anchoring middleware detected that we were trying
                                // to anchor outdated changes. In order to finish the anchoring
                                // process the conflict must be first resolved
                                if (isAliasSyncError(err)) {
                                    return this.handleAnchoringConflict(listener);
                                }

                                return endAnchoring(listener, anchoringStatus.ANCHOR_VERSION_ERR, err);
                            }

                            // After the alias is updated, the strategy is tasked
                            // with updating our anchored BrickMap with the new changes
                            strategy.afterBrickMapAnchoring(brickMap, anchorValue, (err, hashLink) => {
                                if (err) {
                                    return endAnchoring(listener, anchoringStatus.BRICKMAP_UPDATE_ERR, err);
                                }

                                endAnchoring(listener, anchoringStatus.OK, hashLink);

                                if (anchoringRequestExists()) {
                                    // Another anchoring was requested during the time this one
                                    // was in progress, as such, we start the process again
                                    this.anchorChanges(listener);
                                }
                            });
                        }

                        const currentAnchoredHashLink = state.getCurrentAnchoredHashLink();
                        /*if (!currentAnchoredHashLink) {
                            anchoring.createAnchor(keySSI, (err) => {
                                if (err) {
                                    return OpenDSUSafeCallback(listener)(createOpenDSUErrorWrapper(`Failed to create anchor`, err));
                                }

                                anchoring.appendToAnchor(keySSI, signedHashLink, '', updateAnchorCallback);
                            });
                        } else {
                            anchoring.appendToAnchor(keySSI, signedHashLink, currentAnchoredHashLink, updateAnchorCallback);
                        }*/

                        if(anchoringx.testIfRecoveryActiveFor(anchorId)){
                            if(!keySSI.canAppend()){
                                //if we are in recovery mode, and we are const keyssi type then we don't create the anchor
                                return updateAnchorCallback();
                            }
                            //if in recovery then we faked the last hashlink even if we couldn't load...
                            return anchoringx.appendAnchor(anchorId, anchorValue, updateAnchorCallback);
                        }

                        //TODO: update the smart contract and after that uncomment the above code and eliminate the following if statement
                        if (!currentAnchoredHashLink) {
                            anchoringx.getLastVersion(keySSI, (err, version) => {
                                if (err || !version) {
                                    // return OpenDSUSafeCallback(listener)(createOpenDSUErrorWrapper(`Failed to retrieve versions of anchor`, err));
                                    return anchoringx.createAnchor(anchorId, anchorValue, updateAnchorCallback);
                                }
                                return listener(createOpenDSUErrorWrapper(`Failed to create anchor`, err));
                            });
                        } else {
                            anchoringx.getLastVersion(keySSI, (err, version) => {
                                if (err || !version) {
                                    return listener(createOpenDSUErrorWrapper(`Failed to retrieve last anchor version`, err));
                                }

                                if (!anchoringx.testIfRecoveryActiveFor(anchorId) && version.getIdentifier() !== currentAnchoredHashLink.getIdentifier()) {
                                    return updateAnchorCallback({statusCode: 428, message: "Versions out of sync"})
                                }

                                anchoringx.appendAnchor(anchorId, anchorValue, updateAnchorCallback);
                            });
                        }
                    }

                    let lastEntryInAnchor;
                    let getCurrentHashLink = (callback) => {
                        callback(undefined, state.getCurrentAnchoredHashLink());
                    }

                    if (anchoringx.testIfRecoveryActiveFor(anchorId)) {
                        getCurrentHashLink = (callback) => {
                            return anchoringx.getLastVersion(anchorId, callback);
                        }
                    }

                    let proceed = (lastEntryInAnchor) => {
                        keySSI.createAnchorValue(hash, lastEntryInAnchor, (err, anchorValue) => {
                            if (err) {
                                return OpenDSUSafeCallback(listener)(createOpenDSUErrorWrapper(`The SSI type does not have write access`, err));
                            }

                            __storeAnchor(anchorValue);
                        });
                    }

                    if (state.getCurrentAnchoredHashLink() || anchoringx.testIfRecoveryActiveFor(anchorId)) {
                        return getCurrentHashLink((err, lastHashLink) => {
                            if (err) {
                                //ignorable error. can't happen
                            }
                            if (typeof lastHashLink === "string") {
                                lastHashLink = keySSISpace.parse(lastHashLink);
                            }
                            lastEntryInAnchor = lastHashLink.getIdentifier();
                            proceed(lastEntryInAnchor);
                        })
                    }
                    proceed(lastEntryInAnchor);
                });

            })
        });
    }

    /**
     * If an anchoring conflict occurs, reload our anchored BrickMap
     * in order to get the new changes and then try to merge our BrickMapDiff
     * instances
     *
     * @param {callback} listener
     */
    this.handleAnchoringConflict = (listener) => {
        const currentAnchoredHashLinkSSI = strategy.getCurrentHashLink();
        strategy.load(keySSI, (err, brickMap) => {
            if (err) {
                return endAnchoring(listener, anchoringStatus.BRICKMAP_LOAD_ERR, err);
            }
            state.setCurrentAnchoredHashLink(strategy.getCurrentHashLink());

            // Try and merge our changes
            strategy.reconcile(brickMap, currentAnchoredHashLinkSSI, (err, result) => {
                if (err) {
                    return endAnchoring(listener, anchoringStatus.BRICKMAP_RECONCILE_ERR, err);
                }

                anchoringInProgress = false;

                if (!result.status) {
                    return endAnchoring(listener, anchoringStatus.BRICKMAP_RECONCILIATION_HANDOFF)
                }
                this.anchorChanges(listener, result.brickMap);
            });
        });
    }

    /**
     * @return {boolean}
     */
    this.hasUnanchoredChanges = () => {
        return state.hasNewDiffs() || anchoringRequestExists();
    }

    /**
     * @return {object}
     */
    this.getState = () => {
        return state;
    }

    this.getCurrentAnchoredHashLink = () => {
        return state.getCurrentAnchoredHashLink();
    }


    /**
     * Toggle notifications publishing for new anchors
     * @param {boolean} status
     */
    this.enableAnchoringNotifications = (status) => {
        publishAnchoringNotifications = status;
    }

    /**
     * @return {boolean}
     */
    this.anchoringNotificationsEnabled = () => {
        return publishAnchoringNotifications;
    }

    /**
     * Load the latest BrickMaps then try and merge
     * the latest changes
     * @param {function} callback
     */
    this.mergeUpstreamChanges = (callback) => {
        const currentAnchoredHashLinkSSI = strategy.getCurrentHashLink();
        strategy.load(keySSI, (err, brickMap) => {
            if (err) {
                return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to load brickMap`, err));
            }

            strategy.merge(brickMap, currentAnchoredHashLinkSSI, (err, result) => {
                if (err) {
                    return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to merge latest DSU changes`, err));
                }


                callback(undefined, result.status);
            })
        })
    }

    initialize();
}

module.exports = BrickMapController;

},{"./AnchorValidator":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/bar/lib/AnchorValidator.js","./Brick":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/bar/lib/Brick.js","./BrickMap":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/bar/lib/BrickMap.js","./BrickMapDiff":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/bar/lib/BrickMapDiff.js","./BrickMapStrategy":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/bar/lib/BrickMapStrategy/index.js","./constants":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/bar/lib/constants.js","opendsu":"opendsu","swarmutils":"swarmutils"}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/bar/lib/BrickMapDiff.js":[function(require,module,exports){
'use strict';

const BrickMapMixin = require('./BrickMapMixin');

/**
 * Auguments a BrickMap with an operations
 * log
 * @param {object} options
 * @param {string} options.prevDiffHash
 */
function BrickMapDiff(header) {
    Object.assign(this, BrickMapMixin);
    this.initialize(header);

    this.initialize = function (header, callback) {
        if (typeof header === "function") {
            callback = header;
            header = undefined;
        }

        BrickMapMixin.initialize.call(this, header);
        this.load((err) => {
            if (err) {
                return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to load BrickMapDiff`, err));
            }

            if (!this.header.metadata.log) {
                this.header.metadata.log = [];
            }

            callback();
        });
    }

    /**
     * @param {BrickMapDiff} brickMap
     * @throws {Error}
     */
    this.applyDiff = function (brickMap) {
        if (brickMap.constructor !== BrickMapDiff) {
            throw new Error('Unable to merge: expected a BrickMapDiff instance')
        }

        const metadata = brickMap.getMetadata('/');
        const operationsLog = metadata.log;

        if (!Array.isArray(operationsLog)) {
            throw new Error('Invalid BrickMapDiff. No replay log found');
        }

        if (!operationsLog.length) {
            return;
        }

        for (const operation of operationsLog) {
            const data = (typeof operation.data !== 'undefined') ? JSON.parse(JSON.stringify(operation.data))
                                                                 : operation.data;
            this.log(operation.op, operation.path, data);
        }
        this.updateMetadata('/', 'updatedAt', this.getTimestamp());
    }

    /**
     * @return {boolean}
     */
    this.hasItems = function () {
        return this.header.metadata.log.length > 0;
    };

    this.setPrevDiffHashLink = function (hashLink) {
        if (typeof hashLink === 'undefined') {
            return;
        }
        this.header.metadata.prevDiffHashLink = hashLink.getIdentifier();
    }

    /**
     * @param {string} op
     * @param {string} path
     * @param {object|undefined} data
     */
    this.log = function (op, path, data) {
        const timestamp = this.getTimestamp()
        this.header.metadata.log.push({ op, path, timestamp, data });
    }

    /**
     * @param {string} path
     * @param {Array<object>} bricks
     */
    this.addFileEntry = function (path, bricks) {
        this.log('add', path, bricks);
    }

    /**
     * @param {string} path
     * @param {Array<object>} bricks
     */
    this.appendBricksToFile = function (path, bricks) {
        this.log('add', path, bricks);
    }

    /**
     * @param {string} path
     */
    this.emptyList = function (path) {
        this.log('truncate', path);
    }

    /**
     * @param {string} path
     */
    this.delete = function (path) {
        this.log('delete', path);
    }

    /**
     * @param {string} srcPath
     * @param {string} dstPath
     */
    this.copy = function (srcPath, dstPath) {
        this.log('copy', srcPath, dstPath)
    }

    /**
     * @param {string} path
     */
    this.createFolder = function (path) {
        this.log('createFolder', path);
    }

    /**
     * @param {string} path
     */
    this.createFile = function (path) {
        this.log('createFile', path);
    }

    /**
     * @param {string} filePath
     * @param {object} brick
     */
    this.replaceFirstBrick = function (filePath, brick) {
        this.log('replaceFirstBrick', filePath, brick);
    }

    /**
     * @param {string} filePath
     * @param {object} brick
     */
    this.replaceLastBrick = function (filePath, brick) {
        this.log('replaceLastBrick', filePath, brick);
    }

    this.putEmbeddedFile = function(filePath, data) {
        this.log('embed', filePath, data);
    }

    this.appendToEmbedded = function(filePath, data){
        this.log('appendToEmbed', filePath, data);
    }
}
module.exports = BrickMapDiff;

},{"./BrickMapMixin":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/bar/lib/BrickMapMixin.js"}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/bar/lib/BrickMapMixin.js":[function(require,module,exports){
'use strict';

const Brick = require("./Brick");
const pskPath = require("swarmutils").path;
const pathModule = "path";
let path;
try {
    path = require(pathModule);
} catch (err) {
} finally {
    if (typeof path === "undefined") {
        path = {sep: "/"};
    }
}

const BrickMapMixin = {
    header: null,
    templateKeySSI: null,

    /**
     * @param {Brick|string|object} header
     */
    initialize: function (header, options) {
        options = options || {};
        this.header = header;
        if (this.header) {
            if(typeof this.header === "object" && !this.header.embedded){
                //for backwards compatibility reasons
                this.header.embedded = {};
            }
            return;
        }

        this.header = {
            v: 1,
            items: {},
            metadata: {},
            embedded: {}
        }

        if (!options.disableTimeMetadata) {
            this.header.metadata.createdAt = this.getTimestamp();
        }
    },

    updateTimeMetadata: function (target, prop, timestamp) {
        if (typeof target === "string") {
            target = this.getDeepestNode(target);
        }

        if(!target){
            return ;
        }

        prop = prop || "updatedAt";
        timestamp = timestamp || this.getTimestamp();
        if (this.header.metadata.createdAt) {
            if (!target.metadata) {
                target.metadata = {};
            }
            target.metadata[prop] = timestamp;
        }
    },

    /**
     * @return {boolean}
     */
    hasItems: function () {
        return Object.keys(this.header.items).length > 0 || (this.header.embedded && Object.keys(this.header.embedded).length > 0);
    },

    /**
     * @return {string}
     */
    getTimestamp: function () {
        return new Date().toUTCString();
    },

    /**
     * @param {object} node
     * @param {object} brick
     */
    appendBrick: function (node, brick) {
        this.updateTimeMetadata(node);
        node.hashLinks.push(brick);
    },

    /**
     * @param {string} filePath
     */
    getNodeFromPath: function (filePath) {
        filePath = pskPath.normalize(filePath);
        if (filePath === "") {
            throw new Error(`File path must not be empty.`);
        }

        const filePathNode = this.createNodesFromPath(filePath);
        // If this node was previously deleted, remove the "deletedAt" timestamp
        if (filePathNode.metadata.deletedAt) {
            delete filePathNode.metadata.deletedAt;
        }

        return filePathNode;
    },

    /**
     * @param {string} filePath
     * @param {object} brick
     */
    replaceFirstBrick: function (filePath, brick) {
        const node = this.getNodeFromPath(filePath);
        this.updateTimeMetadata(node);
        if (node.hashLinks.length > 0) {
            node.hashLinks[0] = brick;
        }
    },

    /**
     * @param {string} filePath
     * @param {object} brick
     */
    replaceLastBrick: function (filePath, brick) {
        const node = this.getNodeFromPath(filePath);
        this.updateTimeMetadata(node);
        if (node.hashLinks.length > 0) {
            node.hashLinks[node.hashLinks.length - 1] = brick;
        }
    },

    /**
     * @param {object} parent
     * @param {string} name
     */
    createFileNode: function (parent, name) {
        const node = {
            hashLinks: [],
            metadata: {}
        };
        parent.items[name] = node;
        this.updateTimeMetadata(node, "createdAt");
    },

    /**
     * @param {object} root
     * @param {string} name
     */
    createDirectoryNode: function (root, name) {
        const node = {
            metadata: {},
            items: {}
        }
        root.items[name] = node;
        this.updateTimeMetadata(node, "createdAt");
    },

    /**
     * Create all the nodes required to traverse `path`
     * and return the deepest node in the tree
     *
     * @param {string} path
     * @param {object} options
     * @param {string} options.trailingNodeType Possible values are 'child' or 'parent'
     * @return {object}
     */
    createNodesFromPath: function (path, options) {
        options = options || {
            trailingNodeType: 'child',
            addCreatedAtTimestamp: true
        };

        const pathSegments = path.split('/');

        let parentNode = this.header;
        let nodeName;

        while (pathSegments.length) {
            nodeName = pathSegments.shift();
            if (nodeName === "") {
                nodeName = pathSegments.shift();
            }

            if (parentNode.items[nodeName]) {
                delete parentNode.items[nodeName].metadata.deletedAt;
            }

            if (typeof parentNode.metadata === 'object') {
                // remove the "deletedAt" attribute in case we're trying
                // to add an entry in a previously deleted folder
                delete parentNode.metadata.deletedAt;
            }

            if (!pathSegments.length) {
                break;
            }


            if (!parentNode.items[nodeName]) {
                this.createDirectoryNode(parentNode, nodeName);
            }
            parentNode = parentNode.items[nodeName];
        }

        if (!parentNode.items[nodeName]) {
            if (options.trailingNodeType === 'child') {
                this.createFileNode(parentNode, nodeName);
            } else {
                this.createDirectoryNode(parentNode, nodeName);
            }
        }

        return parentNode.items[nodeName];
    },

    /**
     * @param {string} nodePath
     * @return {string} Returns a parent directory's path
     */
    dirname: function (path) {
        const segments = path.split('/');
        return segments.slice(0, -1).join('/');
    },

    /**
     * @param {string} nodePath
     * @return {string} Returns trailing name component of a path
     */
    basename: function (path) {
        const segments = path.split('/');
        return segments.pop();
    },

    /**
     * @param {object} node
     * @return {boolean}
     */
    nodeIsDeleted: function (node) {
        return typeof node.metadata.deletedAt !== 'undefined';
    },

    /**
     * @param {object} node
     * @return {boolean}
     */
    nodeIsDirectory: function (node) {
        return typeof node.items === 'object';
    },

    /**
     * @param {object} node
     */
    deleteNode: function (node) {
        this.updateTimeMetadata(node, "deletedAt");
        if (this.nodeIsDirectory(node)) {
            node.items = {};
            return;
        }

        node.hashLinks = [];
    },

    /**
     * @param {object} node
     */
    truncateNode: function (node) {
        delete node.metadata.deletedAt;
        this.updateTimeMetadata(node);
        if (this.nodeIsDirectory(node)) {
            node.items = {};
        }

        node.hashLinks = [];
    },

    /**
     * Traverse the nodes identified by `toPath`
     * and return the deepest parent node in the tree
     *
     * @param {string} toPath
     * @return {object|undefined}
     */
    navigate: function (toPath) {
        let parentNode = this.header;
        const segments = toPath.split("/");

        for (let i in segments) {
            let segment = segments[i];
            if (!segment) {
                continue;
            }


            if (typeof parentNode.items[segment] === 'undefined') {
                return;
            }

            if (this.nodeIsDirectory(parentNode.items[segment])) {
                parentNode = parentNode.items[segment];

            }
        }

        return parentNode;
    },

    /**
     * Traverse `path` and return the deepest node
     * in the tree
     *
     * @param {string} path
     * @return {object}
     */
    getDeepestNode: function (path) {
        path = pskPath.normalize(path);
        if (path === '/') {
            return this.header;
        }

        const filename = this.basename(path);
        const dirPath = this.dirname(path);

        const parentNode = this.navigate(dirPath);

        if (!parentNode) {
            return;
        }

        return parentNode.items[filename];
    },


    /**
     * @param {string} path
     * @param {Array<object>} bricks
     */
    addFileEntry: function (path, bricks) {
        if (!this.isEmpty(path)) {
            this.emptyList(path);
        }

        this.appendBricksToFile(path, bricks);
    },

    /**
     * @param {string} path
     * @param {Array<object>} bricks
     */
    appendBricksToFile: function (path, bricks) {
        if (!Array.isArray(bricks)) {
            bricks = [bricks];
        }
        for (const data of bricks) {
            this.add(path, data);
        }
    },

    /**
     * Add brick data for `filePath`
     *
     * @param {string} filePath
     * @param {object} brick
     * @param {string} brick.hash
     * @param {object} brick.encryptionKey
     * @param {string} brick.checkSum
     *
     * @throws {Error}
     */
    add: function (filePath, brick) {
        filePath = pskPath.normalize(filePath);
        if (filePath === "") {
            throw new Error(`File path must not be empty.`);
        }

        const brickObj = {
            checkSum: brick.checkSum,
            hashLink: brick.hashLink
        };
        if (brick.size) {
            brickObj.size = brick.size;
        }

        if (brick.encryptionKey) {
            brickObj.key = brick.encryptionKey
        }

        const filePathNode = this.createNodesFromPath(filePath);
        // If this node was previously deleted, remove the "deletedAt" timestamp
        if (filePathNode.metadata.deletedAt) {
            delete filePathNode.metadata.deletedAt;
        }
        this.appendBrick(filePathNode, brickObj);
    },

    /**
     * @param {string} barPath
     * @throws {Error}
     */
    delete: function (barPath) {
        barPath = pskPath.normalize(barPath);
        const childNode = this.getDeepestNode(barPath);
        if (!childNode) {
            return;
        }
        if (this.nodeIsDeleted(childNode)) {
            return;
        }

        this.deleteNode(childNode);

        let deleteEmbedded = ()=>{
            if(this.header && this.header.embedded){
                let embeddedFiles = Object.keys(this.header.embedded);
                for(let filepath of embeddedFiles){
                    if(filepath.startsWith(barPath)){
                        delete this.header.embedded[filepath];
                    }
                }
            }
        }

        deleteEmbedded();
    },

    createNode: function (barPath, options) {
        barPath = pskPath.normalize(barPath);

        if (barPath === '/') {
            throw new Error('Invalid path: /');
        }

        const dirName = this.basename(barPath);
        const dirPath = this.dirname(barPath);
        const parentDir = this.getDeepestNode(dirPath);

        if (!dirName) {
            throw new Error('Missing folder name.');
        }

        if (dirPath && parentDir) {
            if (!this.nodeIsDirectory(parentDir)) {
                throw new Error('Unable to create a folder in a file.');
            }

            if (typeof parentDir.items[dirName] !== 'undefined' && options.trailingNodeType === "parent") {
                const currentNode = parentDir.items[dirName];
                if(this.nodeIsDeleted(currentNode)) {
                    // trying to create an already deleted node
                    // so we need remove the "deletedAt" timestamp
                    delete currentNode.metadata.deletedAt;
                    this.updateTimeMetadata(currentNode, "createdAt");
                    return;
                }

                throw new Error('Unable to create folder. A file or folder already exists in that location.');
            }
        }

        this.createNodesFromPath(barPath, options);
    },
    /**
     * Create an empty directory
     *
     * @param {string} barPath
     * @throws {Error}
     */
    createFolder: function (barPath) {
        this.createNode(barPath, {trailingNodeType: "parent"});
    },

    createFile: function (barPath) {
        this.createNode(barPath, {trailingNodeType: "child"});
    },
    /**
     * @param {string} filePath
     * @return {Array<object>}
     * @throws {Error}
     */
    getBricksMeta: function (filePath) {
        const fileNode = this.getDeepestNode(filePath);
        if (!fileNode) {
            throw new Error(`Path <${filePath}> not found.`);
        }
        if (this.nodeIsDirectory(fileNode)) {
            throw new Error(`Path <${filePath}> is a folder.`);
        }

        if (this.nodeIsDeleted(fileNode)) {
            throw new Error(`Path <${filePath}> not found.`);
        }

        return fileNode.hashLinks;
    },

    /**
     * @param {string} filePath
     * @return {Array<string>}
     * @throws {Error}
     */
    getHashList: function (filePath) {
        if (filePath === "") {
            throw new Error(`File path must not be empty.`);
        }

        const fileNode = this.getDeepestNode(filePath);
        if (!fileNode) {
            throw new Error(`Path <${filePath}> not found.`);
        }
        if (this.nodeIsDirectory(fileNode)) {
            throw new Error(`Path <${filePath}> is a folder.`);
        }

        const hashes = fileNode.hashLinks.map(brickObj => brickObj.hashLink);
        return hashes;
    },

    getEmbeddedFile: function (filePath) {
        if (filePath === "") {
            throw Error(`File path must not be empty.`);
        }

        let data;
        if (this.header.embedded && this.header.embedded[filePath]) {
            data = this.header.embedded[filePath].content;
        }

        return data;
    },

    putEmbeddedFile:  function (filePath, data) {
        if (filePath === "") {
            throw Error(`File path must not be empty.`);
        }

        if (!this.header.embedded) {
            this.header.embedded = {};
        }

        let embeddedFile = this.header.embedded[filePath];
        if(!embeddedFile){
            embeddedFile = {
                content: data,
                metadata:{}
            };
            this.header.embedded[filePath] = embeddedFile;
            this.updateTimeMetadata(embeddedFile, 'createdAt');
            return;
        }

        embeddedFile.content = data;
        this.updateTimeMetadata(embeddedFile);
    },

    appendToEmbedded: function (filePath, data) {
        let existingData = this.getEmbeddedFile(filePath);
        if (!existingData) {
            existingData = "";
        }

        this.putEmbeddedFile(filePath, existingData + data);
},
    /**
     * @param {string} filePath
     * @return {boolean}
     */
    isEmpty: function (filePath) {
        const node = this.getDeepestNode(filePath);
        if (!node) {
            return true;
        }

        if (this.nodeIsDirectory(node)) {
            return !Object.keys(node.items);
        }
        return !node.hashLinks.length;
    },

    /**
     * Truncates `filePath`
     * @param {string} filePath
     * @throws {Error}
     */
    emptyList: function (filePath) {
        const node = this.getDeepestNode(filePath);
        if (!node) {
            throw new Error(`Path <${filePath}> not found.`);
        }

        this.truncateNode(node);
    },

    /**
     * @param {string} path
     * @return {boolean}
     */
    fileExists: function (path) {
        const node = this.getDeepestNode(path);
        return node && !this.nodeIsDeleted(node);
    },

    /**
     * @param {string} path
     * @return {boolean}
     */
    fileDeleted: function (path) {
        const node = this.getDeepestNode(path);
        return node && this.nodeIsDeleted(node);
    },

    /**
     * @param {string} srcPath
     * @param {string} dstPath
     * @throws {Error}
     */
    copy: function (srcPath, dstPath) {
        const srcNode = this.getDeepestNode(srcPath);
        if (!srcNode) {
            throw new Error(`Source path <${srcPath}> not found.`);
        }

        const dstNode = this.createNodesFromPath(dstPath, {
            trailingNodeType: this.nodeIsDirectory(srcNode) ? 'parent' : 'child',
            addCreatedAtTimestamp: true
        });

        if (this.nodeIsDirectory(srcNode)) {
            // Clone hashlinks
            dstNode.items = JSON.parse(JSON.stringify(srcNode.items));
            return;
        }

        dstNode.hashLinks = JSON.parse(JSON.stringify(srcNode.hashLinks));
    },


    /**
     * @return {Brick}
     */
    toBrick: function () {
        let brickOptions = {templateKeySSI: this.templateKeySSI, brickMap: true};
        let hint = this.templateKeySSI.getHint();
        if(hint && hint.get("avoidRandom")){
            brickOptions.avoidRandom = true;
        }
        const brick = new Brick(brickOptions);
        brick.setKeySSI(this.templateKeySSI);
        brick.setRawData($$.Buffer.from(JSON.stringify(this.header)));
        return brick;
    },


    /**
     * @param {string} folderBarPath
     * @param {boolean} recursive
     * @return {Array<string>}
     */
    getFileList: function (folderBarPath, recursive) {
        let listEmbeddedFiles = ()=>{
            let files = [];
            if(this.header.embedded){
                if(recursive){
                    let embeddedFiles = Object.keys(this.header.embedded);
                    for(let filePath of embeddedFiles){
                        if(filePath.startsWith(folderBarPath)){
                            files.push(filePath.replace(folderBarPath, ""));
                        }
                    }
                }else{
                    let embeddedFiles = Object.keys(this.header.embedded);
                    for(let filePath of embeddedFiles){
                        if(filePath.startsWith(folderBarPath)){
                            let relativePath = filePath.replace(folderBarPath, "");
                            if(relativePath.indexOf("/")===-1){
                                files.push(relativePath);
                            }else{
                                //we skip this file because seems to be a directory (contains at least one more / character)
                            }
                        }
                    }
                }
            }
            return files;
        }

        if (typeof recursive === "undefined") {
            recursive = true;
        }
        const node = this.getDeepestNode(folderBarPath);
        if (!node) {
            let embeddedFiles = listEmbeddedFiles();
            return embeddedFiles;
        }

        const findFiles = (nodes, currentPath) => {
            let files = [];
            currentPath = currentPath || '';

            for (const itemName in nodes) {
                const item = nodes[itemName];
                const itemPath = pskPath.join(currentPath, itemName);

                if (this.nodeIsDirectory(item) && recursive) {
                    files = files.concat(findFiles(item.items, itemPath));
                    continue;
                }

                if (!this.nodeIsDeleted(item) && !this.nodeIsDirectory(item)) {
                    files.push(itemPath);
                }

            }

            return files;
        }

        const files = findFiles(node.items);
        const embeddedFiles = listEmbeddedFiles(files);

        return files.concat(embeddedFiles);
    },

    /**
     * @param {string} barPath
     * @param {boolean} recursive
     * @return {Array<string>}
     */
    getFolderList: function (barPath, recursive) {
        const node = this.getDeepestNode(barPath);
        if (!node) {
            return [];
        }

        const findFolders = (nodes, currentPath) => {
            let folders = [];
            currentPath = currentPath || '';

            for (const itemName in nodes) {
                const item = nodes[itemName];
                const itemPath = pskPath.join(currentPath, itemName);

                if (!this.nodeIsDirectory(item) || this.nodeIsDeleted(item)) {
                    continue;
                }

                folders.push(itemPath);

                if (recursive) {
                    folders = folders.concat(findFolders(item.items, itemPath));

                }
            }

            return folders;
        }

        const folders = findFolders(node.items);
        return folders;
    },

    getBrickEncryptionKeySSI: function (brickMeta) {
        if (typeof brickMeta === "undefined") {
            return this.templateKeySSI.getIdentifier();
        }

        return brickMeta.key;
    },

    /**
     * Load BrickMap state
     */
    load: function (callback) {
        /**
         * JSON reviver callback
         * Convert serialized $$.Buffer to $$.Buffer instance
         * @param {string} key
         * @param {string} value
         * @return {*}
         */
        const reviver = (key, value) => {
            if (key !== 'key') {
                return value;
            }

            if (typeof value !== 'object') {
                return value;
            }

            if (Object.keys(value).length !== 2) {
                return value;
            }

            if (value.type !== '$$.Buffer' || !Array.isArray(value.data)) {
                return value;
            }
            return $$.Buffer.from(value.data);
        };

        if (this.header instanceof Brick) {
            this.header.setKeySSI(this.templateKeySSI);
            this.header.setKeySSI(this.templateKeySSI.getIdentifier());
            this.header.getRawData((err, rawData) => {
                if (err) {
                    return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to get raw data`, err));
                }

                this.header = JSON.parse(rawData.toString(), reviver);
                callback();
            });
        } else {
            if ($$.Buffer.isBuffer(this.header)) {
                this.header = this.header.toString();
            }

            if (typeof this.header === "string") {
                this.header = JSON.parse(this.header, reviver);
            }
            callback();
        }
    },

    /**
     * @param {KeySSI} keySSI
     */
    setKeySSI: function (keySSI) {
        this.templateKeySSI = keySSI;
    },

    /**
     * @return {KeySSI}
     */
    getTemplateKeySSI: function () {
        return this.templateKeySSI;
    },

    /**
     * @return {BrickMap}
     */
    clone: function (callback) {
        const InstanceClass = this.constructor;
        const brickMap = new InstanceClass(JSON.stringify(this.header));
        brickMap.setKeySSI(this.templateKeySSI);
        brickMap.load((err) => {
            if (err) {
                return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to load brickMap`, err));
            }

            callback(undefined, brickMap);
        });
    },

    /**
     * @return {object}
     */
    getState: function () {
        return JSON.parse(JSON.stringify(this.header));
    },

    /**
     * @param {string} path
     * @return {object}
     * @throws {Error}
     */
    getMetadata: function (path) {
        const node = this.getDeepestNode(path);
        if (!node) {
            throw new Error(`Path <${path}> not found.`);
        }

        if (typeof node.metadata === 'undefined') {
            throw new Error(`Path dosn't have any metadata associated.`);
        }

        return node.metadata
    },

    /**
     * @param {object} metadata
     * @throws {Error}
     */
    setMetadata: function (path, metadata) {
        const node = this.getDeepestNode(path);
        if (!node) {
            throw new Error(`Path <${path}> not found.`);
        }
        node.metadata = JSON.parse(JSON.stringify(metadata));
    },

    /**
     * @param {string} path
     * @param {string} key
     * @param {*} value
     * @throws {Error}
     */
    updateMetadata: function (path, key, value) {
        const node = this.getDeepestNode(path);
        if (!node) {
            throw new Error(`Unable to update metadata. Path <${path}> not found.`);
        }

        node.metadata[key] = value;
    },

    getHashLink: function (callback) {
        const brick = this.toBrick();
        brick.setKeySSI(this.getBrickEncryptionKeySSI());
        brick.getHashLink(callback);
    },

    stat: function (path) {
        const node = this.getDeepestNode(path);
        if (this.nodeIsDirectory(node)) {
            return {type: "directory"}
        } else {
            return {type: "file"}
        }
    }
}

module.exports = BrickMapMixin;

},{"./Brick":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/bar/lib/Brick.js","swarmutils":"swarmutils"}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/bar/lib/BrickMapStrategy/BrickMapStrategyMixin.js":[function(require,module,exports){
const BrickMapStrategyMixin = {
    brickMapController: null,
    brickMapState: null,
    anchoringEventListener: null,
    conflictResolutionFunction: null,
    decisionFunction: null,
    signingFunction: null,
    cache: null,
    currentHashLink: null,
    validator: null,
    delay: null,
    anchoringTimeout: null,

    initialize: function (options) {
        if (typeof options.anchoringEventListener === 'function') {
            this.setAnchoringEventListener(options.anchoringEventListener);
        }

        if (typeof options.decisionFn === 'function') {
            this.setDecisionFunction(options.decisionFn);
        }

        if (typeof options.conflictResolutionFn === 'function') {
            this.setConflictResolutionFunction(options.conflictResolutionFn);
        }

        if (typeof options.signingFn === 'function') {
            this.setSigningFunction(options.signingFn);
        }

        if (typeof options.delay !== 'undefined' ) {
            if (!this.anchoringEventListener) {
                throw new Error("An anchoring event listener is required when choosing to delay anchoring");
            }
            this.delay = options.delay;
        }
    },

    /**
     * @param {BrickMapController} controller
     */
    setBrickMapController: function (controller) {
        this.brickMapController = controller;
    },

    /**
     * @param {object} state The BrickMap state
     */
    setBrickMapState: function (state) {
        this.brickMapState = state;
    },

    /**
     * @param {function} callback
     */
    setConflictResolutionFunction: function (fn) {
        this.conflictResolutionFunction = fn;
    },

    /**
     * @return {function}
     */
    getConflictResolutionFunction: function () {
        return this.conflictResolutionFunction;
    },

    /**
     *
     * @param {function} listener
     */
    setAnchoringEventListener: function (listener) {
        this.anchoringEventListener = listener;
    },

    /**
     * @param {function} fn
     */
    setSigningFunction: function (fn) {
        this.signingFunction = fn;
    },

    /**
     * @param {function} fn
     */
    setDecisionFunction: function (fn) {
        this.decisionFunction = fn;
    },

    /**
     * @return {function}
     */
    getDecisionFunction: function () {
        return this.decisionFunction;
    },

    /**
     * @param {object} validator 
     */
    setValidator: function (validator) {
        this.validator = validator;
    },

    /**
     * @param {psk-cache.Cache} cache 
     */
    setCache: function (cache) {
        this.cache = cache;
    },

    /**
     * @param {string} key 
     * @return {boolean}
     */
    hasInCache: function (key) {
        if (!this.cache) {
            return false;
        }

        return this.cache.has(key);
    },

    /**
     * @param {string} key 
     * @return {*}
     */
    getFromCache: function (key) {
        if (!this.cache) {
            return;
        }

        return this.cache.get(key);
    },

    /**
     * @param {string} key 
     * @param {*} value 
     */
    storeInCache: function (key, value) {
        if (!this.cache) {
            return;
        }

        this.cache.set(key, value)
    },

    /**
     *
     * @param {BrickMap} brickMap
     * @param {function} callback
     */
    ifChangesShouldBeAnchored: function (brickMap, callback) {
        if (typeof this.decisionFunction === 'function') {
            return this.decisionFunction(brickMap, callback);
        }

        if (this.delay !== null) {
            clearTimeout(this.anchoringTimeout);
            this.anchoringTimeout = setTimeout(() => {
                const anchoringEventListener = this.getAnchoringEventListener(function(){console.log("Anchoring...")});
                this.brickMapController.anchorChanges(anchoringEventListener);
            }, this.delay);
            return callback(undefined, false);
        }
        return callback(undefined, true);
    },

    /**
     * @return {string|null}
     */
    getCurrentHashLink: function () {
        return this.currentHashLink;
    },

    afterBrickMapAnchoring: function (diff, diffHash, callback) {
        throw new Error('Unimplemented');
    },

    load: function (alias, callback) {
        throw new Error('Unimplemented');
    },

    /**
     * Merge diffs into a single BrickMap object
     * Handles the case when the list of diffs contains
     * whole BrickMap objects
     *
     * @param {BrickMap} brickMap
     * @param {Array<BrickMapDiff>} diffs
     * @return {BrickMap}
     */
    mergeDiffs: function (brickMap, diffs) {
        if (!brickMap && (!Array.isArray(diffs) || !diffs.length)) {
            throw new Error('A target and a list of diffs is required');
        }

        const mergedDiffs = [];

        while (diffs.length) {
            const brickMapDiff = diffs.shift();
            mergedDiffs.push(brickMapDiff);
            brickMap.applyDiff(brickMapDiff);
        }

        return [brickMap, mergedDiffs];
    },

    /* Detect any merge conflicts
     * @param {BrickMap} theirBrickMap The latest anchored BrickMap
     * @param {BrickMap} ourBrickMap Our anchored brickmap
     * @param {KeySSI} ourHashLinkSSI
     */
    detectMergeConflicts: function (theirBrickMap, ourBrickMap, ourHashLinkSSI) {
        // Detect the upstream changeset
        /* @var {BrickMap} */
        const theirChanges = ourBrickMap.diff(theirBrickMap);

        // Check if any of our changes conflict with upstream changeset
        const filesInConflict = theirChanges.detectMergeConflicts(this.brickMapState.getDiffsForAnchoring());

        let conflicts;

        // Call the conflict resolution function if it is defined, or return with error
        if (filesInConflict) {
            conflicts = {
                files: filesInConflict,
                ourHashLinkSSI: ourHashLinkSSI.getIdentifier(),
                theirHashLinkSSI: this.brickMapState.getCurrentAnchoredHashLink().getIdentifier()
            };
        }
        return conflicts;
    },

    /**
     * Detect merge conflicts and if any, call the conflict resolution function
     * or call the callback with an error
     * @param {BrickMap} theirBrickMap The latest anchored BrickMap
     * @param {BrickMap} ourBrickMap Our anchored brickmap
     * @param {KeySSI} ourHashLinkSSI
     * @param {function} callback
     * @return {boolean} True if merge conflicts were detected, False otherwise
     */
    mergeConflictsHandled: function (theirBrickMap, ourBrickMap, ourHashLinkSSI, callback) {
        const mergeConflicts = this.detectMergeConflicts(theirBrickMap, ourBrickMap, ourHashLinkSSI);

        if (!mergeConflicts) {
            return false;
        }

        // Call the conflict resolution function if it is defined, or return with error
        if (typeof this.conflictResolutionFunction === 'function') {
            this.conflictResolutionFunction(mergeConflicts, (err) => {
                if (err) {
                    return callback(err);
                }

                callback(undefined, {
                    status: false
                });
            });
            return true;
        }

        const conflictError = new Error('Anchoring conflict error');
        conflictError.conflicts = mergeConflicts;
        callback(conflictError);
        return true;
    },

    /**
     * Merge remote changes. This method is used when subscring to remote changes
     * on this DSU
     * @param {BrickMap} theirBrickMap The latest anchored BrickMap
     * @param {KeySSI} ourHashLinkSSI
     * @param {function} callback
     */
    merge: function (theirBrickMap, ourHashLinkSSI, callback) {
        const state = this.brickMapState;

        const ourAnchoredBrickMap = state.getAnchoredBrickMap();
        state.prepareNewChangesForAnchoring((err) => {
            if (err) {
                return callback(err);
            }

            if (this.mergeConflictsHandled(theirBrickMap, ourAnchoredBrickMap, ourHashLinkSSI, callback)) {
                return;
            }

            theirBrickMap.clone((err, brickMap) => {
                if (err) {
                    return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to clone BrickMap`, err));
                }
                const dirtyBrickMap = theirBrickMap;

                // No conflicts detected, merge changes
                try {
                    const diffsForAnchoring = [...state.getDiffsForAnchoring()];
                    if (diffsForAnchoring.length) {
                        this.mergeDiffs(dirtyBrickMap, diffsForAnchoring);
                    }
                } catch (e) {
                    return callback(e);
                }

                state.setDirtyBrickMap(dirtyBrickMap);
                state.setAnchoredBrickMap(brickMap);
                state.setCurrentAnchoredHashLink(this.getCurrentHashLink());
                return callback(undefined, {
                    status: true
                });
            })
        });
    },


    /**
     * @param {function} defaultListener
     * @return {function}
     */
    getAnchoringEventListener: function (defaultListener) {
        let anchoringEventListener = this.anchoringEventListener;
        if (typeof anchoringEventListener !== 'function') {
            anchoringEventListener = defaultListener;
        }

        return anchoringEventListener;
    }
}

module.exports = BrickMapStrategyMixin;

},{}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/bar/lib/BrickMapStrategy/DiffStrategy.js":[function(require,module,exports){
'use strict';

const BrickMapDiff = require('../../lib/BrickMapDiff');
const BrickMap = require('../BrickMap');
const BrickMapStrategyMixin = require('./BrickMapStrategyMixin');
/**
 * @param {object} options
 * @param {callback} options.decisionFn Callback which will decide when to effectively anchor changes
 *                                                              If empty, the changes will be anchored after each operation
 * @param {callback} options.conflictResolutionFn Callback which will handle anchoring conflicts
 *                                                              The default strategy is to reload the BrickMap and then apply the new changes
 * @param {callback} options.anchoringCb A callback which is called when the strategy anchors the changes
 * @param {callback} options.signingFn  A function which will sign the new alias
 * @param {callback} callback
 */
function DiffStrategy(options) {
    options = options || {};
    Object.assign(this, BrickMapStrategyMixin);
    const openDSU = require("opendsu")
    const anchoring = openDSU.loadAPI("anchoring");
    const anchoringx = anchoring.getAnchoringX();
    const bricking = openDSU.loadAPI("bricking");
    ////////////////////////////////////////////////////////////
    // Private methods
    ////////////////////////////////////////////////////////////


    /**
     *
     * @param {Array<BrickMapDiff>} brickMapDiffs
     * @param {callback} callback
     */
    const createBrickMapFromDiffs = (brickMapDiffs, callback) => {
        this.brickMapController.createBrickMap((err, brickMap) => {
            if (err) {
                return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to create a new BrickMap`, err));
            }

            try {
                for (const brickMapDiff of brickMapDiffs) {
                    brickMap.applyDiff(brickMapDiff);
                }
            } catch (e) {
                return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to apply diffs on brickMap`, e));
            }

            callback(undefined, brickMap);

        });
    }

    /**
     * @param {Array<string>} hashLinks
     * @return {string}
     */
    const createBricksCacheKey = (hashLinks) => {
        return hashLinks.map(hashLink => {
            return hashLink.getIdentifier();
        }).join(':');
    };

    /**
     * @param {Array<Brick>} bricks
     * @return {Array<BrickMapDiff}
     */
    const createDiffsFromBricks = (bricks, callback) => {
        const diffs = [];
        const __createDiffsRecursively = (_bricks) => {
            if (_bricks.length === 0) {
                return callback(undefined, diffs);
            }

            const brick = _bricks.shift();
            this.brickMapController.createBrickMapDiff(brick, (err, brickMap) => {
                if (err) {
                    return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to create diffs from bricks`, err));
                }

                diffs.push(brickMap);
                __createDiffsRecursively(_bricks);
            });
        };

        __createDiffsRecursively(bricks);
    }

    /**
     * Get the list of BrickMapDiffs either from cache
     * or from Brick storage
     *
     * @param {Array<string>} hashLinks
     * @param {callback} callback
     */
    const getBrickMapDiffs = (hashLinks, callback) => {
        const cacheKey = createBricksCacheKey(hashLinks);
        if (this.hasInCache(cacheKey)) {
            const brickMapDiffs = this.getFromCache(cacheKey);
            return callback(undefined, brickMapDiffs);
        }

        const TaskCounter = require("swarmutils").TaskCounter;
        const bricks = [];
        const taskCounter = new TaskCounter(() => {
            createDiffsFromBricks(bricks, (err, brickMapDiffs) => {
                if (err) {
                    return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to create diffs from bricks`, err));
                }

                this.storeInCache(cacheKey, brickMapDiffs);
                callback(undefined, brickMapDiffs);
            });
        });
        taskCounter.increment(hashLinks.length);
        bricking.getMultipleBricks(hashLinks, (err, brickData) => {
            if (err) {
                return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to retrieve multiple bricks`, err));
            }

            bricks.push(createBrick(brickData));
            taskCounter.decrement();
        });
    }

    const createBrick = (brickData) => {
        const Brick = require("../../lib/Brick");
        const brick = new Brick();
        brick.setTransformedData(brickData);
        return brick;
    };
    /**
     * Assemble a final BrickMap from several BrickMapDiffs
     * after validating the history
     *
     * @param {Array<string>} hashLinks
     * @param {callback} callback
     */
    const assembleBrickMap = (hashLinks, callback) => {
        this.currentHashLink = hashLinks[hashLinks.length - 1];
        getBrickMapDiffs(hashLinks, (err, brickMapDiffs) => {
            if (err) {
                return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to retrieve brickMap diffs`, err));
            }

            this.validator.validate('brickMapHistory', brickMapDiffs, (err) => {
                if (err) {
                    return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to validate brickMapDiffs`, err));
                }

                createBrickMapFromDiffs(brickMapDiffs, callback);
            });
        })
    }


    ////////////////////////////////////////////////////////////
    // Public methods
    ////////////////////////////////////////////////////////////

    this.load = (keySSI, callback) => {
        keySSI.getAnchorId((err, anchorId) => {
            if (err) {
                return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to get anchorId for keySSI ${keySSI.getIdentifier()}`, err));
            }
            anchoringx.getAllVersions(keySSI, (err, hashLinks) => {
                if (err) {
                    return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to retrieve versions for anchor ${anchorId}`, err));
                }

                if (!hashLinks.length) {
                    return callback(new Error(`No data found for anchor <${anchorId}>`));
                }

                assembleBrickMap(hashLinks, callback);
            });
        })
    }


    /**
     * Compact a list of BrickMapDiff objects
     * into a single BrickMap object
     *
     * @param {BrickMap|undefined} dstBrickMap
     * @return {BrickMapDiff}
     */
    this.compactDiffs = (dstBrickMap, callback) => {
        if (typeof dstBrickMap === 'function') {
            callback = dstBrickMap;
            dstBrickMap = undefined;
        }
        this.brickMapState.prepareNewChangesForAnchoring((err) => {
            if (err) {
                return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to prepare diffs for anchoring`, err));
            }

            const mergedDiffs = (dstBrickMap, callback) => {
                const diffsForAnchoring = this.brickMapState.getDiffsForAnchoring();
                let result;
                let error;
                try {
                    result = this.mergeDiffs(dstBrickMap, diffsForAnchoring);
                } catch (e) {
                    error = e;
                }
                callback(error, result);
            }

            if (!dstBrickMap) {
                return this.brickMapController.createBrickMapDiff((err, dstBrickMap) => {
                    if (err) {
                        return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to create empty BrickMapDiff`, err));
                    }

                    mergedDiffs(dstBrickMap, callback);
                })

            }

            mergedDiffs(dstBrickMap, callback);
        })
    }

    /**
     * Merge the `diff` object into the current valid
     * BrickMap object
     *
     * @param {BrickMapDiff} diff
     * @param {string} diffHash
     * @param {callback} callback
     */
    this.afterBrickMapAnchoring = (diff, diffHash, callback) => {
        const anchoredBrickMap = this.brickMapState.getAnchoredBrickMap();
        try {
            anchoredBrickMap.applyDiff(diff);
        } catch (e) {
            return callback(e);
        }
        this.currentHashLink = diffHash;
        this.lastAnchorTimestamp = new Date().getTime();
        this.brickMapState.setCurrentAnchoredHashLink(diffHash);
        callback(undefined, diffHash);
    }


    /**
     * Try and fix an anchoring conflict
     *
     * Merge any "pending anchoring" BrickMapDiff objects in a clone
     * of our anchored BrickMap. If merging fails, call the 'conflictResolutionFn'
     * in order to fix the conflict. If merging succeeds, update the "dirtyBrickMap"
     *
     * If no 'conflictResolutionFn' function was defined
     * The callback will be called with the following error:
     *
     *  error: Error {
     *      message: 'Anchoring conflict error',
     *      conflicts: {
     *          files: {
     *              '/file/path/in/conflict': {
     *                  error: 'LOCAL_OVERWRITE|REMOTE_DELETE|LOCAL_DELETE', // type of conflict
     *                  message: '[User friendly error message]'
     *              },
     *              ...
     *          },
     *          theirHashLinkSSI: '...', // HashLinkSSI of the latest anchored BrickMap
     *          ourHashLinkSSI: '...' // The HashLinkSSI of our version
     *      }
     *  }
     *
     *  Where conflicts.*.error:
     *      LOCAL_OVERWRITE - Our changes will overwrite a newly anchored file/directory
     *      REMOTE_DELETE - The file path we're trying to anchor has been deleted
     *      LOCAL_DELETE - Our changes will delete a newly anchored file/directory
     *
     * If a 'conflictResolutionFn' is defined it will be called with the following arguments:
     *  conflicts - The conflicts object described above
     *  callback
     *
     * @param {BrickMap} theirBrickMap The latest anchored BrickMap
     * @param {KeySSI} ourHashLinkSSI
     * @param {function} callback
     */
    this.reconcile = (theirBrickMap, ourHashLinkSSI, callback) => {
        const state = this.brickMapState;

        const ourAnchoredBrickMap = state.getAnchoredBrickMap();
        state.prepareNewChangesForAnchoring((err) => {
            if (err) {
                return callback(err);
            }

            if (this.mergeConflictsHandled(theirBrickMap, ourAnchoredBrickMap, ourHashLinkSSI, callback)) {
                return;
            }

            // We only need to update the dirty brick map
            // The BrickMapController will compact our diffs and try to anchor them again
            try {
                this.mergeDiffs(theirBrickMap, [...state.getDiffsForAnchoring()]);
                state.setDirtyBrickMap(theirBrickMap);
            } catch (e) {
                return callback(e);
            }
            callback(undefined, {
                status: true
            });
        });
    }

    this.initialize(options);
}

module.exports = DiffStrategy;

},{"../../lib/Brick":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/bar/lib/Brick.js","../../lib/BrickMapDiff":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/bar/lib/BrickMapDiff.js","../BrickMap":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/bar/lib/BrickMap.js","./BrickMapStrategyMixin":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/bar/lib/BrickMapStrategy/BrickMapStrategyMixin.js","opendsu":"opendsu","swarmutils":"swarmutils"}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/bar/lib/BrickMapStrategy/LatestVersionStrategy.js":[function(require,module,exports){
'use strict';

const BrickMapDiff = require('../BrickMapDiff');
const BrickMap = require('../BrickMap');
const BrickMapStrategyMixin = require('./BrickMapStrategyMixin');
const Brick = require("../../lib/Brick");

/**
 * @param {object} options
 * @param {function} options.decisionFn Callback which will decide when to effectively anchor changes
 *                                                              If empty, the changes will be anchored after each operation
 * @param {function} options.anchoringCb A callback which is called when the strategy anchors the changes
 * @param {function} options.signingFn  A function which will sign the new alias
 * @param {function} callback
 */
function LatestVersionStrategy(options) {
    options = options || {};
    Object.assign(this, BrickMapStrategyMixin);
    const openDSU = require("opendsu");
    const anchoring = openDSU.loadAPI("anchoring");
    const anchoringx = anchoring.getAnchoringX();
    const bricking = openDSU.loadAPI("bricking");
    ////////////////////////////////////////////////////////////
    // Private methods
    ////////////////////////////////////////////////////////////

    /**
     * @param {Array<string>} hashes
     * @return {string}
     */
    const createBricksCacheKey = (hashes) => {
        return hashes.map(hash => {
            return hash.getIdentifier();
        }).join(':');
    };

    /**
     * @param {Array<Brick>} bricks
     * @return {Array<BrickMapDiff}
     */
    const createMapsFromBricks = (bricks, callback) => {
        const brickMaps = [];
        const __createBrickMapsRecursively = (_bricks) => {
            if (_bricks.length === 0) {
                return callback(undefined, brickMaps);
            }

            const brick = _bricks.shift();
            this.brickMapController.createBrickMap(brick, (err, brickMap) => {
                if (err) {
                    return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to create a new BrickMap`, err));
                }

                brickMaps.push(brickMap);
                __createBrickMapsRecursively(_bricks);
            });
        };

        __createBrickMapsRecursively(bricks);
    }

    /**
     * Get a list of BrickMap objects either from cache
     * or from Brick storage
     *
     * @param {Array<string>} hashes
     * @param {function} callback
     */
    const createBrickMapsFromHistory = (hashes, callback) => {
        callback = $$.makeSaneCallback(callback);
        const cacheKey = createBricksCacheKey(hashes);
        if (this.hasInCache(cacheKey)) {
            const brickMaps = this.getFromCache(cacheKey);
            return callback(undefined, brickMaps);
        }

        const TaskCounter = require("swarmutils").TaskCounter;
        const bricks = [];
        const taskCounter = new TaskCounter(() => {
            createMapsFromBricks(bricks, (err, brickMaps) => {
                if (err) {
                    return callback(createOpenDSUErrorWrapper(`Failed to create maps from bricks`, err));
                }

                this.storeInCache(cacheKey, brickMaps);
                callback(undefined, brickMaps);
            });
        });
        taskCounter.increment(hashes.length);
        bricking.getMultipleBricks(hashes, (err, brickData) => {
            if (err) {
                return callback(createOpenDSUErrorWrapper(`Failed to retrieve multiple bricks`, err));
            }

            bricks.push(createBrick(brickData));
            taskCounter.decrement();
        });
    }

    const createBrick = (brickData) => {
        const brick = new Brick();
        brick.setTransformedData(brickData);
        return brick;
    };

    ////////////////////////////////////////////////////////////
    // Public methods
    ////////////////////////////////////////////////////////////

    /**
     * Get the latest BrickMap version after validating the
     * history
     *
     * @param {object} versionHash
     * @param {function} callback
     */
    this.loadBrickMapVersion = (versionHash, callback) => {
        this.currentHashLink = versionHash;

        createBrickMapsFromHistory([this.currentHashLink], (err, brickMaps) => {
            if (err) {
                return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to create BrickMaps from history`, err));
            }

            this.validator.validate('brickMapHistory', brickMaps, (err) => {
                if (err) {
                    return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to validate BrickMaps`, err));
                }

                const latestBrickMap = brickMaps[brickMaps.length - 1];
                callback(undefined, latestBrickMap);
            });
        })
    }

    this.load = (keySSI, callback) => {
        keySSI.getAnchorId((err, anchorId) => {
            if (err) {
                return callback(createOpenDSUErrorWrapper(`Failed to get anchorId for keySSI ${keySSI.getIdentifier()}`, err));
            }

            anchoringx.getLastVersion(keySSI, (err, versionHash) => {
                if (err) {
                    return callback(createOpenDSUErrorWrapper(`Failed to get versions for anchor ${anchorId}`, err));
                }
                if (!versionHash) {
                    return callback(new Error(`No data found for anchor <${anchorId}>`));
                }

                const keySSISpace = require("opendsu").loadAPI("keyssi");
                if (typeof versionHash === "string") {
                    try {
                        versionHash = keySSISpace.parse(versionHash);
                    } catch (e) {
                        return callback(e);
                    }
                }
                this.loadBrickMapVersion(versionHash, callback);
            });
        })
    }

    this.loadVersion = (keySSI, versionHash, callback) => {
        const keySSISpace = require("opendsu").loadAPI("keyssi");
        if (typeof versionHash === "string") {
            try {
                versionHash = keySSISpace.parse(versionHash);
            } catch (e) {
                return callback(e);
            }
        }
        this.loadBrickMapVersion(versionHash, callback);
    };

    this.loadLastUncorruptedVersion = (keySSI, callback) => {

    }

    /**
     * Compact a list of BrickMapDiff objects
     * into a single BrickMap object
     *
     * @param {BrickMap|undefined} dstBrickMap
     * @return {BrickMapDiff}
     */
    this.compactDiffs = (dstBrickMap, callback) => {
        if (typeof dstBrickMap === 'function') {
            callback = dstBrickMap;
            dstBrickMap = undefined;
        }
        this.brickMapState.prepareNewChangesForAnchoring((err) => {
            if (err) {
                return callback(err);
            }

            const mergeDiffs = (err, dst) => {
                if (err) {
                    return callback(err);
                }

                let result;
                try {
                    result = this.mergeDiffs(dst, this.brickMapState.getDiffsForAnchoring());
                } catch (e) {
                    return callback(e);
                }
                callback(undefined, result);
            }

            if (!dstBrickMap) {
                return this.brickMapState.cloneAnchoredBrickMap(mergeDiffs);
            }

            mergeDiffs(undefined, dstBrickMap);
        })
    }

    /**
     * Tell the BrickMapController to use the newly anchored
     * BrickMap as a valid one
     *
     * @param {BrickMap} diff
     * @param {string} brickMapHashLink
     * @param {function} callback
     */
    this.afterBrickMapAnchoring = (brickMap, brickMapHashLink, callback) => {
        this.currentHashLink = brickMapHashLink;
        this.lastAnchorTimestamp = new Date().getTime();
        this.brickMapState.setAnchoredBrickMap(brickMap);
        this.brickMapState.setCurrentAnchoredHashLink(brickMapHashLink);
        callback(undefined, brickMapHashLink);
    }

    /**
     * Try and fix an anchoring conflict
     *
     * Merge any "pending anchoring" BrickMapDiff objects in a clone
     * of our anchored BrickMap. If merging fails, call the 'conflictResolutionFn'
     * in order to fix the conflict. If merging succeeds, update the "dirtyBrickMap"
     *
     * If no 'conflictResolutionFn' function was defined
     * The callback will be called with the following error:
     *
     *  error: Error {
     *      message: 'Anchoring conflict error',
     *      conflicts: {
     *          files: {
     *              '/file/path/in/conflict': {
     *                  error: 'LOCAL_OVERWRITE|REMOTE_DELETE|LOCAL_DELETE', // type of conflict
     *                  message: '[User friendly error message]'
     *              },
     *              ...
     *          },
     *          theirHashLinkSSI: '...', // HashLinkSSI of the latest anchored BrickMap
     *          ourHashLinkSSI: '...' // The HashLinkSSI of our version
     *      }
     *  }
     *
     *  Where conflicts.*.error:
     *      LOCAL_OVERWRITE - Our changes will overwrite a newly anchored file/directory
     *      REMOTE_DELETE - The file path we're trying to anchor has been deleted
     *      LOCAL_DELETE - Our changes will delete a newly anchored file/directory
     *
     * If a 'conflictResolutionFn' is defined it will be called with the following arguments:
     *  conflicts - The conflicts object described above
     *  callback
     *
     * @param {BrickMap} theirBrickMap The latest anchored BrickMap
     * @param {KeySSI} ourHashLinkSSI
     * @param {function} callback
     */
    this.reconcile = (theirBrickMap, ourHashLinkSSI, callback) => {
        const state = this.brickMapState;

        state.cloneAnchoredBrickMap((err, ourAnchoredBrickMap) => {
            if (err) {
                return callback(err);
            }

            state.prepareNewChangesForAnchoring((err) => {
                if (err) {
                    return callback(err);
                }

                if (this.mergeConflictsHandled(theirBrickMap, ourAnchoredBrickMap, ourHashLinkSSI, callback)) {
                    return;
                }

                // No conflicts detected, merge changes
                let ourChanges;
                let mergedDiffs;
                try {
                    const diffsForAnchoring = state.getDiffsForAnchoring();

                    if (diffsForAnchoring.length) {
                        [ourChanges, mergedDiffs] = this.mergeDiffs(ourAnchoredBrickMap, diffsForAnchoring);
                        theirBrickMap.merge(ourChanges);
                    }

                    // Their BrickMap now has our changes
                    // and becomes ours
                    state.setDirtyBrickMap(theirBrickMap);
                } catch (e) {
                    state.rollback(mergedDiffs)
                    return callback(e);
                }
                return callback(undefined, {
                    status: true,
                    brickMap: theirBrickMap
                });
            });
        })
    };


    this.initialize(options);
}

module.exports = LatestVersionStrategy;

},{"../../lib/Brick":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/bar/lib/Brick.js","../BrickMap":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/bar/lib/BrickMap.js","../BrickMapDiff":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/bar/lib/BrickMapDiff.js","./BrickMapStrategyMixin":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/bar/lib/BrickMapStrategy/BrickMapStrategyMixin.js","opendsu":"opendsu","swarmutils":"swarmutils"}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/bar/lib/BrickMapStrategy/builtinBrickMapStrategies.js":[function(require,module,exports){
module.exports = {
    DIFF: 'Diff',
    LATEST_VERSION: 'LatestVersion',
    DEFAULT_BRICK_MAP_STRATEGY: 'LatestVersion'
    //DEFAULT_BRICK_MAP_STRATEGY: 'Diff'
}

},{}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/bar/lib/BrickMapStrategy/index.js":[function(require,module,exports){
/**
 * @param {object} options
 */
function BrickMapStrategyFactory(options) {
    const DiffStrategy = require('./DiffStrategy');
    const LastestVersionStrategy = require('./LatestVersionStrategy');
    const builtInStrategies = require("./builtinBrickMapStrategies");
    options = options || {};

    const factories = {};

    ////////////////////////////////////////////////////////////
    // Private methods
    ////////////////////////////////////////////////////////////

    const initialize = () => {
        const builtinStrategies = require("./builtinBrickMapStrategies");
        this.registerStrategy(builtinStrategies.DIFF, this.createDiffStrategy);
        this.registerStrategy(builtinStrategies.LATEST_VERSION, this.createLatestVersionStrategy);
    }

    ////////////////////////////////////////////////////////////
    // Public methods
    ////////////////////////////////////////////////////////////

    /**
     * @param {string} strategyName
     * @param {object} factory
     */
    this.registerStrategy = (strategyName, factory) => {
        factories[strategyName] = factory;
    }

    /**
     * @param {string} strategyName
     * @param {object} options
     * @return {BrickMapStrategyMixin}
     */
    this.create = (strategyName, options) => {
        if (typeof strategyName === "undefined") {
            strategyName = builtInStrategies.DEFAULT_BRICK_MAP_STRATEGY;
        }
        const factory = factories[strategyName];
        options = options || {};
        return factory(options);
    }

    /**
     * @param {object} options
     * @return {DiffStrategy}
     */
    this.createDiffStrategy = (options) => {
        return new DiffStrategy(options);
    }

    /**
     * @param {object} options
     * @return {LastestVersionStrategy}
     */
    this.createLatestVersionStrategy = (options) => {
        return new LastestVersionStrategy(options);
    }

    initialize();
}

module.exports = BrickMapStrategyFactory;

},{"./DiffStrategy":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/bar/lib/BrickMapStrategy/DiffStrategy.js","./LatestVersionStrategy":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/bar/lib/BrickMapStrategy/LatestVersionStrategy.js","./builtinBrickMapStrategies":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/bar/lib/BrickMapStrategy/builtinBrickMapStrategies.js"}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/bar/lib/BrickStorageService/Service.js":[function(require,module,exports){
'use strict';


/**
 * Brick storage layer
 * Wrapper over EDFSBrickStorage
 *
 * @param {object} options
 * @param {Cache} options.cache
 * @param {number} options.bufferSize
 * @param {EDFSBrickStorage} options.storageProvider
 * @param {callback} options.brickFactoryFunction
 * @param {FSAdapter} options.fsAdapter
 * @param {callback} options.brickDataExtractorCallback
 */
function Service(options) {
    const envTypes = require("overwrite-require").constants;
    const isStream = require("../../utils/isStream");
    const stream = require('stream');
    const utils = require("swarmutils");
    const crypto = require("opendsu").loadAPI("crypto");

    options = options || {};
    this.cache = options.cache;
    this.bufferSize = parseInt(options.bufferSize, 10);
    this.brickFactoryFunction = options.brickFactoryFunction;
    this.fsAdapter = options.fsAdapter;
    this.brickDataExtractorCallback = options.brickDataExtractorCallback;
    this.keySSI = options.keySSI;

    const openDSU = require("opendsu");
    const SSIKeys = openDSU.loadApi("keyssi");
    const bricking = openDSU.loadApi("bricking");

    if (isNaN(this.bufferSize) || this.bufferSize < 1) {
        throw new Error('$$.Buffer size is required');
    }

    if (typeof this.brickFactoryFunction !== 'function') {
        throw new Error('A brick factory function is required');
    }

    if (!this.fsAdapter && $$.environmentType !== envTypes.BROWSER_ENVIRONMENT_TYPE &&
        $$.environmentType !== envTypes.SERVICE_WORKER_ENVIRONMENT_TYPE &&
        $$.environmentType !== envTypes.WEB_WORKER_ENVIRONMENT_TYPE) {
        throw new Error('A file system adapter is required');
    }

    if (typeof this.brickDataExtractorCallback !== 'function') {
        throw new Error('A Brick data extractor callback is required');
    }

    /**
     * @param {HashLinkSSI} hlSSI
     * @return {HashLinkSSI}
     */
    const stripHintFromHashLinkSSI = (hlSSI) => {
        //TODO: remove the stripHintFromHashLinkSSI and use direct
        return hlSSI.getNoHintIdentifier();
    };

    /**
     * @param {*} key
     * @return {Boolean}
     */
    const hasInCache = (key) => {
        if (!this.cache) {
            return false;
        }

        return this.cache.has(key);
    };

    /**
     * @param {*} key
     * @param {*} value
     */
    const storeInCache = (key, value) => {
        if (!this.cache) {
            return;
        }

        this.cache.set(key, value);
    };

    /**
     * Creates writable stream to a EDFSBrickStorage instance
     *
     * @param {EDFSBrickStorage} storageProvider
     * @param {callback} beforeCopyCallback
     * @return {stream.Writable}
     */
    const createBricksWritableStream = (storageProvider, beforeCopyCallback) => {
        const self = this;
        return ((storageProvider, beforeCopyCallback) => {

            const writableStream = new stream.Writable({
                write(brickContainer, encoding, callback) {
                    let {brick, brickMeta} = brickContainer;
                    if (typeof beforeCopyCallback === 'function') {
                        brick = beforeCopyCallback(brickMeta, brick);
                    }

                    brick.getTransformedData((err, brickData) => {
                        if (err) {
                            return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to get transformed data`, err));
                        }

                        bricking.putBrick(self.keySSI.getBricksDomain(), brickData, (err, digest) => {
                            if (err) {
                                return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to put brick`, err));
                            }

                            brick.getSummary((err, brickSummary) => {
                                if (err) {
                                    return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to get bricks summary`, err));
                                }


                                brickSummary.digest = digest;
                                this.bricksSummary.push(brickSummary);

                                callback();
                            });
                        })
                    });
                },
                objectMode: true
            });

            writableStream.bricksSummary = [];
            return writableStream;

        })(storageProvider, beforeCopyCallback);
    };

    /**
     * Create a readable stream of Brick objects
     * retrieved from EDFSBrickStorage
     *
     * @param {Array<object>} bricksMeta
     * @return {stream.Readable}
     */
    const createBricksReadableStream = (bricksMeta) => {
        return ((bricksMeta) => {

            let brickIndex = 0;

            const readableStream = new stream.Readable({
                read(size) {
                    if (!bricksMeta.length) {
                        return self.push(null);
                    }
                    if (brickIndex < bricksMeta.length) {
                        self.getBrick(brickIndex++);
                    }
                },
                objectMode: true
            });

            // Get a brick and push it into the stream
            const self = this;
            readableStream.getBrick = function (brickIndex) {
                const brickMeta = bricksMeta[brickIndex];
                const hlSSI = SSIKeys.parse(brickMeta.hashLink);
                bricking.getBrick(hlSSI, (err, brick) => {
                    if (err) {
                        this.destroy(err);
                        return;
                    }

                    this.push({
                        brickMeta,
                        brick
                    });

                    if (brickIndex >= (bricksMeta.length - 1)) {
                        this.push(null);
                    }
                });
            };

            return readableStream;

        })(bricksMeta);
    };

    const createBrick = (brickData) => {
        const Brick = require("../Brick");
        const brick = new Brick();
        brick.setTransformedData(brickData);
        return brick;
    };

    /**
     * @param {HashLinkSSI} hlSSI
     * @return {boolean}
     */
    const hashLinkHasEmbeddedHint = (hlSSI) => {
        return (hlSSI && typeof hlSSI.getEmbeddedData() !== "undefined");
    }

    /**
     * Extract an embedded Brick from an unencrypted Brick container
     * @param {HashLinkSSI} hlSSI
     * @param {object} brickMeta
     * @param {callback} callback
     */
    const getEmbeddedBrickAsBuffer = (hlSSI, brickMeta, callback) => {
        const hintSegments = hlSSI.getEmbeddedData();
        let [offset, size, embeddedHlSSI] = hintSegments.split(',');

        offset = parseInt(offset, 10);
        size = parseInt(size, 10);

        if (isNaN(offset) || isNaN(size) || !embeddedHlSSI) {
            return callback(new Error(`Embedded hint is invalid. Expected offset,size,hlSSI and got: ${hintSegments}`));
        }

        const cacheKey = embeddedHlSSI;

        if (hasInCache(cacheKey)) {
            const data = this.cache.get(cacheKey);
            return callback(undefined, data);
        }

        const containerBrickMeta = Object.assign({}, brickMeta);
        // The container Brick is not encrypted
        delete containerBrickMeta.key;
        // The container Brick doesn't need the hint
        containerBrickMeta.hashLink = stripHintFromHashLinkSSI(hlSSI);

        // Get the container Brick data
        getBrickAsBuffer(containerBrickMeta, (err, data) => {
            if (err) {
                return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to get bricks as buffer`, err));
            }

            const brickData = data.slice(offset, offset + size);
            return this.brickDataExtractorCallback(brickMeta, createBrick(brickData), (err, data) => {
                if (err) {
                    return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to process brick data`, err));
                }

                storeInCache(cacheKey, data);
                return callback(undefined, data);
            });
        });
    }

    /**
     * Retrieves a Brick from storage and converts
     * it into a $$.Buffer
     *
     * @param {object} brickMeta
     * @param {callback} callback
     */
    const getBrickAsBuffer = (brickMeta, callback) => {
        const hlSSI = SSIKeys.parse(brickMeta.hashLink);

        if (hlSSI.isEmbed()) {
            return callback(undefined, hlSSI.getSpecificString());
        }

        if (hashLinkHasEmbeddedHint(hlSSI)) {
            return getEmbeddedBrickAsBuffer(hlSSI, brickMeta, callback);
        }

        let cacheKey = brickMeta.hashLink;
        if (hasInCache(cacheKey)) {
            const data = this.cache.get(cacheKey);
            return callback(undefined, data);
        }

        bricking.getBrick(hlSSI, (err, brickData) => {
            if (err) {
                return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to get brick data`, err));
            }

            function checkBrickDataIntegrity(brickData, callback) {
                brickData = utils.ensureIsBuffer(brickData);
                const hashFn = crypto.getCryptoFunctionForKeySSI(hlSSI, "hash");
                const _brickHash = hashFn(brickData);
                if (err) {
                    return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to compute brick hash`, err));
                }

                const brickHash = hlSSI.getHash();

                if (brickHash !== _brickHash) {
                    return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Got invalid data for brick ${brickHash}`, Error("Possible brick data corruption")));
                }

                callback();
            }

            checkBrickDataIntegrity(brickData, (err) => {
                if (err) {
                    return callback(err);
                }

                this.brickDataExtractorCallback(brickMeta, createBrick(brickData), (err, data) => {
                    if (err) {
                        return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to process brick data`, err));
                    }

                    if (!$$.Buffer.isBuffer(data) && (data instanceof ArrayBuffer || ArrayBuffer.isView(data))) {
                        data = utils.ensureIsBuffer(data);
                    }
                    storeInCache(cacheKey, data);
                    return callback(undefined, data);
                });
            });
        });
    };

    /**
     * Counts the number of blocks in a file
     *
     * @param {string} filePath
     * @param {callback} callback
     */
    const getFileBlocksCount = (filePath, callback) => {
        this.fsAdapter.getFileSize(filePath, (err, size) => {
            if (err) {
                return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to get size for file <${filePath}>`, err));
            }

            let blocksCount = Math.floor(size / this.bufferSize);
            if (size % this.bufferSize > 0) {
                ++blocksCount;
            }

            callback(undefined, blocksCount);
        })
    };

    /**
     * Creates a Brick from a $$.Buffer
     * and saves it into brick storage
     *
     * @param {$$.Buffer} data
     * @param {boolean|callback} encrypt Defaults to `true`
     * @param {callback|undefined} callback
     */
    const convertDataBlockToBrick = (data, encrypt, callback) => {
        if (typeof encrypt === 'function') {
            callback = encrypt;
            encrypt = true;
        }
        const brick = this.brickFactoryFunction(encrypt);
        brick.setRawData(data);
        brick.getTransformedData((err, brickData) => {
            if (err) {
                return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to get transformed data`, err));
            }

            bricking.putBrick(this.keySSI.getBricksDomain(), brickData, (err, digest) => {
                if (err) {
                    return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to put brick`, err));
                }

                brick.getSummary((err, brickSummary) => {
                    if (err) {
                        return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to get bricks summary`, err));
                    }


                    brickSummary.digest = digest;
                    callback(undefined, brickSummary);
                });
            });
        });
    };

    /**
     * Recursively breaks a buffer into Brick objects and
     * stores them into storage
     *
     * @param {Array<object>} resultContainer
     * @param {$$.Buffer} buffer
     * @param {number} blockIndex
     * @param {object} options
     * @param {number} options.bufferSize
     * @param {callback} callback
     */
    const convertBufferToBricks = (resultContainer, buffer, blockIndex, options, callback) => {
        const bufferSize = options.bufferSize;
        let blocksCount = Math.floor(buffer.length / bufferSize);
        if ((buffer.length % bufferSize) > 0) {
            ++blocksCount;
        }

        const encrypt = (typeof options.encrypt === 'undefined') ? true : options.encrypt;
        const blockData = buffer.slice(blockIndex * bufferSize, (blockIndex + 1) * bufferSize);

        convertDataBlockToBrick(blockData, encrypt, (err, result) => {
            if (err) {
                return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to convert data block to brick`, err));
            }

            resultContainer.push(result);
            ++blockIndex;

            if (blockIndex < blocksCount) {
                return convertBufferToBricks(resultContainer, buffer, blockIndex, options, callback);
            }

            return callback();
        });
    };

    /**
     * Copy the contents of a file into brick storage
     *
     * @param {Array<object>} resultContainer
     * @param {string} filePath
     * @param {object} options
     * @param {number} options.blockIndex
     * @param {number} options.blocksCount
     * @param {boolean} options.encrypt
     * @param {callback} callback
     */
    const convertFileToBricks = (resultContainer, filePath, options, callback) => {
        if (typeof options === 'function') {
            callback = options;
            options = {
                encrypt: true
            }
        }

        if (typeof options.blockIndex === 'undefined') {
            options.blockIndex = 0;
        }

        let blockIndex = options.blockIndex;
        const blocksCount = options.blocksCount;
        const blockOffset = blockIndex * this.bufferSize;
        const blockEndOffset = (blockIndex + 1) * this.bufferSize - 1;
        this.fsAdapter.readBlockFromFile(filePath, blockOffset, blockEndOffset, (err, data) => {
            if (err) {
                return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to read block from file <${filePath}>`, err));
            }

            convertDataBlockToBrick(data, options.encrypt, (err, result) => {
                if (err) {
                    return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to convert data block to brick`, err));
                }

                resultContainer.push(result);
                ++blockIndex;

                if (blockIndex < blocksCount) {
                    options.blockIndex = blockIndex;
                    return convertFileToBricks(resultContainer, filePath, options, callback);
                }

                return callback();
            })
        })
    };

    /**
     * Save the buffer containing multiple files as a single brick
     * and generate the proper HashLinkSSI for each file in the brick
     *
     * Each file's HashLinkSSI is constructed by appending the `embedded/${offset},${size}` hint
     * at the end of the Brick's HashLinkSSI. Ex:
     * Brick HashLinkSSI:
     *      ssi:hl:default:29LuHPtSrCG7u4nKNPB8KbG2EuK1U84X5pTTTko2GGcpxZGyPFC1jG8hAh6g2DbYKJxYumJFmNyQWu3iNpQe5jHR::v0
     * File in brick HashLinkSSI:
     *      ssi:hl:default:29LuHPtSrCG7u4nKNPB8KbG2EuK1U84X5pTTTko2GGcpxZGyPFC1jG8hAh6g2DbYKJxYumJFmNyQWu3iNpQe5jHR::v0:embedded/0,5
     *
     * @param {$$.Buffer} buffer
     * @param {Array<Object>} filesList
     * @param {string} filesList[].filename
     * @param {Number} filesList[].offset
     * @param {Number} filesList[].size
     * @param {callback} callback
     */
    const storeCompactedFiles = (buffer, filesList, callback) => {
        return convertDataBlockToBrick(buffer, false, (err, brickMeta) => {
            if (err) {
                return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to convert data block to brick`, err));
            }
            const files = {};
            const brickHLSSI = SSIKeys.parse(brickMeta.hashLink);

            for (const fileInfo of filesList) {

                const fileHLSSI = SSIKeys.createHashLinkSSI(
                    brickHLSSI.getDLDomain(),
                    brickHLSSI.getSpecificString(),
                    brickHLSSI.getVn()
                );

                fileHLSSI.setEmbeddedData(`${fileInfo.offset},${fileInfo.size},${fileInfo.brickSummary.hashLink}`);
                fileInfo.brickSummary.hashLink = fileHLSSI.getIdentifier();
                files[fileInfo.filename] = [fileInfo.brickSummary];
            }

            return callback(undefined, files);
        });
    }

    /**
     * Stores a $$.Buffer as Bricks into brick storage
     *
     * @param {$$.Buffer} buffer
     * @param {objects|callback} options
     * @param {number|callback} options.bufferSize
     * @param {callback|undefined} callback
     */
    this.ingestBuffer = (buffer, options, callback) => {
        if (typeof options === 'function') {
            callback = options;
            options = {
                encrypt: true
            }
        }

        if (!options.bufferSize) {
            options.bufferSize = this.bufferSize;
        }

        const bricksSummary = [];
        convertBufferToBricks(bricksSummary, buffer, 0, options, (err) => {
            if (err) {
                return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to convert buffer to bricks`, err));
            }

            callback(undefined, bricksSummary);
        });
    };

    /**
     * Reads a stream of data into multiple Brick objects
     * stored in brick storage
     *
     * @param {stream.Readable} stream
     * @param {object|callback} options
     * @param {boolean} options.encrypt
     * @param {callback}
     */
    this.ingestStream = (stream, options, callback) => {
        if (typeof options === 'function') {
            callback = options;
            options = {
                encrypt: true
            };
        }

        let bricksSummary = [];
        let receivedData = [];
        stream.on('data', (chunk) => {
            if (typeof chunk === 'string') {
                chunk = $$.Buffer.from(chunk);
            }

            receivedData.push(chunk);
            let chunksCount = this.bufferSize / chunk.length;
            if (receivedData.length >= chunksCount) {
                const buffer = $$.Buffer.concat(receivedData.splice(0, chunksCount));
                stream.pause();
                const ingestBufferOptions = {
                    bufferSize: buffer.length,
                    encrypt: options.encrypt
                };
                this.ingestBuffer(buffer, ingestBufferOptions, (err, summary) => {
                    if (err) {
                        stream.destroy(err);
                        return;
                    }
                    bricksSummary = bricksSummary.concat(summary);
                    stream.resume();
                });
            }
        });
        stream.on('error', (err) => {
            return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to ingest stream`, err));
        });
        stream.on('end', () => {
            const buffer = $$.Buffer.concat(receivedData);
            const ingestBufferOptions = {
                bufferSize: buffer.length,
                encrypt: options.encrypt
            };
            this.ingestBuffer(buffer, ingestBufferOptions, (err, summary) => {
                if (err) {
                    return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to ingest buffer`, err));
                }

                bricksSummary = bricksSummary.concat(summary);
                callback(undefined, bricksSummary);
            });
        })
    };

    /**
     * @param {string|$$.Buffer|stream.Readable} data
     * @param {callback} callback
     */
    this.ingestData = (data, options, callback) => {
        if (typeof data === 'string') {
            data = $$.Buffer.from(data);
        }

        if (typeof options === 'function') {
            callback = options;
            options = {
                encrypt: true,
            };
        }

        if (!$$.Buffer.isBuffer(data) && !isStream.isReadable(data)) {
            return callback(Error(`Type of data is ${typeof data}. Expected $$.Buffer or Stream.Readable`));
        }

        if ($$.Buffer.isBuffer(data)) {
            return this.ingestBuffer(data, options, callback);
        }

        return this.ingestStream(data, options, callback);
    };

    /**
     * Copy the contents of a file into brick storage
     *
     * @param {string} filePath
     * @param {object|callback} options
     * @param {boolean} options.encrypt
     * @param {callback} callback
     */
    this.ingestFile = (filePath, options, callback) => {
        if (typeof options === 'function') {
            callback = options;
            options = {
                encrypt: true
            }
        }
        const bricksSummary = [];

        getFileBlocksCount(filePath, (err, blocksCount) => {
            if (err) {
                return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed get blocks for file <${filePath}>`, err));
            }

            const conversionOptions = Object.assign({}, options);
            conversionOptions.blocksCount = blocksCount;
            convertFileToBricks(bricksSummary, filePath, conversionOptions, (err, result) => {
                if (err) {
                    return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to convert file <${filePath}> to bricks`, err));
                }

                callback(undefined, bricksSummary);
            });
        });
    };

    /**
     * Copy the contents of multiple files into brick storage
     *
     * @param {Array<string>} filePath
     * @param {object|callback} options
     * @param {boolean} options.encrypt
     * @param {callback} callback
     */
    this.ingestFiles = (files, options, callback) => {
        if (typeof options === 'function') {
            callback = options;
            options = {
                encrypt: true
            }
        }

        const bricksSummary = {};

        const ingestFilesRecursive = (files, callback) => {
            if (!files.length) {
                return callback(undefined, bricksSummary);
            }

            const filePath = files.pop();
            const filename = require("path").basename(filePath);

            this.ingestFile(filePath, options, (err, result) => {
                if (err) {
                    return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to ingest file <${filePath}>`, err));
                }

                bricksSummary[filename] = result;

                ingestFilesRecursive(files, callback);
            });
        };

        ingestFilesRecursive(files, callback);
    };
    
    /**
     * Copy the contents of folder into a single brick
     *
     * @param {string} folderPath
     * @param {object|callback} options
     * @param {boolean} options.encrypt
     * @param {callback} callback
     */
    this.createBrickFromFolder = (folderPath, options, callback) => {
        if (typeof options === 'function') {
            callback = options;
            options = {
                encrypt: true
            }
        }
        const filesIterator = this.fsAdapter.getFilesIterator(folderPath);
        const filesList = [];

        const brickBuffers = [];
        let currentOffset = 0;

        const iteratorHandler = (err, filename, dirname) => {
            if (err) {
                return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to create brick from folder <${folderPath}>`, err));
            }

            if (typeof filename === 'undefined') {
                const buffer = $$.Buffer.concat(brickBuffers);
                return storeCompactedFiles(buffer, filesList, callback);
            }

            const filePath = require("path").join(dirname, filename);
            this.readFile(filePath, (err, fileBuffer) => {
                if (err) {
                    return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to read file <${filePath}>`, err));
                }

                const fileBrick = this.brickFactoryFunction(options.encrypt);
                fileBrick.setRawData(fileBuffer);
                fileBrick.getTransformedData((err, brickData) => {
                    if (err) {
                        return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to get transformed data`, err));
                    }

                    fileBrick.getSummary((err, brickSummary) => {
                        if (err) {
                            return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to get brick summary`, err));
                        }

                        const size = brickData.length;
                        const offset = currentOffset;

                        currentOffset += size;
                        filesList.push({
                            filename,
                            offset,
                            size,
                            brickSummary
                        });
                        brickBuffers.push(brickData);

                        filesIterator.next(iteratorHandler);
                    })
                });
            });
        };

        filesIterator.next(iteratorHandler);

    };

    /**
     * Copy the contents of multiple files into a single brick
     *
     * @param {string} folderPath
     * @param {object|callback} options
     * @param {boolean} options.encrypt
     * @param {callback} callback
     */
    this.createBrickFromFiles = (files, options, callback) => {
        if (typeof options === 'function') {
            callback = options;
            options = {
                encrypt: true
            }
        }
        const filesList = [];

        const brickBuffers = [];
        let currentOffset = 0;
        const readFilesRecursive = (files, callback) => {
            if (!files.length) {
                const buffer = $$.Buffer.concat(brickBuffers);
                return storeCompactedFiles(buffer, filesList, callback);
            }

            const filePath = files.pop();
            const filename = require("path").basename(filePath);

            this.readFile(filePath, (err, fileBuffer) => {
                if (err) {
                    return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to read file <${filePath}>`, err));
                }

                const fileBrick = this.brickFactoryFunction(options.encrypt);
                fileBrick.setRawData(fileBuffer);
                fileBrick.getTransformedData((err, brickData) => {
                    if (err) {
                        return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to get transformed data`, err));
                    }

                    fileBrick.getSummary((err, brickSummary) => {
                        if (err) {
                            return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to ingest file <${filePath}>`, err));
                        }

                        const size = brickData.length;
                        const offset = currentOffset;

                        currentOffset += size;
                        filesList.push({
                            filename,
                            offset,
                            size,
                            brickSummary
                        });
                        brickBuffers.push(brickData);

                        readFilesRecursive(files, callback);
                    });
                });
            });
        }

        readFilesRecursive(files, callback);
    };

    /**
     * Copy the contents of folder into brick storage
     *
     * @param {string} folderPath
     * @param {object|callback} options
     * @param {boolean} options.encrypt
     * @param {callback} callback
     */
    this.ingestFolder = (folderPath, options, callback) => {
        if (typeof options === 'function') {
            callback = options;
            options = {
                encrypt: true
            };
        }
        const bricksSummary = {};
        const filesIterator = this.fsAdapter.getFilesIterator(folderPath);

        const iteratorHandler = (err, filename, dirname) => {
            if (err) {
                return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to ingest folder <${folderPath}>`, err));
            }

            if (typeof filename === 'undefined') {
                return callback(undefined, bricksSummary);
            }

            const filePath = require("path").join(dirname, filename);
            this.ingestFile(filePath, options, (err, result) => {
                if (err) {
                    return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to ingest file <${filePath}>`, err));
                }

                bricksSummary[filename] = result;
                filesIterator.next(iteratorHandler);
            });
        };

        filesIterator.next(iteratorHandler);
    };

    /**
     * Retrieve all the Bricks identified by `bricksMeta`
     * from storage and create a $$.Buffer using their data
     *
     * @param {Array<object>} bricksMeta
     * @param {callback} callback
     */
    this.createBufferFromBricks = (bricksMeta, callback) => {
        const buffers = [];
        const getBricksAsBufferRecursive = (index, callback) => {
            const brickMeta = bricksMeta[index];
            getBrickAsBuffer(brickMeta, (err, data) => {
                if (err) {
                    return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to get bricks as buffer`, err));
                }

                buffers.push(data);
                ++index;

                if (index < bricksMeta.length) {
                    return getBricksAsBufferRecursive(index, callback);
                }

                const buffer = $$.Buffer.concat(buffers);
                callback(undefined, buffer);
            });
        };

        getBricksAsBufferRecursive(0, callback);
    };

    /**
     * Retrieve all the Bricks identified by `bricksMeta`
     * from storage and create a readable stream
     * from their data
     *
     * @param {Array<object>} bricksMeta
     * @param {callback} callback
     */
    this.createStreamFromBricks = (bricksMeta, callback) => {
        let brickIndex = 0;

        const readableStream = new stream.Readable({
            read(size) {
                if (!bricksMeta.length) {
                    return this.push(null);
                }

                if (brickIndex < bricksMeta.length) {
                    this.readBrickData(brickIndex++);
                }
            }
        });

        // Get a brick and push it into the stream
        readableStream.readBrickData = function (brickIndex) {
            const brickMeta = bricksMeta[brickIndex];
            getBrickAsBuffer(brickMeta, (err, data) => {
                if (err) {
                    this.destroy(err);
                    return;
                }

                this.push(data);

                if (brickIndex >= (bricksMeta.length - 1)) {
                    this.push(null);
                }
            });
        };

        callback(undefined, readableStream);
    };

    /**
     * Retrieve all the Bricks identified by `sizeSSI` and `bricksMeta`
     * from storage and create a readable stream
     * from their data
     *
     * @param {SizeSSI} sizeSSI
     * @param {Array<object>} bricksMeta
     * @param {callback} callback
     */
    this.createStreamFromBricksWithRange = (sizeSSI, bricksMeta, range, callback) => {
        const totalSize = sizeSSI.getTotalSize();
        const bufferSize = sizeSSI.getBufferSize();
        const {start, end} = range;
        let brickIndex = Math.floor(start / bufferSize);

        const readableStream = new stream.Readable({
            read() {
                if (!bricksMeta.length) {
                    return this.push(null);
                }

                if (brickIndex < bricksMeta.length) {
                    this.readBrickData(brickIndex++);
                }
            }
        });

        readableStream.readBrickData = function (brickIndex) {
            const brickMeta = bricksMeta[brickIndex];
            getBrickAsBuffer(brickMeta, (err, data) => {
                if (err) {
                    this.destroy(err);
                    return;
                }

                const currentIndexStartByte = brickIndex > 0 ? brickIndex * bufferSize : 0;
                const currentIndexEndByte = currentIndexStartByte + data.byteLength;

                const isCurrentBrickAfterStart = currentIndexStartByte >= start;
                if (isCurrentBrickAfterStart) {
                    const slice = end < currentIndexEndByte
                        ? data.slice(0, end - currentIndexStartByte + 1)
                        : data.slice(0);
                    this.push(slice);
                } else {
                    let offset = start - currentIndexStartByte;
                    const mustSliceBeforeCurrentIndexEnd = end < currentIndexEndByte && end < totalSize;
                    const slice = mustSliceBeforeCurrentIndexEnd
                        ? data.slice(offset, end - currentIndexStartByte + 1)
                        : data.slice(offset);
                    this.push(slice);
                }

                if (currentIndexEndByte > end || brickIndex >= (bricksMeta.length - 1)) {
                    this.push(null);
                }
            });
        };

        callback(undefined, readableStream);
    };

    /**
     * Retrieve all the Bricks identified by `bricksMeta`
     * and store their data into a file
     *
     * @param {string} filePath
     * @param {Array<object>} bricksMeta
     * @param {callback} callback
     */
    this.createFileFromBricks = (filePath, bricksMeta, callback) => {
        const getBricksAsBufferRecursive = (index, callback) => {
            const brickMeta = bricksMeta[index];

            getBrickAsBuffer(brickMeta, (err, data) => {
                if (err) {
                    return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to get bricks as buffer`, err));
                }

                this.fsAdapter.appendBlockToFile(filePath, data, (err) => {
                    if (err) {
                        return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to append block to file <${filePath}>`, err));
                    }

                    ++index;

                    if (index < bricksMeta.length) {
                        return getBricksAsBufferRecursive(index, callback);
                    }

                    callback();
                });
            });
        };

        getBricksAsBufferRecursive(0, callback);
    };

    /**
     * Copy all the Bricks identified by `bricksList`
     * into another storage provider
     *
     * @param {object} bricksList
     * @param {object} options
     * @param {FSAdapter} options.dstStorage
     * @param {callback} options.beforeCopyCallback
     * @param {callback} callback
     */
    this.copyBricks = (bricksList, options, callback) => {
        const bricksSetKeys = Object.keys(bricksList);
        const newBricksSetKeys = {};

        const copyBricksRecursive = (callback) => {
            if (!bricksSetKeys.length) {
                return callback();
            }

            const setKey = bricksSetKeys.shift();
            const bricksMeta = bricksList[setKey];

            const srcStream = createBricksReadableStream(bricksMeta);
            const dstStream = createBricksWritableStream(options.dstStorage, options.beforeCopyCallback);

            srcStream.on('error', (err) => {
                OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to copy bricks`, err));
                dstStream.destroy(err);
            });

            dstStream.on('finish', () => {
                newBricksSetKeys[setKey] = dstStream.bricksSummary;
                dstStream.destroy();
                copyBricksRecursive(callback);
            });

            srcStream.pipe(dstStream);
        };

        copyBricksRecursive((err) => {
            if (err) {
                return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to copy bricks recursive`, err));

            }

            callback(undefined, newBricksSetKeys);
        });
    };

    /**
     * @param {string} filePath
     * @param {callback} callback
     */
    this.readFile = (filePath, callback) => {
        this.fsAdapter.getFileSize(filePath, (err, size) => {
            if (err) {
                return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to get size for file <${filePath}>`, err));
            }

            if (!size) {
                size = 1;
            }
            this.fsAdapter.readBlockFromFile(filePath, 0, size - 1, callback);
        });
    };
}

module.exports = Service;

},{"../../utils/isStream":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/bar/utils/isStream.js","../Brick":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/bar/lib/Brick.js","opendsu":"opendsu","overwrite-require":"overwrite-require","path":false,"stream":false,"swarmutils":"swarmutils"}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/bar/lib/BrickStorageService/index.js":[function(require,module,exports){
'use strict'

module.exports = {
    Service: require('./Service')
};

},{"./Service":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/bar/lib/BrickStorageService/Service.js"}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/bar/lib/Manifest.js":[function(require,module,exports){
const MANIFEST_PATH = "/manifest";

function Manifest(archive, options, callback) {
    const pskPath = require("swarmutils").path;
    let manifest;
    let temporary = {};
    let manifestHandler = {};

    if (typeof options === 'function') {
        callback = options;
        options = {};
    }

    options = options || {};


    manifestHandler.mount = function (path, archiveIdentifier, options, callback) {
        if (typeof options === "function") {
            callback = options;
            options = {persist: true};
        }

        if (typeof options === "undefined") {
            options = {persist: true};
        }
        // if (/\W-_/.test(name) === true) {
        //     return callback(Error("Invalid mount name"));
        // }

        for (let mountingPoint in manifest.mounts) {
            if (pskPath.isSubpath(path, mountingPoint) || pskPath.isSubpath(path, mountingPoint)) {
                return callback(Error(`Mount not allowed. Already exist a mount for ${mountingPoint}`));
            }
        }

        manifest.mounts[path] = archiveIdentifier;
        if (options.persist === true) {
            return persist(callback);
        } else {
            temporary[path] = true;
        }

        callback(undefined);
    };

    manifestHandler.unmount = function (path, callback) {
        if (typeof manifest.mounts[path] === "undefined") {
            return callback(Error(`No mount found at path ${path}`));
        }

        delete manifest.mounts[path];

        if (temporary[path]) {
            delete temporary[path];
            callback();
        } else {
            persist(callback);
        }
    };

    manifestHandler.getArchiveIdentifier = function (path, callback) {
        if (typeof manifest.mounts[path] === "undefined") {
            return callback(Error(`No mount found at path ${path}`));
        }

        callback(undefined, manifest.mounts[path]);
    };

    manifestHandler.getArchiveForPath = function (path, callback) {
        if (path[0] !== '/') {
            path = `/${path}`;
        }
        for (let mountingPoint in manifest.mounts) {
            if (mountingPoint === path) {
                return getArchive(manifest.mounts[mountingPoint], (err, archive) => {
                    if (err) {
                        return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to load DSU mounted at mounting point ${manifest.mounts[mountingPoint]}`, err));
                    }

                    return callback(undefined, {prefixPath: mountingPoint, relativePath: "/", archive: archive, identifier: manifest.mounts[mountingPoint]});
                });
            }

            if (pskPath.isSubpath(path, mountingPoint)) {
                return getArchive(manifest.mounts[mountingPoint], (err, archive) => {
                    if (err) {
                        return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to load DSU mounted at mounting point ${manifest.mounts[mountingPoint]}`, err));
                    }

                    let remaining = path.substring(mountingPoint.length);
                    remaining = pskPath.ensureIsAbsolute(remaining);
                    return archive.getArchiveForPath(remaining, function (err, result) {
                        if (err) {
                            return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to load DSU mounted at path ${remaining}`, err));
                        }
                        result.prefixPath = pskPath.join(mountingPoint, result.prefixPath);
                        callback(undefined, result);
                    });
                });
            }
        }

        callback(undefined, {prefixPath: "/", relativePath: path, archive: archive});
    };

    manifestHandler.getMountPoints = function () {
        return Object.keys(manifest.mounts);
    }

    manifestHandler.getMountedDossiers = function (path, callback) {
        let mountedDossiers = [];
        for (let mountPoint in manifest.mounts) {
            if (pskPath.isSubpath(mountPoint, path)) {
                let mountPath = mountPoint.substring(path.length);
                if (mountPath[0] === "/") {
                    mountPath = mountPath.substring(1);
                }
                mountedDossiers.push({
                    path: mountPath,
                    identifier: manifest.mounts[mountPoint]
                });
            }
        }

        const mountPaths = mountedDossiers.map(mountedDossier => mountedDossier.path);
        mountedDossiers = mountedDossiers.filter((mountedDossier, index) => {
            return mountPaths.indexOf(mountedDossier.path) === index;
        });

        callback(undefined, mountedDossiers);
    };

    function getArchive(seed, callback) {
        const resolver = require("opendsu").loadApi("resolver");
        let loadOptions;

        if (typeof options.skipCache === 'boolean' && !options.skipCache) {
            loadOptions = {
                skipCache: true
            };
        }

        resolver.loadDSU(seed, loadOptions, (err, dossier) => {
            if (err) {
                return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to load DSU from keySSI ${seed}`, err));
            }
            callback(undefined, dossier);
        })
    }

    function persist(callback) {
        archive.writeFile(MANIFEST_PATH, JSON.stringify(manifest), {embed: true}, callback);
    }

    function init(callback) {
        archive.readFile(MANIFEST_PATH, {ignoreMounts: true}, (err, manifestContent) => {
            if (err) {
                manifest = {mounts: {}};
            } else {
                try {
                    manifest = JSON.parse(manifestContent.toString());
                } catch (e) {
                    return callback(e);
                }
            }

            callback(undefined, manifestHandler);
        });
    }

    init(callback);
}

module.exports.getManifest = function getManifest(archive, options, callback) {
    Manifest(archive, options, callback);
};


},{"opendsu":"opendsu","swarmutils":"swarmutils"}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/bar/lib/brick-transforms/CompressionTransformation.js":[function(require,module,exports){
const zlib = require("zlib");

function CompressionTransformation(config) {

    this.getInverseTransformParameters = (transformedData) => {
        return {data: transformedData};
    };

    this.createDirectTransform = () => {
        return getCompression(true);
    };

    this.createInverseTransform = () => {
        return getCompression(false);
    };

    function getCompression(isCompression) {
        const algorithm = config.getCompressionAlgorithm();
        switch (algorithm) {
            case "gzip":
                return __createCompress(zlib.gzipSync, zlib.gunzipSync, isCompression);
            case "br":
                return __createCompress(zlib.brotliCompressSync, zlib.brotliDecompressSync, isCompression);
            case "deflate":
                return __createCompress(zlib.deflateSync, zlib.inflateSync, isCompression);
            case "deflateRaw":
                return __createCompress(zlib.deflateRawSync, zlib.inflateRawSync, isCompression);
            default:
                return;
        }
    }

    function __createCompress(compress, decompress, isCompression) {
        const options = config.getCompressionOptions();
        if (!isCompression) {
            return {
                transform(data) {
                    return decompress(data, options);
                }
            }
        }

        return {
            transform(data) {
                return compress(data, options);
            }
        }
    }
}

module.exports = CompressionTransformation;


},{"zlib":false}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/bar/lib/brick-transforms/EncryptionTransformation.js":[function(require,module,exports){
const openDSU = require("opendsu");
const crypto = openDSU.loadApi("crypto");

function EncryptionTransformation(options) {
    this.do = (keySSI, data, callback) => {
        const encrypt = crypto.getCryptoFunctionForKeySSI(keySSI, "encryption");
        let encryptedData;
        keySSI.getEncryptionKey((err, encryptionKey) => {
            if (err) {
                return callback(err);
            }
            try {
                encryptedData = encrypt(data, encryptionKey, options);
            } catch (e) {
                return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to encrypt data`, e));
            }
            callback(undefined, encryptedData);
        });
    };

    this.undo = (keySSI, data, callback) => {
        const decrypt = crypto.getCryptoFunctionForKeySSI(keySSI, "decryption");
        let plainData;
        keySSI.getEncryptionKey((err, encryptionKey) => {
            if (err) {
                return callback(err);
            }
            try {
                plainData = decrypt(data, encryptionKey);
            } catch (e) {
                return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to decrypt data`, e));
            }
            callback(undefined, plainData);
        });
    };
}

module.exports = EncryptionTransformation;
},{"opendsu":"opendsu"}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/bar/lib/brick-transforms/index.js":[function(require,module,exports){
const CompressionTransformation = require("./CompressionTransformation");
const EncryptionTransformation = require("./EncryptionTransformation");

const createBrickTransformation = (options) => {
    options = options || {};
    return new EncryptionTransformation(options);
};


module.exports = {
    createBrickTransformation
};


},{"./CompressionTransformation":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/bar/lib/brick-transforms/CompressionTransformation.js","./EncryptionTransformation":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/bar/lib/brick-transforms/EncryptionTransformation.js"}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/bar/lib/constants.js":[function(require,module,exports){
'use strict';

module.exports = {
    anchoringStatus: {
        OK: 0,
        PERSIST_BRICKMAP_ERR: -1,
        ANCHOR_VERSION_ERR: -2,
        BRICKMAP_UPDATE_ERR: -3,
        BRICKMAP_LOAD_ERR: -4,
        BRICKMAP_RECONCILE_ERR: -5,
        BRICKMAP_RECONCILIATION_HANDOFF: -6
    }
}

},{}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/bar/lib/obsolete/FileBrickMap.js":[function(require,module,exports){
const Brick = require("../Brick");
const util = require("../../utils/utilities");
const pathModule = "path";
const path = require(pathModule);

function FileBrickMap(header) {
    header = header || {};

    let brickOffset = util.getBrickMapOffsetSize();
    let archiveConfig;
    let encryptionKey;

    this.addFileEntry = (path, bricks) => {
        this.appendBricksToEntry(path, bricks);
    };

    this.appendBricksToEntry = (path, bricks) => {
        for (const data of bricks) {
            this.add(path, data);
        }
    }

    this.add = (filePath, brick) => {
        filePath = filePath.split(path.sep).join(path.posix.sep);
        this.load();
        if (typeof header[filePath] === "undefined") {
            header[filePath] = [];
        }

        const brickObj = {
            checkSum: brick.getAdler32(),
            offset: brickOffset,
            hash: brick.getHash()
        };

        const encKey = brick.getTransformParameters() ? brick.getTransformParameters().key : undefined;
        if (encKey) {
            brickObj.key = encKey;
        }

        header[filePath].push(brickObj);
        brickOffset += brick.getTransformedSize();
    };

    this.getHashList = (filePath) => {
        this.load();
        return header[filePath].map(brickObj => brickObj.offset);
    };

    this.getFileList = (folderBarPath) => {
        this.load();
        if (!folderBarPath) {
            return Object.keys(header);
        }
        return Object.keys(header).filter(fileName => fileName.includes(folderBarPath));
    };

    this.getDictionaryObject = () => {
        let objectDict = {};
        Object.keys(header).forEach((fileName) => {
            let brickObjects = header[fileName];
            for (let j = 0; j < brickObjects.length; j++) {
                if (typeof objectDict[brickObjects[j]['checkSum']] === 'undefined') {
                    objectDict[brickObjects[j]['checkSum']] = [];
                }
                objectDict[brickObjects[j]['checkSum']].push(brickObjects[j]['hash']);
            }
        });
        return objectDict;
    };

    this.getTransformParameters = (brickId) => {
        if (!brickId) {
            return encryptionKey ? {key: encryptionKey} : {};
        }

        this.load();
        let bricks = [];
        const files = this.getFileList();

        files.forEach(filePath => {
            bricks = bricks.concat(header[filePath]);
        });

        const brickObj = bricks.find(brick => {
            return brick.offset === brickId;
        });

        const addTransformData = {};
        if (brickObj.key) {
            addTransformData.key = $$.Buffer.from(brickObj.key);
        }

        return addTransformData;
    };

    this.toBrick = () => {
        this.load();
        const brick = new Brick(archiveConfig);
        brick.setTransformParameters({key: encryptionKey});
        brick.setRawData($$.Buffer.from(JSON.stringify(header)));
        return brick;
    };

    this.load = () => {
        if (header instanceof Brick) {
            header.setConfig(archiveConfig);
            if (encryptionKey) {
                header.setTransformParameters({key: encryptionKey});
            }
            header = JSON.parse(header.getRawData().toString());
        }
    };

    this.setConfig = (config) => {
        archiveConfig = config;
    };

    this.getConfig = () => {
        return archiveConfig;
    };

    this.setEncryptionKey = (encKey) => {
        encryptionKey = encKey;
    };

    this.removeFile = (filePath) => {
        this.load();
        delete header[filePath];
    };
}

module.exports = FileBrickMap;

},{"../../utils/utilities":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/bar/utils/utilities.js","../Brick":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/bar/lib/Brick.js"}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/bar/lib/obsolete/FileBrickStorage.js":[function(require,module,exports){
function FileBrickStorage(filePath) {
    const fsModuleName = "fs";
    const fs = require(fsModuleName);
    const BrickMap = require("./FileBrickMap");
    const util = require("../../utils/utilities");
    const Brick = require("../Brick");

    let isFirstBrick = true;
    let map;
    let mapOffset;

    this.setBrickMap = (brickMap) => {
        map = brickMap;
    };

    this.putBrick = (brick, callback) => {
        if (isFirstBrick) {
            isFirstBrick = false;
            const writeStream = fs.createWriteStream(filePath, {start: util.getBrickMapOffsetSize()});
            writeStream.on("error", (err) => {
                return callback(err);
            });

            writeStream.write(brick.getTransformedData(), callback);
        } else {
            fs.appendFile(filePath, brick.getTransformedData(), callback);
        }
    };

    this.getBrick = (brickId, callback) => {
        this.getBrickMap((err, brickMap) => {
            if (err) {
                return callback(err);
            }
            let brickOffsets = [];
            const fileList = brickMap.getFileList();
            fileList.forEach(file => {
                brickOffsets = brickOffsets.concat(brickMap.getHashList(file));
            });

            const brickIndex = brickOffsets.findIndex(el => {
                return el === brickId;
            });

            let nextBrickId = brickOffsets[brickIndex + 1];
            if (!nextBrickId) {
                nextBrickId = Number(mapOffset);
            }

            readBrick(brickId, nextBrickId, callback);
        });

    };

    this.deleteFile = (fileName, callback) => {
        this.getBrickMap((err, brickMap) => {
            if (err) {
                return callback(err);
            }

            brickMap.delete(fileName);
            this.putBrickMap(brickMap, callback);
        });
    };


    this.putBrickMap = (brickMap, callback) => {
        map = brickMap;
        readBrickMapOffset((err, offset) => {
            if(offset) {
                offset = Number(offset);
                fs.truncate(filePath, offset, (err) => {
                    if (err) {
                        return callback(err);
                    }

                    __writeBrickMap(offset);
                });
            }else{
                fs.stat(filePath, (err, stats) => {
                    if (err) {
                        return callback(err);
                    }

                    const brickMapOffset = stats.size;

                    const bufferBrickMapOffset = $$.Buffer.alloc(util.getBrickMapOffsetSize());
                    bufferBrickMapOffset.writeBigUInt64LE(BigInt(brickMapOffset));
                    mapOffset = brickMapOffset;
                    const offsetWriteStream = fs.createWriteStream(filePath, {flags: "r+", start: 0});

                    offsetWriteStream.on("error", (err) => {
                        return callback(err);
                    });

                    offsetWriteStream.write(bufferBrickMapOffset, (err) => {
                        if (err) {
                            return callback(err);
                        }

                        __writeBrickMap(brickMapOffset);
                    });
                });
            }
        });

        function __writeBrickMap(offset) {
            const mapWriteStream = fs.createWriteStream(filePath, {flags: "r+", start: offset});
            mapWriteStream.on("error", (err) => {
                return callback(err);
            });

            const mapBrick = brickMap.toBrick();
            mapBrick.setTransformParameters(brickMap.getTransformParameters());
            mapWriteStream.write(mapBrick.getTransformedData(), callback);
        }

    };

    this.getBrickMap = (mapDigest, callback) => {
        if (typeof mapDigest === "function") {
            callback = mapDigest;
        }

        if (map) {
            return callback(undefined, map);
        }

        readBrickMap((err, brickMap) => {
            if (err) {
                return callback(err);
            }

            map = brickMap;
            callback(undefined, brickMap);
        });
    };

    //------------------------------------------ Internal functions ---------------------------------------------------

    function readBrickMapOffset(callback) {
        const readStream = fs.createReadStream(filePath, {start: 0, end: util.getBrickMapOffsetSize() - 1});

        const buffer = $$.Buffer.alloc(util.getBrickMapOffsetSize());
        let offsetBuffer = 0;

        readStream.on("data", (chunk) => {
            chunk.copy(buffer, offsetBuffer);
            offsetBuffer += chunk.length;
        });

        readStream.on("end", () => {
            callback(undefined, buffer.readBigUInt64LE());
        });

        readStream.on("error", (err) => {
            return callback(err);
        });
    }

    function readBrickMap(callback) {
        readBrickMapOffset((err, brickMapOffset) => {
            if (err) {
                if (err.code === "ENOENT") {
                    return callback(undefined, new BrickMap());
                }

                return callback(err)
            }

            mapOffset = brickMapOffset;
            const readStream = fs.createReadStream(filePath, {start: Number(brickMapOffset)});
            const buffs = [];

            readStream.on("data", (chunk) => {
                buffs.push(chunk);
            });

            readStream.on("error", (err) => {
                return callback(err);
            });

            readStream.on("end", () => {
                const brickMapData = $$.Buffer.concat(buffs);
                const mapBrick = new Brick();
                mapBrick.setTransformedData(brickMapData);
                callback(undefined, new BrickMap(mapBrick));
            });
        });
    }

    function readBrick(brickOffsetStart, brickOffsetEnd, callback) {
        const readStream = fs.createReadStream(filePath, {start: brickOffsetStart, end: brickOffsetEnd - 1});
        const buffs = [];

        readStream.on("data", (chunk) => {
            buffs.push(chunk);
        });

        readStream.on("error", (err) => {
            return callback(err);
        });

        readStream.on("end", () => {
            const brick = new Brick();
            const brickData = $$.Buffer.concat(buffs);
            brick.setTransformedData(brickData);
            callback(undefined, brick);
        });
    }
}

module.exports = {
    createFileBrickStorage(filePath) {
        return new FileBrickStorage(filePath);
    }
};

},{"../../utils/utilities":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/bar/utils/utilities.js","../Brick":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/bar/lib/Brick.js","./FileBrickMap":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/bar/lib/obsolete/FileBrickMap.js"}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/bar/lib/obsolete/FolderBrickStorage.js":[function(require,module,exports){
const BrickMap = require("../BrickMap");
const Brick = require("../Brick");

function FolderBrickStorage(location) {
    const fs = require("fs");
    const path = require("path");
    let map;

    this.setBrickMap = (brickMap) => {
        map = brickMap;
    };

    this.putBrick = (brick, callback) => {
        const writeStream = fs.createWriteStream(path.join(location, brick.getHash()));
        writeStream.write(brick.getTransformedData(), (...args) => {
            writeStream.end();
            callback(...args);
        });
    };

    this.getBrick = (brickHash, callback) => {
        fs.readFile(path.join(location, brickHash), (err, brickData) => {
            if (err) {
                return callback(err);
            }

            const brick = new Brick();
            brick.setTransformedData(brickData);
            callback(err, brick);
        });
    };

    this.deleteFile = (filePath, callback) => {
        this.getBrickMap((err, brickMap) => {
            if (err) {
                return callback(err);
            }

            fs.unlink(path.join(location, brickMap.toBrick().getHash()), (err) => {
                if (err) {
                    return callback(err);
                }

                brickMap.delete(filePath);
                this.putBrickMap(brickMap, callback);
            });
        });
    };

    this.putBrickMap = (brickMap, callback) => {
        map = brickMap;
        const brickMapBrick = brickMap.toBrick();
        brickMapBrick.setTransformParameters(brickMap.getTransformParameters());
       
        let brickId = brickMapBrick.getKey();
        if (!brickId) {
            brickId = brickMapBrick.getHash();
        }

        brickMapBrick.setKey(brickId);
        const writeStream = fs.createWriteStream(path.join(location, brickId));
        writeStream.write(brickMapBrick.getTransformedData(), (err) => {
            writeStream.end();
            callback(err, brickMapBrick.getSeed());
        });
    };

    this.getBrickMap = (mapDigest, callback) => {
        if (typeof mapDigest === "function") {
            callback = mapDigest;
            mapDigest = undefined;
        }

        if (map) {
            return callback(undefined, map);
        }

        if (typeof mapDigest === "undefined") {
            return callback(undefined, new BrickMap());
        }

        this.getBrick(mapDigest, (err, mapBrick) => {
            if (err) {
                return callback(err);
            }

            const brickMap = new BrickMap(mapBrick);
            map = brickMap;
            callback(undefined, brickMap);
        });
    }
}

module.exports = {
    createFolderBrickStorage(location) {
        return new FolderBrickStorage(location);
    }
};

},{"../Brick":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/bar/lib/Brick.js","../BrickMap":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/bar/lib/BrickMap.js","fs":false,"path":false}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/bar/utils/isStream.js":[function(require,module,exports){
function isStream(stream){
    return stream !== null && typeof stream === 'object' && typeof stream.pipe === 'function';
}

function isWritable(stream) {
    return isStream(stream) &&
        stream.writable !== false &&
        typeof stream._write === 'function' &&
        typeof stream._writableState === 'object';

}

function isReadable(stream) {
    return isStream(stream) &&
        stream.readable !== false &&
        typeof stream._read === 'function' &&
        typeof stream._readableState === 'object';
}

function isDuplex(stream){
    return isWritable(stream) &&
        isReadable(stream);
}

module.exports = {
    isStream,
    isReadable,
    isWritable,
    isDuplex
};

},{}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/bar/utils/utilities.js":[function(require,module,exports){
const OFFSET_SIZE = 8;

function getBrickMapOffsetSize() {
    return OFFSET_SIZE;
}

function ensureFileDoesNotExist(filePath, callback) {
    const fs = require('fs');
    fs.access(filePath, (err) => {
        if (!err) {
            fs.unlink(filePath, callback);
        } else {
            return callback();
        }
    });
}

module.exports = {getBrickMapOffsetSize, ensureFileDoesNotExist};
},{"fs":false}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/blockchain/OBFT/OBFTImplementation.js":[function(require,module,exports){
let pskcrypto = require("pskcrypto");
let fs = require("fs");

let consUtil = require("./transactionsUtil");



let detailedDebug = false;




let OBFTPSwarm = $$.flow.describe("OBFTProcess", {
    start: function (delegatedAgentName, communicationOutlet, pdsAdapter, pulsePeriodicity, latency, votingBox) {

        this.lset = {}; // digest -> transaction - localy generated set of transactions (`createTransactionFromSwarm` stores each transaction; `beat` resets `lset`)
        /*this.dset = {}; // digest -> transaction - remotely delivered set of transactions that will be next participate in consensus
        this.pset = {}; // digest -> transaction - consensus pending set */

        this.CP = 0;
        this.CI = undefined;
        this.LAST = 0;
        this.TOP = this.LAST+2*latency;
        this.NEXT = this.TOP+latency;
        this.NTOP = this.TOP+2*latency;

        this.pulsesHistory = new PulseHistory();

        this.vsd = pdsAdapter.getHashLatestBlock();


        this.currentBlock = 0;
        this.nodeName               = delegatedAgentName;
        this.communicationOutlet    = communicationOutlet;
        this.pds                    = pdsAdapter;
        this.PP                     = pulsePeriodicity;
        this.LATENCY                = latency;
        this.votingBox              = votingBox;
        this.explictPhase           = "default"; /* default, boot, late, broken*/

        this.bootNode();
    },
    /*
    * @param {transaction}
    */
    receiveTransaction:function(t){
        this.lset[t.digest] = t;
    },
    /*
     * @param {}
    */
    sendPulse: function () {
        switch(this.explictPhase){
            case "boot": break;
            case "late": break;
            case "ntop": this.sendAtNTOP(); break;
            case "broken":this.whenBroken_HumanInterventionIsRequired(); break
            default:
                if(this.CP <= this.TOP) this.sendUntilTOP(); else
                if(this.CP < this.NEXT) this.sendUntilNEXT(); else
                if(this.CP == this.NEXT) this.sendAtNEXT(); else
                if(this.CP < this.NTOP) this.sendUntilNTOP(); else
                if(this.CP == this.NTOP) this.sendAtNTOP(); else
                    console.log("Should not happen");
        }
        setTimeout(this.sendPulse, this.PP);   //self invocation of the phase
    },
    /*
     * @param {}
    */
    sendUntilTOP: function () {
        communicationOutlet.newPulse()
    },
    /*
     * @param {}
    */
    sendUntilNEXT: function () {

    },
    /*
     * @param {}
    */
    sendAtNEXT: function () {

    },
    /*
     * @param {}
    */
    sendUntilNTOP: function () {

    },
    /*
     * @param {}
    */
    sendAtNTOP: function () {

    },
    /*
     * @param {}
    */
    whenSlowNode: function () {

    },
    /*
     * @param {}
    */
    whenSlowNetwork: function () {

    },
    /*
     * @param {}
    */
    whenBroken_HumanInterventionIsRequired: function () {

    },
    /*
     * @param {pulse}
    */
    receivePulse:function(pulse){

    },
    /*
     * @param {}
    */
    bootNode: function () {
        this.explictPhase = "BOOT";
    },
     /*
     * @param {Pulse} pulse e.g. new Pulse(this.nodeName, this.currentPulse, ......)
     */
    recordPulse: function (pulse) {
    },
    /*
         * @param {}
        */
    requestMissingPulse: function () {

    }
});


/**
 * @param {String} delegatedAgentName e.g. 'Node 0', or 'agent_007'
 * @param {Object} communicationOutlet e.g. object to be used in phase `beat` of the returned "pulseSwarm" flow
 *  - it should have a property: `broadcastPulse`: function(from, pulse) {...}
 *      - {String} `from` e.g. `delegatedAgentName`
 *      - {Pulse} `pulse` (see 'transactionsUtil.js')
 * @param {InMemoryPDS} pdsAdapter e.g. require("pskdb/lib/InMemoryPDS").newPDS(null);
 * @param {Number} pulsePeriodicity e.g. 300
 * 
 * @returns {SwarmDescription} A new instance of "pulseSwarm" flow, with phase `start` already running
 */
exports.createConsensusManager = function (delegatedAgentName, communicationOutlet, pdsAdapter, pulsePeriodicity, votingBox) {
    let instance = pulseSwarm();
    instance.start(delegatedAgentName, communicationOutlet, pdsAdapter, pulsePeriodicity, votingBox);
    return instance;
}

},{"./transactionsUtil":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/blockchain/OBFT/transactionsUtil.js","fs":false,"pskcrypto":"pskcrypto"}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/blockchain/OBFT/PulseUtil.js":[function(require,module,exports){
function PulseUtil(signer, currentPulseNumber, block, newTransactions, vsd, top, last) {
    this.signer         = signer;               //a.k.a. delegatedAgentName
    this.currentPulse   = currentPulseNumber;
    this.lset           = newTransactions;      //digest -> transaction
    this.ptBlock        = block;                //array of digests
    this.vsd            = vsd;
    this.top            = top;                  // a.k.a. topPulseConsensus
    this.last           = last;                 // a.k.a. lastPulseAchievedConsensus
}


module.exports.createPulse = function (signer, CP, CI, lset, top, last) {
    return new PulseUtil(signer, CP, CI, lset, vsd, top, last);
}


function PulseHistory(){

}

module.exports.createPulseHistory = function () {
    return new PulseHistory();
}
},{}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/blockchain/OBFT/transactionsUtil.js":[function(require,module,exports){
/*
consensus helper functions when working with transactions
*/

let  pskcrypto = require("pskcrypto");


module.exports.orderCRTransactions = function (pset) { //order in place the pset array
    var arr = [];
    for (let d in pset) {
        arr.push(pset[d]);
    }

    arr.sort(function (t1, t2) {
        if (t1.transactionPulse < t2.transactionPulse) return -1;
        if (t1.transactionPulse > t2.transactionPulse) return 1;
        if (t1.second < t2.second) return -1;
        if (t1.second > t2.second) return 1;
        if (t1.nanosecod < t2.nanosecod) return -1;
        if (t1.nanosecod > t2.nanosecod) return 1;
        if (t1.digest < t2.digest) return -1;
        if (t1.digest > t2.digest) return 1;
        return 0; //only for identical transactions...
    })
    return arr;
}

},{"pskcrypto":"pskcrypto"}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/blockchain/blockchainSwarmTypes/asset_swarm_template.js":[function(require,module,exports){
var CNST = require("../moduleConstants");

exports.createForObject = function(valueObject, thisObject, localId){
	var callflowModule = require("callflow");
	var ret = callflowModule.createStandardAPIsForSwarms(valueObject, thisObject, localId);

	ret.swarm           = null;
	ret.onReturn        = null;
	ret.onResult        = null;
	ret.asyncReturn     = null;
	ret.return          = null;
	ret.home            = null;

	ret.autoInit        = function(blockchain){
		if(!blockchain) {
			$$.warn("Initialisation asset outside of a blockchain context");
			return;
		}
		let sp = thisObject.getMetadata(CNST.SECURITY_PARADIGM);
		thisObject.securityParadigm = blockchain.getSPRegistry().getSecurityParadigm(thisObject);
		if(sp == undefined){
			let ctor = valueObject.myFunctions[CNST.CTOR];
			if(ctor){
				ctor.apply(thisObject);
			}
		}
	};

	ret.getSwarmId = function(){
		return 	thisObject.getMetadata(CNST.SWARMID);
	};

	ret.getSwarmType = function(){
		return 	thisObject.getMetadata(CNST.SWARMTYPE);
	};

	ret.__reinit = function(blockchain){
		ret.autoInit(blockchain);
	};

	ret.asJSON = function(){
		return thisObject.getInnerValue().publicVars;
	};

	return ret;
};
},{"../moduleConstants":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/blockchain/moduleConstants.js","callflow":"callflow"}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/blockchain/blockchainSwarmTypes/transaction_swarm_template.js":[function(require,module,exports){
let CNST = require("../moduleConstants");

exports.createForObject = function(valueObject, thisObject, localId){
	let callflowModule = require("callflow");

	let _blockchain = undefined;
	let ret = callflowModule.createStandardAPIsForSwarms(valueObject, thisObject, localId);
	ret.swarm           = null;
	ret.onReturn        = null;
	ret.onResult        = null;
	ret.asyncReturn     = null;
	ret.autoInit        = function(blockchain){
		_blockchain = blockchain;
		thisObject.transaction = blockchain.beginTransaction(thisObject);
	};

	ret.commit = function () {
		_blockchain.commit(thisObject.transaction, (error, status) => {
			thisObject.transaction.getSwarm().notify({eventType: "commit", error, status});
		});
	};

	ret.onCommit = function (callback) {
		thisObject.observe((event) => {
			callback(event.error, event.status);
		}, undefined, (event)=>{
			return event.eventType === "commit";
		});
	};

	ret.onReturn = function (callback) {
		thisObject.observe((event) => {
			callback(event.error, event.result);
		}, undefined, (event)=>{
			return event.eventType === "return";
		});
	};

	ret.return = function(error, result){
		thisObject.notify({eventType: "return", error, result});
	};

	ret.home = ret.return;

	return ret;
};
},{"../moduleConstants":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/blockchain/moduleConstants.js","callflow":"callflow"}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/blockchain/defaultConstitution/assets/ACLScope.js":[function(require,module,exports){

$$.asset.describe("ACLScope", {
    public:{
        concern:"string:key",
        db:"json"
    },
    init:function(concern){
        this.concern = concern;
    },
    addResourceParent : function(resourceId, parentId){

    },
    addZoneParent : function(zoneId, parentId){

    },
    grant :function(agentId,  resourceId){

    },
    allow :function(agentId,  resourceId){
        return true;
    }
});
},{}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/blockchain/defaultConstitution/assets/Agent.js":[function(require,module,exports){

$$.asset.describe("Agent", {
    public:{
        alias:"string:key",
        publicKey:"string"
    },
    init:function(alias, value){
        this.alias      = alias;
        this.publicKey  = value;
    },
    update:function(value){
        this.publicKey = value;
    },
    addAgent: function () {
        throw new Error('Not Implemented');
    },
    listAgent: function () {
        throw new Error('Not Implemented');

    },
    removeAgent: function () {
        throw new Error('Not Implemented');

    }
});
},{}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/blockchain/defaultConstitution/assets/Backup.js":[function(require,module,exports){

$$.asset.describe("Backup", {
    public:{
        id:  "string",
        url: "string"
    },

    init:function(id, url){
        this.id = id;
        this.url = url;
    }
});

},{}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/blockchain/defaultConstitution/assets/BarAnchor.js":[function(require,module,exports){
$$.asset.describe("BarAnchor", {
    public: {
        alias: "string",
        mountPoint: "string",
        brickMapDigest: "string",
        readList: "array", //encrypted seeds with public keys
        writeList: "array", //agentIds
    },
    init: function (mountPoint, brickMapDigest) {
        this.mountPoint = mountPoint;
        this.brickMapDigest = brickMapDigest;
    },
    updateReadList: function (encryptedSeed) {
        if (!this.readList) {
            this.readList = [];
        }
        this.readList.push(encryptedSeed);
    },
    updateWriteList: function (agentId) {
        if (!this.writeList) {
            this.writeList = [];
        }

        this.writeList.push(agentId);
    }
});
},{}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/blockchain/defaultConstitution/assets/CSBMeta.js":[function(require,module,exports){

$$.asset.describe("CSBMeta", {
	public:{
		isMaster:"string",
		alias:"string:key",
		description: "string",
		creationDate: "string",
		updatedDate : "string",
		id: "string",
		icon: "string"
	},
	init:function(id){
		this.alias = "meta";
		this.id = id;
	},

	setIsMaster: function (isMaster) {
		this.isMaster = isMaster;
	}

});

},{}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/blockchain/defaultConstitution/assets/DomainConfig.js":[function(require,module,exports){

$$.asset.describe("DomainConfig", {
    public:{
        alias:"string:key",
        blockChainStorageFolderName:"",
        addresses: "map",
        communicationInterfaces: "map",
        workerStrategy: "string"
    },
    init:function(alias){
        this.alias = alias;
        this.addresses = {};
        this.communicationInterfaces = {};
        this.workerStrategy = 'threads';
    },
    updateDomainAddress:function(replicationAgent, address){
        if(!this.addresses){
            this.addresses = {};
        }
        this.addresses[replicationAgent] = address;
    },
    removeDomainAddress:function(replicationAgent){
        this.addresses[replicationAgent] = undefined;
        delete this.addresses[replicationAgent];
    },
    setBlockChainStorageFolderName: function(storageFolderName){
        this.blockChainStorageFolderName = storageFolderName;
    },
    getBlockChainStorageFolderName: function() {
        return this.blockChainStorageFolderName;
    },
    addCommunicationInterface(alias, virtualMQEndpoint, zeroMQEndpoint) {
        if (!this.communicationInterfaces) {
            this.communicationInterfaces = {};
        }
        this.communicationInterfaces[alias] = {virtualMQ: virtualMQEndpoint, zeroMQ: zeroMQEndpoint};
    },
    setWorkerStrategy: function(workerStrategy) {
        this.workerStrategy = workerStrategy;
    }
});
},{}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/blockchain/defaultConstitution/assets/DomainReference.js":[function(require,module,exports){

$$.asset.describe("DomainReference", {
    public:{
        role:"string:index",
        alias:"string:key",
        constitution:"string",
        workspace:"string"
    },
    init:function(role, alias){
        this.role = role;
        this.alias = alias;
    },
    setConstitution:function(pathOrUrlOrCSB){
        this.constitution = pathOrUrlOrCSB;
    },
    getConstitution:function(){
        return this.constitution;
    },
    setWorkspace:function(path){
        this.workspace = path;
    },
    getWorkspace:function(){
        return this.workspace;
    }
});
},{}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/blockchain/defaultConstitution/assets/FileAnchor.js":[function(require,module,exports){
$$.asset.describe("FileAnchor", {
    public: {
        alias: "string",
        type: "string",
        seed: "string",
        digest: "string", //csb digest after file addition
        readList: "array", //encrypted seeds with public keys
        writeList: "array", //agentIds
    },
    init: function (alias, type, seed, digest) {
        this.alias = alias;
        this.type = type;
        this.seed = seed;
        this.digest = digest;
    }
});


},{}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/blockchain/defaultConstitution/assets/Key.js":[function(require,module,exports){

$$.asset.describe("key", {
    public:{
        alias:"string"
    },
    init:function(alias, value){
        this.alias = alias;
        this.value = value;
    },
    update:function(value){
        this.value = value;
    }
});
},{}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/blockchain/defaultConstitution/assets/index.js":[function(require,module,exports){
module.exports = $$.library(function(){
    require("./DomainReference");
    require("./DomainConfig");
    require("./Agent");
    require("./Backup");
    require("./ACLScope");
    require("./Key");
    require("../transactions/transactions");
    require("./BarAnchor");
    require("./FileAnchor");
    require('./CSBMeta');
});
},{"../transactions/transactions":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/blockchain/defaultConstitution/transactions/transactions.js","./ACLScope":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/blockchain/defaultConstitution/assets/ACLScope.js","./Agent":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/blockchain/defaultConstitution/assets/Agent.js","./Backup":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/blockchain/defaultConstitution/assets/Backup.js","./BarAnchor":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/blockchain/defaultConstitution/assets/BarAnchor.js","./CSBMeta":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/blockchain/defaultConstitution/assets/CSBMeta.js","./DomainConfig":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/blockchain/defaultConstitution/assets/DomainConfig.js","./DomainReference":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/blockchain/defaultConstitution/assets/DomainReference.js","./FileAnchor":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/blockchain/defaultConstitution/assets/FileAnchor.js","./Key":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/blockchain/defaultConstitution/assets/Key.js"}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/blockchain/defaultConstitution/swarms/index.js":[function(require,module,exports){
if($$.swarms){
    $$.swarms.describe("transactionHandler", {
        start: function (identity, transactionName, methodName, ...args) {
            let transaction = $$.blockchain.startTransactionAs(identity, transactionName, methodName, ...args);
            transaction.onReturn((err, result) => {
                this.return(err, result);
            });
        }
    });
}

},{}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/blockchain/defaultConstitution/transactions/agentTransaction.js":[function(require,module,exports){
const sharedPhases = require('./sharedPhases');

$$.transaction.describe("Agents", {
    add: function (alias, publicKey) {
        let agent = $$.blockchain.lookup("Agent", alias);
        if(!agent){
            agent = $$.asset.start("Agent", "init", alias, publicKey);
        }else{
            $$.exception(`Agent with ${alias} already exists!`);
        }

        this.transaction.add(agent);
        this.onCommit(()=>{
            this.return(undefined, agent.asJSON());
        });
        this.commit();
    },
    getAgents: sharedPhases.getAllAssetsFactory('global.Agent')
});

},{"./sharedPhases":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/blockchain/defaultConstitution/transactions/sharedPhases.js"}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/blockchain/defaultConstitution/transactions/domainConfigTransaction.js":[function(require,module,exports){
const sharedPhases = require('./sharedPhases');

$$.transaction.describe("DomainConfigTransaction", {
    add: function (alias, communicationInterfaces, workerStrategy) {
        let domain = this.transaction.lookup("DomainConfig", alias);

        if(!domain){
            domain = this.transaction.createAsset("DomainConfig", "init", alias);
        }else{
            $$.exception(`Domain with ${alias} already exists!`);
        }

        if(typeof communicationInterfaces !== "undefined"){
            Object.keys(communicationInterfaces).forEach(commAlias => {
                const {virtualMQ, zeroMQ} = communicationInterfaces[commAlias];
                domain.addCommunicationInterface(commAlias, virtualMQ, zeroMQ);
            });
        }

        if(workerStrategy) {
            domain.setWorkerStrategy(workerStrategy);
        }

        this.transaction.add(domain);
        this.onCommit(()=>{
            this.return(undefined, domain.asJSON());
        });
        this.commit();
    },
    getDomainDetails: sharedPhases.getAssetFactory('global.DomainConfig'),
    getDomains: sharedPhases.getAllAssetsFactory('global.DomainConfig')
});

},{"./sharedPhases":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/blockchain/defaultConstitution/transactions/sharedPhases.js"}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/blockchain/defaultConstitution/transactions/domainTransaction.js":[function(require,module,exports){
const sharedPhases = require('./sharedPhases');

$$.transaction.describe("Domain", {
    add: function (alias, role, workspace, constitution) {
        let domain = this.transaction.lookup("DomainReference", alias);

        if(!domain){
            domain = this.transaction.createAsset("DomainReference", "init", role, alias);
        }else{
            $$.exception(`Domain with ${alias} already exists!`);
        }

        if(typeof workspace !== "undefined"){
            domain.setWorkspace(workspace);
        }

        if(typeof constitution !== "undefined"){
            domain.setConstitution(constitution);
        }

        this.transaction.add(domain);
        this.onCommit(()=>{
            this.return(undefined, domain.asJSON());
        });
        this.commit();
    },
    connectDomainLocally: function(alias, localInterface){
        let domain = this.transaction.lookup("DomainReference", alias);
        domain.addLocalInterface('local', localInterface);

        this.transaction.add(domain);
        this.onCommit(()=>{
            this.return(undefined, domain.asJSON());
        });
        this.commit();
    },
    setWorkspaceForDomain: function(alias, workspace){
        let domain = this.transaction.lookup("DomainReference", alias);
        domain.setWorkspace(workspace);

        this.transaction.add(domain);
        this.onCommit(()=>{
            this.return(undefined, domain.asJSON());
        });
        this.commit();
    },
    setConstitutionForDomain: function(alias, constitution){
        let domain = this.transaction.lookup("DomainReference", alias);
        domain.setConstitution(constitution);

        this.transaction.add(domain);
        this.onCommit(()=>{
            this.return(undefined, domain.asJSON());
        });
        this.commit();
    },
    getDomainDetails:function(alias){
        let domain = this.transaction.lookup("DomainReference", alias);
        return domain.toJson();
    },
    connectDomainToRemote(domainName, alias, remoteEndPoint){
        let domain = this.transaction.lookup("DomainReference", domainName);
        domain.addRemoteInterface(alias, remoteEndPoint);

        this.transaction.add(domain);
        this.onCommit(()=>{
            this.return(undefined, domain.asJSON());
        });
        this.commit();
    },
    setWorkerStrategy: function (alias, workerStrategy) {
        const domainReference =  this.transaction.lookup("DomainReference", alias);
        if(!domainReference) {
            $$.exception(`Domain with alias ${alias} does not exist!`);
        }

        domainReference.setWorkerStrategy(workerStrategy);

        this.transaction.add(domainReference);
        this.onCommit(()=>{
            this.return(undefined, domainReference.asJSON());
        });
        this.commit();
    },
    setMaximumNumberOfWorkers: function (alias, maximumNumberOfWorkers) {
        const domainReference =  this.transaction.lookup("DomainReference", alias);
        if(!domainReference) {
            $$.exception(`Domain with alias ${alias} does not exist!`);
        }

        domainReference.setMaximumNumberOfWorkers(maximumNumberOfWorkers);

        this.transaction.add(domainReference);
        this.onCommit(()=>{
            this.return(undefined, domainReference.asJSON());
        });
        this.commit();
    },
    getDomainDetails: sharedPhases.getAssetFactory('global.DomainReference'),
    getDomains: sharedPhases.getAllAssetsFactory('global.DomainReference')
});

},{"./sharedPhases":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/blockchain/defaultConstitution/transactions/sharedPhases.js"}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/blockchain/defaultConstitution/transactions/firstTransactionWorkaroundDeleteThis.js":[function(require,module,exports){
/**
 * FIXME
 * The first block in the blockchain is 0.
 * When creating a CSB, if only one transaction is committed (only one block written) then only the block 0
 * will be written and blocks/index will have the value 0
 * When loading again the CSB, the CSB's blockchain will replay transaction from pulse 0 until 0, currentPulse
 * remaining 0. When creating a new transaction, it will have pulse 0 again and the block 0 will be overwritten.
 *
 * This transaction's purpose is to always start the blockchain with at least one transaction so it will hopefully
 * write at least two blocks in the beginning
 */
$$.transaction.describe("TooShortBlockChainWorkaroundDeleteThis", {
    add: function () {
        this.onCommit(()=>{
            this.return();
        });
        this.commit();
    }
});
},{}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/blockchain/defaultConstitution/transactions/index.js":[function(require,module,exports){
require('./domainTransaction');
require('./agentTransaction');
require('./standardCSBTransactions');
require('./domainConfigTransaction');
require('./firstTransactionWorkaroundDeleteThis');
},{"./agentTransaction":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/blockchain/defaultConstitution/transactions/agentTransaction.js","./domainConfigTransaction":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/blockchain/defaultConstitution/transactions/domainConfigTransaction.js","./domainTransaction":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/blockchain/defaultConstitution/transactions/domainTransaction.js","./firstTransactionWorkaroundDeleteThis":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/blockchain/defaultConstitution/transactions/firstTransactionWorkaroundDeleteThis.js","./standardCSBTransactions":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/blockchain/defaultConstitution/transactions/standardCSBTransactions.js"}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/blockchain/defaultConstitution/transactions/sharedPhases.js":[function(require,module,exports){
module.exports = {
    getAssetFactory: function(assetType) {
        return function(alias) {
            const transaction = $$.blockchain.beginTransaction({});
            const domainReferenceSwarm = transaction.lookup(assetType, alias);

            if(!domainReferenceSwarm) {
                this.return(new Error(`Could not find swarm named "${assetType}"`));
                return;
            }

            this.return(undefined, domainReferenceSwarm.asJSON());
        }
    },
    getAllAssetsFactory: function(assetType) {
        return function() {
            const transaction = $$.blockchain.beginTransaction({});
            const domains = transaction.loadAssets(assetType) || [];

            this.return(undefined, domains.map(domain => domain.asJSON()));
        };
    }
};
},{}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/blockchain/defaultConstitution/transactions/standardCSBTransactions.js":[function(require,module,exports){
$$.transaction.describe("StandardCSBTransactions", {
    addBarAnchor: function (mountPoint, brickMapDigest) {
        this.transaction.createAsset("BarAnchor", "init", mountPoint, brickMapDigest);
        this.commit();
    },

    addFileAnchor: function (alias, type, seed, digest) {
        try{
            let fileAnchor = this.transaction.createAsset("FileAnchor", "init", alias, type, seed, digest);

            this.onCommit(() => {
                this.return(undefined, fileAnchor.asJSON());
            });

            this.commit();

        }catch(e) {
            this.return(e.message);
        }
    },

    domainLookup: function(alias){
        try{
            let fileAnchor = this.transaction.lookup("FileAnchor", alias);
            this.return(undefined, fileAnchor ? fileAnchor.asJSON() : "");
        }catch(err){
            this.return(err.message);
        }
    },
    updateFileDigest: function (alias, digest) {
        const file = this.transaction.lookup("FileAnchor", alias);
        file.digest = digest;
        this.transaction.add(file);
        this.transaction.commit();
    },
    getSeed: function (alias) {
        try {
            const anchor = this.transaction.lookup("FileAnchor", alias);
            this.return(undefined, anchor.seed);
        } catch (e) {
            this.return(e.message);
        }
    }
});
},{}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/blockchain/defaultConstitution/transactions/transactions.js":[function(require,module,exports){
$$.transaction.describe("transactions", {
    updateKey: function (key, value) {
        var transaction = $$.blockchain.beginTransaction(this);
        var key = transction.lookup("Key", key);
        var keyPermissions = transaction.lookup("ACLScope", "KeysConcern");
        if (keyPermissions.allow(this.agentId, key)) {
            key.update(value);
            transaction.add(key);
            $$.blockchain.commit(transaction);
        } else {
            this.securityError("Agent " + this.agentId + " denied to change key " + key);
        }
    },
    addChild: function (alias) {
        var transaction = $$.blockchain.beginTransaction();
        var reference = $$.contract.start("DomainReference", "init", "child", alias);
        transaction.add(reference);
        $$.blockchain.commit(transaction);
    },
    addParent: function (value) {
        var reference = $$.contract.start("DomainReference", "init", "child", alias);
        this.transaction.save(reference);
        $$.blockchain.persist(this.transaction);
    },
    addAgent: function (alias, publicKey) {
        var reference = $$.contract.start("Agent", "init", alias, publicKey);
        this.transaction.save(reference);
        $$.blockchain.persist(this.transaction);
    },
    updateAgent: function (alias, publicKey) {
        let agent = this.transaction.lookup("Agent", alias);
        agent.update(publicKey);
        this.transaction.save(agent);
        $$.blockchain.persist(this.transaction);
    }
});


$$.newTransaction = function(transactionFlow,ctor,...args){
    var transaction = $$.swarm.start( transactionFlow);
    transaction.meta("agentId", $$.currentAgentId);
    transaction.meta("command", "runEveryWhere")
    transaction.meta("ctor", ctor);
    transaction.meta("args", args);
    transaction.sign();
    //$$.blockchain.sendForConsent(transaction);
    //temporary until consent layer is activated
    transaction[ctor].apply(transaction,args);
}

/*
usages:
    $$.newTransaction("domain.transactions", "updateKey", "key", "value")

 */

},{}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/blockchain/moduleConstants.js":[function(require,module,exports){
module.exports = {
    ALIAS:"alias",
    ALIASES : '/aliases',
    SECURITY_PARADIGM:"SecurityParadigm",
    RESTRICTED:"Restricted",
    CONSTITUTIONAL:"Constitutional",
    PREDICATIVE:"Predicative",
    CTOR:"ctor",
    COMMAND_ARGS:"COMMAND_ARGS",
    SIGNING_AGENT:"SIGNING_AGENT",
    INTIALISATION_CONTEXT:"intialisationContext",
    SWARMID:"swarmId",
    SWARMTYPE:"swarmTypeName"
};
},{}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/blockchain/moduleExports.js":[function(require,module,exports){
module.exports = {
    createBlockchain:function(worldStateCache, historyStorage, consensusAlgorithm, signatureProvider, loadDefaultConstitution, forcedBoot){
        return require("./pskdb").startDefaultDB(worldStateCache, historyStorage, consensusAlgorithm, signatureProvider, loadDefaultConstitution, forcedBoot);
    },
    createABlockchain:function(worldStateCache, historyStorage, consensusAlgorithm, signatureProvider, loadDefaultConstitution, forcedBoot){
        return require("./pskdb").startDB(worldStateCache, historyStorage, consensusAlgorithm, signatureProvider, loadDefaultConstitution, forcedBoot);
    },
    createHistoryStorage:function(storageType,...args){
        return require("./strategies/historyStorages/historyStoragesRegistry").createStorage(storageType,...args);
    },
    createWorldStateCache:function(storageType,...args){
        return require("./strategies/worldStateCaches/worldStateCacheRegistry").createCache(storageType,...args);
    },
    createConsensusAlgorithm:function(name,...args){
        return require("./strategies/consensusAlgortims/consensusAlgoritmsRegistry").createAlgorithm(name,...args);
    },
    createCRTransaction:function (swarmType, command, input, output, currentPulse) {
        /*
            class for Command or Result transactions
        */
        function CRTransaction(swarmType, command, input, output, currentPulse) {
            var pskcrypto = require("pskcrypto");

            this.swarmType = swarmType;

            if(input && output){
                this.input      = input;
                this.output     = output;
            }
            this.command      = command;

            let arr = process.hrtime();
            this.second     = arr[0];
            this.nanosecod  = arr[1];
            this.transactionPulse = currentPulse;
            this.digest     = pskcrypto.hashValues(this);
        }

        return new CRTransaction(swarmType, command, input, output, currentPulse);
    },
    createBlock:function (blockset, pulse, previous) {
        let pskcrypt = require("pskcrypto");
        var block = {blockset, pulse, previous};
        block.hash = pskcrypt.hashValues(block);
        return block;
    },
    createSignatureProvider:function(name,...args){
        return require("./strategies/signatureProvidersRegistry/signatureProvidersRegistry").createSignatureProvider(name,...args);
    },
    createNetworkCommunicationStrategy:function(name,...args){
        return require("./strategies/networkCommunication/networkCommunicationStrategiesRegistry").createNetworkAdapter(name,...args);
    },
    createVotingStrategy:function(name,...args){
        return require("./strategies/votingStrategies/votingStrategiesRegistry").createVotingStrategy(name,...args);
    }
}
},{"./pskdb":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/blockchain/pskdb/index.js","./strategies/consensusAlgortims/consensusAlgoritmsRegistry":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/blockchain/strategies/consensusAlgortims/consensusAlgoritmsRegistry.js","./strategies/historyStorages/historyStoragesRegistry":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/blockchain/strategies/historyStorages/historyStoragesRegistry.js","./strategies/networkCommunication/networkCommunicationStrategiesRegistry":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/blockchain/strategies/networkCommunication/networkCommunicationStrategiesRegistry.js","./strategies/signatureProvidersRegistry/signatureProvidersRegistry":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/blockchain/strategies/signatureProvidersRegistry/signatureProvidersRegistry.js","./strategies/votingStrategies/votingStrategiesRegistry":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/blockchain/strategies/votingStrategies/votingStrategiesRegistry.js","./strategies/worldStateCaches/worldStateCacheRegistry":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/blockchain/strategies/worldStateCaches/worldStateCacheRegistry.js","pskcrypto":"pskcrypto"}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/blockchain/pskdb/Blockchain.js":[function(require,module,exports){
const bm = require('../moduleExports');
var CNST = require("../moduleConstants");

function AliasIndex(assetType, pdsHandler, worldStateCache) {
    this.create = function (alias, uid) {
        const assetAliases = this.getAliases();

        if (typeof assetAliases[alias] !== "undefined") {
            $$.exception(`Alias ${alias} for assets of type ${assetType} already exists`);
        }

        assetAliases[alias] = uid;

        worldStateCache.writeKey(assetType + CNST.ALIASES, J(assetAliases));
    };

    this.getUid = function (alias) {
        const assetAliases = this.getAliases();
        //console.log("assetAliases", assetAliases);
        return assetAliases[alias];
    };

    this.getAliases = function () {
        let aliases = worldStateCache.readKey(assetType + CNST.ALIASES);
        return aliases ? JSON.parse(aliases) : {};
    }
}

function createLoadAssets(blockchain, pdsHandler, worldStateCache) {
    return function (assetType) {
        assetType = $$.fixSwarmName(assetType);
        const assets = [];

        const aliasIndex = new AliasIndex(assetType, pdsHandler, worldStateCache);
        Object.keys(aliasIndex.getAliases()).forEach(alias => {
            assets.push(blockchain.lookup(assetType, alias));
        });

        return assets;
    };
}

function createLookup(blockchain, pdsHandler, SPRegistry, worldStateCache) {
    function hasAliases(spaceName) {
        let ret = !!worldStateCache.readKey(spaceName + CNST.ALIASES);
        return ret;
    }

    return function (assetType, aid) { // aid == alias or id

        let localUid = aid;
        assetType = $$.fixSwarmName(assetType);

        if (hasAliases(assetType)) {
            const aliasIndex = new AliasIndex(assetType, pdsHandler, worldStateCache);
            localUid = aliasIndex.getUid(aid) || aid;
        }

        const value = pdsHandler.readKey(assetType + '/' + localUid, true);

        if (!value) {
            $$.log("Lookup fail, asset not found: ", assetType, " with alias", aid, value);
            //pdsHandler.dump();
            //return $$.asset.start(assetType);
            return null;
        } else {
            const asset = $$.asset.continue(assetType, JSON.parse(value));
            asset.__reinit(blockchain);
            return asset;
        }
    };
}

function Blockchain(pskdb, consensusAlgorithm, worldStateCache, signatureProvider) {
    let spr = require("./securityParadigms/securityParadigmRegistry").getRegistry(this);
    let self = this;

    consensusAlgorithm.setPSKDB(pskdb);

    this.beginTransaction = function (transactionSwarm, handler) {
        if (!transactionSwarm) {
            $$.exception("Can't begin a transaction outside of a swarm instance from transactions namespace");
        }
        if (!handler) {
            handler = pskdb.getHandler();
        }
        return new Transaction(self, handler, transactionSwarm, worldStateCache, spr);
    };


    this.start = function (reportBootingFinishedCallback) {
        pskdb.initialise(function (err, res) {
            reportBootingFinishedCallback(err, self);
        });
    };


    this.lookup = function (assetType, aid) {
        let newLookup = createLookup(self, pskdb.getHandler(), spr, worldStateCache);
        return newLookup(assetType, aid);
    };

    this.loadAssets = createLoadAssets(self, pskdb.getHandler(), worldStateCache);

    this.getSPRegistry = function () {
        return spr;
    };

    this.signAs = function (agentId, msg) {
        return signatureProvider.signAs(agentId, msg);
    };

    this.verifySignature = function (msg, signatures) {
        return signatureProvider.verify(msg, signatures);
    };


    this.registerSecurityParadigm = function (SPName, apiName, factory) {
        return spr.register(SPName, apiName, factory);
    };


    this.startCommandAs = function (agentId, transactionSwarmType, ...args) {
        let t = bm.createCRTransaction(transactionSwarmType, args, null, null, consensusAlgorithm.getCurrentPulse());
        t.signatures = [this.signAs(agentId, t.digest)];
        consensusAlgorithm.commit(t);
    };

    this.startTransactionAs = function (agentId, transactionSwarmType, ...args) {
        let swarm = $$.transaction.startWithContext(self, transactionSwarmType, ...args);
        swarm.setMetadata(CNST.COMMAND_ARGS, args);
        swarm.setMetadata(CNST.SIGNING_AGENT, agentId);
        return swarm;
        //console.log(swarm);
    };

    this.commit = function (transaction, callback) {
        let swarm = transaction.getSwarm();
        let handler = transaction.getHandler();
        const diff = handler.computeSwarmTransactionDiff(swarm);
        //console.log("Diff is", diff.output);
        const t = bm.createCRTransaction(swarm.getMetadata("swarmTypeName"), swarm.getMetadata(CNST.COMMAND_ARGS), diff.input, diff.output, consensusAlgorithm.getCurrentPulse());
        t.signatures = [self.signAs(swarm.getMetadata(CNST.SIGNING_AGENT), t.digest)];
        consensusAlgorithm.commit(t, callback);
    };

    this.onceAllCommitted = pskdb.onceAllCommitted;

    this.dump = function () {
        pskdb.getHandler().dump();
    };
}

function Transaction(blockchain, pdsHandler, transactionSwarm, worldStateCache, spr) {

    let self = this;

    this.getSwarm = function () {
        return transactionSwarm;
    };

    this.getHandler = function () {
        return pdsHandler;
    };

    this.add = function (asset) {
        const swarmTypeName = asset.getMetadata('swarmTypeName');
        const swarmId = asset.getMetadata('swarmId');

        const aliasIndex = new AliasIndex(swarmTypeName, pdsHandler, worldStateCache);
        if (asset.alias && aliasIndex.getUid(asset.alias) !== swarmId) {
            aliasIndex.create(asset.alias, swarmId);
        }


        const serializedSwarm = require("swarmutils").beesHealer.asJSON(asset, null, null);
        pdsHandler.writeKey(swarmTypeName + '/' + swarmId, J(serializedSwarm));
    };

    this.lookup = createLookup(blockchain, pdsHandler, spr, worldStateCache);

    this.loadAssets = createLoadAssets(blockchain, pdsHandler, worldStateCache);

    this.createAsset = function (swarmTypeName, ctor, ...args) {
        let asset = $$.assets.startWithContext(blockchain, swarmTypeName, ctor, ...args);
        this.add(asset);
        return asset;
    };

    this.reviveAsset = function (assetValue) {
        let asset = $$.assets.continue(assetValue);
        asset.__reinit(self);
        return asset;
    };


    this.commit = function () {
        blockchain.commit(self);
    };
}

module.exports = Blockchain;
},{"../moduleConstants":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/blockchain/moduleConstants.js","../moduleExports":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/blockchain/moduleExports.js","./securityParadigms/securityParadigmRegistry":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/blockchain/pskdb/securityParadigms/securityParadigmRegistry.js","swarmutils":"swarmutils"}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/blockchain/pskdb/index.js":[function(require,module,exports){
const Blockchain = require('./Blockchain');

module.exports = {
    startDB: function (worldStateCache, historyStorage, consensusAlgorithm, signatureProvider, loadDefaultConstitution) {
        if(loadDefaultConstitution){
            require('../defaultConstitution/assets/index');
            require('../defaultConstitution/swarms/index');
            require('../defaultConstitution/transactions/index');
        }
        let pds = require('./pskdb').newPSKDB(worldStateCache, historyStorage);
        consensusAlgorithm.pskdb = pds;
        let blockchain = new Blockchain(pds, consensusAlgorithm, worldStateCache, signatureProvider);
        pds.blockchain = blockchain;
        return blockchain;
    },
    startDefaultDB: function (worldStateCache, historyStorage, consensusAlgorithm, signatureProvider, loadDefaultConstitution, forceReboot) {
        if ($$.blockchain && !forceReboot) {
            $$.exception('$$.blockchain is already defined. Throwing an exception!');
        }
        if(!worldStateCache || !historyStorage || !consensusAlgorithm || !signatureProvider){
            console.error("Initialisation failed with arguments:", worldStateCache, historyStorage, consensusAlgorithm, signatureProvider);
            $$.exception('$$.blockchain initialisation failed! Throwing an exception!');
        }
        $$.blockchain = this.startDB(worldStateCache, historyStorage, consensusAlgorithm, signatureProvider, loadDefaultConstitution);
        return $$.blockchain;
    }
};

},{"../defaultConstitution/assets/index":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/blockchain/defaultConstitution/assets/index.js","../defaultConstitution/swarms/index":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/blockchain/defaultConstitution/swarms/index.js","../defaultConstitution/transactions/index":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/blockchain/defaultConstitution/transactions/index.js","./Blockchain":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/blockchain/pskdb/Blockchain.js","./pskdb":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/blockchain/pskdb/pskdb.js"}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/blockchain/pskdb/pskdb.js":[function(require,module,exports){
let CNST = require("../moduleConstants");
let cutil = require("../OBFT/transactionsUtil");
// let bm = require("../moduleExports");

//var ssutil  = require("pskcrypto");


function KeyValueDBWithVersions(worldStateCache) { //main storage
    let cset = {};  // contains all keys
    let keyVersions = {};  //will store versions
    let self = this;

    this.dump = function () {
        //console.log("Main Storage", {keyVersions,cset})
        worldStateCache.dump();
    };

    this.readKey = function (keyName, mandatoryToExist) {
        if (keyVersions.hasOwnProperty(keyName)) {
            return cset[keyName];
        }
        if (mandatoryToExist) {
            keyVersions[keyName] = 0;
        }
        return undefined;
    };

    this.writeKey = function (keyName, value, newVersion) {

        if (keyVersions.hasOwnProperty(keyName)) {
            if (!newVersion) {
                keyVersions[keyName]++;
            } else {
                keyVersions[keyName] = newVersion;
            }
        } else {
            keyVersions[keyName] = 0;
        }
        cset[keyName] = value;
    };

    this.version = function (keyName) {
        if (keyVersions.hasOwnProperty(keyName)) {
            return keyVersions[keyName];
        }
        return undefined;
    };

    this.getInternalValues = function (currentPulse) {
        return {
            cset,
            versions: keyVersions,
            currentPulse
        }
    }
}

function DBTransactionHandler(parentStorage) {
    let readSetVersions = {}; //version of a key when read first time
    let writeSet = {};  //contains only keys modified in handlers

    this.dump = function () {
        console.log("DBTransactionHandler:", {readSetVersions, writeSet});
        parentStorage.dump();
    };

    this.readKey = function (keyName, mandatoryToExist) {
        function internalReadKey() {
            if (readSetVersions.hasOwnProperty(keyName)) {
                return writeSet[keyName];
            }
            let version = parentStorage.version(keyName);
            if (version != undefined) {
                readSetVersions[keyName] = version;
            }
            return parentStorage.readKey(keyName);
        }

        let result = internalReadKey();
        //writeSet[keyName] = result;

        /*
        if(mandatoryToExist){
            console.debug("Looking for ", keyName, " Version:", parentStorage.version(keyName), "Result:", result);
        }
        if(!result && mandatoryToExist){
            console.error("Found nothing for", keyName, "Key Version:", parentStorage.version(keyName));
            this.dump();
            $$.exception("Mandatory key not found:" + keyName);
        }*/
        return result;
    };

    this.writeKey = function (keyName, value) {
        this.readKey(keyName);         //save read version
        writeSet[keyName] = value;
    };

    this.computeSwarmTransactionDiff = function () {
        return {
            input: readSetVersions,
            output: writeSet
        };
    };
}


function PSKDB(worldStateCache, historyStorage) {
    this.blockchain = undefined;
    let mainStorage = new KeyValueDBWithVersions(worldStateCache);
    let self = this;

    let currentPulse = 0;
    let hashOfLatestCommittedBlock = "Genesis Block";

    this.getHandler = function () { // the single way of working with pskdb
        let tempStorage = new DBTransactionHandler(mainStorage);
        return tempStorage;
    };

    this.getCurrentPulse = function () {
        return currentPulse;
    };

    this.setCurrentPulse = function (cp) {
        currentPulse = cp;
    };

    this.getPreviousHash = function () {
        return hashOfLatestCommittedBlock;
    };

    this.initialise = function (reportResultCallback) {
        let gotLatestBlock_done = false;
        let gotState_done = false;
        let lbn = 0;
        let state = 0;
        let cp = 0;

        function loadNextBlock() {
            if (cp > lbn) {
                if (lbn != 0) {
                    currentPulse = cp;
                }
                reportResultCallback(null, lbn);
            } else {
                historyStorage.loadSpecificBlock(cp, function (err, block) {
                    if (block) {
                        self.commitBlock(block, true, (err) => {
                            if(err) {
                                reportResultCallback(err);
                                return;
                            }
                            cp = block.pulse;

                            cp++;
                            loadNextBlock();
                        });
                    } else {
                        cp++;
                        loadNextBlock();
                    }
                })
            }
        }

        function loadMissingBlocksFromHistory() {
            if (gotState_done && gotLatestBlock_done) {
                if (state && state.pulse) {
                    cp = state.pulse;
                }
                console.log("Reloading from cache at pulse ", cp, "and rebuilding state until pulse", lbn);
                if (state.pulse) {
                    mainStorage.initialiseInternalValue(state);
                }
                loadNextBlock();
            }
        }

        function gotLatestBlock(err, val) {
            gotLatestBlock_done = true;
            if (!err) {
                lbn = val;
            }
            loadMissingBlocksFromHistory();
        }

        function gotState(err, val) {
            gotState_done = true;

            if (!err) {
                state = val;
            }
            if (state.latestBlockHash) {
                hashOfLatestCommittedBlock = state.latestBlockHash;
            }
            loadMissingBlocksFromHistory();
        }

        worldStateCache.getState(gotState);
        historyStorage.getLatestBlockNumber(gotLatestBlock);
    };


    this.commitBlock = function (block, doNotSaveHistory, callback) {
        incrementCommitsNumber();
        let blockSet = block.blockset;
        currentPulse = block.pulse;

        let verificationKeySpace = new VerificationKeySpaceHandler(mainStorage, worldStateCache, this.blockchain);

        verificationKeySpace.commit(blockSet);

        hashOfLatestCommittedBlock = block.hash;
        if (!doNotSaveHistory) {
            historyStorage.appendBlock(block, false, (err) => {
                if (err) {
                    return callback(err);
                }

                __updateState();
            });
        } else {
            __updateState()
        }

        function __updateState() {
            let internalValues = mainStorage.getInternalValues(currentPulse);
            internalValues.latestBlockHash = block.hash;
            worldStateCache.updateState(internalValues, (...args) => {
                callback(...args);
                decrementCommitsNumber();
            });
        }
    };

    this.computePTBlock = function (nextBlockSet) {
        let tempStorage = new VerificationKeySpaceHandler(mainStorage, worldStateCache, this.blockchain);
        return tempStorage.computePTBlock(nextBlockSet);
    };

    const notifyCommittedCallbacks = [];
    let commitsInProgress = 0;
    this.onceAllCommitted = function (callback) {
        notifyCommittedCallbacks.push(callback);
    };

    function incrementCommitsNumber() {
        commitsInProgress += 1;
    }

    function decrementCommitsNumber() {
        commitsInProgress -= 1;

        if(commitsInProgress === 0) {
            notifyCommitted();
        }
    }

    function notifyCommitted() {
        for (const callback of notifyCommittedCallbacks) {
            callback();
        }

        notifyCommittedCallbacks.splice(0, notifyCommittedCallbacks.length);
    }

    /* Verification Space Digest is now the hash of the latest commited block*/
    this.getHashLatestBlock = historyStorage.getHashLatestBlock;
}

let lec = require("./securityParadigms/localExecutionCache");

/* play the role of DBTransactionHandler (readKey, writeKey) while also doing transaction validation*/
function VerificationKeySpaceHandler(parentStorage, worldStateCache, blockchain) {
    let readSetVersions = {}; //version of a key when read first time
    let writeSetVersions = {}; //increment version with each writeKey
    let writeSet = {};  //contains only keys modified in handlers
    let self = this;

    let aliases = {};

    this.dump = function () {
        console.log("VerificationKeySpaceHandler:", {readSetVersions, writeSetVersions, writeSet});
        parentStorage.dump();
    };


    this.readKey = function (keyName) {
        if (writeSetVersions.hasOwnProperty(keyName)) {
            return writeSet[keyName];
        }
        readSetVersions[keyName] = parentStorage.version(keyName);
        return parentStorage.readKey(keyName);
    };

    this.saveAlias = function (assetType, alias, swarmId) {
        aliases[swarmId] = {assetType, alias};
    };

    this.writeKey = function (keyName, value) {
        this.readKey(keyName);         //save read version
        if (!writeSetVersions.hasOwnProperty(keyName)) {
            writeSetVersions[keyName] = readSetVersions[keyName];
        }
        writeSetVersions[keyName]++;
        writeSet[keyName] = value;
    };

    this.version = function (keyName) {
        if (writeSetVersions.hasOwnProperty(keyName)) {
            return writeSetVersions[keyName];
        }
        return parentStorage.version(keyName);
    };

    function applyTransaction(t, willBeCommited) {
        let ret = true;
        lec.ensureEventTransaction(t);
        for (let k in t.input) {
            let transactionVersion = t.input[k];
            if (transactionVersion == undefined) {
                transactionVersion = 0;
            }
            let currentVersion = self.version(k);
            if (currentVersion == undefined || currentVersion == null) {
                currentVersion = 0;
            }
            if (transactionVersion != currentVersion) {
                //console.log(k, transactionVersion , currentVersion);
                //ret = "Failed to apply in transactionVersion != currentVersion (" + transactionVersion + "!="+ currentVersion + ")";
                return false;
            }
        }

        //TODO: potential double spending bug if a transaction was replaced
        if (!lec.verifyTransaction(t, self, willBeCommited, blockchain)) {
            return false;
        }

        for (let k in t.output) {
            self.writeKey(k, t.output[k]);
        }

        /* who has this responsability?
        if(willBeCommited){
            lec.removeFromCacheAtCommit(t);
        }*/
        return ret;
    }

    this.computePTBlock = function (nextBlockSet) {   //make a transactions block from nextBlockSet by removing invalid transactions from the key versions point of view
        let validBlock = [];
        let orderedByTime = cutil.orderCRTransactions(nextBlockSet);
        let i = 0;

        while (i < orderedByTime.length) {
            let t = orderedByTime[i];
            if (applyTransaction(t)) {
                validBlock.push(t.digest);
            }
            i++;
        }


        return validBlock;
    };

    this.commit = function (blockSet, reportDropping) {
        let i = 0;
        let orderedByTime = cutil.orderCRTransactions(blockSet);

        while (i < orderedByTime.length) {
            let t = orderedByTime[i];
            if (applyTransaction(t, true) && reportDropping) {
                $$.log("Dropping transaction", t);
            }

            i++;
        }

        for (let v in writeSetVersions) {
            parentStorage.writeKey(v, writeSet[v], writeSetVersions[v]);
        }

        worldStateCache.updateAliases(aliases);
    }
}


exports.newPSKDB = function (worldStateCache, historyStorage) {
    return new PSKDB(worldStateCache, historyStorage);
};
},{"../OBFT/transactionsUtil":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/blockchain/OBFT/transactionsUtil.js","../moduleConstants":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/blockchain/moduleConstants.js","./securityParadigms/localExecutionCache":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/blockchain/pskdb/securityParadigms/localExecutionCache.js"}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/blockchain/pskdb/securityParadigms/localExecutionCache.js":[function(require,module,exports){
let CNST=require("../../moduleConstants");
let cache = {};

let alreadyVerified = {

};

function sandBoxedExecution(cet){
    let transactionType = cet.swarmType;
    $$.transactions.start("")
}

module.exports = {
    ensureEventTransaction:function(cetransaction){
        return cetransaction;
    },
    verifyTransaction:function(t, handler, forceDeepVerification, blockchain){

        //todo: to be removed later; modification done in the same time with the mod in pskdb
        return true;

        let old_assets = {};
        let new_assets = {};
        let fastCheck = true;

        if(!forceDeepVerification){
            let t = cache[t.digest];
            if(typeof t != undefined) return true;
        }

        for(let k in t.output){
            new_assets[k] = {};
            old_assets[k] = {};

            let  old_value = handler.readKey(k);
            let  new_value = t.output[k];

            let assetValue = JSON.parse(new_value);

            let asset = $$.assets.continue(assetValue);
            asset.__reinit(blockchain);

            new_assets[k][asset.getSwarmId()] = asset;
            handler.saveAlias(asset.getSwarmType(), asset.alias, asset.getSwarmId());

            if(old_value !== undefined){
                /* undefined for new asset (did not exist before current transaction)*/
                let assetValue = JSON.parse(old_value);
                let asset = $$.assets.continue(assetValue);
                asset.__reinit(blockchain);
                if(asset.securityParadigm.mainParadigm == CNST.CONSTITUTIONAL){
                    fastCheck = false;
                }
                old_assets[k][asset.getSwarmId()] = asset;;
            }
            //else ... force constitutional checks?
        }

        return true; //TODO: implement proper checks

        if(fastCheck){
            //check the signatures or other rules specified in security paradigms
        } else {
            //execute transaction again and see if the results are identical
        }
        cache[t.digest] = t;
        return true;
    },
    removeFromCacheAtCommit:function(t){
        delete alreadyVerified[t.digest];
        delete cache[t.digest];
    }
};

},{"../../moduleConstants":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/blockchain/moduleConstants.js"}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/blockchain/pskdb/securityParadigms/securityParadigmRegistry.js":[function(require,module,exports){

var CNST = require("../../moduleConstants");

function ConstitutionalSPFactory(){
     this.constitutional = function(spm, optionalTransactionName){
         spm.mainParadigm = CNST.CONSTITUTIONAL;
         if(optionalTransactionName){
             spm.data[CNST.CONSTITUTIONAL] = optionalTransactionName;
             $$.notImplemented("optionalTransactionName is not properly implemented yet")
         }
         //spm.addSecurityParadigm(CNST.CONSTITUTIONAL ,optionalTransactionName);
     }

    /* we do not instantiate SPs... but anyway it behaves as some sort of factory in an virtual way of instantiation*/
    this.checkInsideTransactionValidation = function(transaction, asset){

    }
}

function PredicativeSPFactory(){
    let predicates = {};
    this.addPredicate = function(spm, predicateName, predicateDefinition){
        predicates[predicateName] = predicateDefinition;
        spm.mainParadigm = CNST.PREDICATIVE;
        spm.data[CNST.PREDICATIVE] = predicateName;
    }
    /* not allowed for now... maybe in future*/
    this.registerPredicate = function(predicateName, predicateFunction){

    }

    /* */
    this.checkInsideTransactionValidation = function(transaction, asset){

    }
}

function RestrictedSPFactory(){
    this.allow = function(spm, agentId){
        spm.mainParadigm = CNST.RESTRICTED;
        if(!spm.data[CNST.RESTRICTED]) {
            spm.data[CNST.RESTRICTED] = [agentId];
        } else {
            spm.data[CNST.RESTRICTED].push(agentId);
        }
    }

    this.checkInsideTransactionValidation = function(transaction, asset){

    }

}


function mkApi(sp, APIName, factory){
    return function(...args){
        return factory[APIName](sp, ...args);
    }
}

function SecurityParadigmMetadata(assetInstance,metaData, apiNames, allFactories){
    if(metaData != undefined){
        for(let v in metaData){
            this[v] =  metaData[v];
        }
    } else {
        this.mainParadigm = CNST.RESTRICTED;
        this.data = {};
    }

    //could be refined to add better restrictions
    for(let v in apiNames){
        this[apiNames[v]] = mkApi(this, apiNames[v], allFactories[v]);
    }
    assetInstance.setMetadata("SecurityParadigm", this);
}


function Registry(blockchain){
    let allFactories = {};
    let apiNames = {};
    let self = this;
    this.register = function (SPName, apiName, factory) {
        allFactories[SPName]         = factory;
        apiNames[SPName]    = apiName;
    }

    this.getSecurityParadigm = function(assetInstance){
        let  metaData = assetInstance.getMetadata(CNST.SECURITY_PARADIGM);
        return new SecurityParadigmMetadata(assetInstance, metaData, apiNames, allFactories);
    }

    self.register(CNST.CONSTITUTIONAL ,"constitutional", new ConstitutionalSPFactory());
    self.register(CNST.RESTRICTED,"allow", new RestrictedSPFactory());
    self.register(CNST.PREDICATIVE ,"addPredicate", new PredicativeSPFactory());

    this.validateTransaction = function(currentLayer, transaction){

    }
}

module.exports = {
    getRegistry: function () {
        /* normally should be called only once, made it more open for tests only...*/
        return new Registry();
    }
}
},{"../../moduleConstants":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/blockchain/moduleConstants.js"}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/blockchain/signsensus/SignSensusImplementation.js":[function(require,module,exports){
let pskcrypto = require("pskcrypto");
let fs = require("fs");

let consUtil = require("../OBFT/transactionsUtil");

let detailedDebug = false;


let pulseSwarm = $$.flow.describe("pulseSwarm", {
    start: function (delegatedAgentName, communicationOutlet, pdsAdapter, pulsePeriodicity, votingBox) {

        this.lset = {}; // digest -> transaction - localy generated set of transactions (`createTransactionFromSwarm` stores each transaction; `beat` resets `lset`)
        this.dset = {}; // digest -> transaction - remotely delivered set of transactions that will be next participate in consensus
        this.pset = {}; // digest -> transaction - consensus pending set

        this.currentPulse = 0;
        this.topPulseConsensus = 0;
        this.lastPulseAchievedConsensus = 0;

        this.pulsesHistory = {};

        this.vsd = pdsAdapter.getHashLatestBlock();


        this.commitCounter = 0;                 // total  number of transactions that got commited

        this.nodeName               = delegatedAgentName;
        this.communicationOutlet    = communicationOutlet;
        this.pdsAdapter             = pdsAdapter;
        this.pulsePeriodicity       = pulsePeriodicity;
        this.votingBox              = votingBox;

        this.beat();
    },

    beat: function () {
        let ptBlock = null;
        let nextConsensusPulse = this.topPulseConsensus + 1;
        let majoritarianVSD = "none";

        while (nextConsensusPulse <= this.currentPulse) {
            ptBlock = consUtil.detectMajoritarianPTBlock(nextConsensusPulse, this.pulsesHistory, this.votingBox);
            majoritarianVSD = consUtil.detectMajoritarianVSD(nextConsensusPulse, this.pulsesHistory, this.votingBox);

            if (ptBlock != "none" && this.vsd == majoritarianVSD) {
                if (!this.hasAllTransactions(ptBlock)) {
                    this.print("Unknown transactions detected...")
                    break;
                }
                //console.log(this.nodeName, ptBlock.length,this.vsd, majoritarianVSD, nextConsensusPulse);
                if (ptBlock.length /*&& this.hasAllTransactions(ptBlock)*/) {
                    this.pset = consUtil.setsConcat(this.pset, this.dset);
                    this.dset = {};
                    let resultSet = consUtil.makeSetFromBlock(this.pset, ptBlock);

                    this.commitCounter += ptBlock.length;
                    //this.print("\t\tBlock [" + this.dumpPtBlock(ptBlock) + "] at pulse " + nextConsensusPulse + " and VSD " +  this.vsd.slice(0,8));

                    this.pdsAdapter.commit(resultSet);
                    let topDigest = ptBlock[ptBlock.length - 1];
                    this.topPulseConsensus = this.pset[topDigest].transactionPulse;
                    consUtil.setsRemovePtBlockAndPastTransactions(this.pset, ptBlock, this.topPulseConsensus); //cleanings
                    let oldVsd = this.vsd;
                    this.vsd = this.pdsAdapter.getVSD();

                    this.lastPulseAchievedConsensus = nextConsensusPulse;   //safer than `this.currentPulse`!?
                    //this.topPulseConsensus = nextConsensusPulse;

                    this.print("\t\t consensus at pulse " + nextConsensusPulse + " and VSD " + oldVsd.slice(0, 8));
                } else {
                    this.pset = consUtil.setsConcat(this.pset, this.dset);
                    this.dset = {};
                    this.lastPulseAchievedConsensus = nextConsensusPulse;   //safer than `this.currentPulse`!?
                    this.topPulseConsensus = nextConsensusPulse;
                    //this.print("\t\tEmpty " + " at: " + nextConsensusPulse );
                    //console.log("\t\tmajoritarian ", majoritarianVSD.slice(0,8) , nextConsensusPulse);
                }
                break; //exit WHILE

            } //end if (ptBlock != "none" && this.vsd == majoritarianVSD)

            nextConsensusPulse++;
        } //end while


        //daca nu a reusit,ar trebui sa vada daca nu exista un alt last majoritar
        ptBlock = this.pdsAdapter.computePTBlock(this.pset);

        let newPulse = consUtil.createPulse(
            this.nodeName,                          //==> Pulse.signer
            this.currentPulse,
            ptBlock,
            this.lset,
            this.vsd,
            this.topPulseConsensus,
            this.lastPulseAchievedConsensus);

        //console.log("\t\tPulse", this.nodeName, this.vsd.slice(0,8) );
        //this.print("Pulse" );
        this.recordPulse(newPulse);

        let self = this;
        self.communicationOutlet.broadcastPulse(newPulse);
        
        this.lset = {};
        this.currentPulse++;

        setTimeout(this.beat, this.pulsePeriodicity);   //self invocation of phase `beat`
    },
    hasAllTransactions: function (ptBlock) {
        for (let i = 0; i < ptBlock.length; i++) {
            let item = ptBlock[i];
            if (!this.pset.hasOwnProperty(item)) {
                //TODO: ask for the missing transaction
                return false;
            }
        }
        return true;
    },
    receiveTransaction: function (t) {
        this.lset[t.digest] = t;
        return t;
    },
    /**
     *
     * @param {Pulse} pulse e.g. new Pulse(this.nodeName, this.currentPulse, ......)
     */
    recordPulse: function (pulse) {
        let from = pulse.signer;

        if (!pulse.ptBlock) {
            pulse.ptBlock = [];
        }
        //pulse.blockDigest = pskcrypto.hashValues(pulse.ptBlock);
        //pulse.blockDigest = pulse.ptBlock.blockDigest;

        if (!this.pulsesHistory[pulse.currentPulse]) {
            this.pulsesHistory[pulse.currentPulse] = {};
        }
        this.pulsesHistory[pulse.currentPulse][from] = pulse;

        if(pulse.currentPulse >= this.topPulseConsensus) {
            if (pulse.currentPulse <= this.lastPulseAchievedConsensus) {
                for (let d in pulse.lset) {
                    this.pset[d] = pulse.lset[d];// could still be important for consensus
                }
            } else {
                for (let d in pulse.lset) {
                    this.dset[d] = pulse.lset[d];
                }
            }
        }
        //TODO: ask for pulses that others received but we failed to receive
    },

    dumpPtBlock: function (ptBlock) {
        return ptBlock.map(function (item) {
            return item.slice(0, 8);
        }).join(" ");
    },
    dump: function () {
        // this.print("Final");
    },
    print: function (str) {
        if (!detailedDebug) {
            if (str === "Pulse") return;
        }

        if (!str) {
            str = "State "
        }

        function countSet(set) {
            let l = 0;
            for (let v in set) l++;
            return l;
        }

        console.log(this.nodeName, " | ", str, " | ",
            "currentPulse:", this.currentPulse, "top:", this.topPulseConsensus, "LPAC:", this.lastPulseAchievedConsensus, "VSD:", this.vsd.slice(0, 8),
            " | ", countSet(this.pset), countSet(this.dset), countSet(this.lset),
            " | ", this.commitCounter / GLOBAL_MAX_TRANSACTION_TIME, " tranzactii pe secunda. Total tranzactii comise:", this.commitCounter);

    },
    printState: function () {
        console.log(this.nodeName, ",", this.currentPulse, ",", this.vsd);
    },
    printPset: function () {
        function sortedDigests(set) {
            let res = [];
            for (let d in set) {
                res.push(d);
            }
            return pskcrypto.hashValues(res.sort());
        }
        function appendToCSV(filename, arr) {
            const reducer = (accumulator, currentValue) => accumulator + " , " + currentValue;
            let str = arr.reduce(reducer, "") + "\n";
            fs.appendFileSync(filename, str);
        }

        let arr = [
            this.nodeName,
            this.currentPulse,
            this.topPulseConsensus,
            this.lastPulseAchievedConsensus,
            sortedDigests(this.pset),
            sortedDigests(this.dset),
            sortedDigests(this.lset),
            this.vsd
        ];
        appendToCSV("data.csv", arr);
        // console.log(this.nodeName,",",this.currentPulse,",",Object.keys(this.pset).length);
    }
});


/**
 * @param {String} delegatedAgentName e.g. 'Node 0', or 'agent_007'
 * @param {Object} communicationOutlet e.g. object to be used in phase `beat` of the returned "pulseSwarm" flow
 *  - it should have a property: `broadcastPulse`: function(from, pulse) {...}
 *      - {String} `from` e.g. `delegatedAgentName`
 *      - {Pulse} `pulse` (see 'transactionsUtil.js')
 * @param {InMemoryPDS} pdsAdapter e.g. require("pskdb/lib/InMemoryPDS").newPDS(null);
 * @param {Number} pulsePeriodicity e.g. 300
 * 
 * @returns {SwarmDescription} A new instance of "pulseSwarm" flow, with phase `start` already running
 */
exports.createConsensusManager = function (delegatedAgentName, communicationOutlet, pdsAdapter, pulsePeriodicity, votingBox) {
    let instance = pulseSwarm();
    instance.start(delegatedAgentName, communicationOutlet, pdsAdapter, pulsePeriodicity, votingBox);
    return instance;
}

},{"../OBFT/transactionsUtil":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/blockchain/OBFT/transactionsUtil.js","fs":false,"pskcrypto":"pskcrypto"}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/blockchain/strategies/consensusAlgortims/consensusAlgoritmsRegistry.js":[function(require,module,exports){
var mod = require("../../moduleExports");

function DirectCommitAlgorithm() {
    let pskdb = null;
    this.setPSKDB = function (_pskdb) {
        pskdb = _pskdb;
    };
    this.commit = function (transaction, callback) {
        const set = {};
        let cp = this.pskdb.getCurrentPulse();
        set[transaction.digest] = transaction;
        this.pskdb.commitBlock(mod.createBlock(set, cp, this.pskdb.getPreviousHash()), false, callback);

        cp++;
        this.pskdb.setCurrentPulse(cp);
    };

    this.getCurrentPulse = function () {
        return this.pskdb.getCurrentPulse();
    }
}


function SignSensusAlgoritm(nodeName, networkImplementation, pulsePeriodicity, votingBox) {
    let pskdb = null;
    let algorithm = null;
    this.setPSKDB = function (_pskdb) {
        pskdb = _pskdb;
        algorithm = require("../../signsensus/SignSensusImplementation").createConsensusManager(nodeName, networkImplementation, pskdb, pulsePeriodicity, votingBox);
        this.recordPulse = algorithm.recordPulse;
        console.log("Setting pskdb for algorithm")
    };

    this.commit = function (transaction) {
        algorithm.sendLocalTransactionToConsensus(transaction);
    };

    this.getCurrentPulse = function () {
        return algorithm.currentPulse;
    }
}


function OBFTAlgoritm(nodeName, networkImplementation, pulsePeriodicity, latency, votingBox) {
    let pskdb = null;
    let algorithm = null;
    this.setPSKDB = function (_pskdb) {
        pskdb = _pskdb;
        algorithm = require("../../OBFT/OBFTImplementation").createConsensusManager(nodeName, networkImplementation, pskdb, pulsePeriodicity, latency, votingBox);
        this.recordPulse = algorithm.recordPulse;
        console.log("Setting pskdb for algorithm")
    };

    this.commit = function (transaction) {
        algorithm.sendLocalTransactionToConsensus(transaction);
    };

    this.getCurrentPulse = function () {
        return algorithm.currentPulse;
    }
}

module.exports = {
    createAlgorithm: function (name, ...args) {
        switch (name) {
            case "direct":
                return new DirectCommitAlgorithm(...args);
            case "SignSensus":
                return new SignSensusAlgoritm(...args);
            case "OBFT":
                return new OBFTAlgoritm(...args);
            default:
                $$.exception("Unknown consensus algortihm  " + name);
        }
    }
};
},{"../../OBFT/OBFTImplementation":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/blockchain/OBFT/OBFTImplementation.js","../../moduleExports":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/blockchain/moduleExports.js","../../signsensus/SignSensusImplementation":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/blockchain/signsensus/SignSensusImplementation.js"}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/blockchain/strategies/historyStorages/BarHistoryStorage.js":[function(require,module,exports){
const LatestHashTracker = require("./LatestHashTracker");

function BarHistoryStorage(archive) {
    const blocksPath = "blocks";
    let lht = new LatestHashTracker();

    this.getHashLatestBlock = lht.getHashLatestBlock;
    let latestPulse = -1;

    this.appendBlock = function (block, announceFlag, callback) {
        archive.writeFile(blocksPath + "/" + block.pulse, JSON.stringify(block, null, 1), (err) => {
            if (err) {
                return callback(err);
            }

            if (block.pulse > latestPulse) {
                latestPulse = block.pulse;

                archive.writeFile(blocksPath + "/index", latestPulse.toString(), (err) => {
                    if (err) {
                        return callback(err);
                    }

                    lht.update(block.pulse, block);
                    callback();
                });
            } else {
                callback();
            }
        });
    };

    this.getLatestBlockNumber = function (callback) {
        let maxBlockNumber = 0;
        archive.readFile(blocksPath + "/index", (err, res) => {
            if (err) {
                return callback(err);
            }

            maxBlockNumber = parseInt(res.toString());

            callback(undefined, maxBlockNumber);
        });
    };

    this.loadSpecificBlock = function (blockNumber, callback) {
        archive.readFile(blocksPath + "/" + blockNumber.toString(), (err, res) => {
            if (err) {
                return callback(err);
            }

            try {
                res = JSON.parse(res.toString());
                lht.update(res.pulse, res);
            } catch (e) {
                callback(e);
                return;
            }

            callback(null, res);
        });
    };

    ////////////////////////
    let observer;
    //send to callback all blocks newer then fromVSD
    this.observeNewBlocks = function (fromVSD, callback) {
        observer = callback;
    }
}

module.exports = BarHistoryStorage;
},{"./LatestHashTracker":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/blockchain/strategies/historyStorages/LatestHashTracker.js"}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/blockchain/strategies/historyStorages/FsHistoryStorage.js":[function(require,module,exports){
const LatestHashTracker = require("./LatestHashTracker");

function FsHistoryStorage(folder) {
    const blocksPath = folder + "/blocks";
    let lht = new LatestHashTracker();
    this.getHashLatestBlock = lht.getHashLatestBlock;

    let fs = require("fs");
    let latestPulse = -1;

    this.appendBlock = function (block, announceFlag, callback) {
        ensureBlocksPathExist((err) => {
            if (err) {
                return callback(err);
            }

            fs.writeFile(blocksPath + "/" + block.pulse, JSON.stringify(block, null, 1), (err) => {
                if (err) {
                    return callback(err);
                }

                if(block.pulse > latestPulse) {
                    latestPulse = block.pulse;

                    fs.writeFile(blocksPath + "/index", latestPulse.toString(), (err) => {
                        if (err) {
                            return callback(err);
                        }

                        lht.update(block.pulse, block);
                        callback();

                    });
                } else {
                    callback();
                }
            });
        });
    };

    this.getLatestBlockNumber = function (callback) {
        ensureBlocksPathExist((err) => {
            if (err) {
                return callback(err);
            }

            fs.readFile(blocksPath + "/index", function (err, res) {
                let maxBlockNumber = 0;
                if (err) {
                    callback(err);
                } else {
                    maxBlockNumber = parseInt(res);
                    callback(null, maxBlockNumber);
                }
            });
        });
    };

    this.loadSpecificBlock = function (blockNumber, callback) {
        ensureBlocksPathExist((err) => {
            if (err) {
                return callback(err);
            }

            fs.readFile(blocksPath + "/" + blockNumber, 'utf8', function (err, res) {
                if (err) {
                    callback(err, null);
                } else {
                    try {
                        res = JSON.parse(res);
                        lht.update(res.pulse, res);
                    } catch (e) {
                        console.log('could not parse', e, res);
                        callback(e);
                        return;
                    }

                    callback(null, res);
                }
            });
        });
    };

    ////////////////////////
    let observer;
    //send to callback all blocks newer then fromVSD
    this.observeNewBlocks = function (fromVSD, callback) {
        observer = callback;
    };

    //------------------------------------------- internal methods ----------------------------------------------------
    function ensureBlocksPathExist(callback) {
        fs.access(blocksPath, (err) => {
            if (err) {
                fs.mkdir(blocksPath, {recursive: true}, callback);
            }else{
                callback();
            }
        });
    }
}

module.exports = FsHistoryStorage;

},{"./LatestHashTracker":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/blockchain/strategies/historyStorages/LatestHashTracker.js","fs":false}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/blockchain/strategies/historyStorages/LatestHashTracker.js":[function(require,module,exports){
function LatestHashTracker() {
    let hlb = "none";
    let maxBlockNumber = 0;

    this.update = function (blockNumber, block) {
        if (blockNumber > maxBlockNumber) {
            hlb = block.blockDigest;
        }
    };

    this.getHashLatestBlock = function () {
        return hlb;
    }
}

module.exports = LatestHashTracker;
},{}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/blockchain/strategies/historyStorages/MemoryHistoryStorage.js":[function(require,module,exports){
const LatestHashTracker = require("./LatestHashTracker");

function MemoryHistoryStorage() {
    let blocks = [];
    let lht = new LatestHashTracker();
    this.getHashLatestBlock = lht.getHashLatestBlock;

    this.appendBlock = function (block, announceFlag, callback) {
        blocks.push(block);
        lht.update(blocks.length, block);
        callback(null, block);

    };

    this.getLatestBlockNumber = function (callback) {
        callback(null, blocks.length);
    };

    this.loadSpecificBlock = function (blockNumber, callback) {
        let block = blocks[blockNumber];
        lht.update(blockNumber, block);
        callback(null, blocks[blockNumber]);
    }
}

module.exports = MemoryHistoryStorage;
},{"./LatestHashTracker":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/blockchain/strategies/historyStorages/LatestHashTracker.js"}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/blockchain/strategies/historyStorages/historyStoragesRegistry.js":[function(require,module,exports){
const FsHistoryStorage = require("./FsHistoryStorage");
const MemoryHistoryStorage = require("./MemoryHistoryStorage");
const BarHistoryStorage = require("./BarHistoryStorage");

module.exports = {
    createStorage: function (storageType, ...args) {
        switch (storageType) {
            case "fs":
                return new FsHistoryStorage(...args);
            case "bar":
                return new BarHistoryStorage(...args);
            case "memory":
                return new MemoryHistoryStorage(...args);
            default:
                $$.exception("Unknown blockchain storage " + storageType);
        }
    }
};
},{"./BarHistoryStorage":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/blockchain/strategies/historyStorages/BarHistoryStorage.js","./FsHistoryStorage":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/blockchain/strategies/historyStorages/FsHistoryStorage.js","./MemoryHistoryStorage":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/blockchain/strategies/historyStorages/MemoryHistoryStorage.js"}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/blockchain/strategies/networkCommunication/networkCommunicationStrategiesRegistry.js":[function(require,module,exports){
const mc = require("../../moduleConstants");
let pulseUtil = require("../../OBFT/PulseUtil");


function IPCNetworkSimulator(){
    this.broadcastPulse = function(pulse){
        process.send(pulse);
    }

    this.newPulse = function(){
        let p = pulseUtil.createPulse()
        process.send(pulse);
    }

    this.listen = function(callback){
        process.on('message', function(msg){
            callback(null, msg);
        })
    }
}

/*
var com = {
    broadcastPulse: function(from, pulse){
        nodes.forEach( function(n){
            if(n.nodeName != from) {
                setTimeout(function(){
                    n.recordPulse(from, pulse);
                }, cutil.getRandomInt(cfg.NETWORK_DELAY));
            } else {
                if(pulse.currentPulse > 2 * maxPulse){
                    afterFinish[from] = true;
                }
            }
        });


        if(Object.keys(afterFinish).length >= cfg.MAX_NODES){
            console.log(Object.keys(afterFinish).length , cfg.MAX_NODES);
            setTimeout(terminate, 1);
        }
    }
} */



function VirtualMQAdapter(){

}

module.exports = {
    createNetworkAdapter: function (strategyType, ...args) {
        switch (strategyType) {
            case "ipc":
                return new IPCNetworkSimulator(...args);
            case "virtualmq":
                return new VirtualMQAdapter(...args);
            default:
                $$.error("Unknown communication strategy  " + strategyType);
        }
    }
}
},{"../../OBFT/PulseUtil":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/blockchain/OBFT/PulseUtil.js","../../moduleConstants":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/blockchain/moduleConstants.js"}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/blockchain/strategies/signatureProvidersRegistry/signatureProvidersRegistry.js":[function(require,module,exports){
function PermissiveSignatureProvider(){
    /*
    return a signature of message ms for agent agentId
     */
    this.signAs = function(agentId, msg){
        return "Signature from agent "+agentId + " should be here!";
    }

    this.verify = function(msg, signatures){
        return true;
    };
}


module.exports = {
    createSignatureProvider: function (signProvType,...args) {
        switch (signProvType) {
            case "permissive":
                return new PermissiveSignatureProvider(...args);
            case "blockchain":
            default:
                $$.exception("Signature Provider" + signProvType + " not implemented");
        }
    }
}

},{}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/blockchain/strategies/votingStrategies/votingStrategiesRegistry.js":[function(require,module,exports){

function SimpleMajoritarianStrategy(shareHoldersCounter){
    this.refreshShares = function(){

    }
    this.vote = function (previousValue, agent) {
        if (!previousValue) {
            previousValue = 0;
        }
        return previousValue + 1;
    }

    this.isMajoritarian = function (value) {
        //console.log(value , Math.floor(shareHoldersCounter/2) + 1);
        return value >= Math.floor(shareHoldersCounter / 2) + 1;
    }
}


function BlockchainShareHoldersMajority(){
    let shares = {}
    this.refreshShares = function(){

    }

    this.vote = function (previousValue, agent) {
        if (!previousValue) {
            previousValue = 0;
        }
        return previousValue + shares[agent];
    }

    this.isMajoritarian = function (value) {
        return value > 0.50;
    }
}

module.exports = {
    createVotingStrategy: function (strategyType, ...args) {
        switch (strategyType) {
            case "democratic":
                return new SimpleMajoritarianStrategy(...args);
            case "shareholders":
                return new BlockchainShareHoldersMajority(...args);
            default:
                $$.error("Unknown voting strategy  " + strategyType);
        }
    }
}
},{}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/blockchain/strategies/worldStateCaches/worldStateCacheRegistry.js":[function(require,module,exports){
(function (setImmediate){(function (){
const mc = require("../../moduleConstants");

function StorageContainer(){
    this.pskdb = {};
    this.keys = {};
    this.pulse = 0;
    let self = this;
    let latestState = {

    };

    this.readKey = function(key){
        return self.keys[key];
    };

    this.writeKey = function(key, value){
        self.keys[key] = value;
    };

    function updateAlias(assetType, alias,swarmId){
        let keyName = assetType + mc.ALIASES;
        let value = self.readKey(keyName);
        if(value === undefined){
            value = {};
            value[alias] = swarmId;
        } else {
            value = JSON.parse(value);
            value[alias] = swarmId;
        }
        self.writeKey(keyName,JSON.stringify(value));
    }

    this.updateAliases = function(aliases){
        for(let swarmId in aliases){
            updateAlias(aliases[swarmId].assetType, aliases[swarmId].alias, swarmId);
        }
    }
}

function BarCache(archive) {
    let storage = new StorageContainer();
    this.readKey = storage.readKey;
    this.writeKey = storage.writeKey;
    this.updateAliases = storage.updateAliases;

    //just in case the folder got to use as storage does not exist

    const worldStateCachePath = "/worldStateCache";

    this.getState = function (callback) {
        archive.readFile(worldStateCachePath,  function (err, res) {
            let objRes = {};
            if (err) {
                callback(err, objRes);
                console.log("Initialisating empty blockchain state");
            } else {
                objRes = JSON.parse(res);
                storage.pskdb = objRes.pskdb;
                storage.keys  = objRes.keys;
                storage.pulse  = objRes.pulse;
                callback(null, storage.pskdb);
            }
        });
    };

    this.updateState = function (internalValues, callback) {
        storage.pskdb = internalValues;
        archive.writeFile(worldStateCachePath, JSON.stringify(storage, null, 1), callback);
    };

    this.dump = function(){
        console.log("EDFSCache:", storage);
    }

}

function MemoryCache() {
    let storage = new StorageContainer();
    this.readKey = storage.readKey;
    this.writeKey = storage.writeKey;
    this.updateAliases = storage.updateAliases;

    this.getState = function (callback) { //err, valuesFromCache
        callback(null, storage.pskdb);
    };

    this.updateState = function (internalValues, callback) {
        //console.info("Commiting state in memory cache "/*, internalValues*/)
        storage.pskdb = internalValues;
        storage.pulse = internalValues.pulse;
        setImmediate(() => {
            callback(null, storage.pskdb);
        });
    };

    this.dump = function(){
        console.log("MemoryCache:", storage);
    }
}

function LocalWSCache(folder) {
    let storage = new StorageContainer();
    this.readKey = storage.readKey;
    this.writeKey = storage.writeKey;
    this.updateAliases = storage.updateAliases;

    //just in case the folder got to use as storage does not exist
    require("fs").mkdirSync(folder, {recursive: true});

    const worldStateCachePath = folder + "/worldStateCache";
    let fs = require("fs");

    this.getState = function (callback) {
        fs.readFile(worldStateCachePath, 'utf8', function (err, res) {
            let objRes = {};
            if (err) {
                callback(err, objRes);
                console.log("Initialisating empty blockchain state");
            } else {
                objRes = JSON.parse(res);
                storage.pskdb = objRes.pskdb;
                storage.keys  = objRes.keys;
                storage.pulse  = objRes.pulse;
                callback(null, storage.pskdb);
            }
        });
    };

    this.updateState = function (internalValues, callback) {
        storage.pskdb = internalValues;
        fs.writeFile(worldStateCachePath, JSON.stringify(storage, null, 1), callback);
    };

    this.dump = function(){
        console.log("LocalWSCache:", storage);
    }

}


module.exports = {
    createCache: function (cacheType, ...args) {
        switch (cacheType) {
            case "fs":
                return new LocalWSCache(...args);
            case "bar":
                return new BarCache(...args);
            case "memory":
                return new MemoryCache(...args);
            default:
                $$.exception("Unknown blockchain cache " + cacheType);
        }
    }
};
}).call(this)}).call(this,require("timers").setImmediate)

},{"../../moduleConstants":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/blockchain/moduleConstants.js","fs":false,"timers":false}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/bricksledger/src/Block.js":[function(require,module,exports){
class Block {
    constructor(block) {
        if (!block) {
            throw "Block must be specified";
        }

        const { pbs, blockNumber, previousBlock } = block;
        this.pbs = pbs;
        this.blockNumber = blockNumber;
        this.previousBlock = previousBlock;
    }

    getSerialisation() {
        const { pbs, blockNumber, previousBlock } = this;
        const block = { pbs, blockNumber, previousBlock };
        return JSON.stringify(block);
    }
}

module.exports = Block;

},{}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/bricksledger/src/Broadcaster/PBlockAddedMessage.js":[function(require,module,exports){
(function (Buffer){(function (){
class PBlockAddedMessage {
    constructor(body) {
        if (!body) {
            throw new Error("body must be specified");
        }

        const { validatorDID, validatorURL, blockNumber, pBlockHashLinkSSI, validatorSignature } = body;

        this.validatorDID = validatorDID;
        this.validatorURL = validatorURL;
        this.blockNumber = blockNumber;
        this.pBlockHashLinkSSI = pBlockHashLinkSSI;
        
        if (validatorSignature && !Buffer.isBuffer(validatorSignature)) {
            this.validatorSignature = Buffer.from(validatorSignature, 'hex');
        } else {
            this.validatorSignature = validatorSignature;
        }
    }

    computeHash() {
        const { validatorDID, validatorURL, blockNumber, pBlockHashLinkSSI } = this;

        const objectToHash = {
            validatorDID,
            validatorURL,
            blockNumber,
            pBlockHashLinkSSI,
        };

        const crypto = require("opendsu").loadApi("crypto");
        const hash = crypto.sha256(objectToHash);

        return hash;
    }

    async sign(validatorDID) {
        const hash = this.computeHash();
        this.validatorSignature = await $$.promisify(validatorDID.sign)(hash);
    }

    async validateSignature() {
        const { validatorDID: validatorDIDIdentifier, validatorSignature } = this;

        const hash = this.computeHash();

        const w3cDID = require("opendsu").loadApi("w3cdid");
        const validatorDID = await $$.promisify(w3cDID.resolveDID)(validatorDIDIdentifier);
        const isValidSignature = await $$.promisify(validatorDID.verify)(hash, validatorSignature);

        if (!isValidSignature) {
            throw new Error("Invalid signature specified for PBlockAddedMessage");
        }
    }

    getContent() {
        const { validatorDID, validatorURL, blockNumber, pBlockHashLinkSSI, validatorSignature } = this;

        const content = {
            validatorDID,
            validatorURL,
            blockNumber,
            pBlockHashLinkSSI,
            validatorSignature: (validatorSignature) ? validatorSignature.toString('hex') : validatorSignature,
            hash: this.computeHash(),
        };
        return content;
    }
}

module.exports = PBlockAddedMessage;

}).call(this)}).call(this,require("buffer").Buffer)

},{"buffer":false,"opendsu":"opendsu"}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/bricksledger/src/Broadcaster/ValidatorNonInclusionMessage.js":[function(require,module,exports){
class ValidatorNonInclusionMessage {
    constructor(body) {
        if (!body) {
            throw new Error("body must be specified");
        }

        const { validatorDID, validatorURL, blockNumber, unreachableValidators } = body;

        this.validatorDID = validatorDID;
        this.validatorURL = validatorURL;
        this.blockNumber = blockNumber;
        this.unreachableValidators = unreachableValidators;
    }

    computeHash() {
        const { validatorDID, validatorURL, blockNumber, unreachableValidators } = this;

        const objectToHash = {
            validatorDID,
            validatorURL,
            blockNumber,
            unreachableValidators,
        };

        const crypto = require("opendsu").loadApi("crypto");
        const hash = crypto.sha256(objectToHash);

        return hash;
    }

    async sign(validatorDID) {
        const hash = this.computeHash();
        this.validatorSignature = await $$.promisify(validatorDID.sign)(hash);
    }

    async validateSignature() {
        const { validatorDID: validatorDIDIdentifier, validatorSignature } = this;

        const hash = this.computeHash();

        const w3cDID = require("opendsu").loadApi("w3cdid");
        const validatorDID = await $$.promisify(w3cDID.resolveDID)(validatorDIDIdentifier);
        const isValidSignature = await $$.promisify(validatorDID.verify)(hash, validatorSignature);

        if (!isValidSignature) {
            throw new Error("Invalid signature specified for ValidatorNonInclusionMessage");
        }
    }

    getContent() {
        const { validatorDID, validatorURL, blockNumber, unreachableValidators, validatorSignature } = this;

        const content = {
            validatorDID,
            validatorURL,
            blockNumber,
            unreachableValidators,
            validatorSignature: (validatorSignature) ? validatorSignature.toString('hex') : validatorSignature,
        };
        return content;
    }
}

module.exports = ValidatorNonInclusionMessage;

},{"opendsu":"opendsu"}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/bricksledger/src/Broadcaster/index.js":[function(require,module,exports){
const Logger = require("../Logger");
const PBlockAddedMessage = require("./PBlockAddedMessage");
const ValidatorNonInclusionMessage = require("./ValidatorNonInclusionMessage");
const { getValidatorsForCurrentDomain } = require("../utils/bdns-utils");

class Broadcaster {
    constructor(domain, validatorDID, validatorURL, executionEngine) {
        this.domain = domain;
        this.validatorDID = validatorDID;
        this.validatorURL = validatorURL;
        this.executionEngine = executionEngine;

        this._logger = new Logger(`[Bricksledger][${this.domain}][${this.validatorDID.getIdentifier()}][Broadcaster]`);
        this._logger.info("Create finished");
    }

    async broadcastPBlockAdded(pBlock) {
        const { validatorDID, validatorURL } = this;
        const { blockNumber, hashLinkSSI } = pBlock;
        const message = new PBlockAddedMessage({
            validatorDID: validatorDID.getIdentifier(),
            validatorURL,
            blockNumber,
            pBlockHashLinkSSI: hashLinkSSI,
        });
        await message.sign(validatorDID);
        this._broadcastMessageToAllValidatorsExceptSelf("pblock-added", message.getContent());
    }
    
    async broadcastValidatorNonInclusion(blockNumber, unreachableValidators) {
        const { validatorDID, validatorURL } = this;
        const message = new ValidatorNonInclusionMessage({
            validatorDID: validatorDID.getIdentifier(),
            validatorURL,
            blockNumber,
            unreachableValidators,
        });
        await message.sign(validatorDID);
        this._broadcastMessageToAllValidatorsExceptSelf("validator-non-inclusion", message.getContent());
    }

    async _broadcastMessageToAllValidatorsExceptSelf(endpointSuffix, message) {
        const validators = await getValidatorsForCurrentDomain(this.executionEngine);
        if (!validators || !validators.length) {
            this._logger.info("[Broadcaster] No validators found for current domain");
            return;
        }

        const validatorDID = this.validatorDID.getIdentifier();
        const validatorsToBroadcastTo = validators.filter((validator) => validator.DID !== validatorDID);
        this._logger.info(
            `Broadcasting message '${JSON.stringify(message)}' to ${validatorsToBroadcastTo.length} validator(s)...`
        );

        validatorsToBroadcastTo.forEach((validator) => this._broadcastMessageToValidator(validator, endpointSuffix, message));
    }

    async _broadcastMessageToValidator(validator, endpointSuffix, message) {
        const { doPost } = require("opendsu").loadApi("http");
        const { DID, URL } = validator;

        const broadcastUrl = `${URL}/contracts/${this.domain}/${endpointSuffix}`;
        try {
            this._logger.debug(`Broadcasting to /${endpointSuffix} to validator ${DID} at ${broadcastUrl}....`);
            const response = await $$.promisify(doPost)(broadcastUrl, message);
            this._logger.debug(`Broadcasted to /${endpointSuffix} to validator ${DID} at ${broadcastUrl}`, response);
        } catch (error) {
            this._logger.debug(`Failed to broadcast to ${endpointSuffix} to validator ${DID} at ${broadcastUrl}`, error);
        }
    }
}

function create(...params) {
    return new Broadcaster(...params);
}

module.exports = {
    create,
};

},{"../Logger":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/bricksledger/src/Logger.js","../utils/bdns-utils":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/bricksledger/src/utils/bdns-utils.js","./PBlockAddedMessage":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/bricksledger/src/Broadcaster/PBlockAddedMessage.js","./ValidatorNonInclusionMessage":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/bricksledger/src/Broadcaster/ValidatorNonInclusionMessage.js","opendsu":"opendsu"}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/bricksledger/src/Command.js":[function(require,module,exports){
(function (Buffer){(function (){
class Command {
    constructor(command) {
        if (!command) {
            throw "command must be specified";
        }

        const { domain, contractName, methodName, params, type, blockNumber, timestamp, requesterSignature, signerDID } = command;

        this.domain = domain;
        this.contractName = contractName;
        this.methodName = methodName;
        this.params = params;
        this.type = type;
        this.blockNumber = blockNumber;
        this.timestamp = timestamp;
        this.requesterSignature = requesterSignature;
        this.signerDID = signerDID;
    }

    getHash() {
        const { domain, contractName, methodName, params, type, blockNumber, timestamp } = this;

        const objectToHash = {
            domain,
            contractName,
            methodName,
            params,
        };

        if (type === "nonced") {
            objectToHash.blockNumber = blockNumber;
            objectToHash.timestamp = timestamp;
        }

        const crypto = require("opendsu").loadApi("crypto");
        const hash = crypto.sha256(objectToHash);

        return hash;
    }

    async validateSignature() {
        const { signerDID: signerDIDIdentifier, requesterSignature } = this;

        const hash = this.getHash();

        const w3cDID = require("opendsu").loadApi("w3cdid");
        const signerDID = await $$.promisify(w3cDID.resolveDID)(signerDIDIdentifier);
        const isValidSignature = await $$.promisify(signerDID.verify)(hash, Buffer.from(requesterSignature, 'hex'));

        if (!isValidSignature) {
            throw "Invalid signature specified for Command";
        }
    }

    getForSerialisation() {
        const { domain, contractName, methodName, params, type } = this;
        return {
            domain,
            contractName,
            methodName,
            params,
            type,
        };
    }
}

module.exports = Command;

}).call(this)}).call(this,require("buffer").Buffer)

},{"buffer":false,"opendsu":"opendsu"}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/bricksledger/src/CommandHistoryStorage.js":[function(require,module,exports){
const { ensurePathExists } = require("./utils/fs-utils");

class CommandHistoryStorage {
    constructor(domain, storageFolder) {
        this.domain = domain;
        this.storageFolder = storageFolder;
    }

    async init() {
        const path = require("path");
        const basePath = path.join(this.storageFolder, "domains", this.domain, "command-storage");
        await ensurePathExists(basePath);

        this.optimisticFilePath = path.join(basePath, "optimistic");
        this.validatedFilePath = path.join(basePath, "validated");

        // this.optimisticStreamWriter = fs.createWriteStream(this.optimisticFilePath, { flags: "a" });
        // this.validatedStreamWriter = fs.createWriteStream(this.validatedFilePath, { flags: "a" });
    }

    async addOptimisticComand(command) {
        const fs = require("fs");
        const os = require("os");
        const line = `${os.EOL}${command.getHash()}`;
        const optimisticStreamWriter = fs.createWriteStream(this.optimisticFilePath, { flags: "a" });
        await $$.promisify(optimisticStreamWriter.write.bind(optimisticStreamWriter))(line);
        optimisticStreamWriter.close();
    }

    async addValidatedComand(command) {
        const fs = require("fs");
        const os = require("os");
        const line = `${os.EOL}${command.getHash()}`;
        const validatedStreamWriter = fs.createWriteStream(this.validatedFilePath, { flags: "a" });
        await $$.promisify(validatedStreamWriter.write.bind(validatedStreamWriter))(line);
        validatedStreamWriter.close();
    }

    async isOptimisticCommandHashRegistered(commandHash) {
        return await this._isCommandHashRegistered(this.optimisticFilePath, commandHash);
    }

    async isValidatedCommandHashRegistered(commandHash) {
        return await this._isCommandHashRegistered(this.validatedFilePath, commandHash);
    }

    async _isCommandHashRegistered(commandFilePath, commandHash) {
        const os = require("os");
        return new Promise((resolve, reject) => {
            let isCommandRegistered = false;
            const fs = require("fs");
            const readStream = fs.createReadStream(commandFilePath);
            readStream
                .on("data", function (chunk) {
                    const hashes = chunk.toString().split(os.EOL);
                    const isHashPresent = hashes.some((hash) => hash && hash.trim() === commandHash);

                    if (isHashPresent) {
                        isCommandRegistered = true;
                        resolve(true);
                        readStream.destroy();
                    }
                })
                .on("close", function (error) {
                    if (error) {
                        return reject(error);
                    }
                    if (!isCommandRegistered) {
                        resolve(false);
                    }
                })
                .on("error", function (error) {
                    if (error.code === "ENOENT") {
                        // the file doesn't exist to the command isn't registered
                        return resolve(false);
                    }

                    // we receive an error different than 'no such file'
                    reject(error);
                });
        });
    }
}

function create(domain, storageFolder) {
    return new CommandHistoryStorage(domain, storageFolder);
}

module.exports = {
    create,
};

},{"./utils/fs-utils":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/bricksledger/src/utils/fs-utils.js","fs":false,"os":false,"path":false}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/bricksledger/src/ConsensusCore/PendingBlock.js":[function(require,module,exports){
const { CONSENSUS_PHASES, areNonInclusionListsEqual } = require("./utils");
const Logger = require("../Logger");
const Block = require("../Block");

function sortPBlocks(pBlocks) {
    const sortHashes = (a, b) => {
        if (typeof a === "string" && typeof b === "string") {
            return a.localeCompare(b);
        }

        const aHash = typeof a.hashLinkSSI === "string" ? a.hashLinkSSI : a.hashLinkSSI.getIdentifier();
        const bHash = typeof b.hashLinkSSI === "string" ? b.hashLinkSSI : b.hashLinkSSI.getIdentifier();
        return aHash.localeCompare(bHash);
    };

    pBlocks.sort(sortHashes);
}

class PendingBlock {
    constructor(domain, validatorDID, blockNumber) {
        this._logger = new Logger(
            `[Bricksledger][${domain}][${validatorDID.getIdentifier()}][Consensus][PendingBlock][${blockNumber}]`
        );

        this.blockNumber = blockNumber;

        this.startTime = Date.now();
        this.pBlocks = [];
        this.phase = CONSENSUS_PHASES.PENDING_BLOCKS;
    }

    setValidators(validators) {
        this.validators = validators;
    }

    addPBlock(pBlock) {
        this.pBlocks.push(pBlock);
    }

    clearPendingBlockTimeout() {
        if (this.pendingBlocksTimeout) {
            clearTimeout(this.pendingBlocksTimeout);
            this.pendingBlocksTimeout = null;
        }
    }

    clearNonInclusionCheckTimeout() {
        if (this.nonInclusionCheckTimeout) {
            clearTimeout(this.nonInclusionCheckTimeout);
            this.nonInclusionCheckTimeout = null;
        }
    }

    validateCanReceivePBlock(pBlock) {
        const { phase, blockNumber } = this;
        if (phase !== CONSENSUS_PHASES.PENDING_BLOCKS) {
            const errorMessage = `Pending block number ${blockNumber} is not still at the phase of receiving pBlocks, but at ${phase}`;
            this._logger.error(errorMessage, "pBlock refused for consensus", pBlock);
            throw new Error(errorMessage);
        }
    }

    validatePBlockValidator(pBlock) {
        const { validatorDID } = pBlock;
        this._logger.info(`Checking if pBlock's validator '${validatorDID}' is recognized...`);
        const isValidatorRecognized = this.validators.some((validator) => validator.DID === validatorDID);
        if (!isValidatorRecognized) {
            const errorMessage = `Pblock '${pBlock.hashLinkSSI}' has a nonrecognized validator '${validatorDID}'`;
            this._logger.error(errorMessage);
            throw new Error(errorMessage);
        }
    }

    validateNoPBlockFromValidator(validatorDID) {
        const { blockNumber, pBlocks } = this;
        const isPBlockFromValidatorAlreadyAdded = pBlocks.some((pBlock) => pBlock.validatorDID === validatorDID);
        if (isPBlockFromValidatorAlreadyAdded) {
            const errorMessage = `Validator '${validatorDID}' already had a pBlock for blockNumber ${blockNumber}`;
            this._logger.error(errorMessage);
            throw new Error(errorMessage);
        }
    }

    startPendingBlocksPhase({ timeoutMs, onFinalizeConsensusAsync, onStartNonInclusionPhase }) {
        this.clearPendingBlockTimeout();

        const pendingBlocksTimeout = setTimeout(async () => {
            const { phase } = this; // phase can be changed until timeout is run

            this._logger.debug(`pendingBlocksTimeout triggered...`);

            await this.waitForSafeProcessing();

            this._logger.debug(`pendingBlocksTimeout started...`);

            try {
                // the timeout has occured after the consensus finalization phase started, so we ignore the timeout
                if (phase === CONSENSUS_PHASES.FINALIZING) {
                    this._logger.debug(`pendingBlocksTimeout found the phase to be ${phase}, so canceling timeout...`);
                    return;
                }

                if (this.canFinalizeConsensus()) {
                    await onFinalizeConsensusAsync();
                    return;
                }

                const { pBlocks } = this;
                const validators = this.getValidValidators();
                const canProceedToNonInclusionPhase = pBlocks.length >= Math.floor(validators.length / 2) + 1;
                if (!canProceedToNonInclusionPhase) {
                    this._logger.info(
                        `Consensus for pBlock has received only ${pBlocks.length} pBlock(s) from a total of ${validators.length} validators`,
                        `so it cannot proceed to non inclusion phase yet. Waiting another pendingBlocksTimeout`
                    );

                    this.clearPendingBlockTimeout();
                    this.startPendingBlocksPhase({ timeoutMs, onFinalizeConsensusAsync, onStartNonInclusionPhase });
                    return;
                }

                onStartNonInclusionPhase();
            } catch (error) {
                this._logger.error(`An error has occurred while running pendingBlocksTimeout`, error);

                // an error has occured to start another pending blocks phase check
                this.startPendingBlocksPhase({ timeoutMs, onFinalizeConsensusAsync, onStartNonInclusionPhase });
            }
        }, timeoutMs);

        this.pendingBlocksTimeout = pendingBlocksTimeout;
    }

    isConsensusRunning() {
        return this.phase !== CONSENSUS_PHASES.FINALIZED;
    }

    canFinalizeConsensus() {
        const { pBlocks, phase } = this;
        this._logger.info(`Checking if consensus for pending block can be finalized...`);

        const validators = this.getValidValidators();
        const canFinalizeConsensus = phase !== CONSENSUS_PHASES.FINALIZED && validators.length === pBlocks.length;
        if (canFinalizeConsensus) {
            return true;
        }

        this._logger.info(
            `Consensus for pBlock has received ${pBlocks.length} pBlock(s) from a total of ${validators.length} validators`
        );
        return false;
    }

    startFinalizeConsensus() {
        this._logger.info(`Finalizing consensus for pBlock started...`);
        this.phase = CONSENSUS_PHASES.FINALIZING;
    }

    endFinalizeConsensus() {
        this._logger.info(`Finalizing consensus for pBlock ending...`);

        this.phase = CONSENSUS_PHASES.FINALIZED;
        this.clearPendingBlockTimeout();
        this.clearNonInclusionCheckTimeout();
    }

    removePBlocksForValidatorDIDs(validatorDIDs) {
        const { pBlocks } = this;
        validatorDIDs.forEach((validatorDID) => {
            const validatorPBlockIndex = pBlocks.findIndex((pBlock) => pBlock.validatorDID === validatorDID);
            if (validatorPBlockIndex !== -1) {
                this._logger.debug(`Removing pBlock from validator '${validatorDID}' since it's marked as unreachable...`);
                pBlocks.splice(validatorPBlockIndex, 1);
            } else {
                this._logger.warn(
                    `Validator '${validatorDID}' it's marked as unreachable but its block is not present in the pending block`
                );
            }
        });
    }

    startNonInclusionPhase({ timeout, checkForPendingBlockNonInclusionMajorityAsync, broadcastValidatorNonInclusion }) {
        const { validators, pBlocks } = this;

        this.clearNonInclusionCheckTimeout();

        const nonInclusionCheckTimeout = setTimeout(async () => {
            const { phase } = this; // phase can be changed until timeout is run

            this._logger.debug(`nonInclusionCheckTimeout triggered...`);

            await this.waitForSafeProcessing();

            this._logger.debug(`nonInclusionCheckTimeout started...`);

            try {
                // the timeout has occured after the consensus finalization phase started, so we ignore the timeout
                if (phase === CONSENSUS_PHASES.FINALIZING) {
                    this._logger.debug(`pendingBlocksTimeout found the phase to be ${phase}, so canceling timeout...`);
                    return;
                }

                if (phase === CONSENSUS_PHASES.NON_INCLUSION_CHECK) {
                    const canNonInclusionPhaseBeClosed = await checkForPendingBlockNonInclusionMajorityAsync();
                    if (canNonInclusionPhaseBeClosed) {
                        return;
                    }

                    this._logger.info(
                        `non inclusion phase cannot be closed due to missing majority, so starting a new voting phase...`
                    );
                    this.startNonInclusionPhase({
                        timeout,
                        checkForPendingBlockNonInclusionMajorityAsync,
                        broadcastValidatorNonInclusion,
                    });
                }
            } catch (error) {
                this._logger.error(`An error has occurred while running nonInclusionCheckTimeout`, error);

                // an error has occured to start another non inclusion phase check
                this.startNonInclusionPhase({
                    timeout,
                    checkForPendingBlockNonInclusionMajorityAsync,
                    broadcastValidatorNonInclusion,
                });
            }
        }, timeout);

        this.phase = CONSENSUS_PHASES.NON_INCLUSION_CHECK;
        this._logger.info(
            `Consensus timeout for pBlock has been reached. Received only ${pBlocks.length} pBlocks out of ${validators.length} validators. Enter non inclusion phase`
        );
        this.nonInclusionCheckTimeout = nonInclusionCheckTimeout;
        this.validatorNonInclusions = {};
        this.ownUnreachableValidators = validators.filter((validator) =>
            pBlocks.every((pBlock) => pBlock.validatorDID !== validator.DID)
        );

        const unreachableValidators = this.ownUnreachableValidators;
        this._logger.info(
            `Consensus detected ${unreachableValidators.length} unreachable validator(s) for pBlock`,
            JSON.stringify(unreachableValidators)
        );

        broadcastValidatorNonInclusion(unreachableValidators);
    }

    setValidatorNonInclusionAsync(validatorNonInclusion) {
        const { validatorDID, blockNumber, unreachableValidators } = validatorNonInclusion;

        const { phase, validatorNonInclusions } = this;
        if (phase !== CONSENSUS_PHASES.NON_INCLUSION_CHECK) {
            const errorMessage = `Block with number ${blockNumber} not in non inclusion phase, but in ${phase}`;
            this._logger.warn(errorMessage);
            throw new Error(errorMessage);
        }

        if (validatorNonInclusions[validatorDID]) {
            const errorMessage = `Block with number ${blockNumber} has already received a non inclusion response`;
            this._logger.warn(errorMessage, "existing/new", validatorNonInclusions[validatorDID], unreachableValidators);
            throw new Error(errorMessage);
        }

        this._logger.debug(`Received non inclusion message from '${validatorDID}' for block`, unreachableValidators);

        validatorNonInclusions[validatorDID] = unreachableValidators;

        this._checkForPendingBlockNonInclusionMajority(pendingBlock);
    }

    getNonInclusionMajority() {
        const { ownUnreachableValidators, validatorNonInclusions } = this;
        let allNonInclusions = [ownUnreachableValidators, ...Object.values(validatorNonInclusions)];
        const totalNonInclusionsPresent = allNonInclusions.length;
        const nonInclusionsWithCount = {};

        while (allNonInclusions.length) {
            const nonInclusionToSearch = allNonInclusions.shift();
            const nonInclusionToSearchDIDs = nonInclusionToSearch.map((x) => x.DID);
            nonInclusionToSearchDIDs.sort();
            const nonInclusionToSearchKey = nonInclusionToSearchDIDs.join(",");

            const remainingCount = allNonInclusions.length;

            const remainingNonInclusions = allNonInclusions.filter(
                (nonInclusion) => !areNonInclusionListsEqual(nonInclusionToSearch, nonInclusion)
            );

            const nonInclusionToSearchMatchCount = remainingCount - remainingNonInclusions.length + 1;
            nonInclusionsWithCount[nonInclusionToSearchKey] = {
                unreachableValidators: nonInclusionToSearch,
                count: nonInclusionToSearchMatchCount,
            };

            allNonInclusions = remainingNonInclusions;
        }

        const nonInclusionCounts = Object.values(nonInclusionsWithCount).map((x) => x.count);
        const sameNonInclusionMaxCount = Math.max(...nonInclusionCounts);

        const isMajorityFound = sameNonInclusionMaxCount >= Math.floor(totalNonInclusionsPresent / 2) + 1;
        if (!isMajorityFound) {
            return null;
        }

        const nonInclusionMajorityKey = Object.keys(nonInclusionsWithCount).find(
            (nonInclusion) => nonInclusionsWithCount[nonInclusion].count === sameNonInclusionMaxCount
        );
        const nonInclusionMajority = nonInclusionsWithCount[nonInclusionMajorityKey];

        return nonInclusionMajority.unreachableValidators;
    }

    async waitForSafeProcessing() {
        if (this.processing) {
            try {
                await this.processing;
            } catch (error) {
                // an error has occured during the previous processing logic, so we can ignore it
            }
        }
    }

    createBlock(latestBlockHash) {
        const participatingPBlockHashLinks = this.pBlocks.filter((pBlock) => !pBlock.isEmpty).map((pBlock) => pBlock.hashLinkSSI);
        sortPBlocks(participatingPBlockHashLinks);

        const block = {
            pbs: participatingPBlockHashLinks,
            blockNumber: this.blockNumber,
            previousBlock: latestBlockHash,
        };

        return new Block(block);
    }

    getValidValidators() {
        const { validators, pBlocks } = this;

        let validatorsProposedInCurrentBlock = pBlocks.map((pBlock) => {
            if (pBlock.isEmpty) {
                return [];
            }

            const proposedValidators = pBlock.commands
                .filter((command) => command.contractName === "bdns" && command.methodName === "addDomainValidator")
                .map((command) => (command.params ? command.params[0] : null))
                .filter((validator) => validator);
            return proposedValidators || [];
        });
        validatorsProposedInCurrentBlock = [].concat.apply([], validatorsProposedInCurrentBlock); // flatten the array

        const validValidators = validators.filter((validator) => {
            const isValidatorProposedInCurrentBlock = validatorsProposedInCurrentBlock.some(
                (proposedValidator) => proposedValidator.DID === validator.DID && proposedValidator.URL === validator.URL
            );
            return !isValidatorProposedInCurrentBlock;
        });

        return validValidators;
    }
}

module.exports = PendingBlock;

},{"../Block":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/bricksledger/src/Block.js","../Logger":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/bricksledger/src/Logger.js","./utils":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/bricksledger/src/ConsensusCore/utils.js"}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/bricksledger/src/ConsensusCore/ValidatorContractExecutor.js":[function(require,module,exports){
const Block = require("../Block");
const Command = require("../Command");
const Logger = require("../Logger");
const PBlock = require("../PBlock");

class ValidatorContractExecutor {
    constructor(domain, sourceValidatorDID, validatorDID, validatorURL) {
        this._domain = domain;
        this._validatorDID = validatorDID;
        this._validatorURL = validatorURL;
        this._logger = new Logger(`[Bricksledger][${domain}][${sourceValidatorDID.getIdentifier()}][ValidatorContractExecutor]`);
    }

    async getValidatorsAsync() {
        return await this._callSafeCommand("bdns", "getDomainValidators");
    }

    async getLatestBlockInfoAsync() {
        return await this._callSafeCommand("consensus", "getLatestBlockInfo");
    }

    async getBlockAsync(blockHashLinkSSI) {
        const blockContent = await this._callSafeCommand("consensus", "getBlock", [blockHashLinkSSI]);
        const block = new Block(blockContent);
        return block;
    }

    async getPBlockAsync(pBlockHashLinkSSI) {
        const pBlockContent = await this._callSafeCommand("consensus", "getPBlock", [pBlockHashLinkSSI]);
        const pBlock = new PBlock(pBlockContent);
        await pBlock.validateSignature();

        if (pBlock.commands && Array.isArray(pBlock.commands)) {
            pBlock.commands = pBlock.commands.map((command) => new Command(command));
        }

        return pBlock;
    }

    async getPBlockProposedByValidatorAsync(blockNumber, validatorDID) {
        return await this._callSafeCommand("consensus", "getPBlockProposedByValidator", [blockNumber, validatorDID]);
    }

    async proposeValidatorAsync(proposedValidator) {
        await this._callNoncedCommand("bdns", "addDomainValidator", [proposedValidator]);
    }

    async _callSafeCommand(contractName, methodName, params) {
        const opendsu = require("opendsu");
        const contractsApi = opendsu.loadApi("contracts");

        const generateSafeCommand = $$.promisify(contractsApi.generateSafeCommandForSpecificServer);

        const paramsString = typeof params === "object" ? JSON.stringify(params) : params;
        const callDebugInfo = `validator '${this._validatorDID}'s (${this._validatorURL}) contract '${contractName}' - safe - '${methodName}' - params: ${paramsString}`;
        this._logger.debug(`Calling ${callDebugInfo}`);

        try {
            const result = await generateSafeCommand(this._validatorURL, this._domain, contractName, methodName, params);
            this._logger.debug(`Calling validator ${callDebugInfo} responded with:`, result);

            return result.optimisticResult;
        } catch (error) {
            this._logger.debug(`Calling validator ${callDebugInfo} failed with:`, error);
            throw error;
        }
    }

    async _callNoncedCommand(contractName, methodName, params) {
        const opendsu = require("opendsu");
        const contractsApi = opendsu.loadApi("contracts");

        const generateNoncedCommand = $$.promisify(contractsApi.generateNoncedCommandForSpecificServer);

        const paramsString = typeof params === "object" ? JSON.stringify(params) : params;
        const callDebugInfo = `validator '${this._validatorDID}'s contract '${contractName}' - nonced - '${methodName}' - params: ${paramsString}`;
        this._logger.debug(`Calling ${callDebugInfo}`);

        try {
            const result = await generateNoncedCommand(
                this._validatorURL,
                this._validatorDID,
                this._domain,
                contractName,
                methodName,
                params
            );
            this._logger.debug(`Calling validator ${callDebugInfo} responded with:`, result);

            return result;
        } catch (error) {
            this._logger.debug(`Calling validator ${callDebugInfo} failed with:`, error);
        }
    }
}

module.exports = ValidatorContractExecutor;

},{"../Block":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/bricksledger/src/Block.js","../Command":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/bricksledger/src/Command.js","../Logger":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/bricksledger/src/Logger.js","../PBlock":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/bricksledger/src/PBlock.js","opendsu":"opendsu"}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/bricksledger/src/ConsensusCore/ValidatorContractExecutorFactory.js":[function(require,module,exports){
const ValidatorContractExecutor = require("./ValidatorContractExecutor");

function create(...params) {
    return new ValidatorContractExecutor(...params);
}

module.exports = {
    create
}
},{"./ValidatorContractExecutor":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/bricksledger/src/ConsensusCore/ValidatorContractExecutor.js"}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/bricksledger/src/ConsensusCore/ValidatorSynchronizer.js":[function(require,module,exports){
const Logger = require("../Logger");
const Block = require("../Block");
function getHashFromHashLinkSSI(hashLinkSSI) {
    const keySSI = require("opendsu").loadApi("keyssi");
    hashLinkSSI = keySSI.parse(hashLinkSSI);
    return hashLinkSSI.getHash();
}

const VALIDATOR_SYNC_INTERVAL_MS = 10 * 1000;

class ValidatorSynchronizer {
    constructor(
        domain,
        currentValidatorDID,
        currentValidatorURL,
        validator,
        brickStorage,
        getLatestBlockInfo,
        getLocalValidators,
        validatorContractExecutorFactory,
        executeBlock,
        onSyncFinished
    ) {
        this.domain = domain;
        this.currentValidatorDID = currentValidatorDID;
        this.currentValidatorURL = currentValidatorURL;
        this.validatorDID = validator.DID;
        this.validatorURL = validator.URL;
        this.brickStorage = brickStorage;
        this.getLatestBlockInfo = getLatestBlockInfo;
        this.getLocalValidators = getLocalValidators;
        this.validatorContractExecutorFactory = validatorContractExecutorFactory;
        this.executeBlock = executeBlock;
        this.onSyncFinished = onSyncFinished;

        this._logger = new Logger(
            `[Bricksledger][${domain}][${this.currentValidatorDID.getIdentifier()}][Consensus][ValidatorSynchronizer]`
        );
        this._logger.info("Create finished");
    }

    async synchronize() {
        const { domain, validatorDID, validatorURL, validatorContractExecutorFactory } = this;

        this._logger.info(`Checking validator '${validatorDID}' for validator list...`);
        this._validatorContractExecutor = validatorContractExecutorFactory.create(
            domain,
            this.currentValidatorDID,
            validatorDID,
            validatorURL
        );

        this._blockSyncInterval = setInterval(async () => {
            this._runSyncFlow();
        }, VALIDATOR_SYNC_INTERVAL_MS);

        this._runSyncFlow();
    }

    async _runSyncFlow() {
        if (this._isSyncInProgress) {
            this._logger.info("Another block sync is already in progress...");
            return;
        }

        try {
            this._isSyncInProgress = true;
            await this._getMissingBlocksFromValidator();
            await this._proposeSelfAsValidator();
        } catch (error) {
            this._logger.error("An error has occured while running sync flow", error);
            throw error;
        } finally {
            this._isSyncInProgress = false;
        }
    }

    async _getMissingBlocksFromValidator() {
        const { domain, validatorDID } = this;

        this._logger.info(`Checking validator '${validatorDID}' for latest block info...`);

        const validatorLatestBlockInfo = await this._validatorContractExecutor.getLatestBlockInfoAsync();
        const { number, hash } = validatorLatestBlockInfo;
        this._logger.info(`Validator '${validatorDID}' responded with block number ${number} and latest hash ${hash}...`);

        const { number: latestBlockNumber, hash: latestBlockHash } = this.getLatestBlockInfo();
        if (latestBlockNumber < number) {
            this._logger.info(`Starting synchronization with validator '${validatorDID}'...`);

            const missingBlocks = [];

            let queriedBlockHash = hash;
            while (true) {
                this._logger.info(`Getting block with hash '${queriedBlockHash}' from validator '${validatorDID}'...`);
                const blockInfo = await this._validatorContractExecutor.getBlockAsync(queriedBlockHash);
                const block = new Block(blockInfo);
                block.hashLinkSSI = queriedBlockHash;
                missingBlocks.unshift(block);

                if (!block.previousBlock || block.previousBlock === latestBlockHash) {
                    this._logger.info(
                        `Finished getting ${missingBlocks.length} missing block(s) from validator '${validatorDID}'`
                    );
                    break;
                }

                queriedBlockHash = block.previousBlock;
            }

            for (let blockIndex = 0; blockIndex < missingBlocks.length; blockIndex++) {
                const missingBlock = missingBlocks[blockIndex];
                this._logger.info(
                    `Getting pblocks for block number ${missingBlock.blockNumber} [${blockIndex + 1}/${missingBlocks.length}]'...`
                );

                // loading pblock for block
                const pBlocks = [];
                for (let pBlockIndex = 0; pBlockIndex < missingBlock.pbs.length; pBlockIndex++) {
                    const pBlockHash = missingBlock.pbs[pBlockIndex];
                    this._logger.debug(`Checking pblock '${pBlockHash}' [${pBlockIndex + 1}/${missingBlock.pbs.length}]...`);

                    const pBlockBrickHash = getHashFromHashLinkSSI(pBlockHash);
                    let pBlock;

                    try {
                        this._logger.debug(`Getting pblock '${pBlockHash}' from brickstorage (hash: ${pBlockBrickHash})...`);
                        pBlock = await this.brickStorage.getBrickAsync(pBlockBrickHash);
                    } catch (error) {
                        this._logger.debug(`Pblock '${pBlockHash}' not present in brickstorage, so adding it...`, error);

                        this._logger.debug(`Getting pblock '${pBlockHash}'...`);
                        pBlock = await this._validatorContractExecutor.getPBlockAsync(pBlockHash);

                        this._logger.debug(`Storing pblock '${pBlockHash}' in brickstorage...`);
                        try {
                            const hash = await this.brickStorage.addBrickAsync(pBlock.getSerialisation());
                            if (hash !== pBlockBrickHash) {
                                this._logger.error(
                                    `PBlock '${pBlockHash}' has it's hash equal to '${pBlockBrickHash}', but saving it locally has returned a hash of '${hash}'`
                                );
                            }
                        } catch (error) {
                            // we can continue the boot even if the pblock cache storage failed
                            this._logger.debug(`Storing pblock '${pBlockHash}' in brickstorage failed`, error);
                            throw error;
                        }
                    }

                    pBlocks.push(pBlock);
                }

                this._logger.info(`Executing block with hash '${missingBlock.hashLinkSSI}'...`);
                await this.executeBlock(missingBlock, pBlocks);
            }
        } else {
            this._logger.info(
                `Synchronization with validator '${validatorDID}' (${number} block(s)) is not needed since it doesn't have newer block - self hash ${latestBlockNumber} block(s)`
            );
        }
    }

    async _proposeSelfAsValidator() {
        const { validatorDID } = this;
        const currentValidatorDID = this.currentValidatorDID.getIdentifier();

        const validatorLatestBlockInfo = await this._validatorContractExecutor.getLatestBlockInfoAsync();
        const { number } = validatorLatestBlockInfo;
        const { number: latestBlockNumber } = this.getLatestBlockInfo();
        if (latestBlockNumber < number) {
            this._logger.info(
                `Cannot propose self as validator because validator '${validatorDID}' is at block number ${number} while self is at ${latestBlockNumber}. Waiting for sync...`
            );
            return;
        }

        const validatorValidators = (await this._validatorContractExecutor.getValidatorsAsync()) || [];
        this._logger.info(`Received ${validatorValidators.length} validator(s) from '${validatorDID}'`, validatorValidators);

        const isSelfRegisteredInValidator = validatorValidators.some((validator) => validator.DID === currentValidatorDID);
        if (isSelfRegisteredInValidator) {
            this._logger.info(`Self is already part of the validator's '${this.validatorDID}' validator list`);

            this._logger.info(`Checking if self is part of self's validator list by getting local validators...`);
            const localValidators = await this.getLocalValidators();
            this._logger.debug(`Got ${localValidators.length} local validator(s),`, localValidators);
            const isSelfPresentInLocalValidators = localValidators.some((validator) => validator.DID === currentValidatorDID);
            if (isSelfPresentInLocalValidators) {
                this._logger.info(`Self is part of self's validator list. Synchronization completed.`);
                clearInterval(this._blockSyncInterval);
                this.onSyncFinished();
            }
        } else if (this._validatorProposalBlockNumber == null || this._validatorProposalBlockNumber < number) {
            this._logger.info(`Self is not part of the validator's '${this.validatorDID}' validators list. Sending proposal...`);

            const { currentValidatorURL } = this;

            try {
                const proposedValidator = {
                    DID: currentValidatorDID,
                    URL: currentValidatorURL,
                };
                await this._validatorContractExecutor.proposeValidatorAsync(proposedValidator);

                // we save the block number for when we send the validator proposal command, in order to check if it was accepted or not
                this._validatorProposalBlockNumber = number;

                this._logger.info(`Successfully proposed self as validator`);
            } catch (error) {
                this._logger.info(`Failed to propose self as validator to validator '${validatorDID}'`, error);
                throw error;
            }
        }
    }
}

module.exports = ValidatorSynchronizer;

},{"../Block":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/bricksledger/src/Block.js","../Logger":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/bricksledger/src/Logger.js","opendsu":"opendsu"}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/bricksledger/src/ConsensusCore/index.js":[function(require,module,exports){
/*
A configurable consensus core that can have 3 consensus strategies
 - SVBC - Single Validator BrickLedger Consensus:  Only one node is accepting commands and propose BrickBlocks. A block has only one BrickBlock.
 - MVBC - Multiple Validators BrickLedger Consensus: run the BrickLedger consensus between validators
 - OBAC - Other Blockchain Adapter Consensus: Delegates Consensus to a blockchain adapter that is using other blockchain network for consensus regrading the blocks of commands 
*/

const PendingBlock = require("./PendingBlock");
const PBlock = require("../PBlock");
const Logger = require("../Logger");
const { clone } = require("../utils/object-utils");
const {
    getLocalLatestBlockInfo,
    getValidatedBlocksWriteStream,
    saveBlockInBricks,
    appendValidatedBlockHash,
    loadValidatorsFromBdns,
    savePBlockInBricks,
    areNonInclusionListsEqual,
} = require("./utils");
const ValidatorSynchronizer = require("./ValidatorSynchronizer");
const PBlockAddedMessage = require("../Broadcaster/PBlockAddedMessage");

const DEFAULT_PENDING_BLOCKS_TIMEOUT_MS = 1000 * 60; // 1 minute
const DEFAULT_NON_INCLUSION_CHECK_TIMEOUT_MS = 1000 * 60; // 1 minute

class ConsensusCore {
    constructor(
        validatorDID,
        validatorURL,
        domain,
        storageFolder,
        brickStorage,
        executionEngine,
        broadcaster,
        notifier,
        pendingBlocksTimeoutMs,
        nonInclusionCheckTimeoutMs,
        validatorContractExecutorFactory
    ) {
        this._validatorDID = validatorDID;
        this._validatorURL = validatorURL;
        this._domain = domain;
        this._storageFolder = storageFolder;

        this._pendingBlocksTimeoutMs = pendingBlocksTimeoutMs || DEFAULT_PENDING_BLOCKS_TIMEOUT_MS;
        this._nonInclusionCheckTimeoutMs = nonInclusionCheckTimeoutMs || DEFAULT_NON_INCLUSION_CHECK_TIMEOUT_MS;

        this._brickStorage = brickStorage;
        this._executionEngine = executionEngine;
        this._broadcaster = broadcaster;
        this._notifier = notifier;
        this._validatorContractExecutorFactory =
            validatorContractExecutorFactory || require("./ValidatorContractExecutorFactory");

        this._latestBlockNumber = 0;
        this._latestBlockHash = null;

        this._pendingBlocksByBlockNumber = {};

        this._isRunning = false;

        this._logger = new Logger(`[Bricksledger][${this._domain}][${this._validatorDID.getIdentifier()}][Consensus]`);
        this._logger.info("Create finished");
    }

    async boot() {
        this._logger.info(`Booting consensus...`);

        this.validators = await this._loadValidators();

        this._logger.info(`Checking local blocks history...`);
        const latestBlockInfo = await getLocalLatestBlockInfo(this._storageFolder, this._domain);
        const { number, hash } = latestBlockInfo;
        this._latestBlockNumber = number;
        this._latestBlockHash = hash;
        this._logger.info(`Found ${number} local block(s), with the latest block hash being ${hash}...`);

        // this.validatedBlocksWriteStream = await getValidatedBlocksWriteStream(this._storageFolder, this._domain);

        const validatorsExceptSelf = this.validators.filter((validator) => validator.DID !== this._validatorDID.getIdentifier());
        this._logger.info(`Found ${validatorsExceptSelf.length} external validators`);
        if (validatorsExceptSelf.length) {
            const validator = validatorsExceptSelf[0];

            return new Promise(async (resolve) => {
                const onSyncFinished = () => {
                    // the synchronization process is finished (all blocks are up to date and validator is recognized as a validator)
                    this._isRunning = true;
                    resolve();
                };
                const validatorSynchronizer = new ValidatorSynchronizer(
                    this._domain,
                    this._validatorDID,
                    this._validatorURL,
                    validator,
                    this._brickStorage,
                    this.getLatestBlockInfo.bind(this),
                    loadValidatorsFromBdns.bind(null, this._domain, this._executionEngine),
                    this._validatorContractExecutorFactory,
                    this._executeBlock.bind(this),
                    onSyncFinished
                );
                await validatorSynchronizer.synchronize();
            });
        } else {
            // no external validators were found except self, so we will be running consensus with a single validator
            this._isRunning = true;
        }
    }

    isRunning() {
        return this._isRunning;
    }

    getLatestBlockInfo() {
        return {
            number: this._latestBlockNumber,
            hash: this._latestBlockHash,
        };
    }

    addInConsensus(pBlock, callback) {
        callback = $$.makeSaneCallback(callback);

        this.addInConsensusAsync(pBlock)
            .then((result) => callback(undefined, result))
            .catch((error) => callback(error));
    }

    async addInConsensusAsync(pBlock) {
        if (!this._isRunning) {
            throw new Error("Consensus not yet running");
        }

        if (!(pBlock instanceof PBlock)) {
            throw new Error("pBlock not instance of PBlock");
        }

        await this.validatePBlockAsync(pBlock);

        // return a promise when the final consensus is reached
        return new Promise(async (resolve, reject) => {
            pBlock.onConsensusFinished = (error, result) => {
                if (error) {
                    return reject(error);
                }
                resolve(result);
            };

            reject = $$.makeSaneCallback(reject);
            try {
                await this._addPBlockToPendingBlock(pBlock);
            } catch (error) {
                reject(error);
            }
        });
    }

    async addExternalPBlockInConsensus(pBlockMessage, callback) {
        callback = $$.makeSaneCallback(callback);

        this.addExternalPBlockInConsensusAsync(pBlockMessage)
            .then((result) => callback(undefined, result))
            .catch((error) => callback(error));
    }

    async addExternalPBlockInConsensusAsync(pBlockMessage) {
        if (!this._isRunning) {
            throw new Error("Consensus not yet running");
        }

        if (!(pBlockMessage instanceof PBlockAddedMessage)) {
            throw new Error("pBlock not instance of PBlock");
        }

        let pBlock;
        if (pBlockMessage.pBlockHashLinkSSI) {
            this._logger.debug(`Getting external pBlock ${pBlockMessage.pBlockHashLinkSSI} from pBlock message`, pBlockMessage);
            const { validatorDID, validatorURL, pBlockHashLinkSSI } = pBlockMessage;
            const validatorContractExecutor = this._validatorContractExecutorFactory.create(
                this._domain,
                this._validatorDID,
                validatorDID,
                validatorURL
            );
            pBlock = await validatorContractExecutor.getPBlockAsync(pBlockHashLinkSSI);
            pBlock.hashLinkSSI = await savePBlockInBricks(pBlock, this._domain, this._brickStorage);
        } else {
            this._logger.debug(`Received empty external pBlock`, pBlockMessage);
            pBlock = new PBlock(pBlockMessage);
        }
        this._logger.debug(`Validating external pBlock...`);
        await this.validatePBlockAsync(pBlock);

        // dont' await processing finish in order to return to calling mmember
        this._addPBlockToPendingBlock(pBlock);
    }

    validatePBlock(pBlock, callback) {
        callback = $$.makeSaneCallback(callback);

        this.validatePBlockAsync(pBlock)
            .then((result) => callback(undefined, result))
            .catch((error) => callback(error));
    }

    async validatePBlockAsync(pBlock) {
        if (!this._isRunning) {
            throw new Error("Consensus not yet running");
        }

        if (!(pBlock instanceof PBlock)) {
            throw new Error("pBlock not instance of PBlock");
        }

        const { blockNumber, validatorDID } = pBlock;

        if (blockNumber <= this._latestBlockNumber) {
            this._logger.error("Wanting to validate old PBlock", pBlock);
            throw new Error(
                `pBlock has block number ${blockNumber} less than or equal to the latest block number ${this._latestBlockNumber}`
            );
        }

        await pBlock.validateSignature();
    }

    setValidatorNonInclusion(validatorNonInclusion, callback) {
        callback = $$.makeSaneCallback(callback);

        this.setValidatorNonInclusionAsync(validatorNonInclusion)
            .then((result) => callback(undefined, result))
            .catch((error) => callback(error));
    }

    async setValidatorNonInclusionAsync(validatorNonInclusion) {
        if (!this._isRunning) {
            throw new Error("Consensus not yet running");
        }

        const { blockNumber } = validatorNonInclusion;

        const pendingBlock = this._pendingBlocksByBlockNumber[blockNumber];
        if (!pendingBlock) {
            const errorMessage = `Unexisting block with number ${blockNumber}`;
            this._logger.warn(errorMessage);
            throw new Error(errorMessage);
        }

        await pendingBlock.waitForSafeProcessing();

        pendingBlock.setValidatorNonInclusionAsync(validatorNonInclusion);
        this._checkForPendingBlockNonInclusionMajorityAsync(pendingBlock);
    }

    getPBlockProposedForConsensus(blockNumber, validatorDID, callback) {
        callback = $$.makeSaneCallback(callback);

        this.getPBlockProposedForConsensusAsync(blockNumber, validatorDID)
            .then((result) => callback(undefined, result))
            .catch((error) => callback(error));
    }

    async getPBlockProposedForConsensusAsync(blockNumber, validatorDID) {
        const pendingBlock = this._pendingBlocksByBlockNumber[blockNumber];
        if (!pendingBlock) {
            const errorMessage = `Unexisting block with number ${blockNumber}`;
            this._logger.error(errorMessage);
            throw new Error(errorMessage);
        }

        const validatorPBlock = pendingBlock.pBlocks.find((pBlock) => pBlock.validatorDID === validatorDID);
        if (!pendingBlock) {
            const errorMessage = `Unexisting pBlock with validator '${validatorDID}' for block number ${blockNumber}`;
            this._logger.error(errorMessage);
            throw new Error(errorMessage);
        }

        return validatorPBlock;
    }

    isConsensusRunningForBlockNumber(blockNumber) {
        return (
            this._pendingBlocksByBlockNumber[blockNumber] && this._pendingBlocksByBlockNumber[blockNumber].isConsensusRunning()
        );
    }

    async _addPBlockToPendingBlock(pBlock) {
        const { validatorDID, blockNumber } = pBlock;

        let pendingBlock = this._pendingBlocksByBlockNumber[blockNumber];

        if (!pendingBlock) {
            await this._createPendingBlockForBlockNumber(blockNumber);
            pendingBlock = this._pendingBlocksByBlockNumber[blockNumber];
        }

        await pendingBlock.waitForSafeProcessing();

        pendingBlock.processing = new Promise(async (resolve, reject) => {
            try {
                pendingBlock.validateCanReceivePBlock(pBlock);
                pendingBlock.validatePBlockValidator(pBlock);
                pendingBlock.validateNoPBlockFromValidator(validatorDID);

                pendingBlock.addPBlock(pBlock);

                if (pendingBlock.canFinalizeConsensus()) {
                    this._finalizeConsensusForPendingBlockAsync(pendingBlock); // no need to await in order to finish processing
                }
            } catch (error) {
                this._logger.error(
                    `A processing error has occurred while adding a pBlock to pending block number ${blockNumber}`,
                    pBlock,
                    error
                );
                return reject(error);
            }

            resolve(); // mark processing finished
        });

        await pendingBlock.processing;
    }

    async _createPendingBlockForBlockNumber(blockNumber) {
        const pendingBlock = new PendingBlock(this._domain, this._validatorDID, blockNumber);
        this._pendingBlocksByBlockNumber[blockNumber] = pendingBlock;

        pendingBlock.processing = new Promise(async (resolve, reject) => {
            try {
                // add validators after setting pendingBlock in order to avoid race condition issues
                const validators = await this._loadValidators();
                pendingBlock.setValidators(validators);

                pendingBlock.startPendingBlocksPhase({
                    timeoutMs: this._pendingBlocksTimeoutMs,
                    onFinalizeConsensusAsync: () => {
                        return this._finalizeConsensusForPendingBlockAsync(pendingBlock);
                    },
                    onStartNonInclusionPhase: () => {
                        pendingBlock.startNonInclusionPhase({
                            timeout: this._nonInclusionCheckTimeoutMs,
                            checkForPendingBlockNonInclusionMajorityAsync: () => {
                                return this._checkForPendingBlockNonInclusionMajorityAsync(pendingBlock);
                            },
                            broadcastValidatorNonInclusion: (unreachableValidators) => {
                               this._broadcaster.broadcastValidatorNonInclusion(blockNumber, unreachableValidators);
                            },
                        });
                    },
                });
            } catch (error) {
                this._logger.error(`A processing error has occurred while creating pending block number ${blockNumber}`, error);
                return reject(error);
            }

            resolve(); // mark processing finished
        });
    }

    async _checkForPendingBlockNonInclusionMajorityAsync(pendingBlock) {
        const { blockNumber } = pendingBlock;
        this._logger.info(`Checking if consensus for pending block ${blockNumber} has a non inclusion majority...`);

        const nonInclusionMajority = pendingBlock.getNonInclusionMajority();
        if (!nonInclusionMajority) {
            this._logger.info(`No non inclusion majority found for pending block ${blockNumber}`);
            return false;
        }

        this._logger.info(
            `Found non inclusion majority for pending block ${blockNumber} has a non inclusion majority...`,
            nonInclusionMajority
        );

        const { ownUnreachableValidators } = pendingBlock;
        if (areNonInclusionListsEqual(ownUnreachableValidators, nonInclusionMajority)) {
            this._logger.info(`The pending block own's non inclusion validators is the same as the non inclusion majority`);

            pendingBlock.clearNonInclusionCheckTimeout();
            this._finalizeConsensusForPendingBlockAsync(pendingBlock); // no need to await in order to finish processing
            return true;
        }

        this._logger.info(
            `The pending block own's non inclusion validators is different then the non inclusion majority: [own/majority]`,
            ownUnreachableValidators,
            nonInclusionMajority
        );

        const majorityValidatorDIDsSet = new Set(nonInclusionMajority.map((x) => x.DID));
        const ownUnreachableValidatorDIDsSet = new Set(ownUnreachableValidators.map((x) => x.DID));

        const pendingBlockExtraValidatorDIDs = [...majorityValidatorDIDsSet].filter(
            (x) => !ownUnreachableValidatorDIDsSet.has(x)
        );
        if (pendingBlockExtraValidatorDIDs.length) {
            this._logger.info(
                `The pending block has pBlocks from validators marked as unreachable by the majority`,
                pendingBlockExtraValidatorDIDs
            );

            pendingBlock.removePBlocksForValidatorDIDs(pendingBlockExtraValidatorDIDs);
        }

        const pendingBlockMissingValidatorDIDs = [...ownUnreachableValidatorDIDsSet].filter(
            (x) => !majorityValidatorDIDsSet.has(x)
        );

        if (pendingBlockMissingValidatorDIDs.length) {
            this._logger.info(
                `The pending block has missing pBlocks as compared by the non inclusion majority`,
                pendingBlockMissingValidatorDIDs
            );
            const { pBlocks, validators, validatorNonInclusions } = pendingBlock;
            const reachableValidatorDIDs = pBlocks.map((pBlock) => pBlock.validatorDID);

            for (let i = 0; i < pendingBlockMissingValidatorDIDs.length; i++) {
                const missingValidatorDID = pendingBlockMissingValidatorDIDs[i];
                this._logger.debug(`Trying to get missing pBlock by validator ${missingValidatorDID}...`);

                const validatorDIDsWithMissingValidatorPBlock = reachableValidatorDIDs.filter((did) => {
                    const nonInclusionsForValidator = validatorNonInclusions[did];
                    if (!nonInclusionsForValidator) {
                        // we have received pBlocks for this DID, but we haven't received the non inclusion voting from him, so try to get the missing pBlock
                        return true;
                    }

                    const isMissingValidatorReachableForDID = !nonInclusionsForValidator.some(
                        (nonInclusion) => nonInclusion.DID === did
                    );
                    return isMissingValidatorReachableForDID;
                });

                for (let j = 0; j < validatorDIDsWithMissingValidatorPBlock.length; j++) {
                    const validatorDID = validatorDIDsWithMissingValidatorPBlock[j];
                    const validatorURL = validators.find((validator) => validator.DID === validatorDID);
                    const validatorContractExecutor = this._validatorContractExecutorFactory.create(
                        this._domain,
                        this._validatorDID,
                        validatorDID,
                        validatorURL
                    );

                    try {
                        const missingPBlock = await validatorContractExecutor.getPBlockProposedByValidatorAsync(
                            blockNumber,
                            missingValidatorDID
                        );

                        pBlocks.push(missingPBlock);

                        break; // the missing pBlock has been loaded so continue with the next one
                    } catch (error) {
                        this._logger.error(
                            `Failed to load missing pBlock by validator '${missingValidatorDID}' by querying it from validator '${validatorDID}'`,
                            error
                        );
                    }
                }
            }

            const wereAllMissingPBlocksLoaded = pendingBlockMissingValidatorDIDs.every((missingValidatorDID) =>
                pBlocks.some((pBlock) => pBlock.validatorDID === missingValidatorDID)
            );

            if (wereAllMissingPBlocksLoaded) {
                this._logger.info("All missing pBlocks were successfully loaded, so the consensus can be finalized");
                this._finalizeConsensusForPendingBlockAsync(pendingBlock); // no need to await in order to finish processing
                return true;
            } else {
                this._logger.warn("Not all missing pBlocks were successfully loaded!");
            }
        }

        return false;
    }

    async _finalizeConsensusForPendingBlockAsync(pendingBlock) {
        pendingBlock.startFinalizeConsensus();

        try {
            // consensus finished with success, so generate block and broadcast it
            const block = pendingBlock.createBlock(this._latestBlockHash);
            this._logger.info(`Created block for block number ${pendingBlock.blockNumber}...`, block);
            await this._executeBlock(block, pendingBlock.pBlocks);
            pendingBlock.endFinalizeConsensus();
            await this._notifyPBlocksConsensusFinished(pendingBlock.pBlocks);
        } catch (error) {
            this._logger.error("Error while finalizing pBlock consensus", error, pendingBlock);
            throw error;
        }
    }

    async _executeBlock(block, pBlocks) {
        await this._storeBlock(block);
        await this._executePBlocks(pBlocks);
        await this._updateLatestBlockInfo(block);
    }

    async _storeBlock(block) {
        this._logger.info("Storing block", block);
        const blockHashLinkSSI = await saveBlockInBricks(block, this._domain, this._brickStorage);
        block.hashLinkSSI = blockHashLinkSSI;
    }

    async _executePBlocks(pBlocks) {
        this._logger.debug("Executing pBlocks...");
        const populatedPBlocks = pBlocks.filter((pBlock) => !pBlock.isEmpty);

        for (let index = 0; index < populatedPBlocks.length; index++) {
            const pBlock = populatedPBlocks[index];

            try {
                if (pBlock.validatorDID !== this._validatorDID.getIdentifier()) {
                    // we don't need to execute the current validator's own PBlock since it was executed when the commands were executed
                    // so we just need to call the callback
                    await this._executionEngine.executePBlock(pBlock);
                }
            } catch (error) {
                this._logger.error("Failed to execute pBlock", pBlock);
                // throw error; // todo: find best approach in this situation
            }
        }
    }

    async _notifyPBlocksConsensusFinished(pBlocks) {
        this._logger.debug("Notifying pBlocks of consensus finished...");
        pBlocks
            .filter((pBlock) => typeof pBlock.onConsensusFinished === "function")
            .forEach((pBlock) => {
                try {
                    pBlock.onConsensusFinished();
                } catch (error) {
                    // we just notify the pblock that the consensus has finished
                }
            });
    }

    async _updateLatestBlockInfo(block) {
        this._logger.info(`Updating latest block number to ${block.blockNumber} and latest block hash to ${block.hashLinkSSI}`);
        this._latestBlockNumber = block.blockNumber;
        this._latestBlockHash = block.hashLinkSSI;

        const validatedBlocksWriteStream = await getValidatedBlocksWriteStream(this._storageFolder, this._domain);
        await appendValidatedBlockHash(this._latestBlockHash, validatedBlocksWriteStream);
        validatedBlocksWriteStream.close();

        this._notifier.notifyNewBlock({ number: block.blockNumber, hash: block.hashLinkSSI });
    }

    async _loadValidators() {
        this._logger.info(`Loading validators...`);
        const validators = await loadValidatorsFromBdns(this._domain, this._executionEngine);
        this._logger.info(`Found ${validators.length} validator(s) from BDNS`);
        this._logger.debug(`Validator(s) from BDNS: ${validators.map((validator) => validator.DID).join(", ")}`);

        return validators;
    }
}

function create(...params) {
    return new ConsensusCore(...params);
}

module.exports = {
    create,
};

},{"../Broadcaster/PBlockAddedMessage":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/bricksledger/src/Broadcaster/PBlockAddedMessage.js","../Logger":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/bricksledger/src/Logger.js","../PBlock":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/bricksledger/src/PBlock.js","../utils/object-utils":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/bricksledger/src/utils/object-utils.js","./PendingBlock":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/bricksledger/src/ConsensusCore/PendingBlock.js","./ValidatorContractExecutorFactory":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/bricksledger/src/ConsensusCore/ValidatorContractExecutorFactory.js","./ValidatorSynchronizer":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/bricksledger/src/ConsensusCore/ValidatorSynchronizer.js","./utils":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/bricksledger/src/ConsensusCore/utils.js"}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/bricksledger/src/ConsensusCore/utils.js":[function(require,module,exports){
const { checkIfPathExists, ensurePathExists } = require("../utils/fs-utils");
const { getValidatorsForCurrentDomain } = require("../utils/bdns-utils");

const CONSENSUS_PHASES = {
    PENDING_BLOCKS: "PENDING_BLOCKS",
    NON_INCLUSION_CHECK: "NON_INCLUSION_CHECK",
    FINALIZING: "FINALIZING",
    FINALIZED: "FINALIZED",
};

async function getCachedBlocksFolderPath(storageFolder, domain) {
    const path = require("path");
    const folderPath = path.join(storageFolder, "domains", domain, "cache/blocks");
    try {
        await ensurePathExists(folderPath);
    } catch (error) {
        console.log(error);
    }
    return folderPath;
}

async function getValidatedBlocksFilePath(storageFolder, domain) {
    const path = require("path");
    const validatedBlocksFolderPath = path.join(storageFolder, "domains", domain);
    try {
        await ensurePathExists(validatedBlocksFolderPath);
    } catch (error) {
        console.log(error);
    }

    const validatedBlocksFilePath = path.join(validatedBlocksFolderPath, "blocks");
    return validatedBlocksFilePath;
}

async function getLocalLatestBlockInfo(storageFolder, domain) {
    let latestBlockNumber = 0;
    let latestBlockHash = null;

    // if blocks file exists, then we have blocks that we have validated in the past
    const validatedBlocksFilePath = await getValidatedBlocksFilePath(storageFolder, domain);
    if (await checkIfPathExists(validatedBlocksFilePath)) {
        return new Promise((resolve, reject) => {
            const fs = require("fs");
            const os = require("os");
            const readStream = fs.createReadStream(validatedBlocksFilePath);
            readStream
                .on("data", function (chunk) {
                    // split chunk by newline in order to get the block hashes
                    const hashes = chunk
                        .toString()
                        .split(os.EOL)
                        .map((hash) => (hash ? hash.trim() : null))
                        .filter((hash) => !!hash);

                    if (hashes.length) {
                        latestBlockNumber += hashes.length;
                        latestBlockHash = hashes[hashes.length - 1];
                    }
                })
                .on("close", function (error) {
                    if (error) {
                        return reject(error);
                    }

                    resolve({
                        number: latestBlockNumber,
                        hash: latestBlockHash,
                    });
                });
        });
    }

    return {
        number: latestBlockNumber,
        hash: latestBlockHash,
    };
}

async function getValidatedBlocksWriteStream(storageFolder, domain) {
    const validatedBlocksFilePath = await getValidatedBlocksFilePath(storageFolder, domain);

    const fs = require("fs");
    const validatedBlocksWriteStream = fs.createWriteStream(validatedBlocksFilePath, { flags: "a" });
    return validatedBlocksWriteStream;
}

async function saveBlockInBricks(block, domain, brickStorage) {
    const openDSU = require("opendsu");
    const keySSISpace = openDSU.loadApi("keyssi");

    const brickHash = await brickStorage.addBrickAsync(block.getSerialisation());

    const hashLinkSSI = keySSISpace.createHashLinkSSI(domain, brickHash);
    return hashLinkSSI.getIdentifier();
}

async function savePBlockInBricks(pBlock, domain, brickStorage) {
    const openDSU = require("opendsu");
    const keySSISpace = openDSU.loadApi("keyssi");

    const pBlockBrickHash = await brickStorage.addBrickAsync(pBlock.getSerialisation());

    const hashLinkSSI = keySSISpace.createHashLinkSSI(domain, pBlockBrickHash);
    return hashLinkSSI.getIdentifier();
}

async function appendValidatedBlockHash(blockHash, writeStream) {
    const os = require("os");
    const line = `${os.EOL}${blockHash}`;
    await $$.promisify(writeStream.write.bind(writeStream))(line);
}

async function loadValidatorsFromBdns(domain, executionEngine) {
    const validators = await getValidatorsForCurrentDomain(executionEngine);
    if (!validators || !validators.length) {
        throw new Error(`No validators found for domain '${domain}'`);
    }
    // if (validators.length === 2) {
    //     throw new Error(`Consensus cannot be used for 2 validators`);
    // }
    return validators;
}

function areNonInclusionListsEqual(array1, array2) {
    if (array1.length !== array2.length) {
        return false;
    }
    const array1ValidatorDIDs = array1.map((x) => x.validatorDID);
    array1ValidatorDIDs.sort();

    const array2ValidatorDIDs = array2.map((x) => x.validatorDID);
    array2ValidatorDIDs.sort();

    return array1ValidatorDIDs.join(",") === array2ValidatorDIDs.join(",");
}

module.exports = {
    CONSENSUS_PHASES,
    getCachedBlocksFolderPath,
    getLocalLatestBlockInfo,
    getValidatedBlocksWriteStream,
    saveBlockInBricks,
    savePBlockInBricks,
    appendValidatedBlockHash,
    loadValidatorsFromBdns,
    areNonInclusionListsEqual,
};

},{"../utils/bdns-utils":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/bricksledger/src/utils/bdns-utils.js","../utils/fs-utils":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/bricksledger/src/utils/fs-utils.js","fs":false,"opendsu":"opendsu","os":false,"path":false}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/bricksledger/src/ExecutionEngine/index.js":[function(require,module,exports){
const Logger = require("../Logger");
const {
    getContractMethodExecutionPromise,
    getContractConfigs,
    loadContract,
    setContractMixin,
    validateCommand,
    validateNoncedCommandExecution,
} = require("./utils");

const MAX_ALLOWED_NONCED_BLOCK_NUMBER_DIFF = 1;

class ExecutionEngine {
    constructor(domain, domainConfig, rootFolder, storageFolder, createFSKeyValueStorage, commandHistoryStorage) {
        this.domain = domain;
        this.domainConfig = domainConfig;
        this.rootFolder = rootFolder;
        this.storageFolder = storageFolder;
        this.createFSKeyValueStorage = createFSKeyValueStorage;
        this.commandHistoryStorage = commandHistoryStorage;

        this._logger = new Logger(`[Bricksledger][${this.domain}][ExecutionEngine]`);
        this._logger.info("Create finished");
    }

    async loadContracts(pBlocksFactory) {
        const constitution = this.domainConfig && this.domainConfig.contracts ? this.domainConfig.contracts.constitution : null;
        if (!constitution) {
            throw new Error("Missing constitution");
        }

        this._logger.info("Loading contracts...");

        const openDSU = require("opendsu");
        const resolver = openDSU.loadApi("resolver");

        this._logger.debug(`Loading DSU ${constitution}...`);
        const loadRawDossier = $$.promisify(resolver.loadDSU);
        const rawDossier = await loadRawDossier(constitution);

        this._logger.debug("Loading contract configs...");
        const contractConfigs = await getContractConfigs(rawDossier);

        const contractNames = [];
        this.contracts = {};

        for (let i = 0; i < contractConfigs.length; i++) {
            const contractConfig = contractConfigs[i];
            contractNames.push(contractConfig.name);

            this._logger.debug(`Loading contract '${contractConfig.name}'...`);
            const contract = await loadContract(rawDossier, contractConfig);
            this.contracts[contractConfig.name] = contract;
        }

        this.contractDescribeMethods = {};
        contractNames.forEach((contractName) => {
            const contract = this.contracts[contractName];
            this.contractDescribeMethods[contractName] = contract.describeMethods ? contract.describeMethods() : null;
        });

        // setup contract mixin and initialization
        for (let i = 0; i < contractNames.length; i++) {
            const contractName = contractNames[i];
            const contract = this.contracts[contractName];
            setContractMixin(this, contractName, contract, pBlocksFactory);

            // run initialization step if the init function is defined
            if (typeof contract.init === "function") {
                this._logger.debug(`Initializing contract '${contractName}'...`);
                // need to bind context to contract
                await $$.promisify(contract.init.bind(contract))();
            }
        }

        this._logger.info("Loading contracts finished");
    }

    async validateSafeCommand(command) {
        if (this.domain !== command.domain) {
            throw new Error(`Invalid domain '${command.domain}' specified`);
        }
        await validateCommand(command, this.contracts, this.contractDescribeMethods, this.commandHistoryStorage);
    }

    async validateNoncedCommand(command, currentBlockNumber) {
        if (this.domain !== command.domain) {
            throw new Error(`Invalid domain '${command.domain}' specified`);
        }

        await validateCommand(command, this.contracts, this.contractDescribeMethods, this.commandHistoryStorage);

        this._logger.debug(`[nonced-command-${command.getHash()}] validating nonced command execution...`);
        await validateNoncedCommandExecution(command, this.commandHistoryStorage);

        const { blockNumber } = command;
        const isValidBlockNumber =
            blockNumber === currentBlockNumber ||
            (currentBlockNumber > blockNumber && currentBlockNumber - blockNumber <= MAX_ALLOWED_NONCED_BLOCK_NUMBER_DIFF);
        if (!isValidBlockNumber) {
            throw new Error(`Provided blockNumber ${blockNumber} is much older than the current block ${currentBlockNumber}`);
        }
    }

    describeMethodsForContract(contractName) {
        return this.contractDescribeMethods[contractName];
    }

    executeMethodOptimistically(command) {
        const { contractName } = command;

        const keyValueStorage = this.createFSKeyValueStorage(contractName);
        const contractMethodExecutionPromise = getContractMethodExecutionPromise(
            command,
            this.contracts,
            keyValueStorage,
            this.commandHistoryStorage
        );

        const executionResult = {
            requireConsensus: () => contractMethodExecutionPromise.then(() => keyValueStorage.requireConsensus()),
            getOptimisticExecutionResult: () => contractMethodExecutionPromise,
        };

        return executionResult;
    }

    async executePBlock(pBlock) {
        this._logger.debug(`Executing pBlock '${pBlock.hashLinkSSI}'...`);
        try {
            const { commands } = pBlock;
            for (let i = 0; i < commands.length; i++) {
                const command = commands[i];
                const { contractName } = command;

                const keyValueStorage = this.createFSKeyValueStorage(contractName);
                await getContractMethodExecutionPromise(
                    command,
                    this.contracts,
                    keyValueStorage,
                    this.commandHistoryStorage,
                    true
                );
            }
        } catch (error) {
            throw error;
        }
    }
}

function create(...args) {
    return new ExecutionEngine(...args);
}

module.exports = {
    create,
};

},{"../Logger":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/bricksledger/src/Logger.js","./utils":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/bricksledger/src/ExecutionEngine/utils.js","opendsu":"opendsu"}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/bricksledger/src/ExecutionEngine/utils.js":[function(require,module,exports){
async function validateNoncedCommandExecution(command, commandHistoryStorage, isValidatedMode) {
    // check if this nonced command has already been executed
    const commandHash = command.getHash();
    const isCommandRegistered = isValidatedMode
        ? await commandHistoryStorage.isOptimisticCommandHashRegistered(commandHash)
        : await commandHistoryStorage.isValidatedCommandHashRegistered(commandHash);
    if (isCommandRegistered) {
        throw new Error(`Command ${commandHash} hash already been executed`);
    }
}

async function markNoncedCommandAsExecuted(command, commandHistoryStorage, isValidatedMode) {
    if (isValidatedMode) {
        await commandHistoryStorage.addOptimisticComand(command);
    } else {
        await commandHistoryStorage.addValidatedComand(command);
    }
}

function getContractMethodExecutionPromise(command, contracts, keyValueStorage, commandHistoryStorage, isValidatedMode) {
    const { contractName, methodName, params } = command;
    const contract = contracts[contractName];

    const contractMethodExecutionPromise = new Promise(async (resolve, reject) => {
        const callback = $$.makeSaneCallback((error, result) => {
            if (error) {
                return reject(error);
            }
            resolve(result);
        });

        try {
            // initialize keyValueStorage
            await keyValueStorage.init();

            if (isValidatedMode) {
                keyValueStorage.enterValidatedMode(command.getHash());
            } else {
                keyValueStorage.enterOptimisticMode(command.getHash());
            }

            if (command.type === "nonced") {
                await validateNoncedCommandExecution(command, commandHistoryStorage, isValidatedMode);
                await markNoncedCommandAsExecuted(command, commandHistoryStorage, isValidatedMode);
            }

            // need to bind context to contract, in order to ensure that keyValueStorage is only used for this command
            // in order to properly detect if consensus is needed,
            // so we "extend" the contract and attach the keyValueStorage
            const context = { ...contract };
            const contractPrototype = Object.getPrototypeOf(contract);
            const classMethodNames = Object.getOwnPropertyNames(contractPrototype).filter(
                (methodName) => methodName && methodName !== "constructor" && typeof contractPrototype[methodName] === "function"
            );
            classMethodNames.forEach((methodName) => {
                context[methodName] = contract[methodName];
            });

            context.keyValueStorage = keyValueStorage;

            contract[methodName].call(context, ...(params || []), callback);
        } catch (error) {
            callback(error);
        }
    });
    return contractMethodExecutionPromise;
}

async function getContractConfigs(rawDossier) {
    const listFiles = $$.promisify(rawDossier.listFiles);
    const contractsFolderPath = "/";
    const contractFiles = await listFiles(contractsFolderPath);

    const contractConfigs = contractFiles
        .filter((file) => file)
        .map((file) => file.split("/"))
        .filter((fileParts) => fileParts.length === 2 && fileParts[1].endsWith(".js"))
        .map((fileParts) => {
            return {
                name: fileParts[0],
                filePath: [contractsFolderPath, ...fileParts].join("/"),
            };
        });
    return contractConfigs;
}

async function loadContract(rawDossier, contractConfig) {
    let contract;
    const { name: contractName, filePath: contractFilePath } = contractConfig;
    const readFile = $$.promisify(rawDossier.readFile);
    var fileContent = await readFile(contractFilePath);

    try {
        const ContractClass = eval(`(${fileContent.toString()})`);
        contract = new ContractClass();

        // disabling the automatic context set in order for keyValueStorage consensus detection to work correctly
        // // ensure that all contract methods (invarious of how there are called) have "this" bound to the contract instance
        // const classMethodNames = Object.getOwnPropertyNames(ContractClass.prototype).filter(
        //     (methodName) =>
        //         methodName &&
        //         methodName[0] !== "_" &&
        //         methodName !== "constructor" &&
        //         typeof ContractClass.prototype[methodName] === "function"
        // );
        // classMethodNames.forEach((methodName) => {
        //     contract[methodName] = contract[methodName].bind(contract);
        // });

        return contract;
    } catch (e) {
        console.log("Failed to eval file", contractName, e);
        throw e;
    }
}

function setContractMixin(executionEngine, contractName, contract, consensusCore) {
    const contractNames = Object.keys(executionEngine.contracts)
        .filter((contractName) => !["test"].includes(contractName))
        .sort();

    const contractsMetadata = contractNames.map((contractName) => {
        const contract = executionEngine.contracts[contractName];
        const contractPrototype = Object.getPrototypeOf(contract);

        const contractMethodNames = Object.getOwnPropertyNames(contractPrototype).filter(
            (methodName) =>
                methodName &&
                methodName[0] !== "_" &&
                methodName !== "constructor" &&
                typeof contractPrototype[methodName] === "function"
        );

        return {
            name: contractName,
            methods: contractMethodNames,
        };
    });

    const getContractProxy = (contractName) => {
        // each contract can call only the "safe" methods from other contracts

        const describeMethodsForContract = executionEngine.describeMethodsForContract(contractName);
        const safeMethodNames = describeMethodsForContract ? describeMethodsForContract.safe : null;
        if (!safeMethodNames || !safeMethodNames.length) {
            // the desired contract doesn't have "safe" methods described
            // so no methods can be called
            return {};
        }

        const contract = executionEngine.contracts[contractName];
        const contractProxy = {};
        safeMethodNames.forEach((methodName) => {
            contractProxy[methodName] = contract[methodName].bind(contract);
        });

        return contractProxy;
    };

    contract.name = contractName;
    contract.domain = executionEngine.domain;
    contract.config = executionEngine.domainConfig;
    contract.rootFolder = executionEngine.rootFolder;
    contract.storageFolder = executionEngine.storageFolder;
    contract.getContractNames = () => contractNames;
    contract.getContractsMetadata = () => contractsMetadata;
    contract.getContract = (contractName) => getContractProxy(contractName);

    // used for consensus when a validator is trying to get proposed pBlock from a given validator
    contract.getPBlockProposedForConsensus = consensusCore.getPBlockProposedForConsensus;
}

async function validateCommand(command, contracts, contractDescribeMethods, commandHistoryStorage) {
    const { contractName, methodName, params, type, blockNumber, timestamp, signerDID: signerDIDIdentifier } = command;

    if (!contractName || typeof contractName !== "string" || !contracts[contractName]) {
        throw `Unspecified or unkwnown contract '${contractName}'`;
    }

    const contract = contracts[contractName];

    if (!methodName || typeof methodName !== "string" || !contract[methodName]) {
        throw `Unspecified or unkwnown contract method '${methodName}' for contract '${contractName}'`;
    }

    if (params && !Array.isArray(params)) {
        throw `Unsupported params specified for method '${methodName}' for contract '${contractName}'`;
    }

    const contractMethodsInfo = contractDescribeMethods[contractName];
    if (!contractMethodsInfo) {
        throw `Missing describeMethods for contract '${contractName}'`;
    }

    if (type === "safe") {
        // check if current command is allowed to be called with executeSafeCommand
        const isSafeCallAllowedForMethod = contractMethodsInfo.safe && contractMethodsInfo.safe.includes(methodName);
        if (!isSafeCallAllowedForMethod) {
            throw `Method '${methodName}' for contract '${contractName}' cannot be called with executeSafeCommand`;
        }

        // safe command are called without nounce or signature
        return;
    }

    if (type === "nonced") {
        // check if current command is allowed to be called with executeNoncedCommand
        const isNoncedCallAllowedForMethod = contractMethodsInfo.nonced && contractMethodsInfo.nonced.includes(methodName);
        if (!isNoncedCallAllowedForMethod) {
            throw `Method '${methodName}' for contract '${contractName}' cannot be called with executeNoncedCommand`;
        }

        // for nonced methods we need to validate the timestamp and signature in order to run it
        if (blockNumber == null || !timestamp || !signerDIDIdentifier || typeof signerDIDIdentifier !== "string") {
            throw `Missing inputs required for signature validation`;
        }

        await command.validateSignature();

        // all validations for nonced command passed
        return;
    }

    throw `Unknown command type '${type}' specified`;
}

module.exports = {
    getContractMethodExecutionPromise,
    getContractConfigs,
    loadContract,
    setContractMixin,
    validateCommand,
    validateNoncedCommandExecution,
};

},{}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/bricksledger/src/FSBrickStorage/index.js":[function(require,module,exports){
class FSBrickPathsManager {
    constructor() {
        this.brickPaths = {};
        this.utils = require("./utils");
    }

    storeDomainPath(domainName, domainFolder, serverRoot) {
        if (!this.brickPaths[domainName]) {
            this.brickPaths[domainName] = require("path").join(serverRoot || "", domainFolder || domainName);
        }
    }

    removeDomainPath(domainName) {
        delete this.brickPaths[domainName];
    }

    resolveBrickPath(domainName, brickHash) {
        return require("path").join(this.resolveBrickDirname(domainName, brickHash), brickHash);
    }

    resolveBrickDirname(domainName, brickHash) {
        this.utils.verifyBrickHash(brickHash);
        return require("path").join(this.brickPaths[domainName], brickHash.substr(0, this.utils.HASH_MAX_SIZE));
    }

    getUtils() {
        return this.utils;
    }
}

const fsBrickPathsManager = new FSBrickPathsManager();

class FSBrickStorage {
    constructor(domainName, domainFolder, serverRoot) {
        this.domain = domainName;

        fsBrickPathsManager.storeDomainPath(this.domain, domainFolder, serverRoot);
    }

    getBrick(hash, callback) {
        callback = $$.makeSaneCallback(callback);

        this.getBrickAsync(hash)
            .then(result => callback(undefined, result))
            .catch(error => callback(error));
    }

    async getBrickAsync(hash) {
        const fs = require("fs");
        const brickPath = fsBrickPathsManager.resolveBrickPath(this.domain, hash);
        await $$.promisify(fs.access)(brickPath);
        return await $$.promisify(fs.readFile)(brickPath);
    }

    addBrick(data, callback) {
        callback = $$.makeSaneCallback(callback);

        this.addBrickAsync(data)
            .then(result => callback(undefined, result))
            .catch(error => callback(error));
    }

    async addBrickAsync(data) {
        const fs = require("fs");
        const crypto = require("opendsu").loadAPI("crypto");
        const hash = crypto.sha256(data);

        // TODO: use workers from OpenDSU apiSpace
        // const pool = workers.createPool() or (pool probably should be at FSBrickStorage ctor level)
        // await $$.promisify(pool.runSyncFunction)("crypto", "sha256", data);

        const brickDirPath = fsBrickPathsManager.resolveBrickDirname(this.domain, hash);
        await $$.promisify(fs.mkdir)(brickDirPath, { recursive: true });
        await $$.promisify(fs.access)(brickDirPath);

        const brickPath = fsBrickPathsManager.resolveBrickPath(this.domain, hash);
        await $$.promisify(fs.writeFile)(brickPath, data);

        return hash;
    }

    deleteBrick(hash, callback) {
        callback = $$.makeSaneCallback(callback);

        this.deleteBrickAsync(hash)
            .then(result => callback(undefined, result))
            .catch(error => callback(error));
    }

    async deleteBrickAsync(hash) {
        const fs = require("fs");
        const removeDir = require("swarmutils").removeDir;
        const brickPath = fsBrickPathsManager.resolveBrickPath(this.domain, hash);
        await $$.promisify(fs.access)(brickPath);
        await $$.promisify(fs.unlink)(brickPath);

        const brickDirPath = fsBrickPathsManager.resolveBrickDirname(this.domain, hash);
        await $$.promisify(fs.access)(brickDirPath);
        await $$.promisify(removeDir)(brickDirPath, { recursive: true });
    }

    get utils() {
        return ({ ...fsBrickPathsManager.getUtils() })
    }
}

function create(...params) {
    return new FSBrickStorage(...params);
}

module.exports = {
    create
};
},{"./utils":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/bricksledger/src/FSBrickStorage/utils.js","fs":false,"opendsu":"opendsu","path":false,"swarmutils":"swarmutils"}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/bricksledger/src/FSBrickStorage/utils.js":[function(require,module,exports){
/** @deprecated */
process.env.FOLDER_NAME_SIZE;

const HASH_MAX_SIZE = process.env.FOLDER_NAME_SIZE || 5;

function verifyBrickHash(brickHash) {
    if (!brickHash || typeof brickHash !== 'string') {
        throw Error('[Bricking] No hash specified');
    }

    if (brickHash.length < HASH_MAX_SIZE) {
        throw Error(`[Bricking] Hash "${brickHash}" is too small`);
    }
}

module.exports = {
    HASH_MAX_SIZE,
    verifyBrickHash
}
},{}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/bricksledger/src/FSKeyValueStorage/StorageValue.js":[function(require,module,exports){
class StorageValue {
    constructor(stringValue) {
        this.value = stringValue
            ? JSON.parse(stringValue)
            : {
                  validated: null,
                  pending: [],
              };
    }

    updateValidated(commandHash, validatedValue) {
        this.value.validated = validatedValue;
        const pendingCommandIndex = this.value.pending.findIndex((command) => command.commandHash === commandHash);
        if (pendingCommandIndex !== -1) {
            this.value.pending.splice(pendingCommandIndex, 1);
        }
        // log inconsistencies
    }

    addPending(commandHash, newValue) {
        this.value.pending.push({ commandHash, newValue });
    }

    asString() {
        return JSON.stringify(this.value);
    }

    /*
        if latest is false, return the validate value, otherwise get the latest
    */
    getValue(latest) {
        if (!latest) {
            return this.value.validated;
        }

        const { pending } = this.value;
        if (!pending.length) {
            // if there are no latest values so return the validated one
            return this.value.validated;
        }

        const latestValue = pending[pending.length - 1].newValue;
        return latestValue;
    }
}

module.exports = StorageValue;

},{}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/bricksledger/src/FSKeyValueStorage/index.js":[function(require,module,exports){
const StorageValue = require("./StorageValue");

class FSKeyValueStorage {
    constructor(domain, storageFolder, subFolderName) {
        this.domain = domain;
        this.storageFolder = storageFolder;

        this.basePath = require("path").join(storageFolder, "domain-storage", domain, subFolderName);
        this.isOptimisticMode = true;
        this.commandHash = null;
    }

    async init() {
        try {
            await this._ensureBasePathExists();
        } catch (error) {
            console.log(error);
        }
    }

    enterOptimisticMode(commandHash) {
        this.isOptimisticMode = true;
        this.commandHash = commandHash;
    }

    enterValidatedMode(commandHash) {
        this.isOptimisticMode = false;
        this.commandHash = commandHash;
    }

    async set(key, newValueObject) {
        // since the set is called then changes are made, so consensus is required
        if (this.isOptimisticMode) {
            console.log("[FSKeyValueStorage] Detected changes during optimistic run");
            this.commandRequiresConsensus = true;
        }

        const keyFilePath = this._getKeyPath(key);
        const storageValue = await this._getStorageValue(key);

        if (this.isOptimisticMode) {
            storageValue.addPending(this.commandHash, newValueObject);
        } else {
            storageValue.updateValidated(this.commandHash, newValueObject);
        }

        await $$.promisify(require("fs").writeFile)(keyFilePath, storageValue.asString());
    }

    async get(key) {
        const storageValue = await this._getStorageValue(key);
        return storageValue.getValue(true);
    }

    async getValidated(key) {
        const storageValue = await this._getStorageValue(key);
        return storageValue.getValue(false);
    }

    requireConsensus() {
        return this.commandRequiresConsensus;
    }

    _getKeyPath(key) {
        return `${this.basePath}/${key}`;
    }

    async _getStorageValue(key) {
        const keyFilePath = this._getKeyPath(key);
        try {
            const keyContent = await $$.promisify(require("fs").readFile)(keyFilePath);
            const value = new StorageValue(keyContent);
            return value;
        } catch (error) {
            if (error.code === "ENOENT") {
                // file doesn't exists, so we consider thee value to be null
                const value = new StorageValue();
                return value;
            }

            throw err;
        }
    }

    async _ensureBasePathExists() {
        const fs = require("fs");
        try {
            await $$.promisify(fs.access)(this.basePath);
        } catch (error) {
            // base folder doesn't exists, so we create it
            await $$.promisify(fs.mkdir)(this.basePath, { recursive: true });
        }
    }
}

function create(domain, storageFolder, subFolderName) {
    return new FSKeyValueStorage(domain, storageFolder, subFolderName);
}

module.exports = {
    create,
};

},{"./StorageValue":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/bricksledger/src/FSKeyValueStorage/StorageValue.js","fs":false,"path":false}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/bricksledger/src/Logger.js":[function(require,module,exports){
const ENABLE_DEBUG = false;

class Logger {
    constructor(prefix) {
        this.prefix = prefix || "";
    }

    debug(...args) {
        if (ENABLE_DEBUG) {
            console.log(`${this.prefix}[DEBUG]`, ...args);
        }
    }

    info(...args) {
        console.log(`${this.prefix}[INFO]`, ...args);
    }

    warn(...args) {
        console.log(`${this.prefix}[WARN]`, ...args);
    }

    error(...args) {
        console.log(`${this.prefix}[ERROR]`, ...args);
    }

    trace(...args) {
        console.trace(`${this.prefix}[ERROR]`, ...args);
    }
}

module.exports = Logger;

},{}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/bricksledger/src/Notifier.js":[function(require,module,exports){
const Logger = require("./Logger");

class Notifier {
    constructor(domain, validatorDID) {
        this.domain = domain;
        this.validatorDID = validatorDID;

        this._logger = new Logger(`[Bricksledger][${this.domain}][${this.validatorDID.getIdentifier()}][Notifier]`);
        this._logger.info("Create finished");
    }

    notifyNewBlock(blockInfo) {
        const openDSU = require("opendsu");
        const notificationsApi = openDSU.loadApi("notifications");

        const validatorSSI = {
            getDLDomain: () => this.domain,
            getAnchorId: () => this.validatorDID.getIdentifier(),
        };

        const message = {
            type: "newBlock",
            payload: blockInfo,
        };

        this._logger.debug(`Publishing new block notification: ${JSON.stringify(message)}...`);
        notificationsApi.publish(validatorSSI, message, (error, response) => {
            if (error) {
                return this._logger.error(`Failed to publish new block notification`, error);
            }
            this._logger.debug(`Received new block notification response`, response);
        });
    }
}

function create(...params) {
    return new Notifier(...params);
}

module.exports = {
    create,
};

},{"./Logger":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/bricksledger/src/Logger.js","opendsu":"opendsu"}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/bricksledger/src/PBlock.js":[function(require,module,exports){
(function (Buffer){(function (){
const Command = require("./Command");

class PBlock {
    constructor(pBlock, onConsensusFinished) {
        if (!pBlock) {
            throw "pBlock must be specified";
        }

        const { validatorDID, commands, previousBlockHash, blockNumber, hash, validatorSignature, hashLinkSSI } = pBlock;

        this.validatorDID = validatorDID;
        this.commands = commands;
        this.previousBlockHash = previousBlockHash;
        this.blockNumber = blockNumber;
        this.hash = hash;

        if (validatorSignature && !Buffer.isBuffer(validatorSignature)) {
            this.validatorSignature = Buffer.from(validatorSignature, 'hex');
        } else {
            this.validatorSignature = validatorSignature;
        }
        this.hashLinkSSI = hashLinkSSI;
        this.onConsensusFinished = onConsensusFinished;
        this.isEmpty = !commands || !commands.length;
        this.signer = null;
    }

    async sign(validatorDID) {
        if (!validatorDID && !this.signer) {
            throw new Error('ValidatorDID is required for signing');
        }
        validatorDID = (validatorDID) ? validatorDID : this.signer;
        this.hash = this.computeHash();
        this.validatorSignature = await $$.promisify(validatorDID.sign)(this.hash);
    }
    
    setSigner(validatorDID) {
        this.signer = validatorDID;
    }

    computeHash() {
        const { previousBlockHash, blockNumber } = this;
        const commands = this.getCommandsForSerialisation();

        const objectToHash = {
            commands,
            previousBlockHash,
            blockNumber,
        };

        const crypto = require("opendsu").loadApi("crypto");
        const hash = crypto.sha256(objectToHash);

        return hash;
    }

    async validateSignature() {
        const { validatorDID: validatorDIDIdentifier, validatorSignature } = this;

        const hash = this.computeHash();

        const w3cDID = require("opendsu").loadApi("w3cdid");
        const validatorDID = await $$.promisify(w3cDID.resolveDID)(validatorDIDIdentifier);
        const isValidSignature = await $$.promisify(validatorDID.verify)(hash, validatorSignature);

        if (!isValidSignature) {
            throw "Invalid signature specified for PBlock";
        }
    }

    getSerialisation() {
        const { validatorDID, previousBlockHash, blockNumber, hash, validatorSignature, hashLinkSSI } = this;
        const commands = this.getCommandsForSerialisation();
        const pBlock = {
            validatorDID,
            commands,
            previousBlockHash,
            blockNumber,
            hash,
            validatorSignature: (validatorSignature) ? validatorSignature.toString('hex') : validatorSignature,
            hashLinkSSI
        };
        return JSON.stringify(pBlock);
    }

    getCommandsForSerialisation() {
        let commands = this.commands;
        if (commands) {
            commands = commands.map((command) => (command instanceof Command ? command.getForSerialisation() : command));
        }
        return commands;
    }
}

module.exports = PBlock;

}).call(this)}).call(this,require("buffer").Buffer)

},{"./Command":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/bricksledger/src/Command.js","buffer":false,"opendsu":"opendsu"}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/bricksledger/src/PBlocksFactory.js":[function(require,module,exports){
const Logger = require("./Logger");
const PBlock = require("./PBlock");

async function savePBlockInBricks(pBlock, domain, brickStorage) {
    const openDSU = require("opendsu");
    const keySSISpace = openDSU.loadApi("keyssi");
    
    const pBlockBrickHash = await brickStorage.addBrickAsync(pBlock.getSerialisation());

    const hashLinkSSI = keySSISpace.createHashLinkSSI(domain, pBlockBrickHash);
    return hashLinkSSI.getIdentifier();
}

function createPBlock(validatorDID, commands, previousBlockHash, blockNumber) {
    const pBlockInfo = {
        validatorDID: validatorDID.getIdentifier(),
        commands,
        previousBlockHash,
        blockNumber,
    };
    const pBlock = new PBlock(pBlockInfo);
    pBlock.setSigner(validatorDID);
    return pBlock;
}

class PBlocksFactory {
    constructor(domain, validatorDID, brickStorage, consensusCore, broadcaster, maxPBlockSize, maxPBlockTimeMs) {
        this.domain = domain;
        this.validatorDID = validatorDID;
        this.brickStorage = brickStorage;
        this.consensusCore = consensusCore;
        this.broadcaster = broadcaster;

        this.pendingCommands = [];

        if (!maxPBlockSize) {
            maxPBlockSize = 100;
        }
        this.maxPBlockSize = maxPBlockSize;

        if (!maxPBlockTimeMs) {
            maxPBlockTimeMs = 1000 * 60; // 1 minute
        }
        this.maxPBlockTimeMs = maxPBlockTimeMs;

        this._latestPBlock = null;
        this._forceRequestedBlockNumbers = {};

        this._logger = new Logger(`[Bricksledger][${this.domain}][${this.validatorDID.getIdentifier()}][PBlocksFactory]`);
        this._logger.info("Create finished");

        this._startBlockTimeCheckTimeout();
    }

    addCommandForConsensus(pBlock, callback) {
        callback = $$.makeSaneCallback(callback);

        this.addCommandForConsensusAsync(pBlock)
            .then((result) => callback(undefined, result))
            .catch((error) => callback(error));
    }

    async addCommandForConsensusAsync(command) {
        this._logger.info(`Adding command for consensus with hash ${command.getHash()}...`);

        if (this._commandProcessing) {
            await this._commandProcessing;
        }

        this._commandProcessing = new Promise((resolve) => {
            try {
                this.pendingCommands.push(command);
                this._constructPBlockIfBlockSizeRestrictionReached();
            } catch (error) {
                this._logger.error(`Failed to add command with hash ${command.getHash()}`, error);
            }

            resolve(); // mark processing finished
        });
    }

    forcePBlockCreationForBlockNumberIfAbsent(blockNumber, callback) {
        callback = $$.makeSaneCallback(callback);

        this.forcePBlockCreationForBlockNumberIfAbsentAsync(blockNumber)
            .then((result) => callback(undefined, result))
            .catch((error) => callback(error));
    }

    async forcePBlockCreationForBlockNumberIfAbsentAsync(blockNumber) {
        this._logger.info(`Trying to force PBlock creation for block number ${blockNumber}...`);

        if (this._commandProcessing) {
            await this._commandProcessing;
        }

        this._commandProcessing = new Promise(async (resolve) => {
            try {
                const latestVerifiedBlockInfo = this.consensusCore.getLatestBlockInfo();
                const latestVerifiedBlockNumber = latestVerifiedBlockInfo.number;
                if (blockNumber <= latestVerifiedBlockNumber) {
                    this._logger.warn(
                        `Wanting to force pBlock creation for block number ${blockNumber} but latest confirmed consensus is already at block number ${latestVerifiedBlockNumber}`
                    );
                    return resolve();
                }

                let canForceCreateBlockNow = false;

                if (this._latestPBlock) {
                    this._logger.debug(`Found existing _latestPBlock`);
                    const currentBlockNumber = this._latestPBlock.blockNumber;
                    if (blockNumber < currentBlockNumber) {
                        this._logger.warn(
                            `Wanting to force pBlock creation for block number ${blockNumber} but consensus is already at block number ${currentBlockNumber}`
                        );
                        return resolve();
                    }

                    if (blockNumber === currentBlockNumber) {
                        this._logger.debug(
                            `Latest pBlock is already destinated for block number ${blockNumber}, so skipping force creation...`
                        );
                        return resolve();
                    }

                    const isConsensusStillRunningForCurrentBlockNumber = latestVerifiedBlockNumber === currentBlockNumber - 1;
                    if (isConsensusStillRunningForCurrentBlockNumber) {
                        if (this.consensusCore.isConsensusRunningForBlockNumber(currentBlockNumber)) {
                            this._forceRequestedBlockNumbers[blockNumber] = true;
                            this._logger.info(
                                `Latest pBlock (block number ${currentBlockNumber}) is currently awaiting consensus finalization, so keep force request for block number ${blockNumber}`
                            );
                        } else {
                            this._logger.warn(
                                `Latest pBlock (block number ${currentBlockNumber}) is in consensus status finalized, but not removed from pBlocksFactory, so removing it`
                            );
                            this._latestPBlock = null;
                            canForceCreateBlockNow = true;
                        }
                    } else {
                        const isPBlocksFactoryGoingToBeNotifiedOfCurrentConsensusEnd =
                            latestVerifiedBlockNumber === this._latestPBlock.blockNumber &&
                            !this.consensusCore.isConsensusRunningForBlockNumber(latestVerifiedBlockNumber + 1);
                        if (isPBlocksFactoryGoingToBeNotifiedOfCurrentConsensusEnd) {
                            this._forceRequestedBlockNumbers[blockNumber] = true;
                            this._logger.info(
                                `PBlocksFactory is waiting to be notified when processing for current pBlock is finished (since the next block is not yet started)...`
                            );
                            return resolve();
                        }

                        canForceCreateBlockNow = true;
                        if (currentBlockNumber <= latestVerifiedBlockNumber) {
                            this._logger.warn(
                                `Latest pBlock (block number ${currentBlockNumber}) is older than latest verified block number of ${latestVerifiedBlockNumber}, but not removed from pBlocksFactory, so removing it`
                            );
                            this._latestPBlock = null;
                        }
                    }
                } else {
                    this._logger.debug(`Didn't find existing _latestPBlock`);
                    if (latestVerifiedBlockNumber == blockNumber - 1) {
                        this._logger.debug(
                            `Wanting to force pBlock creation for block number ${blockNumber} and latest confirmed block is the previous one, so continuing`
                        );
                        canForceCreateBlockNow = true;
                    } else {
                        this._logger.debug(
                            `Wanting to force pBlock creation for block number ${blockNumber}, but latest confirmed block is at block number ${latestVerifiedBlockNumber}, so skipping it`
                        );
                    }
                }

                if (canForceCreateBlockNow) {
                    // restart timeout check
                    this._startBlockTimeCheckTimeout();

                    let pBlock = this._forceBuildPBlockFromAllCommands();
                    if (pBlock) {
                        this._logger.debug(`Created pBlock for block number ${blockNumber}`, pBlock);
                    } else {
                        this._logger.debug(`Created empty pBlock`);
                        pBlock = this._buildPBlock();
                    }

                    this._sendPBlockForConsensus(pBlock);
                }
            } catch (error) {
                this._logger.error(`Failed to force pBlock creation for block number ${blockNumber}`, error);
            }

            resolve(); // mark processing finished
        });
    }

    _startBlockTimeCheckTimeout() {
        this._clearBlockTimeCheckTimeout();

        this._blockTimeCheckTimeout = setTimeout(async () => {
            this._logger.info(`Reached block time restriction of ${this.maxPBlockTimeMs}ms`);

            if (this._commandProcessing) {
                await this._commandProcessing;
            }

            this._clearBlockTimeCheckTimeout();

            this._commandProcessing = new Promise(async (resolve) => {
                try {
                    // if we have commands then contruct the pBlock because of the block time restriction has been reached
                    if (this.pendingCommands.length !== 0) {
                        const pBlock = this._buildPBlockForMaxBlockSize();
                        if (pBlock) {
                            this._sendPBlockForConsensus(pBlock);
                        }
                    }
                } catch (error) {
                    this._logger.error('Failed to build pblock', error);
                }

                resolve(); // mark processing finished

                // start another timeout check
                this._startBlockTimeCheckTimeout();
            });
        }, this.maxPBlockTimeMs);
    }

    _forceBuildPBlockFromAllCommands() {
        if (!this.consensusCore.isRunning()) {
            throw new Error("Cannot build PBlock due to consensus not running");
        }

        const commands = this.pendingCommands.splice(0, this.pendingCommands.length);
        return this._buildPBlock(commands);
    }

    _buildPBlockForMaxBlockSize() {
        if (!this.consensusCore.isRunning()) {
            throw new Error("Cannot build PBlock due to consensus not running");
        }

        if (this._latestPBlock) {
            const latestVerifiedBlockInfo = this.consensusCore.getLatestBlockInfo();
            const currentConsensusBlockNumber = latestVerifiedBlockInfo.number + 1;

            if (this._latestPBlock.blockNumber === currentConsensusBlockNumber) {
                // the previous block hasn't been confirmed yet,
                // so we must wait until it's finished before constructing the next one

                this._logger.info(
                    "Previous PBlock not yet accepted. Waiting for it to finished before creating another...",
                    this._latestPBlock
                );
                return;
            }

            this._logger.info(
                `Consensus is currently at block number ${currentConsensusBlockNumber} and the local current pBlock is at ${this._latestPBlock.blockNumber}`
            );

            const isPBlocksFactoryGoingToBeNotifiedOfCurrentConsensusEnd =
                currentConsensusBlockNumber === this._latestPBlock.blockNumber + 1 &&
                !this.consensusCore.isConsensusRunningForBlockNumber(currentConsensusBlockNumber + 1);
            if (isPBlocksFactoryGoingToBeNotifiedOfCurrentConsensusEnd) {
                this._logger.info(
                    `PBlocksFactory is waiting to be notified when processing for current pBlock is finished (since the next block is not yet started)...`
                );
                return;
            }

            // somehow the consensus for the latestPBlock has already finished, but PBlocksFactory wasn't notified
            this._logger.warn(
                `Consensus is currently at block number ${currentConsensusBlockNumber} and the local current pBlock is at ${this._latestPBlock.blockNumber}`
            );
            this._logger.warn(`Removing _latestPBlock in order to continue consensus`, this._latestPBlock);
            this._latestPBlock = null;
        }

        const commands = this.pendingCommands.splice(0, this.maxPBlockSize);
        return this._buildPBlockFromCommands(commands);
    }

    _buildPBlockFromCommands(commands) {
        if (!commands.length) {
            throw new Error("Cannot create pBlock with no commands");
        }
        return this._buildPBlock(commands);
    }

    _buildPBlock(commands = []) {
        const latestVerifiedBlockInfo = this.consensusCore.getLatestBlockInfo();
        const blockNumber = latestVerifiedBlockInfo.number !== -1 ? latestVerifiedBlockInfo.number + 1 : 1;

        this._logger.info(`Constructing pBlock number ${blockNumber} having ${commands.length} command(s)...`);
        const pBlock = createPBlock(this.validatorDID, commands, latestVerifiedBlockInfo.hash, blockNumber);

        return pBlock;
    }

    async _sendPBlockForConsensus(pBlock) {
        this._logger.info(`Sending pBlock to consensus ${pBlock.hash}...`);
        this._latestPBlock = pBlock;

        try {
            await pBlock.sign();

            this._logger.info(`Saving pBlock number ${pBlock.blockNumber} in bricks...`);
            const pBlockHashLinkSSI = await savePBlockInBricks(pBlock, this.domain, this.brickStorage);
            pBlock.hashLinkSSI = pBlockHashLinkSSI;

            this.broadcaster.broadcastPBlockAdded(pBlock);

            try {
                await this.consensusCore.addInConsensusAsync(pBlock);
                this._logger.info(`Consensus finished for block number ${pBlock.blockNumber}`);
            } catch (error) {
                this._logger.error(`Consensus failed for block number ${pBlock.blockNumber}`, error);
            }

            this._latestPBlock = null;

            if (this._commandProcessing) {
                await this._commandProcessing;
            }

            const latestVerifiedBlockInfo = this.consensusCore.getLatestBlockInfo();
            const latestVerifiedBlockNumber = latestVerifiedBlockInfo.number;
            const isNextBlockAlreadyForceRequested = !!this._forceRequestedBlockNumbers[latestVerifiedBlockNumber + 1];
            if (isNextBlockAlreadyForceRequested) {
                const forceBlockNumber = latestVerifiedBlockNumber + 1;
                this._logger.info(`Block number ${forceBlockNumber} was force requested before, so trying to create it`);
                let pBlock = this._forceBuildPBlockFromAllCommands();
                if (pBlock) {
                    this._logger.debug(`Created pBlock for block number ${forceBlockNumber}`, pBlock);
                } else {
                    this._logger.debug(`Created empty pBlock for block number ${forceBlockNumber}`);
                    pBlock = this._buildPBlock();
                }

                this._sendPBlockForConsensus(pBlock);
                return;
            }

            const isPlockConstructed = this._constructPBlockIfBlockSizeRestrictionReached();
            if (!isPlockConstructed) {
                this._startBlockTimeCheckTimeout();
            }
        } catch (error) {
            this._logger.error("An error has occurred while running the consensus for pBlock", error);
        }
    }

    _constructPBlockIfBlockSizeRestrictionReached() {
        const isBlockSizeLimitReached = this.pendingCommands.length >= this.maxPBlockSize;
        if (isBlockSizeLimitReached) {
            this._logger.info(`Reached block size restriction of ${this.maxPBlockSize}`);
            const pBlock = this._buildPBlockForMaxBlockSize();
            if (pBlock) {
                this._sendPBlockForConsensus(pBlock);
                return true;
            }
        }

        return false;
    }

    _clearBlockTimeCheckTimeout() {
        if (this._blockTimeCheckTimeout) {
            clearTimeout(this._blockTimeCheckTimeout);
            this._blockTimeCheckTimeout = null;
        }
    }
}

function create(...params) {
    return new PBlocksFactory(...params);
}

module.exports = {
    create,
};

},{"./Logger":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/bricksledger/src/Logger.js","./PBlock":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/bricksledger/src/PBlock.js","opendsu":"opendsu"}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/bricksledger/src/utils/bdns-utils.js":[function(require,module,exports){
async function getValidatorsForCurrentDomain(executionEngine) {
    const { contracts } = executionEngine;
    const domainInfo = await $$.promisify(contracts.bdns.getDomainInfo.bind(contracts.bdns))();
    return domainInfo.validators;
}

module.exports = {
    getValidatorsForCurrentDomain,
};

},{}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/bricksledger/src/utils/fs-utils.js":[function(require,module,exports){
async function checkIfPathExists(path) {
    try {
        const fs = require("fs");
        await $$.promisify(fs.access)(path);
        return true;
    } catch (error) {
        return false;
    }
}

async function ensurePathExists(path) {
    const pathExists = await checkIfPathExists(path);
    if (!pathExists) {
        const fs = require("fs");
        await $$.promisify(fs.mkdir)(path, { recursive: true });
    }
}

module.exports = {
    checkIfPathExists,
    ensurePathExists,
};

},{"fs":false}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/bricksledger/src/utils/object-utils.js":[function(require,module,exports){
function clone(obj) {
    return JSON.parse(JSON.stringify(obj));
}

module.exports = {
    clone,
};

},{}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/callflow/constants.js":[function(require,module,exports){
$$.CONSTANTS = {
    SWARM_FOR_EXECUTION:"swarm_for_execution",//TODO: remove
    INBOUND:"inbound",//TODO: remove
    OUTBOUND:"outbound",//TODO: remove
    PDS:"PrivateDataSystem", //TODO: remove
    CRL:"CommunicationReplicationLayer", //TODO: remove
    SWARM_RETURN: 'swarm_return', //TODO: remove
    BEFORE_INTERCEPTOR: 'before',//TODO: document
    AFTER_INTERCEPTOR: 'after'//TODO: document
};


$$.CONSTANTS.mixIn = function(otherConstants){
    for(let v in otherConstants){
        if($$.CONSTANTS[v] && $$.CONSTANTS[v] !== otherConstants[v]){
            $$.warn("Overwriting CONSTANT "+ v + " previous value " + $$.CONSTANTS[v] + "new value " + otherConstants[v]);
        }
        $$.CONSTANTS[v] = otherConstants[v];
    }
}

},{}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/callflow/lib/InterceptorRegistry.js":[function(require,module,exports){
(function (global){(function (){
// related to: SwarmSpace.SwarmDescription.createPhase()

function InterceptorRegistry() {
    const rules = new Map();

     global._CLASS_NAME = 'InterceptorRegistry';

    /************* PRIVATE METHODS *************/

    function _throwError(err, msg) {
        console.error(err.message, `${_CLASS_NAME} error message:`, msg);
        throw err;
    }

    function _warning(msg) {
        console.warn(`${_CLASS_NAME} warning message:`, msg);
    }

    const getWhenOptions = (function () {
        let WHEN_OPTIONS;
        return function () {
            if (WHEN_OPTIONS === undefined) {
                WHEN_OPTIONS = Object.freeze([
                    $$.CONSTANTS.BEFORE_INTERCEPTOR,
                    $$.CONSTANTS.AFTER_INTERCEPTOR
                ]);
            }
            return WHEN_OPTIONS;
        };
    })();

    function verifyWhenOption(when) {
        if (!getWhenOptions().includes(when)) {
            _throwError(new RangeError(`Option '${when}' is wrong!`),
                `it should be one of: ${getWhenOptions()}`);
        }
    }

    function verifyIsFunctionType(fn) {
        if (typeof fn !== 'function') {
            _throwError(new TypeError(`Parameter '${fn}' is wrong!`),
                `it should be a function, not ${typeof fn}!`);
        }
    }

    function resolveNamespaceResolution(swarmTypeName) {
        if (swarmTypeName === '*') {
            return swarmTypeName;
        }

        return (swarmTypeName.includes(".") ? swarmTypeName : ($$.libraryPrefix + "." + swarmTypeName));
    }

    /**
     * Transforms an array into a generator with the particularity that done is set to true on the last element,
     * not after it finished iterating, this is helpful in optimizing some other functions
     * It is useful if you want call a recursive function over the array elements but without popping the first
     * element of the Array or sending the index as an extra parameter
     * @param {Array<*>} arr
     * @return {IterableIterator<*>}
     */
    function* createArrayGenerator(arr) {
        const len = arr.length;

        for (let i = 0; i < len - 1; ++i) {
            yield arr[i];
        }

        return arr[len - 1];
    }

    /**
     * Builds a tree like structure over time (if called on the same root node) where internal nodes are instances of
     * Map containing the name of the children nodes (each child name is the result of calling next on `keysGenerator)
     * and a reference to them and on leafs it contains an instance of Set where it adds the function given as parameter
     * (ex: for a keyGenerator that returns in this order ("key1", "key2") the resulting structure will be:
     * {"key1": {"key1": Set([fn])}} - using JSON just for illustration purposes because it's easier to represent)
     * @param {Map} rulesMap
     * @param {IterableIterator} keysGenerator - it has the particularity that done is set on last element, not after it
     * @param {function} fn
     */
    function registerRecursiveRule(rulesMap, keysGenerator, fn) {
        const {value, done} = keysGenerator.next();

        if (!done) { // internal node
            const nextKey = rulesMap.get(value);

            if (typeof nextKey === 'undefined') { // if value not found in rulesMap
                rulesMap.set(value, new Map());
            }

            registerRecursiveRule(rulesMap.get(value), keysGenerator, fn);
        } else { // reached leaf node
            if (!rulesMap.has(value)) {

                rulesMap.set(value, new Set([fn]));
            } else {
                const set = rulesMap.get(value);

                if (set.has(fn)) {
                    _warning(`Duplicated interceptor for '${key}'`);
                }

                set.add(fn);
            }
        }
    }

    /**
     * Returns the corresponding set of functions for the given key if found
     * @param {string} key - formatted as a path without the first '/' (ex: swarmType/swarmPhase/before)
     * @return {Array<Set<function>>}
     */
    function getInterceptorsForKey(key) {
        if (key.startsWith('/')) {
            _warning(`Interceptor called on key ${key} starting with '/', automatically removing it`);
            key = key.substring(1);
        }

        const keyElements = key.split('/');
        const keysGenerator = createArrayGenerator(keyElements);

        return getValueRecursively([rules], keysGenerator);
    }

    /**
     * It works like a BFS search returning the leafs resulting from traversing the internal nodes with corresponding
     * names given for each level (depth) by `keysGenerator`
     * @param {Array<Map>} searchableNodes
     * @param {IterableIterator} keysGenerator - it has the particularity that done is set on last element, not after it
     * @return {Array<Set<function>>}
     */
    function getValueRecursively(searchableNodes, keysGenerator) {
        const {value: nodeName, done} = keysGenerator.next();

        const nextNodes = [];

        for (const nodeInRules of searchableNodes) {
            const nextNodeForAll = nodeInRules.get('*');
            const nextNode = nodeInRules.get(nodeName);

            if (typeof nextNode !== "undefined") {
                nextNodes.push(nextNode);
            }

            if (typeof nextNodeForAll !== "undefined") {
                nextNodes.push(nextNodeForAll);
            }

        }

        if (done) {
            return nextNodes;
        }

        return getValueRecursively(nextNodes, keysGenerator);
    }


    /************* PUBLIC METHODS *************/

    this.register = function (swarmTypeName, phaseName, when, fn) {
        verifyWhenOption(when);
        verifyIsFunctionType(fn);

        const resolvedSwarmTypeName = resolveNamespaceResolution(swarmTypeName);
        const keys = createArrayGenerator([resolvedSwarmTypeName, phaseName, when]);

        registerRecursiveRule(rules, keys, fn);
    };

    // this.unregister = function () { }

    this.callInterceptors = function (key, targetObject, args) {
        const interceptors = getInterceptorsForKey(key);

        if (interceptors) {
            for (const interceptorSet of interceptors) {
                for (const fn of interceptorSet) { // interceptors on key '*' are called before those specified by name
                    fn.apply(targetObject, args);
                }
            }
        }
    };
}


exports.createInterceptorRegistry = function () {
    return new InterceptorRegistry();
};

}).call(this)}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/callflow/lib/loadLibrary.js":[function(require,module,exports){
/*
Initial License: (c) Axiologic Research & Alboaie Snic.
Contributors: Axiologic Research , PrivateSky project
Code License: LGPL or MIT.
*/

//var fs = require("fs");
//var path = require("path");


function SwarmLibrary(prefixName, folder){
    var self = this;
    function wrapCall(original, prefixName){
        return function(...args){
            //console.log("prefixName", prefixName)
            var previousPrefix = $$.libraryPrefix;
            var previousLibrary = $$.__global.currentLibrary;

            $$.libraryPrefix = prefixName;
            $$.__global.currentLibrary = self;
            try{
                var ret = original.apply(this, args);
                $$.libraryPrefix = previousPrefix ;
                $$.__global.currentLibrary = previousLibrary;
            }catch(err){
                $$.libraryPrefix = previousPrefix ;
                $$.__global.currentLibrary = previousLibrary;
                throw err;
            }
            return ret;
        }
    }

    $$.libraries[prefixName] = this;
    var prefixedRequire = wrapCall(function(path){
        return require(path);
    }, prefixName);

    function includeAllInRoot(folder) {
        if(typeof folder != "string"){
            //we assume that it is a library module properly required with require and containing $$.library
            for(var v in folder){
                $$.registerSwarmDescription(prefixName,v, prefixName + "." + v,  folder[v]);
            }

            var newNames = $$.__global.requireLibrariesNames[prefixName];
            for(var v in newNames){
                self[v] =  newNames[v];
            }
            return folder;
        }


        var res = prefixedRequire(folder); // a library is just a module
        if(typeof res.__autogenerated_privatesky_libraryName != "undefined"){
            var swarms = $$.__global.requireLibrariesNames[res.__autogenerated_privatesky_libraryName];
        } else {
            var swarms = $$.__global.requireLibrariesNames[folder];
        }
            var existingName;
            for(var v in swarms){
                existingName = swarms[v];
                self[v] = existingName;
                $$.registerSwarmDescription(prefixName,v, prefixName + "." + v,  existingName);
            }
        return res;
    }

    function wrapSwarmRelatedFunctions(space, prefixName){
        var ret = {};
        var names = ["create", "describe", "start", "restart"];
        for(var i = 0; i<names.length; i++ ){
            ret[names[i]] = wrapCall(space[names[i]], prefixName);
        }
        return ret;
    }

    this.callflows        = this.callflow   = wrapSwarmRelatedFunctions($$.callflows, prefixName);
    this.swarms           = this.swarm      = wrapSwarmRelatedFunctions($$.swarms, prefixName);

    includeAllInRoot(folder, prefixName);
}

exports.loadLibrary = function(prefixName, folder){
    var existing = $$.libraries[prefixName];
    if(existing ){
        if(!(existing instanceof SwarmLibrary)){
            var sL = new SwarmLibrary(prefixName, folder);
            for(var prop in existing){
                sL[prop] = existing[prop];
            }
            return sL;
        }
        if(folder) {
            $$.syntaxError("Reusing already loaded library " + prefixName + "could be an error!");
        }
        return existing;
    }
    //var absolutePath = path.resolve(folder);
    return new SwarmLibrary(prefixName, folder);
}


},{}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/callflow/lib/parallelJoinPoint.js":[function(require,module,exports){

var globalJoinCounter = 0;

function ParallelJoinPoint(swarm, callback, args){
    globalJoinCounter++;
    var channelId = "ParallelJoinPoint" + globalJoinCounter;
    var self = this;
    var counter = 0;
    var stopOtherExecution     = false;

    function executionStep(stepFunc, localArgs, stop){

        this.doExecute = function(){
            if(stopOtherExecution){
                return false;
            }
            try{
                stepFunc.apply(swarm, localArgs);
                if(stop){
                    stopOtherExecution = true;
                    return false;
                }
                return true; //everyting is fine
            } catch(err){
                args.unshift(err);
                sendForSoundExecution(callback, args, true);
                return false; //stop it, do not call again anything
            }
        }
    }

    if(typeof callback !== "function"){
        $$.syntaxError("invalid join",swarm, "invalid function at join in swarm");
        return;
    }

    $$.PSK_PubSub.subscribe(channelId,function(forExecution){
        if(stopOtherExecution){
            return ;
        }

        try{
            if(forExecution.doExecute()){
                decCounter();
            } // had an error...
        } catch(err){
            $$.info(err);
            //$$.errorHandler.syntaxError("__internal__",swarm, "exception in the execution of the join function of a parallel task");
        }
    });

    function incCounter(){
        if(testIfUnderInspection()){
            //preventing inspector from increasing counter when reading the values for debug reason
            //console.log("preventing inspection");
            return;
        }
        counter++;
    }

    function testIfUnderInspection(){
        var res = false;
        var constArgv = process.execArgv.join();
        if(constArgv.indexOf("inspect")!==-1 || constArgv.indexOf("debug")!==-1){
            //only when running in debug
            var callstack = new Error().stack;
            if(callstack.indexOf("DebugCommandProcessor")!==-1){
                console.log("DebugCommandProcessor detected!");
                res = true;
            }
        }
        return res;
    }

    function sendForSoundExecution(funct, args, stop){
        var obj = new executionStep(funct, args, stop);
        $$.PSK_PubSub.publish(channelId, obj); // force execution to be "sound"
    }

    function decCounter(){
        counter--;
        if(counter == 0) {
            args.unshift(null);
            sendForSoundExecution(callback, args, false);
        }
    }

    var inner = swarm.getInnerValue();

    function defaultProgressReport(err, res){
        if(err) {
            throw err;
        }
        return {
            text:"Parallel execution progress event",
            swarm:swarm,
            args:args,
            currentResult:res
        };
    }

    function mkFunction(name){
        return function(...args){
            var f = defaultProgressReport;
            if(name != "progress"){
                f = inner.myFunctions[name];
            }
            var args = $$.__intern.mkArgs(args, 0);
            sendForSoundExecution(f, args, false);
            return __proxyObject;
        }
    }


    this.get = function(target, prop, receiver){
        if(inner.myFunctions.hasOwnProperty(prop) || prop == "progress"){
            incCounter();
            return mkFunction(prop);
        }
        return swarm[prop];
    };

    var __proxyObject;

    this.__setProxyObject = function(p){
        __proxyObject = p;
    }
}

exports.createJoinPoint = function(swarm, callback, args){
    var jp = new ParallelJoinPoint(swarm, callback, args);
    var inner = swarm.getInnerValue();
    var p = new Proxy(inner, jp);
    jp.__setProxyObject(p);
    return p;
};
},{}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/callflow/lib/serialJoinPoint.js":[function(require,module,exports){

var joinCounter = 0;

function SerialJoinPoint(swarm, callback, args){

    joinCounter++;

    var self = this;
    var channelId = "SerialJoinPoint" + joinCounter;

    if(typeof callback !== "function"){
        $$.syntaxError("unknown", swarm, "invalid function given to serial in swarm");
        return;
    }

    var inner = swarm.getInnerValue();


    function defaultProgressReport(err, res){
        if(err) {
            throw err;
        }
        return res;
    }


    var functionCounter     = 0;
    var executionCounter    = 0;

    var plannedExecutions   = [];
    var plannedArguments    = {};

    function mkFunction(name, pos){
        //console.log("Creating function ", name, pos);
        plannedArguments[pos] = undefined;

        function triggetNextStep(){
            if(plannedExecutions.length == executionCounter || plannedArguments[executionCounter] )  {
                $$.PSK_PubSub.publish(channelId, self);
            }
        }

        var f = function (...args){
            if(executionCounter != pos) {
                plannedArguments[pos] = args;
                //console.log("Delaying function:", executionCounter, pos, plannedArguments, arguments, functionCounter);
                return __proxy;
            } else{
                if(plannedArguments[pos]){
                    //console.log("Executing  function:", executionCounter, pos, plannedArguments, arguments, functionCounter);
					args = plannedArguments[pos];
                } else {
                    plannedArguments[pos] = args;
                    triggetNextStep();
                    return __proxy;
                }
            }

            var f = defaultProgressReport;
            if(name != "progress"){
                f = inner.myFunctions[name];
            }


            try{
                f.apply(self,args);
            } catch(err){
                    args.unshift(err);
                    callback.apply(swarm,args); //error
                    $$.PSK_PubSub.unsubscribe(channelId,runNextFunction);
                return; //terminate execution with an error...!
            }
            executionCounter++;

            triggetNextStep();

            return __proxy;
        };

        plannedExecutions.push(f);
        functionCounter++;
        return f;
    }

     var finished = false;

    function runNextFunction(){
        if(executionCounter == plannedExecutions.length ){
            if(!finished){
                args.unshift(null);
                callback.apply(swarm,args);
                finished = true;
                $$.PSK_PubSub.unsubscribe(channelId,runNextFunction);
            } else {
                console.log("serial construct is using functions that are called multiple times...");
            }
        } else {
            plannedExecutions[executionCounter]();
        }
    }

    $$.PSK_PubSub.subscribe(channelId,runNextFunction); // force it to be "sound"


    this.get = function(target, prop, receiver){
        if(prop == "progress" || inner.myFunctions.hasOwnProperty(prop)){
            return mkFunction(prop, functionCounter);
        }
        return swarm[prop];
    }

    var __proxy;
    this.setProxyObject = function(p){
        __proxy = p;
    }
}

exports.createSerialJoinPoint = function(swarm, callback, args){
    var jp = new SerialJoinPoint(swarm, callback, args);
    var inner = swarm.getInnerValue();
    var p = new Proxy(inner, jp);
    jp.setProxyObject(p);
    return p;
}
},{}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/callflow/lib/swarmDescription.js":[function(require,module,exports){
const swarmDescriptionsRegistry = {};
let currentInlineCounter = 0;

$$.registerSwarmDescription =  function(libraryName, shortName, swarmTypeName, description){
    if(!$$.libraries[libraryName]){
        $$.libraries[libraryName] = {};
    }

    if(!$$.__global.requireLibrariesNames[libraryName]){
        $$.__global.requireLibrariesNames[libraryName] = {};
    }

    $$.libraries[libraryName][shortName] = description;
    //console.log("Registering ", libraryName,shortName, $$.__global.currentLibraryName);
    if($$.__global.currentLibraryName){
        $$.__global.requireLibrariesNames[$$.__global.currentLibraryName][shortName] = libraryName + "." + shortName;
    }

    $$.__global.requireLibrariesNames[libraryName][shortName] = swarmTypeName;

    if(typeof description == "string"){
        description = swarmDescriptionsRegistry[description];
    }
    swarmDescriptionsRegistry[swarmTypeName] = description;
};


var currentLibraryCounter = 0;
$$.library = function(callback){
    currentLibraryCounter++;
    var previousCurrentLibrary = $$.__global.currentLibraryName;
    var libraryName = "___privatesky_library"+currentLibraryCounter;
    var ret = $$.__global.requireLibrariesNames[libraryName] = {};
    $$.__global.currentLibraryName = libraryName;
    callback();
    $$.__global.currentLibraryName = previousCurrentLibrary;
    ret.__autogenerated_privatesky_libraryName = libraryName;
    return ret;
};


$$.fixSwarmName = function(shortName){
    let fullName;
    try{
        if(shortName && shortName.includes(".")) {
            fullName = shortName;
        } else {
            fullName = $$.libraryPrefix + "." + shortName;
        }

    } catch(err){
        $$.err(err);
    }
    return fullName;
};

function SwarmSpace(swarmType, utils) {
    let beesHealer = require("swarmutils").beesHealer;

    function getFullName(shortName){
        return $$.fixSwarmName(shortName);
    }

    function VarDescription(desc){
        return {
            init:function(){
                return undefined;
            },
            restore:function(jsonString){
                return JSON.parse(jsonString);
            },
            toJsonString:function(x){
                return JSON.stringify();
            }
        };
    }

    function SwarmDescription(swarmTypeName, description){

        swarmTypeName = getFullName(swarmTypeName);

        var localId = 0;  // unique for each swarm

        function createVars(descr){
            var members = {};
            for(var v in descr){
                members[v] = new VarDescription(descr[v]);
            }
            return members;
        }

        function createMembers(descr){
            var members = {};
            for(var v in description){

                if(v != "public" && v != "private"){
                    members[v] = description[v];
                }
            }
            return members;
        }

        var publicVars = createVars(description.public);
        var privateVars = createVars(description.private);
        var myFunctions = createMembers(description);

        function createPhase(thisInstance, func, phaseName){
            var keyBefore = `${swarmTypeName}/${phaseName}/${$$.CONSTANTS.BEFORE_INTERCEPTOR}`;
            var keyAfter = `${swarmTypeName}/${phaseName}/${$$.CONSTANTS.AFTER_INTERCEPTOR}`;

            var phase = function(...args){
                var ret;
                try{
                    $$.PSK_PubSub.blockCallBacks();
                    thisInstance.setMetadata('phaseName', phaseName);
                    $$.interceptor.callInterceptors(keyBefore, thisInstance, args);
                    ret = func.apply(thisInstance, args);
                    $$.interceptor.callInterceptors(keyAfter, thisInstance, args);
                    $$.PSK_PubSub.releaseCallBacks();
                }catch(err){
                    $$.PSK_PubSub.releaseCallBacks();
                    throw err;
                }
                return ret;
            };
            //dynamic named func in order to improve callstack
            Object.defineProperty(phase, "name", {get: function(){return swarmTypeName+"."+func.name}});
            return phase;
        }

        this.initialise = function(serialisedValues){
            const OwM = require("swarmutils").OwM;
            var result = new OwM({
                publicVars:{

                },
                privateVars:{

                },
                protectedVars:{

                },
                myFunctions:{

                },
                utilityFunctions:{

                },
                meta:{
                    swarmTypeName:swarmTypeName,
                    swarmDescription:description
                }
            });


            for(var v in publicVars){
                result.publicVars[v] = publicVars[v].init();
            }

            for(var v in privateVars){
                result.privateVars[v] = privateVars[v].init();
            }


            if(serialisedValues){
                beesHealer.jsonToNative(serialisedValues, result);
            }
            return result;
        };

        this.initialiseFunctions = function(valueObject, thisObject){

            for(var v in myFunctions){
                valueObject.myFunctions[v] = createPhase(thisObject, myFunctions[v], v);
            }

            localId++;
            valueObject.utilityFunctions = utils.createForObject(valueObject, thisObject, localId);

        };

        this.get = function(target, property, receiver){


            if(publicVars.hasOwnProperty(property))
            {
                return target.publicVars[property];
            }

            if(privateVars.hasOwnProperty(property))
            {
                return target.privateVars[property];
            }

            if(target.utilityFunctions.hasOwnProperty(property))
            {

                return target.utilityFunctions[property];
            }


            if(myFunctions.hasOwnProperty(property))
            {
                return target.myFunctions[property];
            }

            if(target.protectedVars.hasOwnProperty(property))
            {
                return target.protectedVars[property];
            }

            if(typeof property != "symbol") {
                $$.syntaxError(" Undefined symbol " + property + " in swarm " + target.meta.swarmTypeName);
            }
            return undefined;
        };

        this.set = function(target, property, value, receiver){

            if(target.utilityFunctions.hasOwnProperty(property) || target.myFunctions.hasOwnProperty(property)) {
                $$.syntaxError(property);
                throw new Error("Trying to overwrite immutable member" + property);
            }

            if(privateVars.hasOwnProperty(property))
            {
                target.privateVars[property] = value;
            } else
            if(publicVars.hasOwnProperty(property))
            {
                target.publicVars[property] = value;
            } else {
                target.protectedVars[property] = value;
            }
            return true;
        };

        this.apply = function(target, thisArg, argumentsList){
            console.log("Proxy apply");
            //var func = target[]
            //swarmGlobals.executionProvider.execute(null, thisArg, func, argumentsList)
        };

        var self = this;

        this.isExtensible = function(target) {
            return false;
        };

        this.has = function(target, prop) {
            if(target.publicVars[prop] || target.protectedVars[prop]) {
                return true;
            }
            return false;
        };

        this.ownKeys = function(target) {
            return Reflect.ownKeys(target.publicVars);
        };

        return function(serialisedValues, initialisationContext){
            var valueObject = self.initialise(serialisedValues);
            var result = new Proxy(valueObject,self);
            self.initialiseFunctions(valueObject,result);
			if(!serialisedValues){
				if(!valueObject.getMeta("swarmId")){
					valueObject.setMeta("swarmId", $$.uidGenerator.safe_uuid());  //do not overwrite!!!
				}
				valueObject.utilityFunctions.notify();
			}

			if(result.autoInit){
                result.autoInit(initialisationContext);
                $$.fixMe("Reinstate somehow the next comment")
                //result.autoInit = undefined;
            }
			return result;
        }
    }



    this.describe = function describeSwarm(swarmTypeName, description){
        swarmTypeName = getFullName(swarmTypeName);

        var pointPos = swarmTypeName.lastIndexOf('.');
        var shortName = swarmTypeName.substr( pointPos+ 1);
        var libraryName = swarmTypeName.substr(0, pointPos);
        if(!libraryName){
            libraryName = "global";
        }

        var description = new SwarmDescription(swarmTypeName, description);
        if(swarmDescriptionsRegistry[swarmTypeName] != undefined){
            $$.warn("Duplicate swarm description "+ swarmTypeName);
        }

        swarmDescriptionsRegistry[swarmTypeName] = description;
		//$$.registerSwarmDescription(libraryName, shortName, swarmTypeName, description);
        return description;
    };


    var self = this;
    $$.fixMe("This could generate memory leaks. Fix it later");
    this.inline = function inline(description, ...args){
        currentInlineCounter++;
        var desc = self.describe("inlineSwarm" + currentInlineCounter, description);
        var flow = desc();
        flow.start(...args);
        return flow;
    };

    this.create = function(){
        $$.err("Create APIs for creation of swarms was  removed. Use describe!");
    };

    this.continue = function(swarmTypeName, initialValues){
        if(!initialValues){
            initialValues = swarmTypeName;
            swarmTypeName = initialValues.meta.swarmTypeName;
        }

        swarmTypeName = getFullName(swarmTypeName);
        let desc = swarmDescriptionsRegistry[swarmTypeName];
        if(desc){
            return desc(initialValues);
        } else {
            $$.err(swarmTypeName,initialValues,
                "Failed to restart a swarm with type " + swarmTypeName + "\n Maybe different swarm space (used flow instead of swarm!?)");
        }
    };

    this.start = function(swarmTypeName, ctor, ...params){
        let ret = this.startWithContext(undefined, swarmTypeName, ctor, ...params);
        return ret;
    };

    this.startWithContext = function(context, swarmTypeName, ctor, ...params){
        swarmTypeName = getFullName(swarmTypeName);
        var desc = swarmDescriptionsRegistry[swarmTypeName];
        if(!desc){
            $$.syntaxError(null, swarmTypeName);
            return null;
        }
        let res = desc(undefined, context);
        res.setMetadata("homeSecurityContext", $$.securityContext);

        if(ctor){
            res[ctor].apply(res, params);
        }

        return res;
    }
}

exports.createSwarmEngine = function(swarmType, utils){
    if(typeof utils == "undefined"){
        utils = require("./utilityFunctions/callflow");
    }
    return new SwarmSpace(swarmType, utils);
};


},{"./utilityFunctions/callflow":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/callflow/lib/utilityFunctions/callflow.js","swarmutils":"swarmutils"}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/callflow/lib/utilityFunctions/SwarmDebug.js":[function(require,module,exports){
(function (global){(function (){
/*
 Initial License: (c) Axiologic Research & Alboaie Snic.
 Contributors: Axiologic Research , PrivateSky project
 Code License: LGPL or MIT.
 */

var util = require("util");
global.cprint = console.log;
global.wprint = console.warn;
global.dprint = console.debug;
global.eprint = console.error;


/**
 * Shortcut to JSON.stringify
 * @param obj
 */
global.J = function (obj) {
    return JSON.stringify(obj);
}


/**
 * Print swarm contexts (Messages) and easier to read compared with J
 * @param obj
 * @return {string}
 */
exports.cleanDump = function (obj) {
    var o = obj.valueOf();
    var meta = {
        swarmTypeName:o.meta.swarmTypeName
    };
    return "\t swarmId: " + o.meta.swarmId + "{\n\t\tmeta: "    + J(meta) +
        "\n\t\tpublic: "        + J(o.publicVars) +
        "\n\t\tprotected: "     + J(o.protectedVars) +
        "\n\t\tprivate: "       + J(o.privateVars) + "\n\t}\n";
}

//M = exports.cleanDump;
/**
 * Experimental functions
 */


/*

 logger      = monitor.logger;
 assert      = monitor.assert;
 throwing    = monitor.exceptions;


 var temporaryLogBuffer = [];

 var currentSwarmComImpl = null;

 logger.record = function(record){
 if(currentSwarmComImpl===null){
 temporaryLogBuffer.push(record);
 } else {
 currentSwarmComImpl.recordLog(record);
 }
 }

 var container = require("dicontainer").container;

 container.service("swarmLoggingMonitor", ["swarmingIsWorking", "swarmComImpl"], function(outOfService,swarming, swarmComImpl){

 if(outOfService){
 if(!temporaryLogBuffer){
 temporaryLogBuffer = [];
 }
 } else {
 var tmp = temporaryLogBuffer;
 temporaryLogBuffer = [];
 currentSwarmComImpl = swarmComImpl;
 logger.record = function(record){
 currentSwarmComImpl.recordLog(record);
 }

 tmp.forEach(function(record){
 logger.record(record);
 });
 }
 })

 */
global.uncaughtExceptionString = "";
global.uncaughtExceptionExists = false;
if(typeof globalVerbosity == 'undefined'){
    global.globalVerbosity = false;
}

var DEBUG_START_TIME = new Date().getTime();

function getDebugDelta(){
    var currentTime = new Date().getTime();
    return currentTime - DEBUG_START_TIME;
}

/**
 * Debug functions, influenced by globalVerbosity global variable
 * @param txt
 */
global.dprint = function (txt) {
    if (globalVerbosity == true) {
        if (thisAdapter.initilised ) {
            console.log("DEBUG: [" + thisAdapter.nodeName + "](" + getDebugDelta()+ "):"+txt);
        }
        else {
            console.log("DEBUG: (" + getDebugDelta()+ "):"+txt);
            console.log("DEBUG: " + txt);
        }
    }
}

/**
 * obsolete!?
 * @param txt
 */
global.aprint = function (txt) {
    console.log("DEBUG: [" + thisAdapter.nodeName + "]: " + txt);
}



/**
 * Utility function usually used in tests, exit current process after a while
 * @param msg
 * @param timeout
 */
global.delayExit = function (msg, retCode,timeout) {
    if(retCode == undefined){
        retCode = ExitCodes.UnknownError;
    }

    if(timeout == undefined){
        timeout = 100;
    }

    if(msg == undefined){
        msg = "Delaying exit with "+ timeout + "ms";
    }

    console.log(msg);
    setTimeout(function () {
        process.exit(retCode);
    }, timeout);
}


function localLog (logType, message, err) {
    var fs = require("fs");
    var time = new Date();
    var now = time.getDate() + "-" + (time.getMonth() + 1) + "," + time.getHours() + ":" + time.getMinutes();
    var msg;

    msg = '[' + now + '][' + thisAdapter.nodeName + '] ' + message;

    if (err != null && err != undefined) {
        msg += '\n     Err: ' + err.toString();
        if (err.stack && err.stack != undefined)
            msg += '\n     Stack: ' + err.stack + '\n';
    }

    cprint(msg);
    if(thisAdapter.initilised){
        try{
            fs.appendFileSync(getSwarmFilePath(thisAdapter.config.logsPath + "/" + logType), msg);
        } catch(err){
            console.log("Failing to write logs in ", thisAdapter.config.logsPath );
        }

    }
}


// printf = function (...params) {
//     var args = []; // empty array
//     // copy all other arguments we want to "pass through"
//     for (var i = 0; i < params.length; i++) {
//         args.push(params[i]);
//     }
//     var out = util.format.apply(this, args);
//     console.log(out);
// }
//
// sprintf = function (...params) {
//     var args = []; // empty array
//     for (var i = 0; i < params.length; i++) {
//         args.push(params[i]);
//     }
//     return util.format.apply(this, args);
// }


}).call(this)}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"fs":false,"util":false}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/callflow/lib/utilityFunctions/base.js":[function(require,module,exports){
exports.createForObject = function(valueObject, thisObject, localId){
	var swarmDebug = require("./SwarmDebug");
	let ret = {};

	function getInnerValue(){
		return valueObject;
	}

	function runPhase(functName, args){
		var func = valueObject.myFunctions[functName];
		if(func){
			func.apply(thisObject, args);
		} else {
			$$.syntaxError(functName, valueObject, "Function " + functName + " does not exist!");
		}

	}

	function update(serialisation){
		require("swarmutils").beesHealer.jsonToNative(serialisation,valueObject);
	}


	function valueOf(){
		var ret = {};
		ret.meta                = valueObject.meta;
		ret.publicVars          = valueObject.publicVars;
		ret.privateVars         = valueObject.privateVars;
		ret.protectedVars       = valueObject.protectedVars;
		return ret;
	}

	function toString (){
		return swarmDebug.cleanDump(thisObject.valueOf());
	}


	function createParallel(callback){
		return require("../parallelJoinPoint").createJoinPoint(thisObject, callback, $$.__intern.mkArgs(arguments,1));
	}

	function createSerial(callback){
		return require("../serialJoinPoint").createSerialJoinPoint(thisObject, callback, $$.__intern.mkArgs(arguments,1));
	}

	function inspect(){
		return swarmDebug.cleanDump(thisObject.valueOf());
	}

	function constructor(){
		return SwarmDescription;
	}

	function ensureLocalId(){
		if(!valueObject.localId){
			valueObject.localId = valueObject.meta.swarmTypeName + "-" + localId;
			localId++;
		}
	}

	function observe(callback, waitForMore, messageIdentityFilter){
		if(!waitForMore){
			waitForMore = function (){
				return false;
			}
		}

		ensureLocalId();

		$$.PSK_PubSub.subscribe(valueObject.localId, callback, waitForMore, messageIdentityFilter);
	}

	function toJSON(prop){
		//preventing max call stack size exceeding on proxy auto referencing
		//replace {} as result of JSON(Proxy) with the string [Object protected object]
		return "[Object protected object]";
	}

	function getJSON(callback){
		return	require("swarmutils").beesHealer.asJSON(valueObject, null, null,callback);
	}

	function notify(event){
		if(!event){
			event = valueObject;
		}
		ensureLocalId();

		setTimeout(()=>{
			$$.PSK_PubSub.publish(valueObject.localId, event);
		});
	}

	function getMeta(name){
		return valueObject.getMeta(name);
	}

	function setMeta(name, value){
		return valueObject.setMeta(name, value);
	}

	ret.setMeta			= setMeta;
	ret.getMeta			= getMeta;

	ret.notify          = notify;
	ret.getJSON    	    = getJSON;
	ret.toJSON          = toJSON;
	ret.observe         = observe;
	ret.inspect         = inspect;
	ret.join            = createParallel;
	ret.parallel        = createParallel;
	ret.serial          = createSerial;
	ret.valueOf         = valueOf;
	ret.actualize       = update;
	ret.runPhase        = runPhase;


	ret.getInnerValue   = getInnerValue;
	ret.toString        = toString;
	ret.constructor     = constructor;
	ret.setMetadata		= valueObject.setMeta.bind(valueObject);
	ret.getMetadata		= valueObject.getMeta.bind(valueObject);

	ret.autoInit		= null;
	return ret;

};

},{"../parallelJoinPoint":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/callflow/lib/parallelJoinPoint.js","../serialJoinPoint":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/callflow/lib/serialJoinPoint.js","./SwarmDebug":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/callflow/lib/utilityFunctions/SwarmDebug.js","swarmutils":"swarmutils"}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/callflow/lib/utilityFunctions/callflow.js":[function(require,module,exports){
exports.createForObject = function(valueObject, thisObject, localId){
	var ret = require("./base").createForObject(valueObject, thisObject, localId);
	return ret;
};
},{"./base":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/callflow/lib/utilityFunctions/base.js"}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/dossier/lib/RawDossier.js":[function(require,module,exports){
function RawDossier(bar) {
    Object.assign(this, bar);
}

module.exports = RawDossier;

},{}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/double-check/lib/runner.js":[function(require,module,exports){
(function (__dirname){(function (){
const fs = require("fs");
const path = require("path");
const forker = require('child_process');

const configuration_file_name = "double-check.json";

let globToRegExp =  require("./utils/glob-to-regexp");

const MAX_WORKERS = process.env['DOUBLE_CHECK_POOL_SIZE'] || 10;
const RUNNER_VERBOSE = process.env['DOUBLE_CHECK_RUNNER_VERBOSE'] || true;

const WORKER_PROCESS_STATES = {
    READY: 'ready',
    RUNNING: 'running',
    FINISHED: 'finished'
};

function TestRunner(){

    // Session object
    function initializeSession() {
        return {
            testCount: 0,
            currentTestIndex: 0,
            processedTestCount: 0,
            workers: {
                running: 0,
                terminated: 0
            }
        };
    }

    let defaultConfig = {
        fileExt: ".js",                         // test file supported by extension
        matchDirs: ["*"],
        testDirs: process.cwd(),                // path to the root tests location
        ignore: [".git"],
        reports: {
            basePath: process.cwd(),            // path where the reports will be saved
            prefix: "Report-",                  // prefix for report files, filename pattern: [prefix]-{timestamp}{ext}
            ext: ".txt"                         // report file extension
        }
    };

    // Template structure for test reports.
    let reportFileStructure = {
        count: 0,
        suites: new Set(),
        passed: new Set(),
        failed: new Set()
    };

    let config;

    function init(cfg){

        // no matter how and when runner is exiting first of all do a report print
        let process_exit = process.exit;
        process.exit = (...args)=>{
            process.exit = process_exit;
            doReports(()=>{
                process.exit(...args);
            });
        };

        process.on("SIGINT", process.exit);
        //--------------------------------------------------------------------------------------

        config = extend(defaultConfig, cfg);
        debug("Starting config", config);

        //the testTree holds the tree of directories and files descovered
        this.testTree = {};
        //sorted list of all test files discovered
        this.testList = [];

        this.session = initializeSession();

        // create reports directory if not exist
        if (!fs.existsSync(config.reports.basePath)){
            fs.mkdirSync(config.reports.basePath);
        }
    }

    function getDefaultNodeStructure() {
        return  {
            __meta: {
                conf: null,
                parent: null,
                isDirectory: false
            },
            data: {
                name: null,
                path: null,
            },
            result: {
                state: WORKER_PROCESS_STATES.READY, // ready | running | terminated | timeout
                pass: null,
                executionTime: 0,
                runs: 0,
                asserts: [],
                messages: []
            },
            items: null
        };
    }

    function discoverTestFiles(dir, parentConf) {
        dir = path.resolve(dir);
        const stat = fs.statSync(dir);
        if(!stat.isDirectory()){
            throw new Error(dir + " is not a directory!");
        }

        let currentConf = JSON.parse(JSON.stringify(parentConf));

        let currentNode = getDefaultNodeStructure();
        currentNode.__meta.parent = path.dirname(dir);
        currentNode.__meta.isDirectory = true;

        let files = fs.readdirSync(dir);
        // first look for conf file
        if(files.indexOf(configuration_file_name) !== -1) {
            let fd = path.join(dir, configuration_file_name);
            let conf = readConf(fd);
            if(conf) {
                currentNode.__meta.conf = conf;
                currentConf = extend(currentConf, conf);
                //currentConf = conf;
            }
        }

        currentNode.data.name = path.basename(dir);
        currentNode.data.path = dir;
        currentNode.items = [];

        for(let i = 0, len = files.length; i < len; i++) {
            let item = files[i];

            let fd = path.join(dir, item);
            let stat = fs.statSync(fd);
            let isDir = stat.isDirectory();
            let isTestDir = validateAsTestDir(fd);

            if(isDir && !isTestDir) {
                continue; // ignore dirs that does not follow the naming rule for test dirs
            }

            if(!isDir && item.match(configuration_file_name)){
                continue; // already processed
            }

            // exclude files based on glob patterns
            if(currentConf) {
                // currentConf['ignore'] - array of regExp
                if(currentConf['ignore']) {
                    const isMatch = isAnyMatch(currentConf['ignore'], item);
                    if(isMatch) {continue;}
                }
            }

            let childNode = getDefaultNodeStructure();
            childNode.__meta.conf = {};
            childNode.__meta.isDirectory = isDir;
            childNode.__meta.parent = path.dirname(fd);

            if (isDir) {
                let tempChildNode = discoverTestFiles(fd, currentConf);
                childNode = Object.assign(childNode, tempChildNode);
                currentNode.items.push(childNode);
            }
            else if(path.extname(fd) ===  config.fileExt){
                childNode.__meta.conf.runs = currentConf['runs'] || 1;
                childNode.__meta.conf.silent = currentConf['silent'];

                childNode.data.name = item;
                childNode.data.path = fd;
                reportFileStructure.suites.add(childNode.__meta.parent);
                currentNode.items.push(childNode);
            }
        }

        return currentNode;
    }

    function readConf(confPath) {
        var config = {};
        try{
            config = require(confPath);
        } catch(error) {
            console.error(error);
        }

        return config;
    }

    function validateAsTestDir(dir) {
        if(!config || !config.matchDirs) {
            throw new Error(`matchDirs is not defined on config ${JSON.stringify(config)} does not exist!`);
        }

       let isTestDir = isAnyMatch(config.matchDirs, dir);

        return isTestDir;
    }

    function isAnyMatch(globExpArray, str) {
        const hasMatch = function(globExp) {
            const regex = globToRegExp(globExp);
            return regex.test(str);
        };

        return globExpArray.some(hasMatch);
    }

    let launchTests = () => {

        this.session.testCount = this.testList.length;

        console.log(`Start launching tests (${this.session.testCount})...`);

        reportFileStructure.startDate = new Date().getTime();
        reportFileStructure.count = this.session.testCount;
        if(this.session.testCount > 0) {
            setInterval(scheduleWork, 100);
        } else {
            doReports();
        }
    };

    let scheduleWork = () => {
        //launching tests for each workers available
        while(this.session.workers.running < MAX_WORKERS && this.session.currentTestIndex < this.session.testCount){
            let test = this.testList[this.session.currentTestIndex];
            launchTest(test);
        }
    };

    let launchTest = (test) => {
        this.session.workers.running++;

        test.result.state = WORKER_PROCESS_STATES.RUNNING;

        let env = process.env;

        const cwd = test.__meta.parent;
        console.log("Executing", test.data.path);
        let worker = forker.fork(test.data.path, [], {
                'cwd': cwd,
                'env': env,
                stdio: ["inherit", "pipe", 'pipe', 'ipc'],
                silent: false
            });

        let workerStatusInterval;
        const setIntervalValue = 10000;
        let alreadyFinished = false;
        //we set the status check interval with a delay in order to not monitor
        //fast ending tests...
        setTimeout(()=>{
            if(alreadyFinished){
                return;
            }

            //console.log(`Added ${setIntervalValue}ms status check interval for worker that handles`, test.data.name);
            workerStatusInterval = setInterval(()=>{
                console.log(`Test ${test.data.path} is still running`);
            }, setIntervalValue);
        }, setIntervalValue);

        function clearStatusInterval(fnc){
            return (...args)=>{
                alreadyFinished = true;
                //if a setInterval was set we clear it
                if(workerStatusInterval){
                    //console.log("Cleared status check interval for worker that handles", test.data.name);
                    clearInterval(workerStatusInterval);
                }
                fnc(...args);
            }
        }

        worker.on("exit", clearStatusInterval(onExitEventHandlerWrapper(test)));
        worker.on("message", onMessageEventHandlerWrapper(test));
        worker.on("error", onErrorEventHandlerWrapper(test));
        worker.stderr.on("data", messageCaughtOnStdErr(test));

        debug(`Launching test ${test.data.name}, on worker pid[${worker.pid}] `);
        console.log(`Progress: ${this.session.currentTestIndex+1} of ${this.session.testCount}`);

        this.session.currentTestIndex++;

        worker.stdout.on('data', function (dataBuffer) {
            let content = dataBuffer.toString('utf8');
            if (test.__meta.conf.silent) {
                console.log(content);
            }
            test.result.messages.push(content);
        }.bind(this));


        var self = this;

        function onMessageEventHandlerWrapper(test) {
            return function (log) {
                if (log.type === 'assert') {
                    test.result.asserts.push(log);
                } else {
                    test.result.messages.push(log);
                }
            };
        }

        function onExitEventHandlerWrapper(test) {
            return function (code, signal) {
                //clearTimeout(worker.timerVar);
                debug(`Test ${test.data.name} exit with code ${code}, signal ${signal} `);

                test.result.state = WORKER_PROCESS_STATES.FINISHED;
                self.session.processedTestCount++;
                if (code === 0 && test.result.pass === null) {
                    test.result.pass = true;
                    reportFileStructure.passed.add(test);
                } else {
                    test.result.pass = false;
                    reportFileStructure.failed.add(test);
                    test.result.messages.push("Process finished with errors!",
                        `Exit code: ${code} Signal: ${signal}`);
                }

                self.session.workers.running--;
                self.session.workers.terminated++;

                //scheduleWork();
                checkWorkersStatus();
            };
        }

        // this handler can be triggered when:
        // 1. The process could not be spawned, or
        // 2. The process could not be killed, or
        // 3. Sending a message to the child process failed.
        // IMPORTANT: The 'exit' event may or may not fire after an error has occurred!
        function onErrorEventHandlerWrapper(test) {
            return function (error) {
                if($$.Buffer.isBuffer(error)){
                    error = error.toString();
                }
                debug(`Worker ${worker.pid} - error event.`, test.data.name);
                //debug(error);

                test.result.pass = false;
                test.result.messages.push(error);

                reportFileStructure.failed.add(test);
                self.session.workers.running--;
                self.session.workers.terminated++;
            };
        }

        function messageCaughtOnStdErr(test) {
            return function (error) {
                if($$.Buffer.isBuffer(error)){
                    error = error.toString();
                }
                //debug(`Worker ${worker.pid} - error event.`, test.data.name);
                //debug(error);

                test.result.pass = false;
                test.result.messages.push(error);

                reportFileStructure.failed.add(test);
            };
        }
    };

    let checkWorkersStatus = ()=>{
        let remaining = this.session.testCount - this.session.processedTestCount;
        if(this.session.workers.running === 0 && remaining === 0) {
            doReports();
        }else{
            console.log(`Testing still in progress... ${this.session.workers.running} workers busy and ${remaining} tests are waiting to finish.`);
        }
    };

    let reportsAllReadyPrinted = false;
    let doReports = (cb) => {
        if(reportsAllReadyPrinted){
            if(cb){
                cb();
            }
           return;
        }
        reportsAllReadyPrinted = true;
        //doing reports :D
        //on console and html report please!
        reportFileStructure.endDate = new Date().getTime();
        reportFileStructure.runned = this.session.processedTestCount;

        doConsoleReport();

        doHTMLReport((err, res)=>{
            if(cb){
                cb(err, res);
            }
            this.callback(err, this.session);
        });
    };

    let doConsoleReport = () =>{
        console.log("\n\nResults\n==========================");
        console.log(`Finish running ${this.session.processedTestCount} tests from a total of ${this.session.testCount}.`);
        console.log(`\x1b[31m ${reportFileStructure.failed.size} \x1b[0mfailed tests and \x1b[32m ${reportFileStructure.passed.size} \x1b[0mpassed tests.`);

        this.session.failed = reportFileStructure.failed.size;
        this.session.passed = reportFileStructure.passed.size;
        const sortedTestResults = [...reportFileStructure.failed, ...reportFileStructure.passed];
        const greenCheckbox = '\x1b[32m \u2714 \x1b[0m';
        const redCross = '\x1b[31m \u274C \x1b[0m';

        console.log("==========================\nSummary:");
        for (const test of sortedTestResults) {
            const passed = test.result.pass;

            console.log(` ${passed ? greenCheckbox : redCross} ${test.data.name}`);
            if(!passed){
                console.log(`\t at (${test.data.path}:1:1)`);
            }
        }
        console.log("==========================");
    };

    let doHTMLReport = (cb) => {
        var folderName = path.resolve(__dirname);
        fs.readFile(path.join(folderName,'/utils/report.html'), 'utf8', (err, res) => {
            if (err) {
                debug("An error occurred while reading the html report template file. HTML report can't be generated for now.");
                if(cb){
                    cb();
                }
                return;
            }
            let destination = path.join(process.cwd(), "testReport.html");
            let summary = JSON.parse(JSON.stringify(reportFileStructure));
            summary.failed = Array.from(reportFileStructure.failed);
            summary.passed = Array.from(reportFileStructure.passed);
            summary.suites = Array.from(reportFileStructure.suites);

            let content = res.replace("</html>", `<script>\nprint(${JSON.stringify(summary)});\n</script>\n</html>`);
            fs.writeFile(destination, content, 'utf8', (err) => {
                if (err) {
                    debug('An error occurred while writing the html report file, with the following error: ' + JSON.stringify(err));
                    throw err;
                }

                debug(`Finished writing HTML Report to file://${destination}`);
                if(cb){
                    cb();
                }
            });
        });
    };

    function debug(...args){
        if(!RUNNER_VERBOSE){
            return;
        }

        console.log(...args);
    }

    function extend(first, second) {
        for (const key in second) {
            if (!first.hasOwnProperty(key)) {
                first[key] = second[key];
            } else {
                let val = second[key];
                if(typeof first[key] === 'object' && !Array.isArray(first[key])) {
                    val = extend(first[key], second[key]);
                }
                first[key] = val;
            }
        }

        return first;
    }

    function testTreeToList(rootNode) {
        var testList = [];

        traverse(rootNode);

        function traverse(node) {
            if(!node.__meta.isDirectory || !node.items) {
                return;
            }

            for(let i = 0, len = node.items.length; i < len; i++) {
                const item = node.items[i];
                if(item.__meta.isDirectory) {
                    traverse(item);
                } else {
                    testList.push(item);
                }
            }
        }

        return testList;
    }

    /**
     * Main entry point. It will start the flow runner flow.
     * @param cfg {Object} - object containing settings such as conf file name, test dir.
     * @param callback {Function} - handler(error, result) invoked when an error occurred or the runner has completed all jobs.
     */
    this.start = function(cfg, callback){

        this.callback = function(err, result) {
            if(err) {
                debug("Sending error to the callback", err);
            }

            if(callback) {
                return callback(err, result);
            }
        };

        init.call(this, cfg);

        console.log("Start discovering tests ...");
        let testTree = [];
        if(Array.isArray(config.testDirs)){
            for(let i=0; i<config.testDirs.length; i++){
                testTree = testTree.concat(discoverTestFiles(config.testDirs[i], config));
            }
        }else{
            testTree = discoverTestFiles(config.testDirs, config);
        }

        this.testList = [];
        for(let i=0; i<testTree.length; i++){
            this.testList = this.testList.concat(testTreeToList(testTree[i]));
        }

        launchTests();
    }
}

exports.init = function(sf) {
    sf.testRunner = new TestRunner();
}

}).call(this)}).call(this,"/modules/double-check/lib")

},{"./utils/glob-to-regexp":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/double-check/lib/utils/glob-to-regexp.js","child_process":false,"fs":false,"path":false}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/double-check/lib/standardAsserts.js":[function(require,module,exports){
(function (global){(function (){
module.exports.init = function (sf, logger) {
    /**
     * Registering handler for failed asserts. The handler is doing logging and is throwing an error.
     * @param explanation {String} - failing reason message.
     */
    let __failWasAlreadyGenerated = false;
    let __assetsCounter = 0;
    let beginWasCalled = false;

    const watchedStream = ["stdout", "stderr"];

    function buildTimeCounterName(streamName){
    	return streamName+"TimeCounter";
	}

    function getLostTimeCounterFor(streamName){
		return global[buildTimeCounterName(streamName)];
	}

	function getTotalLostTime(){
    	let time = 0;
		for(let i=0; i<watchedStream.length; i++){
			time += getLostTimeCounterFor(watchedStream[i]);
		}
		return time;
	}

    function enableLostTimeCounterFor(streamName){
    	let globalFlag = buildTimeCounterName(streamName);

		if(typeof global[globalFlag] === "undefined"){
			let write = process[streamName].write;
			global[globalFlag] = 0;

			process[streamName].write = function(...args){
				let start = process.hrtime();
				write.call(process.stdout, ...args);
				let diff = process.hrtime(start);
				global[globalFlag] += (diff[0] * 1e9 / 1e6)+1;
			}
		}
	}

	for(let i=0; i<watchedStream.length; i++){
		enableLostTimeCounterFor(watchedStream[i]);
	}

	function getTimeoutTestFactor(){
	    let multiplyFactor = process.env.DOUBLE_CHECK_TIMEOUT_FACTOR || 1;
	    if(multiplyFactor < 1){
	        multiplyFactor = 1;
        }
	    return multiplyFactor;
    }

    if (typeof global.timeoutUntilBegin === "undefined") {
        global.timeoutUntilBegin = setTimeout(function () {
            if (!beginWasCalled) {
                sf.assert.begin("asset.begin was not called, the exit time for the test is automatically set to 2 seconds. asset.callback can increase this time");
            }
        }, 1000);
    } else {
        console.trace("DoubleCheck was evaluated atleast 2 times! Maybe it was required from disk instead of bundles.");
    }


    /**
     * Registering assert for printing a message and asynchronously printing all logs from logger.dumpWhys.
     * @param message {String} - message to be recorded
     * @param cleanFunctions {Function} - cleaning function
     * @param timeout {Number} - number of milliseconds for the timeout check. Default to 500ms.
     */
    sf.assert.addCheck('forceFailedTest', function (message, err) {
        console.error("Test should fail because:", message, err);
        __failWasAlreadyGenerated = true;
    });

    /**
     * Registering assert for printing a message and asynchronously printing all logs from logger.dumpWhys.
     * @param message {String} - message to be recorded
     * @param cleanFunctions {Function} - cleaning function
     * @param timeout {Number} - number of milliseconds for the timeout check. Default to 500ms.
     */
    sf.assert.addCheck('begin', function (message, cleanFunctions, timeout) {
        //logger.recordAssert(message);

        if(typeof cleanFunctions === "number"){
            timeout = cleanFunctions;
            cleanFunctions = function(){};
        }
        beginWasCalled = true;
        console.log(message);
        sf.assert.end(cleanFunctions, timeout, true);
    });
    sf.assert.begin         = sf.assert.begin;

    function recordFail(...args) { //record fail only once
        if (!__failWasAlreadyGenerated) {
            __failWasAlreadyGenerated = true;
            logger.recordAssert(...args);
        }
    }

    function delayEnd(message, milliseconds) {
        if (!beginWasCalled && timeoutUntilBegin) {
            clearTimeout(timeoutUntilBegin);
            //sf.assert.begin(message, null, timerOffset+milliseconds);
        }
    }

    /**
     * Registering assert for evaluating a value to null. If check fails, the assertFail is invoked.
     * @param explanation {String} - failing reason message in case the assert fails
     */
    sf.exceptions.register('assertFail', function (explanation) {
        const message = "Assert or invariant has failed " + (explanation ? explanation : "");
        const err = new Error(message);
        err.isFailedAssert = true;
        recordFail('[Fail] ' + message, err, true);
        throw err;
    });

    /**
     * Registering assert for equality. If check fails, the assertFail is invoked.
     * @param v1 {String|Number|Object} - first value
     * @param v1 {String|Number|Object} - second value
     * @param explanation {String} - failing reason message in case the assert fails.
     */
    sf.assert.addCheck('equal', function (v1, v2, explanation) {
        if (v1 !== v2) {
            if (!explanation) {
                explanation = "Assertion failed: [" + v1 + " !== " + v2 + "]";
            }
            sf.exceptions.assertFail(explanation);
        }
    });

    /**
     * Registering assert for inequality. If check fails, the assertFail is invoked.
     * @param v1 {String|Number|Object} - first value
     * @param v1 {String|Number|Object} - second value
     * @param explanation {String} - failing reason message in case the assert fails
     */
    sf.assert.addCheck('notEqual', function (v1, v2, explanation) {
        if (v1 === v2) {
            if (!explanation) {
                explanation = " [" + v1 + " == " + v2 + "]";
            }
            sf.exceptions.assertFail(explanation);
        }
    });

    /**
     * Registering assert for evaluating an expression to true. If check fails, the assertFail is invoked.
     * @param b {Boolean} - result of an expression
     * @param explanation {String} - failing reason message in case the assert fails
     */
    sf.assert.addCheck('true', function (b, explanation) {
        if (!b) {
            if (!explanation) {
                explanation = " expression is false but is expected to be true";
            }
            sf.exceptions.assertFail(explanation);
        }
    });

    /**
     * Registering assert for evaluating an expression to false. If check fails, the assertFail is invoked.
     * @param b {Boolean} - result of an expression
     * @param explanation {String} - failing reason message in case the assert fails
     */
    sf.assert.addCheck('false', function (b, explanation) {
        if (b) {
            if (!explanation) {
                explanation = " expression is true but is expected to be false";
            }
            sf.exceptions.assertFail(explanation);
        }
    });

    /**
     * Registering assert for evaluating a value to null. If check fails, the assertFail is invoked.
     * @param b {Boolean} - result of an expression
     * @param explanation {String} - failing reason message in case the assert fails
     */
    sf.assert.addCheck('isNull', function (v1, explanation) {
        if (v1 !== null) {
            sf.exceptions.assertFail(explanation);
        }
    });

    /**
     * Registering assert for evaluating a value to be not null. If check fails, the assertFail is invoked.
     * @param b {Boolean} - result of an expression
     * @param explanation {String} - failing reason message in case the assert fails
     */
    sf.assert.addCheck('notNull', function (v1, explanation) {
        if (v1 === null) {
            sf.exceptions.assertFail(explanation);
        }
    });

    /**
     * Checks if all properties of the second object are own properties of the first object.
     * @param firstObj {Object} - first object
     * @param secondObj{Object} - second object
     * @returns {boolean} - returns true, if the check has passed or false otherwise.
     */
    function objectHasFields(firstObj, secondObj) {
        for (let field in secondObj) {
            if (firstObj.hasOwnProperty(field)) {
                if (firstObj[field] !== secondObj[field]) {
                    return false;
                }
            } else {
                return false;
            }
        }
        return true;
    }

    function objectsAreEqual(firstObj, secondObj) {
        let areEqual = true;
        if (firstObj !== secondObj) {
            if (typeof firstObj !== typeof secondObj) {
                areEqual = false;
            } else if (Array.isArray(firstObj) && Array.isArray(secondObj)) {
                firstObj.sort();
                secondObj.sort();
                if (firstObj.length !== secondObj.length) {
                    areEqual = false;
                } else {
                    for (let i = 0; i < firstObj.length; ++i) {
                        if (!objectsAreEqual(firstObj[i], secondObj[i])) {
                            areEqual = false;
                            break;
                        }
                    }
                }
            } else if ((typeof firstObj === 'function' && typeof secondObj === 'function') ||
                (firstObj instanceof Date && secondObj instanceof Date) ||
                (firstObj instanceof RegExp && secondObj instanceof RegExp) ||
                (firstObj instanceof String && secondObj instanceof String) ||
                (firstObj instanceof Number && secondObj instanceof Number)) {
                areEqual = firstObj.toString() === secondObj.toString();
            } else if (typeof firstObj === 'object' && typeof secondObj === 'object') {
                areEqual = objectHasFields(firstObj, secondObj);
                // isNaN(undefined) returns true
            } else if (isNaN(firstObj) && isNaN(secondObj) && typeof firstObj === 'number' && typeof secondObj === 'number') {
                areEqual = true;
            } else {
                areEqual = false;
            }
        }

        return areEqual;
    }

    /**
     * Registering assert for evaluating if all properties of the second object are own properties of the first object.
     * If check fails, the assertFail is invoked.
     * @param firstObj {Object} - first object
     * @param secondObj{Object} - second object
     * @param explanation {String} - failing reason message in case the assert fails
     */
    sf.assert.addCheck("objectHasFields", function (firstObj, secondObj, explanation) {
        if (!objectHasFields(firstObj, secondObj)) {
            sf.exceptions.assertFail(explanation);
        }
    });

    /**
     * Registering assert for evaluating if all element from the second array are present in the first array.
     * Deep comparison between the elements of the array is used.
     * If check fails, the assertFail is invoked.
     * @param firstArray {Array}- first array
     * @param secondArray {Array} - second array
     * @param explanation {String} - failing reason message in case the assert fails
     */
    sf.assert.addCheck("arraysMatch", function (firstArray, secondArray, explanation) {
        if (firstArray.length !== secondArray.length) {
            sf.exceptions.assertFail(explanation);
        } else {
            const result = objectsAreEqual(firstArray, secondArray);
            // const arraysDontMatch = secondArray.every(element => firstArray.indexOf(element) !== -1);
            // let arraysDontMatch = secondArray.some(function (expectedElement) {
            //     let found = firstArray.some(function(resultElement){
            //         return objectHasFields(resultElement,expectedElement);
            //     });
            //     return found === false;
            // });

            if (!result) {
                sf.exceptions.assertFail(explanation);
            }
        }
    });


    /**
     * Registering assert for evaluating if all the properties from the second object are present in the first object.
     * Deep comparison between the properties of the object is used.
     * If check fails, the assertFail is invoked.
     * @param firstObj {Object}- first object
     * @param secondObj {Object} - second object
     * @param explanation {String} - failing reason message in case the assert fails
     */
    sf.assert.addCheck("objectsAreEqual", function (firstObj, secondObj, explanation) {
        const result = objectsAreEqual(firstObj, secondObj);
        if (!result) {
            sf.exceptions.assertFail(explanation);
        }
    });

    // added mainly for test purposes, better test frameworks like mocha could be much better

    /**
     * Registering assert for checking if a function is failing.
     * If the function is throwing an exception, the test is passed or failed otherwise.
     * @param testName {String} - test name or description
     * @param func {Function} - function to be invoked
     */
    sf.assert.addCheck('fail', function (testName, func) {
        try {
            func();
            recordFail("[Fail] " + testName);
        } catch (err) {
            logger.recordAssert("[Pass] " + testName);
        }
    });

    /**
     * Registering assert for checking if a function is executed with no exceptions.
     * If the function is not throwing any exception, the test is passed or failed otherwise.
     * @param testName {String} - test name or description
     * @param func {Function} - function to be invoked
     */
    sf.assert.addCheck('pass', function (testName, func) {
        try {
            func();
            logger.recordAssert("[Pass] " + testName);
        } catch (err) {
            recordFail("[Fail] " + testName, err.stack);
        }
    });

    /**
     * Alias for the pass assert.
     */
    sf.assert.alias('test', 'pass');

    /**
     * Registering assert for checking if a callback function is executed before timeout is reached without any exceptions.
     * If the function is throwing any exception or the timeout is reached, the test is failed or passed otherwise.
     * @param testName {String} - test name or description
     * @param func {Function} - function to be invoked
     * @param timeout {Number} - number of milliseconds for the timeout check. Default to 500ms.
     */
    sf.assert.addCheck('callback', function (testName, func, timeout) {

        if (!func || typeof func != "function") {
            throw new Error("Wrong usage of assert.callback!");
        }

        if (!timeout) {
            timeout = 500;
        }

        __assetsCounter++;

        let passed = false;

        function resolution(){
            __assetsCounter--;
            if (__assetsCounter === 0) {
                //small tweak to eliminate potential not necessary timeout until the test end
                sf.assert.end(undefined, 0, true);
            }
        }

        function callback() {
            if (!passed) {
                passed = true;
                logger.recordAssert("[Pass] " + testName);
                successTest();
            } else {
                recordFail("[Fail (multiple calls)] " + testName);
            }
            resolution();
        }

        timeout = timeout*getTimeoutTestFactor();
        setTimeout(successTest, timeout);
        delayEnd(testName, timeout + 100);

        try {
            func(callback);
        } catch (err) {
            recordFail("[Fail] " + testName, err, true);
        }

        function successTest(force) {
            setTimeout(()=>{
                if (!passed) {
                    logger.recordAssert("[Fail Timeout] " + testName);
                    resolution();
                }
            }, getTotalLostTime()*getTimeoutTestFactor());
        }

    });

    /**
     * Registering assert for checking if an array of callback functions are executed in a waterfall manner,
     * before timeout is reached without any exceptions.
     * If any of the functions is throwing any exception or the timeout is reached, the test is failed or passed otherwise.
     * @param testName {String} - test name or description
     * @param func {Function} - function to be invoked
     * @param timeout {Number} - number of milliseconds for the timeout check. Default to 500ms.
     */
    sf.assert.addCheck('steps', function (testName, arr, timeout) {
        if (!timeout) {
            timeout = 500;
        }

        let currentStep = 0;
        let passed = false;

        function next() {
            if (currentStep === arr.length) {
                passed = true;
                logger.recordAssert("[Pass] " + testName);
                return;
            }

            const func = arr[currentStep];
            currentStep++;
            try {
                func(next);
            } catch (err) {
                recordFail("[Fail] " + testName + " [at step " + currentStep + "]", err);
            }
        }

        function successTest(force) {
            if (!passed) {
                recordFail("[Fail Timeout] " + testName + " [at step " + currentStep + "]");
            }
        }

        setTimeout(successTest, timeout);
        // delayEnd(testName, timeout + 100);
        next();
    });

    /**
     * Alias for the steps assert.
     */
    sf.assert.alias('waterfall', 'steps');


    let cleaningArray = [];
    /**
     * Registering a cleaning function
     * @param func {Function} - function to be invoked
     */
    sf.assert.addCheck('addCleaningFunction', function (func) {
        cleaningArray.push(func);
    });

    /**
     * Registering a cleaning function
     * @param func {Function} - function to be invoked
     */
    sf.assert.addCheck('disableCleanings', function (func) {
        cleaningArray = [];
    });

    sf.assert.addCheck('hashesAreEqual', function (hash1, hash2) {
        if (!Array.isArray(hash1) && !Array.isArray(hash2)) {
            return hash1 === hash2;
        }

        if (!Array.isArray(hash1) || !Array.isArray(hash2)) {
            return false;
        }

        hash1.sort();
        hash2.sort();
        for (let i in hash1) {
            if (hash1[i] !== hash2[i]) {
                return false;
            }
        }

        return true;
    });

    /**
     * Registering assert for asynchronously printing all execution summary from logger.dumpWhys.
     * @param message {String} - message to be recorded
     * @param timeout {Number} - number of milliseconds for the timeout check. Default to 500ms.
     */
    sf.assert.addCheck('end', function (cleaningFunction, timeout, silence) {
        if (!timeout) {
            timeout = 1000;
        }

        function handler() {
            if (logger.dumpWhys) {
                logger.dumpWhys().forEach(function (c) {
                    const executionSummary = c.getExecutionSummary();
                    console.log(JSON.stringify(executionSummary, null, 4));
                });
            }

            if (!silence) {
                console.log("Forcing exit after", timeout, "ms");
            }

            setTimeout(function () {
                if (__failWasAlreadyGenerated || __assetsCounter != 0) {
                    process.exit(1);
                } else {
                    process.exit(0);
                }
            }, 1000);

            cleaningArray.forEach(function (func) {
                func();
            });

            if (cleaningFunction) {
                cleaningFunction();
            }
        }

        setTimeout(handler, timeout);
    });


    /**
     * Registering performance assertion based on a configuration
     * @param config {object} - containing 3 fields: @timeOut , @minRatePerSecond and @testFunction
     * @param callback {function} - a functioning returning errors or a result object containing statistics about execution, and in particular an @actualRate field
     */
    sf.assert.addCheck("performance", function(config, callback){
        let testEnded = false;

        let result ={actualRate:0};
        let errors = [];
        let successfulTestsCounter = 0;

        if(typeof config.testFunction !== "function"){
            throw new Error("config.testFunction should be a function");
        }

        function runTests(counter, end) {
            for(let i =0;i<counter;i++){
                setTimeout(function(){
                    config.testFunction(end);
                }, 0);
            }
        }

        function endTest(err){
            if(err){
                errors.push(err);
            }
            successfulTestsCounter++;
            runTests(1, endTest);
        }




        let startTime = Date.now();

        setTimeout(function(){
            testEnded = true;
            let endTime = Date.now();
            let actualNumberOfSeconds = (endTime - startTime) / 1000;
            result.actualRate = Math.floor(successfulTestsCounter / actualNumberOfSeconds);
            callback(errors.length == 0?undefined:errors, result);
        }, config.timeOut);

        runTests(config.parallelCalls, endTest);

    });


    sf.assert.end           = sf.assert.end;
    sf.assert.performance   = sf.assert.performance;

};
}).call(this)}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/double-check/lib/standardChecks.js":[function(require,module,exports){
/*
    checks are like asserts but are intended to be used in production code to help debugging and signaling wrong behaviours

 */

exports.init = function(sf){
    sf.exceptions.register('checkFail', function(explanation, err){
        var stack;
        if(err){
            stack = err.stack;
        }
        console.log("Check failed ", explanation, stack);
    });

    sf.check.addCheck('equal', function(v1 , v2, explanation){

        if(v1 !== v2){
            if(!explanation){
                explanation =  " ["+ v1 + " != " + v2 + "]";
            }

            sf.exceptions.checkFail(explanation);
        }
    });


    sf.check.addCheck('true', function(b, explanation){
        if(!b){
            if(!explanation){
                explanation =  " expression is false but is expected to be true";
            }

            sf.exceptions.checkFail(explanation);
        }
    });


    sf.check.addCheck('false', function(b, explanation){
        if(b){
            if(!explanation){
                explanation =  " expression is true but is expected to be false";
            }

            sf.exceptions.checkFail(explanation);
        }
    });

    sf.check.addCheck('notequal', function(v1 , v2, explanation){
        if(v1 == v2){
            if(!explanation){
                explanation =  " ["+ v1 + " == " + v2 + "]";
            }
            sf.exceptions.checkFail(explanation);
        }
    });


    /*
        added mainly for test purposes, better test frameworks like mocha could be much better :)
    */
    sf.check.addCheck('fail', function(testName ,func){
        try{
            func();
            console.log("[Fail] " + testName );
        } catch(err){
            console.log("[Pass] " + testName );
        }
    });


    sf.check.addCheck('pass', function(testName ,func){
        try{
            func();
            console.log("[Pass] " + testName );
        } catch(err){
            console.log("[Fail] " + testName  ,  err.stack);
        }
    });


    sf.check.alias('test','pass');


    sf.check.addCheck('callback', function(testName ,func, timeout){
        if(!timeout){
            timeout = 500;
        }
        var passed = false;
        function callback(){
            if(!passed){
                passed = true;
                console.log("[Pass] " + testName );
                SuccessTest();
            } else {
                console.log("[Fail (multiple calls)] " + testName );
            }
        }
        try{
            func(callback);
        } catch(err){
            console.log("[Fail] " + testName  ,  err.stack);
        }

        function SuccessTest(force){
            if(!passed){
                console.log("[Fail Timeout] " + testName );
            }
        }

        setTimeout(SuccessTest, timeout);
    });


    sf.check.addCheck('steps', function(testName , arr, timeout){
        var  currentStep = 0;
        var passed = false;
        if(!timeout){
            timeout = 500;
        }

        function next(){
            if(currentStep === arr.length){
                passed = true;
                console.log("[Pass] " + testName );
                return ;
            }
            var func = arr[currentStep];
            currentStep++;
            try{
                func(next);
            } catch(err){
                console.log("[Fail] " + testName  ,"\n\t" , err.stack + "\n\t" , " [at step ", currentStep + "]");
            }
        }

        function SuccessTest(force){
            if(!passed){
                console.log("[Fail Timeout] " + testName + "\n\t" , " [at step ", currentStep+ "]");
            }
        }

        setTimeout(SuccessTest, timeout);
        next();
    });

    sf.check.alias('waterfall','steps');
    sf.check.alias('notEqual','notequal');

    sf.check.addCheck('end', function(timeOut, silence){
        if(!timeOut){
            timeOut = 1000;
        }

        setTimeout(function(){
            if(!silence){
                console.log("Forcing exit after", timeOut, "ms");
            }
            process.exit(0);
        }, timeOut);
    });


    sf.check.addCheck('begin', function(message, timeOut){
        console.log(message);
        sf.check.end(timeOut, true);
    });


};
},{}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/double-check/lib/standardExceptions.js":[function(require,module,exports){
exports.init = function(sf){
    /**
     * Registering unknown exception handler.
     */
    sf.exceptions.register('unknown', function(explanation){
        explanation = explanation || "";
        const message = "Unknown exception" + explanation;
        throw(message);
    });

    /**
     * Registering resend exception handler.
     */
    sf.exceptions.register('resend', function(exceptions){
        throw(exceptions);
    });

    /**
     * Registering notImplemented exception handler.
     */
    sf.exceptions.register('notImplemented', function(explanation){
        explanation = explanation || "";
        const message = "notImplemented exception" + explanation;
        throw(message);
    });

    /**
     * Registering security exception handler.
     */
    sf.exceptions.register('security', function(explanation){
        explanation = explanation || "";
        const message = "security exception" + explanation;
        throw(message);
    });

    /**
     * Registering duplicateDependency exception handler.
     */
    sf.exceptions.register('duplicateDependency', function(variable){
        variable = variable || "";
        const message = "duplicateDependency exception" + variable;
        throw(message);
    });
};
},{}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/double-check/lib/standardLogs.js":[function(require,module,exports){
const LOG_LEVELS = {
    HARD_ERROR: 0,  // system level critical error: hardError
    ERROR: 1,  // potentially causing user's data loosing error: error
    ASSERT_FAIL: 1,  // an assert fails
    LOG_ERROR: 2,  // minor annoyance, recoverable error:   logError
    UX_ERROR: 3,  // user experience causing issues error:  uxError
    WARN: 4,  // warning,possible isues but somehow unclear behaviour: warn
    INFO: 5,  // store general info about the system working: info
    DEBUG: 6,  // system level debug: debug
    LOCAL_DEBUG: 7,  // local node/service debug: ldebug
    USER_DEBUG: 8,  // user level debug; udebug
    DEV_DEBUG: 9,  // development time debug: ddebug
    WHYS: 10, // whyLog for code reasoning
    TEST_RESULT: 11, // testResult to log running tests
};

exports.init = function (sf) {

    /**
     * Records log messages from various use cases.
     * @param record {String} - log message.
     */
    sf.logger.record = function (record) {
        const triggerStrings = ["pskruntime", "double-check", "psklogger", "standardGlobalSymbols"];
        let displayOnConsole = true;
        if (process.send) {
            process.send(record);
            displayOnConsole = false;
        }

        function removeLines(str, nb) {
            function removeLine(str,  force) {
                let pos = str.indexOf("\n");
                let willBeRemoved = str.slice(0, pos);
                if (!force) {
                    let foundMatch = false;
                    for(let i=0; i< triggerStrings.length;i++){
                        let item = triggerStrings[i];
                        if (willBeRemoved.indexOf(item) != -1) {
                            foundMatch = true;
                        }
                    }
                    if (!foundMatch) {
                        throw foundMatch;
                    }
                }
                return str.slice(pos + 1, str.length);
            }

            let ret = str;
            for (let v = 0; v < nb; v++) {
                try {
                    ret = removeLine(ret, v==0);
                } catch (err) {
                    // nothing... exit for
                }
            }
            return "Stack:\n"+ret;
        }

        if (displayOnConsole) {
            //const prettyLog = JSON.stringify(record, null, 2);
            //console.log(prettyLog);
            console.log(record.message);
            if (record.stack) {
                var pos = record.stack.indexOf("\n");
                var message = record.stack.slice(0, pos);
                if(record.level<=LOG_LEVELS.ERROR){
                    console.error(message);
                    console.error(removeLines(record.stack, 3));
                } else {
                    console.log(message);
                    console.log(removeLines(record.stack, 3));
                }
            }
        }
    };

    /**
     * Adding case for logging system level critical errors.
     */
    sf.logger.addCase('hardError', function (message, exception, args, pos, data) {
        sf.logger.record(createDebugRecord(LOG_LEVELS.HARD_ERROR, 'systemError', message, exception, true, args, pos, data));
    }, [
        {
            'message': 'explanation'
        }
    ]);

    /**
     * Adding case for logging potentially causing user's data loosing errors.
     */
    sf.logger.addCase('error', function (message, exception, args, pos, data) {
        sf.logger.record(createDebugRecord(LOG_LEVELS.ERROR, 'error', message, exception, true, args, pos, data));
    }, [
        {
            'message': 'explanation'
        },
        {
            'exception': 'exception'
        }
    ]);

    /**
     * Adding case for logging minor annoyance, recoverable errors.
     */
    sf.logger.addCase('logError', function (message, exception, args, pos, data) {
        sf.logger.record(createDebugRecord(LOG_LEVELS.LOG_ERROR, 'logError', message, exception, true, args, pos, data));
    }, [
        {
            'message': 'explanation'
        },
        {
            'exception': 'exception'
        }
    ]);

    /**
     * Adding case for logging user experience causing issues errors.
     */
    sf.logger.addCase('uxError', function (message) {
        sf.logger.record(createDebugRecord(LOG_LEVELS.UX_ERROR, 'uxError', message, null, false));
    }, [
        {
            'message': 'explanation'
        }
    ]);

    /**
     * Adding case for logging throttling messages.
     */
    sf.logger.addCase('throttling', function (message) {
        sf.logger.record(createDebugRecord(LOG_LEVELS.WARN, 'throttling', message, null, false));
    }, [
        {
            'message': 'explanation'
        }
    ]);

    /**
     * Adding case for logging warning, possible issues, but somehow unclear behaviours.
     */
    sf.logger.addCase('warning', function (message) {
        sf.logger.record(createDebugRecord(LOG_LEVELS.WARN, 'warning', message, null, false, arguments, 0));
    }, [
        {
            'message': 'explanation'
        }
    ]);

    sf.logger.alias('warn', 'warning');

    /**
     * Adding case for logging general info about the system working.
     */
    sf.logger.addCase('info', function (message) {
        sf.logger.record(createDebugRecord(LOG_LEVELS.INFO, 'info', message, null, false, arguments, 0));
    }, [
        {
            'message': 'explanation'
        }
    ]);

    /**
     * Adding case for logging system level debug messages.
     */
    sf.logger.addCase('debug', function (message) {
        sf.logger.record(createDebugRecord(LOG_LEVELS.DEBUG, 'debug', message, null, false, arguments, 0));
    }, [
        {
            'message': 'explanation'
        }
    ]);


    /**
     * Adding case for logging local node/service debug messages.
     */
    sf.logger.addCase('ldebug', function (message) {
        sf.logger.record(createDebugRecord(LOG_LEVELS.LOCAL_DEBUG, 'ldebug', message, null, false, arguments, 0));
    }, [
        {
            'message': 'explanation'
        }
    ]);

    /**
     * Adding case for logging user level debug messages.
     */
    sf.logger.addCase('udebug', function (message) {
        sf.logger.record(createDebugRecord(LOG_LEVELS.USER_DEBUG, 'udebug', message, null, false, arguments, 0));
    }, [
        {
            'message': 'explanation'
        }
    ]);

    /**
     * Adding case for logging development debug messages.
     */
    sf.logger.addCase('devel', function (message) {
        sf.logger.record(createDebugRecord(LOG_LEVELS.DEV_DEBUG, 'devel', message, null, false, arguments, 0));
    }, [
        {
            'message': 'explanation'
        }
    ]);

    /**
     * Adding case for logging "whys" reasoning messages.
     */
    sf.logger.addCase("logWhy", function (logOnlyCurrentWhyContext) {
        sf.logger.record(createDebugRecord(LOG_LEVELS.WHYS, 'logwhy', undefined, undefined, undefined, undefined, undefined, undefined, logOnlyCurrentWhyContext));
    });

    /**
     * Adding case for logging asserts messages to running tests.
     */
    sf.logger.addCase("recordAssert", function (message, error, showStack) {
        if(error || showStack){
            sf.logger.record(createDebugRecord(LOG_LEVELS.ASSERT_FAIL, 'assert', message, error, showStack));
        } else {
            sf.logger.record(createDebugRecord(LOG_LEVELS.TEST_RESULT, 'assert', message, error, showStack));
        }
    });

    /**
     * Generic method to create structured debug records based on the log level.
     * @param level {Number} - number from 1-11, used to identify the level of attention that a log entry should get from operations point of view
     * @param type {String} - identifier name for log type
     * @param message {String} - description of the debug record
     * @param exception {String} - exception details if any
     * @param saveStack {Boolean} - if set to true, the exception call stack will be added to the debug record
     * @param args {Array} - arguments of the caller function
     * @param pos {Number} - position
     * @param data {String|Number|Array|Object} - payload information
     * @param logOnlyCurrentWhyContext - if whys is enabled, only the current context will be logged
     * @returns Debug record model {Object} with the following fields:
     * [required]: level: *, type: *, timestamp: number, message: *, data: * and
     * [optional]: stack: *, exception: *, args: *, whyLog: *
     */
    function createDebugRecord(level, type, message, exception, saveStack, args, pos, data, logOnlyCurrentWhyContext) {

        var ret = {
            level: level,
            type: type,
            timestamp: (new Date()).getTime(),
            message: message
        };

        if(data){
            ret.data = data;
        }

        if (saveStack) {
            var stack = '';
            if (exception) {
                stack = exception.stack;
            } else {
                stack = (new Error()).stack;
            }
            ret.stack = stack;
        }

        if (exception) {
            ret.exception = exception.message;
        }

        if (args) {
            ret.args = JSON.parse(JSON.stringify(args));
        }

        if (process.env.RUN_WITH_WHYS) {
            var why = require('whys');
            if (logOnlyCurrentWhyContext) {
                ret['whyLog'] = why.getGlobalCurrentContext().getExecutionSummary();
            } else {
                ret['whyLog'] = why.getAllContexts().map(function (context) {
                    return context.getExecutionSummary();
                });
            }
        }
        return ret;
    }

}
;


},{"whys":false}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/double-check/lib/utils/glob-to-regexp.js":[function(require,module,exports){

// globToRegExp turns a UNIX glob expression into a RegEx expression.
//  Supports all simple glob patterns. Examples: *.ext, /foo/*, ../../path, ^foo.*
// - single character matching, matching ranges of characters etc. group matching are no supported
// - flags are not supported
var globToRegExp = function (globExp) {
    if (typeof globExp !== 'string') {
        throw new TypeError('Glob Expression must be a string!');
    }

    var regExp = "";

    for (let i = 0, len = globExp.length; i < len; i++) {
        let c = globExp[i];

        switch (c) {
            case "/":
            case "$":
            case "^":
            case "+":
            case ".":
            case "(":
            case ")":
            case "=":
            case "!":
            case "|":
                regExp += "\\" + c;
                break;

            case "*":
                // treat any number of "*" as one
                while(globExp[i + 1] === "*") {
                    i++;
                }
                regExp += ".*";
                break;

            default:
                regExp += c;
        }
    }

    // set the regular expression with ^ & $
    regExp = "^" + regExp + "$";

    return new RegExp(regExp);
};

module.exports = globToRegExp;
},{}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/double-check/utils/AsyncDispatcher.js":[function(require,module,exports){

function AsyncDispatcher(finalCallback) {
	let results = [];
	let errors = [];

	let started = 0;

	function markOneAsFinished(err, res) {
		if(err) {
			errors.push(err);
		}

		if(arguments.length > 2) {
			arguments[0] = undefined;
			res = arguments;
		}

		if(typeof res !== "undefined") {
			results.push(res);
		}

		if(--started <= 0) {
            return callCallback();
		}
	}

	function dispatchEmpty(amount = 1) {
		started += amount;
	}

	function callCallback() {
	    if(errors && errors.length === 0) {
	        errors = undefined;
        }

	    if(results && results.length === 0) {
	        results = undefined;
        }

        finalCallback(errors, results);
    }

	return {
		dispatchEmpty,
		markOneAsFinished
	};
}

module.exports = AsyncDispatcher;
},{}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/dsu-wizard/CommandRegistry.js":[function(require,module,exports){
function CommandRegistry(server){
	const URL_PREFIX = require("./constants").URL_PREFIX;

	this.register = (url, method, commandFactory)=>{
		const fullUrl = "/dsu-wizard/:domain"+url+"/:transactionId";
		console.log("Registering url", fullUrl, method);
		server[method](fullUrl, (req, res)=>{
			commandFactory(req, (err, command)=>{
				if(err){
					console.log(err);
					res.statusCode = 500;
					return res.end();
				}

				const transactionManager = require("./TransactionManager");
				transactionManager.addCommandToTransaction(req.params.transactionId, command, (err)=>{
					if(err){
						console.log(err);
						res.statusCode = 500;
						return res.end();
					}

					res.statusCode = 200;
					res.end();
				});
			});
		});
	}
}

module.exports = {
	getRegistry : function(server){
		return new CommandRegistry(server);
	}
};
},{"./TransactionManager":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/dsu-wizard/TransactionManager.js","./constants":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/dsu-wizard/constants.js"}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/dsu-wizard/TransactionManager.js":[function(require,module,exports){
function TransactionsManager(){
	const serverConfig = require("apihub").getServerConfig();
	const config = serverConfig.componentsConfig["dsu-wizard"];

	const WorkerPoolManager = require("./WorkerPoolManager.js");

	const {persistTransaction, getTransaction, getWorkerScript} = require("./TransactionUtils");

	const numberOfWorkers = config.workers || 5;
	const poolManager = new WorkerPoolManager(getWorkerScript(), numberOfWorkers);

	this.persistTransaction = persistTransaction;
	this.getTransaction = getTransaction;

	this.beginTransaction = function(req, callback){
		const crypto = require("pskcrypto");
		const randSize = require("./constants").transactionIdLength;

		let transactionId = crypto.randomBytes(randSize).toString('hex');
		let transaction = {
			id: transactionId,
			commands: [],
			context: {
				result: {},
				dlDomain: req.params.domain,
				domain: req.params.domain,
				options: {useSSIAsIdentifier: false}
			}
		};

		persistTransaction(transaction, (err) => {
			if(err){
				return callback(err);
			}
			callback(undefined, transactionId);
		});
	}

	this.addCommandToTransaction = function(transactionId, command, callback){
		getTransaction(transactionId, (err, transaction)=>{
			if(!transaction || err){
				callback('Transaction could not be found');
			}

			transaction.commands.push(command);
			persistTransaction(transaction, (err)=>{
				if(err){
					return callback(err);
				}
				callback();
			});
		});
	}

	this.closeTransaction = function (transactionId, authorization, callback) {
		getTransaction(transactionId, (err, transaction) => {
			if (typeof transaction === "undefined" || err) {
				return callback(Error('Transaction could not be found'));
			}

			poolManager.runTask({transactionId, authorization}, (err, taskResult)=>{
				if(err){
					return callback(err);
				}

				let {error, result} = taskResult;
				callback(error, result);
			});
		});
	}
}

module.exports = new TransactionsManager();

},{"./TransactionUtils":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/dsu-wizard/TransactionUtils.js","./WorkerPoolManager.js":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/dsu-wizard/WorkerPoolManager.js","./constants":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/dsu-wizard/constants.js","apihub":"apihub","pskcrypto":"pskcrypto"}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/dsu-wizard/TransactionUtils.js":[function(require,module,exports){
const serverConfig = require("apihub").getServerConfig();
const config = serverConfig.componentsConfig["dsu-wizard"];

function persistTransaction(transaction, callback){
	const fs = require("fs");
	let serialization = JSON.stringify(transaction, function(key, value) {
		return typeof value === "function" ? value.toString() : value;
	});
	fs.writeFile(getFileForTransaction(transaction.id), serialization, callback);
}

function clearTransaction(transaction, callback){
	const fs = require("fs");
	fs.unlink(getFileForTransaction(transaction.id), callback);
}

function getFileForTransaction(transactionId){
	let path = require("path");
	const storage = path.join(serverConfig.storage, config.storage);

	const fs = require("fs");
	if (!fs.existsSync(storage)) {
		console.log(`[DSU-Wizard] Creating storage folder at path: <${storage}>`);
		fs.mkdirSync(storage, {recursive: true});
	}

	return path.join(storage, transactionId);
}

function getTransaction(transactionId, callback){
	function testIfFunction(value) {
		return /^function.*?\(.*?\)\s*\{(\s*|.*)*\}$/.test(value);
	}

	function convertStringIntoFunction(value) {
		return eval(`(${value})`);
	}

	const fs = require("fs");
	fs.readFile(getFileForTransaction(transactionId), (err, transactionBuffer)=>{
		let serialization = transactionBuffer.toString();
		let transaction;
		try{
			transaction = JSON.parse(serialization, function(key, value) {
				if (testIfFunction(value)) {
					return convertStringIntoFunction(value);
				} else {
					return value;
				}
			});
		}catch(err){
			return callback(err);
		}
		return callback(undefined, transaction);
	});
}

function initializeWorker(){

	function TransactionWorker(){
		const { parentPort, isMainThread } = require('worker_threads');

		if(isMainThread){
			throw Error("This script is not meant to be ran in a main thread!");
		}

		let busy = false;
		function deliverMessage(message){
			busy = false;
			parentPort.postMessage(message);
		}

		parentPort.on('message', (message) => {
			//console.log("Received message", message);
			if(busy){
				return parentPort.postMessage({ error: Error("Worker still busy...") });
			}
			if(typeof message.transactionId !== "undefined"){
				busy = true;
				const {transactionId, authorization} = message;

				return getTransaction(transactionId, (err, transaction)=>{
					if(err){
						return deliverMessage({error: err});
					}
					processTransaction(transaction, authorization, (err, result)=>{
						deliverMessage({ error: err, result });
					});
				});
			}
			deliverMessage({ error: Error("Unknown message type") });
		});

		function processTransaction(transaction, authorization, callback){
			let newKeySSIJustInitialised = false;
			if (typeof transaction === "undefined") {
				callback(Error('Transaction could not be found'));
			}

			function authInterceptor(target, callback){
				const {url, headers} = target;
				if(typeof authorization !== "undefined"){
					headers['authorization'] = authorization;
				}else{
					console.log(`Missing authorization info. Not able to set authorization header for req ${url}. Request could fail if authorization not provided!`);
				}

				//console.log("Setting authorization header for url", headers, url);
				return callback(undefined, target);
			}

			function enableAuthorization(){
				let http = require("opendsu").loadApi("http");
				http.registerInterceptor(authInterceptor);
			}

			function resetAuthorization(){
				let http = require("opendsu").loadApi("http");
				http.unregisterInterceptor(authInterceptor);
			}

			const executeCommand = () => {
				let command = transaction.commands.pop();
				//console.log("Preparing to execute command", command);
				if (!command) {
					if (transaction.commands.length === 0) {
						// Anchor all changes in this transaction
						return transaction.context.dsu.doAnchoring((err, result) => {
							if (err) {
								return callback(new Error(`Failed to anchor DSU`, err));
							}
							return transaction.context.dsu.getKeySSIAsString((err, keySSI)=>{
								resetAuthorization();
								callback(err, keySSI);
							});
						});
					}
				}

				let commandMethod = command.method(...command.args);
				commandMethod.execute(transaction.context, (err) => {
					if (err) {
						return callback(new Error(`Failed to execute command ${command.type} with args [${command.args}]`, err));
					}

					executeCommand();
				});
			}

			if(typeof config.bundle !== "undefined"){
				require(config.bundle);
			}

			const openDSU = require("opendsu");
			const keyssi = openDSU.loadApi("keyssi");

			let resolverMethod = 'loadDSU';
			if (typeof transaction.context.keySSI === "undefined") {
				transaction.context.keySSI = keyssi.createTemplateSeedSSI(transaction.context.domain);
				resolverMethod = 'createDSU';
				newKeySSIJustInitialised = true;
			}

			if (transaction.context.forceNewDSU) {
				resolverMethod = 'createDSU';
			}

			const dsuOptions = transaction.context.options || {};
			if (typeof dsuOptions.anchoringOptions === 'undefined') {
				dsuOptions.anchoringOptions = {};
			}

			if (typeof dsuOptions.anchoringOptions.decisionFn !== 'function') {
				dsuOptions.anchoringOptions.decisionFn = (brickMap, callback) => {
					// Prevent "auto anchoring" each file
					// Anchoring will be manually triggered
					// when closing the transaction
					callback(false);
				};
			}
			let resolver = openDSU.loadApi("resolver");
			let keyssiutil = openDSU.loadApi("keyssi");

			let initialiseContextDSU = () => {
				enableAuthorization();
				const keyssiSpace = require("opendsu").loadApi("keyssi");
				let ssi = transaction.context.keySSI;
				if(typeof ssi === "string"){
					ssi = keyssiSpace.parse(ssi);
				}
				resolver[resolverMethod](ssi, dsuOptions, (err, dsu) => {
					if (err) {
						return callback(new Error(`Failed to initialize context DSU`, err));
					}
					transaction.context.dsu = dsu;
					//start executing the stored commands from transaction
					executeCommand();
				});
			}

			if (resolverMethod === "createDSU" && !newKeySSIJustInitialised) {
				let testSSI = transaction.context.keySSI;
				if(typeof testSSI === "string"){
					testSSI = keyssiutil.parse(testSSI);
				}
				resolver.loadDSU(testSSI, dsuOptions, (err, dsu) => {
					if (!err && dsu) {
						return callback(new Error("DSU already exist, refusing to overwrite"));
					}
					//a DSU with this Seed does not exist, so it is safe to create one
					initialiseContextDSU();
				});
			} else {
				initialiseContextDSU();
			}
		}
	}

	new TransactionWorker();
}

function getWorkerScript(){
	let script = "";

	script += "const serverConfig = JSON.parse(\'"+JSON.stringify(serverConfig)+"\'); \n";
	script += "const config = serverConfig.componentsConfig[\"dsu-wizard\"]; \n";
	script += `${getTransaction.toString()} ${getFileForTransaction.toString()} (${initializeWorker.toString()})()`;

	return script;
}

module.exports = {getTransaction, getFileForTransaction, clearTransaction, persistTransaction, getWorkerScript};

},{"apihub":"apihub","fs":false,"opendsu":"opendsu","path":false,"worker_threads":false}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/dsu-wizard/WorkerPoolManager.js":[function(require,module,exports){
const workers = {};
const busyWorkers = {};
const retryIntervalTimeout = 1000;

function WorkerPoolManager(script, workerLimit = 5){

	 function getWorker(callback){
		const { Worker } = require('worker_threads');

		function createNewWorker(cb){
			let numberOfWorkers = Object.keys(workers).length;
			if(numberOfWorkers === workerLimit){
				setTimeout(()=>{
					this.getWorker(callback);
				}, retryIntervalTimeout);
			}
			//console.log("Creating a worker for script", script);
			const worker = new Worker(script, { eval: true });
			workers[worker.threadId] = worker;
			return cb(undefined, worker);
		}

		function reserveWorker(){
			const ws = Object.keys(workers);
			const numberOfWorkers = ws.length;
			const busy = Object.keys(busyWorkers);
			const numberOfBusyWorkers = busy.length;

			if((numberOfWorkers === 0 || numberOfWorkers === numberOfBusyWorkers) && numberOfWorkers < workerLimit){
				// no worker available and the workerLimit not reached
				return createNewWorker((err, worker)=>{
					return callback(undefined, worker);
				});
			}

			//searching for a free worker
			for(let i=0; i<numberOfWorkers; i++){
				const workerId = ws[i];
				if(typeof busyWorkers[workerId] === "undefined"){
					const worker = workers[workerId];
					busyWorkers[workerId] = worker;
					return callback(undefined, worker);
				}
			}

			//no free worker available... retrying later
			setTimeout(()=>{
				reserveWorker();
			}, retryIntervalTimeout);
		}

		reserveWorker();
	}

	function releaseWorker(worker){
		busyWorkers[worker.threadId] = undefined;
		delete busyWorkers[worker.threadId];
	}

	this.runTask = function(task, callback){
		getWorker((err, worker) => {
			if(err){
				return callback(err);
			}

			let delivered = false;
			function deliverMessage(err, result){
				if(!delivered){
					delivered = true;
					releaseWorker(worker);
					callback(err, result);
				}else{
					console.log("Something wrong happened during task execution.");
				}
			}

			function messageHandler(message){
				worker.off("message", messageHandler);
				deliverMessage(undefined, message);
			}

			function errorHandler(err){
				//console.log("Caught error", err);
				worker.off("error", errorHandler);
				//if the worker is in unstable state is better to remove it from the workers list
				workers[worker.threadId] = undefined;
				delete workers[worker.threadId];

				deliverMessage(err);
			}

			worker.on("message", messageHandler);
			worker.on("error", errorHandler);

			worker.postMessage(task);

		});
	}
}

module.exports = WorkerPoolManager;
},{"worker_threads":false}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/dsu-wizard/commands/addFile.js":[function(require,module,exports){
function AddFile(server){
	const pathName = "path";
	const path = require(pathName);
	const fsName = "fs";
	const fs = require(fsName);
	const osName = "os";
	const os = require(osName);

	const utils = require("../utils");

	function createAddFileCommand(filePath, dossierPath){
		const command = {
			execute: function(context, callback){
				context.dsu.addFile(filePath, dossierPath, (err)=>{
					if(err){
						return callback(err);
					}
					//once the file is added into dossier we remove it.
					const fs = require("fs");
					fs.unlink(filePath, ()=>{
						//we ignore errors that can appear during unlink on windows machines
						return callback();
					});
				});
			}
		}

		return command;
	}

	const commandRegistry = require("../CommandRegistry").getRegistry(server);
	commandRegistry.register("/addFile", "post", (req, callback)=>{
		utils.formDataParser(req, (err, formData)=>{
			if(err){
				return callback(err);
			}
			if(formData.length === 0){
				return callback('No files found');
			}

			let fileContent = formData[0].content;
			const crypto = require("pskcrypto");

			const dossierPath = req.headers["x-dossier-path"];
			let tempFileName = crypto.randomBytes(10).toString('hex');

			fs.mkdtemp(path.join(os.tmpdir(), req.params.transactionId), (err, directory) => {
				if (err){
					return callback(err);
				}

				const tempFilePath = path.join(directory, tempFileName);
				const file = fs.createWriteStream(tempFilePath);

				file.write(fileContent);

				let cmd = {
					args: [tempFilePath, dossierPath],
					type: "addFile",
					method: createAddFileCommand
				}

				return callback(undefined, cmd);
			});
		});
	});
}

module.exports = AddFile;
},{"../CommandRegistry":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/dsu-wizard/CommandRegistry.js","../utils":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/dsu-wizard/utils.js","fs":false,"pskcrypto":"pskcrypto"}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/dsu-wizard/commands/copy.js":[function(require,module,exports){
function Copy(server) {
    function createCopyCommand(src, dest) {
        const command = {
            execute: function (context, callback) {
                context.dsu.cloneFolder(src, dest, callback);
            }
        }

        return command;
    }

    const commandRegistry = require("../CommandRegistry").getRegistry(server);
    commandRegistry.register("/copy", "post", (req, callback) => {
        const src = req.headers["x-src-path"];
        const dest = req.headers["x-dest-path"];

        let cmd = {
            args: [src, dest],
            type: "copy",
            method: createCopyCommand
        }

        return callback(undefined, cmd);
    });
}

module.exports = Copy;
},{"../CommandRegistry":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/dsu-wizard/CommandRegistry.js"}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/dsu-wizard/commands/dummyCommand.js":[function(require,module,exports){
module.exports.create = function(name){
	function createExecutableCommand(){
		const command = {
			execute : function(context, callback){
				return callback();
			}
		}
		return command;
	}

	let cmd = {
		args: [],
		type: name,
		method: createExecutableCommand
	}
	return cmd;
}
},{}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/dsu-wizard/commands/index.js":[function(require,module,exports){
const addFile = require("./addFile");
const mount = require("./mount");
const setKeySSI = require("./setKeySSI");
const copy = require("./copy");

module.exports = {
	addFile,
	mount,
	setKeySSI,
	copy
}
},{"./addFile":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/dsu-wizard/commands/addFile.js","./copy":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/dsu-wizard/commands/copy.js","./mount":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/dsu-wizard/commands/mount.js","./setKeySSI":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/dsu-wizard/commands/setKeySSI.js"}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/dsu-wizard/commands/mount.js":[function(require,module,exports){
function mount(server){
	const commandRegistry = require("../CommandRegistry").getRegistry(server);

	commandRegistry.register("/mount", "post", (req, callback)=>{
		const path = req.headers['x-mount-path'];
		const keySSI = req.headers['x-mounted-dossier-seed'];

		if(typeof path === "undefined" || typeof keySSI === "undefined"){
			return callback('Wrong usage of the command');
		}

		function createExecutableCommand(path, keySSI){
			const command = {
				execute : function(context, callback){
					context.dsu.mount(path, keySSI, callback);
				}
			}
			return command;
		}

		let cmd = {
			args: [path, keySSI],
			type: "mount",
			method: createExecutableCommand
		}

		return callback(undefined, cmd);
	});
}

module.exports = mount;
},{"../CommandRegistry":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/dsu-wizard/CommandRegistry.js"}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/dsu-wizard/commands/setKeySSI.js":[function(require,module,exports){


function setKeySSI(server){
	const commandRegistry = require("../CommandRegistry").getRegistry(server);
	const utils = require("../utils");

	commandRegistry.register("/setKeySSI", "post", (req, callback)=>{
		const transactionManager = require("../TransactionManager");
		utils.bodyParser(req, (err)=>{
			if(err){
				return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to parse body`, err));
			}

			transactionManager.getTransaction(req.params.transactionId, (err, transaction) => {
				if (err || !transaction) {
					return callback(err);
				}
				transaction.context.keySSI = req.body;
				transaction.context.options.useSSIAsIdentifier = true;
				transaction.context.forceNewDSU = req.headers['x-force-dsu-create'];
				transactionManager.persistTransaction(transaction, (err) => {
					if (err) {
						return callback(err);
					}

					const command = require("./dummyCommand").create("setKeySSI");
					return callback(undefined, command);
				});
			});
		});
	});
}

module.exports = setKeySSI;
},{"../CommandRegistry":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/dsu-wizard/CommandRegistry.js","../TransactionManager":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/dsu-wizard/TransactionManager.js","../utils":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/dsu-wizard/utils.js","./dummyCommand":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/dsu-wizard/commands/dummyCommand.js"}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/dsu-wizard/constants.js":[function(require,module,exports){
const URL_PREFIX = '/dsu-wizard';
const transactionIdLength = 32;

module.exports = { URL_PREFIX, transactionIdLength};
},{}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/dsu-wizard/utils.js":[function(require,module,exports){
function bodyParser(req, callback) {
    let bodyContent = '';

    req.on('data', function (dataChunk) {
        bodyContent += dataChunk;
    });

    req.on('end', function () {
        req.body = bodyContent;
        callback(undefined, req.body);
    });

    req.on('error', function (err) {
        callback(err);
    });
}

function formDataParser(req, callback) {
    const buffers = [];
    let formData = [];

    req.on('data', function (dataChunk) {
        buffers.push(dataChunk);
    });

    req.on('end', function () {
        const dataBuf = $$.Buffer.concat(buffers);
        newFormParser(dataBuf, retrieveBoundaryIdentifier(req));
        req.formData = formData;
        callback(undefined, req.formData);
    });

    req.on('error', function (err) {
        callback(err);
    });

    function retrieveBoundaryIdentifier(req){
        let contentType = req.headers["content-type"];
        if(!contentType){
            return;
        }
        const identifier = "boundary=";
        let boundaryIndex = contentType.indexOf(identifier);

        if(boundaryIndex !== -1){
            return contentType.slice(boundaryIndex+identifier.length);
        }
    }

    function newFormParser(data, boundary) {
        //console.log("Read boundary", boundary);
        let boundaryIndexes = [];
        let offset = 0;
        let indexCorrection = 0;

        while(true){
            let index = data.indexOf(boundary, offset);
            if(offset===0 && index > 0){
                //this mechanism is trying to solve the issue when into the header the boundary starts with "----" and
                // into the body starts with "------"
                indexCorrection = index;
            }
            if(index !== -1){
                boundaryIndexes.push(index-indexCorrection);
                offset = index + boundary.length + indexCorrection;
            }else{
                //we need to escape this index discovery loop because we can't find any other boundary so we are done
                break;
            }
        }

        let formItems = [];
        for(let i=0; i<boundaryIndexes.length; i++){
            if(i+1 >= boundaryIndexes.length){
                break;
            }
            let f = data.slice(boundaryIndexes[i]+indexCorrection+boundary.length+"\r\n".length, boundaryIndexes[i+1]);

            //console.log("item", f.toString());
            formItems.push(f);
        }

        for(let i=0; i<formItems.length; i++){
            let parsedItem = {};
            let formItem = formItems[i];

            let testContentDisposition = formItem.indexOf("Content-Disposition:") === 0;

            if(testContentDisposition){
                //we extract the content disposition until the first appearance of the group "\r\n"
                let contentDisposition = formItem.slice(0, formItem.indexOf("\r\n"));
                formItem = formItem.slice(contentDisposition.length+"\r\n".length);

                let metas = contentDisposition.toString().split("; ");
                metas.forEach(meta=>{
                    if(meta.indexOf("name=") === 0){
                        parsedItem.type = meta.replace("name=", "").replace(/\"|'/g, "");
                    }
                    if(meta.indexOf("filename=") === 0){
                        parsedItem.fileName = meta.replace("filename=", "").replace(/\"|'/g, "");
                    }
                })
            }

            let testContentType = formItem.indexOf("Content-Type:") === 0;

            if(testContentType){
                let contentType = formItem.slice(0, formItem.indexOf("\r\n"));
                formItem = formItem.slice(contentType.length+"\r\n".length);

                parsedItem.contentType = contentType.toString().replace("Content-Type: ", "").replace(/\r\n/g, "");
            }

            //no matter if content type line exists or not there is a \r\n before the content
            formItem = formItem.slice("\r\n".length);

            parsedItem.content = formItem.slice(0, formItem.byteLength-"\r\n".length);
            //console.log("ParsedItem", parsedItem);

            formData.push(parsedItem);
        }
    }
}

function redirect(req, res) {
    const URL_PREFIX = require("./constants").URL_PREFIX;
    res.statusCode = 303;
    let redirectLocation = 'index.html';

    if (!req.url.endsWith('/')) {
        redirectLocation = `${URL_PREFIX}/` + redirectLocation;
    }

    res.setHeader("Location", redirectLocation);
    res.end();
}

module.exports = {
    bodyParser,
    formDataParser,
    redirect
}

},{"./constants":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/dsu-wizard/constants.js"}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/key-ssi-resolver/lib/CryptoAlgorithms/CryptoAlgorithmsMixin.js":[function(require,module,exports){
function CryptoAlgorithmsMixin(target) {
    target = target || {};
    const crypto = require("pskcrypto");

    target.hash = (data) => {
        return target.encoding(crypto.hash('sha256', data));
    }

    target.keyDerivation = (password, iterations) => {
        return crypto.deriveKey('aes-256-gcm', password, iterations);
    }

    target.encryptionKeyGeneration = () => {
        const pskEncryption = crypto.createPskEncryption('aes-256-gcm');
        return pskEncryption.generateEncryptionKey();
    }

    target.encryption = (plainData, encryptionKey, options) => {
        const pskEncryption = crypto.createPskEncryption('aes-256-gcm');
        return pskEncryption.encrypt(plainData, encryptionKey, options);
    }

    target.decryption = (encryptedData, decryptionKey, authTagLength, options) => {
        const pskEncryption = crypto.createPskEncryption('aes-256-gcm');
        const utils = require("swarmutils");
        if (!$$.Buffer.isBuffer(decryptionKey) && (decryptionKey instanceof ArrayBuffer || ArrayBuffer.isView(decryptionKey))) {
            decryptionKey = utils.ensureIsBuffer(decryptionKey);
        }
        if (!$$.Buffer.isBuffer(encryptedData) && (decryptionKey instanceof ArrayBuffer || ArrayBuffer.isView(decryptionKey))) {
            encryptedData = utils.ensureIsBuffer(encryptedData);
        }
        return pskEncryption.decrypt(encryptedData, decryptionKey, 16, options);
    }

    target.encoding = (data) => {
        return crypto.pskBase58Encode(data);
    }

    target.decoding = (data) => {
        return crypto.pskBase58Decode(data);
    }

    target.base64Encoding = (data) => {
        return crypto.pskBase64Encode(data);
    }

    target.base64Decoding = (data) => {
        return crypto.pskBase64Decode(data);
    }

    target.keyPairGenerator = () => {
        return crypto.createKeyPairGenerator();
    }

    target.convertPublicKey = (rawPublicKey, options) => {
        const keyGenerator = crypto.createKeyPairGenerator();
        return keyGenerator.convertPublicKey(rawPublicKey, options);
    };

    target.verify = (data, publicKey, signature) => {
        return crypto.verifyETH(data, signature, publicKey);
    }

    target.ecies_encryption = (receiverPublicKey, message) => {
        return crypto.ecies_encrypt(receiverPublicKey, message, target.getConfigForIES())
    };

    target.ecies_decryption = (receiverPrivateKey, encEnvelope) => {
        return crypto.ecies_decrypt(receiverPrivateKey, encEnvelope, target.getConfigForIES());
    };

    target.ecies_encryption_ds = (senderKeyPair, receiverPublicKey, message) => {
        return crypto.ecies_encrypt_ds(senderKeyPair, receiverPublicKey, message, target.getConfigForIES())
    };

    target.ecies_decryption_ds = (receiverPrivateKey, encEnvelope) => {
        return crypto.ecies_decrypt_ds(receiverPrivateKey, encEnvelope, target.getConfigForIES());
    };

    target.ecies_encryption_kmac = (senderKeyPair, receiverPublicKey, message) => {
        return crypto.ecies_encrypt_kmac(senderKeyPair, receiverPublicKey, message, target.getConfigForIES())
    };

    target.ecies_decryption_kmac = (receiverPrivateKey, encEnvelope) => {
        return crypto.ecies_decrypt_kmac(receiverPrivateKey, encEnvelope, target.getConfigForIES());
    };

    let config = {
        curveName: 'secp256k1',
        encodingFormat: 'base64',
        macAlgorithmName: 'sha256',
        macKeySize: 16,
        hashFunctionName: 'sha256',
        hashSize: 32,
        signAlgorithmName: 'sha256',
        symmetricCipherName: 'aes-128-cbc',
        symmetricCipherKeySize: 16,
        ivSize: 16
    };

    target.getConfigForIES = () => {
        return config;
    };

    target.setConfigForIES = (_config) => {
        config = _config;
    }

    return target;
}

module.exports = CryptoAlgorithmsMixin;

},{"pskcrypto":"pskcrypto","swarmutils":"swarmutils"}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/key-ssi-resolver/lib/CryptoAlgorithms/CryptoAlgorithmsRegistry.js":[function(require,module,exports){
const SSITypes = require("../KeySSIs/SSITypes");
const CryptoFunctionTypes = require("./CryptoFunctionTypes");
const CryptoAlgorithmsMixin = require("./CryptoAlgorithmsMixin");
const SeedSSICryptoAlgorithms = require("./SeedSSICryptoAlgorithms");
const cryptoInterfaces = {};

const registerCryptoInterface = (keySSIType, vn, cryptoInterface) => {
    if (typeof cryptoInterfaces[keySSIType] !== "undefined" && typeof cryptoInterfaces[keySSIType][vn] !== "undefined") {
        throw Error(`A crypto interface for Key SSI ${keySSIType} is already registered for version ${vn}`);
    }

    if (typeof cryptoInterfaces[keySSIType] === "undefined") {
        cryptoInterfaces[keySSIType] = {};
    }

    cryptoInterfaces[keySSIType][vn] = cryptoInterface;
};

const getCryptoFunction = (keySSI, algorithmType) => {
    let cryptoFunction;
    try {
        cryptoFunction = cryptoInterfaces[keySSI.getTypeName()][keySSI.getVn()][algorithmType];
    } catch (e) {
        throw Error(`Algorithm type <${algorithmType}> not recognized for <${keySSI.getIdentifier(true)}>`);
    }

    if (typeof cryptoFunction === "undefined") {
        throw Error(`Algorithm type <${algorithmType}> not recognized for <${keySSI.getIdentifier(true)}>`);
    }
    return cryptoFunction;
};

function CryptoAlgorithmsRegistry() {
}

module.exports = new CryptoAlgorithmsRegistry();
CryptoAlgorithmsRegistry.prototype.getHashFunction = (keySSI) => {
    return getCryptoFunction(keySSI, CryptoFunctionTypes.HASH);
};

CryptoAlgorithmsRegistry.prototype.getKeyDerivationFunction = (keySSI) => {
    return getCryptoFunction(keySSI, CryptoFunctionTypes.KEY_DERIVATION);
};

CryptoAlgorithmsRegistry.prototype.getEncryptionFunction = (keySSI) => {
    return getCryptoFunction(keySSI, CryptoFunctionTypes.ENCRYPTION);
};

CryptoAlgorithmsRegistry.prototype.getEncryptionKeyGenerationFunction = (keySSI) => {
    return getCryptoFunction(keySSI, CryptoFunctionTypes.ENCRYPTION_KEY_GENERATION);
};

CryptoAlgorithmsRegistry.prototype.getDecryptionFunction = (keySSI) => {
    return getCryptoFunction(keySSI, CryptoFunctionTypes.DECRYPTION);
};

CryptoAlgorithmsRegistry.prototype.getEncodingFunction = (keySSI) => {
    return getCryptoFunction(keySSI, CryptoFunctionTypes.ENCODING);
};

CryptoAlgorithmsRegistry.prototype.getDecodingFunction = (keySSI) => {
    return getCryptoFunction(keySSI, CryptoFunctionTypes.DECODING);
};

CryptoAlgorithmsRegistry.prototype.getBase64EncodingFunction = (keySSI) => {
    return getCryptoFunction(keySSI, CryptoFunctionTypes.BASE64_ENCODING);
};

CryptoAlgorithmsRegistry.prototype.getBase64DecodingFunction = (keySSI) => {
    return getCryptoFunction(keySSI, CryptoFunctionTypes.BASE64_DECODING);
};

CryptoAlgorithmsRegistry.prototype.getKeyPairGenerator = (keySSI) => {
    return getCryptoFunction(keySSI, CryptoFunctionTypes.KEY_PAIR_GENERATOR);
};

CryptoAlgorithmsRegistry.prototype.getSignFunction = (keySSI) => {
    return getCryptoFunction(keySSI, CryptoFunctionTypes.SIGN);
};

CryptoAlgorithmsRegistry.prototype.getVerifyFunction = (keySSI) => {
    return getCryptoFunction(keySSI, CryptoFunctionTypes.VERIFY);
};

CryptoAlgorithmsRegistry.prototype.getDerivePublicKeyFunction = (keySSI) => {
    return getCryptoFunction(keySSI, CryptoFunctionTypes.DERIVE_PUBLIC_KEY);
};

CryptoAlgorithmsRegistry.prototype.getConvertPublicKeyFunction = (keySSI) => {
    return getCryptoFunction(keySSI, CryptoFunctionTypes.CONVERT_PUBLIC_KEY);
};

CryptoAlgorithmsRegistry.prototype.getCryptoFunction = getCryptoFunction;
CryptoAlgorithmsRegistry.prototype.registerCryptoInterface = registerCryptoInterface;

CryptoAlgorithmsRegistry.prototype.registerCryptoInterface(SSITypes.SEED_SSI, 'v0', new SeedSSICryptoAlgorithms());
CryptoAlgorithmsRegistry.prototype.registerCryptoInterface(SSITypes.PATH_SSI, 'v0', new CryptoAlgorithmsMixin());
CryptoAlgorithmsRegistry.prototype.registerCryptoInterface(SSITypes.WALLET_SSI, 'v0', new SeedSSICryptoAlgorithms());
CryptoAlgorithmsRegistry.prototype.registerCryptoInterface(SSITypes.SREAD_SSI, 'v0', new CryptoAlgorithmsMixin());
CryptoAlgorithmsRegistry.prototype.registerCryptoInterface(SSITypes.SZERO_ACCESS_SSI, 'v0', new CryptoAlgorithmsMixin());

CryptoAlgorithmsRegistry.prototype.registerCryptoInterface(SSITypes.PASSWORD_SSI, 'v0', new CryptoAlgorithmsMixin());
CryptoAlgorithmsRegistry.prototype.registerCryptoInterface(SSITypes.ARRAY_SSI, 'v0', new SeedSSICryptoAlgorithms());
CryptoAlgorithmsRegistry.prototype.registerCryptoInterface(SSITypes.CONST_SSI, 'v0', new SeedSSICryptoAlgorithms());
CryptoAlgorithmsRegistry.prototype.registerCryptoInterface(SSITypes.CONSTANT_ZERO_ACCESS_SSI, 'v0', new CryptoAlgorithmsMixin());
CryptoAlgorithmsRegistry.prototype.registerCryptoInterface(SSITypes.HASH_LINK_SSI, 'v0', new CryptoAlgorithmsMixin());
CryptoAlgorithmsRegistry.prototype.registerCryptoInterface(SSITypes.SYMMETRICAL_ENCRYPTION_SSI, 'v0', new CryptoAlgorithmsMixin());
CryptoAlgorithmsRegistry.prototype.registerCryptoInterface(SSITypes.EMBED_SSI, 'v0', new CryptoAlgorithmsMixin());

CryptoAlgorithmsRegistry.prototype.registerCryptoInterface(SSITypes.TOKEN_SSI, 'v0', new CryptoAlgorithmsMixin());
CryptoAlgorithmsRegistry.prototype.registerCryptoInterface(SSITypes.OWNERSHIP_SSI, 'v0', new SeedSSICryptoAlgorithms());
CryptoAlgorithmsRegistry.prototype.registerCryptoInterface(SSITypes.OWNERSHIP_READ_SSI, 'v0', new CryptoAlgorithmsMixin());
CryptoAlgorithmsRegistry.prototype.registerCryptoInterface(SSITypes.TRANSFER_SSI, 'v0', new SeedSSICryptoAlgorithms());
CryptoAlgorithmsRegistry.prototype.registerCryptoInterface(SSITypes.ZERO_ACCESS_TOKEN_SSI, 'v0', new CryptoAlgorithmsMixin());
CryptoAlgorithmsRegistry.prototype.registerCryptoInterface(SSITypes.SIGNED_HASH_LINK_SSI, 'v0', new CryptoAlgorithmsMixin());

CryptoAlgorithmsRegistry.prototype.registerCryptoInterface(SSITypes.CONSENSUS_SSI, 'v0', new CryptoAlgorithmsMixin());
CryptoAlgorithmsRegistry.prototype.registerCryptoInterface(SSITypes.PUBLIC_KEY_SSI, 'v0', new CryptoAlgorithmsMixin());


},{"../KeySSIs/SSITypes":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/key-ssi-resolver/lib/KeySSIs/SSITypes.js","./CryptoAlgorithmsMixin":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/key-ssi-resolver/lib/CryptoAlgorithms/CryptoAlgorithmsMixin.js","./CryptoFunctionTypes":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/key-ssi-resolver/lib/CryptoAlgorithms/CryptoFunctionTypes.js","./SeedSSICryptoAlgorithms":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/key-ssi-resolver/lib/CryptoAlgorithms/SeedSSICryptoAlgorithms.js"}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/key-ssi-resolver/lib/CryptoAlgorithms/CryptoFunctionTypes.js":[function(require,module,exports){
module.exports = {
    HASH: "hash",
    ENCRYPTION: "encryption",
    DECRYPTION: "decryption",
    ECIES_ENCRYPTION: "ecies_encryption",
    ECIES_DECRYPTION: "ecies_decryption",
    ECIES_ENCRYPTION_KMAC: "ecies_encryption_kmac",
    ECIES_DECRYPTION_KMAC: "ecies_decryption_kmac",
    ECIES_ENCRYPTION_DS: "ecies_encryption_ds",
    ECIES_DECRYPTION_DS: "ecies_decryption_ds",
    ENCRYPTION_KEY_GENERATION: "encryptionKeyGeneration",
    KEY_DERIVATION: "keyDerivation",
    ENCODING: "encoding",
    DECODING: "decoding",
    BASE64_ENCODING:"base64Encoding",
    BASE64_DECODING:"base64Decoding",
    SIGN: "sign",
    VERIFY: "verify",
    DERIVE_PUBLIC_KEY: "derivePublicKey",
    CONVERT_PUBLIC_KEY: "convertPublicKey",
    KEY_PAIR_GENERATOR: "keyPairGenerator",
    GET_IES_CONFIG: "getConfigForIES",
    SET_IES_CONFIG: "setConfigForIES",
};

},{}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/key-ssi-resolver/lib/CryptoAlgorithms/SeedSSICryptoAlgorithms.js":[function(require,module,exports){
function SeedSSICryptoAlgorithms() {
    const crypto = require("pskcrypto");
    const CryptoAlgorithmsMixin = require("./CryptoAlgorithmsMixin");
    CryptoAlgorithmsMixin(this);
    const self = this;

    self.sign = (data, privateKey) => {
        return crypto.signETH(data, privateKey);
    }

    self.derivePublicKey = (privateKey, format) => {
        if (typeof format === "undefined") {
            format = "pem";
        }
        const keyGenerator = crypto.createKeyPairGenerator();
        let publicKey = keyGenerator.getPublicKey(privateKey, 'secp256k1');
        switch (format) {
            case "raw":
                return publicKey;
            case "pem":
                return keyGenerator.getPemKeys(privateKey, publicKey).publicKey;
            default:
                throw Error("Invalid format name");
        }
    }
}

module.exports = SeedSSICryptoAlgorithms;

},{"./CryptoAlgorithmsMixin":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/key-ssi-resolver/lib/CryptoAlgorithms/CryptoAlgorithmsMixin.js","pskcrypto":"pskcrypto"}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/key-ssi-resolver/lib/DSUFactoryRegistry/ConsensusDSUFactory.js":[function(require,module,exports){
/**
 * @param {object} options
 * @param {KeySSIFactory} options.keySSIFactory
 * @param {BrickMapStrategyFactory} options.brickMapStrategyFactory
 */
function ConsensusDSUFactory(options) {
    options = options || {};
    this.barFactory = options.barFactory;

    /**
     * @param {object} options
     * @param {string} options.brickMapStrategy 'Diff', 'Versioned' or any strategy registered with the factory
     * @param {object} options.anchoringOptions Anchoring options to pass to bar map strategy
     * @param {callback} options.anchoringOptions.decisionFn Callback which will decide when to effectively anchor changes
     *                                                              If empty, the changes will be anchored after each operation
     * @param {callback} options.anchoringOptions.conflictResolutionFn Callback which will handle anchoring conflicts
     *                                                              The default strategy is to reload the BrickMap and then apply the new changes
     * @param {callback} options.anchoringOptions.anchoringEventListener An event listener which is called when the strategy anchors the changes
     * @param {callback} options.anchoringOptions.signingFn  A function which will sign the new alias
     * @param {object} options.validationRules
     * @param {object} options.validationRules.preWrite An object capable of validating operations done in the "preWrite" stage of the BrickMap
     * @param {callback} callback
     */
    this.create = (keySSI, options, callback) => {
        if (typeof options === 'function') {
            callback = options;
            options = undefined;
        }

        if (typeof options === "undefined") {
            options = {};
        }

        if(typeof options.useSSIAsIdentifier === "undefined" || !options.useSSIAsIdentifier){
            throw Error("Creating a DSU using keySSI from the ConsensusSSI family not allowed. Use the resolver.createDSUForExisting method instead.");
        }

        // enable options.validationRules.preWrite to stop content update
        this.barFactory.create(keySSI, options, callback);
    };

    /**
     * @param {string} keySSI
     * @param {object} options
     * @param {string} options.brickMapStrategy 'Diff', 'Versioned' or any strategy registered with the factory
     * @param {object} options.anchoringOptions Anchoring options to pass to bar map strategy
     * @param {callback} options.anchoringOptions.decisionFn Callback which will decide when to effectively anchor changes
     *                                                              If empty, the changes will be anchored after each operation
     * @param {callback} options.anchoringOptions.conflictResolutionFn Callback which will handle anchoring conflicts
     *                                                              The default strategy is to reload the BrickMap and then apply the new changes
     * @param {callback} options.anchoringOptions.anchoringEventListener An event listener which is called when the strategy anchors the changes
     * @param {callback} options.anchoringOptions.signingFn  A function which will sign the new alias
     * @param {object} options.validationRules
     * @param {object} options.validationRules.preWrite An object capable of validating operations done in the "preWrite" stage of the BrickMap
     * @param {callback} callback
     */
    this.load = (keySSI, options, callback) => {
        if (typeof options === 'function') {
            callback = options;
            options = {};
        }

        // enable options.validationRules.preWrite to stop content update
        this.barFactory.load(keySSI, options, callback);
    };
}

module.exports = ConsensusDSUFactory;

},{}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/key-ssi-resolver/lib/DSUFactoryRegistry/ConstDSUFactory.js":[function(require,module,exports){
/**
 * @param {object} options
 * @param {KeySSIFactory} options.keySSIFactory
 * @param {BrickMapStrategyFactory} options.brickMapStrategyFactory
 */
function ConstDSUFactory(options) {
    options = options || {};
    this.barFactory = options.barFactory;

    /**
     * @param {object} options
     * @param {string} options.brickMapStrategy 'Diff', 'Versioned' or any strategy registered with the factory
     * @param {object} options.anchoringOptions Anchoring options to pass to bar map strategy
     * @param {callback} options.anchoringOptions.decisionFn Callback which will decide when to effectively anchor changes
     *                                                              If empty, the changes will be anchored after each operation
     * @param {callback} options.anchoringOptions.conflictResolutionFn Callback which will handle anchoring conflicts
     *                                                              The default strategy is to reload the BrickMap and then apply the new changes
     * @param {callback} options.anchoringOptions.anchoringEventListener An event listener which is called when the strategy anchors the changes
     * @param {callback} options.anchoringOptions.signingFn  A function which will sign the new alias
     * @param {object} options.validationRules
     * @param {object} options.validationRules.preWrite An object capable of validating operations done in the "preWrite" stage of the BrickMap
     * @param {callback} callback
     */
    this.create = (keySSI, options, callback) => {
        if (typeof options === 'function') {
            callback = options;
            options = {};
        }
        if(typeof options.useSSIAsIdentifier === "undefined" || !options.useSSIAsIdentifier){
            throw Error("Creating a DSU using keySSI from the arraySSI family not allowed. Use the resolver.createDSUForExisting method instead.");
        }
        //preventing default mechanism that forces an anchor at the dsu creation
        options.addLog = false;
        //testing if a constDSU already exists in order to prevent new instances
        options.disableTimeMetadata = true;
        this.barFactory.load(keySSI, options, (err, loadedInstance)=>{
            if(!err){
                return callback(new Error("ConstDSU already exists! Can't be created again."));
            }
            // enable options.validationRules.preWrite to stop content update
            this.barFactory.create(keySSI, options, callback);
        });
    };

    /**
     * @param {string} keySSI
     * @param {object} options
     * @param {string} options.brickMapStrategy 'Diff', 'Versioned' or any strategy registered with the factory
     * @param {object} options.anchoringOptions Anchoring options to pass to bar map strategy
     * @param {callback} options.anchoringOptions.decisionFn Callback which will decide when to effectively anchor changes
     *                                                              If empty, the changes will be anchored after each operation
     * @param {callback} options.anchoringOptions.conflictResolutionFn Callback which will handle anchoring conflicts
     *                                                              The default strategy is to reload the BrickMap and then apply the new changes
     * @param {callback} options.anchoringOptions.anchoringEventListener An event listener which is called when the strategy anchors the changes
     * @param {callback} options.anchoringOptions.signingFn  A function which will sign the new alias
     * @param {object} options.validationRules
     * @param {object} options.validationRules.preWrite An object capable of validating operations done in the "preWrite" stage of the BrickMap
     * @param {callback} callback
     */
    this.load = (keySSI, options, callback) => {
        if (typeof options === 'function') {
            callback = options;
            options = {};
        }

        if (typeof options === "undefined") {
            options = {};
        }

        options.disableTimeMetadata = true;
        // enable options.validationRules.preWrite to stop content update
        this.barFactory.load(keySSI, options, callback);
    };
}

module.exports = ConstDSUFactory;

},{}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/key-ssi-resolver/lib/DSUFactoryRegistry/DSUFactory.js":[function(require,module,exports){
/**
 * @param {object} options
 * @param {KeySSIFactory} options.keySSIFactory
 * @param {BrickMapStrategyFactory} options.brickMapStrategyFactory
 */
const cache = require('psk-cache').getDefaultInstance();

function DSUFactory(options) {
    const barModule = require('bar');
    const fsAdapter = require('bar-fs-adapter');
    options = options || {};
    const MAX_BRICK_SIZE = options.maxBrickSize || 1000000;
    this.keySSIFactory = options.keySSIFactory;
    this.brickMapStrategyFactory = options.brickMapStrategyFactory;
    const openDSU = require("opendsu");
    const keySSISpace = openDSU.loadAPI("keyssi");

    function castSSI(ssi) {
        if (typeof ssi !== "undefined") {
            if (typeof ssi === "string") {
                ssi = keySSISpace.parse(ssi);
            } else {
                if (ssi.getTypeName === undefined || ssi.getIdentifier === undefined) {
                    throw Error("Please provide a proper SSI instance ");
                }
            }
        } else {
            throw Error("SSI should not be undefined");
        }
        return ssi;
    }

    ////////////////////////////////////////////////////////////
    // Private methods
    ////////////////////////////////////////////////////////////

    /**
     * @param {SeedSSI} keySSI
     * @param {object} options
     * @return {Archive}
     */
    const createInstance = (keySSI, options, initializationMethod, callback) => {
        const INIT = "init";
        const LOAD = "load";
        const LOAD_VERSION = "loadVersion";
        const allowedInitMethods = [INIT, LOAD];
        if (allowedInitMethods.indexOf(initializationMethod) === -1) {
            throw Error("Wrong usage of the createInstance method");
        }

        let bar;
        try {
            let identifier = keySSI;

            const ArchiveConfigurator = barModule.ArchiveConfigurator;
            ArchiveConfigurator.prototype.registerFsAdapter("FsAdapter", fsAdapter.createFsAdapter);
            const archiveConfigurator = new ArchiveConfigurator(options);
            archiveConfigurator.setCache(cache);
            const envTypes = require("overwrite-require").constants;
            if ($$.environmentType !== envTypes.BROWSER_ENVIRONMENT_TYPE &&
                $$.environmentType !== envTypes.SERVICE_WORKER_ENVIRONMENT_TYPE &&
                $$.environmentType !== envTypes.WEB_WORKER_ENVIRONMENT_TYPE) {
                archiveConfigurator.setFsAdapter("FsAdapter");
            }
            archiveConfigurator.setBufferSize(MAX_BRICK_SIZE);
            archiveConfigurator.setKeySSI(keySSI);
            let brickMapStrategyName = options.brickMapStrategy;
            let anchoringOptions = options.anchoringOptions;

            let brickMapStrategy = createBrickMapStrategy(brickMapStrategyName, anchoringOptions);
            archiveConfigurator.setBrickMapStrategy(brickMapStrategy);

            if (options.validationRules) {
                archiveConfigurator.setValidationRules(options.validationRules);
            }

            if (options.skipCache) {
                archiveConfigurator.disableDSUCaching()
            }

            bar = barModule.createArchive(archiveConfigurator);
            const DSUBase = require("./mixins/DSUBase");
            DSUBase(bar);

        } catch (err) {
            return callback(err);
        }

        let defaultCallback = err => {
            callback(err, bar)
        };

        let initCallback = (err) => {
            if (err) {
                return callback(err);
            }

            if (typeof options === "object" && options.addLog) {
                return bar.dsuLog("DSU created on " + Date.now(), defaultCallback);
            }

            callback(err, bar);
        }

        if (initializationMethod === LOAD) {
            if (options && options.versionHashlink) {
                initializationMethod = LOAD_VERSION;
                return bar[initializationMethod](options.versionHashlink, defaultCallback);
            }

            initializationMethod = LOAD;
        }

        bar[initializationMethod](initializationMethod === INIT ? initCallback : defaultCallback);
    }

    /**
     * @return {object}
     */
    const createBrickMapStrategy = (name, options) => {
        const strategy = this.brickMapStrategyFactory.create(name, options);
        return strategy;
    }

    /**
     * @return {SecretDID}
     * @param templateKeySSI
     * @param callback
     */
    const initializeKeySSI = (templateKeySSI, callback) => {
        if (typeof templateKeySSI === "function") {
            callback = templateKeySSI;
            templateKeySSI = undefined;
        }

        if (typeof templateKeySSI === "undefined") {
            return callback(Error("A template keySSI should be provided when creating a new DSU."));
        }
        const KeySSIFactory = require("../KeySSIs/KeySSIFactory");
        const keySSI = KeySSIFactory.createType(templateKeySSI.getTypeName());

        // keySSI.initialize(templateKeySSI.getDLDomain(), undefined, undefined, undefined, templateKeySSI.getHint(), callback);
        keySSISpace.createSeedSSI(templateKeySSI.getDLDomain(), undefined, templateKeySSI.getHint(), callback);
        // keySSI.initialize(templateKeySSI.getDLDomain(), templateKeySSI.getSpecificString(), templateKeySSI.getControlString(), templateKeySSI.getVn(), templateKeySSI.getHint(), callback);
    }

    ////////////////////////////////////////////////////////////
    // Public methods
    ////////////////////////////////////////////////////////////

    /**
     * @param {object} options
     * @param {string} options.brickMapStrategy 'Diff', 'Versioned' or any strategy registered with the factory
     * @param {object} options.anchoringOptions Anchoring options to pass to bar map strategy
     * @param {callback} options.anchoringOptions.decisionFn Callback which will decide when to effectively anchor changes
     *                                                              If empty, the changes will be anchored after each operation
     * @param {callback} options.anchoringOptions.conflictResolutionFn Callback which will handle anchoring conflicts
     *                                                              The default strategy is to reload the BrickMap and then apply the new changes
     * @param {callback} options.anchoringOptions.anchoringEventListener An event listener which is called when the strategy anchors the changes
     * @param {callback} options.anchoringOptions.signingFn  A function which will sign the new alias
     * @param {object} options.validationRules
     * @param {object} options.validationRules.preWrite An object capable of validating operations done in the "preWrite" stage of the BrickMap
     * @param {callback} callback
     */
    this.create = (keySSI, options, callback) => {
        keySSI = castSSI(keySSI);
        if (typeof options === "function") {
            callback = options;
            options = undefined;
        }
        options = options || {};
        if (options.useSSIAsIdentifier) {
            return createInstance(keySSI, options, "init", callback);
        }

        initializeKeySSI(keySSI, (err, _keySSI) => {
            if (err) {
                return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to initialize keySSI <${keySSI.getIdentifier(true)}>`, err));
            }
            return createInstance(_keySSI, options, "init", callback);
        });
    }

    /**
     * @param {string} keySSI
     * @param {object} options
     * @param {string} options.brickMapStrategy 'Diff', 'Versioned' or any strategy registered with the factory
     * @param {object} options.anchoringOptions Anchoring options to pass to bar map strategy
     * @param {callback} options.anchoringOptions.decisionFn Callback which will decide when to effectively anchor changes
     *                                                              If empty, the changes will be anchored after each operation
     * @param {callback} options.anchoringOptions.conflictResolutionFn Callback which will handle anchoring conflicts
     *                                                              The default strategy is to reload the BrickMap and then apply the new changes
     * @param {callback} options.anchoringOptions.anchoringEventListener An event listener which is called when the strategy anchors the changes
     * @param {callback} options.anchoringOptions.signingFn  A function which will sign the new alias
     * @param {object} options.validationRules
     * @param {object} options.validationRules.preWrite An object capable of validating operations done in the "preWrite" stage of the BrickMap
     * @param {callback} callback
     */
    this.load = (keySSI, options, callback) => {
        keySSI = castSSI(keySSI);
        if (typeof options === "function") {
            callback = options;
            options = undefined;
        }
        options = options || {};
        createInstance(keySSI, options, "load", callback);
    }
}

module.exports = DSUFactory;

},{"../KeySSIs/KeySSIFactory":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/key-ssi-resolver/lib/KeySSIs/KeySSIFactory.js","./mixins/DSUBase":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/key-ssi-resolver/lib/DSUFactoryRegistry/mixins/DSUBase.js","bar":"bar","bar-fs-adapter":"bar-fs-adapter","opendsu":"opendsu","overwrite-require":"overwrite-require","psk-cache":"psk-cache"}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/key-ssi-resolver/lib/DSUFactoryRegistry/OwnershipDSUFactory.js":[function(require,module,exports){
/**
 * @param {object} options
 * @param {KeySSIFactory} options.keySSIFactory
 * @param {BrickMapStrategyFactory} options.brickMapStrategyFactory
 */
function OwnershipDSUFactory(options) {
    options = options || {};
    this.barFactory = options.barFactory;

    /**
     * @param {object} options
     * @param {string} options.brickMapStrategy 'Diff', 'Versioned' or any strategy registered with the factory
     * @param {object} options.anchoringOptions Anchoring options to pass to bar map strategy
     * @param {callback} options.anchoringOptions.decisionFn Callback which will decide when to effectively anchor changes
     *                                                              If empty, the changes will be anchored after each operation
     * @param {callback} options.anchoringOptions.conflictResolutionFn Callback which will handle anchoring conflicts
     *                                                              The default strategy is to reload the BrickMap and then apply the new changes
     * @param {callback} options.anchoringOptions.anchoringEventListener An event listener which is called when the strategy anchors the changes
     * @param {callback} options.anchoringOptions.signingFn  A function which will sign the new alias
     * @param {object} options.validationRules
     * @param {object} options.validationRules.preWrite An object capable of validating operations done in the "preWrite" stage of the BrickMap
     * @param {callback} callback
     */
    this.create = (keySSI, options, callback) => {
        if (typeof options === 'function') {
            callback = options;
            options = undefined;
        }

        if (typeof options === "undefined") {
            options = {};
        }

        if(typeof options.useSSIAsIdentifier === "undefined" || !options.useSSIAsIdentifier){
            throw Error("Creating a DSU using keySSI from the OwnershipSSI family not allowed. Use the resolver.createDSUForExisting method instead.");
        }

        // enable options.validationRules.preWrite to stop content update
        this.barFactory.create(keySSI, options, callback);
    };

    /**
     * @param {string} keySSI
     * @param {object} options
     * @param {string} options.brickMapStrategy 'Diff', 'Versioned' or any strategy registered with the factory
     * @param {object} options.anchoringOptions Anchoring options to pass to bar map strategy
     * @param {callback} options.anchoringOptions.decisionFn Callback which will decide when to effectively anchor changes
     *                                                              If empty, the changes will be anchored after each operation
     * @param {callback} options.anchoringOptions.conflictResolutionFn Callback which will handle anchoring conflicts
     *                                                              The default strategy is to reload the BrickMap and then apply the new changes
     * @param {callback} options.anchoringOptions.anchoringEventListener An event listener which is called when the strategy anchors the changes
     * @param {callback} options.anchoringOptions.signingFn  A function which will sign the new alias
     * @param {object} options.validationRules
     * @param {object} options.validationRules.preWrite An object capable of validating operations done in the "preWrite" stage of the BrickMap
     * @param {callback} callback
     */
    this.load = (keySSI, options, callback) => {
        if (typeof options === 'function') {
            callback = options;
            options = {};
        }

        // enable options.validationRules.preWrite to stop content update
        this.barFactory.load(keySSI, options, callback);
    };
}

module.exports = OwnershipDSUFactory;

},{}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/key-ssi-resolver/lib/DSUFactoryRegistry/WalletFactory.js":[function(require,module,exports){
/**
 * @param {object} options
 * @param {KeySSIFactory} options.keySSIFactory
 * @param {BrickMapStrategyFactory} options.brickMapStrategyFactory
 */
function WalletFactory(options) {
    options = options || {};
    this.dsuFactory = options.barFactory;
    const WALLET_MOUNT_POINT = "/writableDSU";
    /**
     * @param {object} options
     * @param {string} options.brickMapStrategy 'Diff', 'Versioned' or any strategy registered with the factory
     * @param {object} options.anchoringOptions Anchoring options to pass to bar map strategy
     * @param {callback} options.anchoringOptions.decisionFn Callback which will decide when to effectively anchor changes
     *                                                              If empty, the changes will be anchored after each operation
     * @param {callback} options.anchoringOptions.conflictResolutionFn Callback which will handle anchoring conflicts
     *                                                              The default strategy is to reload the BrickMap and then apply the new changes
     * @param {callback} options.anchoringOptions.anchoringEventListener An event listener which is called when the strategy anchors the changes
     * @param {callback} options.anchoringOptions.signingFn  A function which will sign the new alias
     * @param {object} options.validationRules
     * @param {object} options.validationRules.preWrite An object capable of validating operations done in the "preWrite" stage of the BrickMap
     * @param {object} options.walletKeySSI - KeySSI of the wallet to be mounted in constDSUWallet
     * @param {callback} callback
     */
    this.create = (keySSI, options, callback) => {
        const defaultOpts = {overwrite: false};

        if (typeof options === 'function') {
            callback = options;
            options = {};
        }
        let writableWallet;
        let constDSUWallet;

        Object.assign(defaultOpts, options);
        options = defaultOpts;

        let createWritableDSU = () => {
            let templateSSI = require("opendsu").loadApi("keyssi").createTemplateSeedSSI(keySSI.getDLDomain(), undefined, undefined, undefined, keySSI.getHint());
            this.dsuFactory.create(templateSSI, (err, writableDSU) => {
                if (err) {
                    return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to create writable using templateSSI <${templateSSI.getIdentifier(true)}>`, err));
                }
                writableWallet = writableDSU;
                mountDSUType();
            })
        }

        let mountDSUType = () => {
            writableWallet.mount("/code", options.dsuTypeSSI, (err => {
                if (err) {
                    return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to mount constitution in writable DSU`, err));
                }
                createConstDSU();
            }));
        }

        let createConstDSU = () => {
            const newOptions = JSON.parse(JSON.stringify(options));
            newOptions.addLog = false;
            this.dsuFactory.create(keySSI, newOptions, (err, constWallet) => {
                if (err) {
                    return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to create ConstDSU using keySSI <${keySSI.getIdentifier(true)}>`, err));
                }

                constDSUWallet = constWallet;
                constDSUWallet.getWritableDSU = function () {
                    return writableWallet;
                }
                mountWritableWallet();
            })
        }


        let mountWritableWallet = () => {
            writableWallet.getKeySSIAsString((err, seedSSI) => {
                if (err) {
                    return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper("Failed to get seedSSI", err));
                }
                constDSUWallet.mount(WALLET_MOUNT_POINT, seedSSI, (err => {
                    if (err) {
                        return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper("Failed to mount writable SSI in wallet", err));
                    }
                    callback(undefined, constDSUWallet);
                }));
            });
        }

        if (options.walletKeySSI) {
            this.dsuFactory.load(options.walletKeySSI, (err, dsu) => {
                if (err) {
                    return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper("Failed to load writable DSU from ConstDSU Wallet ------->>>>>>", err));
                }
                writableWallet = dsu;
                createConstDSU();
            });
        } else {
            createWritableDSU();
        }

    };


    /**
     * @param {string} keySSI
     * @param {object} options
     * @param {string} options.brickMapStrategy 'Diff', 'Versioned' or any strategy registered with the factory
     * @param {object} options.anchoringOptions Anchoring options to pass to bar map strategy
     * @param {callback} options.anchoringOptions.decisionFn Callback which will decide when to effectively anchor changes
     *                                                              If empty, the changes will be anchored after each operation
     * @param {callback} options.anchoringOptions.conflictResolutionFn Callback which will handle anchoring conflicts
     *                                                              The default strategy is to reload the BrickMap and then apply the new changes
     * @param {callback} options.anchoringOptions.anchoringEventListener An event listener which is called when the strategy anchors the changes
     * @param {callback} options.anchoringOptions.signingFn  A function which will sign the new alias
     * @param {object} options.validationRules
     * @param {object} options.validationRules.preWrite An object capable of validating operations done in the "preWrite" stage of the BrickMap
     * @param {callback} callback
     */
    this.load = (keySSI, options, callback) => {
        const defaultOpts = {overwrite: false};
        if (typeof options === 'function') {
            callback = options;
            options = {};
        }
        Object.assign(defaultOpts, options);
        options = defaultOpts;
        let constDSU;
        let writableDSU;
        let writableSSI;

        let loadConstDSU = () => {
            this.dsuFactory.load(keySSI, options, (err, dsu) => {
                if (err) {
                    return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper("Failed to load ConstDSU", err));
                }
                constDSU = dsu;
                getSSIFromMountPoint();
            });
        }


        let getSSIFromMountPoint = () => {
            constDSU.getSSIForMount(WALLET_MOUNT_POINT, (err, ssi) => {
                if (err) {
                    return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper("Failed to get mount point in ConstDSU", err));
                }
                writableSSI = require("opendsu").loadApi("keyssi").parse(ssi);
                loadWritableDSU();
            });
        }

        let loadWritableDSU = () => {
            this.dsuFactory.load(writableSSI, options, (err, dsu) => {
                if (err) {
                    return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper("Failed to load writable DSU from ConstDSU Wallet", err));
                }
                writableDSU = dsu;
                constDSU.getWritableDSU = function () {
                    return writableDSU;
                }
                return callback(undefined, constDSU);
            });
        }


        loadConstDSU();

    };
}

module.exports = WalletFactory;

},{"opendsu":"opendsu"}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/key-ssi-resolver/lib/DSUFactoryRegistry/index.js":[function(require,module,exports){
const BarFactory = require('./DSUFactory');
const SSITypes = require("../KeySSIs/SSITypes");
/**
 * @param {object} options
 * @param {KeySSIFactory} options.keySSIFactory
 * @param {BrickMapStrategyFactory} options.brickMapStrategyFactory
 */
const factories = {};

function Registry(options) {
    options = options || {};

    const keySSIFactory = options.keySSIFactory;
    const brickMapStrategyFactory = options.brickMapStrategyFactory

    if (!keySSIFactory) {
        throw new Error('A KeySSI factory is required');
    }

    if (!brickMapStrategyFactory) {
        throw new Error('A BrickMapStratregy factory is required');
    }

    /**
     * Initialize the factory state
     */
    const initialize = () => {
        const barFactory = new BarFactory({
            keySSIFactory,
            brickMapStrategyFactory
        });

        this.registerDSUType(SSITypes.SEED_SSI, barFactory);
        this.registerDSUType(SSITypes.SREAD_SSI, barFactory);
        const WalletFactory = require("./WalletFactory");
        const walletFactory = new WalletFactory({barFactory});
        this.registerDSUType(SSITypes.WALLET_SSI, walletFactory);
        const ConstDSUFactory = require("./ConstDSUFactory");
        const constDSUFactory = new ConstDSUFactory({barFactory});
        this.registerDSUType(SSITypes.CONST_SSI, constDSUFactory);
        this.registerDSUType(SSITypes.ARRAY_SSI, constDSUFactory);

        const OwnershipDSUFactory = require("./OwnershipDSUFactory");
        const ownershipDSUFactory = new OwnershipDSUFactory({barFactory})
        this.registerDSUType(SSITypes.OWNERSHIP_SSI, ownershipDSUFactory);
        this.registerDSUType(SSITypes.OWNERSHIP_READ_SSI, ownershipDSUFactory);

        const ConsensusDSUFactory = require("./ConsensusDSUFactory");
        const consensusDSUFactory = new ConsensusDSUFactory({barFactory});
        this.registerDSUType(SSITypes.CONSENSUS_SSI, consensusDSUFactory);
    }

    ////////////////////////////////////////////////////////////
    // Public methods
    ////////////////////////////////////////////////////////////

    /**
     * @param {string} representation
     * @return {boolean}
     */
    this.isValidKeySSI = (keySSI) => {
        try{
            return typeof factories[keySSI.getTypeName()] !== 'undefined';
        } catch(err){
            return false;
        }
    };


    /**
     * @param {object} keySSI
     * @param {object} dsuConfiguration
     * @param {string} dsuConfiguration.brickMapStrategyFactory 'Diff', 'Versioned' or any strategy registered with the factory
     * @param {object} dsuConfiguration.anchoringOptions Anchoring options to pass to bar map strategy
     * @param {callback} dsuConfiguration.anchoringOptions.decisionFn Callback which will decide when to effectively anchor changes
     *                                                              If empty, the changes will be anchored after each operation
     * @param {callback} dsuConfiguration.anchoringOptions.conflictResolutionFn Callback which will handle anchoring conflicts
     *                                                              The default strategy is to reload the BrickMap and then apply the new changes
     * @param {callback} dsuConfiguration.anchoringOptions.anchoringCb A callback which is called when the strategy anchors the changes
     * @param {callback} dsuConfiguration.anchoringOptions.signingFn  A function which will sign the new alias
     * @param {object} dsuConfiguration.validationRules
     * @param {object} dsuConfiguration.validationRules.preWrite An object capable of validating operations done in the "preWrite" stage of the BrickMap
     * @param {callback} callback
     */
    this.create = (keySSI, dsuConfiguration, callback) => {
        let type = keySSI.getTypeName();
        if (keySSI.options && keySSI.options.dsuFactoryType) {
            type = keySSI.options.dsuFactoryType;
        }
        const factory = factories[type];
        factory.create(keySSI, dsuConfiguration, callback);
    }

    /**
     * @param {object} keySSI
     * @param {string} representation
     * @param {object} dsuConfiguration
     * @param {string} dsuConfiguration.brickMapStrategyFactory 'Diff', 'Versioned' or any strategy registered with the factory
     * @param {object} dsuConfiguration.anchoringOptions Anchoring options to pass to bar map strategy
     * @param {callback} dsuConfiguration.anchoringOptions.decisionFn Callback which will decide when to effectively anchor changes
     *                                                              If empty, the changes will be anchored after each operation
     * @param {callback} dsuConfiguration.anchoringOptions.conflictResolutionFn Callback which will handle anchoring conflicts
     *                                                              The default strategy is to reload the BrickMap and then apply the new changes
     * @param {callback} dsuConfiguration.anchoringOptions.anchoringCb A callback which is called when the strategy anchors the changes
     * @param {callback} dsuConfiguration.anchoringOptions.signingFn  A function which will sign the new alias
     * @param {object} dsuConfiguration.validationRules
     * @param {object} dsuConfiguration.validationRules.preWrite An object capable of validating operations done in the "preWrite" stage of the BrickMap
     * @param {callback} callback
     */
    this.load = (keySSI, dsuConfiguration, callback) => {
        let type = keySSI.getTypeName();
        if (keySSI.options && keySSI.options.dsuFactoryType) {
            type = keySSI.options.dsuFactoryType;
        }
        const factory = factories[type];
        return factory.load(keySSI, dsuConfiguration, callback);
    }

    initialize();
}

/**
 * @param {string} dsuType
 * @param {object} factory
 */
Registry.prototype.registerDSUType = (dsuType, factory) => {
    factories[dsuType] = factory;
}

Registry.prototype.getDSUFactory = (dsuType) => {
    return factories[dsuType];
}

module.exports = Registry;

},{"../KeySSIs/SSITypes":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/key-ssi-resolver/lib/KeySSIs/SSITypes.js","./ConsensusDSUFactory":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/key-ssi-resolver/lib/DSUFactoryRegistry/ConsensusDSUFactory.js","./ConstDSUFactory":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/key-ssi-resolver/lib/DSUFactoryRegistry/ConstDSUFactory.js","./DSUFactory":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/key-ssi-resolver/lib/DSUFactoryRegistry/DSUFactory.js","./OwnershipDSUFactory":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/key-ssi-resolver/lib/DSUFactoryRegistry/OwnershipDSUFactory.js","./WalletFactory":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/key-ssi-resolver/lib/DSUFactoryRegistry/WalletFactory.js"}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/key-ssi-resolver/lib/DSUFactoryRegistry/mixins/DSUBase.js":[function(require,module,exports){
module.exports = function(archive){
	archive.call = (functionName, ...args) => {
		if(args.length === 0){
			throw Error('Missing arguments. Usage: call(functionName, [arg1, arg2 ...] callback)');
		}
		const callback = args.pop();
		if(typeof  callback !== "function"){
			throw Error('Last argument is always a callback function. Usage: call(functionName, [arg1, arg2 ...] callback)');
		}

		let evaluatedAPICode;

		function doEval(apiCode){
			const or = require("overwrite-require");

			switch($$.environmentType){
				case or.constants.BROWSER_ENVIRONMENT_TYPE:
				case or.constants.WEB_WORKER_ENVIRONMENT_TYPE:
				case or.constants.SERVICE_WORKER_ENVIRONMENT_TYPE:
					apiCode = new TextDecoder("utf-8").decode(apiCode);
					break;
				default:
					apiCode = apiCode.toString();
			}
			apiCode = "let module = {exports: {}}\n" + apiCode + "\nmodule.exports";
			evaluatedAPICode = eval(apiCode);
		}

		function execute(){
			try{
				//before eval we need to convert from $$.Buffer/ArrayBuffer to String
				evaluatedAPICode[functionName].call(this, ...args, callback);
			}catch(err){
				return callback(createOpenDSUErrorWrapper(`Failed to  execute api.js code `, err));
			}
		}

		if(!evaluatedAPICode){
			archive.readFile("/code/api.js", function(err, apiCode){
				if(err){
					archive.readFile("/app/api.js", function(err, apiCode){
						if(err){
							return callback(createOpenDSUErrorWrapper(`Failed to  read file api.js in /code or /app`, err));
						} else {
							doEval(apiCode);
							execute();
						}
					});
				} else {
					doEval(apiCode);
					execute();
				}
			});
		} else {
			execute();
		}
	}
	return archive;
}

},{"overwrite-require":"overwrite-require"}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/key-ssi-resolver/lib/KeySSIResolver.js":[function(require,module,exports){
/**
 * @param {BrickMapStrategyFactory} options.brickMapStrategyFactory
 * @param {DSUFactory} options.dsuFactory
 */
function KeySSIResolver(options) {
    options = options || {};
    const brickMapStrategyFactory = options.brickMapStrategyFactory;

    const dsuFactory = options.dsuFactory;


    ////////////////////////////////////////////////////////////
    // Public methods
    ////////////////////////////////////////////////////////////

    /**
     * @param {SeedSSI} dsuRepresentation
     * @param {object} options
     * @param {string} options.brickMapStrategy 'Diff' or any strategy registered with the factory
     * @param {object} options.anchoringOptions Anchoring options to pass to bar map strategy
     * @param {callback} options.anchoringOptions.decisionFn A function which will decide when to effectively anchor changes
     *                                                              If empty, the changes will be anchored after each operation
     * @param {callback} options.anchoringOptions.conflictResolutionFn A function which will handle anchoring conflicts
     *                                                              The default strategy is to reload the BrickMap and then apply the new changes
     * @param {callback} options.anchoringOptions.anchoringEventListener An event listener which is called when the strategy anchors the changes
     * @param {callback} options.anchoringOptions.signingFn  A function which will sign the new alias
     * @param {object} options.validationRules
     * @param {object} options.validationRules.preWrite An object capable of validating operations done in the "preWrite" stage of the BrickMap
     * @param {callback} callback
     */
    this.createDSU = (keySSI, options, callback) => {
        if (typeof options === 'function') {
            callback = options;
            options = {};
        }

        dsuFactory.create(keySSI, options, callback);
    };

    /**
     * @param {string} keySSI
     * @param {object} options
     * @param {string} options.brickMapStrategy 'Diff', 'Versioned' or any strategy registered with the factory
     * @param {object} options.anchoringOptions Anchoring options to pass to bar map strategy
     * @param {callback} options.anchoringOptions.decisionFn A function which will decide when to effectively anchor changes
     *                                                              If empty, the changes will be anchored after each operation
     * @param {callback} options.anchoringOptions.conflictResolutionFn Callback which will handle anchoring conflicts
     *                                                              The default strategy is to reload the BrickMap and then apply the new changes
     * @param {callback} options.anchoringOptions.anchoringEventListener An event listener which is called when the strategy anchors the changes
     * @param {callback} options.anchoringOptions.signingFn  A function which will sign the new alias
     * @param {object} options.validationRules
     * @param {object} options.validationRules.preWrite An object capable of validating operations done in the "preWrite" stage of the BrickMap
     * @param {boolean} options.skipCache If `true` the DSU will skip caching when loading any mounted DSUs
     * @param {callback} callback
     */
    this.loadDSU = (keySSI, options, callback) => {
        if (typeof options === 'function') {
            callback = options;
            options = {};
        }
        if (!dsuFactory.isValidKeySSI(keySSI)) {
            let helpString;
            if(typeof keySSI === "string"){
                helpString = keySSI;
            } else {
                helpString = keySSI.getIdentifier(true);
            }
            return callback(new Error(`Invalid KeySSI: ${helpString}`));
        }
        dsuFactory.load(keySSI, options, callback);
    };

    /**
     * @return {DSUFactory}
     */
    this.getDSUFactory = () => {
        return dsuFactory;
    }

    /**
     * @return {BrickMapStrategyFactory}
     */
    this.getBrickMapStrategyFactory = () => {
        return brickMapStrategyFactory;
    }
}

module.exports = KeySSIResolver;

},{}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/key-ssi-resolver/lib/KeySSIs/ConstSSIs/ArraySSI.js":[function(require,module,exports){
function ArraySSI(enclave, identifier) {
    if (typeof enclave === "string") {
        identifier = enclave;
        enclave = undefined;
    }
    const SSITypes = require("../SSITypes");
    const KeySSIMixin = require("../KeySSIMixin");
    const cryptoRegistry = require("../../CryptoAlgorithms/CryptoAlgorithmsRegistry");

    KeySSIMixin(this, enclave);
    const self = this;

    if (typeof identifier !== "undefined") {
        self.autoLoad(identifier);
    }

    self.getTypeName = function () {
        return SSITypes.ARRAY_SSI;
    }

    self.initialize = (dlDomain, arr, vn, hint) => {
        if (typeof vn === "undefined") {
            vn = 'v0';
        }
        const key = cryptoRegistry.getKeyDerivationFunction(self)(arr.join(''), 1000);
        self.load(SSITypes.ARRAY_SSI, dlDomain, cryptoRegistry.getBase64EncodingFunction(self)(key), "", vn, hint);
    };

    self.derive = (callback) => {
        const ConstSSI = require("./ConstSSI");
        const constSSI = ConstSSI.createConstSSI();
        constSSI.load(SSITypes.CONST_SSI, self.getDLDomain(), self.getSpecificString(), self.getControlString(), self.getVn(), self.getHint());
        callback(undefined, constSSI);
    };

    self.getEncryptionKey = (callback) => {
        self.derive((err, derivedKeySSI) => {
            if (err) {
                return callback(err);
            }

            derivedKeySSI.getEncryptionKey(callback);
        });
    };

    self.createAnchorValue = function (brickMapHash, previousAnchorValue, callback) {
        if (typeof previousAnchorValue === "function") {
            callback = previousAnchorValue;
            previousAnchorValue = undefined;
        }
        try {
            const keySSIFactory = require("../KeySSIFactory");
            const hashLinkSSI = keySSIFactory.createType(SSITypes.HASH_LINK_SSI);
            hashLinkSSI.initialize(self.getBricksDomain(), brickMapHash, self.getVn(), self.getHint());
            callback(undefined, hashLinkSSI);
        } catch (e) {
            callback(e);
        }
    }

    self.canAppend = function () {
        return false;
    }
}

function createArraySSI(enclave, identifier) {
    return new ArraySSI(enclave, identifier);
}

module.exports = {
    createArraySSI
};

},{"../../CryptoAlgorithms/CryptoAlgorithmsRegistry":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/key-ssi-resolver/lib/CryptoAlgorithms/CryptoAlgorithmsRegistry.js","../KeySSIFactory":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/key-ssi-resolver/lib/KeySSIs/KeySSIFactory.js","../KeySSIMixin":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/key-ssi-resolver/lib/KeySSIs/KeySSIMixin.js","../SSITypes":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/key-ssi-resolver/lib/KeySSIs/SSITypes.js","./ConstSSI":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/key-ssi-resolver/lib/KeySSIs/ConstSSIs/ConstSSI.js"}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/key-ssi-resolver/lib/KeySSIs/ConstSSIs/CZaSSI.js":[function(require,module,exports){
const KeySSIMixin = require("../KeySSIMixin");
const SSITypes = require("../SSITypes");

function CZaSSI(enclave, identifier) {
    if (typeof enclave === "string") {
        identifier = enclave;
        enclave = undefined;
    }
    KeySSIMixin(this, enclave);
    const self = this;
    if (typeof identifier !== "undefined") {
        self.autoLoad(identifier);
    }

    self.getTypeName = function () {
        return SSITypes.CONSTANT_ZERO_ACCESS_SSI;
    }

    self.initialize = (dlDomain, hpk, vn, hint) => {
        self.load(SSITypes.CONSTANT_ZERO_ACCESS_SSI, dlDomain, '', hpk, vn, hint);
    };

    

    self.canAppend = function(){
        return false;
    }
}

function createCZaSSI(enclave, identifier) {
    return new CZaSSI(enclave, identifier);
}

module.exports = {
    createCZaSSI
};

},{"../KeySSIMixin":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/key-ssi-resolver/lib/KeySSIs/KeySSIMixin.js","../SSITypes":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/key-ssi-resolver/lib/KeySSIs/SSITypes.js"}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/key-ssi-resolver/lib/KeySSIs/ConstSSIs/ConstSSI.js":[function(require,module,exports){
const KeySSIMixin = require("../KeySSIMixin");
const CZaSSI = require("./CZaSSI");
const SSITypes = require("../SSITypes");
const cryptoRegistry = require("../../CryptoAlgorithms/CryptoAlgorithmsRegistry");

function ConstSSI(enclave, identifier) {
    if (typeof enclave === "string") {
        identifier = enclave;
        enclave = undefined;
    }
    KeySSIMixin(this, enclave);
    const self = this;
    if (typeof identifier !== "undefined") {
        self.autoLoad(identifier);
    }

    self.getTypeName = function () {
        return SSITypes.CONST_SSI;
    }

    self.initialize = (dlDomain, constString, vn, hint) => {
        const key = cryptoRegistry.getKeyDerivationFunction(self)(constString, 1000);
        self.load(SSITypes.CONST_SSI, dlDomain, cryptoRegistry.getBase64EncodingFunction(self)(key), "", vn, hint);
    };

    self.getEncryptionKey = (callback) => {
        try {
            const encryptionKey = cryptoRegistry.getBase64DecodingFunction(self)(self.getSpecificString());
            callback(undefined, encryptionKey);
        } catch (e) {
            callback(e);
        }
    };

    self.derive = (callback) => {
        const cZaSSI = CZaSSI.createCZaSSI();
        self.getEncryptionKey((err, encryptionKey) => {
            if (err) {
                return callback(err);
            }
            try {
                const subtypeKey = cryptoRegistry.getHashFunction(self)(encryptionKey);
                cZaSSI.load(SSITypes.CONSTANT_ZERO_ACCESS_SSI, self.getDLDomain(), subtypeKey, self.getControlString(), self.getVn(), self.getHint());
                callback(undefined, cZaSSI);
            } catch (e) {
                callback(e);
            }
        });
    };

    self.createAnchorValue = function (brickMapHash, previousAnchorValue, callback) {
        if (typeof previousAnchorValue === "function") {
            callback = previousAnchorValue;
            previousAnchorValue = undefined;
        }
        try {
            const keySSIFactory = require("../KeySSIFactory");
            const hashLinkSSI = keySSIFactory.createType(SSITypes.HASH_LINK_SSI);
            hashLinkSSI.initialize(self.getBricksDomain(), brickMapHash, self.getVn(), self.getHint());
            callback(undefined, hashLinkSSI);
        } catch (e) {
            return callback(e);
        }
    }

    self.canAppend = function () {
        return false;
    }
}

function createConstSSI(enclave, identifier) {
    return new ConstSSI(enclave, identifier);
}

module.exports = {
    createConstSSI
};

},{"../../CryptoAlgorithms/CryptoAlgorithmsRegistry":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/key-ssi-resolver/lib/CryptoAlgorithms/CryptoAlgorithmsRegistry.js","../KeySSIFactory":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/key-ssi-resolver/lib/KeySSIs/KeySSIFactory.js","../KeySSIMixin":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/key-ssi-resolver/lib/KeySSIs/KeySSIMixin.js","../SSITypes":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/key-ssi-resolver/lib/KeySSIs/SSITypes.js","./CZaSSI":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/key-ssi-resolver/lib/KeySSIs/ConstSSIs/CZaSSI.js"}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/key-ssi-resolver/lib/KeySSIs/ConstSSIs/PasswordSSI.js":[function(require,module,exports){
const KeySSIMixin = require("../KeySSIMixin");
const ConstSSI = require("./ConstSSI");
const SSITypes = require("../SSITypes");
const cryptoRegistry = require("../../CryptoAlgorithms/CryptoAlgorithmsRegistry");

function PasswordSSI(enclave, identifier){
    if (typeof enclave === "string") {
        identifier = enclave;
        enclave = undefined;
    }
    KeySSIMixin(this, enclave);
    const self = this;

    if (typeof identifier !== "undefined") {
        self.autoLoad(identifier);
    }

    self.initialize = (dlDomain, context, password, kdfOptions, vn, hint) => {
        const subtypeSpecificString = cryptoRegistry.getKeyDerivationFunction(self)(context + password, kdfOptions);
        self.load(SSITypes.PASSWORD_SSI, dlDomain, subtypeSpecificString, '', vn, hint);
    };

    self.derive = (callback) => {
        const constSSI = ConstSSI.createConstSSI();
        constSSI.load(SSITypes.CONST_SSI, self.getDLDomain(), self.getSpecificString(), self.getControlString(), self.getVn(), self.getHint());
        callback(constSSI);
    };

    self.getEncryptionKey = (callback) => {
        self.derive((err, constSSI)=>{
            if (err) {
                return callback(err);
            }

            constSSI.getEncryptionKey(callback);
        })
    };
}

function createPasswordSSI(enclave, identifier) {
    return new PasswordSSI(enclave, identifier);
}

module.exports = {
    createPasswordSSI
};

},{"../../CryptoAlgorithms/CryptoAlgorithmsRegistry":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/key-ssi-resolver/lib/CryptoAlgorithms/CryptoAlgorithmsRegistry.js","../KeySSIMixin":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/key-ssi-resolver/lib/KeySSIs/KeySSIMixin.js","../SSITypes":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/key-ssi-resolver/lib/KeySSIs/SSITypes.js","./ConstSSI":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/key-ssi-resolver/lib/KeySSIs/ConstSSIs/ConstSSI.js"}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/key-ssi-resolver/lib/KeySSIs/ContractSSIs/ConsensusSSI.js":[function(require,module,exports){
const KeySSIMixin = require("../KeySSIMixin");
const SSITypes = require("../SSITypes");

function ConsensusSSI(identifier) {
    KeySSIMixin(this);
    const self = this;

    if (typeof identifier !== "undefined") {
        self.autoLoad(identifier);
    }

    self.initialize = (dlDomain, contractName, vn, hint) => {
        self.load(SSITypes.CONSENSUS_SSI, dlDomain, contractName, undefined, vn, hint);
    };
}

function createConsensusSSI(identifier) {
    return new ConsensusSSI(identifier);
}

module.exports = {
    createConsensusSSI,
};

},{"../KeySSIMixin":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/key-ssi-resolver/lib/KeySSIs/KeySSIMixin.js","../SSITypes":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/key-ssi-resolver/lib/KeySSIs/SSITypes.js"}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/key-ssi-resolver/lib/KeySSIs/DSURepresentationNames.js":[function(require,module,exports){
const DSURepresentationNames = {
    "seed": "RawDossier"
}

module.exports = DSURepresentationNames;
},{}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/key-ssi-resolver/lib/KeySSIs/HashLinkSSIs/SignedHashLinkSSI.js":[function(require,module,exports){
const KeySSIMixin = require("../KeySSIMixin");
const {createHashLinkSSI} = require("../OtherKeySSIs/HashLinkSSI");
const SSITypes = require("../SSITypes");
const cryptoRegistry = require("../../CryptoAlgorithms/CryptoAlgorithmsRegistry");

function SignedHashLinkSSI(enclave, identifier) {
    if (typeof enclave === "string") {
        identifier = enclave;
        enclave = undefined;
    }
    const SEPARATOR = "|";
    KeySSIMixin(this, enclave);
    const self = this;

    if (typeof identifier !== "undefined") {
        self.autoLoad(identifier);
    }

    self.getTypeName = function () {
        return SSITypes.SIGNED_HASH_LINK_SSI;
    }

    self.initialize = (dlDomain, hash, timestamp, signature, vn, hint) => {
        self.load(SSITypes.SIGNED_HASH_LINK_SSI, dlDomain, hash, `${timestamp}${SEPARATOR}${signature}`, vn, hint);
    };

    self.canBeVerified = () => {
        return true;
    };

    self.getHash = () => {
        const specificString = self.getSpecificString();
        if (typeof specificString !== "string") {
            console.trace("Specific string is not string", specificString.toString());
        }
        return specificString;
    };

    self.derive = () => {
        const hashLinkSSI = createHashLinkSSI();
        hashLinkSSI.load(SSITypes.HASH_LINK_SSI, self.getDLDomain(), self.getHash(), "", self.getVn(), self.getHint());
        return hashLinkSSI;
    };

    self.getTimestamp = function () {
        let control = self.getControlString();
        return control.split(SEPARATOR)[0];
    }

    self.getSignature = function (encoding) {
        if (typeof encoding === "undefined") {
            encoding = "base64";
        }
        let control = self.getControlString();
        let splitControl = control.split(SEPARATOR);
        let signature = splitControl[1];
        if (encoding === "raw") {
            const base64Decode = cryptoRegistry.getBase64DecodingFunction(self);
            return base64Decode(signature);
        }

        return signature;
    }

    self.getDataToSign = function (anchorSSI, previousAnchorValue) {
        const keySSIFactory = require("../KeySSIFactory");

        if (typeof anchorSSI === "string") {
            anchorSSI = keySSIFactory.create(anchorSSI);
        }

        if (typeof previousAnchorValue === "string") {
            previousAnchorValue = keySSIFactory.create(previousAnchorValue);
        }

        let previousIdentifier = '';
        const timestamp = self.getTimestamp();
        if (previousAnchorValue) {
            previousIdentifier = previousAnchorValue.getIdentifier(true);
        }
        return anchorSSI.getIdentifier(true) + self.getSpecificString() + previousIdentifier + timestamp;
    }
}

function createSignedHashLinkSSI(enclave, identifier) {
    return new SignedHashLinkSSI(enclave, identifier);
}

module.exports = {
    createSignedHashLinkSSI
};

},{"../../CryptoAlgorithms/CryptoAlgorithmsRegistry":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/key-ssi-resolver/lib/CryptoAlgorithms/CryptoAlgorithmsRegistry.js","../KeySSIFactory":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/key-ssi-resolver/lib/KeySSIs/KeySSIFactory.js","../KeySSIMixin":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/key-ssi-resolver/lib/KeySSIs/KeySSIMixin.js","../OtherKeySSIs/HashLinkSSI":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/key-ssi-resolver/lib/KeySSIs/OtherKeySSIs/HashLinkSSI.js","../SSITypes":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/key-ssi-resolver/lib/KeySSIs/SSITypes.js"}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/key-ssi-resolver/lib/KeySSIs/Hint.js":[function(require,module,exports){
const constants = require("./constants");

function Hint(hintSerialisation) {
    const {BRICKS_DOMAIN_KEY} = require('opendsu').constants;
    let _hintObject;

    const init = () => {
        if (hintSerialisation) {
            if (typeof hintSerialisation === "object") {
                _hintObject = hintSerialisation;
            } else {
                try {
                    _hintObject = JSON.parse(hintSerialisation);
                } catch (e) {
                    throw Error(`Hint should be a JSON. Received <${hintSerialisation}>`);
                }
            }
        }
    }

    this.set = (key, value) => {
        if (typeof _hintObject === "undefined") {
            _hintObject = {};
        }

        _hintObject[key] = value;
    }

    this.get = (key) => {
        return _hintObject[key];
    }

    this.setDSUVersion = (dsuVersion) => {
        this.set(constants.DSU_VERSION_KEY, dsuVersion);
    }

    this.getDSUVersion = () => {
        return this.get(constants.DSU_VERSION_KEY);
    }

    this.setBricksDomain = (bricksDomain) => {
        this.set(BRICKS_DOMAIN_KEY, bricksDomain);
    };

    this.getBricksDomain = () => {
        return this.get(BRICKS_DOMAIN_KEY);
    };

    this.setEmbeddedData = (embeddedData) => {
        this.set(constants.EMBEDDED_DATA_KEY, embeddedData);
    }

    this.getEmbeddedData = () => {
        return this.get(constants.EMBEDDED_DATA_KEY);
    }

    this.getSerialisation = () => {
        if (typeof _hintObject === "undefined") {
            return undefined;
        }

        let versionFreeHint = JSON.parse(JSON.stringify(_hintObject));
        if (typeof versionFreeHint[constants.DSU_VERSION_KEY] !== "undefined") {
            delete versionFreeHint[constants.DSU_VERSION_KEY];
        }

        return JSON.stringify(versionFreeHint);
    }

    init();
}

module.exports = Hint;

},{"./constants":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/key-ssi-resolver/lib/KeySSIs/constants.js","opendsu":"opendsu"}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/key-ssi-resolver/lib/KeySSIs/KeySSIFactory.js":[function(require,module,exports){
const createSecretSSI = require("./SecretSSIs/SecretSSI").createSecretSSI;
const createAnchorSSI = require("./SecretSSIs/AnchorSSI").createAnchorSSI;
const createReadSSI = require("./SecretSSIs/ReadSSI").createReadSSI;
const createPublicSSI = require("./SecretSSIs/PublicSSI").createPublicSSI;
const createZaSSI = require("./SecretSSIs/ZaSSI").createZaSSI;

const createPathKeySSI = require("./SeedSSIs/PathKeySSI").createPathKeySSI;
const createSeedSSI = require("./SeedSSIs/SeedSSI").createSeedSSI;
const createSReadSSI = require("./SeedSSIs/SReadSSI").createSReadSSI;
const createSZaSSI = require("./SeedSSIs/SZaSSI").createSZaSSI;

const createWalletSSI = require("./OtherKeySSIs/WalletSSI").createWalletSSI;
const createPasswordSSI = require("./ConstSSIs/PasswordSSI").createPasswordSSI;
const createArraySSI = require("./ConstSSIs/ArraySSI").createArraySSI;
const createConstSSI = require("./ConstSSIs/ConstSSI").createConstSSI;
const createCZaSSI = require("./ConstSSIs/CZaSSI").createCZaSSI;
const createHashLinkSSI = require("./OtherKeySSIs/HashLinkSSI").createHashLinkSSI;
const createSymmetricalEncryptionSSI = require("./OtherKeySSIs/SymmetricalEncryptionSSI").createSymmetricalEncryptionSSI;

const createTokenSSI = require("./TokenSSIs/TokenSSI").createTokenSSI;
const createOwnershipSSI = require("./OwnershipSSIs/OwnershipSSI").createOwnershipSSI;
const createOReadSSI = require("./OwnershipSSIs/OReadSSI").createOReadSSI;
const createZATSSI = require("./OwnershipSSIs/ZATSSI").createZATSSI;
const createTransferSSI = require("./TransferSSIs/TransferSSI").createTransferSSI;
const createSignedHashLinkSSI = require("./HashLinkSSIs/SignedHashLinkSSI").createSignedHashLinkSSI;

const createConsensusSSI = require("./ContractSSIs/ConsensusSSI").createConsensusSSI;
const createPublicKeySSI = require("./OtherKeySSIs/PublicKeySSI").createPublicKeySSI;

const createAliasSSI = require("./OtherKeySSIs/AliasSSI").createAliasSSI;
const createEmbedSSI = require("./OtherKeySSIs/EmbedSSI").createEmbedSSI;

const createSizeSSI = require("./OtherKeySSIs/SizeSSI").createSizeSSI;

const SSITypes = require("./SSITypes");

const registry = {};

function KeySSIFactory() {
}

KeySSIFactory.prototype.registerFactory = (typeName, vn, derivedType, functionFactory) => {
    if (typeof derivedType === "function") {
        functionFactory = derivedType;
        derivedType = undefined;
    }

    if (typeof registry[typeName] !== "undefined") {
        throw Error(`A function factory for KeySSI of type ${typeName} is already registered.`);
    }

    registry[typeName] = {derivedType, functionFactory};
};

KeySSIFactory.prototype.create = (enclave, identifier, options) => {
    if (typeof enclave === "string") {
        identifier = enclave;
        enclave = undefined;
    }

    if (typeof identifier === "undefined") {
        throw Error("An SSI should be provided");
    }

    const KeySSIMixin = require("./KeySSIMixin");
    let keySSI = {}
    KeySSIMixin(keySSI, enclave);

    try {
        keySSI.autoLoad(identifier);
    } catch (e) {
        throw createOpenDSUErrorWrapper(`Invalid format for keySSI ${identifier}`, e);
    }

    const typeName = keySSI.getTypeName();

    return KeySSIFactory.prototype.createByType(typeName, enclave, identifier, options);
};

KeySSIFactory.prototype.createByType = (typeName, enclave, identifier, options) => {
    if (typeof enclave === "string") {
        identifier = enclave;
        enclave = undefined;
    }

    if (typeof identifier === "undefined") {
        throw Error("An SSI should be provided");
    }

    if (typeof registry[typeName] === "undefined") {
        throw Error(`The type ${typeName} is not a registered KeySSI type`);
    }
    const keySSI = registry[typeName].functionFactory(enclave, identifier);
    keySSI.options = options;
    return keySSI;
};

KeySSIFactory.prototype.createType = (typeName, enclave) => {
    return registry[typeName].functionFactory(enclave);
}

KeySSIFactory.prototype.getDerivedType = (keySSI, otherType, callback) => {
    if (keySSI.getTypeName() === otherType) {
        return callback(undefined, keySSI);
    }
    let currentEntry = registry[otherType];
    if (typeof currentEntry === "undefined") {
        return callback(Error(`${otherType} is not a registered KeySSI type.`))
    }

    while (typeof currentEntry.derivedType !== "undefined") {
        if (currentEntry.derivedType === keySSI.getTypeName()) {
            return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`${otherType} is not derived from ${keySSI.getTypeName()}`));
        }
        currentEntry = registry[currentEntry.derivedType];
    }

    getDerivedKeySSI(keySSI, otherType, callback);
};

KeySSIFactory.prototype.getRelatedType = (keySSI, otherType, callback) => {
    console.log(".getRelatedType function is obsolete. Use .getDerivedType instead.");
    KeySSIFactory.prototype.getDerivedType(keySSI, otherType, callback);
}

KeySSIFactory.prototype.getAnchorType = (keySSI, callback) => {
    const __getAnchorTypeRecursively = (currentKeySSI) => {
        if (typeof registry[currentKeySSI.getTypeName()].derivedType === "undefined") {
            return callback(undefined, currentKeySSI);
        }

        currentKeySSI.derive((err, derivedKeySSI) => {
            if (err) {
                return callback(err);
            }

            __getAnchorTypeRecursively(derivedKeySSI);
        })
    }

    try {
        __getAnchorTypeRecursively(keySSI);
    } catch (e) {
        return callback(e);
    }
};

KeySSIFactory.prototype.getRootKeySSITypeName = (keySSI) => {
    if (typeof keySSI === "object") {
        return KeySSIFactory.prototype.getRootKeySSITypeName(keySSI.getTypeName())
    } else if (typeof keySSI === "string") {
        let found = 0
        for (let parentKey in registry) {
            if (registry[parentKey].derivedType === keySSI) {
                found++
                return KeySSIFactory.prototype.getRootKeySSITypeName(parentKey)
            }
        }

        if (!found || found > 1) {
            return typeof keySSI === "object" ? keySSI.getTypeName() : keySSI
        }
    } else {
        return false
    }
}

const getDerivedKeySSI = (keySSI, derivedTypeName, callback) => {

    const __getDerivedKeySSIRecursively = (currentKeySSI) => {
        let currentEntry = registry[currentKeySSI.getTypeName()];
        if (typeof currentEntry.derivedType === "undefined") {
            return callback(Error(`${derivedTypeName} is not a valid KeySSI Type`));
        }

        if (currentEntry.derivedType === derivedTypeName) {
            return currentKeySSI.derive(callback);
        }

        currentKeySSI.derive((err, derivedKeySSI) => {
            if (err) {
                return callback(err);
            }

            __getDerivedKeySSIRecursively(derivedKeySSI);
        })
    }

    try{
        __getDerivedKeySSIRecursively(keySSI);
    }catch (e) {
        return callback(e);
    }
};

KeySSIFactory.prototype.registerFactory(SSITypes.SECRET_SSI, 'v0', SSITypes.ANCHOR_SSI, createSecretSSI);
KeySSIFactory.prototype.registerFactory(SSITypes.ANCHOR_SSI, 'v0', SSITypes.READ_SSI, createAnchorSSI);
KeySSIFactory.prototype.registerFactory(SSITypes.READ_SSI, 'v0', SSITypes.PUBLIC_SSI, createReadSSI);
KeySSIFactory.prototype.registerFactory(SSITypes.PUBLIC_SSI, 'v0', SSITypes.ZERO_ACCESS_SSI, createPublicSSI);
KeySSIFactory.prototype.registerFactory(SSITypes.ZERO_ACCESS_SSI, 'v0', undefined, createZaSSI);
KeySSIFactory.prototype.registerFactory(SSITypes.PATH_SSI, 'v0', SSITypes.PATH_SSI, createPathKeySSI);
KeySSIFactory.prototype.registerFactory(SSITypes.SEED_SSI, 'v0', SSITypes.SREAD_SSI, createSeedSSI);
KeySSIFactory.prototype.registerFactory(SSITypes.WALLET_SSI, 'v0', SSITypes.CONST_SSI, createWalletSSI);
KeySSIFactory.prototype.registerFactory(SSITypes.SREAD_SSI, 'v0', SSITypes.SZERO_ACCESS_SSI, createSReadSSI);
KeySSIFactory.prototype.registerFactory(SSITypes.SZERO_ACCESS_SSI, 'v0', undefined, createSZaSSI);
KeySSIFactory.prototype.registerFactory(SSITypes.PASSWORD_SSI, 'v0', SSITypes.CONST_SSI, createPasswordSSI);
KeySSIFactory.prototype.registerFactory(SSITypes.ARRAY_SSI, 'v0', SSITypes.CONST_SSI, createArraySSI);
KeySSIFactory.prototype.registerFactory(SSITypes.CONST_SSI, 'v0', SSITypes.CONSTANT_ZERO_ACCESS_SSI, createConstSSI);
KeySSIFactory.prototype.registerFactory(SSITypes.CONSTANT_ZERO_ACCESS_SSI, 'v0', undefined, createCZaSSI);
KeySSIFactory.prototype.registerFactory(SSITypes.HASH_LINK_SSI, 'v0', undefined, createHashLinkSSI);
KeySSIFactory.prototype.registerFactory(SSITypes.SYMMETRICAL_ENCRYPTION_SSI, 'v0', undefined, createSymmetricalEncryptionSSI);

KeySSIFactory.prototype.registerFactory(SSITypes.TOKEN_SSI, 'v0', undefined, createTokenSSI);
KeySSIFactory.prototype.registerFactory(SSITypes.OWNERSHIP_SSI, 'v0', SSITypes.OWNERSHIP_READ_SSI, createOwnershipSSI);
KeySSIFactory.prototype.registerFactory(SSITypes.OWNERSHIP_READ_SSI, 'v0', SSITypes.ZERO_ACCESS_TOKEN_SSI, createOReadSSI);
KeySSIFactory.prototype.registerFactory(SSITypes.ZERO_ACCESS_TOKEN_SSI, 'v0', undefined, createZATSSI);
KeySSIFactory.prototype.registerFactory(SSITypes.TRANSFER_SSI, 'v0', undefined, createTransferSSI);
KeySSIFactory.prototype.registerFactory(SSITypes.SIGNED_HASH_LINK_SSI, 'v0', SSITypes.HASH_LINK_SSI, createSignedHashLinkSSI);

KeySSIFactory.prototype.registerFactory(SSITypes.CONSENSUS_SSI, 'v0', undefined, createConsensusSSI);
KeySSIFactory.prototype.registerFactory(SSITypes.PUBLIC_KEY_SSI, 'v0', undefined, createPublicKeySSI);

KeySSIFactory.prototype.registerFactory(SSITypes.ALIAS_SSI, 'v0', undefined, createAliasSSI);
KeySSIFactory.prototype.registerFactory(SSITypes.EMBED_SSI, 'v0', undefined, createEmbedSSI);

KeySSIFactory.prototype.registerFactory(SSITypes.SIZE_SSI, 'v0', undefined, createSizeSSI);

module.exports = new KeySSIFactory();

},{"./ConstSSIs/ArraySSI":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/key-ssi-resolver/lib/KeySSIs/ConstSSIs/ArraySSI.js","./ConstSSIs/CZaSSI":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/key-ssi-resolver/lib/KeySSIs/ConstSSIs/CZaSSI.js","./ConstSSIs/ConstSSI":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/key-ssi-resolver/lib/KeySSIs/ConstSSIs/ConstSSI.js","./ConstSSIs/PasswordSSI":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/key-ssi-resolver/lib/KeySSIs/ConstSSIs/PasswordSSI.js","./ContractSSIs/ConsensusSSI":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/key-ssi-resolver/lib/KeySSIs/ContractSSIs/ConsensusSSI.js","./HashLinkSSIs/SignedHashLinkSSI":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/key-ssi-resolver/lib/KeySSIs/HashLinkSSIs/SignedHashLinkSSI.js","./KeySSIMixin":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/key-ssi-resolver/lib/KeySSIs/KeySSIMixin.js","./OtherKeySSIs/AliasSSI":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/key-ssi-resolver/lib/KeySSIs/OtherKeySSIs/AliasSSI.js","./OtherKeySSIs/EmbedSSI":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/key-ssi-resolver/lib/KeySSIs/OtherKeySSIs/EmbedSSI.js","./OtherKeySSIs/HashLinkSSI":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/key-ssi-resolver/lib/KeySSIs/OtherKeySSIs/HashLinkSSI.js","./OtherKeySSIs/PublicKeySSI":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/key-ssi-resolver/lib/KeySSIs/OtherKeySSIs/PublicKeySSI.js","./OtherKeySSIs/SizeSSI":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/key-ssi-resolver/lib/KeySSIs/OtherKeySSIs/SizeSSI.js","./OtherKeySSIs/SymmetricalEncryptionSSI":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/key-ssi-resolver/lib/KeySSIs/OtherKeySSIs/SymmetricalEncryptionSSI.js","./OtherKeySSIs/WalletSSI":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/key-ssi-resolver/lib/KeySSIs/OtherKeySSIs/WalletSSI.js","./OwnershipSSIs/OReadSSI":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/key-ssi-resolver/lib/KeySSIs/OwnershipSSIs/OReadSSI.js","./OwnershipSSIs/OwnershipSSI":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/key-ssi-resolver/lib/KeySSIs/OwnershipSSIs/OwnershipSSI.js","./OwnershipSSIs/ZATSSI":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/key-ssi-resolver/lib/KeySSIs/OwnershipSSIs/ZATSSI.js","./SSITypes":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/key-ssi-resolver/lib/KeySSIs/SSITypes.js","./SecretSSIs/AnchorSSI":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/key-ssi-resolver/lib/KeySSIs/SecretSSIs/AnchorSSI.js","./SecretSSIs/PublicSSI":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/key-ssi-resolver/lib/KeySSIs/SecretSSIs/PublicSSI.js","./SecretSSIs/ReadSSI":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/key-ssi-resolver/lib/KeySSIs/SecretSSIs/ReadSSI.js","./SecretSSIs/SecretSSI":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/key-ssi-resolver/lib/KeySSIs/SecretSSIs/SecretSSI.js","./SecretSSIs/ZaSSI":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/key-ssi-resolver/lib/KeySSIs/SecretSSIs/ZaSSI.js","./SeedSSIs/PathKeySSI":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/key-ssi-resolver/lib/KeySSIs/SeedSSIs/PathKeySSI.js","./SeedSSIs/SReadSSI":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/key-ssi-resolver/lib/KeySSIs/SeedSSIs/SReadSSI.js","./SeedSSIs/SZaSSI":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/key-ssi-resolver/lib/KeySSIs/SeedSSIs/SZaSSI.js","./SeedSSIs/SeedSSI":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/key-ssi-resolver/lib/KeySSIs/SeedSSIs/SeedSSI.js","./TokenSSIs/TokenSSI":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/key-ssi-resolver/lib/KeySSIs/TokenSSIs/TokenSSI.js","./TransferSSIs/TransferSSI":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/key-ssi-resolver/lib/KeySSIs/TransferSSIs/TransferSSI.js"}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/key-ssi-resolver/lib/KeySSIs/KeySSIMixin.js":[function(require,module,exports){
const cryptoRegistry = require("../CryptoAlgorithms/CryptoAlgorithmsRegistry");
const pskCrypto = require("pskcrypto");
const SSITypes = require("./SSITypes");
const Hint = require("./Hint");
const MAX_KEYSSI_LENGTH = 2048

function keySSIMixin(target, enclave) {
    let _prefix = "ssi";
    let _subtype;
    let _dlDomain;
    let _subtypeSpecificString;
    let _controlString;
    let _vn = "v0";
    let _hint;
    let _canSign = false;

    const _createHint = (hintSerialisation) => {
        if (_hint instanceof Hint) {
            return;
        }

        _hint = new Hint(hintSerialisation);
    }

    target.autoLoad = function (identifier) {
        if (typeof identifier === "undefined") {
            return;
        }

        if (typeof identifier !== "string") {
            throw new Error("The identifier should be string");
        }

        target.validateKeySSICharLength();

        let originalId = identifier;
        if (identifier.indexOf(":") === -1) {
            identifier = pskCrypto.pskBase58Decode(identifier).toString();
        }

        if (identifier.indexOf(":") === -1) {
            throw new Error(`Wrong format of SSI. ${originalId} ${identifier}`);
        }

        let segments = identifier.split(":");
        segments.shift();
        _subtype = segments.shift();
        _dlDomain = segments.shift();
        _subtypeSpecificString = segments.shift();
        _controlString = segments.shift();
        let version = segments.shift();
        if (version !== '') {
            _vn = version;
        }
        if (segments.length > 0) {
            _hint = segments.join(":");
            _createHint(_hint);
        }

        // _subtypeSpecificString = cryptoRegistry.getDecodingFunction(target)(_subtypeSpecificString);
    }

    target.validateKeySSICharLength = () => {
        if (target.getIdentifier() > MAX_KEYSSI_LENGTH) {
            throw new Error(`The identifier length exceed maximum char length ${MAX_KEYSSI_LENGTH}`);
        }
    }

    target.load = function (subtype, dlDomain, subtypeSpecificString, control, vn, hint) {
        _subtype = subtype;
        _dlDomain = dlDomain;
        _subtypeSpecificString = subtypeSpecificString;
        _controlString = control || '';
        _vn = vn || "v0";
        _hint = hint;

        if (_hint) {
            _createHint(_hint)
        }
        target.validateKeySSICharLength();
    }

    /**
     *
     * @param ssiType - string
     * @param callback - function
     */
    target.getDerivedType = function (ssiType, callback) {
        const KeySSIFactory = require("./KeySSIFactory");
        KeySSIFactory.getDerivedType(target, ssiType, callback);
    }

    target.getRelatedType = function (ssiType, callback) {
        console.log(".getRelatedType function is obsolete. Use .getDerivedType instead.");
        target.getDerivedType(ssiType, callback);
    }

    target.getRootKeySSITypeName = function () {
        const KeySSIFactory = require("./KeySSIFactory");
        return KeySSIFactory.getRootKeySSITypeName(target);
    }

    target.getAnchorId = function (plain, callback) {
        if (typeof plain === "function") {
            callback = plain;
            plain = false;
        }
        const keySSIFactory = require("./KeySSIFactory");
        keySSIFactory.getAnchorType(target, (err, anchorSSI) => {
            if (err) {
                return callback(err);
            }

            callback(undefined, anchorSSI.getNoHintIdentifier(plain));
        })
    }

    target.getSpecificString = function () {
        return _subtypeSpecificString;
    }

    target.getName = function () {
        console.trace("Obsolete function. Replace with getTypeName");
        return _subtype;
    }

    target.getTypeName = function () {
        return _subtype;
    }

    target.getDLDomain = function () {
        if (_dlDomain === '' || typeof _dlDomain === "undefined") {
            return undefined;
        }

        if (_dlDomain.startsWith("$")) {
            return process.env[_dlDomain.slice(1)];
        }

        return _dlDomain;
    }

    target.getControlString = function () {
        return _controlString || '';
    }

    target.getHint = function () {
        return _hint;
    }

    target.getVn = function () {
        return _vn;
    }
    
    target.getDSURepresentationName = function () {
        const DSURepresentationNames = require("./DSURepresentationNames");
        return DSURepresentationNames[_subtype];
    }

    target.getNoHintIdentifier = function (plain) {
        let identifier = `${_prefix}:${target.getTypeName()}:${target.getDLDomain()}:${target.getSpecificString()}:${target.getControlString()}:${target.getVn()}`;
        return plain ? identifier : pskCrypto.pskBase58Encode(identifier);
    }

    target.getIdentifier = function (plain) {
        let id = target.getNoHintIdentifier(true);

        if (typeof _hint !== "undefined") {
            id += ":" + _hint.getSerialisation();
        }

        return plain ? id : pskCrypto.pskBase58Encode(id);
    }

    target.getBricksDomain = function () {
        let bricksDomain
        try {
            bricksDomain = _hint.getBricksDomain();
        } catch (e) {

        }
        return bricksDomain ? bricksDomain : _dlDomain;
    }

    target.getDSUVersionHint = function () {
        if (typeof _hint !== "undefined") {
            return _hint.getDSUVersion();
        }

        return undefined;
    }

    target.setDSUVersionHint = function (version) {
        if (typeof _hint === "undefined") {
            _createHint();
        }

        _hint.setDSUVersion(version);
    }

    target.setEmbeddedData = function (embeddedData) {
        if (typeof _hint === "undefined") {
            _createHint();
        }

        _hint.setEmbeddedData(embeddedData);
    }

    target.getEmbeddedData = function () {
        if (typeof _hint === "undefined") {
            return;
        }

        return _hint.getEmbeddedData();
    }

    target.clone = function () {
        let clone = {};
        clone.prototype = target.prototype;
        for (let attr in target) {
            if (target.hasOwnProperty(attr)) {
                clone[attr] = target[attr];
            }
        }
        keySSIMixin(clone);
        return clone;
    }

    /*
    * This method is meant to be used in order to cast between similar types of SSIs
    * e.g. WalletSSI to ArraySSI
    *
    * */
    target.cast = function (newType) {
        target.getTypeName = () => {
            return newType;
        };
        target.load(newType, _dlDomain, _subtypeSpecificString, _controlString, _vn, _hint);
    }

    target.canSign = () => {
        return _canSign;
    }

    target.setCanSign = (canSign) => {
        _canSign = canSign;
    }

    target.canBeVerified = () => {
        return false;
    };

    target.sign = (dataToSign, callback) => {
        if (typeof enclave !== "undefined") {
            return enclave.signForKeySSI(undefined, target, dataToSign, callback);
        }
        const sc = require("opendsu").loadAPI("sc").getSecurityContext();
        sc.signForKeySSI(undefined, target, dataToSign, callback);
    };

    target.verify = (data, signature) => {
        const decode = cryptoRegistry.getBase64DecodingFunction(target);
        signature = decode(signature);
        const verify = cryptoRegistry.getVerifyFunction(target);

        return verify(data, target.getPublicKey(), signature);
    };

    target.hash = (data) => {
        return cryptoRegistry.getHashFunction(target)(data);
    }

    target.toJSON = function () {
        return target.getIdentifier();
    }

    target.canAppend = function () {
        return true;
    }

    target.isTransfer = function () {
        return false;
    }

    target.isAlias = function () {
        return false;
    }

    target.isEmbed = function () {
        return false;
    }

    target.withoutCryptoData = function () {
        if (!_subtypeSpecificString && !_controlString) {
            return true;
        }

        return false;
    }

    target.createAnchorValue = function (brickMapHash, previousAnchorValue, callback) {
        const keySSIFactory = require("./KeySSIFactory");

        const signedHashLinkSSI = keySSIFactory.createType(SSITypes.SIGNED_HASH_LINK_SSI);
        target.getAnchorId(true, (err, anchorId) => {
            if (err) {
                return callback(err);
            }
            if (typeof previousAnchorValue === "string") {
                previousAnchorValue = keySSIFactory.create(previousAnchorValue);
            }

            let previousIdentifier = '';
            const timestamp = Date.now();
            if (previousAnchorValue) {
                previousIdentifier = previousAnchorValue.getIdentifier(true);
            }
            let dataToSign = anchorId + brickMapHash + previousIdentifier + timestamp;
            target.sign(dataToSign, (err, signature) => {
                if (err) {
                    return callback(err);
                }

                signedHashLinkSSI.initialize(target.getBricksDomain(), brickMapHash, timestamp, signature, target.getVn(), target.getHint());
                callback(undefined, signedHashLinkSSI);
            })
        })
    }

    return target;
}

module.exports = keySSIMixin;

},{"../CryptoAlgorithms/CryptoAlgorithmsRegistry":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/key-ssi-resolver/lib/CryptoAlgorithms/CryptoAlgorithmsRegistry.js","./DSURepresentationNames":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/key-ssi-resolver/lib/KeySSIs/DSURepresentationNames.js","./Hint":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/key-ssi-resolver/lib/KeySSIs/Hint.js","./KeySSIFactory":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/key-ssi-resolver/lib/KeySSIs/KeySSIFactory.js","./SSITypes":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/key-ssi-resolver/lib/KeySSIs/SSITypes.js","opendsu":"opendsu","pskcrypto":"pskcrypto"}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/key-ssi-resolver/lib/KeySSIs/OtherKeySSIs/AliasSSI.js":[function(require,module,exports){
const SSITypes = require("../SSITypes");

function AliasSSI(enclave, identifier) {
    if (typeof enclave === "string") {
        identifier = enclave;
        enclave = undefined;
    }
    const KeySSIMixin = require("../KeySSIMixin");
    KeySSIMixin(this, enclave);

    if (typeof identifier !== "undefined") {
        this.autoLoad(identifier);
    }

    this.initialize = (domain, alias, vn, hint, callback) => {
        if (typeof alias === "function") {
            callback = alias;
            alias = domain;
            domain = undefined;
        }

        if (typeof vn === "function") {
            callback = vn;
            vn = 'v0';
        }
        if (typeof hint === "function") {
            callback = hint;
            hint = undefined;
        }
        if (typeof domain === "undefined") {
            if (process.env.VAULT_DOMAIN) {
                this.load(SSITypes.ALIAS_SSI, process.env.VAULT_DOMAIN, alias, '', vn, hint);
                return callback(undefined, this);
            }

            const scAPI = require("opendsu").loadAPI("sc");
            return scAPI.getVaultDomain((err, vaultDomain) => {
                if (err) {
                    return callback(err);
                }

                this.load(SSITypes.ALIAS_SSI, vaultDomain, alias, '', vn, hint);
                return callback(undefined, this);
            });
        }

        this.load(SSITypes.ALIAS_SSI, domain, alias, '', vn, hint);
        callback(undefined, this);
    };

    this.isAlias = () => {
        return true;

    }
    this.derive = () => {
        throw Error("Alias SSI cannot be derived");
    }
}

const createAliasSSI = (enclave, identifier) => {
    return new AliasSSI(enclave, identifier);
}

module.exports = {
    createAliasSSI
};
},{"../KeySSIMixin":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/key-ssi-resolver/lib/KeySSIs/KeySSIMixin.js","../SSITypes":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/key-ssi-resolver/lib/KeySSIs/SSITypes.js","opendsu":"opendsu"}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/key-ssi-resolver/lib/KeySSIs/OtherKeySSIs/EmbedSSI.js":[function(require,module,exports){
const KeySSIMixin = require("../KeySSIMixin");
const SSITypes = require("../SSITypes");
const cryptoRegistry = require("../../CryptoAlgorithms/CryptoAlgorithmsRegistry");

function EmbedSSI(enclave, identifier) {
    if (typeof enclave === "string") {
        identifier = enclave;
        enclave = undefined;
    }
    KeySSIMixin(this, enclave);
    const self = this;

    if (typeof identifier !== "undefined") {
        self.autoLoad(identifier);
    }

    self.getTypeName = function () {
        return SSITypes.EMBED_SSI;
    }

    const originalGetSpecificString = self.getSpecificString;

    self.initialize = (dlDomain, data, vn, hint) => {
        if (!$$.Buffer.isBuffer(data)) {
            data = $$.Buffer.from(data);
        }
        data = cryptoRegistry.getBase64EncodingFunction(self)(data);
        self.load(SSITypes.EMBED_SSI, dlDomain, data, '', vn, hint);
    };

    self.getSpecificString = () => {
        return cryptoRegistry.getBase64DecodingFunction(self)(originalGetSpecificString());
    }

    self.isEmbed = () => {
        return true;
    }

    
}

function createEmbedSSI(enclave, identifier) {
    return new EmbedSSI(enclave, identifier);
}

module.exports = {
    createEmbedSSI
};

},{"../../CryptoAlgorithms/CryptoAlgorithmsRegistry":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/key-ssi-resolver/lib/CryptoAlgorithms/CryptoAlgorithmsRegistry.js","../KeySSIMixin":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/key-ssi-resolver/lib/KeySSIs/KeySSIMixin.js","../SSITypes":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/key-ssi-resolver/lib/KeySSIs/SSITypes.js"}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/key-ssi-resolver/lib/KeySSIs/OtherKeySSIs/HashLinkSSI.js":[function(require,module,exports){
const KeySSIMixin = require("../KeySSIMixin");
const SSITypes = require("../SSITypes");

function HashLinkSSI(enclave, identifier) {
    if (typeof enclave === "string") {
        identifier = enclave;
        enclave = undefined;
    }
    KeySSIMixin(this, enclave);
    const self = this;

    if (typeof identifier !== "undefined") {
        self.autoLoad(identifier);
    }

    self.getTypeName = function () {
        return SSITypes.HASH_LINK_SSI;
    }

    self.initialize = (dlDomain, hash, vn, hint) => {
        self.load(SSITypes.HASH_LINK_SSI, dlDomain, hash, '', vn, hint);
    };

    self.getHash = () => {
        const specificString = self.getSpecificString();
        if (typeof specificString !== "string") {
            console.trace("Specific string is not string", specificString.toString());
        }
        return specificString;
    };

    
}

function createHashLinkSSI(enclave, identifier) {
    return new HashLinkSSI(enclave, identifier);
}

module.exports = {
    createHashLinkSSI
};

},{"../KeySSIMixin":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/key-ssi-resolver/lib/KeySSIs/KeySSIMixin.js","../SSITypes":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/key-ssi-resolver/lib/KeySSIs/SSITypes.js"}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/key-ssi-resolver/lib/KeySSIs/OtherKeySSIs/PublicKeySSI.js":[function(require,module,exports){
const KeySSIMixin = require("../KeySSIMixin");
const SSITypes = require("../SSITypes");
const cryptoRegistry = require("../../CryptoAlgorithms/CryptoAlgorithmsRegistry");

function PublicKeySSI(enclave, identifier) {
    if (typeof enclave === "string") {
        identifier = enclave;
        enclave = undefined;
    }
    KeySSIMixin(this, enclave);
    const self = this;

    if (typeof identifier !== "undefined") {
        self.autoLoad(identifier);
    }

    self.getTypeName = function () {
        return SSITypes.PUBLIC_KEY_SSI;
    }

    self.initialize = (compatibleFamilyName, publicKey, vn) => {
        publicKey = cryptoRegistry.getBase64EncodingFunction(self)(publicKey);
        self.load(SSITypes.PUBLIC_KEY_SSI, '', compatibleFamilyName, publicKey, vn);
    };

    self.getPublicKey = (format) => {
        let publicKey = cryptoRegistry.getBase64DecodingFunction(self)(self.getControlString());
        if (format !== "raw") {
            publicKey = cryptoRegistry.getConvertPublicKeyFunction(self)(publicKey, {outputFormat: format});
        }

        return publicKey;
    };

    self.generateCompatiblePowerfulKeySSI = (callback) => {
        const keySSIFactory = require("../KeySSIFactory");
        const powerfulSSI = keySSIFactory.createType(self.getSpecificString());
        powerfulSSI.initialize(self.getDLDomain(), undefined, undefined, self.getVn(), callback);
    }
    
}

function createPublicKeySSI(enclave, identifier) {
    return new PublicKeySSI(enclave, identifier);
}

module.exports = {
    createPublicKeySSI
};

},{"../../CryptoAlgorithms/CryptoAlgorithmsRegistry":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/key-ssi-resolver/lib/CryptoAlgorithms/CryptoAlgorithmsRegistry.js","../KeySSIFactory":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/key-ssi-resolver/lib/KeySSIs/KeySSIFactory.js","../KeySSIMixin":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/key-ssi-resolver/lib/KeySSIs/KeySSIMixin.js","../SSITypes":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/key-ssi-resolver/lib/KeySSIs/SSITypes.js"}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/key-ssi-resolver/lib/KeySSIs/OtherKeySSIs/SizeSSI.js":[function(require,module,exports){
const SSITypes = require("../SSITypes");
const KeySSIMixin = require("../KeySSIMixin");

function SizeSSI(enclave, identifier) {
    if (typeof enclave === "string") {
        identifier = enclave;
        enclave = undefined;
    }

    KeySSIMixin(this);
    const self = this;

    if (typeof identifier !== "undefined") {
        self.autoLoad(identifier);
    }

    self.initialize = (domain, totalSize, bufferSize, vn, hint) => {
        if (!domain) {
            throw new Error("domain is required");
        }
        if (totalSize == null) {
            throw new Error("totalSize is required");
        }
        if (bufferSize == null) {
            bufferSize = totalSize;
            vn = "v0";
        }
        if (vn == null) {
            vn = "v0";
        }

        self.load(SSITypes.SIZE_SSI, domain, totalSize, bufferSize, vn, hint);
    };

    self.isSizeSSI = () => {
        return true;
    };

    self.getTotalSize = () => {
        return parseInt(self.getSpecificString(), 10);
    };

    self.getBufferSize = () => {
        return parseInt(self.getControlString(), 10);
    };

    self.derive = () => {
        throw Error("Size SSI cannot be derived");
    };
}

const createSizeSSI = (enclave, identifier) => {
    return new SizeSSI(enclave, identifier);
};

module.exports = {
    createSizeSSI,
};

},{"../KeySSIMixin":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/key-ssi-resolver/lib/KeySSIs/KeySSIMixin.js","../SSITypes":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/key-ssi-resolver/lib/KeySSIs/SSITypes.js"}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/key-ssi-resolver/lib/KeySSIs/OtherKeySSIs/SymmetricalEncryptionSSI.js":[function(require,module,exports){
const KeySSIMixin = require("../KeySSIMixin");
const SSITypes = require("../SSITypes");
const cryptoRegistry = require("../../CryptoAlgorithms/CryptoAlgorithmsRegistry");

function SymmetricalEncryptionSSI(enclave, identifier) {
    if (typeof enclave === "string") {
        identifier = enclave;
        enclave = undefined;
    }
    KeySSIMixin(this, enclave);
    const self = this;
    if (typeof identifier !== "undefined") {
        self.autoLoad(identifier);
    }

    self.getTypeName = () => {
        return SSITypes.SYMMETRICAL_ENCRYPTION_SSI;
    };

    let load = self.load;
    self.load = function (subtype, dlDomain, encryptionKey, control, vn, hint){
        if (typeof encryptionKey === "undefined") {
            encryptionKey = cryptoRegistry.getEncryptionKeyGenerationFunction(self)();
        }

        if ($$.Buffer.isBuffer(encryptionKey)) {
            encryptionKey = cryptoRegistry.getBase64EncodingFunction(self)(encryptionKey);
        }

        load(subtype, dlDomain, encryptionKey, '', vn, hint);
    }

    self.getEncryptionKey = function(callback) {
        const encryptionKey = cryptoRegistry.getBase64DecodingFunction(self)(self.getSpecificString());
        callback(undefined, encryptionKey);
    };

    self.derive = function (){
        throw Error("Not implemented");
    }
}

function createSymmetricalEncryptionSSI(enclave, identifier) {
    return new SymmetricalEncryptionSSI(enclave, identifier);
}

module.exports = {
    createSymmetricalEncryptionSSI
};

},{"../../CryptoAlgorithms/CryptoAlgorithmsRegistry":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/key-ssi-resolver/lib/CryptoAlgorithms/CryptoAlgorithmsRegistry.js","../KeySSIMixin":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/key-ssi-resolver/lib/KeySSIs/KeySSIMixin.js","../SSITypes":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/key-ssi-resolver/lib/KeySSIs/SSITypes.js"}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/key-ssi-resolver/lib/KeySSIs/OtherKeySSIs/WalletSSI.js":[function(require,module,exports){
const ArraySSI = require("./../ConstSSIs/ArraySSI");
const SSITypes = require("../SSITypes");

function WalletSSI(enclave, identifier) {
    const self = this;
    const arraySSI = ArraySSI.createArraySSI(enclave, identifier);

    arraySSI.getTypeName = () => {
        return SSITypes.WALLET_SSI;
    };

    Object.assign(self, arraySSI);
}

function createWalletSSI(enclave, identifier) {
    return new WalletSSI(enclave, identifier);
}

module.exports = {
    createWalletSSI
}

},{"../SSITypes":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/key-ssi-resolver/lib/KeySSIs/SSITypes.js","./../ConstSSIs/ArraySSI":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/key-ssi-resolver/lib/KeySSIs/ConstSSIs/ArraySSI.js"}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/key-ssi-resolver/lib/KeySSIs/OwnershipSSIs/OReadSSI.js":[function(require,module,exports){
const KeySSIMixin = require("../KeySSIMixin");
const ZATSSI = require("./ZATSSI");
const SSITypes = require("../SSITypes");
const cryptoRegistry = require("../../CryptoAlgorithms/CryptoAlgorithmsRegistry");

function OReadSSI(identifier) {
    KeySSIMixin(this);
    const self = this;

    if (typeof identifier !== "undefined") {
        self.autoLoad(identifier);
    }

    self.getTypeName = function () {
        return SSITypes.OWNERSHIP_READ_SSI;
    }

    self.initialize = (dlDomain, hashPrivateKey, hashPublicKeyLevelAndToken, vn, hint) => {
        self.load(SSITypes.OWNERSHIP_READ_SSI, dlDomain, hashPrivateKey, hashPublicKeyLevelAndToken, vn, hint);
    };

    self.derive = (callback) => {
        const zatSSI = ZATSSI.createZATSSI();
        const token = self.getToken();
        const hashPublicKey = self.getHashPublicKey();
        zatSSI.load(
            SSITypes.ZERO_ACCESS_TOKEN_SSI,
            self.getDLDomain(),
            token,
            hashPublicKey,
            self.getVn(),
            self.getHint()
        );
        callback(undefined, zatSSI);
    };

    self.getEncryptionKey = (callback) => {
        const encryptionKey = cryptoRegistry.getBase64DecodingFunction(self)(self.getHashPublicKey());
        callback(undefined, encryptionKey);
    };

    const getControlParts = function () {
        let control = self.getControlString();
        if (control == null) {
            throw Error("Operation requested on an invalid OwnershipSSI. Initialise first");
        }
        return control.split("/");
    };

    self.getHashPublicKey = function () {
        let token = getControlParts()[0];
        return token;
    };

    self.getLevel = function () {
        let level = getControlParts()[1];
        return level;
    };

    self.getToken = function () {
        let token = getControlParts()[2];
        return token;
    };
}

function createOReadSSI(identifier) {
    return new OReadSSI(identifier);
}

module.exports = {
    createOReadSSI
};

},{"../../CryptoAlgorithms/CryptoAlgorithmsRegistry":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/key-ssi-resolver/lib/CryptoAlgorithms/CryptoAlgorithmsRegistry.js","../KeySSIMixin":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/key-ssi-resolver/lib/KeySSIs/KeySSIMixin.js","../SSITypes":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/key-ssi-resolver/lib/KeySSIs/SSITypes.js","./ZATSSI":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/key-ssi-resolver/lib/KeySSIs/OwnershipSSIs/ZATSSI.js"}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/key-ssi-resolver/lib/KeySSIs/OwnershipSSIs/OwnershipSSI.js":[function(require,module,exports){
const KeySSIMixin = require("../KeySSIMixin");
const OReadSSI = require("./OReadSSI");
const SSITypes = require("../SSITypes");
const cryptoRegistry = require("../../CryptoAlgorithms/CryptoAlgorithmsRegistry");

function OwnershipSSI(identifier) {
    KeySSIMixin(this);
    const self = this;
    if (typeof identifier !== "undefined") {
        self.autoLoad(identifier);
    }

    self.getTypeName = function () {
        return SSITypes.OWNERSHIP_SSI;
    }

    self.setCanSign(true);

    self.initialize = function (dlDomain, privateKey, levelAndToken, vn, hint, callback) {
        if (typeof privateKey === "function") {
            callback = privateKey;
            privateKey = undefined;
        }
        if (typeof levelAndToken === "function") {
            callback = levelAndToken;
            levelAndToken = undefined;
        }
        if (typeof vn === "function") {
            callback = vn;
            vn = "v0";
        }
        if (typeof hint === "function") {
            callback = hint;
            hint = undefined;
        }

        if (typeof privateKey === "undefined") {
            cryptoRegistry
                .getKeyPairGenerator(self)()
                .generateKeyPair((err, publicKey, privateKey) => {
                    if (err) {
                        return OpenDSUSafeCallback(callback)(
                            createOpenDSUErrorWrapper(`Failed generate private/public key pair`, err)
                        );
                    }
                    privateKey = cryptoRegistry.getBase64EncodingFunction(self)(privateKey);
                    self.load(SSITypes.OWNERSHIP_SSI, dlDomain, privateKey, levelAndToken, vn, hint);
                    if (callback) {
                        callback(undefined, self);
                    }
                });
        } else {
            self.load(SSITypes.OWNERSHIP_SSI, dlDomain, privateKey, levelAndToken, vn, hint);
            if (callback) {
                callback(undefined, self);
            }
        }
        self.initialize = function () {
            throw Error("KeySSI already initialized");
        };
    };

    self.derive = function (callback) {
        const oReadSSI = OReadSSI.createOReadSSI();
        const privateKey = self.getPrivateKey();
        const publicKey = cryptoRegistry.getDerivePublicKeyFunction(self)(privateKey, "raw");
        const publicKeyHash = cryptoRegistry.getHashFunction(self)(publicKey);
        const levelAndToken = self.getControlString();

        const oReadSpecificString = cryptoRegistry.getHashFunction(self)(privateKey);
        const oReadControl = `${publicKeyHash}/${levelAndToken}`;
        oReadSSI.load(
            SSITypes.OWNERSHIP_READ_SSI,
            self.getDLDomain(),
            oReadSpecificString,
            oReadControl,
            self.getVn(),
            self.getHint()
        );
        callback(undefined, oReadSSI);
    };

    self.getPrivateKey = function (format) {
        let validSpecificString = self.getSpecificString();
        if (validSpecificString === undefined) {
            throw Error("Operation requested on an invalid OwnershipSSI. Initialise first");
        }
        let privateKey = validSpecificString;
        if (typeof privateKey === "string") {
            privateKey = cryptoRegistry.getBase64DecodingFunction(self)(privateKey);
        }
        if (format === "pem") {
            const pemKeys = cryptoRegistry.getKeyPairGenerator(self)().getPemKeys(privateKey, self.getPublicKey("raw"));
            privateKey = pemKeys.privateKey;
        }
        return privateKey;
    };

    self.sign = function (dataToSign, callback) {
        const privateKey = self.getPrivateKey();
        const sign = cryptoRegistry.getSignFunction(self);
        const encode = cryptoRegistry.getBase64EncodingFunction(self);
        const digitalProof = {};
        digitalProof.signature = encode(sign(dataToSign, privateKey));
        digitalProof.publicKey = encode(self.getPublicKey("raw"));

        callback(undefined, digitalProof);
    }


    self.getPrivateKeyHash = function () {
        return cryptoRegistry.getHashFunction(self)(self.getPrivateKey());
    };

    self.getPublicKey = function (format) {
        return cryptoRegistry.getDerivePublicKeyFunction(self)(self.getPrivateKey(), format);
    };

    self.getPublicKeyHash = function () {
        // const publicKey = cryptoRegistry.getDerivePublicKeyFunction(self)(self.getPrivateKey(), "raw");
        const publicKey = self.getPublicKey("raw");
        const publicKeyHash = cryptoRegistry.getHashFunction(self)(publicKey);
        return publicKeyHash;
    };

    self.getEncryptionKey = function (callback) {
        self.derive((err, derivedKeySSI) => {
            if (err) {
                return callback(err);
            }

            derivedKeySSI.getEncryptionKey(callback);
        });
    };

    const getControlParts = function () {
        let control = self.getControlString();
        if (control == null) {
            throw Error("Operation requested on an invalid OwnershipSSI. Initialise first");
        }
        return control.split("/");
    };

    self.getLevel = function () {
        let level = getControlParts()[0];
        return level;
    };

    self.getToken = function () {
        let token = getControlParts()[1];
        return token;
    };

    self.getAnchorId = function () {
        return self.getToken();
    };
}

function createOwnershipSSI(identifier) {
    return new OwnershipSSI(identifier);
}

module.exports = {
    createOwnershipSSI
};

},{"../../CryptoAlgorithms/CryptoAlgorithmsRegistry":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/key-ssi-resolver/lib/CryptoAlgorithms/CryptoAlgorithmsRegistry.js","../KeySSIMixin":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/key-ssi-resolver/lib/KeySSIs/KeySSIMixin.js","../SSITypes":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/key-ssi-resolver/lib/KeySSIs/SSITypes.js","./OReadSSI":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/key-ssi-resolver/lib/KeySSIs/OwnershipSSIs/OReadSSI.js"}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/key-ssi-resolver/lib/KeySSIs/OwnershipSSIs/ZATSSI.js":[function(require,module,exports){
const KeySSIMixin = require("../KeySSIMixin");
const SSITypes = require("../SSITypes");

function ZATSSI(identifier) {
    const self = this;
    KeySSIMixin(self);

    if (typeof identifier !== "undefined") {
        self.autoLoad(identifier);
    }

    self.getTypeName = function () {
        return SSITypes.ZERO_ACCESS_TOKEN_SSI;
    }

    self.initialize = (dlDomain, token, hashInitialOwnerPublicKey, vn, hint) => {
        self.load(SSITypes.ZERO_ACCESS_TOKEN_SSI, dlDomain, token, hashInitialOwnerPublicKey, vn, hint);
    };

    
}

function createZATSSI(identifier) {
    return new ZATSSI(identifier);
}

module.exports = {
    createZATSSI
};

},{"../KeySSIMixin":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/key-ssi-resolver/lib/KeySSIs/KeySSIMixin.js","../SSITypes":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/key-ssi-resolver/lib/KeySSIs/SSITypes.js"}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/key-ssi-resolver/lib/KeySSIs/SSITypes.js":[function(require,module,exports){
module.exports = {
    DEFAULT: "default",
    SECRET_SSI: "secret",
    ANCHOR_SSI: "anchor",
    READ_SSI: "read",
    PUBLIC_SSI: "public",
    ZERO_ACCESS_SSI: "za",
    PATH_SSI: "path",
    SEED_SSI: "seed",
    SREAD_SSI: "sread",
    SZERO_ACCESS_SSI: "sza",
    PASSWORD_SSI: "pass",
    CONST_SSI: "const",
    CONSTANT_ZERO_ACCESS_SSI: "cza",
    ARRAY_SSI: "array",
    HASH_LINK_SSI: "hl",
    WALLET_SSI: "wallet",
    SYMMETRICAL_ENCRYPTION_SSI: "se",
    TOKEN_SSI: "token",
    OWNERSHIP_SSI: "own",
    OWNERSHIP_READ_SSI: "oread",
    ZERO_ACCESS_TOKEN_SSI: "zat",
    TRANSFER_SSI: "transfer",
    SIGNED_HASH_LINK_SSI: "shl",
    CONSENSUS_SSI: "consensus",
    PUBLIC_KEY_SSI: "pk",
    ALIAS_SSI: "alias",
    SIZE_SSI: "size",
    EMBED_SSI: "embed"
};

},{}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/key-ssi-resolver/lib/KeySSIs/SecretSSIs/AnchorSSI.js":[function(require,module,exports){
const KeySSIMixin = require("../KeySSIMixin");
const ReadSSI = require("./ReadSSI");
const SSITypes = require("../SSITypes");
const cryptoRegistry = require("../../CryptoAlgorithms/CryptoAlgorithmsRegistry");

function AnchorSSI(identifier) {
    KeySSIMixin(this);

    if (typeof identifier !== "undefined") {
        this.autoLoad(identifier);
    }

    this.derive = (callback) => {
        const readSSI = ReadSSI.createReadSSI();
        this.getEncryptionKey((err, encryptionKey) => {
            if (err) {
                return callback(err);
            }

            const subtypeKey = cryptoRegistry.getHashFunction(this)(encryptionKey);
            readSSI.load(SSITypes.READ_SSI, this.getDLDomain(), subtypeKey, this.getControlString(), this.getVn(), this.getHint());
            callback(undefined, readSSI);
        });
    };
}

function createAnchorSSI(identifier) {
    return new AnchorSSI(identifier);
}

module.exports = {
    createAnchorSSI
}

},{"../../CryptoAlgorithms/CryptoAlgorithmsRegistry":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/key-ssi-resolver/lib/CryptoAlgorithms/CryptoAlgorithmsRegistry.js","../KeySSIMixin":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/key-ssi-resolver/lib/KeySSIs/KeySSIMixin.js","../SSITypes":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/key-ssi-resolver/lib/KeySSIs/SSITypes.js","./ReadSSI":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/key-ssi-resolver/lib/KeySSIs/SecretSSIs/ReadSSI.js"}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/key-ssi-resolver/lib/KeySSIs/SecretSSIs/PublicSSI.js":[function(require,module,exports){
const KeySSIMixin = require("../KeySSIMixin");
const ZaSSI = require("./ZaSSI");
const SSITypes = require("../SSITypes");
const cryptoRegistry = require("../../CryptoAlgorithms/CryptoAlgorithmsRegistry");

function PublicSSI(identifier) {
    KeySSIMixin(this);

    if (typeof identifier !== "undefined") {
        this.autoLoad(identifier);
    }

    this.derive = () => {
        const zaSSI = ZaSSI.createZaSSI();
        const subtypeKey = cryptoRegistry.getHashFunction(this)(this.getEncryptionKey())
        zaSSI.initialize(SSITypes.ZERO_ACCESS_SSI, this.getDLDomain(), subtypeKey, this.getControlString(), this.getVn(), this.getHint());
        return zaSSI;
    };
}

function createPublicSSI(identifier) {
    return new PublicSSI(identifier);
}

module.exports = {
    createPublicSSI
};

},{"../../CryptoAlgorithms/CryptoAlgorithmsRegistry":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/key-ssi-resolver/lib/CryptoAlgorithms/CryptoAlgorithmsRegistry.js","../KeySSIMixin":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/key-ssi-resolver/lib/KeySSIs/KeySSIMixin.js","../SSITypes":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/key-ssi-resolver/lib/KeySSIs/SSITypes.js","./ZaSSI":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/key-ssi-resolver/lib/KeySSIs/SecretSSIs/ZaSSI.js"}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/key-ssi-resolver/lib/KeySSIs/SecretSSIs/ReadSSI.js":[function(require,module,exports){
const KeySSIMixin = require("../KeySSIMixin");
const PublicSSI = require("./PublicSSI");
const SSITypes = require("../SSITypes");
const cryptoRegistry = require("../../CryptoAlgorithms/CryptoAlgorithmsRegistry");

function ReadSSI(identifier) {
    KeySSIMixin(this);

    if (typeof identifier !== "undefined") {
        this.load(identifier);
    }

    this.derive = () => {
        const publicSSI = PublicSSI.createPublicSSI();
        const subtypeKey = cryptoRegistry.getHashFunction(this)(this.getEncryptionKey());
        publicSSI.load(SSITypes.PUBLIC_SSI, this.getDLDomain(), subtypeKey, this.getControlString(), this.getVn(), this.getHint());
        return publicSSI;
    };
}

function createReadSSI(identifier) {
    return new ReadSSI(identifier);
}

module.exports = {
    createReadSSI
};

},{"../../CryptoAlgorithms/CryptoAlgorithmsRegistry":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/key-ssi-resolver/lib/CryptoAlgorithms/CryptoAlgorithmsRegistry.js","../KeySSIMixin":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/key-ssi-resolver/lib/KeySSIs/KeySSIMixin.js","../SSITypes":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/key-ssi-resolver/lib/KeySSIs/SSITypes.js","./PublicSSI":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/key-ssi-resolver/lib/KeySSIs/SecretSSIs/PublicSSI.js"}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/key-ssi-resolver/lib/KeySSIs/SecretSSIs/SecretSSI.js":[function(require,module,exports){
const KeySSIMixin = require("../KeySSIMixin");
const AnchorSSI = require("./AnchorSSI");
const SSITypes = require("../SSITypes");
const cryptoRegistry = require("../../CryptoAlgorithms/CryptoAlgorithmsRegistry");

function SecretSSI(identifier) {
    KeySSIMixin(this);

    if (typeof identifier !== "undefined") {
        this.autoLoad(identifier);
    }

    this.derive = () => {
        const anchorSSI = AnchorSSI.createAnchorSSI();
        const subtypeKey = cryptoRegistry.getHashFunction(this)(this.getEncryptionKey())
        anchorSSI.load(SSITypes.ANCHOR_SSI, this.getDLDomain(), subtypeKey, this.getControlString(), this.getVn(), this.getHint());
        return anchorSSI;
    };
}

function createSecretSSI (identifier){
    return new SecretSSI(identifier);
}
module.exports = {
    createSecretSSI
}

},{"../../CryptoAlgorithms/CryptoAlgorithmsRegistry":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/key-ssi-resolver/lib/CryptoAlgorithms/CryptoAlgorithmsRegistry.js","../KeySSIMixin":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/key-ssi-resolver/lib/KeySSIs/KeySSIMixin.js","../SSITypes":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/key-ssi-resolver/lib/KeySSIs/SSITypes.js","./AnchorSSI":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/key-ssi-resolver/lib/KeySSIs/SecretSSIs/AnchorSSI.js"}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/key-ssi-resolver/lib/KeySSIs/SecretSSIs/ZaSSI.js":[function(require,module,exports){
const KeySSIMixin = require("../KeySSIMixin");
function ZaSSI(identifier) {
    KeySSIMixin(this);

    if (typeof identifier !== "undefined") {
        this.autoLoad(identifier);
    }

    this.derive = () => {
        throw Error("Not implemented");
    };
}

function createZaSSI(identifier) {
    return new ZaSSI(identifier);
}

module.exports = {
    createZaSSI
};
},{"../KeySSIMixin":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/key-ssi-resolver/lib/KeySSIs/KeySSIMixin.js"}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/key-ssi-resolver/lib/KeySSIs/SeedSSIs/PathKeySSI.js":[function(require,module,exports){
const KeySSIMixin = require("../KeySSIMixin");
const SeedSSI = require("./SeedSSI");
const SSITypes = require("../SSITypes");
const cryptoRegistry = require("../../CryptoAlgorithms/CryptoAlgorithmsRegistry");

function PathKeySSI(enclave, identifier) {
    if (typeof enclave === "string") {
        identifier = enclave;
        enclave = undefined;
    }
    KeySSIMixin(this, enclave);
    const self = this;
    let privateKey;

    if (typeof identifier !== "undefined") {
        self.autoLoad(identifier);
    }

    self.getTypeName = function () {
        return SSITypes.PATH_SSI;
    }

    self.setCanSign(true);

    const _getEnclave = (callback) => {
        const openDSU = require("opendsu")
        const scAPI = openDSU.loadAPI("sc")
        scAPI.getSharedEnclave((err, sharedEnclave) => {
            if (err) {
                return scAPI.getMainEnclave(callback);
            }

            callback(undefined, sharedEnclave);
        });
    }

    self.derive = function (callback) {
        const specificString = self.getSpecificString();
        const index = specificString.indexOf("/");
        const slot = specificString.slice(0, index);
        const path = specificString.slice(index + 1);

        const __getPrivateKeyForSlot = () => {
            enclave.getPrivateKeyForSlot(slot, (err, _privateKey) => {
                if (err) {
                    return callback(err);
                }

                try {
                    privateKey = _privateKey;
                    privateKey = cryptoRegistry.getHashFunction(self)(`${path}${privateKey}`);
                    privateKey = cryptoRegistry.getDecodingFunction(self)(privateKey);
                    const seedSpecificString = cryptoRegistry.getBase64EncodingFunction(self)(privateKey);
                    const seedSSI = SeedSSI.createSeedSSI(enclave);
                    seedSSI.load(SSITypes.SEED_SSI, self.getDLDomain(), seedSpecificString, undefined, self.getVn(), self.getHint());
                    callback(undefined, seedSSI);
                } catch (e) {
                    callback(e);
                }
            });
        }

        if (typeof enclave === "undefined") {
            _getEnclave((err, _enclave) => {
                if (err) {
                    return callback(err);
                }

                enclave = _enclave;
                __getPrivateKeyForSlot();
            })

            return;
        }

        __getPrivateKeyForSlot();
    };

    self.getPrivateKey = function (format) {
        let validSpecificString = self.getSpecificString();
        if (validSpecificString === undefined) {
            throw Error("Operation requested on an invalid SeedSSI. Initialise first")
        }
        let privateKey = cryptoRegistry.getBase64DecodingFunction(self)(validSpecificString);
        if (format === "pem") {
            const pemKeys = cryptoRegistry.getKeyPairGenerator(self)().getPemKeys(privateKey, self.getPublicKey("raw"));
            privateKey = pemKeys.privateKey;
        }
        return privateKey;
    }

    self.sign = function (dataToSign, callback) {
        self.derive((err, seedSSI) => {
            if (err) {
                return callback(err);
            }

            seedSSI.sign(dataToSign, callback);
        })
    }

    self.getPublicKey = function (format) {
        return cryptoRegistry.getDerivePublicKeyFunction(self)(self.getPrivateKey(), format);
    }

    self.getEncryptionKey = function (callback) {
        self.derive((err, seedSSI) => {
            if (err) {
                return callback(err);
            }

            seedSSI.getEncryptionKey(callback);
        })
    };

    self.getKeyPair = function () {
        const keyPair = {
            privateKey: self.getPrivateKey("pem"),
            publicKey: self.getPublicKey("pem")
        }

        return keyPair;
    }
}

function createPathKeySSI(enclave, identifier) {
    return new PathKeySSI(enclave, identifier);
}

module.exports = {
    createPathKeySSI
};

},{"../../CryptoAlgorithms/CryptoAlgorithmsRegistry":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/key-ssi-resolver/lib/CryptoAlgorithms/CryptoAlgorithmsRegistry.js","../KeySSIMixin":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/key-ssi-resolver/lib/KeySSIs/KeySSIMixin.js","../SSITypes":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/key-ssi-resolver/lib/KeySSIs/SSITypes.js","./SeedSSI":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/key-ssi-resolver/lib/KeySSIs/SeedSSIs/SeedSSI.js","opendsu":"opendsu"}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/key-ssi-resolver/lib/KeySSIs/SeedSSIs/SReadSSI.js":[function(require,module,exports){
const KeySSIMixin = require("../KeySSIMixin");
const SZaSSI = require("./SZaSSI");
const SSITypes = require("../SSITypes");
const cryptoRegistry = require("../../CryptoAlgorithms/CryptoAlgorithmsRegistry");

function SReadSSI(enclave, identifier) {
    if (typeof enclave === "string") {
        identifier = enclave;
        enclave = undefined;
    }
    KeySSIMixin(this, enclave);
    const self = this;

    if (typeof identifier !== "undefined") {
        self.autoLoad(identifier);
    }

    self.getTypeName = function () {
        return SSITypes.SREAD_SSI;
    }

    self.initialize = (dlDomain, vn, hint) => {
        self.load(SSITypes.SREAD_SSI, dlDomain, "", undefined, vn, hint);
    };

    self.derive = (callback) => {
        try{
            const sZaSSI = SZaSSI.createSZaSSI();
            const subtypeKey = '';
            const subtypeControl = self.getControlString();
            sZaSSI.load(SSITypes.SZERO_ACCESS_SSI, self.getDLDomain(), subtypeKey, subtypeControl, self.getVn(), self.getHint());
            callback(undefined, sZaSSI);
        }catch (e) {
            return callback(e);
        }
    };

    self.getEncryptionKey = (callback) => {
        const encryptionKey = cryptoRegistry.getDecodingFunction(self)(self.getSpecificString());
        callback(undefined, encryptionKey);
    };

    self.getPublicKey = (options) => {
        let publicKey = cryptoRegistry.getBase64DecodingFunction(self)(self.getControlString());
        return cryptoRegistry.getConvertPublicKeyFunction(self)(publicKey, options);
    };
}

function createSReadSSI(enclave, identifier) {
    return new SReadSSI(enclave, identifier)
}

module.exports = {
    createSReadSSI
};

},{"../../CryptoAlgorithms/CryptoAlgorithmsRegistry":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/key-ssi-resolver/lib/CryptoAlgorithms/CryptoAlgorithmsRegistry.js","../KeySSIMixin":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/key-ssi-resolver/lib/KeySSIs/KeySSIMixin.js","../SSITypes":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/key-ssi-resolver/lib/KeySSIs/SSITypes.js","./SZaSSI":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/key-ssi-resolver/lib/KeySSIs/SeedSSIs/SZaSSI.js"}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/key-ssi-resolver/lib/KeySSIs/SeedSSIs/SZaSSI.js":[function(require,module,exports){
const KeySSIMixin = require("../KeySSIMixin");
const SSITypes = require("../SSITypes");
const cryptoRegistry = require("../../CryptoAlgorithms/CryptoAlgorithmsRegistry");

function SZaSSI(enclave, identifier) {
    if (typeof enclave === "string") {
        identifier = enclave;
        enclave = undefined;
    }
    const self = this;
    KeySSIMixin(self, enclave);

    if (typeof identifier !== "undefined") {
        self.autoLoad(identifier);
    }

    self.getTypeName = function () {
        return SSITypes.SZERO_ACCESS_SSI;
    }

    self.initialize = (dlDomain, hpk, vn, hint) => {
        self.load(SSITypes.SZERO_ACCESS_SSI, dlDomain, '', hpk, vn, hint);
    };

    self.getPublicKey = (options) => {
        let publicKey = cryptoRegistry.getBase64DecodingFunction(self)(self.getControlString());
        return cryptoRegistry.getConvertPublicKeyFunction(self)(publicKey, options);
    };

    
}

function createSZaSSI(enclave, identifier) {
    return new SZaSSI(enclave, identifier);
}

module.exports = {
    createSZaSSI
};

},{"../../CryptoAlgorithms/CryptoAlgorithmsRegistry":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/key-ssi-resolver/lib/CryptoAlgorithms/CryptoAlgorithmsRegistry.js","../KeySSIMixin":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/key-ssi-resolver/lib/KeySSIs/KeySSIMixin.js","../SSITypes":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/key-ssi-resolver/lib/KeySSIs/SSITypes.js"}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/key-ssi-resolver/lib/KeySSIs/SeedSSIs/SeedSSI.js":[function(require,module,exports){
const KeySSIMixin = require("../KeySSIMixin");
const SReadSSI = require("./SReadSSI");
const SSITypes = require("../SSITypes");
const cryptoRegistry = require("../../CryptoAlgorithms/CryptoAlgorithmsRegistry");

function SeedSSI(enclave, identifier) {
    if (typeof enclave === "string") {
        identifier = enclave;
        enclave = undefined;
    }
    KeySSIMixin(this, enclave);
    const self = this;
    if (typeof identifier !== "undefined") {
        self.autoLoad(identifier);
    }

    self.getTypeName = function () {
        return SSITypes.SEED_SSI;
    }

    self.setCanSign(true);

    self.initialize = function (dlDomain, privateKey, control, vn, hint, callback) {
        if (typeof privateKey === "function") {
            callback = privateKey;
            privateKey = undefined;
        }
        if (typeof control === "function") {
            callback = control;
            control = undefined;
        }
        if (typeof vn === "function") {
            callback = vn;
            vn = 'v0';
        }
        if (typeof hint === "function") {
            callback = hint;
            hint = undefined;
        }

        if (typeof privateKey === "undefined") {
            cryptoRegistry.getKeyPairGenerator(self)().generateKeyPair((err, publicKey, privateKey) => {
                if (err) {
                    return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed generate private/public key pair`, err));
                }
                privateKey = cryptoRegistry.getBase64EncodingFunction(self)(privateKey);
                self.load(SSITypes.SEED_SSI, dlDomain, privateKey, '', vn, hint);
                if (callback) {
                    callback(undefined, self);
                }
            });
        } else {
            privateKey = cryptoRegistry.getBase64EncodingFunction(self)(privateKey);
            self.load(SSITypes.SEED_SSI, dlDomain, privateKey, '', vn, hint);
            if (callback) {
                callback(undefined, self);
            }
        }
        self.initialize = function () {
            throw Error("KeySSI already initialized");
        }
    };

    self.derive = function (callback) {
        try {
            const sReadSSI = SReadSSI.createSReadSSI();
            const privateKey = self.getPrivateKey();
            const sreadSpecificString = cryptoRegistry.getHashFunction(self)(privateKey);
            const publicKey = cryptoRegistry.getDerivePublicKeyFunction(self)(privateKey, "raw");
            const controlString = cryptoRegistry.getBase64EncodingFunction(self)(publicKey);
            sReadSSI.load(SSITypes.SREAD_SSI, self.getDLDomain(), sreadSpecificString, controlString, self.getVn(), self.getHint());
            callback(undefined, sReadSSI);
        } catch (e) {
            callback(e);
        }
    };

    self.getPrivateKey = function (format) {
        let validSpecificString = self.getSpecificString();
        if (validSpecificString === undefined) {
            throw Error("Operation requested on an invalid SeedSSI. Initialise first")
        }
        let privateKey = cryptoRegistry.getBase64DecodingFunction(self)(validSpecificString);
        if (format === "pem") {
            const pemKeys = cryptoRegistry.getKeyPairGenerator(self)().getPemKeys(privateKey, self.getPublicKey("raw"));
            privateKey = pemKeys.privateKey;
        }
        return privateKey;
    }

    self.sign = function (dataToSign, callback) {
        let signature;
        try {
            const privateKey = self.getPrivateKey();
            const sign = cryptoRegistry.getSignFunction(self);
            const encode = cryptoRegistry.getBase64EncodingFunction(self);
            signature = encode(sign(dataToSign, privateKey));
        } catch (e) {
            if (callback) {
                return callback(e);
            }
            throw e;
        }

        if (callback) {
            callback(undefined, signature);
        }

        return signature;
    }

    self.getPublicKey = function (format) {
        return cryptoRegistry.getDerivePublicKeyFunction(self)(self.getPrivateKey(), format);
    }

    self.getEncryptionKey = function (callback) {
        self.derive((err, derivedKeySSI) => {
            if (err) {
                return callback(err);
            }

            derivedKeySSI.getEncryptionKey(callback);
        });
    };

    self.getKeyPair = function () {
        const keyPair = {
            privateKey: self.getPrivateKey("pem"),
            publicKey: self.getPublicKey("pem")
        }

        return keyPair;
    }
}

function createSeedSSI(enclave, identifier) {
    return new SeedSSI(enclave, identifier);
}

module.exports = {
    createSeedSSI
};

},{"../../CryptoAlgorithms/CryptoAlgorithmsRegistry":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/key-ssi-resolver/lib/CryptoAlgorithms/CryptoAlgorithmsRegistry.js","../KeySSIMixin":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/key-ssi-resolver/lib/KeySSIs/KeySSIMixin.js","../SSITypes":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/key-ssi-resolver/lib/KeySSIs/SSITypes.js","./SReadSSI":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/key-ssi-resolver/lib/KeySSIs/SeedSSIs/SReadSSI.js"}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/key-ssi-resolver/lib/KeySSIs/TokenSSIs/TokenSSI.js":[function(require,module,exports){
const KeySSIMixin = require("../KeySSIMixin");
const SSITypes = require("../SSITypes");

function TokenSSI(enclave, identifier) {
    if (typeof enclave === "string") {
        identifier = enclave;
        enclave = undefined;
    }
    KeySSIMixin(this, enclave);
    const self = this;
    if (typeof identifier !== "undefined") {
        self.autoLoad(identifier);
    }

    self.getTypeName = function () {
        return SSITypes.TOKEN_SSI;
    }

    self.initialize = function (dlDomain, amount, hashInitialOwnerPublicKey, vn, hint, callback) {
        if (typeof amount === "function") {
            callback = amount;
            amount = undefined;
        }
        if (typeof hashInitialOwnerPublicKey === "function") {
            callback = hashInitialOwnerPublicKey;
            hashInitialOwnerPublicKey = undefined;
        }
        if (typeof vn === "function") {
            callback = vn;
            vn = "v0";
        }
        if (typeof hint === "function") {
            callback = hint;
            hint = undefined;
        }

        self.load(SSITypes.TOKEN_SSI, dlDomain, amount, hashInitialOwnerPublicKey, vn, hint);
        if (callback) {
            callback(undefined, self);
        }

        self.initialize = function () {
            throw Error("KeySSI already initialized");
        };
    };

    self.takeOwnership = function (ownershipSSI, callback) {
        // will give token ownership to another generated ownershipSSI
        throw Error("Not implemented");
        // callback(err, newOwnershipSSI);
    };

    self.giveOwnership = function (ownershipSSI, oReadSSI, callback) {
        // will give token ownership to another specified oReadSSI
        throw Error("Not implemented");
        // callback(err, transferSSI);
    };
}

function createTokenSSI(enclave, identifier) {
    return new TokenSSI(enclave, identifier);
}

module.exports = {
    createTokenSSI
};

},{"../KeySSIMixin":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/key-ssi-resolver/lib/KeySSIs/KeySSIMixin.js","../SSITypes":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/key-ssi-resolver/lib/KeySSIs/SSITypes.js"}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/key-ssi-resolver/lib/KeySSIs/TransferSSIs/TransferSSI.js":[function(require,module,exports){
const KeySSIMixin = require("../KeySSIMixin");
const SSITypes = require("../SSITypes");
const cryptoRegistry = require("../../CryptoAlgorithms/CryptoAlgorithmsRegistry");
const keySSIFactory = require("../KeySSIFactory");

function TransferSSI(enclave, identifier) {
    if (typeof enclave === "string") {
        identifier = enclave;
        enclave = undefined;
    }
    KeySSIMixin(this, enclave);
    const self = this;
    if (typeof identifier !== "undefined") {
        self.autoLoad(identifier);
    }

    self.getTypeName = function () {
        return SSITypes.TRANSFER_SSI;
    }

    self.initialize = function (dlDomain, newPublicKey, timestamp, signature, vn, hint, callback) {
        if (typeof vn === "function") {
            callback = vn;
            vn = "v0";
        }
        if (typeof hint === "function") {
            callback = hint;
            hint = undefined;
        }

        self.load(SSITypes.TRANSFER_SSI, dlDomain, newPublicKey, `${timestamp}/${signature}`, vn, hint);

        if (callback) {
            callback(undefined, self);
        }

        self.initialize = function () {
            throw Error("KeySSI already initialized");
        };
    };

    self.getPublicKeyHash = function () {
        return self.getSpecificString();
    };

    self.getTimestamp = function () {
        let control = self.getControlString();
        return control.split("/")[0];
    }

    self.getSignature = function (encoding) {
        if (typeof encoding === "undefined") {
            encoding = "base64";
        }
        let control = self.getControlString();
        let splitControl = control.split("/");
        let signature = splitControl[1];
        if (encoding === "raw") {
            const base64Decode = cryptoRegistry.getBase64DecodingFunction(self);
            return base64Decode(signature);
        }
        return signature;
    }

    self.getPublicKey = (options) => {
        let publicKey = cryptoRegistry.getBase64DecodingFunction(self)(self.getSpecificString());
        return cryptoRegistry.getConvertPublicKeyFunction(self)(publicKey, options);
    };

    self.getDataToSign = function (anchorSSI, previousAnchorValue) {
        if (typeof anchorSSI === "string") {
            anchorSSI = keySSIFactory.create(anchorSSI);
        }

        if (typeof previousAnchorValue === "string") {
            previousAnchorValue = keySSIFactory.create(previousAnchorValue);
        }

        let previousIdentifier = '';
        const timestamp = self.getTimestamp();
        if (previousAnchorValue) {
            previousIdentifier = previousAnchorValue.getIdentifier(true);
        }
        return anchorSSI.getIdentifier(true) + self.getSpecificString() + previousIdentifier + timestamp;
    }

    self.isTransfer = function () {
        return true;
    }
}

function createTransferSSI(enclave, identifier) {
    return new TransferSSI(enclave, identifier);
}

module.exports = {
    createTransferSSI
};

},{"../../CryptoAlgorithms/CryptoAlgorithmsRegistry":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/key-ssi-resolver/lib/CryptoAlgorithms/CryptoAlgorithmsRegistry.js","../KeySSIFactory":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/key-ssi-resolver/lib/KeySSIs/KeySSIFactory.js","../KeySSIMixin":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/key-ssi-resolver/lib/KeySSIs/KeySSIMixin.js","../SSITypes":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/key-ssi-resolver/lib/KeySSIs/SSITypes.js"}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/key-ssi-resolver/lib/KeySSIs/constants.js":[function(require,module,exports){
module.exports = {
    DSU_VERSION_KEY: "dsuVersion",
    EMBEDDED_DATA_KEY: "embedded"
}
},{}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/loki-enclave-facade/lib/lokijs/src/loki-fs-sync-adapter.js":[function(require,module,exports){
/*
  A synchronous version of the Loki Filesystem adapter for node.js

  Intended for diagnostics or environments where synchronous i/o is required.

  This adapter will perform worse than the default LokiFsAdapter but 
  is provided for quick adaptation to synchronous code.
*/

(function (root, factory) {
    if (typeof define === 'function' && define.amd) {
        // AMD
        define([], factory);
    } else if (typeof exports === 'object') {
        // Node, CommonJS-like
        module.exports = factory();
    } else {
        // Browser globals (root is window)
        root.LokiFsSyncAdapter = factory();
    }
}(this, function () {
  return (function() {
    'use strict';

    /**
     * A loki persistence adapter which persists using node fs module
     * @constructor LokiFsSyncAdapter
     */
    function LokiFsSyncAdapter() {
      this.fs = require('fs');
    }

    /**
     * loadDatabase() - Load data from file, will throw an error if the file does not exist
     * @param {string} dbname - the filename of the database to load
     * @param {function} callback - the callback to handle the result
     * @memberof LokiFsSyncAdapter
     */
    LokiFsSyncAdapter.prototype.loadDatabase = function loadDatabase(dbname, callback) {
      var self = this;
      var contents;

      try {
        var stats = this.fs.statSync(dbname);
        if (stats.isFile()) {
          contents = self.fs.readFileSync(dbname, {
            encoding: 'utf8'
          });
          
          callback(contents);
        }
        else {
          callback(null);
        }
      }
      catch (err) {
        // first autoload when file doesn't exist yet
        // should not throw error but leave default
        // blank database.
        if (err.code === "ENOENT") {
          callback(null);
        }
        
        callback(err);
      }
    };

    /**
     * saveDatabase() - save data to file, will throw an error if the file can't be saved
     * might want to expand this to avoid dataloss on partial save
     * @param {string} dbname - the filename of the database to load
     * @param {function} callback - the callback to handle the result
     * @memberof LokiFsSyncAdapter
     */
    LokiFsSyncAdapter.prototype.saveDatabase = function saveDatabase(dbname, dbstring, callback) {
      try {
        this.fs.writeFileSync(dbname, dbstring);
        callback();
      }
      catch (err) {
        callback(err);
      }
    };

    /**
     * deleteDatabase() - delete the database file, will throw an error if the
     * file can't be deleted
     * @param {string} dbname - the filename of the database to delete
     * @param {function} callback - the callback to handle the result
     * @memberof LokiFsSyncAdapter
     */
    LokiFsSyncAdapter.prototype.deleteDatabase = function deleteDatabase(dbname, callback) {
      try {
        this.fs.unlinkSync(dbname);
        callback();
      }
      catch (err) {
        callback(err);
      }
    };

    return LokiFsSyncAdapter;

  }());
}));

},{"fs":false}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/loki-enclave-facade/lib/lokijs/src/loki-indexed-adapter.js":[function(require,module,exports){
/*
  Loki IndexedDb Adapter (need to include this script to use it)

  Console Usage can be used for management/diagnostic, here are a few examples :
  adapter.getDatabaseList(); // with no callback passed, this method will log results to console
  adapter.saveDatabase('UserDatabase', JSON.stringify(myDb));
  adapter.loadDatabase('UserDatabase'); // will log the serialized db to console
  adapter.deleteDatabase('UserDatabase');
*/

(function (root, factory) {
    if (typeof define === 'function' && define.amd) {
        // AMD
        define([], factory);
    } else if (typeof exports === 'object') {
        // Node, CommonJS-like
        module.exports = factory();
    } else {
        // Browser globals (root is window)
        root.LokiIndexedAdapter = factory();
    }
}(this, function () {
  return (function() {

    /**
     * Loki persistence adapter class for indexedDb.
     *     This class fulfills abstract adapter interface which can be applied to other storage methods.
     *     Utilizes the included LokiCatalog app/key/value database for actual database persistence.
     *     Indexeddb is highly async, but this adapter has been made 'console-friendly' as well.
     *     Anywhere a callback is omitted, it should return results (if applicable) to console.
     *     IndexedDb storage is provided per-domain, so we implement app/key/value database to
     *     allow separate contexts for separate apps within a domain.
     *
     * @example
     * var idbAdapter = new LokiIndexedAdapter('finance');
     *
     * @constructor LokiIndexedAdapter
     *
     * @param {string} appname - (Optional) Application name context can be used to distinguish subdomains, 'loki' by default
     * @param {object=} options Configuration options for the adapter
     * @param {boolean} options.closeAfterSave Whether the indexedDB database should be closed after saving.
     */
    function LokiIndexedAdapter(appname, options)
    {
      this.app = 'loki';
      this.options = options || {};

      if (typeof (appname) !== 'undefined')
      {
        this.app = appname;
      }

      // keep reference to catalog class for base AKV operations
      this.catalog = null;

      if (!this.checkAvailability()) {
        throw new Error('indexedDB does not seem to be supported for your environment');
      }
    }

    /**
     * Used for closing the indexeddb database.
     */
    LokiIndexedAdapter.prototype.closeDatabase = function ()
    {
      if (this.catalog && this.catalog.db) {
        this.catalog.db.close();
        this.catalog.db = null;
      }
    };

    /**
     * Used to check if adapter is available
     *
     * @returns {boolean} true if indexeddb is available, false if not.
     * @memberof LokiIndexedAdapter
     */
    LokiIndexedAdapter.prototype.checkAvailability = function()
    {
      if (typeof indexedDB !== 'undefined' && indexedDB) return true;

      return false;
    };

    /**
     * Retrieves a serialized db string from the catalog.
     *
     * @example
     * // LOAD
     * var idbAdapter = new LokiIndexedAdapter('finance');
     * var db = new loki('test', { adapter: idbAdapter });
     *   db.loadDatabase(function(result) {
     *   console.log('done');
     * });
     *
     * @param {string} dbname - the name of the database to retrieve.
     * @param {function} callback - callback should accept string param containing serialized db string.
     * @memberof LokiIndexedAdapter
     */
    LokiIndexedAdapter.prototype.loadDatabase = function(dbname, callback)
    {
      var appName = this.app;
      var adapter = this;

      // lazy open/create db reference so dont -need- callback in constructor
      if (this.catalog === null || this.catalog.db === null) {
        this.catalog = new LokiCatalog(function(cat) {
          adapter.catalog = cat;

          adapter.loadDatabase(dbname, callback);
        });

        return;
      }

      // lookup up db string in AKV db
      this.catalog.getAppKey(appName, dbname, function(result) {
        if (typeof (callback) === 'function') {
          if (result.id === 0) {
            callback(null);
            return;
          }
          callback(result.val);
        }
        else {
          // support console use of api
          console.log(result.val);
        }
      });
    };

    // alias
    LokiIndexedAdapter.prototype.loadKey = LokiIndexedAdapter.prototype.loadDatabase;

    /**
     * Saves a serialized db to the catalog.
     *
     * @example
     * // SAVE : will save App/Key/Val as 'finance'/'test'/{serializedDb}
     * var idbAdapter = new LokiIndexedAdapter('finance');
     * var db = new loki('test', { adapter: idbAdapter });
     * var coll = db.addCollection('testColl');
     * coll.insert({test: 'val'});
     * db.saveDatabase();  // could pass callback if needed for async complete
     *
     * @param {string} dbname - the name to give the serialized database within the catalog.
     * @param {string} dbstring - the serialized db string to save.
     * @param {function} callback - (Optional) callback passed obj.success with true or false
     * @memberof LokiIndexedAdapter
     */
    LokiIndexedAdapter.prototype.saveDatabase = function(dbname, dbstring, callback)
    {
      var appName = this.app;
      var adapter = this;

      function saveCallback(result) {
        if (result && result.success === true) {
          callback(null);
        }
        else {
          callback(new Error("Error saving database"));
        }

        if (adapter.options.closeAfterSave) {
          adapter.closeDatabase();
        }
      }

      // lazy open/create db reference so dont -need- callback in constructor
      if (this.catalog === null || this.catalog.db === null) {
        this.catalog = new LokiCatalog(function(cat) {
          adapter.saveDatabase(dbname, dbstring, saveCallback);
        });

        return;
      }

      // set (add/update) entry to AKV database
      this.catalog.setAppKey(appName, dbname, dbstring, saveCallback);
    };

    // alias
    LokiIndexedAdapter.prototype.saveKey = LokiIndexedAdapter.prototype.saveDatabase;

    /**
     * Deletes a serialized db from the catalog.
     *
     * @example
     * // DELETE DATABASE
     * // delete 'finance'/'test' value from catalog
     * idbAdapter.deleteDatabase('test', function {
     *   // database deleted
     * });
     *
     * @param {string} dbname - the name of the database to delete from the catalog.
     * @param {function=} callback - (Optional) executed on database delete
     * @memberof LokiIndexedAdapter
     */
    LokiIndexedAdapter.prototype.deleteDatabase = function(dbname, callback)
    {
      var appName = this.app;
      var adapter = this;

      // lazy open/create db reference and pass callback ahead
      if (this.catalog === null || this.catalog.db === null) {
        this.catalog = new LokiCatalog(function(cat) {
          adapter.catalog = cat;

          adapter.deleteDatabase(dbname, callback);
        });

        return;
      }

      // catalog was already initialized, so just lookup object and delete by id
      this.catalog.getAppKey(appName, dbname, function(result) {
        var id = result.id;

        if (id !== 0) {
          adapter.catalog.deleteAppKey(id, callback);
        } else if (typeof (callback) === 'function') {
          callback({ success: true });
        }
      });
    };

    // alias
    LokiIndexedAdapter.prototype.deleteKey = LokiIndexedAdapter.prototype.deleteDatabase;

    /**
     * Removes all database partitions and pages with the base filename passed in.
     * This utility method does not (yet) guarantee async deletions will be completed before returning
     *
     * @param {string} dbname - the base filename which container, partitions, or pages are derived
     * @memberof LokiIndexedAdapter
     */
    LokiIndexedAdapter.prototype.deleteDatabasePartitions = function(dbname) {
      var self=this;
      this.getDatabaseList(function(result) {
        result.forEach(function(str) {
          if (str.startsWith(dbname)) {
            self.deleteDatabase(str);
          }
        });
      });
    };

    /**
     * Retrieves object array of catalog entries for current app.
     *
     * @example
     * idbAdapter.getDatabaseList(function(result) {
     *   // result is array of string names for that appcontext ('finance')
     *   result.forEach(function(str) {
     *     console.log(str);
     *   });
     * });
     *
     * @param {function} callback - should accept array of database names in the catalog for current app.
     * @memberof LokiIndexedAdapter
     */
    LokiIndexedAdapter.prototype.getDatabaseList = function(callback)
    {
      var appName = this.app;
      var adapter = this;

      // lazy open/create db reference so dont -need- callback in constructor
      if (this.catalog === null || this.catalog.db === null) {
        this.catalog = new LokiCatalog(function(cat) {
          adapter.catalog = cat;

          adapter.getDatabaseList(callback);
        });

        return;
      }

      // catalog already initialized
      // get all keys for current appName, and transpose results so just string array
      this.catalog.getAppKeys(appName, function(results) {
        var names = [];

        for(var idx = 0; idx < results.length; idx++) {
          names.push(results[idx].key);
        }

        if (typeof (callback) === 'function') {
          callback(names);
        }
        else {
          names.forEach(function(obj) {
            console.log(obj);
          });
        }
      });
    };

    // alias
    LokiIndexedAdapter.prototype.getKeyList = LokiIndexedAdapter.prototype.getDatabaseList;

    /**
     * Allows retrieval of list of all keys in catalog along with size
     *
     * @param {function} callback - (Optional) callback to accept result array.
     * @memberof LokiIndexedAdapter
     */
    LokiIndexedAdapter.prototype.getCatalogSummary = function(callback)
    {
      var appName = this.app;
      var adapter = this;

      // lazy open/create db reference
      if (this.catalog === null || this.catalog.db === null) {
        this.catalog = new LokiCatalog(function(cat) {
          adapter.catalog = cat;

          adapter.getCatalogSummary(callback);
        });

        return;
      }

      // catalog already initialized
      // get all keys for current appName, and transpose results so just string array
      this.catalog.getAllKeys(function(results) {
        var entries = [];
        var obj,
          size,
          oapp,
          okey,
          oval;

        for(var idx = 0; idx < results.length; idx++) {
          obj = results[idx];
          oapp = obj.app || '';
          okey = obj.key || '';
          oval = obj.val || '';

          // app and key are composited into an appkey column so we will mult by 2
          size = oapp.length * 2 + okey.length * 2 + oval.length + 1;

          entries.push({ "app": obj.app, "key": obj.key, "size": size });
        }

        if (typeof (callback) === 'function') {
          callback(entries);
        }
        else {
          entries.forEach(function(obj) {
            console.log(obj);
          });
        }
      });
    };

    /**
     * LokiCatalog - underlying App/Key/Value catalog persistence
     *    This non-interface class implements the actual persistence.
     *    Used by the IndexedAdapter class.
     */
    function LokiCatalog(callback)
    {
      this.db = null;
      this.initializeLokiCatalog(callback);
    }

    LokiCatalog.prototype.initializeLokiCatalog = function(callback) {
      var openRequest = indexedDB.open('LokiCatalog', 1);
      var cat = this;

      // If database doesn't exist yet or its version is lower than our version specified above (2nd param in line above)
      openRequest.onupgradeneeded = function(e) {
        var thisDB = e.target.result;
        if (thisDB.objectStoreNames.contains('LokiAKV')) {
          thisDB.deleteObjectStore('LokiAKV');
        }

        if(!thisDB.objectStoreNames.contains('LokiAKV')) {
          var objectStore = thisDB.createObjectStore('LokiAKV', { keyPath: 'id', autoIncrement:true });
          objectStore.createIndex('app', 'app', {unique:false});
          objectStore.createIndex('key', 'key', {unique:false});
          // hack to simulate composite key since overhead is low (main size should be in val field)
          // user (me) required to duplicate the app and key into comma delimited appkey field off object
          // This will allow retrieving single record with that composite key as well as
          // still supporting opening cursors on app or key alone
          objectStore.createIndex('appkey', 'appkey', {unique:true});
        }
      };

      openRequest.onsuccess = function(e) {
        cat.db = e.target.result;

        if (typeof (callback) === 'function') callback(cat);
      };

      openRequest.onerror = function(e) {
        throw e;
      };
    };

    LokiCatalog.prototype.getAppKey = function(app, key, callback) {
      var transaction = this.db.transaction(['LokiAKV'], 'readonly');
      var store = transaction.objectStore('LokiAKV');
      var index = store.index('appkey');
      var appkey = app + "," + key;
      var request = index.get(appkey);

      request.onsuccess = (function(usercallback) {
        return function(e) {
          var lres = e.target.result;

          if (lres === null || typeof(lres) === 'undefined') {
            lres = {
              id: 0,
              success: false
            };
          }

          if (typeof(usercallback) === 'function') {
            usercallback(lres);
          }
          else {
            console.log(lres);
          }
        };
      })(callback);

      request.onerror = (function(usercallback) {
        return function(e) {
          if (typeof(usercallback) === 'function') {
            usercallback({ id: 0, success: false });
          }
          else {
            throw e;
          }
        };
      })(callback);
    };

    LokiCatalog.prototype.getAppKeyById = function (id, callback, data) {
      var transaction = this.db.transaction(['LokiAKV'], 'readonly');
      var store = transaction.objectStore('LokiAKV');
      var request = store.get(id);

      request.onsuccess = (function(data, usercallback){
        return function(e) {
          if (typeof(usercallback) === 'function') {
            usercallback(e.target.result, data);
          }
          else {
            console.log(e.target.result);
          }
        };
      })(data, callback);
    };

    LokiCatalog.prototype.setAppKey = function (app, key, val, callback) {
      var transaction = this.db.transaction(['LokiAKV'], 'readwrite');
      var store = transaction.objectStore('LokiAKV');
      var index = store.index('appkey');
      var appkey = app + "," + key;
      var request = index.get(appkey);

      // first try to retrieve an existing object by that key
      // need to do this because to update an object you need to have id in object, otherwise it will append id with new autocounter and clash the unique index appkey
      request.onsuccess = function(e) {
        var res = e.target.result;

        if (res === null || res === undefined) {
          res = {
            app:app,
            key:key,
            appkey: app + ',' + key,
            val:val
          };
        }
        else {
          res.val = val;
        }

        var requestPut = store.put(res);

        requestPut.onerror = (function(usercallback) {
          return function(e) {
            if (typeof(usercallback) === 'function') {
              usercallback({ success: false });
            }
            else {
              console.error('LokiCatalog.setAppKey (set) onerror');
              console.error(request.error);
            }
          };

        })(callback);

        requestPut.onsuccess = (function(usercallback) {
          return function(e) {
            if (typeof(usercallback) === 'function') {
              usercallback({ success: true });
            }
          };
        })(callback);
      };

      request.onerror = (function(usercallback) {
        return function(e) {
          if (typeof(usercallback) === 'function') {
            usercallback({ success: false });
          }
          else {
            console.error('LokiCatalog.setAppKey (get) onerror');
            console.error(request.error);
          }
        };
      })(callback);
    };

    LokiCatalog.prototype.deleteAppKey = function (id, callback) {
      var transaction = this.db.transaction(['LokiAKV'], 'readwrite');
      var store = transaction.objectStore('LokiAKV');
      var request = store.delete(id);

      request.onsuccess = (function(usercallback) {
        return function(evt) {
          if (typeof(usercallback) === 'function') usercallback({ success: true });
        };
      })(callback);

      request.onerror = (function(usercallback) {
        return function(evt) {
          if (typeof(usercallback) === 'function') {
            usercallback({ success: false });
          }
          else {
            console.error('LokiCatalog.deleteAppKey raised onerror');
            console.error(request.error);
          }
        };
      })(callback);
    };

    LokiCatalog.prototype.getAppKeys = function(app, callback) {
      var transaction = this.db.transaction(['LokiAKV'], 'readonly');
      var store = transaction.objectStore('LokiAKV');
      var index = store.index('app');

      // We want cursor to all values matching our (single) app param
      var singleKeyRange = IDBKeyRange.only(app);

      // To use one of the key ranges, pass it in as the first argument of openCursor()/openKeyCursor()
      var cursor = index.openCursor(singleKeyRange);

      // cursor internally, pushing results into this.data[] and return
      // this.data[] when done (similar to service)
      var localdata = [];

      cursor.onsuccess = (function(data, callback) {
        return function(e) {
          var cursor = e.target.result;
          if (cursor) {
            var currObject = cursor.value;

            data.push(currObject);

            cursor.continue();
          }
          else {
            if (typeof(callback) === 'function') {
              callback(data);
            }
            else {
              console.log(data);
            }
          }
        };
      })(localdata, callback);

      cursor.onerror = (function(usercallback) {
        return function(e) {
          if (typeof(usercallback) === 'function') {
            usercallback(null);
          }
          else {
            console.error('LokiCatalog.getAppKeys raised onerror');
            console.error(e);
          }
        };
      })(callback);

    };

    // Hide 'cursoring' and return array of { id: id, key: key }
    LokiCatalog.prototype.getAllKeys = function (callback) {
      var transaction = this.db.transaction(['LokiAKV'], 'readonly');
      var store = transaction.objectStore('LokiAKV');
      var cursor = store.openCursor();

      var localdata = [];

      cursor.onsuccess = (function(data, callback) {
        return function(e) {
          var cursor = e.target.result;
          if (cursor) {
            var currObject = cursor.value;

            data.push(currObject);

            cursor.continue();
          }
          else {
            if (typeof(callback) === 'function') {
              callback(data);
            }
            else {
              console.log(data);
            }
          }
        };
      })(localdata, callback);

      cursor.onerror = (function(usercallback) {
        return function(e) {
          if (typeof(usercallback) === 'function') usercallback(null);
        };
      })(callback);

    };

    return LokiIndexedAdapter;

  }());
}));

},{}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/loki-enclave-facade/lib/lokijs/src/lokijs.js":[function(require,module,exports){
(function (global){(function (){
/**
 * LokiJS
 * @author Joe Minichino <joe.minichino@gmail.com>
 *
 * A lightweight document oriented javascript database
 */
(function (root, factory) {
  if (typeof define === 'function' && define.amd) {
    // AMD
    define([], factory);
  } else if (typeof exports === 'object') {
    // CommonJS
    module.exports = factory();
  } else {
    // Browser globals
    root.loki = factory();
  }
}(this, function () {

  return (function () {
    'use strict';

    var hasOwnProperty = Object.prototype.hasOwnProperty;

    function deepFreeze(obj) {
      var prop, i;
      if (Array.isArray(obj)) {
        for (i = 0; i < obj.length; i++) {
          deepFreeze(obj[i]);
        }
        freeze(obj);
      } else if (obj !== null && (typeof obj === 'object')) {
        for (prop in obj) {
          if (obj.hasOwnProperty(prop)) {
            deepFreeze(obj[prop]);
          }
        }
        freeze(obj);
      }
    }

    function freeze(obj) {
      if (!Object.isFrozen(obj)) {
        Object.freeze(obj);
      }
    }

    function unFreeze(obj) {
      if (!Object.isFrozen(obj)) {
        return obj;
      }
      return clone(obj, 'shallow');
    }

    var Utils = {
      copyProperties: function (src, dest) {
        var prop;
        for (prop in src) {
          dest[prop] = src[prop];
        }
      },
      // used to recursively scan hierarchical transform step object for param substitution
      resolveTransformObject: function (subObj, params, depth) {
        var prop,
          pname;

        if (typeof depth !== 'number') {
          depth = 0;
        }

        if (++depth >= 10) return subObj;

        for (prop in subObj) {
          if (typeof subObj[prop] === 'string' && subObj[prop].indexOf("[%lktxp]") === 0) {
            pname = subObj[prop].substring(8);
            if (params.hasOwnProperty(pname)) {
              subObj[prop] = params[pname];
            }
          } else if (typeof subObj[prop] === "object") {
            subObj[prop] = Utils.resolveTransformObject(subObj[prop], params, depth);
          }
        }

        return subObj;
      },
      // top level utility to resolve an entire (single) transform (array of steps) for parameter substitution
      resolveTransformParams: function (transform, params) {
        var idx,
          clonedStep,
          resolvedTransform = [];

        if (typeof params === 'undefined') return transform;

        // iterate all steps in the transform array
        for (idx = 0; idx < transform.length; idx++) {
          // clone transform so our scan/replace can operate directly on cloned transform
          clonedStep = clone(transform[idx], "shallow-recurse-objects");
          resolvedTransform.push(Utils.resolveTransformObject(clonedStep, params));
        }

        return resolvedTransform;
      },

      // By default (if usingDotNotation is false), looks up path in
      // object via `object[path]`
      //
      // If `usingDotNotation` is true, then the path is assumed to
      // represent a nested path. It can be in the form of an array of
      // field names, or a period delimited string. The function will
      // look up the value of object[path[0]], and then call
      // result[path[1]] on the result, etc etc.
      //
      // If `usingDotNotation` is true, this function still supports
      // non nested fields.
      //
      // `usingDotNotation` is a performance optimization. The caller
      // may know that a path is *not* nested. In which case, this
      // function avoids a costly string.split('.')
      //
      // examples:
      // getIn({a: 1}, "a") => 1
      // getIn({a: 1}, "a", true) => 1
      // getIn({a: {b: 1}}, ["a", "b"], true) => 1
      // getIn({a: {b: 1}}, "a.b", true) => 1
      getIn: function (object, path, usingDotNotation) {
        if (object == null) {
          return undefined;
        }
        if (!usingDotNotation) {
          return object[path];
        }

        if (typeof (path) === "string") {
          path = path.split(".");
        }

        if (!Array.isArray(path)) {
          throw new Error("path must be a string or array. Found " + typeof (path));
        }

        var index = 0,
          length = path.length;

        while (object != null && index < length) {
          object = object[path[index++]];
        }
        return (index && index == length) ? object : undefined;
      }
    };

    // wrapping in object to expose to default export for potential user override.
    // warning: overriding these methods will override behavior for all loki db instances in memory.
    // warning: if you use binary indices these comparators should be the same for all inserts/updates/removes.
    var Comparators = {
      aeq: aeqHelper,
      lt: ltHelper,
      gt: gtHelper
    };

    /** Helper function for determining 'loki' abstract equality which is a little more abstract than ==
     *     aeqHelper(5, '5') === true
     *     aeqHelper(5.0, '5') === true
     *     aeqHelper(new Date("1/1/2011"), new Date("1/1/2011")) === true
     *     aeqHelper({a:1}, {z:4}) === true (all objects sorted equally)
     *     aeqHelper([1, 2, 3], [1, 3]) === false
     *     aeqHelper([1, 2, 3], [1, 2, 3]) === true
     *     aeqHelper(undefined, null) === true
     */
    function aeqHelper(prop1, prop2) {
      var cv1, cv2, t1, t2;

      if (prop1 === prop2) return true;

      // 'falsy' and Boolean handling
      if (!prop1 || !prop2 || prop1 === true || prop2 === true || prop1 !== prop1 || prop2 !== prop2) {
        // dates and NaN conditions (typed dates before serialization)
        switch (prop1) {
          case undefined: t1 = 1; break;
          case null: t1 = 1; break;
          case false: t1 = 3; break;
          case true: t1 = 4; break;
          case "": t1 = 5; break;
          default: t1 = (prop1 === prop1) ? 9 : 0; break;
        }

        switch (prop2) {
          case undefined: t2 = 1; break;
          case null: t2 = 1; break;
          case false: t2 = 3; break;
          case true: t2 = 4; break;
          case "": t2 = 5; break;
          default: t2 = (prop2 === prop2) ? 9 : 0; break;
        }

        // one or both is edge case
        if (t1 !== 9 || t2 !== 9) {
          return (t1 === t2);
        }
      }

      // Handle 'Number-like' comparisons
      cv1 = Number(prop1);
      cv2 = Number(prop2);

      // if one or both are 'number-like'...
      if (cv1 === cv1 || cv2 === cv2) {
        return (cv1 === cv2);
      }

      // not strict equal nor less than nor gt so must be mixed types, convert to string and use that to compare
      cv1 = prop1.toString();
      cv2 = prop2.toString();

      return (cv1 == cv2);
    }

    /** Helper function for determining 'less-than' conditions for ops, sorting, and binary indices.
     *     In the future we might want $lt and $gt ops to use their own functionality/helper.
     *     Since binary indices on a property might need to index [12, NaN, new Date(), Infinity], we
     *     need this function (as well as gtHelper) to always ensure one value is LT, GT, or EQ to another.
     */
    function ltHelper(prop1, prop2, equal) {
      var cv1, cv2, t1, t2;

      // if one of the params is falsy or strictly true or not equal to itself
      // 0, 0.0, "", NaN, null, undefined, not defined, false, true
      if (!prop1 || !prop2 || prop1 === true || prop2 === true || prop1 !== prop1 || prop2 !== prop2) {
        switch (prop1) {
          case undefined: t1 = 1; break;
          case null: t1 = 1; break;
          case false: t1 = 3; break;
          case true: t1 = 4; break;
          case "": t1 = 5; break;
          // if strict equal probably 0 so sort higher, otherwise probably NaN so sort lower than even null
          default: t1 = (prop1 === prop1) ? 9 : 0; break;
        }

        switch (prop2) {
          case undefined: t2 = 1; break;
          case null: t2 = 1; break;
          case false: t2 = 3; break;
          case true: t2 = 4; break;
          case "": t2 = 5; break;
          default: t2 = (prop2 === prop2) ? 9 : 0; break;
        }

        // one or both is edge case
        if (t1 !== 9 || t2 !== 9) {
          return (t1 === t2) ? equal : (t1 < t2);
        }
      }

      // if both are numbers (string encoded or not), compare as numbers
      cv1 = Number(prop1);
      cv2 = Number(prop2);

      if (cv1 === cv1 && cv2 === cv2) {
        if (cv1 < cv2) return true;
        if (cv1 > cv2) return false;
        return equal;
      }

      if (cv1 === cv1 && cv2 !== cv2) {
        return true;
      }

      if (cv2 === cv2 && cv1 !== cv1) {
        return false;
      }

      if (prop1 < prop2) return true;
      if (prop1 > prop2) return false;
      if (prop1 == prop2) return equal;

      // not strict equal nor less than nor gt so must be mixed types, convert to string and use that to compare
      cv1 = prop1.toString();
      cv2 = prop2.toString();

      if (cv1 < cv2) {
        return true;
      }

      if (cv1 == cv2) {
        return equal;
      }

      return false;
    }

    function gtHelper(prop1, prop2, equal) {
      var cv1, cv2, t1, t2;

      // 'falsy' and Boolean handling
      if (!prop1 || !prop2 || prop1 === true || prop2 === true || prop1 !== prop1 || prop2 !== prop2) {
        switch (prop1) {
          case undefined: t1 = 1; break;
          case null: t1 = 1; break;
          case false: t1 = 3; break;
          case true: t1 = 4; break;
          case "": t1 = 5; break;
          // NaN 0
          default: t1 = (prop1 === prop1) ? 9 : 0; break;
        }

        switch (prop2) {
          case undefined: t2 = 1; break;
          case null: t2 = 1; break;
          case false: t2 = 3; break;
          case true: t2 = 4; break;
          case "": t2 = 5; break;
          default: t2 = (prop2 === prop2) ? 9 : 0; break;
        }

        // one or both is edge case
        if (t1 !== 9 || t2 !== 9) {
          return (t1 === t2) ? equal : (t1 > t2);
        }
      }

      // if both are numbers (string encoded or not), compare as numbers
      cv1 = Number(prop1);
      cv2 = Number(prop2);
      if (cv1 === cv1 && cv2 === cv2) {
        if (cv1 > cv2) return true;
        if (cv1 < cv2) return false;
        return equal;
      }

      if (cv1 === cv1 && cv2 !== cv2) {
        return false;
      }

      if (cv2 === cv2 && cv1 !== cv1) {
        return true;
      }

      if (prop1 > prop2) return true;
      if (prop1 < prop2) return false;
      if (prop1 == prop2) return equal;

      // not strict equal nor less than nor gt so must be dates or mixed types
      // convert to string and use that to compare
      cv1 = prop1.toString();
      cv2 = prop2.toString();

      if (cv1 > cv2) {
        return true;
      }

      if (cv1 == cv2) {
        return equal;
      }

      return false;
    }

    function sortHelper(prop1, prop2, desc) {
      if (Comparators.aeq(prop1, prop2)) return 0;

      if (Comparators.lt(prop1, prop2, false)) {
        return (desc) ? (1) : (-1);
      }

      if (Comparators.gt(prop1, prop2, false)) {
        return (desc) ? (-1) : (1);
      }

      // not lt, not gt so implied equality-- date compatible
      return 0;
    }

    /**
     * compoundeval() - helper function for compoundsort(), performing individual object comparisons
     *
     * @param {array} properties - array of property names, in order, by which to evaluate sort order
     * @param {object} obj1 - first object to compare
     * @param {object} obj2 - second object to compare
     * @returns {integer} 0, -1, or 1 to designate if identical (sortwise) or which should be first
     */
    function compoundeval(properties, obj1, obj2) {
      var res = 0;
      var prop, field, val1, val2, arr, path;
      for (var i = 0, len = properties.length; i < len; i++) {
        prop = properties[i];
        field = prop[0];
        if (~field.indexOf('.')) {
          arr = field.split('.');
          val1 = Utils.getIn(obj1, arr, true);
          val2 = Utils.getIn(obj2, arr, true);
        } else {
          val1 = obj1[field];
          val2 = obj2[field];
        }
        res = sortHelper(val1, val2, prop[1]);
        if (res !== 0) {
          return res;
        }
      }
      return 0;
    }

    /**
     * dotSubScan - helper function used for dot notation queries.
     *
     * @param {object} root - object to traverse
     * @param {array} paths - array of properties to drill into
     * @param {function} fun - evaluation function to test with
     * @param {any} value - comparative value to also pass to (compare) fun
     * @param {any} extra - extra arg to also pass to compare fun
     * @param {number} poffset - index of the item in 'paths' to start the sub-scan from
     */
    function dotSubScan(root, paths, fun, value, extra, poffset) {
      var pathOffset = poffset || 0;
      var path = paths[pathOffset];

      var valueFound = false;
      var element;
      if (typeof root === 'object' && path in root) {
        element = root[path];
      }
      if (pathOffset + 1 >= paths.length) {
        // if we have already expanded out the dot notation,
        // then just evaluate the test function and value on the element
        valueFound = fun(element, value, extra);
      } else if (Array.isArray(element)) {
        for (var index = 0, len = element.length; index < len; index += 1) {
          valueFound = dotSubScan(element[index], paths, fun, value, extra, pathOffset + 1);
          if (valueFound === true) {
            break;
          }
        }
      } else {
        valueFound = dotSubScan(element, paths, fun, value, extra, pathOffset + 1);
      }

      return valueFound;
    }

    function containsCheckFn(a) {
      if (typeof a === 'string' || Array.isArray(a)) {
        return function (b) {
          return a.indexOf(b) !== -1;
        };
      } else if (typeof a === 'object' && a !== null) {
        return function (b) {
          return hasOwnProperty.call(a, b);
        };
      }
      return null;
    }

    function doQueryOp(val, op, record) {
      for (var p in op) {
        if (hasOwnProperty.call(op, p)) {
          return LokiOps[p](val, op[p], record);
        }
      }
      return false;
    }

    var LokiOps = {
      // comparison operators
      // a is the value in the collection
      // b is the query value
      $eq: function (a, b) {
        return a === b;
      },

      // abstract/loose equality
      $aeq: function (a, b) {
        return a == b;
      },

      $ne: function (a, b) {
        // ecma 5 safe test for NaN
        if (b !== b) {
          // ecma 5 test value is not NaN
          return (a === a);
        }

        return a !== b;
      },
      // date equality / loki abstract equality test
      $dteq: function (a, b) {
        return Comparators.aeq(a, b);
      },

      // loki comparisons: return identical unindexed results as indexed comparisons
      $gt: function (a, b) {
        return Comparators.gt(a, b, false);
      },

      $gte: function (a, b) {
        return Comparators.gt(a, b, true);
      },

      $lt: function (a, b) {
        return Comparators.lt(a, b, false);
      },

      $lte: function (a, b) {
        return Comparators.lt(a, b, true);
      },

      // lightweight javascript comparisons
      $jgt: function (a, b) {
        return a > b;
      },

      $jgte: function (a, b) {
        return a >= b;
      },

      $jlt: function (a, b) {
        return a < b;
      },

      $jlte: function (a, b) {
        return a <= b;
      },

      // ex : coll.find({'orderCount': {$between: [10, 50]}});
      $between: function (a, vals) {
        if (a === undefined || a === null) return false;
        return (Comparators.gt(a, vals[0], true) && Comparators.lt(a, vals[1], true));
      },

      $jbetween: function (a, vals) {
        if (a === undefined || a === null) return false;
        return (a >= vals[0] && a <= vals[1]);
      },

      $in: function (a, b) {
        return b.indexOf(a) !== -1;
      },

      $inSet: function(a, b) {
        return b.has(a);
      },

      $nin: function (a, b) {
        return b.indexOf(a) === -1;
      },

      $keyin: function (a, b) {
        return a in b;
      },

      $nkeyin: function (a, b) {
        return !(a in b);
      },

      $definedin: function (a, b) {
        return b[a] !== undefined;
      },

      $undefinedin: function (a, b) {
        return b[a] === undefined;
      },

      $regex: function (a, b) {
        return b.test(a);
      },

      $containsString: function (a, b) {
        return (typeof a === 'string') && (a.indexOf(b) !== -1);
      },

      $containsNone: function (a, b) {
        return !LokiOps.$containsAny(a, b);
      },

      $containsAny: function (a, b) {
        var checkFn = containsCheckFn(a);
        if (checkFn !== null) {
          return (Array.isArray(b)) ? (b.some(checkFn)) : (checkFn(b));
        }
        return false;
      },

      $contains: function (a, b) {
        var checkFn = containsCheckFn(a);
        if (checkFn !== null) {
          return (Array.isArray(b)) ? (b.every(checkFn)) : (checkFn(b));
        }
        return false;
      },

      $elemMatch: function (a, b) {
        if (Array.isArray(a)) {
          return a.some(function (item) {
            return Object.keys(b).every(function (property) {
              var filter = b[property];
              if (!(typeof filter === 'object' && filter)) {
                filter = { $eq: filter };
              }

              if (property.indexOf('.') !== -1) {
                return dotSubScan(item, property.split('.'), doQueryOp, b[property], item);
              }
              return doQueryOp(item[property], filter, item);
            });
          });
        }
        return false;
      },

      $type: function (a, b, record) {
        var type = typeof a;
        if (type === 'object') {
          if (Array.isArray(a)) {
            type = 'array';
          } else if (a instanceof Date) {
            type = 'date';
          }
        }
        return (typeof b !== 'object') ? (type === b) : doQueryOp(type, b, record);
      },

      $finite: function (a, b) {
        return (b === isFinite(a));
      },

      $size: function (a, b, record) {
        if (Array.isArray(a)) {
          return (typeof b !== 'object') ? (a.length === b) : doQueryOp(a.length, b, record);
        }
        return false;
      },

      $len: function (a, b, record) {
        if (typeof a === 'string') {
          return (typeof b !== 'object') ? (a.length === b) : doQueryOp(a.length, b, record);
        }
        return false;
      },

      $where: function (a, b) {
        return b(a) === true;
      },

      // field-level logical operators
      // a is the value in the collection
      // b is the nested query operation (for '$not')
      //   or an array of nested query operations (for '$and' and '$or')
      $not: function (a, b, record) {
        return !doQueryOp(a, b, record);
      },

      $and: function (a, b, record) {
        for (var idx = 0, len = b.length; idx < len; idx += 1) {
          if (!doQueryOp(a, b[idx], record)) {
            return false;
          }
        }
        return true;
      },

      $or: function (a, b, record) {
        for (var idx = 0, len = b.length; idx < len; idx += 1) {
          if (doQueryOp(a, b[idx], record)) {
            return true;
          }
        }
        return false;
      },

      $exists: function (a, b) {
        if (b) {
          return a !== undefined;
        } else {
          return a === undefined;
        }
      }
    };

    // ops that can be used with { $$op: 'column-name' } syntax
    var valueLevelOps = ['$eq', '$aeq', '$ne', '$dteq', '$gt', '$gte', '$lt', '$lte', '$jgt', '$jgte', '$jlt', '$jlte', '$type'];
    valueLevelOps.forEach(function (op) {
      var fun = LokiOps[op];
      LokiOps['$' + op] = function (a, spec, record) {
        if (typeof spec === 'string') {
          return fun(a, record[spec]);
        } else if (typeof spec === 'function') {
          return fun(a, spec(record));
        } else {
          throw new Error('Invalid argument to $$ matcher');
        }
      };
    });

    // if an op is registered in this object, our 'calculateRange' can use it with our binary indices.
    // if the op is registered to a function, we will run that function/op as a 2nd pass filter on results.
    // those 2nd pass filter functions should be similar to LokiOps functions, accepting 2 vals to compare.
    var indexedOps = {
      $eq: LokiOps.$eq,
      $aeq: true,
      $dteq: true,
      $gt: true,
      $gte: true,
      $lt: true,
      $lte: true,
      $in: true,
      $between: true
    };

    function clone(data, method) {
      if (data === null || data === undefined) {
        return null;
      }

      var cloneMethod = method || 'parse-stringify',
        cloned;

      switch (cloneMethod) {
        case "parse-stringify":
          cloned = JSON.parse(JSON.stringify(data));
          break;
        case "jquery-extend-deep":
          cloned = jQuery.extend(true, {}, data);
          break;
        case "shallow":
          // more compatible method for older browsers
          cloned = Object.create(data.constructor.prototype);
          Object.keys(data).map(function (i) {
            cloned[i] = data[i];
          });
          break;
        case "shallow-assign":
          // should be supported by newer environments/browsers
          cloned = Object.create(data.constructor.prototype);
          Object.assign(cloned, data);
          break;
        case "shallow-recurse-objects":
          // shallow clone top level properties
          cloned = clone(data, "shallow");
          var keys = Object.keys(data);
          // for each of the top level properties which are object literals, recursively shallow copy
          keys.forEach(function (key) {
            if (typeof data[key] === "object" && data[key].constructor.name === "Object") {
              cloned[key] = clone(data[key], "shallow-recurse-objects");
            } else if (Array.isArray(data[key])) {
              cloned[key] = cloneObjectArray(data[key], "shallow-recurse-objects");
            }
          });
          break;
        default:
          break;
      }

      return cloned;
    }

    function cloneObjectArray(objarray, method) {
      if (method == "parse-stringify") {
        return clone(objarray, method);
      }
      var result = [];
      for (var i = 0, len = objarray.length; i < len; i++) {
        result[i] = clone(objarray[i], method);
      }
      return result;
    }

    function localStorageAvailable() {
      try {
        return (window && window.localStorage !== undefined && window.localStorage !== null);
      } catch (e) {
        return false;
      }
    }


    /**
     * LokiEventEmitter is a minimalist version of EventEmitter. It enables any
     * constructor that inherits EventEmitter to emit events and trigger
     * listeners that have been added to the event through the on(event, callback) method
     *
     * @constructor LokiEventEmitter
     */
    function LokiEventEmitter() { }

    /**
     * @prop {hashmap} events - a hashmap, with each property being an array of callbacks
     * @memberof LokiEventEmitter
     */
    LokiEventEmitter.prototype.events = {};

    /**
     * @prop {boolean} asyncListeners - boolean determines whether or not the callbacks associated with each event
     * should happen in an async fashion or not
     * Default is false, which means events are synchronous
     * @memberof LokiEventEmitter
     */
    LokiEventEmitter.prototype.asyncListeners = false;

    /**
     * on(eventName, listener) - adds a listener to the queue of callbacks associated to an event
     * @param {string|string[]} eventName - the name(s) of the event(s) to listen to
     * @param {function} listener - callback function of listener to attach
     * @returns {int} the index of the callback in the array of listeners for a particular event
     * @memberof LokiEventEmitter
     */
    LokiEventEmitter.prototype.on = function (eventName, listener) {
      var event;
      var self = this;

      if (Array.isArray(eventName)) {
        eventName.forEach(function (currentEventName) {
          self.on(currentEventName, listener);
        });
        return listener;
      }

      event = this.events[eventName];
      if (!event) {
        event = this.events[eventName] = [];
      }
      event.push(listener);
      return listener;
    };

    /**
     * emit(eventName, data) - emits a particular event
     * with the option of passing optional parameters which are going to be processed by the callback
     * provided signatures match (i.e. if passing emit(event, arg0, arg1) the listener should take two parameters)
     * @param {string} eventName - the name of the event
     * @param {object=} data - optional object passed with the event
     * @memberof LokiEventEmitter
     */
    LokiEventEmitter.prototype.emit = function (eventName) {
      var self = this;
      var selfArgs;
      if (eventName && this.events[eventName]) {
        if (this.events[eventName].length) {
          selfArgs = Array.prototype.slice.call(arguments, 1);
          this.events[eventName].forEach(function (listener) {
            if (self.asyncListeners) {
              setTimeout(function () {
                listener.apply(self, selfArgs);
              }, 1);
            } else {
              listener.apply(self, selfArgs);
            }
          });
        }
      } else {
        throw new Error('No event ' + eventName + ' defined');
      }
    };

    /**
     * Alias of LokiEventEmitter.prototype.on
     * addListener(eventName, listener) - adds a listener to the queue of callbacks associated to an event
     * @param {string|string[]} eventName - the name(s) of the event(s) to listen to
     * @param {function} listener - callback function of listener to attach
     * @returns {int} the index of the callback in the array of listeners for a particular event
     * @memberof LokiEventEmitter
     */
    LokiEventEmitter.prototype.addListener = LokiEventEmitter.prototype.on;

    /**
     * removeListener() - removes the listener at position 'index' from the event 'eventName'
     * @param {string|string[]} eventName - the name(s) of the event(s) which the listener is attached to
     * @param {function} listener - the listener callback function to remove from emitter
     * @memberof LokiEventEmitter
     */
    LokiEventEmitter.prototype.removeListener = function (eventName, listener) {
      var self = this;

      if (Array.isArray(eventName)) {
        eventName.forEach(function (currentEventName) {
          self.removeListener(currentEventName, listener);
        });

        return;
      }

      if (this.events[eventName]) {
        var listeners = this.events[eventName];
        listeners.splice(listeners.indexOf(listener), 1);
      }
    };

    /**
     * Loki: The main database class
     * @constructor Loki
     * @implements LokiEventEmitter
     * @param {string} filename - name of the file to be saved to
     * @param {object=} options - (Optional) config options object
     * @param {string} options.env - override environment detection as 'NODEJS', 'BROWSER', 'CORDOVA'
     * @param {boolean} [options.verbose=false] - enable console output
     * @param {boolean} [options.autosave=false] - enables autosave
     * @param {int} [options.autosaveInterval=5000] - time interval (in milliseconds) between saves (if dirty)
     * @param {boolean} [options.autoload=false] - enables autoload on loki instantiation
     * @param {function} options.autoloadCallback - user callback called after database load
     * @param {adapter} options.adapter - an instance of a loki persistence adapter
     * @param {string} [options.serializationMethod='normal'] - ['normal', 'pretty', 'destructured']
     * @param {string} options.destructureDelimiter - string delimiter used for destructured serialization
     * @param {boolean} [options.throttledSaves=true] - debounces multiple calls to to saveDatabase reducing number of disk I/O operations
                                                and guaranteeing proper serialization of the calls.
     */
    function Loki(filename, options) {
      this.filename = filename || 'loki.db';
      this.collections = [];

      // persist version of code which created the database to the database.
      // could use for upgrade scenarios
      this.databaseVersion = 1.5;
      this.engineVersion = 1.5;

      // autosave support (disabled by default)
      // pass autosave: true, autosaveInterval: 6000 in options to set 6 second autosave
      this.autosave = false;
      this.autosaveInterval = 5000;
      this.autosaveHandle = null;
      this.throttledSaves = true;

      this.options = {};

      // currently keeping persistenceMethod and persistenceAdapter as loki level properties that
      // will not or cannot be deserialized.  You are required to configure persistence every time
      // you instantiate a loki object (or use default environment detection) in order to load the database anyways.

      // persistenceMethod could be 'fs', 'localStorage', or 'adapter'
      // this is optional option param, otherwise environment detection will be used
      // if user passes their own adapter we will force this method to 'adapter' later, so no need to pass method option.
      this.persistenceMethod = null;

      // retain reference to optional (non-serializable) persistenceAdapter 'instance'
      this.persistenceAdapter = null;

      // flags used to throttle saves
      this.throttledSavePending = false;
      this.throttledCallbacks = [];

      // enable console output if verbose flag is set (disabled by default)
      this.verbose = options && options.hasOwnProperty('verbose') ? options.verbose : false;

      this.events = {
        'init': [],
        'loaded': [],
        'flushChanges': [],
        'close': [],
        'changes': [],
        'warning': []
      };

      var getENV = function () {
        if (typeof global !== 'undefined' && (global.android || global.NSObject)) {
          // If no adapter assume nativescript which needs adapter to be passed manually
          return 'NATIVESCRIPT'; //nativescript
        }

        if (typeof window === 'undefined') {
          return 'NODEJS';
        }

        if (typeof global !== 'undefined' && global.window && typeof process !== 'undefined') {
          return 'NODEJS'; //node-webkit
        }

        if (typeof document !== 'undefined') {
          if (document.URL.indexOf('http://') === -1 && document.URL.indexOf('https://') === -1) {
            return 'CORDOVA';
          }
          return 'BROWSER';
        }
        return 'CORDOVA';
      };

      // refactored environment detection due to invalid detection for browser environments.
      // if they do not specify an options.env we want to detect env rather than default to nodejs.
      // currently keeping two properties for similar thing (options.env and options.persistenceMethod)
      //   might want to review whether we can consolidate.
      if (options && options.hasOwnProperty('env')) {
        this.ENV = options.env;
      } else {
        this.ENV = getENV();
      }

      // not sure if this is necessary now that i have refactored the line above
      if (this.ENV === 'undefined') {
        this.ENV = 'NODEJS';
      }

      this.configureOptions(options, true);

      this.on('init', this.clearChanges);

    }

    // db class is an EventEmitter
    Loki.prototype = new LokiEventEmitter();
    Loki.prototype.constructor = Loki;

    // experimental support for browserify's abstract syntax scan to pick up dependency of indexed adapter.
    // Hopefully, once this hits npm a browserify require of lokijs should scan the main file and detect this indexed adapter reference.
    Loki.prototype.getIndexedAdapter = function () {
      var adapter;

      if (typeof require === 'function') {
        adapter = require("./loki-indexed-adapter.js");
      }

      return adapter;
    };


    /**
     * Allows reconfiguring database options
     *
     * @param {object} options - configuration options to apply to loki db object
     * @param {string} options.env - override environment detection as 'NODEJS', 'BROWSER', 'CORDOVA'
     * @param {boolean} options.verbose - enable console output (default is 'false')
     * @param {boolean} options.autosave - enables autosave
     * @param {int} options.autosaveInterval - time interval (in milliseconds) between saves (if dirty)
     * @param {boolean} options.autoload - enables autoload on loki instantiation
     * @param {function} options.autoloadCallback - user callback called after database load
     * @param {adapter} options.adapter - an instance of a loki persistence adapter
     * @param {string} options.serializationMethod - ['normal', 'pretty', 'destructured']
     * @param {string} options.destructureDelimiter - string delimiter used for destructured serialization
     * @param {boolean} initialConfig - (internal) true is passed when loki ctor is invoking
     * @memberof Loki
     */
    Loki.prototype.configureOptions = function (options, initialConfig) {
      var defaultPersistence = {
        'NODEJS': 'fs',
        'BROWSER': 'localStorage',
        'CORDOVA': 'localStorage',
        'MEMORY': 'memory'
      },
        persistenceMethods = {
          'fs': LokiFsAdapter,
          'localStorage': LokiLocalStorageAdapter,
          'memory': LokiMemoryAdapter
        };

      this.options = {};

      this.persistenceMethod = null;
      // retain reference to optional persistence adapter 'instance'
      // currently keeping outside options because it can't be serialized
      this.persistenceAdapter = null;

      // process the options
      if (typeof (options) !== 'undefined') {
        this.options = options;

        if (this.options.hasOwnProperty('persistenceMethod')) {
          // check if the specified persistence method is known
          if (typeof (persistenceMethods[options.persistenceMethod]) == 'function') {
            this.persistenceMethod = options.persistenceMethod;
            this.persistenceAdapter = new persistenceMethods[options.persistenceMethod]();
          }
          // should be throw an error here, or just fall back to defaults ??
        }

        // if user passes adapter, set persistence mode to adapter and retain persistence adapter instance
        if (this.options.hasOwnProperty('adapter')) {
          this.persistenceMethod = 'adapter';
          this.persistenceAdapter = options.adapter;
          this.options.adapter = null;

          // if true, will keep track of dirty ids
          this.isIncremental = this.persistenceAdapter.mode === 'incremental';
        }


        // if they want to load database on loki instantiation, now is a good time to load... after adapter set and before possible autosave initiation
        if (options.autoload && initialConfig) {
          // for autoload, let the constructor complete before firing callback
          var self = this;
          setTimeout(function () {
            self.loadDatabase(options, options.autoloadCallback);
          }, 1);
        }

        if (this.options.hasOwnProperty('autosaveInterval')) {
          this.autosaveDisable();
          this.autosaveInterval = parseInt(this.options.autosaveInterval, 10);
        }

        if (this.options.hasOwnProperty('autosave') && this.options.autosave) {
          this.autosaveDisable();
          this.autosave = true;

          if (this.options.hasOwnProperty('autosaveCallback')) {
            this.autosaveEnable(options, options.autosaveCallback);
          } else {
            this.autosaveEnable();
          }
        }

        if (this.options.hasOwnProperty('throttledSaves')) {
          this.throttledSaves = this.options.throttledSaves;
        }
      } // end of options processing

      // ensure defaults exists for options which were not set
      if (!this.options.hasOwnProperty('serializationMethod')) {
        this.options.serializationMethod = 'normal';
      }

      // ensure passed or default option exists
      if (!this.options.hasOwnProperty('destructureDelimiter')) {
        this.options.destructureDelimiter = '$<\n';
      }

      // if by now there is no adapter specified by user nor derived from persistenceMethod: use sensible defaults
      if (this.persistenceAdapter === null) {
        this.persistenceMethod = defaultPersistence[this.ENV];
        if (this.persistenceMethod) {
          this.persistenceAdapter = new persistenceMethods[this.persistenceMethod]();
        }
      }

    };

    /**
     * Copies 'this' database into a new Loki instance. Object references are shared to make lightweight.
     *
     * @param {object} options - apply or override collection level settings
     * @param {bool} options.removeNonSerializable - nulls properties not safe for serialization.
     * @memberof Loki
     */
    Loki.prototype.copy = function (options) {
      // in case running in an environment without accurate environment detection, pass 'NA'
      var databaseCopy = new Loki(this.filename, { env: "NA" });
      var clen, idx;

      options = options || {};

      // currently inverting and letting loadJSONObject do most of the work
      databaseCopy.loadJSONObject(this, { retainDirtyFlags: true });

      // since our JSON serializeReplacer is not invoked for reference database adapters, this will let us mimic
      if (options.hasOwnProperty("removeNonSerializable") && options.removeNonSerializable === true) {
        databaseCopy.autosaveHandle = null;
        databaseCopy.persistenceAdapter = null;

        clen = databaseCopy.collections.length;
        for (idx = 0; idx < clen; idx++) {
          databaseCopy.collections[idx].constraints = null;
          databaseCopy.collections[idx].ttl = null;
        }
      }

      return databaseCopy;
    };

    /**
     * Adds a collection to the database.
     * @param {string} name - name of collection to add
     * @param {object=} options - (optional) options to configure collection with.
     * @param {array=} [options.unique=[]] - array of property names to define unique constraints for
     * @param {array=} [options.exact=[]] - array of property names to define exact constraints for
     * @param {array=} [options.indices=[]] - array property names to define binary indexes for
     * @param {boolean} [options.asyncListeners=false] - whether listeners are called asynchronously
     * @param {boolean} [options.disableMeta=false] - set to true to disable meta property on documents
     * @param {boolean} [options.disableChangesApi=true] - set to false to enable Changes Api
     * @param {boolean} [options.disableDeltaChangesApi=true] - set to false to enable Delta Changes API (requires Changes API, forces cloning)
     * @param {boolean} [options.autoupdate=false] - use Object.observe to update objects automatically
     * @param {boolean} [options.clone=false] - specify whether inserts and queries clone to/from user
     * @param {string} [options.cloneMethod='parse-stringify'] - 'parse-stringify', 'jquery-extend-deep', 'shallow, 'shallow-assign'
     * @param {int=} options.ttl - age of document (in ms.) before document is considered aged/stale.
     * @param {int=} options.ttlInterval - time interval for clearing out 'aged' documents; not set by default.
     * @returns {Collection} a reference to the collection which was just added
     * @memberof Loki
     */
    Loki.prototype.addCollection = function (name, options) {
      var i,
        len = this.collections.length;

      if (options && options.disableMeta === true) {
        if (options.disableChangesApi === false) {
          throw new Error("disableMeta option cannot be passed as true when disableChangesApi is passed as false");
        }
        if (options.disableDeltaChangesApi === false) {
          throw new Error("disableMeta option cannot be passed as true when disableDeltaChangesApi is passed as false");
        }
        if (typeof options.ttl === "number" && options.ttl > 0) {
          throw new Error("disableMeta option cannot be passed as true when ttl is enabled");
        }
      }

      for (i = 0; i < len; i += 1) {
        if (this.collections[i].name === name) {
          return this.collections[i];
        }
      }

      var collection = new Collection(name, options);
      collection.isIncremental = this.isIncremental;
      this.collections.push(collection);

      if (this.verbose)
        collection.lokiConsoleWrapper = console;

      return collection;
    };

    Loki.prototype.loadCollection = function (collection) {
      if (!collection.name) {
        throw new Error('Collection must have a name property to be loaded');
      }
      this.collections.push(collection);
    };

    /**
     * Retrieves reference to a collection by name.
     * @param {string} collectionName - name of collection to look up
     * @returns {Collection} Reference to collection in database by that name, or null if not found
     * @memberof Loki
     */
    Loki.prototype.getCollection = function (collectionName) {
      var i,
        len = this.collections.length;

      for (i = 0; i < len; i += 1) {
        if (this.collections[i].name === collectionName) {
          return this.collections[i];
        }
      }

      // no such collection
      this.emit('warning', 'collection ' + collectionName + ' not found');
      return null;
    };

    /**
     * Renames an existing loki collection
     * @param {string} oldName - name of collection to rename
     * @param {string} newName - new name of collection
     * @returns {Collection} reference to the newly renamed collection
     * @memberof Loki
     */
    Loki.prototype.renameCollection = function (oldName, newName) {
      var c = this.getCollection(oldName);

      if (c) {
        c.name = newName;
      }

      return c;
    };

    /**
     * Returns a list of collections in the database.
     * @returns {object[]} array of objects containing 'name', 'type', and 'count' properties.
     * @memberof Loki
     */
    Loki.prototype.listCollections = function () {

      var i = this.collections.length,
        colls = [];

      while (i--) {
        colls.push({
          name: this.collections[i].name,
          type: this.collections[i].objType,
          count: this.collections[i].data.length
        });
      }
      return colls;
    };

    /**
     * Removes a collection from the database.
     * @param {string} collectionName - name of collection to remove
     * @memberof Loki
     */
    Loki.prototype.removeCollection = function (collectionName) {
      var i,
        len = this.collections.length;

      for (i = 0; i < len; i += 1) {
        if (this.collections[i].name === collectionName) {
          var tmpcol = new Collection(collectionName, {});
          var curcol = this.collections[i];
          for (var prop in curcol) {
            if (curcol.hasOwnProperty(prop) && tmpcol.hasOwnProperty(prop)) {
              curcol[prop] = tmpcol[prop];
            }
          }
          this.collections.splice(i, 1);
          return;
        }
      }
    };

    Loki.prototype.getName = function () {
      return this.name;
    };

    /**
     * serializeReplacer - used to prevent certain properties from being serialized
     *
     */
    Loki.prototype.serializeReplacer = function (key, value) {
      switch (key) {
        case 'autosaveHandle':
        case 'persistenceAdapter':
        case 'constraints':
        case 'ttl':
          return null;
        case 'throttledSavePending':
        case 'throttledCallbacks':
          return undefined;
        case 'lokiConsoleWrapper':
          return null;
        default:
          return value;
      }
    };

    /**
     * Serialize database to a string which can be loaded via {@link Loki#loadJSON}
     *
     * @returns {string} Stringified representation of the loki database.
     * @memberof Loki
     */
    Loki.prototype.serialize = function (options) {
      options = options || {};

      if (!options.hasOwnProperty("serializationMethod")) {
        options.serializationMethod = this.options.serializationMethod;
      }

      switch (options.serializationMethod) {
        case "normal": return JSON.stringify(this, this.serializeReplacer);
        case "pretty": return JSON.stringify(this, this.serializeReplacer, 2);
        case "destructured": return this.serializeDestructured(); // use default options
        default: return JSON.stringify(this, this.serializeReplacer);
      }
    };

    // alias of serialize
    Loki.prototype.toJson = Loki.prototype.serialize;

    /**
     * Database level destructured JSON serialization routine to allow alternate serialization methods.
     * Internally, Loki supports destructuring via loki "serializationMethod' option and
     * the optional LokiPartitioningAdapter class. It is also available if you wish to do
     * your own structured persistence or data exchange.
     *
     * @param {object=} options - output format options for use externally to loki
     * @param {bool=} options.partitioned - (default: false) whether db and each collection are separate
     * @param {int=} options.partition - can be used to only output an individual collection or db (-1)
     * @param {bool=} options.delimited - (default: true) whether subitems are delimited or subarrays
     * @param {string=} options.delimiter - override default delimiter
     *
     * @returns {string|array} A custom, restructured aggregation of independent serializations.
     * @memberof Loki
     */
    Loki.prototype.serializeDestructured = function (options) {
      var idx, sidx, result, resultlen;
      var reconstruct = [];
      var dbcopy;

      options = options || {};

      if (!options.hasOwnProperty("partitioned")) {
        options.partitioned = false;
      }

      if (!options.hasOwnProperty("delimited")) {
        options.delimited = true;
      }

      if (!options.hasOwnProperty("delimiter")) {
        options.delimiter = this.options.destructureDelimiter;
      }

      // 'partitioned' along with 'partition' of 0 or greater is a request for single collection serialization
      if (options.partitioned === true && options.hasOwnProperty("partition") && options.partition >= 0) {
        return this.serializeCollection({
          delimited: options.delimited,
          delimiter: options.delimiter,
          collectionIndex: options.partition
        });
      }

      // not just an individual collection, so we will need to serialize db container via shallow copy
      dbcopy = new Loki(this.filename);
      dbcopy.loadJSONObject(this);

      for (idx = 0; idx < dbcopy.collections.length; idx++) {
        dbcopy.collections[idx].data = [];
      }

      // if we -only- wanted the db container portion, return it now
      if (options.partitioned === true && options.partition === -1) {
        // since we are deconstructing, override serializationMethod to normal for here
        return dbcopy.serialize({
          serializationMethod: "normal"
        });
      }

      // at this point we must be deconstructing the entire database
      // start by pushing db serialization into first array element
      reconstruct.push(dbcopy.serialize({
        serializationMethod: "normal"
      }));

      dbcopy = null;

      // push collection data into subsequent elements
      for (idx = 0; idx < this.collections.length; idx++) {
        result = this.serializeCollection({
          delimited: options.delimited,
          delimiter: options.delimiter,
          collectionIndex: idx
        });

        // NDA : Non-Delimited Array : one iterable concatenated array with empty string collection partitions
        if (options.partitioned === false && options.delimited === false) {
          if (!Array.isArray(result)) {
            throw new Error("a nondelimited, non partitioned collection serialization did not return an expected array");
          }

          // Array.concat would probably duplicate memory overhead for copying strings.
          // Instead copy each individually, and clear old value after each copy.
          // Hopefully this will allow g.c. to reduce memory pressure, if needed.
          resultlen = result.length;

          for (sidx = 0; sidx < resultlen; sidx++) {
            reconstruct.push(result[sidx]);
            result[sidx] = null;
          }

          reconstruct.push("");
        }
        else {
          reconstruct.push(result);
        }
      }

      // Reconstruct / present results according to four combinations : D, DA, NDA, NDAA
      if (options.partitioned) {
        // DA : Delimited Array of strings [0] db [1] collection [n] collection { partitioned: true, delimited: true }
        // useful for simple future adaptations of existing persistence adapters to save collections separately
        if (options.delimited) {
          return reconstruct;
        }
        // NDAA : Non-Delimited Array with subArrays. db at [0] and collection subarrays at [n] { partitioned: true, delimited : false }
        // This format might be the most versatile for 'rolling your own' partitioned sync or save.
        // Memory overhead can be reduced by specifying a specific partition, but at this code path they did not, so its all.
        else {
          return reconstruct;
        }
      }
      else {
        // D : one big Delimited string { partitioned: false, delimited : true }
        // This is the method Loki will use internally if 'destructured'.
        // Little memory overhead improvements but does not require multiple asynchronous adapter call scheduling
        if (options.delimited) {
          // indicate no more collections
          reconstruct.push("");

          return reconstruct.join(options.delimiter);
        }
        // NDA : Non-Delimited Array : one iterable array with empty string collection partitions { partitioned: false, delimited: false }
        // This format might be best candidate for custom synchronous syncs or saves
        else {
          // indicate no more collections
          reconstruct.push("");

          return reconstruct;
        }
      }

      reconstruct.push("");

      return reconstruct.join(delim);
    };

    /**
     * Collection level utility method to serialize a collection in a 'destructured' format
     *
     * @param {object=} options - used to determine output of method
     * @param {int} options.delimited - whether to return single delimited string or an array
     * @param {string} options.delimiter - (optional) if delimited, this is delimiter to use
     * @param {int} options.collectionIndex -  specify which collection to serialize data for
     *
     * @returns {string|array} A custom, restructured aggregation of independent serializations for a single collection.
     * @memberof Loki
     */
    Loki.prototype.serializeCollection = function (options) {
      var doccount,
        docidx,
        resultlines = [];

      options = options || {};

      if (!options.hasOwnProperty("delimited")) {
        options.delimited = true;
      }

      if (!options.hasOwnProperty("collectionIndex")) {
        throw new Error("serializeCollection called without 'collectionIndex' option");
      }

      doccount = this.collections[options.collectionIndex].data.length;

      resultlines = [];

      for (docidx = 0; docidx < doccount; docidx++) {
        resultlines.push(JSON.stringify(this.collections[options.collectionIndex].data[docidx]));
      }

      // D and DA
      if (options.delimited) {
        // indicate no more documents in collection (via empty delimited string)
        resultlines.push("");

        return resultlines.join(options.delimiter);
      }
      else {
        // NDAA and NDA
        return resultlines;
      }
    };

    /**
     * Database level destructured JSON deserialization routine to minimize memory overhead.
     * Internally, Loki supports destructuring via loki "serializationMethod' option and
     * the optional LokiPartitioningAdapter class. It is also available if you wish to do
     * your own structured persistence or data exchange.
     *
     * @param {string|array} destructuredSource - destructured json or array to deserialize from
     * @param {object=} options - source format options
     * @param {bool=} [options.partitioned=false] - whether db and each collection are separate
     * @param {int=} options.partition - can be used to deserialize only a single partition
     * @param {bool=} [options.delimited=true] - whether subitems are delimited or subarrays
     * @param {string=} options.delimiter - override default delimiter
     *
     * @returns {object|array} An object representation of the deserialized database, not yet applied to 'this' db or document array
     * @memberof Loki
     */
    Loki.prototype.deserializeDestructured = function (destructuredSource, options) {
      var workarray = [];
      var len, cdb;
      var idx, collIndex = 0, collCount, lineIndex = 1, done = false;
      var currLine, currObject;

      options = options || {};

      if (!options.hasOwnProperty("partitioned")) {
        options.partitioned = false;
      }

      if (!options.hasOwnProperty("delimited")) {
        options.delimited = true;
      }

      if (!options.hasOwnProperty("delimiter")) {
        options.delimiter = this.options.destructureDelimiter;
      }

      // Partitioned
      // DA : Delimited Array of strings [0] db [1] collection [n] collection { partitioned: true, delimited: true }
      // NDAA : Non-Delimited Array with subArrays. db at [0] and collection subarrays at [n] { partitioned: true, delimited : false }
      // -or- single partition
      if (options.partitioned) {
        // handle single partition
        if (options.hasOwnProperty('partition')) {
          // db only
          if (options.partition === -1) {
            cdb = JSON.parse(destructuredSource[0]);

            return cdb;
          }

          // single collection, return doc array
          return this.deserializeCollection(destructuredSource[options.partition + 1], options);
        }

        // Otherwise we are restoring an entire partitioned db
        cdb = JSON.parse(destructuredSource[0]);
        collCount = cdb.collections.length;
        for (collIndex = 0; collIndex < collCount; collIndex++) {
          // attach each collection docarray to container collection data, add 1 to collection array index since db is at 0
          cdb.collections[collIndex].data = this.deserializeCollection(destructuredSource[collIndex + 1], options);
        }

        return cdb;
      }

      // Non-Partitioned
      // D : one big Delimited string { partitioned: false, delimited : true }
      // NDA : Non-Delimited Array : one iterable array with empty string collection partitions { partitioned: false, delimited: false }

      // D
      if (options.delimited) {
        workarray = destructuredSource.split(options.delimiter);
        destructuredSource = null; // lower memory pressure
        len = workarray.length;

        if (len === 0) {
          return null;
        }
      }
      // NDA
      else {
        workarray = destructuredSource;
      }

      // first line is database and collection shells
      cdb = JSON.parse(workarray[0]);
      collCount = cdb.collections.length;
      workarray[0] = null;

      while (!done) {
        currLine = workarray[lineIndex];

        // empty string indicates either end of collection or end of file
        if (workarray[lineIndex] === "") {
          // if no more collections to load into, we are done
          if (++collIndex > collCount) {
            done = true;
          }
        }
        else {
          currObject = JSON.parse(workarray[lineIndex]);
          cdb.collections[collIndex].data.push(currObject);
        }

        // lower memory pressure and advance iterator
        workarray[lineIndex++] = null;
      }

      return cdb;
    };

    /**
     * Collection level utility function to deserializes a destructured collection.
     *
     * @param {string|array} destructuredSource - destructured representation of collection to inflate
     * @param {object=} options - used to describe format of destructuredSource input
     * @param {int=} [options.delimited=false] - whether source is delimited string or an array
     * @param {string=} options.delimiter - if delimited, this is delimiter to use (if other than default)
     *
     * @returns {array} an array of documents to attach to collection.data.
     * @memberof Loki
     */
    Loki.prototype.deserializeCollection = function (destructuredSource, options) {
      var workarray = [];
      var idx, len;

      options = options || {};

      if (!options.hasOwnProperty("partitioned")) {
        options.partitioned = false;
      }

      if (!options.hasOwnProperty("delimited")) {
        options.delimited = true;
      }

      if (!options.hasOwnProperty("delimiter")) {
        options.delimiter = this.options.destructureDelimiter;
      }

      if (options.delimited) {
        workarray = destructuredSource.split(options.delimiter);
        workarray.pop();
      }
      else {
        workarray = destructuredSource;
      }

      len = workarray.length;
      for (idx = 0; idx < len; idx++) {
        workarray[idx] = JSON.parse(workarray[idx]);
      }

      return workarray;
    };

    /**
     * Inflates a loki database from a serialized JSON string
     *
     * @param {string} serializedDb - a serialized loki database string
     * @param {object=} options - apply or override collection level settings
     * @param {bool} options.retainDirtyFlags - whether collection dirty flags will be preserved
     * @memberof Loki
     */
    Loki.prototype.loadJSON = function (serializedDb, options) {
      var dbObject;
      if (serializedDb.length === 0) {
        dbObject = {};
      } else {

        // using option defined in instantiated db not what was in serialized db
        switch (this.options.serializationMethod) {
          case "normal":
          case "pretty": dbObject = JSON.parse(serializedDb); break;
          case "destructured": dbObject = this.deserializeDestructured(serializedDb); break;
          default: dbObject = JSON.parse(serializedDb); break;
        }
      }

      this.loadJSONObject(dbObject, options);
    };

    /**
     * Inflates a loki database from a JS object
     *
     * @param {object} dbObject - a serialized loki database string
     * @param {object=} options - apply or override collection level settings
     * @param {bool} options.retainDirtyFlags - whether collection dirty flags will be preserved
     * @memberof Loki
     */
    Loki.prototype.loadJSONObject = function (dbObject, options) {
      var i = 0,
        len = dbObject.collections ? dbObject.collections.length : 0,
        coll,
        copyColl,
        clen,
        j,
        loader,
        collObj;

      this.name = dbObject.name;

      // restore save throttled boolean only if not defined in options
      if (dbObject.hasOwnProperty('throttledSaves') && options && !options.hasOwnProperty('throttledSaves')) {
        this.throttledSaves = dbObject.throttledSaves;
      }

      this.collections = [];

      function makeLoader(coll) {
        var collOptions = options[coll.name];
        var inflater;

        if (collOptions.proto) {
          inflater = collOptions.inflate || Utils.copyProperties;

          return function (data) {
            var collObj = new (collOptions.proto)();
            inflater(data, collObj);
            return collObj;
          };
        }

        return collOptions.inflate;
      }

      for (i; i < len; i += 1) {
        coll = dbObject.collections[i];

        copyColl = this.addCollection(coll.name, {
          disableChangesApi: coll.disableChangesApi,
          disableDeltaChangesApi: coll.disableDeltaChangesApi,
          disableMeta: coll.disableMeta,
          disableFreeze: coll.hasOwnProperty('disableFreeze') ? coll.disableFreeze : true
        });

        copyColl.adaptiveBinaryIndices = coll.hasOwnProperty('adaptiveBinaryIndices') ? (coll.adaptiveBinaryIndices === true) : false;
        copyColl.transactional = coll.transactional;
        copyColl.asyncListeners = coll.asyncListeners;
        copyColl.cloneObjects = coll.cloneObjects;
        copyColl.cloneMethod = coll.cloneMethod || "parse-stringify";
        copyColl.autoupdate = coll.autoupdate;
        copyColl.changes = coll.changes;
        copyColl.dirtyIds = coll.dirtyIds || [];

        if (options && options.retainDirtyFlags === true) {
          copyColl.dirty = coll.dirty;
        }
        else {
          copyColl.dirty = false;
        }

        // load each element individually
        clen = coll.data.length;
        j = 0;
        if (options && options.hasOwnProperty(coll.name)) {
          loader = makeLoader(coll);

          for (j; j < clen; j++) {
            collObj = loader(coll.data[j]);
            copyColl.data[j] = collObj;
            copyColl.addAutoUpdateObserver(collObj);
            if (!copyColl.disableFreeze) {
              deepFreeze(copyColl.data[j]);
            }
          }
        } else {

          for (j; j < clen; j++) {
            copyColl.data[j] = coll.data[j];
            copyColl.addAutoUpdateObserver(copyColl.data[j]);
            if (!copyColl.disableFreeze) {
              deepFreeze(copyColl.data[j]);
            }
          }
        }

        copyColl.maxId = (typeof coll.maxId === 'undefined') ? 0 : coll.maxId;
        if (typeof (coll.binaryIndices) !== 'undefined') {
          copyColl.binaryIndices = coll.binaryIndices;
        }
        if (typeof coll.transforms !== 'undefined') {
          copyColl.transforms = coll.transforms;
        }

        // regenerate unique indexes
        copyColl.uniqueNames = [];
        if (coll.hasOwnProperty("uniqueNames")) {
          copyColl.uniqueNames = coll.uniqueNames;
        }

        // in case they are loading a database created before we added dynamic views, handle undefined
        if (typeof (coll.DynamicViews) === 'undefined') continue;

        // reinflate DynamicViews and attached Resultsets
        for (var idx = 0; idx < coll.DynamicViews.length; idx++) {
          var colldv = coll.DynamicViews[idx];

          var dv = copyColl.addDynamicView(colldv.name, colldv.options);
          dv.resultdata = colldv.resultdata;
          dv.resultsdirty = colldv.resultsdirty;
          dv.filterPipeline = colldv.filterPipeline;
          dv.sortCriteriaSimple = colldv.sortCriteriaSimple;
          dv.sortCriteria = colldv.sortCriteria;
          dv.sortFunction = null;
          dv.sortDirty = colldv.sortDirty;
          if (!copyColl.disableFreeze) {
            deepFreeze(dv.filterPipeline);
            if (dv.sortCriteriaSimple) {
              deepFreeze(dv.sortCriteriaSimple);
            } else if (dv.sortCriteria) {
              deepFreeze(dv.sortCriteria);
            }
          }
          dv.resultset.filteredrows = colldv.resultset.filteredrows;
          dv.resultset.filterInitialized = colldv.resultset.filterInitialized;

          dv.rematerialize({
            removeWhereFilters: true
          });
        }

        // Upgrade Logic for binary index refactoring at version 1.5
        if (dbObject.databaseVersion < 1.5) {
          // rebuild all indices
          copyColl.ensureAllIndexes(true);
          copyColl.dirty = true;
        }
      }
    };

    /**
     * Emits the close event. In autosave scenarios, if the database is dirty, this will save and disable timer.
     * Does not actually destroy the db.
     *
     * @param {function=} callback - (Optional) if supplied will be registered with close event before emitting.
     * @memberof Loki
     */
    Loki.prototype.close = function (callback) {
      // for autosave scenarios, we will let close perform final save (if dirty)
      // For web use, you might call from window.onbeforeunload to shutdown database, saving pending changes
      if (this.autosave) {
        this.autosaveDisable();
        if (this.autosaveDirty()) {
          this.saveDatabase(callback);
          callback = undefined;
        }
      }

      if (callback) {
        this.on('close', callback);
      }
      this.emit('close');
    };

    /**-------------------------+
    | Changes API               |
    +--------------------------*/

    /**
     * The Changes API enables the tracking the changes occurred in the collections since the beginning of the session,
     * so it's possible to create a differential dataset for synchronization purposes (possibly to a remote db)
     */

    /**
     * (Changes API) : takes all the changes stored in each
     * collection and creates a single array for the entire database. If an array of names
     * of collections is passed then only the included collections will be tracked.
     *
     * @param {array=} optional array of collection names. No arg means all collections are processed.
     * @returns {array} array of changes
     * @see private method createChange() in Collection
     * @memberof Loki
     */
    Loki.prototype.generateChangesNotification = function (arrayOfCollectionNames) {
      function getCollName(coll) {
        return coll.name;
      }
      var changes = [],
        selectedCollections = arrayOfCollectionNames || this.collections.map(getCollName);

      this.collections.forEach(function (coll) {
        if (selectedCollections.indexOf(getCollName(coll)) !== -1) {
          changes = changes.concat(coll.getChanges());
        }
      });
      return changes;
    };

    /**
     * (Changes API) - stringify changes for network transmission
     * @returns {string} string representation of the changes
     * @memberof Loki
     */
    Loki.prototype.serializeChanges = function (collectionNamesArray) {
      return JSON.stringify(this.generateChangesNotification(collectionNamesArray));
    };

    /**
     * (Changes API) : clears all the changes in all collections.
     * @memberof Loki
     */
    Loki.prototype.clearChanges = function () {
      this.collections.forEach(function (coll) {
        if (coll.flushChanges) {
          coll.flushChanges();
        }
      });
    };

    /*------------------+
    | PERSISTENCE       |
    -------------------*/

    /** there are two build in persistence adapters for internal use
     * fs             for use in Nodejs type environments
     * localStorage   for use in browser environment
     * defined as helper classes here so its easy and clean to use
     */

    /**
     * In in-memory persistence adapter for an in-memory database.
     * This simple 'key/value' adapter is intended for unit testing and diagnostics.
     *
     * @param {object=} options - memory adapter options
     * @param {boolean} [options.asyncResponses=false] - whether callbacks are invoked asynchronously
     * @param {int} [options.asyncTimeout=50] - timeout in ms to queue callbacks
     * @constructor LokiMemoryAdapter
     */
    function LokiMemoryAdapter(options) {
      this.hashStore = {};
      this.options = options || {};

      if (!this.options.hasOwnProperty('asyncResponses')) {
        this.options.asyncResponses = false;
      }

      if (!this.options.hasOwnProperty('asyncTimeout')) {
        this.options.asyncTimeout = 50; // 50 ms default
      }
    }

    /**
     * Loads a serialized database from its in-memory store.
     * (Loki persistence adapter interface function)
     *
     * @param {string} dbname - name of the database (filename/keyname)
     * @param {function} callback - adapter callback to return load result to caller
     * @memberof LokiMemoryAdapter
     */
    LokiMemoryAdapter.prototype.loadDatabase = function (dbname, callback) {
      var self = this;

      if (this.options.asyncResponses) {
        setTimeout(function () {
          if (self.hashStore.hasOwnProperty(dbname)) {
            callback(self.hashStore[dbname].value);
          }
          else {
            // database doesn't exist, return falsy
            callback(null);
          }
        }, this.options.asyncTimeout);
      }
      else {
        if (this.hashStore.hasOwnProperty(dbname)) {
          // database doesn't exist, return falsy
          callback(this.hashStore[dbname].value);
        }
        else {
          callback(null);
        }
      }
    };

    /**
     * Saves a serialized database to its in-memory store.
     * (Loki persistence adapter interface function)
     *
     * @param {string} dbname - name of the database (filename/keyname)
     * @param {function} callback - adapter callback to return load result to caller
     * @memberof LokiMemoryAdapter
     */
    LokiMemoryAdapter.prototype.saveDatabase = function (dbname, dbstring, callback) {
      var self = this;
      var saveCount;

      if (this.options.asyncResponses) {
        setTimeout(function () {
          saveCount = (self.hashStore.hasOwnProperty(dbname) ? self.hashStore[dbname].savecount : 0);

          self.hashStore[dbname] = {
            savecount: saveCount + 1,
            lastsave: new Date(),
            value: dbstring
          };

          callback();
        }, this.options.asyncTimeout);
      }
      else {
        saveCount = (this.hashStore.hasOwnProperty(dbname) ? this.hashStore[dbname].savecount : 0);

        this.hashStore[dbname] = {
          savecount: saveCount + 1,
          lastsave: new Date(),
          value: dbstring
        };

        callback();
      }
    };

    /**
     * Deletes a database from its in-memory store.
     *
     * @param {string} dbname - name of the database (filename/keyname)
     * @param {function} callback - function to call when done
     * @memberof LokiMemoryAdapter
     */
    LokiMemoryAdapter.prototype.deleteDatabase = function (dbname, callback) {
      if (this.hashStore.hasOwnProperty(dbname)) {
        delete this.hashStore[dbname];
      }

      if (typeof callback === "function") {
        callback();
      }
    };

    /**
     * An adapter for adapters.  Converts a non reference mode adapter into a reference mode adapter
     * which can perform destructuring and partioning.  Each collection will be stored in its own key/save and
     * only dirty collections will be saved.  If you  turn on paging with default page size of 25megs and save
     * a 75 meg collection it should use up roughly 3 save slots (key/value pairs sent to inner adapter).
     * A dirty collection that spans three pages will save all three pages again
     * Paging mode was added mainly because Chrome has issues saving 'too large' of a string within a
     * single indexeddb row.  If a single document update causes the collection to be flagged as dirty, all
     * of that collection's pages will be written on next save.
     *
     * @param {object} adapter - reference to a 'non-reference' mode loki adapter instance.
     * @param {object=} options - configuration options for partitioning and paging
     * @param {bool} options.paging - (default: false) set to true to enable paging collection data.
     * @param {int} options.pageSize - (default : 25MB) you can use this to limit size of strings passed to inner adapter.
     * @param {string} options.delimiter - allows you to override the default delimeter
     * @constructor LokiPartitioningAdapter
     */
    function LokiPartitioningAdapter(adapter, options) {
      this.mode = "reference";
      this.adapter = null;
      this.options = options || {};
      this.dbref = null;
      this.dbname = "";
      this.pageIterator = {};

      // verify user passed an appropriate adapter
      if (adapter) {
        if (adapter.mode === "reference") {
          throw new Error("LokiPartitioningAdapter cannot be instantiated with a reference mode adapter");
        }
        else {
          this.adapter = adapter;
        }
      }
      else {
        throw new Error("LokiPartitioningAdapter requires a (non-reference mode) adapter on construction");
      }

      // set collection paging defaults
      if (!this.options.hasOwnProperty("paging")) {
        this.options.paging = false;
      }

      // default to page size of 25 megs (can be up to your largest serialized object size larger than this)
      if (!this.options.hasOwnProperty("pageSize")) {
        this.options.pageSize = 25 * 1024 * 1024;
      }

      if (!this.options.hasOwnProperty("delimiter")) {
        this.options.delimiter = '$<\n';
      }
    }

    /**
     * Loads a database which was partitioned into several key/value saves.
     * (Loki persistence adapter interface function)
     *
     * @param {string} dbname - name of the database (filename/keyname)
     * @param {function} callback - adapter callback to return load result to caller
     * @memberof LokiPartitioningAdapter
     */
    LokiPartitioningAdapter.prototype.loadDatabase = function (dbname, callback) {
      var self = this;
      this.dbname = dbname;
      this.dbref = new Loki(dbname);

      // load the db container (without data)
      this.adapter.loadDatabase(dbname, function (result) {
        // empty database condition is for inner adapter return null/undefined/falsy
        if (!result) {
          // partition 0 not found so new database, no need to try to load other partitions.
          // return same falsy result to loadDatabase to signify no database exists (yet)
          callback(result);
          return;
        }

        if (typeof result !== "string") {
          callback(new Error("LokiPartitioningAdapter received an unexpected response from inner adapter loadDatabase()"));
        }

        // I will want to use loki destructuring helper methods so i will inflate into typed instance
        var db = JSON.parse(result);
        self.dbref.loadJSONObject(db);
        db = null;

        var clen = self.dbref.collections.length;

        if (self.dbref.collections.length === 0) {
          callback(self.dbref);
          return;
        }

        self.pageIterator = {
          collection: 0,
          pageIndex: 0
        };

        self.loadNextPartition(0, function () {
          callback(self.dbref);
        });
      });
    };

    /**
     * Used to sequentially load each collection partition, one at a time.
     *
     * @param {int} partition - ordinal collection position to load next
     * @param {function} callback - adapter callback to return load result to caller
     */
    LokiPartitioningAdapter.prototype.loadNextPartition = function (partition, callback) {
      var keyname = this.dbname + "." + partition;
      var self = this;

      if (this.options.paging === true) {
        this.pageIterator.pageIndex = 0;
        this.loadNextPage(callback);
        return;
      }

      this.adapter.loadDatabase(keyname, function (result) {
        var data = self.dbref.deserializeCollection(result, { delimited: true, collectionIndex: partition });
        self.dbref.collections[partition].data = data;

        if (++partition < self.dbref.collections.length) {
          self.loadNextPartition(partition, callback);
        }
        else {
          callback();
        }
      });
    };

    /**
     * Used to sequentially load the next page of collection partition, one at a time.
     *
     * @param {function} callback - adapter callback to return load result to caller
     */
    LokiPartitioningAdapter.prototype.loadNextPage = function (callback) {
      // calculate name for next saved page in sequence
      var keyname = this.dbname + "." + this.pageIterator.collection + "." + this.pageIterator.pageIndex;
      var self = this;

      // load whatever page is next in sequence
      this.adapter.loadDatabase(keyname, function (result) {
        var data = result.split(self.options.delimiter);
        result = ""; // free up memory now that we have split it into array
        var dlen = data.length;
        var idx;

        // detect if last page by presence of final empty string element and remove it if so
        var isLastPage = (data[dlen - 1] === "");
        if (isLastPage) {
          data.pop();
          dlen = data.length;
          // empty collections are just a delimiter meaning two blank items
          if (data[dlen - 1] === "" && dlen === 1) {
            data.pop();
            dlen = data.length;
          }
        }

        // convert stringified array elements to object instances and push to collection data
        for (idx = 0; idx < dlen; idx++) {
          self.dbref.collections[self.pageIterator.collection].data.push(JSON.parse(data[idx]));
          data[idx] = null;
        }
        data = [];

        // if last page, we are done with this partition
        if (isLastPage) {

          // if there are more partitions, kick off next partition load
          if (++self.pageIterator.collection < self.dbref.collections.length) {
            self.loadNextPartition(self.pageIterator.collection, callback);
          }
          else {
            callback();
          }
        }
        else {
          self.pageIterator.pageIndex++;
          self.loadNextPage(callback);
        }
      });
    };

    /**
     * Saves a database by partioning into separate key/value saves.
     * (Loki 'reference mode' persistence adapter interface function)
     *
     * @param {string} dbname - name of the database (filename/keyname)
     * @param {object} dbref - reference to database which we will partition and save.
     * @param {function} callback - adapter callback to return load result to caller
     *
     * @memberof LokiPartitioningAdapter
     */
    LokiPartitioningAdapter.prototype.exportDatabase = function (dbname, dbref, callback) {
      var self = this;
      var idx, clen = dbref.collections.length;

      this.dbref = dbref;
      this.dbname = dbname;

      // queue up dirty partitions to be saved
      this.dirtyPartitions = [-1];
      for (idx = 0; idx < clen; idx++) {
        if (dbref.collections[idx].dirty) {
          this.dirtyPartitions.push(idx);
        }
      }

      this.saveNextPartition(function (err) {
        callback(err);
      });
    };

    /**
     * Helper method used internally to save each dirty collection, one at a time.
     *
     * @param {function} callback - adapter callback to return load result to caller
     */
    LokiPartitioningAdapter.prototype.saveNextPartition = function (callback) {
      var self = this;
      var partition = this.dirtyPartitions.shift();
      var keyname = this.dbname + ((partition === -1) ? "" : ("." + partition));

      // if we are doing paging and this is collection partition
      if (this.options.paging && partition !== -1) {
        this.pageIterator = {
          collection: partition,
          docIndex: 0,
          pageIndex: 0
        };

        // since saveNextPage recursively calls itself until done, our callback means this whole paged partition is finished
        this.saveNextPage(function (err) {
          if (self.dirtyPartitions.length === 0) {
            callback(err);
          }
          else {
            self.saveNextPartition(callback);
          }
        });
        return;
      }

      // otherwise this is 'non-paged' partioning...
      var result = this.dbref.serializeDestructured({
        partitioned: true,
        delimited: true,
        partition: partition
      });

      this.adapter.saveDatabase(keyname, result, function (err) {
        if (err) {
          callback(err);
          return;
        }

        if (self.dirtyPartitions.length === 0) {
          callback(null);
        }
        else {
          self.saveNextPartition(callback);
        }
      });
    };

    /**
     * Helper method used internally to generate and save the next page of the current (dirty) partition.
     *
     * @param {function} callback - adapter callback to return load result to caller
     */
    LokiPartitioningAdapter.prototype.saveNextPage = function (callback) {
      var self = this;
      var coll = this.dbref.collections[this.pageIterator.collection];
      var keyname = this.dbname + "." + this.pageIterator.collection + "." + this.pageIterator.pageIndex;
      var pageLen = 0,
        cdlen = coll.data.length,
        delimlen = this.options.delimiter.length;
      var serializedObject = "",
        pageBuilder = "";
      var doneWithPartition = false,
        doneWithPage = false;

      var pageSaveCallback = function (err) {
        pageBuilder = "";

        if (err) {
          callback(err);
        }

        // update meta properties then continue process by invoking callback
        if (doneWithPartition) {
          callback(null);
        }
        else {
          self.pageIterator.pageIndex++;
          self.saveNextPage(callback);
        }
      };

      if (coll.data.length === 0) {
        doneWithPartition = true;
      }

      while (true) {
        if (!doneWithPartition) {
          // serialize object
          serializedObject = JSON.stringify(coll.data[this.pageIterator.docIndex]);
          pageBuilder += serializedObject;
          pageLen += serializedObject.length;

          // if no more documents in collection to add, we are done with partition
          if (++this.pageIterator.docIndex >= cdlen) doneWithPartition = true;
        }
        // if our current page is bigger than defined pageSize, we are done with page
        if (pageLen >= this.options.pageSize) doneWithPage = true;

        // if not done with current page, need delimiter before next item
        // if done with partition we also want a delmiter to indicate 'end of pages' final empty row
        if (!doneWithPage || doneWithPartition) {
          pageBuilder += this.options.delimiter;
          pageLen += delimlen;
        }

        // if we are done with page save it and pass off to next recursive call or callback
        if (doneWithPartition || doneWithPage) {
          this.adapter.saveDatabase(keyname, pageBuilder, pageSaveCallback);
          return;
        }
      }
    };

    /**
     * A loki persistence adapter which persists using node fs module
     * @constructor LokiFsAdapter
     */
    function LokiFsAdapter() {
      try {
        this.fs = require('fs');
      } catch (e) {
        this.fs = null;
      }
    }

    /**
     * loadDatabase() - Load data from file, will throw an error if the file does not exist
     * @param {string} dbname - the filename of the database to load
     * @param {function} callback - the callback to handle the result
     * @memberof LokiFsAdapter
     */
    LokiFsAdapter.prototype.loadDatabase = function loadDatabase(dbname, callback) {
      var self = this;

      this.fs.stat(dbname, function (err, stats) {
        if (!err && stats.isFile()) {
          self.fs.readFile(dbname, {
            encoding: 'utf8'
          }, function readFileCallback(err, data) {
            if (err) {
              callback(new Error(err));
            } else {
              callback(data);
            }
          });
        }
        else {
          callback(null);
        }
      });
    };

    /**
     * saveDatabase() - save data to file, will throw an error if the file can't be saved
     * might want to expand this to avoid dataloss on partial save
     * @param {string} dbname - the filename of the database to load
     * @param {function} callback - the callback to handle the result
     * @memberof LokiFsAdapter
     */
    LokiFsAdapter.prototype.saveDatabase = function saveDatabase(dbname, dbstring, callback) {
      var self = this;
      var tmpdbname = dbname + '~';
      this.fs.writeFile(tmpdbname, dbstring, function writeFileCallback(err) {
        if (err) {
          callback(new Error(err));
        } else {
          self.fs.rename(tmpdbname, dbname, callback);
        }
      });
    };

    /**
     * deleteDatabase() - delete the database file, will throw an error if the
     * file can't be deleted
     * @param {string} dbname - the filename of the database to delete
     * @param {function} callback - the callback to handle the result
     * @memberof LokiFsAdapter
     */
    LokiFsAdapter.prototype.deleteDatabase = function deleteDatabase(dbname, callback) {
      this.fs.unlink(dbname, function deleteDatabaseCallback(err) {
        if (err) {
          callback(new Error(err));
        } else {
          callback();
        }
      });
    };


    /**
     * A loki persistence adapter which persists to web browser's local storage object
     * @constructor LokiLocalStorageAdapter
     */
    function LokiLocalStorageAdapter() { }

    /**
     * loadDatabase() - Load data from localstorage
     * @param {string} dbname - the name of the database to load
     * @param {function} callback - the callback to handle the result
     * @memberof LokiLocalStorageAdapter
     */
    LokiLocalStorageAdapter.prototype.loadDatabase = function loadDatabase(dbname, callback) {
      if (localStorageAvailable()) {
        callback(localStorage.getItem(dbname));
      } else {
        callback(new Error('localStorage is not available'));
      }
    };

    /**
     * saveDatabase() - save data to localstorage, will throw an error if the file can't be saved
     * might want to expand this to avoid dataloss on partial save
     * @param {string} dbname - the filename of the database to load
     * @param {function} callback - the callback to handle the result
     * @memberof LokiLocalStorageAdapter
     */
    LokiLocalStorageAdapter.prototype.saveDatabase = function saveDatabase(dbname, dbstring, callback) {
      if (localStorageAvailable()) {
        localStorage.setItem(dbname, dbstring);
        callback(null);
      } else {
        callback(new Error('localStorage is not available'));
      }
    };

    /**
     * deleteDatabase() - delete the database from localstorage, will throw an error if it
     * can't be deleted
     * @param {string} dbname - the filename of the database to delete
     * @param {function} callback - the callback to handle the result
     * @memberof LokiLocalStorageAdapter
     */
    LokiLocalStorageAdapter.prototype.deleteDatabase = function deleteDatabase(dbname, callback) {
      if (localStorageAvailable()) {
        localStorage.removeItem(dbname);
        callback(null);
      } else {
        callback(new Error('localStorage is not available'));
      }
    };

    /**
     * Wait for throttledSaves to complete and invoke your callback when drained or duration is met.
     *
     * @param {function} callback - callback to fire when save queue is drained, it is passed a sucess parameter value
     * @param {object=} options - configuration options
     * @param {boolean} options.recursiveWait - (default: true) if after queue is drained, another save was kicked off, wait for it
     * @param {bool} options.recursiveWaitLimit - (default: false) limit our recursive waiting to a duration
     * @param {int} options.recursiveWaitLimitDelay - (default: 2000) cutoff in ms to stop recursively re-draining
     * @memberof Loki
     */
    Loki.prototype.throttledSaveDrain = function (callback, options) {
      var self = this;
      var now = (new Date()).getTime();

      if (!this.throttledSaves) {
        callback(true);
      }

      options = options || {};
      if (!options.hasOwnProperty('recursiveWait')) {
        options.recursiveWait = true;
      }
      if (!options.hasOwnProperty('recursiveWaitLimit')) {
        options.recursiveWaitLimit = false;
      }
      if (!options.hasOwnProperty('recursiveWaitLimitDuration')) {
        options.recursiveWaitLimitDuration = 2000;
      }
      if (!options.hasOwnProperty('started')) {
        options.started = (new Date()).getTime();
      }

      // if save is pending
      if (this.throttledSaves && this.throttledSavePending) {
        // if we want to wait until we are in a state where there are no pending saves at all
        if (options.recursiveWait) {
          // queue the following meta callback for when it completes
          this.throttledCallbacks.push(function () {
            // if there is now another save pending...
            if (self.throttledSavePending) {
              // if we wish to wait only so long and we have exceeded limit of our waiting, callback with false success value
              if (options.recursiveWaitLimit && (now - options.started > options.recursiveWaitLimitDuration)) {
                callback(false);
                return;
              }
              // it must be ok to wait on next queue drain
              self.throttledSaveDrain(callback, options);
              return;
            }
            // no pending saves so callback with true success
            else {
              callback(true);
              return;
            }
          });
        }
        // just notify when current queue is depleted
        else {
          this.throttledCallbacks.push(callback);
          return;
        }
      }
      // no save pending, just callback
      else {
        callback(true);
      }
    };

    /**
     * Internal load logic, decoupled from throttling/contention logic
     *
     * @param {object} options - not currently used (remove or allow overrides?)
     * @param {function=} callback - (Optional) user supplied async callback / error handler
     */
    Loki.prototype.loadDatabaseInternal = function (options, callback) {
      var cFun = callback || function (err, data) {
        if (err) {
          throw err;
        }
      },
        self = this;

      // the persistenceAdapter should be present if all is ok, but check to be sure.
      if (this.persistenceAdapter !== null) {

        this.persistenceAdapter.loadDatabase(this.filename, function loadDatabaseCallback(dbString) {
          if (typeof (dbString) === 'string') {
            var parseSuccess = false;
            try {
              self.loadJSON(dbString, options || {});
              parseSuccess = true;
            } catch (err) {
              cFun(err);
            }
            if (parseSuccess) {
              cFun(null);
              self.emit('loaded', 'database ' + self.filename + ' loaded');
            }
          } else {
            // falsy result means new database
            if (!dbString) {
              cFun(null);
              self.emit('loaded', 'empty database ' + self.filename + ' loaded');
              return;
            }

            // instanceof error means load faulted
            if (dbString instanceof Error) {
              cFun(dbString);
              return;
            }

            // if adapter has returned an js object (other than null or error) attempt to load from JSON object
            if (typeof (dbString) === "object") {
              self.loadJSONObject(dbString, options || {});
              cFun(null); // return null on success
              self.emit('loaded', 'database ' + self.filename + ' loaded');
              return;
            }

            cFun("unexpected adapter response : " + dbString);
          }
        });

      } else {
        cFun(new Error('persistenceAdapter not configured'));
      }
    };

    /**
     * Handles manually loading from file system, local storage, or adapter (such as indexeddb)
     *    This method utilizes loki configuration options (if provided) to determine which
     *    persistence method to use, or environment detection (if configuration was not provided).
     *    To avoid contention with any throttledSaves, we will drain the save queue first.
     *
     * If you are configured with autosave, you do not need to call this method yourself.
     *
     * @param {object} options - if throttling saves and loads, this controls how we drain save queue before loading
     * @param {boolean} options.recursiveWait - (default: true) wait recursively until no saves are queued
     * @param {bool} options.recursiveWaitLimit - (default: false) limit our recursive waiting to a duration
     * @param {int} options.recursiveWaitLimitDelay - (default: 2000) cutoff in ms to stop recursively re-draining
     * @param {function=} callback - (Optional) user supplied async callback / error handler
     * @memberof Loki
     * @example
     * db.loadDatabase({}, function(err) {
     *   if (err) {
     *     console.log("error : " + err);
     *   }
     *   else {
     *     console.log("database loaded.");
     *   }
     * });
     */
    Loki.prototype.loadDatabase = function (options, callback) {
      var self = this;

      // if throttling disabled, just call internal
      if (!this.throttledSaves) {
        this.loadDatabaseInternal(options, callback);
        return;
      }

      // try to drain any pending saves in the queue to lock it for loading
      this.throttledSaveDrain(function (success) {
        if (success) {
          // pause/throttle saving until loading is done
          self.throttledSavePending = true;

          self.loadDatabaseInternal(options, function (err) {
            // now that we are finished loading, if no saves were throttled, disable flag
            if (self.throttledCallbacks.length === 0) {
              self.throttledSavePending = false;
            }
            // if saves requests came in while loading, kick off new save to kick off resume saves
            else {
              self.saveDatabase();
            }

            if (typeof callback === 'function') {
              callback(err);
            }
          });
          return;
        }
        else {
          if (typeof callback === 'function') {
            callback(new Error("Unable to pause save throttling long enough to read database"));
          }
        }
      }, options);
    };

    /**
     * Internal save logic, decoupled from save throttling logic
     */
    Loki.prototype.saveDatabaseInternal = function (callback) {
      var cFun = callback || function (err) {
        if (err) {
          throw err;
        }
        return;
      };
      var self = this;

      // the persistenceAdapter should be present if all is ok, but check to be sure.
      if (!this.persistenceAdapter) {
        cFun(new Error('persistenceAdapter not configured'));
        return;
      }

      // run incremental, reference, or normal mode adapters, depending on what's available
      if (this.persistenceAdapter.mode === "incremental") {
        var cachedDirty;
        // ignore autosave until we copy loki (only then we can clear dirty flags,
        // but if we don't do it now, autosave will be triggered a lot unnecessarily)
        this.ignoreAutosave = true;
        this.persistenceAdapter.saveDatabase(
          this.filename,
          function getLokiCopy() {
            self.ignoreAutosave = false;
            if (cachedDirty) {
              cFun(new Error('adapter error - getLokiCopy called more than once'));
              return;
            }
            var lokiCopy = self.copy({ removeNonSerializable: true });

            // remember and clear dirty ids -- we must do it before the save so that if
            // and update occurs between here and callback, it will get saved later
            cachedDirty = self.collections.map(function (collection) {
              return [collection.dirty, collection.dirtyIds];
            });
            self.collections.forEach(function (col) {
              col.dirty = false;
              col.dirtyIds = [];
            });
            return lokiCopy;
          },
          function exportDatabaseCallback(err) {
            self.ignoreAutosave = false;
            if (err && cachedDirty) {
              // roll back dirty IDs to be saved later
              self.collections.forEach(function (col, i) {
                var cached = cachedDirty[i];
                col.dirty = col.dirty || cached[0];
                col.dirtyIds = col.dirtyIds.concat(cached[1]);
              });
            }
            cFun(err);
          });
      } else if (this.persistenceAdapter.mode === "reference" && typeof this.persistenceAdapter.exportDatabase === "function") {
        // TODO: dirty should be cleared here
        // filename may seem redundant but loadDatabase will need to expect this same filename
        this.persistenceAdapter.exportDatabase(this.filename, this.copy({ removeNonSerializable: true }), function exportDatabaseCallback(err) {
          self.autosaveClearFlags();
          cFun(err);
        });
      }
      // otherwise just pass the serialized database to adapter
      else {
        // persistenceAdapter might be asynchronous, so we must clear `dirty` immediately
        // or autosave won't work if an update occurs between here and the callback
        // TODO: This should be stored and rolled back in case of DB save failure
        this.autosaveClearFlags();
        this.persistenceAdapter.saveDatabase(this.filename, this.serialize(), function saveDatabasecallback(err) {
          cFun(err);
        });
      }
    };

    /**
     * Handles manually saving to file system, local storage, or adapter (such as indexeddb)
     *    This method utilizes loki configuration options (if provided) to determine which
     *    persistence method to use, or environment detection (if configuration was not provided).
     *
     * If you are configured with autosave, you do not need to call this method yourself.
     *
     * @param {function=} callback - (Optional) user supplied async callback / error handler
     * @memberof Loki
     * @example
     * db.saveDatabase(function(err) {
     *   if (err) {
     *     console.log("error : " + err);
     *   }
     *   else {
     *     console.log("database saved.");
     *   }
     * });
     */
    Loki.prototype.saveDatabase = function (callback) {
      if (!this.throttledSaves) {
        this.saveDatabaseInternal(callback);
        return;
      }

      if (this.throttledSavePending) {
        this.throttledCallbacks.push(callback);
        return;
      }

      var localCallbacks = this.throttledCallbacks;
      this.throttledCallbacks = [];
      localCallbacks.unshift(callback);
      this.throttledSavePending = true;

      var self = this;
      this.saveDatabaseInternal(function (err) {
        self.throttledSavePending = false;
        localCallbacks.forEach(function (pcb) {
          if (typeof pcb === 'function') {
            // Queue the callbacks so we first finish this method execution
            setTimeout(function () {
              pcb(err);
            }, 1);
          }
        });

        // since this is called async, future requests may have come in, if so.. kick off next save
        if (self.throttledCallbacks.length > 0) {
          self.saveDatabase();
        }
      });
    };

    // alias
    Loki.prototype.save = Loki.prototype.saveDatabase;

    /**
     * Handles deleting a database from file system, local
     *    storage, or adapter (indexeddb)
     *    This method utilizes loki configuration options (if provided) to determine which
     *    persistence method to use, or environment detection (if configuration was not provided).
     *
     * @param {function=} callback - (Optional) user supplied async callback / error handler
     * @memberof Loki
     */
    Loki.prototype.deleteDatabase = function (options, callback) {
      var cFun = callback || function (err, data) {
        if (err) {
          throw err;
        }
      };

      // we aren't even using options, so we will support syntax where
      // callback is passed as first and only argument
      if (typeof options === 'function' && !callback) {
        cFun = options;
      }

      // the persistenceAdapter should be present if all is ok, but check to be sure.
      if (this.persistenceAdapter !== null) {
        this.persistenceAdapter.deleteDatabase(this.filename, function deleteDatabaseCallback(err) {
          cFun(err);
        });
      } else {
        cFun(new Error('persistenceAdapter not configured'));
      }
    };

    /**
     * autosaveDirty - check whether any collections are 'dirty' meaning we need to save (entire) database
     *
     * @returns {boolean} - true if database has changed since last autosave, false if not.
     */
    Loki.prototype.autosaveDirty = function () {
      for (var idx = 0; idx < this.collections.length; idx++) {
        if (this.collections[idx].dirty) {
          return true;
        }
      }

      return false;
    };

    /**
     * autosaveClearFlags - resets dirty flags on all collections.
     *    Called from saveDatabase() after db is saved.
     *
     */
    Loki.prototype.autosaveClearFlags = function () {
      for (var idx = 0; idx < this.collections.length; idx++) {
        this.collections[idx].dirty = false;
      }
    };

    /**
     * autosaveEnable - begin a javascript interval to periodically save the database.
     *
     * @param {object} options - not currently used (remove or allow overrides?)
     * @param {function=} callback - (Optional) user supplied async callback
     */
    Loki.prototype.autosaveEnable = function (options, callback) {
      this.autosave = true;

      var delay = 5000,
        self = this;

      if (typeof (this.autosaveInterval) !== 'undefined' && this.autosaveInterval !== null) {
        delay = this.autosaveInterval;
      }

      this.autosaveHandle = setInterval(function autosaveHandleInterval() {
        // use of dirty flag will need to be hierarchical since mods are done at collection level with no visibility of 'db'
        // so next step will be to implement collection level dirty flags set on insert/update/remove
        // along with loki level isdirty() function which iterates all collections to see if any are dirty

        if (self.autosaveDirty() && !self.ignoreAutosave) {
          self.saveDatabase(callback);
        }
      }, delay);
    };

    /**
     * autosaveDisable - stop the autosave interval timer.
     *
     */
    Loki.prototype.autosaveDisable = function () {
      if (typeof (this.autosaveHandle) !== 'undefined' && this.autosaveHandle !== null) {
        clearInterval(this.autosaveHandle);
        this.autosaveHandle = null;
      }
    };


    /**
     * Resultset class allowing chainable queries.  Intended to be instanced internally.
     *    Collection.find(), Collection.where(), and Collection.chain() instantiate this.
     *
     * @example
     *    mycollection.chain()
     *      .find({ 'doors' : 4 })
     *      .where(function(obj) { return obj.name === 'Toyota' })
     *      .data();
     *
     * @constructor Resultset
     * @param {Collection} collection - The collection which this Resultset will query against.
     */
    function Resultset(collection, options) {
      options = options || {};

      // retain reference to collection we are querying against
      this.collection = collection;
      this.filteredrows = [];
      this.filterInitialized = false;

      return this;
    }

    /**
     * reset() - Reset the resultset to its initial state.
     *
     * @returns {Resultset} Reference to this resultset, for future chain operations.
     */
    Resultset.prototype.reset = function () {
      if (this.filteredrows.length > 0) {
        this.filteredrows = [];
      }
      this.filterInitialized = false;
      return this;
    };

    /**
     * toJSON() - Override of toJSON to avoid circular references
     *
     */
    Resultset.prototype.toJSON = function () {
      var copy = this.copy();
      copy.collection = null;
      return copy;
    };

    /**
     * Allows you to limit the number of documents passed to next chain operation.
     *    A resultset copy() is made to avoid altering original resultset.
     *
     * @param {int} qty - The number of documents to return.
     * @returns {Resultset} Returns a copy of the resultset, limited by qty, for subsequent chain ops.
     * @memberof Resultset
     * // find the two oldest users
     * var result = users.chain().simplesort("age", true).limit(2).data();
     */
    Resultset.prototype.limit = function (qty) {
      // if this has no filters applied, we need to populate filteredrows first
      if (!this.filterInitialized && this.filteredrows.length === 0) {
        this.filteredrows = this.collection.prepareFullDocIndex();
      }

      var rscopy = new Resultset(this.collection);
      rscopy.filteredrows = this.filteredrows.slice(0, qty);
      rscopy.filterInitialized = true;
      return rscopy;
    };

    /**
     * Used for skipping 'pos' number of documents in the resultset.
     *
     * @param {int} pos - Number of documents to skip; all preceding documents are filtered out.
     * @returns {Resultset} Returns a copy of the resultset, containing docs starting at 'pos' for subsequent chain ops.
     * @memberof Resultset
     * // find everyone but the two oldest users
     * var result = users.chain().simplesort("age", true).offset(2).data();
     */
    Resultset.prototype.offset = function (pos) {
      // if this has no filters applied, we need to populate filteredrows first
      if (!this.filterInitialized && this.filteredrows.length === 0) {
        this.filteredrows = this.collection.prepareFullDocIndex();
      }

      var rscopy = new Resultset(this.collection);
      rscopy.filteredrows = this.filteredrows.slice(pos);
      rscopy.filterInitialized = true;
      return rscopy;
    };

    /**
     * copy() - To support reuse of resultset in branched query situations.
     *
     * @returns {Resultset} Returns a copy of the resultset (set) but the underlying document references will be the same.
     * @memberof Resultset
     */
    Resultset.prototype.copy = function () {
      var result = new Resultset(this.collection);

      if (this.filteredrows.length > 0) {
        result.filteredrows = this.filteredrows.slice();
      }
      result.filterInitialized = this.filterInitialized;

      return result;
    };

    /**
     * Alias of copy()
     * @memberof Resultset
     */
    Resultset.prototype.branch = Resultset.prototype.copy;

    /**
     * transform() - executes a named collection transform or raw array of transform steps against the resultset.
     *
     * @param transform {(string|array)} - name of collection transform or raw transform array
     * @param parameters {object=} - (Optional) object property hash of parameters, if the transform requires them.
     * @returns {Resultset} either (this) resultset or a clone of of this resultset (depending on steps)
     * @memberof Resultset
     * @example
     * users.addTransform('CountryFilter', [
     *   {
     *     type: 'find',
     *     value: {
     *       'country': { $eq: '[%lktxp]Country' }
     *     }
     *   },
     *   {
     *     type: 'simplesort',
     *     property: 'age',
     *     options: { desc: false}
     *   }
     * ]);
     * var results = users.chain().transform("CountryFilter", { Country: 'fr' }).data();
     */
    Resultset.prototype.transform = function (transform, parameters) {
      var idx,
        step,
        rs = this;

      // if transform is name, then do lookup first
      if (typeof transform === 'string') {
        if (this.collection.transforms.hasOwnProperty(transform)) {
          transform = this.collection.transforms[transform];
        }
      }

      // either they passed in raw transform array or we looked it up, so process
      if (typeof transform !== 'object' || !Array.isArray(transform)) {
        throw new Error("Invalid transform");
      }

      if (typeof parameters !== 'undefined') {
        transform = Utils.resolveTransformParams(transform, parameters);
      }

      for (idx = 0; idx < transform.length; idx++) {
        step = transform[idx];

        switch (step.type) {
          case "find":
            rs.find(step.value);
            break;
          case "where":
            rs.where(step.value);
            break;
          case "simplesort":
            rs.simplesort(step.property, step.desc || step.options);
            break;
          case "compoundsort":
            rs.compoundsort(step.value);
            break;
          case "sort":
            rs.sort(step.value);
            break;
          case "limit":
            rs = rs.limit(step.value);
            break; // limit makes copy so update reference
          case "offset":
            rs = rs.offset(step.value);
            break; // offset makes copy so update reference
          case "map":
            rs = rs.map(step.value, step.dataOptions);
            break;
          case "eqJoin":
            rs = rs.eqJoin(step.joinData, step.leftJoinKey, step.rightJoinKey, step.mapFun, step.dataOptions);
            break;
          // following cases break chain by returning array data so make any of these last in transform steps
          case "mapReduce":
            rs = rs.mapReduce(step.mapFunction, step.reduceFunction);
            break;
          // following cases update documents in current filtered resultset (use carefully)
          case "update":
            rs.update(step.value);
            break;
          case "remove":
            rs.remove();
            break;
          default:
            break;
        }
      }

      return rs;
    };

    /**
     * User supplied compare function is provided two documents to compare. (chainable)
     * @example
     *    rslt.sort(function(obj1, obj2) {
     *      if (obj1.name === obj2.name) return 0;
     *      if (obj1.name > obj2.name) return 1;
     *      if (obj1.name < obj2.name) return -1;
     *    });
     *
     * @param {function} comparefun - A javascript compare function used for sorting.
     * @returns {Resultset} Reference to this resultset, sorted, for future chain operations.
     * @memberof Resultset
     */
    Resultset.prototype.sort = function (comparefun) {
      // if this has no filters applied, just we need to populate filteredrows first
      if (!this.filterInitialized && this.filteredrows.length === 0) {
        this.filteredrows = this.collection.prepareFullDocIndex();
      }

      var wrappedComparer =
        (function (userComparer, data) {
          return function (a, b) {
            return userComparer(data[a], data[b]);
          };
        })(comparefun, this.collection.data);

      this.filteredrows.sort(wrappedComparer);

      return this;
    };

    /**
     * Simpler, loose evaluation for user to sort based on a property name. (chainable).
     *    Sorting based on the same lt/gt helper functions used for binary indices.
     *
     * @param {string} propname - name of property to sort by.
     * @param {object|bool=} options - boolean to specify if isdescending, or options object
     * @param {boolean} [options.desc=false] - whether to sort descending
     * @param {boolean} [options.disableIndexIntersect=false] - whether we should explicity not use array intersection.
     * @param {boolean} [options.forceIndexIntersect=false] - force array intersection (if binary index exists).
     * @param {boolean} [options.useJavascriptSorting=false] - whether results are sorted via basic javascript sort.
     * @returns {Resultset} Reference to this resultset, sorted, for future chain operations.
     * @memberof Resultset
     * @example
     * var results = users.chain().simplesort('age').data();
     */
    Resultset.prototype.simplesort = function (propname, options) {
      var eff,
        targetEff = 10,
        dc = this.collection.data.length,
        frl = this.filteredrows.length,
        hasBinaryIndex = this.collection.binaryIndices.hasOwnProperty(propname);

      if (typeof (options) === 'undefined' || options === false) {
        options = { desc: false };
      }
      if (options === true) {
        options = { desc: true };
      }

      // if nothing in filtered rows array...
      if (frl === 0) {
        // if the filter is initialized to be empty resultset, do nothing
        if (this.filterInitialized) {
          return this;
        }

        // otherwise no filters applied implies all documents, so we need to populate filteredrows first

        // if we have a binary index, we can just use that instead of sorting (again)
        if (this.collection.binaryIndices.hasOwnProperty(propname)) {
          // make sure index is up-to-date
          this.collection.ensureIndex(propname);
          // copy index values into filteredrows
          this.filteredrows = this.collection.binaryIndices[propname].values.slice(0);

          if (options.desc) {
            this.filteredrows.reverse();
          }

          // we are done, return this (resultset) for further chain ops
          return this;
        }
        // otherwise initialize array for sort below
        else {
          // build full document index (to be sorted subsequently)
          this.filteredrows = this.collection.prepareFullDocIndex();
        }
      }
      // otherwise we had results to begin with, see if we qualify for index intercept optimization
      else {

        // If already filtered, but we want to leverage binary index on sort.
        // This will use custom array intection algorithm.
        if (!options.disableIndexIntersect && hasBinaryIndex) {

          // calculate filter efficiency
          eff = dc / frl;

          // when javascript sort fallback is enabled, you generally need more than ~17% of total docs in resultset
          // before array intersect is determined to be the faster algorithm, otherwise leave at 10% for loki sort.
          if (options.useJavascriptSorting) {
            targetEff = 6;
          }

          // anything more than ratio of 10:1 (total documents/current results) should use old sort code path
          // So we will only use array intersection if you have more than 10% of total docs in your current resultset.
          if (eff <= targetEff || options.forceIndexIntersect) {
            var idx, fr = this.filteredrows;
            var io = {};
            // set up hashobject for simple 'inclusion test' with existing (filtered) results
            for (idx = 0; idx < frl; idx++) {
              io[fr[idx]] = true;
            }
            // grab full sorted binary index array
            var pv = this.collection.binaryIndices[propname].values;

            // filter by existing results
            this.filteredrows = pv.filter(function (n) { return io[n]; });

            if (options.desc) {
              this.filteredrows.reverse();
            }

            return this;
          }
        }
      }

      // at this point, we will not be able to leverage binary index so we will have to do an array sort

      // if we have opted to use simplified javascript comparison function...
      if (options.useJavascriptSorting) {
        return this.sort(function (obj1, obj2) {
          if (obj1[propname] === obj2[propname]) return 0;
          if (obj1[propname] > obj2[propname]) return 1;
          if (obj1[propname] < obj2[propname]) return -1;
        });
      }

      // otherwise use loki sort which will return same results if column is indexed or not
      var wrappedComparer =
        (function (prop, desc, data) {
          var val1, val2, arr;
          return function (a, b) {
            if (~prop.indexOf('.')) {
              arr = prop.split('.');
              val1 = Utils.getIn(data[a], arr, true);
              val2 = Utils.getIn(data[b], arr, true);
            } else {
              val1 = data[a][prop];
              val2 = data[b][prop];
            }
            return sortHelper(val1, val2, desc);
          };
        })(propname, options.desc, this.collection.data);

      this.filteredrows.sort(wrappedComparer);

      return this;
    };

    /**
     * Allows sorting a resultset based on multiple columns.
     * @example
     * // to sort by age and then name (both ascending)
     * rs.compoundsort(['age', 'name']);
     * // to sort by age (ascending) and then by name (descending)
     * rs.compoundsort(['age', ['name', true]]);
     *
     * @param {array} properties - array of property names or subarray of [propertyname, isdesc] used evaluate sort order
     * @returns {Resultset} Reference to this resultset, sorted, for future chain operations.
     * @memberof Resultset
     */
    Resultset.prototype.compoundsort = function (properties) {
      if (properties.length === 0) {
        throw new Error("Invalid call to compoundsort, need at least one property");
      }

      var prop;
      if (properties.length === 1) {
        prop = properties[0];
        if (Array.isArray(prop)) {
          return this.simplesort(prop[0], prop[1]);
        }
        return this.simplesort(prop, false);
      }

      // unify the structure of 'properties' to avoid checking it repeatedly while sorting
      for (var i = 0, len = properties.length; i < len; i += 1) {
        prop = properties[i];
        if (!Array.isArray(prop)) {
          properties[i] = [prop, false];
        }
      }

      // if this has no filters applied, just we need to populate filteredrows first
      if (!this.filterInitialized && this.filteredrows.length === 0) {
        this.filteredrows = this.collection.prepareFullDocIndex();
      }

      var wrappedComparer =
        (function (props, data) {
          return function (a, b) {
            return compoundeval(props, data[a], data[b]);
          };
        })(properties, this.collection.data);

      this.filteredrows.sort(wrappedComparer);

      return this;
    };

    /**
     * findOr() - oversee the operation of OR'ed query expressions.
     *    OR'ed expression evaluation runs each expression individually against the full collection,
     *    and finally does a set OR on each expression's results.
     *    Each evaluation can utilize a binary index to prevent multiple linear array scans.
     *
     * @param {array} expressionArray - array of expressions
     * @returns {Resultset} this resultset for further chain ops.
     */
    Resultset.prototype.findOr = function (expressionArray) {
      var fr = null,
        fri = 0,
        frlen = 0,
        docset = [],
        idxset = [],
        idx = 0,
        origCount = this.count();

      // If filter is already initialized, then we query against only those items already in filter.
      // This means no index utilization for fields, so hopefully its filtered to a smallish filteredrows.
      for (var ei = 0, elen = expressionArray.length; ei < elen; ei++) {
        // we need to branch existing query to run each filter separately and combine results
        fr = this.branch().find(expressionArray[ei]).filteredrows;
        frlen = fr.length;

        // add any document 'hits'
        for (fri = 0; fri < frlen; fri++) {
          idx = fr[fri];
          if (idxset[idx] === undefined) {
            idxset[idx] = true;
            docset.push(idx);
          }
        }
      }

      this.filteredrows = docset;
      this.filterInitialized = true;

      return this;
    };
    Resultset.prototype.$or = Resultset.prototype.findOr;

    // precompile recursively
    function precompileQuery(operator, value) {
      // for regex ops, precompile
      if (operator === '$regex') {
        if (Array.isArray(value)) {
          value = new RegExp(value[0], value[1]);
        } else if (!(value instanceof RegExp)) {
          value = new RegExp(value);
        }
      }
      else if (typeof value === 'object') {
        for (var key in value) {
          if (key === '$regex' || typeof value[key] === 'object') {
            value[key] = precompileQuery(key, value[key]);
          }
        }
      }

      return value;
    }

    /**
     * findAnd() - oversee the operation of AND'ed query expressions.
     *    AND'ed expression evaluation runs each expression progressively against the full collection,
     *    internally utilizing existing chained resultset functionality.
     *    Only the first filter can utilize a binary index.
     *
     * @param {array} expressionArray - array of expressions
     * @returns {Resultset} this resultset for further chain ops.
     */
    Resultset.prototype.findAnd = function (expressionArray) {
      // we have already implementing method chaining in this (our Resultset class)
      // so lets just progressively apply user supplied and filters
      for (var i = 0, len = expressionArray.length; i < len; i++) {
        if (this.count() === 0) {
          return this;
        }
        this.find(expressionArray[i]);
      }
      return this;
    };
    Resultset.prototype.$and = Resultset.prototype.findAnd;

    /**
     * Used for querying via a mongo-style query object.
     *
     * @param {object} query - A mongo-style query object used for filtering current results.
     * @param {boolean=} firstOnly - (Optional) Used by collection.findOne()
     * @returns {Resultset} this resultset for further chain ops.
     * @memberof Resultset
     * @example
     * var over30 = users.chain().find({ age: { $gte: 30 } }).data();
     */
    Resultset.prototype.find = function (query, firstOnly) {
      if (this.collection.data.length === 0) {
        this.filteredrows = [];
        this.filterInitialized = true;
        return this;
      }

      var queryObject = query || 'getAll',
        p,
        property,
        queryObjectOp,
        obj,
        operator,
        value,
        key,
        searchByIndex = false,
        result = [],
        filters = [],
        index = null;

      // flag if this was invoked via findOne()
      firstOnly = firstOnly || false;

      if (typeof queryObject === 'object') {
        for (p in queryObject) {
          obj = {};
          obj[p] = queryObject[p];
          filters.push(obj);

          if (hasOwnProperty.call(queryObject, p)) {
            property = p;
            queryObjectOp = queryObject[p];
          }
        }
        // if more than one expression in single query object,
        // convert implicit $and to explicit $and
        if (filters.length > 1) {
          return this.find({ '$and': filters }, firstOnly);
        }
      }

      // apply no filters if they want all
      if (!property || queryObject === 'getAll') {
        if (firstOnly) {
          if (this.filterInitialized) {
            this.filteredrows = this.filteredrows.slice(0, 1);
          } else {
            this.filteredrows = (this.collection.data.length > 0) ? [0] : [];
            this.filterInitialized = true;
          }
        }

        return this;
      }

      // injecting $and and $or expression tree evaluation here.
      if (property === '$and' || property === '$or') {
        this[property](queryObjectOp);

        // for chained find with firstonly,
        if (firstOnly && this.filteredrows.length > 1) {
          this.filteredrows = this.filteredrows.slice(0, 1);
        }

        return this;
      }

      // see if query object is in shorthand mode (assuming eq operator)
      if (queryObjectOp === null || (typeof queryObjectOp !== 'object' || queryObjectOp instanceof Date)) {
        operator = '$eq';
        value = queryObjectOp;
      } else if (typeof queryObjectOp === 'object') {
        for (key in queryObjectOp) {
          if (hasOwnProperty.call(queryObjectOp, key)) {
            operator = key;
            value = queryObjectOp[key];
            break;
          }
        }
      } else {
        throw new Error('Do not know what you want to do.');
      }

      if (operator === '$regex' || typeof value === 'object') {
        value = precompileQuery(operator, value);
      }

      // if user is deep querying the object such as find('name.first': 'odin')
      var usingDotNotation = (property.indexOf('.') !== -1);

      // if an index exists for the property being queried against, use it
      // for now only enabling where it is the first filter applied and prop is indexed
      var doIndexCheck = !this.filterInitialized;

      if (doIndexCheck && this.collection.binaryIndices[property] && indexedOps[operator]) {
        // this is where our lazy index rebuilding will take place
        // basically we will leave all indexes dirty until we need them
        // so here we will rebuild only the index tied to this property
        // ensureIndex() will only rebuild if flagged as dirty since we are not passing force=true param
        if (this.collection.adaptiveBinaryIndices !== true) {
          this.collection.ensureIndex(property);
        }

        searchByIndex = true;
        index = this.collection.binaryIndices[property];
      }

      // opportunistically speed up $in searches from O(n*m) to O(n*log m)
      if (!searchByIndex && operator === '$in' && Array.isArray(value) && typeof Set !== 'undefined') {
        value = new Set(value);
        operator = '$inSet';
      }

      // the comparison function
      var fun = LokiOps[operator];

      // "shortcut" for collection data
      var t = this.collection.data;
      // filter data length
      var i = 0,
        len = 0;

      // Query executed differently depending on :
      //    - whether the property being queried has an index defined
      //    - if chained, we handle first pass differently for initial filteredrows[] population
      //
      // For performance reasons, each case has its own if block to minimize in-loop calculations

      var filter, rowIdx = 0, record;

      // If the filteredrows[] is already initialized, use it
      if (this.filterInitialized) {
        filter = this.filteredrows;
        len = filter.length;

        // currently supporting dot notation for non-indexed conditions only
        if (usingDotNotation) {
          property = property.split('.');
          for (i = 0; i < len; i++) {
            rowIdx = filter[i];
            record = t[rowIdx];
            if (dotSubScan(record, property, fun, value, record)) {
              result.push(rowIdx);
              if (firstOnly) {
                this.filteredrows = result;
                return this;
              }
            }
          }
        } else {
          for (i = 0; i < len; i++) {
            rowIdx = filter[i];
            record = t[rowIdx];
            if (fun(record[property], value, record)) {
              result.push(rowIdx);
              if (firstOnly) {
                this.filteredrows = result;
                return this;
              }
            }
          }
        }
      }
      // first chained query so work against data[] but put results in filteredrows
      else {
        // if not searching by index
        if (!searchByIndex) {
          len = t.length;

          if (usingDotNotation) {
            property = property.split('.');
            for (i = 0; i < len; i++) {
              record = t[i];
              if (dotSubScan(record, property, fun, value, record)) {
                result.push(i);
                if (firstOnly) {
                  this.filteredrows = result;
                  this.filterInitialized = true;
                  return this;
                }
              }
            }
          } else {
            for (i = 0; i < len; i++) {
              record = t[i];
              if (fun(record[property], value, record)) {
                result.push(i);
                if (firstOnly) {
                  this.filteredrows = result;
                  this.filterInitialized = true;
                  return this;
                }
              }
            }
          }
        } else {
          // search by index
          var segm = this.collection.calculateRange(operator, property, value);

          if (operator !== '$in') {
            for (i = segm[0]; i <= segm[1]; i++) {
              if (indexedOps[operator] !== true) {
                // must be a function, implying 2nd phase filtering of results from calculateRange
                if (indexedOps[operator](Utils.getIn(t[index.values[i]], property, usingDotNotation), value)) {
                  result.push(index.values[i]);
                  if (firstOnly) {
                    this.filteredrows = result;
                    this.filterInitialized = true;
                    return this;
                  }
                }
              }
              else {
                result.push(index.values[i]);
                if (firstOnly) {
                  this.filteredrows = result;
                  this.filterInitialized = true;
                  return this;
                }
              }
            }
          } else {
            for (i = 0, len = segm.length; i < len; i++) {
              result.push(index.values[segm[i]]);
              if (firstOnly) {
                this.filteredrows = result;
                this.filterInitialized = true;
                return this;
              }
            }
          }
        }

      }

      this.filteredrows = result;
      this.filterInitialized = true; // next time work against filteredrows[]
      return this;
    };


    /**
     * where() - Used for filtering via a javascript filter function.
     *
     * @param {function} fun - A javascript function used for filtering current results by.
     * @returns {Resultset} this resultset for further chain ops.
     * @memberof Resultset
     * @example
     * var over30 = users.chain().where(function(obj) { return obj.age >= 30; }.data();
     */
    Resultset.prototype.where = function (fun) {
      var viewFunction,
        result = [];

      if ('function' === typeof fun) {
        viewFunction = fun;
      } else {
        throw new TypeError('Argument is not a stored view or a function');
      }
      try {
        // If the filteredrows[] is already initialized, use it
        if (this.filterInitialized) {
          var j = this.filteredrows.length;

          while (j--) {
            if (viewFunction(this.collection.data[this.filteredrows[j]]) === true) {
              result.push(this.filteredrows[j]);
            }
          }

          this.filteredrows = result;

          return this;
        }
        // otherwise this is initial chained op, work against data, push into filteredrows[]
        else {
          var k = this.collection.data.length;

          while (k--) {
            if (viewFunction(this.collection.data[k]) === true) {
              result.push(k);
            }
          }

          this.filteredrows = result;
          this.filterInitialized = true;

          return this;
        }
      } catch (err) {
        throw err;
      }
    };

    /**
     * count() - returns the number of documents in the resultset.
     *
     * @returns {number} The number of documents in the resultset.
     * @memberof Resultset
     * @example
     * var over30Count = users.chain().find({ age: { $gte: 30 } }).count();
     */
    Resultset.prototype.count = function () {
      if (this.filterInitialized) {
        return this.filteredrows.length;
      }
      return this.collection.count();
    };

    /**
     * Terminates the chain and returns array of filtered documents
     *
     * @param {object=} options - allows specifying 'forceClones' and 'forceCloneMethod' options.
     * @param {boolean} options.forceClones - Allows forcing the return of cloned objects even when
     *        the collection is not configured for clone object.
     * @param {string} options.forceCloneMethod - Allows overriding the default or collection specified cloning method.
     *        Possible values include 'parse-stringify', 'jquery-extend-deep', 'shallow', 'shallow-assign'
     * @param {bool} options.removeMeta - Will force clones and strip $loki and meta properties from documents
     *
     * @returns {array} Array of documents in the resultset
     * @memberof Resultset
     * @example
     * var resutls = users.chain().find({ age: 34 }).data();
     */
    Resultset.prototype.data = function (options) {
      var result = [],
        data = this.collection.data,
        obj,
        len,
        i,
        method;

      options = options || {};

      // if user opts to strip meta, then force clones and use 'shallow' if 'force' options are not present
      if (options.removeMeta && !options.forceClones) {
        options.forceClones = true;
        options.forceCloneMethod = options.forceCloneMethod || 'shallow';
      }

      // if collection has delta changes active, then force clones and use 'parse-stringify' for effective change tracking of nested objects
      // if collection is immutable freeze and unFreeze takes care of cloning
      if (!this.collection.disableDeltaChangesApi && this.collection.disableFreeze) {
        options.forceClones = true;
        options.forceCloneMethod = 'parse-stringify';
      }

      // if this has no filters applied, just return collection.data
      if (!this.filterInitialized) {
        if (this.filteredrows.length === 0) {
          // determine whether we need to clone objects or not
          if (this.collection.cloneObjects || options.forceClones) {
            len = data.length;
            method = options.forceCloneMethod || this.collection.cloneMethod;
            for (i = 0; i < len; i++) {
              obj = clone(data[i], method);
              if (options.removeMeta) {
                delete obj.$loki;
                delete obj.meta;
              }
              result.push(obj);
            }
            return result;
          }
          // otherwise we are not cloning so return sliced array with same object references
          else {
            return data.slice();
          }
        } else {
          // filteredrows must have been set manually, so use it
          this.filterInitialized = true;
        }
      }

      var fr = this.filteredrows;
      len = fr.length;

      if (this.collection.cloneObjects || options.forceClones) {
        method = options.forceCloneMethod || this.collection.cloneMethod;
        for (i = 0; i < len; i++) {
          obj = clone(data[fr[i]], method);
          if (options.removeMeta) {
            delete obj.$loki;
            delete obj.meta;
          }
          result.push(obj);
        }
      } else {
        for (i = 0; i < len; i++) {
          result.push(data[fr[i]]);
        }
      }
      return result;
    };

    /**
     * Used to run an update operation on all documents currently in the resultset.
     *
     * @param {function} updateFunction - User supplied updateFunction(obj) will be executed for each document object.
     * @returns {Resultset} this resultset for further chain ops.
     * @memberof Resultset
     * @example
     * users.chain().find({ country: 'de' }).update(function(user) {
     *   user.phoneFormat = "+49 AAAA BBBBBB";
     * });
     */
    Resultset.prototype.update = function (updateFunction) {

      if (typeof (updateFunction) !== "function") {
        throw new TypeError('Argument is not a function');
      }

      // if this has no filters applied, we need to populate filteredrows first
      if (!this.filterInitialized && this.filteredrows.length === 0) {
        this.filteredrows = this.collection.prepareFullDocIndex();
      }

      var obj, len = this.filteredrows.length,
        rcd = this.collection.data;

      // pass in each document object currently in resultset to user supplied updateFunction
      for (var idx = 0; idx < len; idx++) {
        // if we have cloning option specified or are doing differential delta changes, clone object first
        if (!this.disableFreeze || this.collection.cloneObjects || !this.collection.disableDeltaChangesApi) {
          obj = clone(rcd[this.filteredrows[idx]], this.collection.cloneMethod);
          updateFunction(obj);
          this.collection.update(obj);
        }
        else {
          // no need to clone, so just perform update on collection data object instance
          updateFunction(rcd[this.filteredrows[idx]]);
          this.collection.update(rcd[this.filteredrows[idx]]);
        }
      }

      return this;
    };

    /**
     * Removes all document objects which are currently in resultset from collection (as well as resultset)
     *
     * @returns {Resultset} this (empty) resultset for further chain ops.
     * @memberof Resultset
     * @example
     * // remove users inactive since 1/1/2001
     * users.chain().find({ lastActive: { $lte: new Date("1/1/2001").getTime() } }).remove();
     */
    Resultset.prototype.remove = function () {

      // if this has no filters applied, we need to populate filteredrows first
      if (!this.filterInitialized && this.filteredrows.length === 0) {
        this.filteredrows = this.collection.prepareFullDocIndex();
      }

      this.collection.removeBatchByPositions(this.filteredrows);

      this.filteredrows = [];

      return this;
    };

    /**
     * data transformation via user supplied functions
     *
     * @param {function} mapFunction - this function accepts a single document for you to transform and return
     * @param {function} reduceFunction - this function accepts many (array of map outputs) and returns single value
     * @returns {value} The output of your reduceFunction
     * @memberof Resultset
     * @example
     * var db = new loki("order.db");
     * var orders = db.addCollection("orders");
     * orders.insert([{ qty: 4, unitCost: 100.00 }, { qty: 10, unitCost: 999.99 }, { qty: 2, unitCost: 49.99 }]);
     *
     * function mapfun (obj) { return obj.qty*obj.unitCost };
     * function reducefun(array) {
     *   var grandTotal=0;
     *   array.forEach(function(orderTotal) { grandTotal += orderTotal; });
     *   return grandTotal;
     * }
     * var grandOrderTotal = orders.chain().mapReduce(mapfun, reducefun);
     * console.log(grandOrderTotal);
     */
    Resultset.prototype.mapReduce = function (mapFunction, reduceFunction) {
      try {
        return reduceFunction(this.data().map(mapFunction));
      } catch (err) {
        throw err;
      }
    };

    /**
     * eqJoin() - Left joining two sets of data. Join keys can be defined or calculated properties
     * eqJoin expects the right join key values to be unique.  Otherwise left data will be joined on the last joinData object with that key
     * @param {Array|Resultset|Collection} joinData - Data array to join to.
     * @param {(string|function)} leftJoinKey - Property name in this result set to join on or a function to produce a value to join on
     * @param {(string|function)} rightJoinKey - Property name in the joinData to join on or a function to produce a value to join on
     * @param {function=} mapFun - (Optional) A function that receives each matching pair and maps them into output objects - function(left,right){return joinedObject}
     * @param {object=} dataOptions - options to data() before input to your map function
     * @param {bool} dataOptions.removeMeta - allows removing meta before calling mapFun
     * @param {boolean} dataOptions.forceClones - forcing the return of cloned objects to your map object
     * @param {string} dataOptions.forceCloneMethod - Allows overriding the default or collection specified cloning method.
     * @returns {Resultset} A resultset with data in the format [{left: leftObj, right: rightObj}]
     * @memberof Resultset
     * @example
     * var db = new loki('sandbox.db');
     *
     * var products = db.addCollection('products');
     * var orders = db.addCollection('orders');
     *
     * products.insert({ productId: "100234", name: "flywheel energy storage", unitCost: 19999.99 });
     * products.insert({ productId: "140491", name: "300F super capacitor", unitCost: 129.99 });
     * products.insert({ productId: "271941", name: "fuel cell", unitCost: 3999.99 });
     * products.insert({ productId: "174592", name: "390V 3AH lithium bank", unitCost: 4999.99 });
     *
     * orders.insert({ orderDate : new Date("12/1/2017").getTime(), prodId: "174592", qty: 2, customerId: 2 });
     * orders.insert({ orderDate : new Date("4/15/2016").getTime(), prodId: "271941", qty: 1, customerId: 1 });
     * orders.insert({ orderDate : new Date("3/12/2017").getTime(), prodId: "140491", qty: 4, customerId: 4 });
     * orders.insert({ orderDate : new Date("7/31/2017").getTime(), prodId: "100234", qty: 7, customerId: 3 });
     * orders.insert({ orderDate : new Date("8/3/2016").getTime(), prodId: "174592", qty: 3, customerId: 5 });
     *
     * var mapfun = function(left, right) {
     *   return {
     *     orderId: left.$loki,
     *     orderDate: new Date(left.orderDate) + '',
     *     customerId: left.customerId,
     *     qty: left.qty,
     *     productId: left.prodId,
     *     prodName: right.name,
     *     prodCost: right.unitCost,
     *     orderTotal: +((right.unitCost * left.qty).toFixed(2))
     *   };
     * };
     *
     * // join orders with relevant product info via eqJoin
     * var orderSummary = orders.chain().eqJoin(products, "prodId", "productId", mapfun).data();
     *
     * console.log(orderSummary);
     */
    Resultset.prototype.eqJoin = function (joinData, leftJoinKey, rightJoinKey, mapFun, dataOptions) {

      var leftData = [],
        leftDataLength,
        rightData = [],
        rightDataLength,
        key,
        result = [],
        leftKeyisFunction = typeof leftJoinKey === 'function',
        rightKeyisFunction = typeof rightJoinKey === 'function',
        joinMap = {};

      //get the left data
      leftData = this.data(dataOptions);
      leftDataLength = leftData.length;

      //get the right data
      if (joinData instanceof Collection) {
        rightData = joinData.chain().data(dataOptions);
      } else if (joinData instanceof Resultset) {
        rightData = joinData.data(dataOptions);
      } else if (Array.isArray(joinData)) {
        rightData = joinData;
      } else {
        throw new TypeError('joinData needs to be an array or result set');
      }
      rightDataLength = rightData.length;

      //construct a lookup table

      for (var i = 0; i < rightDataLength; i++) {
        key = rightKeyisFunction ? rightJoinKey(rightData[i]) : rightData[i][rightJoinKey];
        joinMap[key] = rightData[i];
      }

      if (!mapFun) {
        mapFun = function (left, right) {
          return {
            left: left,
            right: right
          };
        };
      }

      //Run map function over each object in the resultset
      for (var j = 0; j < leftDataLength; j++) {
        key = leftKeyisFunction ? leftJoinKey(leftData[j]) : leftData[j][leftJoinKey];
        result.push(mapFun(leftData[j], joinMap[key] || {}));
      }

      //return return a new resultset with no filters
      this.collection = new Collection('joinData');
      this.collection.insert(result);
      this.filteredrows = [];
      this.filterInitialized = false;

      return this;
    };

    /**
     * Applies a map function into a new collection for further chaining.
     * @param {function} mapFun - javascript map function
     * @param {object=} dataOptions - options to data() before input to your map function
     * @param {bool} dataOptions.removeMeta - allows removing meta before calling mapFun
     * @param {boolean} dataOptions.forceClones - forcing the return of cloned objects to your map object
     * @param {string} dataOptions.forceCloneMethod - Allows overriding the default or collection specified cloning method.
     * @memberof Resultset
     * @example
     * var orders.chain().find({ productId: 32 }).map(function(obj) {
     *   return {
     *     orderId: $loki,
     *     productId: productId,
     *     quantity: qty
     *   };
     * });
     */
    Resultset.prototype.map = function (mapFun, dataOptions) {
      var data = this.data(dataOptions).map(mapFun);
      //return return a new resultset with no filters
      this.collection = new Collection('mappedData');
      this.collection.insert(data);
      this.filteredrows = [];
      this.filterInitialized = false;

      return this;
    };

    /**
     * DynamicView class is a versatile 'live' view class which can have filters and sorts applied.
     *    Collection.addDynamicView(name) instantiates this DynamicView object and notifies it
     *    whenever documents are add/updated/removed so it can remain up-to-date. (chainable)
     *
     * @example
     * var mydv = mycollection.addDynamicView('test');  // default is non-persistent
     * mydv.applyFind({ 'doors' : 4 });
     * mydv.applyWhere(function(obj) { return obj.name === 'Toyota'; });
     * var results = mydv.data();
     *
     * @constructor DynamicView
     * @implements LokiEventEmitter
     * @param {Collection} collection - A reference to the collection to work against
     * @param {string} name - The name of this dynamic view
     * @param {object=} options - (Optional) Pass in object with 'persistent' and/or 'sortPriority' options.
     * @param {boolean} [options.persistent=false] - indicates if view is to main internal results array in 'resultdata'
     * @param {string} [options.sortPriority='passive'] - 'passive' (sorts performed on call to data) or 'active' (after updates)
     * @param {number} options.minRebuildInterval - minimum rebuild interval (need clarification to docs here)
     * @see {@link Collection#addDynamicView} to construct instances of DynamicView
     */
    function DynamicView(collection, name, options) {
      this.collection = collection;
      this.name = name;
      this.rebuildPending = false;
      this.options = options || {};

      if (!this.options.hasOwnProperty('persistent')) {
        this.options.persistent = false;
      }

      // 'persistentSortPriority':
      // 'passive' will defer the sort phase until they call data(). (most efficient overall)
      // 'active' will sort async whenever next idle. (prioritizes read speeds)
      if (!this.options.hasOwnProperty('sortPriority')) {
        this.options.sortPriority = 'passive';
      }

      if (!this.options.hasOwnProperty('minRebuildInterval')) {
        this.options.minRebuildInterval = 1;
      }

      this.resultset = new Resultset(collection);
      this.resultdata = [];
      this.resultsdirty = false;

      this.cachedresultset = null;

      // keep ordered filter pipeline
      this.filterPipeline = [];
      if (!this.collection.disableFreeze) {
        Object.freeze(this.filterPipeline);
      }

      // sorting member variables
      // we only support one active search, applied using applySort() or applySimpleSort()
      this.sortFunction = null;
      this.sortCriteria = null;
      this.sortCriteriaSimple = null;
      this.sortDirty = false;

      // for now just have 1 event for when we finally rebuilt lazy view
      // once we refactor transactions, i will tie in certain transactional events

      this.events = {
        'rebuild': [],
        'filter': [],
        'sort': []
      };
    }

    DynamicView.prototype = new LokiEventEmitter();
    DynamicView.prototype.constructor = DynamicView;

    /**
     * getSort() - used to get the current sort
     *
     * @returns function (sortFunction) or array (sortCriteria) or object (sortCriteriaSimple)
     */
    DynamicView.prototype.getSort = function () {
      return this.sortFunction || this.sortCriteria || this.sortCriteriaSimple;
    };

    /**
     * rematerialize() - internally used immediately after deserialization (loading)
     *    This will clear out and reapply filterPipeline ops, recreating the view.
     *    Since where filters do not persist correctly, this method allows
     *    restoring the view to state where user can re-apply those where filters.
     *
     * @param {Object=} options - (Optional) allows specification of 'removeWhereFilters' option
     * @returns {DynamicView} This dynamic view for further chained ops.
     * @memberof DynamicView
     * @fires DynamicView.rebuild
     */
    DynamicView.prototype.rematerialize = function (options) {
      var fpl,
        fpi,
        idx;

      options = options || {};

      this.resultdata = [];
      this.resultsdirty = true;
      this.resultset = new Resultset(this.collection);

      if (this.sortFunction || this.sortCriteria || this.sortCriteriaSimple) {
        this.sortDirty = true;
      }

      var wasFrozen = Object.isFrozen(this.filterPipeline);
      if (options.hasOwnProperty('removeWhereFilters')) {
        // for each view see if it had any where filters applied... since they don't
        // serialize those functions lets remove those invalid filters
        if (wasFrozen) {
          this.filterPipeline = this.filterPipeline.slice();
        }
        fpl = this.filterPipeline.length;
        fpi = fpl;
        while (fpi--) {
          if (this.filterPipeline[fpi].type === 'where') {
            if (fpi !== this.filterPipeline.length - 1) {
              this.filterPipeline[fpi] = this.filterPipeline[this.filterPipeline.length - 1];
            }
            this.filterPipeline.length--;
          }
        }
      }

      // back up old filter pipeline, clear filter pipeline, and reapply pipeline ops
      var ofp = this.filterPipeline;
      this.filterPipeline = [];

      // now re-apply 'find' filterPipeline ops
      fpl = ofp.length;
      for (idx = 0; idx < fpl; idx++) {
        this.applyFind(ofp[idx].val, ofp[idx].uid);
      }
      if (wasFrozen) {
        Object.freeze(this.filterPipeline);
      }

      // during creation of unit tests, i will remove this forced refresh and leave lazy
      this.data();

      // emit rebuild event in case user wants to be notified
      this.emit('rebuild', this);

      return this;
    };

    /**
     * branchResultset() - Makes a copy of the internal resultset for branched queries.
     *    Unlike this dynamic view, the branched resultset will not be 'live' updated,
     *    so your branched query should be immediately resolved and not held for future evaluation.
     *
     * @param {(string|array=)} transform - Optional name of collection transform, or an array of transform steps
     * @param {object=} parameters - optional parameters (if optional transform requires them)
     * @returns {Resultset} A copy of the internal resultset for branched queries.
     * @memberof DynamicView
     * @example
     * var db = new loki('test');
     * var coll = db.addCollection('mydocs');
     * var dv = coll.addDynamicView('myview');
     * var tx = [
     *   {
     *     type: 'offset',
     *     value: '[%lktxp]pageStart'
     *   },
     *   {
     *     type: 'limit',
     *     value: '[%lktxp]pageSize'
     *   }
     * ];
     * coll.addTransform('viewPaging', tx);
     *
     * // add some records
     *
     * var results = dv.branchResultset('viewPaging', { pageStart: 10, pageSize: 10 }).data();
     */
    DynamicView.prototype.branchResultset = function (transform, parameters) {
      var rs = this.resultset.branch();

      if (typeof transform === 'undefined') {
        return rs;
      }

      return rs.transform(transform, parameters);
    };

    /**
     * toJSON() - Override of toJSON to avoid circular references
     *
     */
    DynamicView.prototype.toJSON = function () {
      var copy = new DynamicView(this.collection, this.name, this.options);
      copy.resultset = this.resultset;
      copy.resultdata = []; // let's not save data (copy) to minimize size
      copy.resultsdirty = true;
      copy.filterPipeline = this.filterPipeline;
      copy.sortFunction = this.sortFunction;
      copy.sortCriteria = this.sortCriteria;
      copy.sortCriteriaSimple = this.sortCriteriaSimple || null;
      copy.sortDirty = this.sortDirty;

      // avoid circular reference, reapply in db.loadJSON()
      copy.collection = null;

      return copy;
    };

    /**
     * removeFilters() - Used to clear pipeline and reset dynamic view to initial state.
     *     Existing options should be retained.
     * @param {object=} options - configure removeFilter behavior
     * @param {boolean=} options.queueSortPhase - (default: false) if true we will async rebuild view (maybe set default to true in future?)
     * @memberof DynamicView
     */
    DynamicView.prototype.removeFilters = function (options) {
      options = options || {};

      this.rebuildPending = false;
      this.resultset.reset();
      this.resultdata = [];
      this.resultsdirty = true;

      this.cachedresultset = null;

      var wasFrozen = Object.isFrozen(this.filterPipeline);
      var filterChanged = this.filterPipeline.length > 0;
      // keep ordered filter pipeline
      this.filterPipeline = [];
      if (wasFrozen) {
        Object.freeze(this.filterPipeline);
      }

      // sorting member variables
      // we only support one active search, applied using applySort() or applySimpleSort()
      this.sortFunction = null;
      this.sortCriteria = null;
      this.sortCriteriaSimple = null;
      this.sortDirty = false;

      if (options.queueSortPhase === true) {
        this.queueSortPhase();
      }

      if (filterChanged) {
        this.emit('filter');
      }
    };

    /**
     * applySort() - Used to apply a sort to the dynamic view
     * @example
     * dv.applySort(function(obj1, obj2) {
     *   if (obj1.name === obj2.name) return 0;
     *   if (obj1.name > obj2.name) return 1;
     *   if (obj1.name < obj2.name) return -1;
     * });
     *
     * @param {function} comparefun - a javascript compare function used for sorting
     * @returns {DynamicView} this DynamicView object, for further chain ops.
     * @memberof DynamicView
     */
    DynamicView.prototype.applySort = function (comparefun) {
      this.sortFunction = comparefun;
      this.sortCriteria = null;
      this.sortCriteriaSimple = null;

      this.queueSortPhase();
      this.emit('sort');

      return this;
    };

    /**
     * applySimpleSort() - Used to specify a property used for view translation.
     * @example
     * dv.applySimpleSort("name");
     *
     * @param {string} propname - Name of property by which to sort.
     * @param {object|boolean=} options - boolean for sort descending or options object
     * @param {boolean} [options.desc=false] - whether we should sort descending.
     * @param {boolean} [options.disableIndexIntersect=false] - whether we should explicity not use array intersection.
     * @param {boolean} [options.forceIndexIntersect=false] - force array intersection (if binary index exists).
     * @param {boolean} [options.useJavascriptSorting=false] - whether results are sorted via basic javascript sort.
     * @returns {DynamicView} this DynamicView object, for further chain ops.
     * @memberof DynamicView
     */
    DynamicView.prototype.applySimpleSort = function (propname, options) {
      this.sortCriteriaSimple = { propname: propname, options: options || false };
      if (!this.collection.disableFreeze) {
        deepFreeze(this.sortCriteriaSimple);
      }
      this.sortCriteria = null;
      this.sortFunction = null;

      this.queueSortPhase();
      this.emit('sort');

      return this;
    };

    /**
     * applySortCriteria() - Allows sorting a resultset based on multiple columns.
     * @example
     * // to sort by age and then name (both ascending)
     * dv.applySortCriteria(['age', 'name']);
     * // to sort by age (ascending) and then by name (descending)
     * dv.applySortCriteria(['age', ['name', true]);
     * // to sort by age (descending) and then by name (descending)
     * dv.applySortCriteria(['age', true], ['name', true]);
     *
     * @param {array} properties - array of property names or subarray of [propertyname, isdesc] used evaluate sort order
     * @returns {DynamicView} Reference to this DynamicView, sorted, for future chain operations.
     * @memberof DynamicView
     */
    DynamicView.prototype.applySortCriteria = function (criteria) {
      this.sortCriteria = criteria;
      if (!this.collection.disableFreeze) {
        deepFreeze(this.sortCriteria);
      }
      this.sortCriteriaSimple = null;
      this.sortFunction = null;

      this.queueSortPhase();
      this.emit('sort');
      return this;
    };

    /**
     * startTransaction() - marks the beginning of a transaction.
     *
     * @returns {DynamicView} this DynamicView object, for further chain ops.
     */
    DynamicView.prototype.startTransaction = function () {
      this.cachedresultset = this.resultset.copy();

      return this;
    };

    /**
     * commit() - commits a transaction.
     *
     * @returns {DynamicView} this DynamicView object, for further chain ops.
     */
    DynamicView.prototype.commit = function () {
      this.cachedresultset = null;

      return this;
    };

    /**
     * rollback() - rolls back a transaction.
     *
     * @returns {DynamicView} this DynamicView object, for further chain ops.
     */
    DynamicView.prototype.rollback = function () {
      this.resultset = this.cachedresultset;

      if (this.options.persistent) {
        // for now just rebuild the persistent dynamic view data in this worst case scenario
        // (a persistent view utilizing transactions which get rolled back), we already know the filter so not too bad.
        this.resultdata = this.resultset.data();

        this.emit('rebuild', this);
      }

      return this;
    };


    /**
     * Implementation detail.
     * _indexOfFilterWithId() - Find the index of a filter in the pipeline, by that filter's ID.
     *
     * @param {(string|number)} uid - The unique ID of the filter.
     * @returns {number}: index of the referenced filter in the pipeline; -1 if not found.
     */
    DynamicView.prototype._indexOfFilterWithId = function (uid) {
      if (typeof uid === 'string' || typeof uid === 'number') {
        for (var idx = 0, len = this.filterPipeline.length; idx < len; idx += 1) {
          if (uid === this.filterPipeline[idx].uid) {
            return idx;
          }
        }
      }
      return -1;
    };

    /**
     * Implementation detail.
     * _addFilter() - Add the filter object to the end of view's filter pipeline and apply the filter to the resultset.
     *
     * @param {object} filter - The filter object. Refer to applyFilter() for extra details.
     */
    DynamicView.prototype._addFilter = function (filter) {
      var wasFrozen = Object.isFrozen(this.filterPipeline);
      if (wasFrozen) {
        this.filterPipeline = this.filterPipeline.slice();
      }
      if (!this.collection.disableFreeze) {
        deepFreeze(filter);
      }
      this.filterPipeline.push(filter);
      if (wasFrozen) {
        Object.freeze(this.filterPipeline);
      }
      this.resultset[filter.type](filter.val);
    };

    /**
     * reapplyFilters() - Reapply all the filters in the current pipeline.
     *
     * @returns {DynamicView} this DynamicView object, for further chain ops.
     */
    DynamicView.prototype.reapplyFilters = function () {
      this.resultset.reset();

      this.cachedresultset = null;
      if (this.options.persistent) {
        this.resultdata = [];
        this.resultsdirty = true;
      }

      var filters = this.filterPipeline;
      var wasFrozen = Object.isFrozen(filters);
      this.filterPipeline = [];

      for (var idx = 0, len = filters.length; idx < len; idx += 1) {
        this._addFilter(filters[idx]);
      }
      if (wasFrozen) {
        Object.freeze(this.filterPipeline);
      }

      if (this.sortFunction || this.sortCriteria || this.sortCriteriaSimple) {
        this.queueSortPhase();
      } else {
        this.queueRebuildEvent();
      }
      this.emit('filter');
      return this;
    };

    /**
     * applyFilter() - Adds or updates a filter in the DynamicView filter pipeline
     *
     * @param {object} filter - A filter object to add to the pipeline.
     *    The object is in the format { 'type': filter_type, 'val', filter_param, 'uid', optional_filter_id }
     * @returns {DynamicView} this DynamicView object, for further chain ops.
     * @memberof DynamicView
     */
    DynamicView.prototype.applyFilter = function (filter) {
      var idx = this._indexOfFilterWithId(filter.uid);
      if (idx >= 0) {
        var wasFrozen = Object.isFrozen(this.filterPipeline);
        if (wasFrozen) {
          this.filterPipeline = this.filterPipeline.slice();
        }
        this.filterPipeline[idx] = filter;
        if (wasFrozen) {
          freeze(filter);
          Object.freeze(this.filterPipeline);
        }
        return this.reapplyFilters();
      }

      this.cachedresultset = null;
      if (this.options.persistent) {
        this.resultdata = [];
        this.resultsdirty = true;
      }

      this._addFilter(filter);

      if (this.sortFunction || this.sortCriteria || this.sortCriteriaSimple) {
        this.queueSortPhase();
      } else {
        this.queueRebuildEvent();
      }

      this.emit('filter');
      return this;
    };

    /**
     * applyFind() - Adds or updates a mongo-style query option in the DynamicView filter pipeline
     *
     * @param {object} query - A mongo-style query object to apply to pipeline
     * @param {(string|number)=} uid - Optional: The unique ID of this filter, to reference it in the future.
     * @returns {DynamicView} this DynamicView object, for further chain ops.
     * @memberof DynamicView
     */
    DynamicView.prototype.applyFind = function (query, uid) {
      this.applyFilter({
        type: 'find',
        val: query,
        uid: uid
      });
      return this;
    };

    /**
     * applyWhere() - Adds or updates a javascript filter function in the DynamicView filter pipeline
     *
     * @param {function} fun - A javascript filter function to apply to pipeline
     * @param {(string|number)=} uid - Optional: The unique ID of this filter, to reference it in the future.
     * @returns {DynamicView} this DynamicView object, for further chain ops.
     * @memberof DynamicView
     */
    DynamicView.prototype.applyWhere = function (fun, uid) {
      this.applyFilter({
        type: 'where',
        val: fun,
        uid: uid
      });
      return this;
    };

    /**
     * removeFilter() - Remove the specified filter from the DynamicView filter pipeline
     *
     * @param {(string|number)} uid - The unique ID of the filter to be removed.
     * @returns {DynamicView} this DynamicView object, for further chain ops.
     * @memberof DynamicView
     */
    DynamicView.prototype.removeFilter = function (uid) {
      var idx = this._indexOfFilterWithId(uid);
      if (idx < 0) {
        throw new Error("Dynamic view does not contain a filter with ID: " + uid);
      }
      var wasFrozen = Object.isFrozen(this.filterPipeline);
      if (wasFrozen) {
        this.filterPipeline = this.filterPipeline.slice();
      }
      this.filterPipeline.splice(idx, 1);
      if (wasFrozen) {
        Object.freeze(this.filterPipeline);
      }
      this.reapplyFilters();
      return this;
    };

    /**
     * count() - returns the number of documents representing the current DynamicView contents.
     *
     * @returns {number} The number of documents representing the current DynamicView contents.
     * @memberof DynamicView
     */
    DynamicView.prototype.count = function () {
      // in order to be accurate we will pay the minimum cost (and not alter dv state management)
      // recurring resultset data resolutions should know internally its already up to date.
      // for persistent data this will not update resultdata nor fire rebuild event.
      if (this.resultsdirty) {
        this.resultdata = this.resultset.data();
      }

      return this.resultset.count();
    };

    /**
     * data() - resolves and pending filtering and sorting, then returns document array as result.
     *
     * @param {object=} options - optional parameters to pass to resultset.data() if non-persistent
     * @param {boolean} options.forceClones - Allows forcing the return of cloned objects even when
     *        the collection is not configured for clone object.
     * @param {string} options.forceCloneMethod - Allows overriding the default or collection specified cloning method.
     *        Possible values include 'parse-stringify', 'jquery-extend-deep', 'shallow', 'shallow-assign'
     * @param {bool} options.removeMeta - Will force clones and strip $loki and meta properties from documents
     * @returns {array} An array of documents representing the current DynamicView contents.
     * @memberof DynamicView
     */
    DynamicView.prototype.data = function (options) {
      // using final sort phase as 'catch all' for a few use cases which require full rebuild
      if (this.sortDirty || this.resultsdirty) {
        this.performSortPhase({
          suppressRebuildEvent: true
        });
      }
      return (this.options.persistent) ? (this.resultdata) : (this.resultset.data(options));
    };

    /**
     * queueRebuildEvent() - When the view is not sorted we may still wish to be notified of rebuild events.
     *     This event will throttle and queue a single rebuild event when batches of updates affect the view.
     */
    DynamicView.prototype.queueRebuildEvent = function () {
      if (this.rebuildPending) {
        return;
      }
      this.rebuildPending = true;

      var self = this;
      setTimeout(function () {
        if (self.rebuildPending) {
          self.rebuildPending = false;
          self.emit('rebuild', self);
        }
      }, this.options.minRebuildInterval);
    };

    /**
     * queueSortPhase : If the view is sorted we will throttle sorting to either :
     *    (1) passive - when the user calls data(), or
     *    (2) active - once they stop updating and yield js thread control
     */
    DynamicView.prototype.queueSortPhase = function () {
      // already queued? exit without queuing again
      if (this.sortDirty) {
        return;
      }
      this.sortDirty = true;

      var self = this;
      if (this.options.sortPriority === "active") {
        // active sorting... once they are done and yield js thread, run async performSortPhase()
        setTimeout(function () {
          self.performSortPhase();
        }, this.options.minRebuildInterval);
      } else {
        // must be passive sorting... since not calling performSortPhase (until data call), lets use queueRebuildEvent to
        // potentially notify user that data has changed.
        this.queueRebuildEvent();
      }
    };

    /**
     * performSortPhase() - invoked synchronously or asynchronously to perform final sort phase (if needed)
     *
     */
    DynamicView.prototype.performSortPhase = function (options) {
      // async call to this may have been pre-empted by synchronous call to data before async could fire
      if (!this.sortDirty && !this.resultsdirty) {
        return;
      }

      options = options || {};

      if (this.sortDirty) {
        if (this.sortFunction) {
          this.resultset.sort(this.sortFunction);
        } else if (this.sortCriteria) {
          this.resultset.compoundsort(this.sortCriteria);
        } else if (this.sortCriteriaSimple) {
          this.resultset.simplesort(this.sortCriteriaSimple.propname, this.sortCriteriaSimple.options);
        }

        this.sortDirty = false;
      }

      if (this.options.persistent) {
        // persistent view, rebuild local resultdata array
        this.resultdata = this.resultset.data();
        this.resultsdirty = false;
      }

      if (!options.suppressRebuildEvent) {
        this.emit('rebuild', this);
      }
    };

    /**
     * evaluateDocument() - internal method for (re)evaluating document inclusion.
     *    Called by : collection.insert() and collection.update().
     *
     * @param {int} objIndex - index of document to (re)run through filter pipeline.
     * @param {bool} isNew - true if the document was just added to the collection.
     */
    DynamicView.prototype.evaluateDocument = function (objIndex, isNew) {
      // if no filter applied yet, the result 'set' should remain 'everything'
      if (!this.resultset.filterInitialized) {
        if (this.options.persistent) {
          this.resultdata = this.resultset.data();
        }
        // need to re-sort to sort new document
        if (this.sortFunction || this.sortCriteria || this.sortCriteriaSimple) {
          this.queueSortPhase();
        } else {
          this.queueRebuildEvent();
        }
        return;
      }

      var ofr = this.resultset.filteredrows;
      var oldPos = (isNew) ? (-1) : (ofr.indexOf(+objIndex));
      var oldlen = ofr.length;

      // creating a 1-element resultset to run filter chain ops on to see if that doc passes filters;
      // mostly efficient algorithm, slight stack overhead price (this function is called on inserts and updates)
      var evalResultset = new Resultset(this.collection);
      evalResultset.filteredrows = [objIndex];
      evalResultset.filterInitialized = true;
      var filter;
      for (var idx = 0, len = this.filterPipeline.length; idx < len; idx++) {
        filter = this.filterPipeline[idx];
        evalResultset[filter.type](filter.val);
      }

      // not a true position, but -1 if not pass our filter(s), 0 if passed filter(s)
      var newPos = (evalResultset.filteredrows.length === 0) ? -1 : 0;

      // wasn't in old, shouldn't be now... do nothing
      if (oldPos === -1 && newPos === -1) return;

      // wasn't in resultset, should be now... add
      if (oldPos === -1 && newPos !== -1) {
        ofr.push(objIndex);

        if (this.options.persistent) {
          this.resultdata.push(this.collection.data[objIndex]);
        }

        // need to re-sort to sort new document
        if (this.sortFunction || this.sortCriteria || this.sortCriteriaSimple) {
          this.queueSortPhase();
        } else {
          this.queueRebuildEvent();
        }

        return;
      }

      // was in resultset, shouldn't be now... delete
      if (oldPos !== -1 && newPos === -1) {
        if (oldPos < oldlen - 1) {
          ofr.splice(oldPos, 1);

          if (this.options.persistent) {
            this.resultdata.splice(oldPos, 1);
          }
        } else {
          ofr.length = oldlen - 1;

          if (this.options.persistent) {
            this.resultdata.length = oldlen - 1;
          }
        }

        // in case changes to data altered a sort column
        if (this.sortFunction || this.sortCriteria || this.sortCriteriaSimple) {
          this.queueSortPhase();
        } else {
          this.queueRebuildEvent();
        }

        return;
      }

      // was in resultset, should still be now... (update persistent only?)
      if (oldPos !== -1 && newPos !== -1) {
        if (this.options.persistent) {
          // in case document changed, replace persistent view data with the latest collection.data document
          this.resultdata[oldPos] = this.collection.data[objIndex];
        }

        // in case changes to data altered a sort column
        if (this.sortFunction || this.sortCriteria || this.sortCriteriaSimple) {
          this.queueSortPhase();
        } else {
          this.queueRebuildEvent();
        }

        return;
      }
    };

    /**
     * removeDocument() - internal function called on collection.delete()
     * @param {number|number[]} objIndex - index of document to (re)run through filter pipeline.
     */
    DynamicView.prototype.removeDocument = function (objIndex) {
      var idx, rmidx, rmlen, rxo = {}, fxo = {};
      var adjels = [];
      var drs = this.resultset;
      var fr = this.resultset.filteredrows;
      var frlen = fr.length;

      // if no filter applied yet, the result 'set' should remain 'everything'
      if (!this.resultset.filterInitialized) {
        if (this.options.persistent) {
          this.resultdata = this.resultset.data();
        }
        // in case changes to data altered a sort column
        if (this.sortFunction || this.sortCriteria || this.sortCriteriaSimple) {
          this.queueSortPhase();
        } else {
          this.queueRebuildEvent();
        }
        return;
      }

      // if passed single index, wrap in array
      if (!Array.isArray(objIndex)) {
        objIndex = [objIndex];
      }

      rmlen = objIndex.length;
      // create intersection object of data indices to remove
      for (rmidx = 0; rmidx < rmlen; rmidx++) {
        rxo[objIndex[rmidx]] = true;
      }

      // pivot remove data indices into remove filteredrows indices and dump in hashobject
      for (idx = 0; idx < frlen; idx++) {
        if (rxo[fr[idx]]) fxo[idx] = true;
      }

      // if any of the removed items were in our filteredrows...
      if (Object.keys(fxo).length > 0) {
        // remove them from filtered rows
        this.resultset.filteredrows = this.resultset.filteredrows.filter(function (di, idx) { return !fxo[idx]; });
        // if persistent...
        if (this.options.persistent) {
          // remove from resultdata
          this.resultdata = this.resultdata.filter(function (obj, idx) { return !fxo[idx]; });
        }

        // and queue sorts
        if (this.sortFunction || this.sortCriteria || this.sortCriteriaSimple) {
          this.queueSortPhase();
        } else {
          this.queueRebuildEvent();
        }
      }

      // to remove holes, we need to 'shift down' indices, this filter function finds number of positions to shift
      var filt = function (idx) { return function (di) { return di < drs.filteredrows[idx]; }; };

      frlen = drs.filteredrows.length;
      for (idx = 0; idx < frlen; idx++) {
        // grab subset of removed elements where data index is less than current filtered row data index;
        // use this to determine how many positions iterated remaining data index needs to be 'shifted down'
        adjels = objIndex.filter(filt(idx));
        drs.filteredrows[idx] -= adjels.length;
      }
    };

    /**
     * mapReduce() - data transformation via user supplied functions
     *
     * @param {function} mapFunction - this function accepts a single document for you to transform and return
     * @param {function} reduceFunction - this function accepts many (array of map outputs) and returns single value
     * @returns The output of your reduceFunction
     * @memberof DynamicView
     */
    DynamicView.prototype.mapReduce = function (mapFunction, reduceFunction) {
      try {
        return reduceFunction(this.data().map(mapFunction));
      } catch (err) {
        throw err;
      }
    };


    /**
     * Collection class that handles documents of same type
     * @constructor Collection
     * @implements LokiEventEmitter
     * @param {string} name - collection name
     * @param {(array|object)=} options - (optional) array of property names to be indicized OR a configuration object
     * @param {array=} [options.unique=[]] - array of property names to define unique constraints for
     * @param {array=} [options.exact=[]] - array of property names to define exact constraints for
     * @param {array=} [options.indices=[]] - array property names to define binary indexes for
     * @param {boolean} [options.adaptiveBinaryIndices=true] - collection indices will be actively rebuilt rather than lazily
     * @param {boolean} [options.asyncListeners=false] - whether listeners are invoked asynchronously
     * @param {boolean} [options.disableMeta=false] - set to true to disable meta property on documents
     * @param {boolean} [options.disableChangesApi=true] - set to false to enable Changes API
     * @param {boolean} [options.disableDeltaChangesApi=true] - set to false to enable Delta Changes API (requires Changes API, forces cloning)
     * @param {boolean} [options.autoupdate=false] - use Object.observe to update objects automatically
     * @param {boolean} [options.clone=false] - specify whether inserts and queries clone to/from user
     * @param {boolean} [options.serializableIndices=true[]] - converts date values on binary indexed properties to epoch time
     * @param {boolean} [options.disableFreeze=true] - when false all docs are frozen
     * @param {string} [options.cloneMethod='parse-stringify'] - 'parse-stringify', 'jquery-extend-deep', 'shallow', 'shallow-assign'
     * @param {int=} options.ttl - age of document (in ms.) before document is considered aged/stale.
     * @param {int=} options.ttlInterval - time interval for clearing out 'aged' documents; not set by default.
     * @see {@link Loki#addCollection} for normal creation of collections
     */
    function Collection(name, options) {
      // the name of the collection

      this.name = name;
      // the data held by the collection
      this.data = [];
      this.idIndex = null; // position->$loki index (built lazily)
      this.binaryIndices = {}; // user defined indexes
      this.constraints = {
        unique: {},
        exact: {}
      };

      // unique contraints contain duplicate object references, so they are not persisted.
      // we will keep track of properties which have unique contraint applied here, and regenerate lazily
      this.uniqueNames = [];

      // transforms will be used to store frequently used query chains as a series of steps
      // which itself can be stored along with the database.
      this.transforms = {};

      // the object type of the collection
      this.objType = name;

      // in autosave scenarios we will use collection level dirty flags to determine whether save is needed.
      // currently, if any collection is dirty we will autosave the whole database if autosave is configured.
      // defaulting to true since this is called from addCollection and adding a collection should trigger save
      this.dirty = true;

      // private holders for cached data
      this.cachedIndex = null;
      this.cachedBinaryIndex = null;
      this.cachedData = null;
      var self = this;

      /* OPTIONS */
      options = options || {};

      // exact match and unique constraints
      if (options.hasOwnProperty('unique')) {
        if (!Array.isArray(options.unique)) {
          options.unique = [options.unique];
        }
        // save names; actual index is built lazily
        options.unique.forEach(function (prop) {
          self.uniqueNames.push(prop);
        });
      }

      if (options.hasOwnProperty('exact')) {
        options.exact.forEach(function (prop) {
          self.constraints.exact[prop] = new ExactIndex(prop);
        });
      }

      // if set to true we will optimally keep indices 'fresh' during insert/update/remove ops (never dirty/never needs rebuild)
      // if you frequently intersperse insert/update/remove ops between find ops this will likely be significantly faster option.
      this.adaptiveBinaryIndices = options.hasOwnProperty('adaptiveBinaryIndices') ? options.adaptiveBinaryIndices : true;

      // is collection transactional
      this.transactional = options.hasOwnProperty('transactional') ? options.transactional : false;

      // options to clone objects when inserting them
      this.cloneObjects = options.hasOwnProperty('clone') ? options.clone : false;

      // default clone method (if enabled) is parse-stringify
      this.cloneMethod = options.hasOwnProperty('cloneMethod') ? options.cloneMethod : "parse-stringify";

      // option to make event listeners async, default is sync
      this.asyncListeners = options.hasOwnProperty('asyncListeners') ? options.asyncListeners : false;

      // if set to true we will not maintain a meta property for a document
      this.disableMeta = options.hasOwnProperty('disableMeta') ? options.disableMeta : false;

      // disable track changes
      this.disableChangesApi = options.hasOwnProperty('disableChangesApi') ? options.disableChangesApi : true;

      // disable delta update object style on changes
      this.disableDeltaChangesApi = options.hasOwnProperty('disableDeltaChangesApi') ? options.disableDeltaChangesApi : true;
      if (this.disableChangesApi) { this.disableDeltaChangesApi = true; }

      // option to observe objects and update them automatically, ignored if Object.observe is not supported
      this.autoupdate = options.hasOwnProperty('autoupdate') ? options.autoupdate : false;

      // by default, if you insert a document into a collection with binary indices, if those indexed properties contain
      // a DateTime we will convert to epoch time format so that (across serializations) its value position will be the
      // same 'after' serialization as it was 'before'.
      this.serializableIndices = options.hasOwnProperty('serializableIndices') ? options.serializableIndices : true;

      // option to deep freeze all documents
      this.disableFreeze = options.hasOwnProperty('disableFreeze') ? options.disableFreeze : true;

      //option to activate a cleaner daemon - clears "aged" documents at set intervals.
      this.ttl = {
        age: null,
        ttlInterval: null,
        daemon: null
      };
      this.setTTL(options.ttl || -1, options.ttlInterval);

      // currentMaxId - change manually at your own peril!
      this.maxId = 0;

      this.DynamicViews = [];

      // events
      this.events = {
        'insert': [],
        'update': [],
        'pre-insert': [],
        'pre-update': [],
        'close': [],
        'flushbuffer': [],
        'error': [],
        'delete': [],
        'warning': []
      };

      // changes are tracked by collection and aggregated by the db
      this.changes = [];

      // lightweight changes tracking (loki IDs only) for optimized db saving
      this.dirtyIds = [];

      // initialize optional user-supplied indices array ['age', 'lname', 'zip']
      var indices = [];
      if (options && options.indices) {
        if (Object.prototype.toString.call(options.indices) === '[object Array]') {
          indices = options.indices;
        } else if (typeof options.indices === 'string') {
          indices = [options.indices];
        } else {
          throw new TypeError('Indices needs to be a string or an array of strings');
        }
      }

      for (var idx = 0; idx < indices.length; idx++) {
        this.ensureIndex(indices[idx]);
      }

      function observerCallback(changes) {

        var changedObjects = typeof Set === 'function' ? new Set() : [];

        if (!changedObjects.add)
          changedObjects.add = function (object) {
            if (this.indexOf(object) === -1)
              this.push(object);
            return this;
          };

        changes.forEach(function (change) {
          changedObjects.add(change.object);
        });

        changedObjects.forEach(function (object) {
          if (!hasOwnProperty.call(object, '$loki'))
            return self.removeAutoUpdateObserver(object);
          try {
            self.update(object);
          } catch (err) { }
        });
      }

      this.observerCallback = observerCallback;

      //Compare changed object (which is a forced clone) with existing object and return the delta
      function getChangeDelta(obj, old) {
        if (old) {
          return getObjectDelta(old, obj);
        }
        else {
          return JSON.parse(JSON.stringify(obj));
        }
      }

      this.getChangeDelta = getChangeDelta;

      function getObjectDelta(oldObject, newObject) {
        var propertyNames = newObject !== null && typeof newObject === 'object' ? Object.keys(newObject) : null;
        if (propertyNames && propertyNames.length && ['string', 'boolean', 'number'].indexOf(typeof (newObject)) < 0) {
          var delta = {};
          for (var i = 0; i < propertyNames.length; i++) {
            var propertyName = propertyNames[i];
            if (newObject.hasOwnProperty(propertyName)) {
              if (!oldObject.hasOwnProperty(propertyName) || self.uniqueNames.indexOf(propertyName) >= 0 || propertyName == '$loki' || propertyName == 'meta') {
                delta[propertyName] = newObject[propertyName];
              }
              else {
                var propertyDelta = getObjectDelta(oldObject[propertyName], newObject[propertyName]);
                if (typeof propertyDelta !== "undefined" && propertyDelta != {}) {
                  delta[propertyName] = propertyDelta;
                }
              }
            }
          }
          return Object.keys(delta).length === 0 ? undefined : delta;
        }
        else {
          return oldObject === newObject ? undefined : newObject;
        }
      }

      this.getObjectDelta = getObjectDelta;

      // clear all the changes
      function flushChanges() {
        self.changes = [];
      }

      this.getChanges = function () {
        return self.changes;
      };

      this.flushChanges = flushChanges;

      this.setChangesApi = function (enabled) {
        self.disableChangesApi = !enabled;
        if (!enabled) { self.disableDeltaChangesApi = false; }
      };

      this.on('delete', function deleteCallback(obj) {
        if (!self.disableChangesApi) {
          self.createChange(self.name, 'R', obj);
        }
      });

      this.on('warning', function (warning) {
        self.lokiConsoleWrapper.warn(warning);
      });
      // for de-serialization purposes
      flushChanges();
    }

    Collection.prototype = new LokiEventEmitter();
    Collection.prototype.contructor = Collection;

    /*
      * For ChangeAPI default to clone entire object, for delta changes create object with only differences (+ $loki and meta)
      */
    Collection.prototype.createChange = function (name, op, obj, old) {
      this.changes.push({
        name: name,
        operation: op,
        obj: op == 'U' && !this.disableDeltaChangesApi ? this.getChangeDelta(obj, old) : JSON.parse(JSON.stringify(obj))
      });
    };

    Collection.prototype.insertMeta = function (obj) {
      var len, idx;

      if (this.disableMeta || !obj) {
        return;
      }

      // if batch insert
      if (Array.isArray(obj)) {
        len = obj.length;

        for (idx = 0; idx < len; idx++) {
          if (!obj[idx].hasOwnProperty('meta')) {
            obj[idx].meta = {};
          }

          obj[idx].meta.created = (new Date()).getTime();
          obj[idx].meta.revision = 0;
        }

        return;
      }

      // single object
      if (!obj.meta) {
        obj.meta = {};
      }

      obj.meta.created = (new Date()).getTime();
      obj.meta.revision = 0;
    };

    Collection.prototype.updateMeta = function (obj) {
      if (this.disableMeta || !obj) {
        return obj;
      }
      if (!this.disableFreeze) {
        obj = unFreeze(obj);
        obj.meta = unFreeze(obj.meta);
      }
      obj.meta.updated = (new Date()).getTime();
      obj.meta.revision += 1;
      return obj;
    };

    Collection.prototype.createInsertChange = function (obj) {
      this.createChange(this.name, 'I', obj);
    };

    Collection.prototype.createUpdateChange = function (obj, old) {
      this.createChange(this.name, 'U', obj, old);
    };

    Collection.prototype.insertMetaWithChange = function (obj) {
      this.insertMeta(obj);
      this.createInsertChange(obj);
    };

    Collection.prototype.updateMetaWithChange = function (obj, old, objFrozen) {
      obj = this.updateMeta(obj, objFrozen);
      this.createUpdateChange(obj, old);
      return obj;
    };

    Collection.prototype.lokiConsoleWrapper = {
      log: function () { },
      warn: function () { },
      error: function () { },
    };

    Collection.prototype.addAutoUpdateObserver = function (object) {
      if (!this.autoupdate || typeof Object.observe !== 'function')
        return;

      Object.observe(object, this.observerCallback, ['add', 'update', 'delete', 'reconfigure', 'setPrototype']);
    };

    Collection.prototype.removeAutoUpdateObserver = function (object) {
      if (!this.autoupdate || typeof Object.observe !== 'function')
        return;

      Object.unobserve(object, this.observerCallback);
    };

    /**
     * Adds a named collection transform to the collection
     * @param {string} name - name to associate with transform
     * @param {array} transform - an array of transformation 'step' objects to save into the collection
     * @memberof Collection
     * @example
     * users.addTransform('progeny', [
     *   {
     *     type: 'find',
     *     value: {
     *       'age': {'$lte': 40}
     *     }
     *   }
     * ]);
     *
     * var results = users.chain('progeny').data();
     */
    Collection.prototype.addTransform = function (name, transform) {
      if (this.transforms.hasOwnProperty(name)) {
        throw new Error("a transform by that name already exists");
      }

      this.transforms[name] = transform;
    };

    /**
     * Retrieves a named transform from the collection.
     * @param {string} name - name of the transform to lookup.
     * @memberof Collection
     */
    Collection.prototype.getTransform = function (name) {
      return this.transforms[name];
    };

    /**
     * Updates a named collection transform to the collection
     * @param {string} name - name to associate with transform
     * @param {object} transform - a transformation object to save into collection
     * @memberof Collection
     */
    Collection.prototype.setTransform = function (name, transform) {
      this.transforms[name] = transform;
    };

    /**
     * Removes a named collection transform from the collection
     * @param {string} name - name of collection transform to remove
     * @memberof Collection
     */
    Collection.prototype.removeTransform = function (name) {
      delete this.transforms[name];
    };

    Collection.prototype.byExample = function (template) {
      var k, obj, query;
      query = [];
      for (k in template) {
        if (!template.hasOwnProperty(k)) continue;
        query.push((
          obj = {},
          obj[k] = template[k],
          obj
        ));
      }
      return {
        '$and': query
      };
    };

    Collection.prototype.findObject = function (template) {
      return this.findOne(this.byExample(template));
    };

    Collection.prototype.findObjects = function (template) {
      return this.find(this.byExample(template));
    };

    /*----------------------------+
    | TTL daemon                  |
    +----------------------------*/
    Collection.prototype.ttlDaemonFuncGen = function () {
      var collection = this;
      var age = this.ttl.age;
      return function ttlDaemon() {
        var now = Date.now();
        var toRemove = collection.chain().where(function daemonFilter(member) {
          var timestamp = member.meta.updated || member.meta.created;
          var diff = now - timestamp;
          return age < diff;
        });
        toRemove.remove();
      };
    };

    /**
     * Updates or applies collection TTL settings.
     * @param {int} age - age (in ms) to expire document from collection
     * @param {int} interval - time (in ms) to clear collection of aged documents.
     * @memberof Collection
     */
    Collection.prototype.setTTL = function (age, interval) {
      if (age < 0) {
        clearInterval(this.ttl.daemon);
      } else {
        this.ttl.age = age;
        this.ttl.ttlInterval = interval;
        this.ttl.daemon = setInterval(this.ttlDaemonFuncGen(), interval);
      }
    };

    /*----------------------------+
    | INDEXING                    |
    +----------------------------*/

    /**
     * create a row filter that covers all documents in the collection
     */
    Collection.prototype.prepareFullDocIndex = function () {
      var len = this.data.length;
      var indexes = new Array(len);
      for (var i = 0; i < len; i += 1) {
        indexes[i] = i;
      }
      return indexes;
    };

    /**
     * Will allow reconfiguring certain collection options.
     * @param {boolean} options.adaptiveBinaryIndices - collection indices will be actively rebuilt rather than lazily
     * @memberof Collection
     */
    Collection.prototype.configureOptions = function (options) {
      options = options || {};

      if (options.hasOwnProperty('adaptiveBinaryIndices')) {
        this.adaptiveBinaryIndices = options.adaptiveBinaryIndices;

        // if switching to adaptive binary indices, make sure none are 'dirty'
        if (this.adaptiveBinaryIndices) {
          this.ensureAllIndexes();
        }
      }
    };

    /**
     * Ensure binary index on a certain field
     * @param {string} property - name of property to create binary index on
     * @param {boolean=} force - (Optional) flag indicating whether to construct index immediately
     * @memberof Collection
     */
    Collection.prototype.ensureIndex = function (property, force) {
      // optional parameter to force rebuild whether flagged as dirty or not
      if (typeof (force) === 'undefined') {
        force = false;
      }

      if (property === null || property === undefined) {
        throw new Error('Attempting to set index without an associated property');
      }

      if (this.binaryIndices[property] && !force) {
        if (!this.binaryIndices[property].dirty) return;
      }

      // if the index is already defined and we are using adaptiveBinaryIndices and we are not forcing a rebuild, return.
      if (this.adaptiveBinaryIndices === true && this.binaryIndices.hasOwnProperty(property) && !force) {
        return;
      }

      var index = {
        'name': property,
        'dirty': true,
        'values': this.prepareFullDocIndex()
      };
      this.binaryIndices[property] = index;

      var wrappedComparer =
        (function (prop, data) {
          var val1, val2;
          var propPath = ~prop.indexOf('.') ? prop.split('.') : false;
          return function (a, b) {
            if (propPath) {
              val1 = Utils.getIn(data[a], propPath, true);
              val2 = Utils.getIn(data[b], propPath, true);
            } else {
              val1 = data[a][prop];
              val2 = data[b][prop];
            }

            if (val1 !== val2) {
              if (Comparators.lt(val1, val2, false)) return -1;
              if (Comparators.gt(val1, val2, false)) return 1;
            }
            return 0;
          };
        })(property, this.data);

      index.values.sort(wrappedComparer);
      index.dirty = false;

      this.dirty = true; // for autosave scenarios
    };

    /**
     * Perform checks to determine validity/consistency of all binary indices
     * @param {object=} options - optional configuration object
     * @param {boolean} [options.randomSampling=false] - whether (faster) random sampling should be used
     * @param {number} [options.randomSamplingFactor=0.10] - percentage of total rows to randomly sample
     * @param {boolean} [options.repair=false] - whether to fix problems if they are encountered
     * @returns {string[]} array of index names where problems were found.
     * @memberof Collection
     * @example
     * // check all indices on a collection, returns array of invalid index names
     * var result = coll.checkAllIndexes({ repair: true, randomSampling: true, randomSamplingFactor: 0.15 });
     * if (result.length > 0) {
     *   results.forEach(function(name) {
     *     console.log('problem encountered with index : ' + name);
     *   });
     * }
     */
    Collection.prototype.checkAllIndexes = function (options) {
      var key, bIndices = this.binaryIndices;
      var results = [], result;

      for (key in bIndices) {
        if (hasOwnProperty.call(bIndices, key)) {
          result = this.checkIndex(key, options);
          if (!result) {
            results.push(key);
          }
        }
      }

      return results;
    };

    /**
     * Perform checks to determine validity/consistency of a binary index
     * @param {string} property - name of the binary-indexed property to check
     * @param {object=} options - optional configuration object
     * @param {boolean} [options.randomSampling=false] - whether (faster) random sampling should be used
     * @param {number} [options.randomSamplingFactor=0.10] - percentage of total rows to randomly sample
     * @param {boolean} [options.repair=false] - whether to fix problems if they are encountered
     * @returns {boolean} whether the index was found to be valid (before optional correcting).
     * @memberof Collection
     * @example
     * // full test
     * var valid = coll.checkIndex('name');
     * // full test with repair (if issues found)
     * valid = coll.checkIndex('name', { repair: true });
     * // random sampling (default is 10% of total document count)
     * valid = coll.checkIndex('name', { randomSampling: true });
     * // random sampling (sample 20% of total document count)
     * valid = coll.checkIndex('name', { randomSampling: true, randomSamplingFactor: 0.20 });
     * // random sampling (implied boolean)
     * valid = coll.checkIndex('name', { randomSamplingFactor: 0.20 });
     * // random sampling with repair (if issues found)
     * valid = coll.checkIndex('name', { repair: true, randomSampling: true });
     */
    Collection.prototype.checkIndex = function (property, options) {
      options = options || {};
      // if 'randomSamplingFactor' specified but not 'randomSampling', assume true
      if (options.randomSamplingFactor && options.randomSampling !== false) {
        options.randomSampling = true;
      }
      options.randomSamplingFactor = options.randomSamplingFactor || 0.1;
      if (options.randomSamplingFactor < 0 || options.randomSamplingFactor > 1) {
        options.randomSamplingFactor = 0.1;
      }

      var valid = true, idx, iter, pos, len, biv;

      // make sure we are passed a valid binary index name
      if (!this.binaryIndices.hasOwnProperty(property)) {
        throw new Error("called checkIndex on property without an index: " + property);
      }

      // if lazy indexing, rebuild only if flagged as dirty
      if (!this.adaptiveBinaryIndices) {
        this.ensureIndex(property);
      }

      biv = this.binaryIndices[property].values;
      len = biv.length;

      // if the index has an incorrect number of values
      if (len !== this.data.length) {
        if (options.repair) {
          this.ensureIndex(property, true);
        }
        return false;
      }

      if (len === 0) {
        return true;
      }

      var usingDotNotation = (property.indexOf('.') !== -1);

      if (len === 1) {
        valid = (biv[0] === 0);
      }
      else {
        if (options.randomSampling) {
          // validate first and last
          if (!LokiOps.$lte(Utils.getIn(this.data[biv[0]], property, usingDotNotation),
            Utils.getIn(this.data[biv[1]], property, usingDotNotation))) {
            valid = false;
          }
          if (!LokiOps.$lte(Utils.getIn(this.data[biv[len - 2]], property, usingDotNotation),
            Utils.getIn(this.data[biv[len - 1]], property, usingDotNotation))) {
            valid = false;
          }

          // if first and last positions are sorted correctly with their nearest neighbor,
          // continue onto random sampling phase...
          if (valid) {
            // # random samplings = total count * sampling factor
            iter = Math.floor((len - 1) * options.randomSamplingFactor);

            // for each random sampling, validate that the binary index is sequenced properly
            // with next higher value.
            for (idx = 0; idx < iter - 1; idx++) {
              // calculate random position
              pos = Math.floor(Math.random() * (len - 1));
              if (!LokiOps.$lte(Utils.getIn(this.data[biv[pos]], property, usingDotNotation),
                Utils.getIn(this.data[biv[pos + 1]], property, usingDotNotation))) {
                valid = false;
                break;
              }
            }
          }
        }
        else {
          // validate that the binary index is sequenced properly
          for (idx = 0; idx < len - 1; idx++) {
            if (!LokiOps.$lte(Utils.getIn(this.data[biv[idx]], property, usingDotNotation),
              Utils.getIn(this.data[biv[idx + 1]], property, usingDotNotation))) {
              valid = false;
              break;
            }
          }
        }
      }

      // if incorrectly sequenced and we are to fix problems, rebuild index
      if (!valid && options.repair) {
        this.ensureIndex(property, true);
      }

      return valid;
    };

    Collection.prototype.getBinaryIndexValues = function (property) {
      var idx, idxvals = this.binaryIndices[property].values;
      var result = [];

      for (idx = 0; idx < idxvals.length; idx++) {
        result.push(Utils.getIn(this.data[idxvals[idx]], property, true));
      }

      return result;
    };

    /**
     * Returns a named unique index
     * @param {string} field - indexed field name
     * @param {boolean} force - if `true`, will rebuild index; otherwise, function may return null
     */
    Collection.prototype.getUniqueIndex = function (field, force) {
      var index = this.constraints.unique[field];
      if (!index && force) {
        return this.ensureUniqueIndex(field);
      }
      return index;
    };

    Collection.prototype.ensureUniqueIndex = function (field) {
      var index = this.constraints.unique[field];
      if (!index) {
        // keep track of new unique index for regenerate after database (re)load.
        if (this.uniqueNames.indexOf(field) == -1) {
          this.uniqueNames.push(field);
        }
      }

      // if index already existed, (re)loading it will likely cause collisions, rebuild always
      this.constraints.unique[field] = index = new UniqueIndex(field);
      this.data.forEach(function (obj) {
        index.set(obj);
      });
      return index;
    };

    /**
     * Ensure all binary indices
     * @param {boolean} force - whether to force rebuild of existing lazy binary indices
     * @memberof Collection
     */
    Collection.prototype.ensureAllIndexes = function (force) {
      var key, bIndices = this.binaryIndices;
      for (key in bIndices) {
        if (hasOwnProperty.call(bIndices, key)) {
          this.ensureIndex(key, force);
        }
      }
    };

    /**
     * Internal method used to flag all lazy index as dirty
     */
    Collection.prototype.flagBinaryIndexesDirty = function () {
      var key, bIndices = this.binaryIndices;
      for (key in bIndices) {
        if (hasOwnProperty.call(bIndices, key)) {
          bIndices[key].dirty = true;
        }
      }
    };

    /**
     * Internal method used to flag a lazy index as dirty
     */
    Collection.prototype.flagBinaryIndexDirty = function (index) {
      if (this.binaryIndices[index])
        this.binaryIndices[index].dirty = true;
    };

    /**
     * Quickly determine number of documents in collection (or query)
     * @param {object=} query - (optional) query object to count results of
     * @returns {number} number of documents in the collection
     * @memberof Collection
     */
    Collection.prototype.count = function (query) {
      if (!query) {
        return this.data.length;
      }

      return this.chain().find(query).filteredrows.length;
    };

    /**
     * Rebuild idIndex
     */
    Collection.prototype.ensureId = function () {
      if (this.idIndex) {
        return;
      }
      var data = this.data,
        i = 0;
      var len = data.length;
      var index = new Array(len);
      for (i; i < len; i++) {
        index[i] = data[i].$loki;
      }
      this.idIndex = index;
    };

    /**
     * Rebuild idIndex async with callback - useful for background syncing with a remote server
     */
    Collection.prototype.ensureIdAsync = function (callback) {
      this.async(function () {
        this.ensureId();
      }, callback);
    };

    /**
     * Add a dynamic view to the collection
     * @param {string} name - name of dynamic view to add
     * @param {object=} options - options to configure dynamic view with
     * @param {boolean} [options.persistent=false] - indicates if view is to main internal results array in 'resultdata'
     * @param {string} [options.sortPriority='passive'] - 'passive' (sorts performed on call to data) or 'active' (after updates)
     * @param {number} options.minRebuildInterval - minimum rebuild interval (need clarification to docs here)
     * @returns {DynamicView} reference to the dynamic view added
     * @memberof Collection
     * @example
     * var pview = users.addDynamicView('progeny');
     * pview.applyFind({'age': {'$lte': 40}});
     * pview.applySimpleSort('name');
     *
     * var results = pview.data();
     **/

    Collection.prototype.addDynamicView = function (name, options) {
      var dv = new DynamicView(this, name, options);
      this.DynamicViews.push(dv);

      return dv;
    };

    /**
     * Remove a dynamic view from the collection
     * @param {string} name - name of dynamic view to remove
     * @memberof Collection
     **/
    Collection.prototype.removeDynamicView = function (name) {
      this.DynamicViews =
        this.DynamicViews.filter(function (dv) { return dv.name !== name; });
    };

    /**
     * Look up dynamic view reference from within the collection
     * @param {string} name - name of dynamic view to retrieve reference of
     * @returns {DynamicView} A reference to the dynamic view with that name
     * @memberof Collection
     **/
    Collection.prototype.getDynamicView = function (name) {
      for (var idx = 0; idx < this.DynamicViews.length; idx++) {
        if (this.DynamicViews[idx].name === name) {
          return this.DynamicViews[idx];
        }
      }

      return null;
    };

    /**
     * Applies a 'mongo-like' find query object and passes all results to an update function.
     * For filter function querying you should migrate to [updateWhere()]{@link Collection#updateWhere}.
     *
     * @param {object|function} filterObject - 'mongo-like' query object (or deprecated filterFunction mode)
     * @param {function} updateFunction - update function to run against filtered documents
     * @memberof Collection
     */
    Collection.prototype.findAndUpdate = function (filterObject, updateFunction) {
      if (typeof (filterObject) === "function") {
        this.updateWhere(filterObject, updateFunction);
      }
      else {
        this.chain().find(filterObject).update(updateFunction);
      }
    };

    /**
     * Applies a 'mongo-like' find query object removes all documents which match that filter.
     *
     * @param {object} filterObject - 'mongo-like' query object
     * @memberof Collection
     */
    Collection.prototype.findAndRemove = function (filterObject) {
      this.chain().find(filterObject).remove();
    };

    /**
     * Adds object(s) to collection, ensure object(s) have meta properties, clone it if necessary, etc.
     * @param {(object|array)} doc - the document (or array of documents) to be inserted
     * @param {boolean=} overrideAdaptiveIndices - (optional) if `true`, adaptive indicies will be
     *   temporarily disabled and then fully rebuilt after batch. This will be faster for
     *   large inserts, but slower for small/medium inserts in large collections
     * @returns {(object|array)} document or documents inserted
     * @memberof Collection
     * @example
     * users.insert({
     *     name: 'Odin',
     *     age: 50,
     *     address: 'Asgard'
     * });
     *
     * // alternatively, insert array of documents
     * users.insert([{ name: 'Thor', age: 35}, { name: 'Loki', age: 30}]);
     */
    Collection.prototype.insert = function (doc, overrideAdaptiveIndices) {
      if (!Array.isArray(doc)) {
        return this.insertOne(doc);
      }

      // holder to the clone of the object inserted if collections is set to clone objects
      var obj;
      var results = [];

      // if not cloning, disable adaptive binary indices for the duration of the batch insert,
      // followed by lazy rebuild and re-enabling adaptive indices after batch insert.
      var adaptiveBatchOverride = overrideAdaptiveIndices && !this.cloneObjects &&
        this.adaptiveBinaryIndices && Object.keys(this.binaryIndices).length > 0;

      if (adaptiveBatchOverride) {
        this.adaptiveBinaryIndices = false;
      }

      try {
        this.emit('pre-insert', doc);
        for (var i = 0, len = doc.length; i < len; i++) {
          obj = this.insertOne(doc[i], true);
          if (!obj) {
            return undefined;
          }
          results.push(obj);
        }
      } finally {
        if (adaptiveBatchOverride) {
          this.ensureAllIndexes();
          this.adaptiveBinaryIndices = true;
        }
      }

      // at the 'batch' level, if clone option is true then emitted docs are clones
      this.emit('insert', results);

      // if clone option is set, clone return values
      results = this.cloneObjects ? clone(results, this.cloneMethod) : results;

      return results.length === 1 ? results[0] : results;
    };

    /**
     * Adds a single object, ensures it has meta properties, clone it if necessary, etc.
     * @param {object} doc - the document to be inserted
     * @param {boolean} bulkInsert - quiet pre-insert and insert event emits
     * @returns {object} document or 'undefined' if there was a problem inserting it
     */
    Collection.prototype.insertOne = function (doc, bulkInsert) {
      var err = null;
      var returnObj;

      if (typeof doc !== 'object') {
        err = new TypeError('Document needs to be an object');
      } else if (doc === null) {
        err = new TypeError('Object cannot be null');
      }

      if (err !== null) {
        this.emit('error', err);
        throw err;
      }

      // if configured to clone, do so now... otherwise just use same obj reference
      var obj = this.cloneObjects ? clone(doc, this.cloneMethod) : doc;
      if (!this.disableFreeze) {
        obj = unFreeze(obj);
      }

      if (!this.disableMeta) {
        if (typeof obj.meta === 'undefined') {
          obj.meta = {
            revision: 0,
            created: 0
          };
        } else if (!this.disableFreeze) {
          obj.meta = unFreeze(obj.meta);
        }
      }

      // both 'pre-insert' and 'insert' events are passed internal data reference even when cloning
      // insert needs internal reference because that is where loki itself listens to add meta
      if (!bulkInsert) {
        this.emit('pre-insert', obj);
      }
      if (!this.add(obj)) {
        return undefined;
      }

      // update meta and store changes if ChangesAPI is enabled
      // (moved from "insert" event listener to allow internal reference to be used)
      if (this.disableChangesApi) {
        this.insertMeta(obj);
      } else {
        this.insertMetaWithChange(obj);
      }

      if (!this.disableFreeze) {
        deepFreeze(obj);
      }

      // if cloning is enabled, emit insert event with clone of new object
      returnObj = this.cloneObjects ? clone(obj, this.cloneMethod) : obj;

      if (!bulkInsert) {
        this.emit('insert', returnObj);
      }

      this.addAutoUpdateObserver(returnObj);

      return returnObj;
    };

    /**
     * Empties the collection.
     * @param {object=} options - configure clear behavior
     * @param {bool=} [options.removeIndices=false] - whether to remove indices in addition to data
     * @memberof Collection
     */
    Collection.prototype.clear = function (options) {
      var self = this;

      options = options || {};

      this.data = [];
      this.idIndex = null;
      this.cachedIndex = null;
      this.cachedBinaryIndex = null;
      this.cachedData = null;
      this.maxId = 0;
      this.DynamicViews = [];
      this.dirty = true;
      this.constraints = {
        unique: {},
        exact: {}
      };

      // if removing indices entirely
      if (options.removeIndices === true) {
        this.binaryIndices = {};
        this.uniqueNames = [];
      }
      // clear indices but leave definitions in place
      else {
        // clear binary indices
        var keys = Object.keys(this.binaryIndices);
        keys.forEach(function (biname) {
          self.binaryIndices[biname].dirty = false;
          self.binaryIndices[biname].values = [];
        });
      }
    };

    /**
     * Updates an object and notifies collection that the document has changed.
     * @param {object} doc - document to update within the collection
     * @memberof Collection
     */
    Collection.prototype.update = function (doc) {
      var adaptiveBatchOverride, k, len;

      if (Array.isArray(doc)) {
        len = doc.length;

        // if not cloning, disable adaptive binary indices for the duration of the batch update,
        // followed by lazy rebuild and re-enabling adaptive indices after batch update.
        adaptiveBatchOverride = !this.cloneObjects &&
          this.adaptiveBinaryIndices && Object.keys(this.binaryIndices).length > 0;

        if (adaptiveBatchOverride) {
          this.adaptiveBinaryIndices = false;
        }

        try {
          for (k = 0; k < len; k += 1) {
            this.update(doc[k]);
          }
        }
        finally {
          if (adaptiveBatchOverride) {
            this.ensureAllIndexes();
            this.adaptiveBinaryIndices = true;
          }
        }

        return;
      }

      // verify object is a properly formed document
      if (!hasOwnProperty.call(doc, '$loki')) {
        throw new Error('Trying to update unsynced document. Please save the document first by using insert() or addMany()');
      }
      try {
        this.startTransaction();
        var arr = this.get(doc.$loki, true),
          oldInternal,   // ref to existing obj
          newInternal, // ref to new internal obj
          position,
          self = this;

        if (!arr) {
          throw new Error('Trying to update a document not in collection.');
        }

        oldInternal = arr[0]; // -internal- obj ref
        position = arr[1]; // position in data array

        // if configured to clone, do so now... otherwise just use same obj reference
        newInternal = this.cloneObjects || (!this.disableDeltaChangesApi && this.disableFreeze) ? clone(doc, this.cloneMethod) : doc;

        this.emit('pre-update', doc);

        this.uniqueNames.forEach(function (key) {
          self.getUniqueIndex(key, true).update(oldInternal, newInternal);
        });

        // operate the update
        this.data[position] = newInternal;

        if (newInternal !== doc) {
          this.addAutoUpdateObserver(doc);
        }

        // now that we can efficiently determine the data[] position of newly added document,
        // submit it for all registered DynamicViews to evaluate for inclusion/exclusion
        for (var idx = 0; idx < this.DynamicViews.length; idx++) {
          this.DynamicViews[idx].evaluateDocument(position, false);
        }

        var key;
        if (this.adaptiveBinaryIndices) {
          // for each binary index defined in collection, immediately update rather than flag for lazy rebuild
          var bIndices = this.binaryIndices;
          for (key in bIndices) {
            this.adaptiveBinaryIndexUpdate(position, key);
          }
        }
        else {
          this.flagBinaryIndexesDirty();
        }

        this.idIndex[position] = newInternal.$loki;
        //this.flagBinaryIndexesDirty();

        if (this.isIncremental) {
          this.dirtyIds.push(newInternal.$loki);
        }

        this.commit();
        this.dirty = true; // for autosave scenarios

        // update meta and store changes if ChangesAPI is enabled
        if (this.disableChangesApi) {
          newInternal = this.updateMeta(newInternal);
        } else {
          newInternal = this.updateMetaWithChange(newInternal, oldInternal);
        }

        if (!this.disableFreeze) {
          deepFreeze(newInternal);
        }

        var returnObj;

        // if cloning is enabled, emit 'update' event and return with clone of new object
        if (this.cloneObjects) {
          returnObj = clone(newInternal, this.cloneMethod);
        }
        else {
          returnObj = newInternal;
        }

        this.emit('update', returnObj, oldInternal);
        return returnObj;
      } catch (err) {
        this.rollback();
        this.lokiConsoleWrapper.error(err.message);
        this.emit('error', err);
        throw (err); // re-throw error so user does not think it succeeded
      }
    };

    /**
     * Add object to collection
     */
    Collection.prototype.add = function (obj) {
      // if parameter isn't object exit with throw
      if ('object' !== typeof obj) {
        throw new TypeError('Object being added needs to be an object');
      }
      // if object you are adding already has id column it is either already in the collection
      // or the object is carrying its own 'id' property.  If it also has a meta property,
      // then this is already in collection so throw error, otherwise rename to originalId and continue adding.
      if (typeof (obj.$loki) !== 'undefined') {
        throw new Error('Document is already in collection, please use update()');
      }

      /*
       * try adding object to collection
       */
      try {
        this.startTransaction();
        this.maxId++;

        if (isNaN(this.maxId)) {
          this.maxId = (this.data[this.data.length - 1].$loki + 1);
        }

        var newId = this.maxId;
        obj.$loki = newId;

        if (!this.disableMeta) {
          obj.meta.version = 0;
        }

        for (var i = 0, len = this.uniqueNames.length; i < len; i ++) {
          this.getUniqueIndex(this.uniqueNames[i], true).set(obj);
        }

        if (this.idIndex) {
          this.idIndex.push(newId);
        }

        if (this.isIncremental) {
          this.dirtyIds.push(newId);
        }

        // add the object
        this.data.push(obj);

        var addedPos = this.data.length - 1;

        // now that we can efficiently determine the data[] position of newly added document,
        // submit it for all registered DynamicViews to evaluate for inclusion/exclusion
        var dvlen = this.DynamicViews.length;
        for (i = 0; i < dvlen; i++) {
          this.DynamicViews[i].evaluateDocument(addedPos, true);
        }

        if (this.adaptiveBinaryIndices) {
          // for each binary index defined in collection, immediately update rather than flag for lazy rebuild
          var bIndices = this.binaryIndices;
          for (var key in bIndices) {
            this.adaptiveBinaryIndexInsert(addedPos, key);
          }
        }
        else {
          this.flagBinaryIndexesDirty();
        }

        this.commit();
        this.dirty = true; // for autosave scenarios

        return (this.cloneObjects) ? (clone(obj, this.cloneMethod)) : (obj);
      } catch (err) {
        this.rollback();
        this.lokiConsoleWrapper.error(err.message);
        this.emit('error', err);
        throw (err); // re-throw error so user does not think it succeeded
      }
    };

    /**
     * Applies a filter function and passes all results to an update function.
     *
     * @param {function} filterFunction - filter function whose results will execute update
     * @param {function} updateFunction - update function to run against filtered documents
     * @memberof Collection
     */
    Collection.prototype.updateWhere = function (filterFunction, updateFunction) {
      var results = this.where(filterFunction),
        i = 0,
        obj;
      try {
        for (i; i < results.length; i++) {
          obj = updateFunction(results[i]);
          this.update(obj);
        }

      } catch (err) {
        this.rollback();
        this.lokiConsoleWrapper.error(err.message);
      }
    };

    /**
     * Remove all documents matching supplied filter function.
     * For 'mongo-like' querying you should migrate to [findAndRemove()]{@link Collection#findAndRemove}.
     * @param {function|object} query - query object to filter on
     * @memberof Collection
     */
    Collection.prototype.removeWhere = function (query) {
      var list;
      if (typeof query === 'function') {
        list = this.data.filter(query);
        this.remove(list);
      } else {
        this.chain().find(query).remove();
      }
    };

    Collection.prototype.removeDataOnly = function () {
      this.remove(this.data.slice());
    };

    /**
     * Internal method to remove a batch of documents from the collection.
     * @param {number[]} positions - data/idIndex positions to remove
     */
    Collection.prototype.removeBatchByPositions = function (positions) {
      var len = positions.length;
      var xo = {};
      var dlen, didx, idx;
      var bic = Object.keys(this.binaryIndices).length;
      var uic = Object.keys(this.constraints.unique).length;
      var adaptiveOverride = this.adaptiveBinaryIndices && Object.keys(this.binaryIndices).length > 0;
      var doc, self = this;

      try {
        this.startTransaction();

        // create hashobject for positional removal inclusion tests...
        // all keys defined in this hashobject represent $loki ids of the documents to remove.
        this.ensureId();
        for (idx = 0; idx < len; idx++) {
          xo[this.idIndex[positions[idx]]] = true;
        }

        // if we will need to notify dynamic views and/or binary indices to update themselves...
        dlen = this.DynamicViews.length;
        if ((dlen > 0) || (bic > 0) || (uic > 0)) {
          if (dlen > 0) {
            // notify dynamic views to remove relevant documents at data positions
            for (didx = 0; didx < dlen; didx++) {
              // notify dv of remove (passing batch/array of positions)
              this.DynamicViews[didx].removeDocument(positions);
            }
          }

          // notify binary indices to update
          if (this.adaptiveBinaryIndices && !adaptiveOverride) {
            // for each binary index defined in collection, immediately update rather than flag for lazy rebuild
            var key, bIndices = this.binaryIndices;

            for (key in bIndices) {
              this.adaptiveBinaryIndexRemove(positions, key);
            }
          }
          else {
            this.flagBinaryIndexesDirty();
          }

          if (uic) {
            this.uniqueNames.forEach(function (key) {
              var index = self.getUniqueIndex(key);
              if (index) {
                for (idx = 0; idx < len; idx++) {
                  doc = self.data[positions[idx]];
                  if (doc[key] !== null && doc[key] !== undefined) {
                    index.remove(doc[key]);
                  }
                }
              }
            });
          }
        }

        // emit 'delete' events only of listeners are attached.
        // since data not removed yet, in future we can emit single delete event with array...
        // for now that might be breaking change to put in potential 1.6 or LokiDB (lokijs2) version
        if (!this.disableChangesApi || this.events.delete.length > 1) {
          for (idx = 0; idx < len; idx++) {
            this.emit('delete', this.data[positions[idx]]);
          }
        }

        // remove from data[] :
        // filter collection data for items not in inclusion hashobject
        this.data = this.data.filter(function (obj) {
          return !xo[obj.$loki];
        });

        if (this.isIncremental) {
          for(idx=0; idx < len; idx++) {
            this.dirtyIds.push(this.idIndex[positions[idx]]);
          }
        }

        // remove from idIndex[] :
        // filter idIndex for items not in inclusion hashobject
        this.idIndex = this.idIndex.filter(function (id) {
          return !xo[id];
        });

        if (this.adaptiveBinaryIndices && adaptiveOverride) {
          this.adaptiveBinaryIndices = false;
          this.ensureAllIndexes(true);
          this.adaptiveBinaryIndices = true;
        }

        this.commit();

        // flag collection as dirty for autosave
        this.dirty = true;
      }
      catch (err) {
        this.rollback();
        if (adaptiveOverride) {
          this.adaptiveBinaryIndices = true;
        }
        this.lokiConsoleWrapper.error(err.message);
        this.emit('error', err);
        return null;
      }
    };

    /**
     *  Internal method called by remove()
     * @param {object[]|number[]} batch - array of documents or $loki ids to remove
     */
    Collection.prototype.removeBatch = function (batch) {
      var len = batch.length,
        dlen = this.data.length,
        idx;
      var xlt = {};
      var posx = [];

      // create lookup hashobject to translate $loki id to position
      for (idx = 0; idx < dlen; idx++) {
        xlt[this.data[idx].$loki] = idx;
      }

      // iterate the batch
      for (idx = 0; idx < len; idx++) {
        if (typeof (batch[idx]) === 'object') {
          posx.push(xlt[batch[idx].$loki]);
        }
        else {
          posx.push(xlt[batch[idx]]);
        }
      }

      this.removeBatchByPositions(posx);
    };

    /**
     * Remove a document from the collection
     * @param {object} doc - document to remove from collection
     * @memberof Collection
     */
    Collection.prototype.remove = function (doc) {
      var frozen;

      if (typeof doc === 'number') {
        doc = this.get(doc);
      }

      if ('object' !== typeof doc) {
        throw new Error('Parameter is not an object');
      }
      if (Array.isArray(doc)) {
        this.removeBatch(doc);
        return;
      }

      if (!hasOwnProperty.call(doc, '$loki')) {
        throw new Error('Object is not a document stored in the collection');
      }

      try {
        this.startTransaction();
        var arr = this.get(doc.$loki, true),
          // obj = arr[0],
          position = arr[1];
        var self = this;
        this.uniqueNames.forEach(function (key) {
          if (doc[key] !== null && typeof doc[key] !== 'undefined') {
            var index = self.getUniqueIndex(key);
            if (index) {
              index.remove(doc[key]);
            }
          }
        });
        // now that we can efficiently determine the data[] position of newly added document,
        // submit it for all registered DynamicViews to remove
        for (var idx = 0; idx < this.DynamicViews.length; idx++) {
          this.DynamicViews[idx].removeDocument(position);
        }

        if (this.adaptiveBinaryIndices) {
          // for each binary index defined in collection, immediately update rather than flag for lazy rebuild
          var key, bIndices = this.binaryIndices;
          for (key in bIndices) {
            this.adaptiveBinaryIndexRemove(position, key);
          }
        }
        else {
          this.flagBinaryIndexesDirty();
        }

        this.data.splice(position, 1);
        this.removeAutoUpdateObserver(doc);

        // remove id from idIndex
        this.idIndex.splice(position, 1);

        if (this.isIncremental) {
          this.dirtyIds.push(doc.$loki);
        }

        this.commit();
        this.dirty = true; // for autosave scenarios
        this.emit('delete', arr[0]);

        if (!this.disableFreeze) {
          doc = unFreeze(doc);
        }
        delete doc.$loki;
        delete doc.meta;
        if (!this.disableFreeze) {
          freeze(doc);
        }
        return doc;

      } catch (err) {
        this.rollback();
        this.lokiConsoleWrapper.error(err.message);
        this.emit('error', err);
        return null;
      }
    };

    /*---------------------+
    | Finding methods     |
    +----------------------*/

    /**
     * Get by Id - faster than other methods because of the searching algorithm
     * @param {int} id - $loki id of document you want to retrieve
     * @param {boolean} returnPosition - if 'true' we will return [object, position]
     * @returns {(object|array|null)} Object reference if document was found, null if not,
     *     or an array if 'returnPosition' was passed.
     * @memberof Collection
     */
    Collection.prototype.get = function (id, returnPosition) {
      if (!this.idIndex) {
        this.ensureId();
      }

      var retpos = returnPosition || false,
        data = this.idIndex,
        max = data.length - 1,
        min = 0,
        mid = (min + max) >> 1;

      id = typeof id === 'number' ? id : parseInt(id, 10);

      if (isNaN(id)) {
        throw new TypeError('Passed id is not an integer');
      }

      while (data[min] < data[max]) {
        mid = (min + max) >> 1;

        if (data[mid] < id) {
          min = mid + 1;
        } else {
          max = mid;
        }
      }

      if (max === min && data[min] === id) {
        if (retpos) {
          return [this.data[min], min];
        }
        return this.data[min];
      }
      return null;

    };

    /**
     * Perform binary range lookup for the data[dataPosition][binaryIndexName] property value
     *    Since multiple documents may contain the same value (which the index is sorted on),
     *    we hone in on range and then linear scan range to find exact index array position.
     * @param {int} dataPosition : coll.data array index/position
     * @param {string} binaryIndexName : index to search for dataPosition in
     */
    Collection.prototype.getBinaryIndexPosition = function (dataPosition, binaryIndexName) {
      var val = Utils.getIn(this.data[dataPosition], binaryIndexName, true);
      var index = this.binaryIndices[binaryIndexName].values;

      // i think calculateRange can probably be moved to collection
      // as it doesn't seem to need resultset.  need to verify
      var range = this.calculateRange("$eq", binaryIndexName, val);

      if (range[0] === 0 && range[1] === -1) {
        // uhoh didn't find range
        return null;
      }

      var min = range[0];
      var max = range[1];

      // narrow down the sub-segment of index values
      // where the indexed property value exactly matches our
      // value and then linear scan to find exact -index- position
      for (var idx = min; idx <= max; idx++) {
        if (index[idx] === dataPosition) return idx;
      }

      // uhoh
      return null;
    };

    /**
     * Adaptively insert a selected item to the index.
     * @param {int} dataPosition : coll.data array index/position
     * @param {string} binaryIndexName : index to search for dataPosition in
     */
    Collection.prototype.adaptiveBinaryIndexInsert = function (dataPosition, binaryIndexName) {
      var usingDotNotation = (binaryIndexName.indexOf('.') !== -1);
      var index = this.binaryIndices[binaryIndexName].values;
      var val = Utils.getIn(this.data[dataPosition], binaryIndexName, usingDotNotation);

      // If you are inserting a javascript Date value into a binary index, convert to epoch time
      if (this.serializableIndices === true && val instanceof Date) {
        this.data[dataPosition][binaryIndexName] = val.getTime();
        val = Utils.getIn(this.data[dataPosition], binaryIndexName);
      }

      var idxPos = (index.length === 0) ? 0 : this.calculateRangeStart(binaryIndexName, val, true, usingDotNotation);

      // insert new data index into our binary index at the proper sorted location for relevant property calculated by idxPos.
      // doing this after adjusting dataPositions so no clash with previous item at that position.
      this.binaryIndices[binaryIndexName].values.splice(idxPos, 0, dataPosition);
    };

    /**
     * Adaptively update a selected item within an index.
     * @param {int} dataPosition : coll.data array index/position
     * @param {string} binaryIndexName : index to search for dataPosition in
     */
    Collection.prototype.adaptiveBinaryIndexUpdate = function (dataPosition, binaryIndexName) {
      // linear scan needed to find old position within index unless we optimize for clone scenarios later
      // within (my) node 5.6.0, the following for() loop with strict compare is -much- faster than indexOf()
      var idxPos,
        index = this.binaryIndices[binaryIndexName].values,
        len = index.length;

      for (idxPos = 0; idxPos < len; idxPos++) {
        if (index[idxPos] === dataPosition) break;
      }

      //var idxPos = this.binaryIndices[binaryIndexName].values.indexOf(dataPosition);
      this.binaryIndices[binaryIndexName].values.splice(idxPos, 1);

      //this.adaptiveBinaryIndexRemove(dataPosition, binaryIndexName, true);
      this.adaptiveBinaryIndexInsert(dataPosition, binaryIndexName);
    };

    /**
     * Adaptively remove a selected item from the index.
     * @param {number|number[]} dataPosition : coll.data array index/position
     * @param {string} binaryIndexName : index to search for dataPosition in
     */
    Collection.prototype.adaptiveBinaryIndexRemove = function (dataPosition, binaryIndexName, removedFromIndexOnly) {
      var bi = this.binaryIndices[binaryIndexName];
      var len, idx, rmidx, rmlen, rxo = {};
      var curr, shift, idxPos;

      if (Array.isArray(dataPosition)) {
        // when called from chained remove, and only one document in array,
        // it will be faster to use old algorithm
        rmlen = dataPosition.length;
        if (rmlen === 1) {
          dataPosition = dataPosition[0];
        }
        // we were passed an array (batch) of documents so use this 'batch optimized' algorithm
        else {
          for (rmidx = 0; rmidx < rmlen; rmidx++) {
            rxo[dataPosition[rmidx]] = true;
          }

          // remove document from index (with filter function)
          bi.values = bi.values.filter(function (di) { return !rxo[di]; });

          // if we passed this optional flag parameter, we are calling from adaptiveBinaryIndexUpdate,
          // in which case data positions stay the same.
          if (removedFromIndexOnly === true) {
            return;
          }

          var sortedPositions = dataPosition.slice();
          sortedPositions.sort(function (a, b) { return a - b; });

          // to remove holes, we need to 'shift down' the index's data array positions
          // we need to adjust array positions -1 for each index data positions greater than removed positions
          len = bi.values.length;
          for (idx = 0; idx < len; idx++) {
            curr = bi.values[idx];
            shift = 0;
            for (rmidx = 0; rmidx < rmlen && curr > sortedPositions[rmidx]; rmidx++) {
              shift++;
            }
            bi.values[idx] -= shift;
          }

          // batch processed, bail out
          return;
        }

        // not a batch so continue...
      }

      idxPos = this.getBinaryIndexPosition(dataPosition, binaryIndexName);

      if (idxPos === null) {
        // throw new Error('unable to determine binary index position');
        return null;
      }

      // remove document from index (with splice)
      bi.values.splice(idxPos, 1);

      // if we passed this optional flag parameter, we are calling from adaptiveBinaryIndexUpdate,
      // in which case data positions stay the same.
      if (removedFromIndexOnly === true) {
        return;
      }

      // since index stores data array positions, if we remove a document
      // we need to adjust array positions -1 for all document positions greater than removed position
      len = bi.values.length;
      for (idx = 0; idx < len; idx++) {
        if (bi.values[idx] > dataPosition) {
          bi.values[idx]--;
        }
      }
    };

    /**
     * Internal method used for index maintenance and indexed searching.
     * Calculates the beginning of an index range for a given value.
     * For index maintainance (adaptive:true), we will return a valid index position to insert to.
     * For querying (adaptive:false/undefined), we will :
     *    return lower bound/index of range of that value (if found)
     *    return next lower index position if not found (hole)
     * If index is empty it is assumed to be handled at higher level, so
     * this method assumes there is at least 1 document in index.
     *
     * @param {string} prop - name of property which has binary index
     * @param {any} val - value to find within index
     * @param {bool?} adaptive - if true, we will return insert position
     */
    Collection.prototype.calculateRangeStart = function (prop, val, adaptive, usingDotNotation) {
      var rcd = this.data;
      var index = this.binaryIndices[prop].values;
      var min = 0;
      var max = index.length - 1;
      var mid = 0;

      if (index.length === 0) {
        return -1;
      }

      var minVal = Utils.getIn(rcd[index[min]], prop, usingDotNotation);
      var maxVal = Utils.getIn(rcd[index[max]], prop, usingDotNotation);

      // hone in on start position of value
      while (min < max) {
        mid = (min + max) >> 1;

        if (Comparators.lt(Utils.getIn(rcd[index[mid]], prop, usingDotNotation), val, false)) {
          min = mid + 1;
        } else {
          max = mid;
        }
      }

      var lbound = min;

      // found it... return it
      if (Comparators.aeq(val, Utils.getIn(rcd[index[lbound]], prop, usingDotNotation))) {
        return lbound;
      }

      // if not in index and our value is less than the found one
      if (Comparators.lt(val, Utils.getIn(rcd[index[lbound]], prop, usingDotNotation), false)) {
        return adaptive ? lbound : lbound - 1;
      }

      // not in index and our value is greater than the found one
      return adaptive ? lbound + 1 : lbound;
    };

    /**
     * Internal method used for indexed $between.  Given a prop (index name), and a value
     * (which may or may not yet exist) this will find the final position of that upper range value.
     */
    Collection.prototype.calculateRangeEnd = function (prop, val, usingDotNotation) {
      var rcd = this.data;
      var index = this.binaryIndices[prop].values;
      var min = 0;
      var max = index.length - 1;
      var mid = 0;

      if (index.length === 0) {
        return -1;
      }

      var minVal = Utils.getIn(rcd[index[min]], prop, usingDotNotation);
      var maxVal = Utils.getIn(rcd[index[max]], prop, usingDotNotation);

      // hone in on start position of value
      while (min < max) {
        mid = (min + max) >> 1;

        if (Comparators.lt(val, Utils.getIn(rcd[index[mid]], prop, usingDotNotation), false)) {
          max = mid;
        } else {
          min = mid + 1;
        }
      }

      var ubound = max;

      // only eq if last element in array is our val
      if (Comparators.aeq(val, Utils.getIn(rcd[index[ubound]], prop, usingDotNotation))) {
        return ubound;
      }

      // if not in index and our value is less than the found one
      if (Comparators.gt(val, Utils.getIn(rcd[index[ubound]], prop, usingDotNotation), false)) {
        return ubound + 1;
      }

      // either hole or first nonmatch
      if (Comparators.aeq(val, Utils.getIn(rcd[index[ubound - 1]], prop, usingDotNotation))) {
        return ubound - 1;
      }

      // hole, so ubound if nearest gt than the val we were looking for
      return ubound;
    };

    /**
     * calculateRange() - Binary Search utility method to find range/segment of values matching criteria.
     *    this is used for collection.find() and first find filter of resultset/dynview
     *    slightly different than get() binary search in that get() hones in on 1 value,
     *    but we have to hone in on many (range)
     * @param {string} op - operation, such as $eq
     * @param {string} prop - name of property to calculate range for
     * @param {object} val - value to use for range calculation.
     * @returns {array} [start, end] index array positions
     */
    Collection.prototype.calculateRange = function (op, prop, val) {
      var rcd = this.data;
      var index = this.binaryIndices[prop].values;
      var min = 0;
      var max = index.length - 1;
      var mid = 0;
      var lbound, lval;
      var ubound, uval;

      // when no documents are in collection, return empty range condition
      if (rcd.length === 0) {
        return [0, -1];
      }

      var usingDotNotation = (prop.indexOf('.') !== -1);

      var minVal = Utils.getIn(rcd[index[min]], prop, usingDotNotation);
      var maxVal = Utils.getIn(rcd[index[max]], prop, usingDotNotation);

      // if value falls outside of our range return [0, -1] to designate no results
      switch (op) {
        case '$eq':
        case '$aeq':
          if (Comparators.lt(val, minVal, false) || Comparators.gt(val, maxVal, false)) {
            return [0, -1];
          }
          break;
        case '$dteq':
          if (Comparators.lt(val, minVal, false) || Comparators.gt(val, maxVal, false)) {
            return [0, -1];
          }
          break;
        case '$gt':
          // none are within range
          if (Comparators.gt(val, maxVal, true)) {
            return [0, -1];
          }
          // all are within range
          if (Comparators.gt(minVal, val, false)) {
            return [min, max];
          }
          break;
        case '$gte':
          // none are within range
          if (Comparators.gt(val, maxVal, false)) {
            return [0, -1];
          }
          // all are within range
          if (Comparators.gt(minVal, val, true)) {
            return [min, max];
          }
          break;
        case '$lt':
          // none are within range
          if (Comparators.lt(val, minVal, true)) {
            return [0, -1];
          }
          // all are within range
          if (Comparators.lt(maxVal, val, false)) {
            return [min, max];
          }
          break;
        case '$lte':
          // none are within range
          if (Comparators.lt(val, minVal, false)) {
            return [0, -1];
          }
          // all are within range
          if (Comparators.lt(maxVal, val, true)) {
            return [min, max];
          }
          break;
        case '$between':
          // none are within range (low range is greater)
          if (Comparators.gt(val[0], maxVal, false)) {
            return [0, -1];
          }
          // none are within range (high range lower)
          if (Comparators.lt(val[1], minVal, false)) {
            return [0, -1];
          }

          lbound = this.calculateRangeStart(prop, val[0], false, usingDotNotation);
          ubound = this.calculateRangeEnd(prop, val[1], usingDotNotation);

          if (lbound < 0) lbound++;
          if (ubound > max) ubound--;

          if (!Comparators.gt(Utils.getIn(rcd[index[lbound]], prop, usingDotNotation), val[0], true)) lbound++;
          if (!Comparators.lt(Utils.getIn(rcd[index[ubound]], prop, usingDotNotation), val[1], true)) ubound--;

          if (ubound < lbound) return [0, -1];

          return ([lbound, ubound]);
        case '$in':
          var idxset = [],
            segResult = [];
          // query each value '$eq' operator and merge the seqment results.
          for (var j = 0, len = val.length; j < len; j++) {
            var seg = this.calculateRange('$eq', prop, val[j]);

            for (var i = seg[0]; i <= seg[1]; i++) {
              if (idxset[i] === undefined) {
                idxset[i] = true;
                segResult.push(i);
              }
            }
          }
          return segResult;
      }

      // determine lbound where needed
      switch (op) {
        case '$eq':
        case '$aeq':
        case '$dteq':
        case '$gte':
        case '$lt':
          lbound = this.calculateRangeStart(prop, val, false, usingDotNotation);
          lval = Utils.getIn(rcd[index[lbound]], prop, usingDotNotation);
          break;
        default: break;
      }

      // determine ubound where needed
      switch (op) {
        case '$eq':
        case '$aeq':
        case '$dteq':
        case '$lte':
        case '$gt':
          ubound = this.calculateRangeEnd(prop, val, usingDotNotation);
          uval = Utils.getIn(rcd[index[ubound]], prop, usingDotNotation);
          break;
        default: break;
      }


      switch (op) {
        case '$eq':
        case '$aeq':
        case '$dteq':
          // if hole (not found)
          if (!Comparators.aeq(lval, val)) {
            return [0, -1];
          }

          return [lbound, ubound];

        case '$gt':
          // if hole (not found) ub position is already greater
          if (!Comparators.aeq(Utils.getIn(rcd[index[ubound]], prop, usingDotNotation), val)) {
            return [ubound, max];
          }
          // otherwise (found) so ubound is still equal, get next
          return [ubound + 1, max];

        case '$gte':
          // if hole (not found) lb position marks left outside of range
          if (!Comparators.aeq(Utils.getIn(rcd[index[lbound]], prop, usingDotNotation), val)) {
            return [lbound + 1, max];
          }
          // otherwise (found) so lb is first position where its equal
          return [lbound, max];

        case '$lt':
          // if hole (not found) position already is less than
          if (!Comparators.aeq(Utils.getIn(rcd[index[lbound]], prop, usingDotNotation), val)) {
            return [min, lbound];
          }
          // otherwise (found) so lb marks left inside of eq range, get previous
          return [min, lbound - 1];

        case '$lte':
          // if hole (not found) ub position marks right outside so get previous
          if (!Comparators.aeq(Utils.getIn(rcd[index[ubound]], prop, usingDotNotation), val)) {
            return [min, ubound - 1];
          }
          // otherwise (found) so ub is last position where its still equal
          return [min, ubound];

        default:
          return [0, rcd.length - 1];
      }
    };

    /**
     * Retrieve doc by Unique index
     * @param {string} field - name of uniquely indexed property to use when doing lookup
     * @param {value} value - unique value to search for
     * @returns {object} document matching the value passed
     * @memberof Collection
     */
    Collection.prototype.by = function (field, value) {
      var self;
      if (value === undefined) {
        self = this;
        return function (value) {
          return self.by(field, value);
        };
      }

      var result = this.getUniqueIndex(field, true).get(value);
      if (!this.cloneObjects) {
        return result;
      } else {
        return clone(result, this.cloneMethod);
      }
    };

    /**
     * Find one object by index property, by property equal to value
     * @param {object} query - query object used to perform search with
     * @returns {(object|null)} First matching document, or null if none
     * @memberof Collection
     */
    Collection.prototype.findOne = function (query) {
      query = query || {};

      // Instantiate Resultset and exec find op passing firstOnly = true param
      var result = this.chain().find(query, true).data();

      if (Array.isArray(result) && result.length === 0) {
        return null;
      } else {
        if (!this.cloneObjects) {
          return result[0];
        } else {
          return clone(result[0], this.cloneMethod);
        }
      }
    };

    /**
     * Chain method, used for beginning a series of chained find() and/or view() operations
     * on a collection.
     *
     * @param {string|array=} transform - named transform or array of transform steps
     * @param {object=} parameters - Object containing properties representing parameters to substitute
     * @returns {Resultset} (this) resultset, or data array if any map or join functions where called
     * @memberof Collection
     */
    Collection.prototype.chain = function (transform, parameters) {
      var rs = new Resultset(this);

      if (typeof transform === 'undefined') {
        return rs;
      }

      return rs.transform(transform, parameters);
    };

    /**
     * Find method, api is similar to mongodb.
     * for more complex queries use [chain()]{@link Collection#chain} or [where()]{@link Collection#where}.
     * @example {@tutorial Query Examples}
     * @param {object} query - 'mongo-like' query object
     * @returns {array} Array of matching documents
     * @memberof Collection
     */
    Collection.prototype.find = function (query) {
      return this.chain().find(query).data();
    };

    /**
     * Find object by unindexed field by property equal to value,
     * simply iterates and returns the first element matching the query
     */
    Collection.prototype.findOneUnindexed = function (prop, value) {
      var i = this.data.length,
        doc;
      while (i--) {
        if (Utils.getIn(this.data[i], prop, true) === value) {
          doc = this.data[i];
          return doc;
        }
      }
      return null;
    };

    /**
     * Transaction methods
     */

    /** start the transation */
    Collection.prototype.startTransaction = function () {
      if (this.transactional) {
        this.cachedData = clone(this.data, this.cloneMethod);
        this.cachedIndex = this.idIndex;
        this.cachedBinaryIndex = this.binaryIndices;
        this.cachedDirtyIds = this.dirtyIds;

        // propagate startTransaction to dynamic views
        for (var idx = 0; idx < this.DynamicViews.length; idx++) {
          this.DynamicViews[idx].startTransaction();
        }
      }
    };

    /** commit the transation */
    Collection.prototype.commit = function () {
      if (this.transactional) {
        this.cachedData = null;
        this.cachedIndex = null;
        this.cachedBinaryIndex = null;
        this.cachedDirtyIds = null;

        // propagate commit to dynamic views
        for (var idx = 0; idx < this.DynamicViews.length; idx++) {
          this.DynamicViews[idx].commit();
        }
      }
    };

    /** roll back the transation */
    Collection.prototype.rollback = function () {
      if (this.transactional) {
        if (this.cachedData !== null && this.cachedIndex !== null) {
          this.data = this.cachedData;
          this.idIndex = this.cachedIndex;
          this.binaryIndices = this.cachedBinaryIndex;
          this.dirtyIds = this.cachedDirtyIds;
        }

        // propagate rollback to dynamic views
        for (var idx = 0; idx < this.DynamicViews.length; idx++) {
          this.DynamicViews[idx].rollback();
        }
      }
    };

    // async executor. This is only to enable callbacks at the end of the execution.
    Collection.prototype.async = function (fun, callback) {
      setTimeout(function () {
        if (typeof fun === 'function') {
          fun();
          callback();
        } else {
          throw new TypeError('Argument passed for async execution is not a function');
        }
      }, 0);
    };

    /**
     * Query the collection by supplying a javascript filter function.
     * @example
     * var results = coll.where(function(obj) {
     *   return obj.legs === 8;
     * });
     *
     * @param {function} fun - filter function to run against all collection docs
     * @returns {array} all documents which pass your filter function
     * @memberof Collection
     */
    Collection.prototype.where = function (fun) {
      return this.chain().where(fun).data();
    };

    /**
     * Map Reduce operation
     *
     * @param {function} mapFunction - function to use as map function
     * @param {function} reduceFunction - function to use as reduce function
     * @returns {data} The result of your mapReduce operation
     * @memberof Collection
     */
    Collection.prototype.mapReduce = function (mapFunction, reduceFunction) {
      try {
        return reduceFunction(this.data.map(mapFunction));
      } catch (err) {
        throw err;
      }
    };

    /**
     * Join two collections on specified properties
     *
     * @param {array|Resultset|Collection} joinData - array of documents to 'join' to this collection
     * @param {string} leftJoinProp - property name in collection
     * @param {string} rightJoinProp - property name in joinData
     * @param {function=} mapFun - (Optional) map function to use
     * @param {object=} dataOptions - options to data() before input to your map function
     * @param {bool} dataOptions.removeMeta - allows removing meta before calling mapFun
     * @param {boolean} dataOptions.forceClones - forcing the return of cloned objects to your map object
     * @param {string} dataOptions.forceCloneMethod - Allows overriding the default or collection specified cloning method.
     * @returns {Resultset} Result of the mapping operation
     * @memberof Collection
     */
    Collection.prototype.eqJoin = function (joinData, leftJoinProp, rightJoinProp, mapFun, dataOptions) {
      // logic in Resultset class
      return new Resultset(this).eqJoin(joinData, leftJoinProp, rightJoinProp, mapFun, dataOptions);
    };

    /* ------ STAGING API -------- */
    /**
     * stages: a map of uniquely identified 'stages', which hold copies of objects to be
     * manipulated without affecting the data in the original collection
     */
    Collection.prototype.stages = {};

    /**
     * (Staging API) create a stage and/or retrieve it
     * @memberof Collection
     */
    Collection.prototype.getStage = function (name) {
      if (!this.stages[name]) {
        this.stages[name] = {};
      }
      return this.stages[name];
    };
    /**
     * a collection of objects recording the changes applied through a commmitStage
     */
    Collection.prototype.commitLog = [];

    /**
     * (Staging API) create a copy of an object and insert it into a stage
     * @memberof Collection
     */
    Collection.prototype.stage = function (stageName, obj) {
      var copy = JSON.parse(JSON.stringify(obj));
      this.getStage(stageName)[obj.$loki] = copy;
      return copy;
    };

    /**
     * (Staging API) re-attach all objects to the original collection, so indexes and views can be rebuilt
     * then create a message to be inserted in the commitlog
     * @param {string} stageName - name of stage
     * @param {string} message
     * @memberof Collection
     */
    Collection.prototype.commitStage = function (stageName, message) {
      var stage = this.getStage(stageName),
        prop,
        timestamp = new Date().getTime();

      for (prop in stage) {

        this.update(stage[prop]);
        this.commitLog.push({
          timestamp: timestamp,
          message: message,
          data: JSON.parse(JSON.stringify(stage[prop]))
        });
      }
      this.stages[stageName] = {};
    };

    Collection.prototype.no_op = function () {
      return;
    };

    /**
     * @memberof Collection
     */
    Collection.prototype.extract = function (field) {
      var i = 0,
        len = this.data.length,
        isDotNotation = isDeepProperty(field),
        result = [];
      for (i; i < len; i += 1) {
        result.push(deepProperty(this.data[i], field, isDotNotation));
      }
      return result;
    };

    /**
     * @memberof Collection
     */
    Collection.prototype.max = function (field) {
      return Math.max.apply(null, this.extract(field));
    };

    /**
     * @memberof Collection
     */
    Collection.prototype.min = function (field) {
      return Math.min.apply(null, this.extract(field));
    };

    /**
     * @memberof Collection
     */
    Collection.prototype.maxRecord = function (field) {
      var i = 0,
        len = this.data.length,
        deep = isDeepProperty(field),
        result = {
          index: 0,
          value: undefined
        },
        max;

      for (i; i < len; i += 1) {
        if (max !== undefined) {
          if (max < deepProperty(this.data[i], field, deep)) {
            max = deepProperty(this.data[i], field, deep);
            result.index = this.data[i].$loki;
          }
        } else {
          max = deepProperty(this.data[i], field, deep);
          result.index = this.data[i].$loki;
        }
      }
      result.value = max;
      return result;
    };

    /**
     * @memberof Collection
     */
    Collection.prototype.minRecord = function (field) {
      var i = 0,
        len = this.data.length,
        deep = isDeepProperty(field),
        result = {
          index: 0,
          value: undefined
        },
        min;

      for (i; i < len; i += 1) {
        if (min !== undefined) {
          if (min > deepProperty(this.data[i], field, deep)) {
            min = deepProperty(this.data[i], field, deep);
            result.index = this.data[i].$loki;
          }
        } else {
          min = deepProperty(this.data[i], field, deep);
          result.index = this.data[i].$loki;
        }
      }
      result.value = min;
      return result;
    };

    /**
     * @memberof Collection
     */
    Collection.prototype.extractNumerical = function (field) {
      return this.extract(field).map(parseBase10).filter(Number).filter(function (n) {
        return !(isNaN(n));
      });
    };

    /**
     * Calculates the average numerical value of a property
     *
     * @param {string} field - name of property in docs to average
     * @returns {number} average of property in all docs in the collection
     * @memberof Collection
     */
    Collection.prototype.avg = function (field) {
      return average(this.extractNumerical(field));
    };

    /**
     * Calculate standard deviation of a field
     * @memberof Collection
     * @param {string} field
     */
    Collection.prototype.stdDev = function (field) {
      return standardDeviation(this.extractNumerical(field));
    };

    /**
     * @memberof Collection
     * @param {string} field
     */
    Collection.prototype.mode = function (field) {
      var dict = {},
        data = this.extract(field);
      data.forEach(function (obj) {
        if (dict[obj]) {
          dict[obj] += 1;
        } else {
          dict[obj] = 1;
        }
      });
      var max,
        prop, mode;
      for (prop in dict) {
        if (max) {
          if (max < dict[prop]) {
            mode = prop;
          }
        } else {
          mode = prop;
          max = dict[prop];
        }
      }
      return mode;
    };

    /**
     * @memberof Collection
     * @param {string} field - property name
     */
    Collection.prototype.median = function (field) {
      var values = this.extractNumerical(field);
      values.sort(sub);

      var half = Math.floor(values.length / 2);

      if (values.length % 2) {
        return values[half];
      } else {
        return (values[half - 1] + values[half]) / 2.0;
      }
    };

    /**
     * General utils, including statistical functions
     */
    function isDeepProperty(field) {
      return field.indexOf('.') !== -1;
    }

    function parseBase10(num) {
      return parseFloat(num, 10);
    }

    function isNotUndefined(obj) {
      return obj !== undefined;
    }

    function add(a, b) {
      return a + b;
    }

    function sub(a, b) {
      return a - b;
    }

    function median(values) {
      values.sort(sub);
      var half = Math.floor(values.length / 2);
      return (values.length % 2) ? values[half] : ((values[half - 1] + values[half]) / 2.0);
    }

    function average(array) {
      return (array.reduce(add, 0)) / array.length;
    }

    function standardDeviation(values) {
      var avg = average(values);
      var squareDiffs = values.map(function (value) {
        var diff = value - avg;
        var sqrDiff = diff * diff;
        return sqrDiff;
      });

      var avgSquareDiff = average(squareDiffs);

      var stdDev = Math.sqrt(avgSquareDiff);
      return stdDev;
    }

    function deepProperty(obj, property, isDeep) {
      if (isDeep === false) {
        // pass without processing
        return obj[property];
      }
      var pieces = property.split('.'),
        root = obj;
      while (pieces.length > 0) {
        root = root[pieces.shift()];
      }
      return root;
    }

    function binarySearch(array, item, fun) {
      var lo = 0,
        hi = array.length,
        compared,
        mid;
      while (lo < hi) {
        mid = (lo + hi) >> 1;
        compared = fun.apply(null, [item, array[mid]]);
        if (compared === 0) {
          return {
            found: true,
            index: mid
          };
        } else if (compared < 0) {
          hi = mid;
        } else {
          lo = mid + 1;
        }
      }
      return {
        found: false,
        index: hi
      };
    }

    function BSonSort(fun) {
      return function (array, item) {
        return binarySearch(array, item, fun);
      };
    }

    function KeyValueStore() { }

    KeyValueStore.prototype = {
      keys: [],
      values: [],
      sort: function (a, b) {
        return (a < b) ? -1 : ((a > b) ? 1 : 0);
      },
      setSort: function (fun) {
        this.bs = new BSonSort(fun);
      },
      bs: function () {
        return new BSonSort(this.sort);
      },
      set: function (key, value) {
        var pos = this.bs(this.keys, key);
        if (pos.found) {
          this.values[pos.index] = value;
        } else {
          this.keys.splice(pos.index, 0, key);
          this.values.splice(pos.index, 0, value);
        }
      },
      get: function (key) {
        return this.values[binarySearch(this.keys, key, this.sort).index];
      }
    };

    function UniqueIndex(uniqueField) {
      this.field = uniqueField;
      this.keyMap = Object.create(null);
      this.lokiMap = Object.create(null);
    }
    UniqueIndex.prototype.keyMap = {};
    UniqueIndex.prototype.lokiMap = {};
    UniqueIndex.prototype.set = function (obj) {
      var fieldValue = obj[this.field];
      if (fieldValue !== null && typeof (fieldValue) !== 'undefined') {
        if (this.keyMap[fieldValue]) {
          throw new Error('Duplicate key for property ' + this.field + ': ' + fieldValue);
        } else {
          this.keyMap[fieldValue] = obj;
          this.lokiMap[obj.$loki] = fieldValue;
        }
      }
    };
    UniqueIndex.prototype.get = function (key) {
      return this.keyMap[key];
    };

    UniqueIndex.prototype.byId = function (id) {
      return this.keyMap[this.lokiMap[id]];
    };
    /**
     * Updates a document's unique index given an updated object.
     * @param  {Object} obj Original document object
     * @param  {Object} doc New document object (likely the same as obj)
     */
    UniqueIndex.prototype.update = function (obj, doc) {
      if (this.lokiMap[obj.$loki] !== doc[this.field]) {
        var old = this.lokiMap[obj.$loki];
        this.set(doc);
        // make the old key fail bool test, while avoiding the use of delete (mem-leak prone)
        this.keyMap[old] = undefined;
      } else {
        this.keyMap[obj[this.field]] = doc;
      }
    };
    UniqueIndex.prototype.remove = function (key) {
      var obj = this.keyMap[key];
      if (obj !== null && typeof obj !== 'undefined') {
        // avoid using `delete`
        this.keyMap[key] = undefined;
        this.lokiMap[obj.$loki] = undefined;
      } else {
        throw new Error('Key is not in unique index: ' + this.field);
      }
    };
    UniqueIndex.prototype.clear = function () {
      this.keyMap = Object.create(null);
      this.lokiMap = Object.create(null);
    };

    function ExactIndex(exactField) {
      this.index = Object.create(null);
      this.field = exactField;
    }

    // add the value you want returned to the key in the index
    ExactIndex.prototype = {
      set: function add(key, val) {
        if (this.index[key]) {
          this.index[key].push(val);
        } else {
          this.index[key] = [val];
        }
      },

      // remove the value from the index, if the value was the last one, remove the key
      remove: function remove(key, val) {
        var idxSet = this.index[key];
        for (var i in idxSet) {
          if (idxSet[i] == val) {
            idxSet.splice(i, 1);
          }
        }
        if (idxSet.length < 1) {
          this.index[key] = undefined;
        }
      },

      // get the values related to the key, could be more than one
      get: function get(key) {
        return this.index[key];
      },

      // clear will zap the index
      clear: function clear(key) {
        this.index = {};
      }
    };

    function SortedIndex(sortedField) {
      this.field = sortedField;
    }

    SortedIndex.prototype = {
      keys: [],
      values: [],
      // set the default sort
      sort: function (a, b) {
        return (a < b) ? -1 : ((a > b) ? 1 : 0);
      },
      bs: function () {
        return new BSonSort(this.sort);
      },
      // and allow override of the default sort
      setSort: function (fun) {
        this.bs = new BSonSort(fun);
      },
      // add the value you want returned  to the key in the index
      set: function (key, value) {
        var pos = binarySearch(this.keys, key, this.sort);
        if (pos.found) {
          this.values[pos.index].push(value);
        } else {
          this.keys.splice(pos.index, 0, key);
          this.values.splice(pos.index, 0, [value]);
        }
      },
      // get all values which have a key == the given key
      get: function (key) {
        var bsr = binarySearch(this.keys, key, this.sort);
        if (bsr.found) {
          return this.values[bsr.index];
        } else {
          return [];
        }
      },
      // get all values which have a key < the given key
      getLt: function (key) {
        var bsr = binarySearch(this.keys, key, this.sort);
        var pos = bsr.index;
        if (bsr.found) pos--;
        return this.getAll(key, 0, pos);
      },
      // get all values which have a key > the given key
      getGt: function (key) {
        var bsr = binarySearch(this.keys, key, this.sort);
        var pos = bsr.index;
        if (bsr.found) pos++;
        return this.getAll(key, pos, this.keys.length);
      },

      // get all vals from start to end
      getAll: function (key, start, end) {
        var results = [];
        for (var i = start; i < end; i++) {
          results = results.concat(this.values[i]);
        }
        return results;
      },
      // just in case someone wants to do something smart with ranges
      getPos: function (key) {
        return binarySearch(this.keys, key, this.sort);
      },
      // remove the value from the index, if the value was the last one, remove the key
      remove: function (key, value) {
        var pos = binarySearch(this.keys, key, this.sort).index;
        var idxSet = this.values[pos];
        for (var i in idxSet) {
          if (idxSet[i] == value) idxSet.splice(i, 1);
        }
        if (idxSet.length < 1) {
          this.keys.splice(pos, 1);
          this.values.splice(pos, 1);
        }
      },
      // clear will zap the index
      clear: function () {
        this.keys = [];
        this.values = [];
      }
    };

    Loki.deepFreeze = deepFreeze;
    Loki.freeze = freeze;
    Loki.unFreeze = unFreeze;
    Loki.LokiOps = LokiOps;
    Loki.Collection = Collection;
    Loki.DynamicView = DynamicView;
    Loki.Resultset = Resultset;
    Loki.KeyValueStore = KeyValueStore;
    Loki.LokiMemoryAdapter = LokiMemoryAdapter;
    Loki.LokiPartitioningAdapter = LokiPartitioningAdapter;
    Loki.LokiLocalStorageAdapter = LokiLocalStorageAdapter;
    Loki.LokiFsAdapter = LokiFsAdapter;
    Loki.persistenceAdapters = {
      fs: LokiFsAdapter,
      localStorage: LokiLocalStorageAdapter
    };
    Loki.aeq = aeqHelper;
    Loki.lt = ltHelper;
    Loki.gt = gtHelper;
    Loki.Comparators = Comparators;
    return Loki;
  }());

}));

}).call(this)}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./loki-indexed-adapter.js":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/loki-enclave-facade/lib/lokijs/src/loki-indexed-adapter.js","fs":false}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/anchoring/RemotePersistence.js":[function(require,module,exports){
const {SmartUrl} = require("../utils");

function RemotePersistence() {
    const openDSU = require("opendsu");
    const keySSISpace = openDSU.loadAPI("keyssi");
    const resolver = openDSU.loadAPI("resolver");
    const promiseRunner = require("../utils/promise-runner");

    const getAnchoringServices = (dlDomain, callback) => {
        const bdns = openDSU.loadAPI("bdns");
        bdns.getAnchoringServices(dlDomain, (err, anchoringServicesArray) => {
            if (err) {
                return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to get anchoring services from bdns`, err));
            }

            if (!anchoringServicesArray.length) {
                return callback('No anchoring service provided');
            }

            callback(undefined, anchoringServicesArray);
        });
    }

    const updateAnchor = (anchorSSI, anchorValue, anchorAction, callback) => {
        if (typeof anchorSSI === "string") {
            try {
                anchorSSI = keySSISpace.parse(anchorSSI);
            } catch (e) {
                return callback(e);
            }
        }

        if (typeof anchorValue === "string") {
            try {
                anchorValue = keySSISpace.parse(anchorValue);
            } catch (e) {
                return callback(e);
            }
        }

        const dlDomain = anchorSSI.getDLDomain();
        anchorSSI.getAnchorId((err, anchorId) => {
            if (err) {
                return callback(err);
            }

            getAnchoringServices(dlDomain, (err, anchoringServicesArray) => {
                if (err) {
                    return callback(err);
                }

                const anchorHandler = getAnchorHandler(anchorId, anchorValue.getIdentifier(), dlDomain, anchorAction);
                promiseRunner.runOneSuccessful(anchoringServicesArray, anchorHandler, callback, new Error(`Failed during execution of ${anchorAction}`));
            })
        })
    }

    const getAnchorHandler = (anchorId, anchorValue, dlDomain, anchorAction) => {
        return function (service) {
            return new Promise((resolve, reject) => {
                let smartUrl = new SmartUrl(service);
                smartUrl = smartUrl.concatWith(`/anchor/${dlDomain}/${anchorAction}/${anchorId}/${anchorValue}`);

                const putResult = smartUrl.doPut("", (err, data) => {
                    if (err) {
                        return reject({
                            statusCode: err.statusCode,
                            message: err.statusCode === 428 ? 'Unable to add alias: versions out of sync' : err.message || 'Error'
                        });
                    }

                    resolver.invalidateDSUCache(anchorId, err => {
                        if (err) {
                            return reject(err);
                        }
                        resolve(data);
                    });
                });
                if (putResult) {
                    putResult.then(resolve).catch(reject);
                }
            })
        }
    };

    this.createAnchor = (capableOfSigningKeySSI, anchorValue, callback) => {
        updateAnchor(capableOfSigningKeySSI, anchorValue, "create-anchor", callback);
    }

    this.appendAnchor = (capableOfSigningKeySSI, anchorValue, callback) => {
        updateAnchor(capableOfSigningKeySSI, anchorValue, "append-to-anchor", callback);
    }

    const getFetchAnchor = (anchorId, dlDomain, actionName, callback) => {
        return function (service) {
            return new Promise((resolve, reject) => {

                let smartUrl = new SmartUrl(service);
                smartUrl = smartUrl.concatWith(`/anchor/${dlDomain}/${actionName}/${anchorId}`);

                smartUrl.doGet((err, data) => {
                    if (err) {
                        if(err.rootCause === require("./../moduleConstants").ERROR_ROOT_CAUSE.MISSING_DATA){
                            return resolve();
                        }
                        return reject(err);
                    }

                    try {
                        data = JSON.parse(data);
                    } catch (e) {
                        return reject(e);
                    }

                    if (actionName === "get-last-version") {
                        data = data.message;
                    }
                    return resolve(data);
                });
            })
        }
    }

    const getAnchorValues = (keySSI, actionName, callback) => {
        if (typeof keySSI === "string") {
            try {
                keySSI = keySSISpace.parse(keySSI);
            } catch (e) {
                return callback(e);
            }
        }

        const dlDomain = keySSI.getDLDomain();
        keySSI.getAnchorId((err, anchorId) => {
            if (err) {
                return callback(err);
            }
            getAnchoringServices(dlDomain, (err, anchoringServicesArray) => {
                if (err) {
                    return callback(err);
                }

                const fetchAnchor = getFetchAnchor(anchorId, dlDomain, actionName, callback);
                promiseRunner.runOneSuccessful(anchoringServicesArray, fetchAnchor, callback, new Error("get Anchoring Service"));
            })
        });
    }

    this.getAllVersions = (keySSI, callback) => {
        getAnchorValues(keySSI, "get-all-versions", callback);
    }

    this.getLastVersion = (keySSI, callback) => {
        getAnchorValues(keySSI, "get-last-version", callback);
    }

    this.createOrUpdateMultipleAnchors = (anchors, callback) => {
        let smartUrl = new SmartUrl(service);
        smartUrl = smartUrl.concatWith(`/anchor/create-or-update-multiple-anchors`);

        smartUrl.doPut(JSON.stringify(anchors), (err, data) => {
            if (err) {
                return callback(err);
            }

            return callback(undefined, data);
        });
    }
}

module.exports = RemotePersistence;
},{"../utils":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/utils/index.js","../utils/promise-runner":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/utils/promise-runner.js","./../moduleConstants":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/moduleConstants.js","opendsu":"opendsu"}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/anchoring/anchoring-utils.js":[function(require,module,exports){
const constants = require("../moduleConstants");

function validateHashLinks(keySSI, hashLinks, callback) {
    const validatedHashLinks = [];
    let lastSSI;
    let lastTransferSSI;

    const __validateHashLinksRecursively = (index) => {
        const newSSI = hashLinks[index];
        if (typeof newSSI === "undefined") {
            return callback(undefined, validatedHashLinks);
        }
        verifySignature(keySSI, newSSI, lastSSI, (err, status) => {
            if (err) {
                return callback(err);
            }

            if (!status) {
                return callback(Error("Failed to verify signature"));
            }

            if (!validateAnchoredSSI(lastTransferSSI, newSSI)) {
                return callback(Error("Failed to validate SSIs"));
            }

            if (newSSI.getTypeName() === constants.KEY_SSIS.TRANSFER_SSI) {
                lastTransferSSI = newSSI;
            } else {
                validatedHashLinks.push(newSSI);
                lastSSI = newSSI;
            }
            __validateHashLinksRecursively(index + 1);
        });
    }

    __validateHashLinksRecursively(0);
}


function validateAnchoredSSI(lastTransferSSI, currentSSI) {
    if (!lastTransferSSI) {
        return true;
    }
    if (lastTransferSSI.getSignature() !== currentSSI.getSignature()) {
        return false;
    }

    return true;
}

function verifySignature(keySSI, newSSI, lastSSI, callback) {
    if (typeof lastSSI === "function") {
        callback = lastSSI;
        lastSSI = undefined;
    }

    if (!keySSI.canSign()) {
        return callback(undefined, true);
    }
    if (!newSSI.canBeVerified()) {
        return callback(undefined, true);
    }
    const timestamp = newSSI.getTimestamp();
    const signature = newSSI.getSignature();
    let lastEntryInAnchor = '';
    if (lastSSI) {
        lastEntryInAnchor = lastSSI.getIdentifier();
    }

    let dataToVerify;
    keySSI.getAnchorId((err, anchorId) => {
        if (err) {
            return callback(err);
        }

        if (newSSI.getTypeName() === constants.KEY_SSIS.SIGNED_HASH_LINK_SSI) {
            dataToVerify = keySSI.hash(anchorId + newSSI.getHash() + lastEntryInAnchor + timestamp);
            return callback(undefined, keySSI.verify(dataToVerify, signature));
        }
        if (newSSI.getTypeName() === constants.KEY_SSIS.TRANSFER_SSI) {
            dataToVerify += newSSI.getSpecificString();
            return callback(undefined, keySSI.verify(dataToVerify, signature));
        }

        callback(undefined, false);
    });
}

module.exports = {
    validateHashLinks,
    verifySignature
};

},{"../moduleConstants":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/moduleConstants.js"}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/anchoring/anchoringAbstractBehaviour.js":[function(require,module,exports){
const {createOpenDSUErrorWrapper} = require("../error");
const fakeHistory = {};
const fakeLastVersion = {};

function AnchoringAbstractBehaviour(persistenceStrategy) {
    const self = this;
    const keySSISpace = require("opendsu").loadAPI("keyssi");

    self.createAnchor = function (anchorId, anchorValueSSI, callback) {
        if (typeof anchorId === 'undefined' || typeof anchorValueSSI === 'undefined' || anchorId === null || anchorValueSSI === null) {
            return callback(Error(`Invalid call for create anchor ${anchorId}:${anchorValueSSI}`));
        }
        //convert to keySSI
        let anchorIdKeySSI = anchorId;
        if (typeof anchorId === "string") {
            anchorIdKeySSI = keySSISpace.parse(anchorId);
        }
        let anchorValueSSIKeySSI = anchorValueSSI;
        if (typeof anchorValueSSI === "string") {
            anchorValueSSIKeySSI = keySSISpace.parse(anchorValueSSI);
        }



        anchorIdKeySSI.getAnchorId((err, _anchorId) => {
            if (err) {
                return callback(err);
            }

            let fakeLastVersionForAnchorId = fakeLastVersion[_anchorId];
            if(fakeLastVersionForAnchorId){
                console.log("!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!");
                return callback(undefined);
            }

            if (!anchorIdKeySSI.canAppend()) {
                return persistenceStrategy.createAnchor(_anchorId, anchorValueSSIKeySSI.getIdentifier(), callback);
            }

            const signer = determineSigner(anchorIdKeySSI, []);
            const signature = anchorValueSSIKeySSI.getSignature();
            const dataToVerify = anchorValueSSIKeySSI.getDataToSign(anchorIdKeySSI, null);
            if (!signer.verify(dataToVerify, signature)) {
                return callback(Error("Failed to verify signature"));
            }
            persistenceStrategy.createAnchor(_anchorId, anchorValueSSIKeySSI.getIdentifier(), callback);
        });
    }

    self.appendAnchor = function (anchorId, anchorValueSSI, callback) {
        const __appendAnchor = () => {
            if (typeof anchorId === 'undefined' || typeof anchorValueSSI === 'undefined' || anchorId === null || anchorValueSSI === null) {
                return callback(Error(`Invalid call for append anchor ${anchorId}:${anchorValueSSI}`));
            }
            //convert to keySSI
            let anchorIdKeySSI = anchorId;
            if (typeof anchorId === "string") {
                anchorIdKeySSI = keySSISpace.parse(anchorId);
            }
            let anchorValueSSIKeySSI = anchorValueSSI;
            if (typeof anchorValueSSI === "string") {
                anchorValueSSIKeySSI = keySSISpace.parse(anchorValueSSI);
            }

            if (!anchorIdKeySSI.canAppend()) {
                return callback(Error(`Cannot append anchor for ${anchorId} because of the keySSI type`));
            }

            anchorIdKeySSI.getAnchorId((err, _anchorId) => {
                if (err) {
                    return callback(err);
                }

                let verifySignaturesAndAppend = (err, data) => {
                    // throw Error("Get all versions callback");
                    if (err) {
                        return callback(err);
                    }
                    if (typeof data === 'undefined' || data === null) {
                        data = [];
                    }

                    if(!self.testIfRecoveryActiveFor(_anchorId)){
                        const historyOfKeySSI = data.map(el => keySSISpace.parse(el));
                        const signer = determineSigner(anchorIdKeySSI, historyOfKeySSI);
                        const signature = anchorValueSSIKeySSI.getSignature();
                        if (typeof data[data.length - 1] === 'undefined') {
                            return callback(`Cannot update non existing anchor ${anchorId}`);
                        }
                        const lastSignedHashLinkKeySSI = keySSISpace.parse(data[data.length - 1]);
                        const dataToVerify = anchorValueSSIKeySSI.getDataToSign(anchorIdKeySSI, lastSignedHashLinkKeySSI);
                        if (!signer.verify(dataToVerify, signature)) {
                            return callback({statusCode: 428, code: 428, message: "Versions out of sync"});
                        }
                    }

                    persistenceStrategy.appendAnchor(_anchorId, anchorValueSSIKeySSI.getIdentifier(), callback);
                }

                let fakeHistoryAvailable = fakeHistory[_anchorId];
                if(fakeHistoryAvailable){
                    return verifySignaturesAndAppend(undefined, fakeHistoryAvailable);
                }

                persistenceStrategy.getAllVersions(anchorId, verifySignaturesAndAppend)
            });
        }

        if (typeof persistenceStrategy.prepareAnchoring === "function") {
            persistenceStrategy.prepareAnchoring(anchorId, err => {
                if (err) {
                    return callback(err);
                }
                __appendAnchor();
            });
        } else {
            __appendAnchor();
        }
    }

    self.getAllVersions = function (anchorId, callback) {
        let anchorIdKeySSI = anchorId;
        if (typeof anchorId === "string") {
            anchorIdKeySSI = keySSISpace.parse(anchorId);
        }

        anchorIdKeySSI.getAnchorId((err, anchorId) => {
            if (err) {
                return callback(err);
            }

            let fakeHistoryAvailable = fakeHistory[anchorId];
            if(fakeHistoryAvailable){
                return callback(undefined, fakeHistoryAvailable);
            }

            persistenceStrategy.getAllVersions(anchorId, (err, data) => {
                if (err) {
                    return callback(err);
                }
                if (typeof data === 'undefined' || data.length === 0) {
                    return callback(undefined, []);
                }
                if (!anchorIdKeySSI.canAppend()) {
                    //skip validation for non signing SSI
                    let anchorValues;
                    try {
                        anchorValues = data.map(el => keySSISpace.parse(el));
                    } catch (e) {
                        return callback(e);
                    }
                    return callback(undefined, anchorValues);
                }
                const historyOfKeySSI = data.map(el => keySSISpace.parse(el));
                const progressiveHistoryOfKeySSI = [];
                let previousSignedHashLinkKeySSI = null;
                for (let i = 0; i <= historyOfKeySSI.length - 1; i++) {
                    const anchorValueSSIKeySSI = historyOfKeySSI[i];
                    const signer = determineSigner(anchorIdKeySSI, progressiveHistoryOfKeySSI);
                    const signature = anchorValueSSIKeySSI.getSignature();
                    const dataToVerify = anchorValueSSIKeySSI.getDataToSign(anchorIdKeySSI, previousSignedHashLinkKeySSI);
                    if (!signer.verify(dataToVerify, signature)) {
                        return callback(Error("Failed to verify signature"));
                    }
                    //build history
                    progressiveHistoryOfKeySSI.push(anchorValueSSIKeySSI);
                    previousSignedHashLinkKeySSI = anchorValueSSIKeySSI;
                }
                //all history was validated
                return callback(undefined, historyOfKeySSI);
            });
        });
    }

    self.getLastVersion = function (anchorId, callback) {
        let anchorIdKeySSI = anchorId;
        if (typeof anchorId === "string") {
            anchorIdKeySSI = keySSISpace.parse(anchorId);
        }

        anchorIdKeySSI.getAnchorId((err, anchorId) => {
            if (err) {
                return callback(err);
            }

            let fakeLastVersionForAnchorId = fakeLastVersion[anchorId];
            if(fakeLastVersionForAnchorId){
                return callback(undefined, fakeLastVersionForAnchorId);
            }

            persistenceStrategy.getLastVersion(anchorId, (err, data) => {
                if (err) {
                    return callback(err);
                }
                if (typeof data === 'undefined' || data === null || data === "") {
                    return callback();
                }

                let anchorValueSSI;
                try {
                    anchorValueSSI = keySSISpace.parse(data);
                } catch (e) {
                    return callback(createOpenDSUErrorWrapper("Failed to parse anchor value", e));
                }
                callback(undefined, anchorValueSSI);
            });
        });
    }

    self.markAnchorForRecovery = function(anchorId, anchorFakeHistory, anchorFakeLastVersion){
        fakeHistory[anchorId] = anchorFakeHistory;
        fakeLastVersion[anchorId] = anchorFakeLastVersion;
    }

    self.unmarkAnchorForRecovery = function(anchorId){
        fakeHistory[anchorId] = undefined;
        fakeLastVersion[anchorId] = undefined;
    }

    self.testIfRecoveryActiveFor = function(anchorId){
        return !!fakeHistory[anchorId];
    }

    function determineSigner(anchorIdKeySSI, historyOfKeySSIValues) {
        const {wasTransferred, signer} = wasHashLinkTransferred(historyOfKeySSIValues);
        if (wasTransferred) {
            return signer;
        }
        return anchorIdKeySSI;
    }

    function wasHashLinkTransferred(historyOfKeySSIValues) {
        if (!Array.isArray(historyOfKeySSIValues)) {
            throw `hashLinks is not Array. Received ${historyOfKeySSIValues}`;
        }
        for (let i = historyOfKeySSIValues.length - 1; i >= 0; i--) {
            let hashLinkSSI = historyOfKeySSIValues[i];
            if (hashLinkSSI.isTransfer()) {
                return {
                    wasTransferred: true, signVerifier: hashLinkSSI
                };
            }
        }
        return {
            wasTransferred: false, signVerifier: undefined
        }
    }
}


module.exports = {
    AnchoringAbstractBehaviour
}

},{"../error":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/error/index.js","opendsu":"opendsu"}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/anchoring/index.js":[function(require,module,exports){
const openDSU = require("opendsu")
const keyssi = openDSU.loadAPI("keyssi");
const utils = openDSU.loadAPI("utils");
const SmartUrl = utils.SmartUrl;
const constants = openDSU.constants;
const promiseRunner = utils.promiseRunner;
const config = openDSU.loadAPI("config");
const {validateHashLinks, verifySignature} = require("./anchoring-utils");

const getAnchoringBehaviour = (persistenceStrategy) => {
        const Aab = require('./anchoringAbstractBehaviour').AnchoringAbstractBehaviour;
        return new Aab(persistenceStrategy);
    };


const isValidVaultCache = () => {
    return typeof config.get(constants.CACHE.VAULT_TYPE) !== "undefined" && config.get(constants.CACHE.VAULT_TYPE) !== constants.CACHE.NO_CACHE;
}

const buildGetVersionFunction = function(processingFunction){
    return function (keySSI, authToken, callback) {
        if (typeof authToken === 'function') {
            callback = authToken;
            authToken = undefined;
        }

        const dlDomain = keySSI.getDLDomain();
        keySSI.getAnchorId((err, anchorId) => {
            if (err) {
                return callback(err);
            }
            const bdns = require("../bdns");
            // if (dlDomain === constants.DOMAINS.VAULT && isValidVaultCache()) {
            //     return cachedAnchoring.versions(anchorId, callback);
            // }

            bdns.getAnchoringServices(dlDomain, function (err, anchoringServicesArray) {
                if (err) {
                    return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to get anchoring services from bdns`, err));
                }

                if (!anchoringServicesArray.length) {
                    return callback('No anchoring service provided');
                }

                //TODO: security issue (which response we trust)
                const fetchAnchor = (service) => {
                    let smartUrl = new SmartUrl(service);
                    smartUrl = smartUrl.concatWith(`/anchor/${dlDomain}/get-all-versions/${anchorId}`);
                    return smartUrl.fetch().then(processingFunction);
                };

                promiseRunner.runOneSuccessful(anchoringServicesArray, fetchAnchor, callback, new Error("get Anchoring Service"));
            });
        });
    }
}

/**
 * Get versions
 * @param {keySSI} keySSI
 * @param {string} authToken
 * @param {function} callback
 */
const getAllVersions = (keySSI, authToken, callback) => {
    const fnc = buildGetVersionFunction((response) => {
        return response.json().then(async (hlStrings) => {
            if (!hlStrings) {
                return [];
            }
            const hashLinks = hlStrings.map((hlString) => {
                return keyssi.parse(hlString);
            });

            const validatedHashLinks = await $$.promisify(validateHashLinks)(keySSI, hashLinks);

            // cache.put(anchorId, hlStrings);
            return validatedHashLinks;
        });
    });
    return fnc(keySSI, authToken, callback);
};

/**
 * Get the latest version only
 * @param {keySSI} keySSI
 * @param {string} authToken
 * @param {function} callback
 */
const getLastVersion = (keySSI, authToken, callback) => {
    const fnc = buildGetVersionFunction((response) => {
        return response.json().then(async (hlStrings) => {
            if (!hlStrings || (Array.isArray(hlStrings) && !hlStrings.length)) {
                //no version found
                return undefined;
            }
            // We need the last two hash links in order to validate the last one
            const hashLinks = hlStrings.slice(-2).map((hlString) => {
                return keyssi.parse(hlString);
            });

            const latestHashLink = hashLinks.pop();
            const prevHashLink = hashLinks.pop();

            const validHL = verifySignature(keySSI, latestHashLink, prevHashLink);

            if (!validHL) {
                throw new Error('Failed to verify signature');
            }

            return latestHashLink;
        });
    });
    return fnc(keySSI, authToken, callback);
};

/**
 * Add new version
 * @param {keySSI} SSICapableOfSigning
 * @param {hashLinkSSI} newSSI
 * @param {hashLinkSSI} lastSSI
 * @param {string} zkpValue
 * @param {string} digitalProof
 * @param {function} callback
 */
const addVersion = (SSICapableOfSigning, newSSI, lastSSI, zkpValue, callback) => {
    if (typeof newSSI === "function") {
        callback = newSSI;
        newSSI = undefined;
        lastSSI = undefined;
        zkpValue = '';
    }

    if (typeof lastSSI === "function") {
        callback = lastSSI;
        lastSSI = undefined;
        zkpValue = '';
    }

    if (typeof zkpValue === "function") {
        callback = zkpValue;
        zkpValue = '';
    }

    const dlDomain = SSICapableOfSigning.getDLDomain();
    SSICapableOfSigning.getAnchorId((err, anchorId) => {
        if (err) {
            return callback(err);
        }

        // if (dlDomain === constants.DOMAINS.VAULT && isValidVaultCache()) {
        //     return cachedAnchoring.addVersion(anchorId, newSSI ? newSSI.getIdentifier() : undefined, callback);
        // }

        const bdns = require("../bdns");
        bdns.getAnchoringServices(dlDomain, (err, anchoringServicesArray) => {
            if (err) {
                return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to get anchoring services from bdns`, err));
            }

            if (!anchoringServicesArray.length) {
                return callback('No anchoring service provided');
            }

            const hashLinkIds = {
                last: lastSSI ? lastSSI.getIdentifier() : null,
                new: newSSI ? newSSI.getIdentifier() : null
            };

            createDigitalProof(SSICapableOfSigning, hashLinkIds.new, hashLinkIds.last, zkpValue, (err, digitalProof) => {
                const body = {
                    hashLinkIds,
                    digitalProof,
                    zkp: zkpValue
                };

                const anchorAction = newSSI ? "append-to-anchor" : "create-anchor";

                const addAnchor = (service) => {
                    return new Promise((resolve, reject) => {

                        let smartUrl = new SmartUrl(service);
                        smartUrl = smartUrl.concatWith(`/anchor/${dlDomain}/${anchorAction}/${anchorId}`);

                        const putResult = smartUrl.doPut(JSON.stringify(body), (err, data) => {
                            if (err) {
                                return reject({
                                    statusCode: err.statusCode,
                                    message: err.statusCode === 428 ? 'Unable to add alias: versions out of sync' : err.message || 'Error'
                                });
                            }

                            require("opendsu").loadApi("resolver").invalidateDSUCache(SSICapableOfSigning, err=>{
                                if (err) {
                                    return reject(err);
                                }
                                return resolve(data);
                            });
                        });
                        if (putResult) {
                            putResult.then(resolve).catch(reject);
                        }
                    })
                };

                promiseRunner.runOneSuccessful(anchoringServicesArray, addAnchor, callback, new Error(`Failed during execution of ${anchorAction}`));
            });
        });
    });
};

function createDigitalProof(SSICapableOfSigning, newSSIIdentifier, lastSSIIdentifier, zkp, callback) {
    // when the anchor is first created, no version is created yet
    if (!newSSIIdentifier) {
        newSSIIdentifier = "";
    }

    SSICapableOfSigning.getAnchorId((err, anchorId) => {
        if (err) {
            return callback(err);
        }
        let dataToSign = anchorId + newSSIIdentifier + zkp;
        if (lastSSIIdentifier) {
            dataToSign += lastSSIIdentifier;
        }

        if (SSICapableOfSigning.getTypeName() === constants.KEY_SSIS.CONST_SSI || SSICapableOfSigning.getTypeName() === constants.KEY_SSIS.ARRAY_SSI || SSICapableOfSigning.getTypeName() === constants.KEY_SSIS.WALLET_SSI) {
            return callback(undefined, {signature: "", publicKey: ""});
        }

        return SSICapableOfSigning.sign(dataToSign, callback);
    });
}

const getObservable = (keySSI, fromVersion, authToken, timeout) => {
    // TODO: to be implemented
}


const callContractMethod = (domain, method, ...args) => {
    const callback = args.pop();
    const contracts = require("opendsu").loadApi("contracts");
    contracts.callContractMethod(domain, "anchoring", method, args, callback);
}

const createAnchor = (dsuKeySSI, callback) => {
    addVersion(dsuKeySSI, callback)
}

const createNFT = (nftKeySSI, callback) => {
    addVersion(nftKeySSI, callback)
}

const appendToAnchor = (dsuKeySSI, newShlSSI, previousShlSSI, zkpValue, callback) => {
    addVersion(dsuKeySSI, newShlSSI, previousShlSSI, zkpValue, callback)
}

const transferTokenOwnership = (nftKeySSI, ownershipSSI, callback) => {
    // TODO: to be implemented
    callContractMethod(domain, "transferTokenOwnership", ...args);
}

const getLatestVersion = (domain, ...args) => {
    // TODO: to be implemented
    callContractMethod(domain, "getLatestVersion", ...args);
}


function getAnchoringX(){
    //todo: See below
    //return anchoring behaviour using the persistence as apihub calls
    //execute the integration testing using the extended FS implementation (fsx)
    const RemotePersistence = require("./RemotePersistence");
    return getAnchoringBehaviour(new RemotePersistence());
}
module.exports = {
    createAnchor,
    createNFT,
    appendToAnchor,
    transferTokenOwnership,
    getAllVersions,
    getLastVersion,
    getLatestVersion,
    getAnchoringBehaviour,
    getAnchoringX
}

},{"../bdns":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/bdns/index.js","./RemotePersistence":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/anchoring/RemotePersistence.js","./anchoring-utils":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/anchoring/anchoring-utils.js","./anchoringAbstractBehaviour":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/anchoring/anchoringAbstractBehaviour.js","opendsu":"opendsu"}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/bdns/index.js":[function(require,module,exports){
const constants = require("../moduleConstants");
const PendingCallMixin = require("../utils/PendingCallMixin");
const getBaseURL = require("../utils/getBaseURL");

function BDNS() {
    PendingCallMixin(this);
    let bdnsCache;
    const http = require("opendsu").loadApi("http");
    let isInitialized = false;

    let retrieveHosts = () => {
        const url = `${getBaseURL()}/bdns#x-blockchain-domain-request`;
        http.fetch(url)
            .then((response) => {
                return response.json()
            }).then((bdnsHosts) => {
            bdnsHosts = JSON.stringify(bdnsHosts);
            bdnsHosts = bdnsHosts.replace(/\$ORIGIN/g, getBaseURL());
            bdnsCache = JSON.parse(bdnsHosts);
            isInitialized = true;
            this.executePendingCalls();
        }).catch((err) => console.log("Failed to retrieve BDNS hosts", err));
    };

    retrieveHosts();

    const getSection = (dlDomain, section, callback) => {
        function load_or_default() {
            if (typeof dlDomain === "undefined") {
                return callback(Error(`The provided domain is undefined`));
            }

            if(typeof bdnsCache[dlDomain] === "undefined"){
                return callback(Error(`BDNS: The provided domain <${dlDomain}> is not configured. Check if the domain name is correct and if BDNS contains info for this specific domain.`));
            }

            const config = bdnsCache[dlDomain][section] ? bdnsCache[dlDomain][section] : [getBaseURL()];
            callback(undefined, config);
        }

        if (!isInitialized) {
            return this.addPendingCall(() => {
                if (dlDomain === undefined) {
                    return callback(new Error("The domain is not defined"));
                }
                return load_or_default();
            })
        }
        if (dlDomain === undefined) {
            return callback(new Error("The domain is not defined"));
        }
        load_or_default();
    }

    this.getRawInfo = (dlDomain, callback) => {
        if (!isInitialized) {
            return this.addPendingCall(() => {
                callback(undefined, bdnsCache[dlDomain]);
            })
        }
        callback(undefined, bdnsCache[dlDomain]);
    };

    this.getBrickStorages = (dlDomain, callback) => {
        getSection(dlDomain, "brickStorages", callback);
    };

    this.getAnchoringServices = (dlDomain, callback) => {
        getSection(dlDomain, "anchoringServices", callback);
    };

    this.getContractServices = (dlDomain, callback) => {
        getSection(dlDomain, "contractServices", callback);
    };

    this.getReplicas = (dlDomain, callback) => {
        getSection(dlDomain, "replicas", callback);
    };

    this.getNotificationEndpoints = (dlDomain, callback) => {
        getSection(dlDomain, "notifications", callback);
    }

    this.getMQEndpoints = (dlDomain, callback) => {
        getSection(dlDomain, "mqEndpoints", callback);
    }

    this.addRawInfo = (dlDomain, rawInfo) => {
        console.warn("This function is obsolete. Doing nothing");
    };

    this.addAnchoringServices = (dlDomain, anchoringServices) => {
        console.warn("This function is obsolete. Doing nothing");
    };

    this.addBrickStorages = (dlDomain, brickStorages) => {
        console.warn("This function is obsolete. Doing nothing");
    };

    this.addReplicas = (dlDomain, replicas) => {
        console.warn("This function is obsolete. Doing nothing");
    };

    this.setBDNSHosts = (bdnsHosts) => {
        isInitialized = true;
        bdnsCache = bdnsHosts;
    }
}


module.exports = new BDNS();

},{"../moduleConstants":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/moduleConstants.js","../utils/PendingCallMixin":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/utils/PendingCallMixin.js","../utils/getBaseURL":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/utils/getBaseURL.js","opendsu":"opendsu"}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/boot/BootEngine.js":[function(require,module,exports){
(function (global){(function (){
function BootEngine(getKeySSI) {
    if (typeof getKeySSI !== "function") {
        throw new Error("getSeed missing or not a function");
    }
    getKeySSI = promisify(getKeySSI);

    const openDSU = require("opendsu");
    const { constants } = openDSU;
    const resolver = openDSU.loadApi("resolver");
    const pskPath = require("swarmutils").path;

    const evalBundles = async (bundles, ignore) => {
        const listFiles = promisify(this.rawDossier.listFiles);
        const readFile = promisify(this.rawDossier.readFile);

        let fileList = await listFiles(constants.CONSTITUTION_FOLDER);
        fileList = bundles
            .filter((bundle) => fileList.includes(bundle) || fileList.includes(`/${bundle}`))
            .map((bundle) => pskPath.join(constants.CONSTITUTION_FOLDER, bundle));

        if (fileList.length !== bundles.length) {
            const message = `Some bundles missing. Expected to have ${JSON.stringify(
                bundles
            )} but got only ${JSON.stringify(fileList)}`;
            if (!ignore) {
                throw new Error(message);
            } else {
                console.log(message);
            }
        }

        for (let i = 0; i < fileList.length; i++) {
            var fileContent = await readFile(fileList[i]);
            try {
                eval(fileContent.toString());
            } catch (e) {
                console.log("Failed to eval file", fileList[i], e);
            }
        }
    };

    this.boot = function (callback) {
        const __boot = async () => {
            const keySSI = await getKeySSI();
            const loadRawDossier = promisify(resolver.loadDSU);
            try {
                this.rawDossier = await loadRawDossier(keySSI);
                global.rawDossier = this.rawDossier;
            } catch (err) {
                console.log(err);
                return callback(err);
            }

            const listFiles = promisify(this.rawDossier.listFiles);
            const readFile = promisify(this.rawDossier.readFile);

            let isBootFilePresent;
            let bootConfig;
            try {
                let allFiles = await listFiles(constants.CODE_FOLDER);
                console.log("allFiles", allFiles);
                isBootFilePresent = allFiles.some((file) => file === constants.BOOT_CONFIG_FILE);
                if (isBootFilePresent) {
                    const bootConfigFile = `${constants.CODE_FOLDER}/${constants.BOOT_CONFIG_FILE}`;
                    let bootConfigfileContent = await readFile(bootConfigFile);
                    bootConfig = JSON.parse(bootConfigfileContent.toString());
                }
            } catch (error) {
                console.error("Cannot check boot config file", error);
                return callback(error);
            }

            if (!isBootFilePresent || !bootConfig) {
                return;
            }

            const { runtimeBundles, constitutionBundles } = bootConfig;

            if (typeof runtimeBundles !== "undefined" && !Array.isArray(runtimeBundles)) {
                return callback(new Error("runtimeBundles is not array"));
            }

            if (typeof constitutionBundles !== "undefined" && !Array.isArray(constitutionBundles)) {
                return callback(new Error("constitutionBundles is not array"));
            }

            try {
                await evalBundles(runtimeBundles);
            } catch (err) {
                if (err.type !== "PSKIgnorableError") {
                    console.log(err);
                    return callback(err);
                }
            }

            if (typeof constitutionBundles !== "undefined") {
                try {
                    await evalBundles(constitutionBundles, true);
                } catch (err) {
                    console.log(err);
                    return callback(err);
                }
            }
        };

        __boot()
            .then(() => callback(undefined, this.rawDossier))
            .catch(callback);
    };
}

function promisify(fn) {
    return function (...args) {
        return new Promise((resolve, reject) => {
            fn(...args, (err, ...res) => {
                if (err) {
                    console.log(err);
                    reject(err);
                } else {
                    resolve(...res);
                }
            });
        });
    };
}

module.exports = BootEngine;

}).call(this)}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"opendsu":"opendsu","swarmutils":"swarmutils"}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/boot/NodeBootScript.js":[function(require,module,exports){
function boot(keySSI) {
    const worker_threads = "worker_threads";
    const { parentPort } = require(worker_threads);
    const { handleMessage } = require("./boot-utils.js");

    parentPort.on("message", (message) => {
        handleMessage(message, (error, result) => {
            parentPort.postMessage({ error, result });
        });
    });

    process.on("uncaughtException", (err) => {
        console.error("[worker] unchaughtException inside worker", err);
        setTimeout(() => {
            process.exit(1);
        }, 100);
    });

    function getKeySSI(callback) {
        callback(null, keySSI);
    }

    const BootEngine = require("./BootEngine.js");

    console.log(`[worker] booting DSU for keySSI ${keySSI}...`);

    const booter = new BootEngine(getKeySSI);

    booter.boot((error) => {
        if (error) {
            parentPort.postMessage({ error });
            throw error;
        }

        console.log("[worker] ready");
        parentPort.postMessage("ready");
    });
}

module.exports = boot;

},{"./BootEngine.js":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/boot/BootEngine.js","./boot-utils.js":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/boot/boot-utils.js"}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/boot/WorkerBootScript.js":[function(require,module,exports){
function boot(keySSI) {
    const { handleMessage } = require("./boot-utils.js");

    onmessage = (message) => {
        handleMessage(message.data, (error, result) => {
            postMessage({ error, result });
        });
    };

    function getKeySSI(callback) {
        callback(null, keySSI);
    }

    const BootEngine = require("./BootEngine.js");

    console.log(`[worker] booting DSU for keySSI ${keySSI}...`);

    const booter = new BootEngine(getKeySSI);

    booter.boot((error) => {
        if (error) {
            postMessage({ error });
            throw error;
        }

        console.log("[worker] ready");
        postMessage("ready");
    });
}

module.exports = boot;

},{"./BootEngine.js":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/boot/BootEngine.js","./boot-utils.js":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/boot/boot-utils.js"}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/boot/boot-utils.js":[function(require,module,exports){
function handleMessage(message, onHandleMessage) {
    // console.log("[worker] Received message", message);

    const { fn, api, args } = message;
    const callback = (error, result) => {
        console.log(`[worker] finished work ${message}`, error, result);

         // in order to ensure result serializability we JSON.stringify it if isn't a Buffer
         if (!$$.Buffer.isBuffer(result)) {
            result = JSON.stringify(result);
        }

        onHandleMessage(error, result);
    };
    try {
        const dsuArgs = [...args, callback];

        if (api) {
            // need to call the DSU's api.js method
            this.rawDossier.call(api, ...dsuArgs);
            return;
        }

        if (fn) {
            this.rawDossier[fn].apply(this.rawDossier, dsuArgs);
            return;
        }

        callback(new Error(`Received unknown task: ${JSON.stringify(message)}`));
    } catch (error) {
        onHandleMessage(error);
    }
}

module.exports = {
    handleMessage,
};

},{}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/boot/index.js":[function(require,module,exports){
let { ENVIRONMENT_TYPES } = require("../moduleConstants.js");

function getBootScript() {
    switch ($$.environmentType) {
        case ENVIRONMENT_TYPES.WEB_WORKER_ENVIRONMENT_TYPE:
            return require("./WorkerBootScript");
        case ENVIRONMENT_TYPES.NODEJS_ENVIRONMENT_TYPE:
            return require("./NodeBootScript");
        default:
            throw new Error(`Current environment ${$$.environmentType} doesn't support opendsu boot script!`);
    }
}

module.exports = getBootScript();

},{"../moduleConstants.js":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/moduleConstants.js","./NodeBootScript":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/boot/NodeBootScript.js","./WorkerBootScript":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/boot/WorkerBootScript.js"}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/bricking/index.js":[function(require,module,exports){
const openDSU = require("opendsu");
const constants = require("../moduleConstants");
const cache = require("../cache/").getCacheForVault(constants.CACHE.ENCRYPTED_BRICKS_CACHE);
const promiseRunner = require("../utils/promise-runner");
const {SmartUrl} = require("../utils");

const isValidBrickHash = (hashLinkSSI, brickData) => {
    const ensureIsBuffer = require("swarmutils").ensureIsBuffer;
    const crypto = openDSU.loadAPI("crypto");
    const hashFn = crypto.getCryptoFunctionForKeySSI(hashLinkSSI, "hash");
    const actualHash = hashFn(ensureIsBuffer(brickData));
    const expectedHash = hashLinkSSI.getHash();
    return actualHash === expectedHash;
}

/**
 * Get brick
 * @param {hashLinkSSI} hashLinkSSI
 * @param {string} authToken
 * @param {function} callback
 * @returns {any}
 */
const getBrick = (hashLinkSSI, authToken, callback) => {
    const dlDomain = hashLinkSSI.getDLDomain();
    const brickHash = hashLinkSSI.getHash();
    if (typeof authToken === 'function') {
        callback = authToken;
        authToken = undefined;
    }

    if (typeof cache === "undefined") {
        __getBrickFromEndpoint();
    } else {
        cache.get(brickHash, (err, brick) => {
            if (err || typeof brick === "undefined") {
                __getBrickFromEndpoint();
            } else {
                callback(undefined, brick);
            }
        });
    }

    function __getBrickFromEndpoint() {
        const bdns = openDSU.loadApi("bdns");
        bdns.getBrickStorages(dlDomain, (err, brickStorageArray) => {
            if (err) {
                return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to get brick storage services from bdns`, err));
            }

            if (!brickStorageArray.length) {
                return callback('No storage provided');
            }

            const fetchBrick = (storage) => {
                let smartUrl = new SmartUrl(storage);
                smartUrl = smartUrl.concatWith(`/bricking/${dlDomain}/get-brick/${brickHash}`);

                return smartUrl.fetch().then(async (response) => {
                    const brickData = await response.arrayBuffer();
                    if (isValidBrickHash(hashLinkSSI, brickData)) {
                        if (typeof cache !== "undefined") {
                            cache.put(brickHash, brickData);
                        }
                        return brickData;
                    }
                    throw Error(`Failed to validate brick <${brickHash}>`);
                });
            };

            const runnerCallback = (error, result) => {
                if (error) {
                    return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to get brick <${brickHash}> from brick storage`, error));
                }

                callback(null, result);
            }

            promiseRunner.runOneSuccessful(brickStorageArray, fetchBrick, runnerCallback, "get brick");
        });
    }

};

/**
 * Get multiple bricks
 * @param {hashLinkSSIList} hashLinkSSIList
 * @param {string} authToken
 * @param {function} callback
 */

const getMultipleBricks = (hashLinkSSIList, authToken, callback) => {
    if (typeof authToken === 'function') {
        callback = authToken;
        authToken = undefined;
    }
    const resultsArr = new Array(hashLinkSSIList.length);
    let currentPointer = -1;

    function getTask(taskNumber) {
        const hashLink = hashLinkSSIList[taskNumber];
        getBrick(hashLink, authToken, (err, brickData) => {
            if (err) {
                return callback(err);
            }

            resultsArr[taskNumber] = brickData;
            attemptCallback();
        });
    }

    function attemptCallback() {
        while (resultsArr[currentPointer + 1]) {
            currentPointer++;
            callback(undefined, resultsArr[currentPointer]);
        }
    }

    // The bricks need to be returned in the same order they were requested
    for (let i = 0; i < hashLinkSSIList.length; i++) {
        getTask(i);
    }
};


/**
 * Put brick
 * @param {keySSI} keySSI
 * @param {ReadableStream} brick
 * @param {string} authToken
 * @param {function} callback
 * @returns {string} brickhash
 */
const putBrick = (domain, brick, authToken, callback) => {
    if (typeof authToken === 'function') {
        callback = authToken;
        authToken = undefined;
    }

    const bdns = openDSU.loadApi("bdns");
    bdns.getBrickStorages(domain, (err, brickStorageArray) => {
        if (err) {
            return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to get brick storage services from bdns`, err));
        }
        const setBrickInStorage = (storage) => {
            return new Promise((resolve, reject) => {
                let smartUrl = new SmartUrl(storage);
                smartUrl = smartUrl.concatWith(`/bricking/${domain}/put-brick`);

                const putResult = smartUrl.doPut(brick, (err, data) => {
                    if (err) {
                        return reject(err);
                    }

                    return resolve(data);
                });
                if (putResult) {
                    putResult.then(resolve).catch(reject);
                }
            })
        };

        promiseRunner.runEnoughForMajority(brickStorageArray, setBrickInStorage, null, null, (err, results) => {
            if (err) {
                return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper("Failed to create bricks", err));
            }

            const foundBrick = results[0];
            const brickHash = JSON.parse(foundBrick).message;
            if (typeof cache === "undefined") {
                return callback(undefined, brickHash)
            }

            cache.put(brickHash, brick, (err) => {
                if (err) {
                    return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to put brick <${brickHash}> in cache`, err));
                }
                callback(undefined, brickHash);
            })

        }, "Storing a brick");
    });
};

const constructBricksFromData = (keySSI, data, options, callback) => {
    const MAX_BRICK_SIZE = 1024 * 1024; // 1MB
    const defaultOpts = {encrypt: true, maxBrickSize: MAX_BRICK_SIZE};

    if (typeof options === "function") {
        callback = options;
        options = {
            maxBrickSize: MAX_BRICK_SIZE
        };
    }

    options = Object.assign({}, defaultOpts, options);

    const bar = require("bar");
    const archiveConfigurator = bar.createArchiveConfigurator();
    archiveConfigurator.setBufferSize(options.maxBrickSize);
    archiveConfigurator.setKeySSI(keySSI);

    const envTypes = require("overwrite-require").constants;
    if ($$.environmentType !== envTypes.BROWSER_ENVIRONMENT_TYPE &&
        $$.environmentType !== envTypes.SERVICE_WORKER_ENVIRONMENT_TYPE &&
        $$.environmentType !== envTypes.WEB_WORKER_ENVIRONMENT_TYPE) {
        const fsAdapter = require('bar-fs-adapter');
        const ArchiveConfigurator = require("bar").ArchiveConfigurator;
        ArchiveConfigurator.prototype.registerFsAdapter("FsAdapter", fsAdapter.createFsAdapter);
        archiveConfigurator.setFsAdapter("FsAdapter");
    }

    const brickStorageService = bar.createBrickStorageService(archiveConfigurator, keySSI);

    brickStorageService.ingestData(data, options, (err, result) => {
        if (err) {
            return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper("Failed to ingest data into brick storage service", err));
        }

        callback(undefined, result);
    });
}

module.exports = {getBrick, putBrick, getMultipleBricks, constructBricksFromData};

},{"../cache/":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/cache/index.js","../moduleConstants":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/moduleConstants.js","../utils":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/utils/index.js","../utils/promise-runner":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/utils/promise-runner.js","bar":"bar","bar-fs-adapter":"bar-fs-adapter","opendsu":"opendsu","overwrite-require":"overwrite-require","swarmutils":"swarmutils"}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/cache/FSCache.js":[function(require,module,exports){
let stores = {};
const config = require("opendsu").loadApi("config");
const CacheMixin = require("../utils/PendingCallMixin");
const constants = require("../moduleConstants");

function FSCache(folderName) {
    const self = this;
    CacheMixin(self);
    const fsName = "fs"; //do not tempt browserify
    const fs = require(fsName);
    let baseFolder = config.get(constants.CACHE.BASE_FOLDER_CONFIG_PROPERTY);
    if (typeof baseFolder === "undefined") {
        baseFolder = process.cwd();
    }
    const path = require("swarmutils").path;
    const folderPath = path.join(baseFolder, folderName);
    let storageFolderIsCreated = false;
    fs.mkdir(folderPath, {recursive: true}, (err) => {
        if (err) {
            throw err;
        }

        storageFolderIsCreated = true;
    });

    self.get = function (key, callback) {
        if (!storageFolderIsCreated) {
            self.addPendingCall(() => {
                self.get(key, callback);
            })
        } else {
            const filePath =path.join(folderPath, key)
            fs.readFile(filePath, (err, data) => {
                if (err) {
                    return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to read file <${filePath}>`, err));
                }

                let content = data;
                try {
                    if(content != undefined && content != "undefined"){
                        content = JSON.parse(content.toString())
                    } else {
                        callback(undefined, undefined);
                    }
                } catch (e) {
                    console.log(e, content);
                    if(callback){
                        return callback(e);
                    }
                    return undefined;
                }
                callback(undefined, content);
            });
        }
    };

    self.put = function (key, value, callback) {
        if (Array.isArray(value)) {
            value = JSON.stringify(value);
        }
        if (!storageFolderIsCreated) {
            self.addPendingCall(() => {
                self.put(key, value, callback);
            });
        } else {
            if (!callback) {
                callback = () => {
                };
            }
            fs.writeFile(path.join(folderPath, key), value, callback);
        }
    }

    self.set = self.put;
}



module.exports.FSCache = FSCache;
},{"../moduleConstants":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/moduleConstants.js","../utils/PendingCallMixin":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/utils/PendingCallMixin.js","opendsu":"opendsu","swarmutils":"swarmutils"}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/cache/IndexeDBCache.js":[function(require,module,exports){
let stores = {};
const config = require("opendsu").loadApi("config");
const CacheMixin = require("../utils/PendingCallMixin");
const constants = require("../moduleConstants");

function IndexedDBCache(storeName, lifetime) {
    const self = this;
    CacheMixin(self);

    let db;
    let openRequest = indexedDB.open(storeName);
    openRequest.onsuccess = () => {
        db = openRequest.result;
        self.executePendingCalls();
        self.executeSerialPendingCalls();
    };

    openRequest.onupgradeneeded = () => {
        db = openRequest.result;
        db.createObjectStore(storeName);
    };

    self.get = (key, callback) => {
        if (typeof db === "undefined") {
            self.addPendingCall(() => {
                self.get(key, callback);
            });
        } else {
            let transaction = db.transaction(storeName, "readonly");
            const store = transaction.objectStore(storeName);
            let req = store.get(key);
            transaction.oncomplete = () => {
                if (typeof lifetime !== "undefined") {
                    const currentTime = Date.now();
                    const timestampedData = req.result;
                    if (typeof timestampedData === "undefined") {
                        return callback();
                    }
                    if (currentTime - timestampedData.timestamp > lifetime) {
                        self.delete(key);
                        return callback();
                    }
                    callback(undefined, timestampedData.value)
                } else {
                    callback(undefined, req.result);
                }
            }
        }
    };

    self.put = (key, value, callback) => {
        self.addSerialPendingCall((next) => {
            let transaction;
            let store
            try {
                transaction = db.transaction(storeName, "readwrite");
                store = transaction.objectStore(storeName);
            }catch (e) {
                callback(e);
                return next();
            }
            let data;
            if (typeof lifetime !== "undefined") {
                data = {
                    value: value,
                    timestamp: Date.now()
                }
            } else {
                data = value;
            }
            let req = store.put(data, key);
            transaction.oncomplete = () => {
                if (typeof callback === "function") {
                    callback(undefined, key);
                }
                next();
            }
            transaction.onabort = function() {
                console.log("Error", transaction.error);
            };
            req.onerror = function (event){
                next();
            }
        });
    };


    self.set = self.put;

    self.delete = (key, callback) => {
            self.addSerialPendingCall((next) => {
                let transaction;
                let store;
                try {
                    transaction = db.transaction(storeName, "readwrite");
                    store = transaction.objectStore(storeName);
                }catch (e) {
                    callback(e);
                    next();
                    return;
                }
                let req = store.delete(key);
                transaction.oncomplete = () => {
                    if (typeof callback === "function") {
                        callback(undefined, key);
                    }
                    next();
                }
                transaction.onabort = function() {
                    console.log("Error", transaction.error);
                };
                req.onerror = function (event){
                    next();
                }
            });
    }
}


module.exports.IndexedDBCache  = IndexedDBCache;
},{"../moduleConstants":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/moduleConstants.js","../utils/PendingCallMixin":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/utils/PendingCallMixin.js","opendsu":"opendsu"}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/cache/MemoryCache.js":[function(require,module,exports){

const constants = require("../moduleConstants");

function MemoryCache(useWeakRef) {
    let storage = {};
    const self = this;

    self.get = function (key, callback) {
        if(typeof key !== "string"){
            throw new Error("Keys should be strings");
        }

        let value = storage[key];
        if(value && useWeakRef){
            value = value.deref();
        }
        if(callback){
            callback(undefined, value);
        }
        return value;
    };

    self.put = function (key, value, callback) {
        if(typeof key !== "string"){
            throw new Error("Keys should be strings");
        }
        if(useWeakRef){
            value = value ? new WeakRef(value) : value;
        }
        storage[key] = value;
        if(callback){
            callback(undefined, true)
        }
    }

    self.set = self.put;
}


module.exports.MemoryCache = MemoryCache;
},{"../moduleConstants":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/moduleConstants.js"}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/cache/index.js":[function(require,module,exports){
let stores = {};
const config = require("opendsu").loadApi("config");
const CacheMixin = require("../utils/PendingCallMixin");
const constants = require("../moduleConstants");

const IndexedDBCache = require("./IndexeDBCache").IndexedDBCache;
const FSCache        = require("./FSCache").FSCache;
const MemoryCache    = require("./MemoryCache").MemoryCache;

function getCacheForVault(storeName, lifetime) {
    if (typeof stores[storeName] === "undefined") {
        switch (config.get(constants.CACHE.VAULT_TYPE)) {
            case constants.CACHE.INDEXED_DB:
                stores[storeName] = new IndexedDBCache(storeName, lifetime);
                break;
            case constants.CACHE.FS:
                stores[storeName] = new FSCache(storeName, lifetime);
                break;
            case constants.CACHE.MEMORY:
                stores[storeName] = new MemoryCache(storeName, lifetime);
                break;
            case constants.CACHE.NO_CACHE:
                break;
            default:
                throw Error("Invalid cache type");
        }
    }

    return stores[storeName];
}

function getMemoryCache(storeName){
    return stores[storeName] = new MemoryCache();
}

function getWeakRefMemoryCache(storeName){
    let cache = stores[storeName];
    if(!cache){
        cache = new MemoryCache(true);
        stores[storeName] = cache;
    }
    return cache;
}

module.exports = {
    getCacheForVault,
    getMemoryCache,
    getWeakRefMemoryCache
}
},{"../moduleConstants":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/moduleConstants.js","../utils/PendingCallMixin":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/utils/PendingCallMixin.js","./FSCache":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/cache/FSCache.js","./IndexeDBCache":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/cache/IndexeDBCache.js","./MemoryCache":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/cache/MemoryCache.js","opendsu":"opendsu"}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/config/autoConfig.js":[function(require,module,exports){
const config = require("./index");
const constants = require("../moduleConstants");
const system = require("../system");
const getBaseURL = require("../utils/getBaseURL");
const errorModule = require("../error");

system.setEnvironmentVariable(constants.BDNS_ROOT_HOSTS, `${getBaseURL()}/bdns#x-blockchain-domain-request`);
switch ($$.environmentType) {
    case constants.ENVIRONMENT_TYPES.SERVICE_WORKER_ENVIRONMENT_TYPE:
    case constants.ENVIRONMENT_TYPES.WEB_WORKER_ENVIRONMENT_TYPE:
        config.set(constants.CACHE.VAULT_TYPE, constants.CACHE.INDEXED_DB);
        break;
    case constants.ENVIRONMENT_TYPES.BROWSER_ENVIRONMENT_TYPE:
        config.set(constants.CACHE.VAULT_TYPE, constants.CACHE.INDEXED_DB);
        break;
    case constants.ENVIRONMENT_TYPES.NODEJS_ENVIRONMENT_TYPE:
        config.set(constants.CACHE.VAULT_TYPE, constants.CACHE.NO_CACHE);
        break;

    default:
}

config.set(constants.CACHE.BASE_FOLDER_CONFIG_PROPERTY, constants.CACHE.BASE_FOLDER);

setGlobalVariable("createOpenDSUErrorWrapper", errorModule.createOpenDSUErrorWrapper);
setGlobalVariable("OpenDSUSafeCallback", errorModule.OpenDSUSafeCallback);
setGlobalVariable("reportUserRelevantWarning", errorModule.reportUserRelevantWarning);
setGlobalVariable("reportUserRelevantInfo", errorModule.reportUserRelevantInfo);
setGlobalVariable("reportDevRelevantInfo", errorModule.reportDevRelevantInfo);
setGlobalVariable("reportUserRelevantError", errorModule.reportUserRelevantError);
setGlobalVariable("registerMandatoryCallback", errorModule.registerMandatoryCallback);
setGlobalVariable("printOpenDSUError", errorModule.printOpenDSUError);




},{"../error":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/error/index.js","../moduleConstants":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/moduleConstants.js","../system":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/system/index.js","../utils/getBaseURL":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/utils/getBaseURL.js","./index":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/config/index.js"}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/config/autoConfigFromEnvironment.js":[function(require,module,exports){

module.exports = function(environment){
        const config = require("./index.js");
        const constants = require("../moduleConstants");
        //const systemEnvirnoment = require("../system");

        if(environment[constants.LOADER_ENVIRONMENT_JSON.VAULT] === constants.LOADER_ENVIRONMENT_JSON.SERVER){
            config.set(constants.CACHE.VAULT_TYPE, constants.CACHE.NO_CACHE);
        }

        if(environment[constants.LOADER_ENVIRONMENT_JSON.AGENT] === constants.LOADER_ENVIRONMENT_JSON.MOBILE){
            config.set(constants.CACHE.VAULT_TYPE, constants.CACHE.NO_CACHE);
            //systemEnvirnoment.setEnvironmentVariable(constants.BDNS_ROOT_HOSTS,
        }
        console.log("Environment for vault", environment.appName,  config.get(constants.CACHE.VAULT_TYPE))
}
},{"../moduleConstants":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/moduleConstants.js","./index.js":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/config/index.js"}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/config/index.js":[function(require,module,exports){
const constants = require("../moduleConstants");
const config = {};

function set(key, value) {
    config[key] = value;
}

function get(key) {
    return config[key];
}

function readEnvFile(callback) {
    const sc = require("opendsu").loadAPI("sc");
    sc.getMainDSU((err, mainDSU) => {
        if (err) {
            return callback(createOpenDSUErrorWrapper(`Failed to get main DSU`, err));
        }

        mainDSU.readFile(constants.ENVIRONMENT_PATH, (err, env) => {
            if (err) {
                return callback(createOpenDSUErrorWrapper(`Failed to get main DSU`, err));
            }

            try {
                env = JSON.parse(env.toString());
            } catch (e) {
                return callback(createOpenDSUErrorWrapper(`Failed parse env file`, e));
            }

            callback(undefined, env);
        });
    });
}

function writeEnvFile(env, callback) {
    const sc = require("opendsu").loadAPI("sc");
    sc.getMainDSU((err, mainDSU) => {
        if (err) {
            return callback(createOpenDSUErrorWrapper(`Failed to get main DSU`, err));
        }
        mainDSU.writeFile(constants.ENVIRONMENT_PATH, JSON.stringify(env), (err)=>{
            if (err) {
                return callback(createOpenDSUErrorWrapper(`Failed to write env`, err));
            }
            callback();
        });
    });
}


function setEnv(key, value, callback) {
    //update environment.json
    readEnvFile((err, env) => {
        if (err) {
            return callback(createOpenDSUErrorWrapper(`Failed to read env file`, err));
        }
        env[key] = value;
        writeEnvFile(env, callback);
    });
}

function getEnv(key, callback) {
    readEnvFile((err, env) => {
        if (err) {
            return callback(createOpenDSUErrorWrapper(`Failed to read env file`, err));
        }

        callback(undefined, env[key]);
    });
}

const autoconfigFromEnvironment = require("./autoConfigFromEnvironment");

function disableLocalVault() {
    set(constants.CACHE.VAULT_TYPE, constants.CACHE.NO_CACHE);
}

module.exports = {
    set,
    get,
    setEnv,
    getEnv,
    autoconfigFromEnvironment,
    disableLocalVault,
    readEnvFile
};


},{"../moduleConstants":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/moduleConstants.js","./autoConfigFromEnvironment":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/config/autoConfigFromEnvironment.js","opendsu":"opendsu"}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/contracts/index.js":[function(require,module,exports){
const getBaseURL = require("../utils/getBaseURL");

const {
    DomainNotSupportedError,
    getSafeCommandBody,
    getNoncedCommandBody,
    getContractEndpointUrl,
    callContractEndpoint,
    callContractEndpointUsingBdns,
} = require("./utils");

class CommandSender {
    constructor(baseUrl, fallbackToUrlFromBDNS) {
        this.baseUrl = baseUrl;
        this.fallbackToUrlFromBDNS = fallbackToUrlFromBDNS;
    }

    async sendCommand(method, contractEndpointPrefix, domain, commandBody, callback) {
        if (typeof commandBody === "function") {
            callback = commandBody;
            commandBody = null;
        }

        callback = $$.makeSaneCallback(callback);

        try {
            try {
                // try to send the command to the current apihub endpoint
                const currentApihubUrl = getContractEndpointUrl(this.baseUrl, domain, contractEndpointPrefix);
                const response = await callContractEndpoint(currentApihubUrl, method, domain, commandBody);
                callback(null, response);
            } catch (error) {
                // if the current apihub endpoint doesn't handle the current domain, then send the command using BDNS
                if (this.fallbackToUrlFromBDNS && error instanceof DomainNotSupportedError) {
                    callContractEndpointUsingBdns(method, contractEndpointPrefix, domain, commandBody, callback);
                    return;
                }
                throw error;
            }
        } catch (error) {
            OpenDSUSafeCallback(callback)(
                createOpenDSUErrorWrapper(`Failed to execute domain contract method: ${JSON.stringify(commandBody)}`, error)
            );
        }
    }

    generateSafeCommand(domain, contractName, methodName, params, callback) {
        if (typeof params === "function") {
            callback = params;
            params = null;
        }

        try {
            const commandBody = getSafeCommandBody(domain, contractName, methodName, params);
            this.sendCommand("POST", "safe-command", domain, commandBody, callback);
        } catch (error) {
            callback(error);
        }
    }

    async generateNoncedCommand(signerDID, domain, contractName, methodName, params, timestamp, callback) {
        if (typeof timestamp === "function") {
            callback = timestamp;

            // check if the param before provided callback is either the timestamp or the params, since both are optional
            if (typeof params === "number") {
                timestamp = params;
                params = null;
            } else {
                timestamp = null;
            }
        }

        if (typeof params === "function") {
            callback = params;
            params = null;
            timestamp = null;
        }
        if (!signerDID) {
            return callback("signerDID not provided");
        }

        if (!timestamp) {
            timestamp = Date.now();
        }

        try {
            if (typeof signerDID === "string") {
                // signerDID contains the identifier, so we need to load the DID
                const w3cDID = require("opendsu").loadAPI("w3cdid");
                signerDID = await $$.promisify(w3cDID.resolveDID)(signerDID);
            }

            const latestBlockInfo = await $$.promisify(this.sendCommand.bind(this))("GET", "latest-block-info", domain);
            const { number: blockNumber } = latestBlockInfo;

            const commandBody = await getNoncedCommandBody(domain, contractName, methodName, params, blockNumber, timestamp, signerDID);
            this.sendCommand("POST", "nonced-command", domain, commandBody, callback);
        } catch (error) {
            callback(error);
        }
    }
}

function generateSafeCommand(domain, contractName, methodName, params, callback) {
    const commandSender = new CommandSender(getBaseURL(), true);
    commandSender.generateSafeCommand(domain, contractName, methodName, params, callback);
}

async function generateNoncedCommand(signerDID, domain, contractName, methodName, params, timestamp, callback) {
    const commandSender = new CommandSender(getBaseURL(), true);
    commandSender.generateNoncedCommand(signerDID, domain, contractName, methodName, params, timestamp, callback);
}

function generateSafeCommandForSpecificServer(serverUrl, domain, contractName, methodName, params, callback) {
    if (!serverUrl || typeof serverUrl !== "string") {
        throw new Error(`Invalid serverUrl specified`);
    }
    const commandSender = new CommandSender(serverUrl);
    commandSender.generateSafeCommand(domain, contractName, methodName, params, callback);
}

function generateNoncedCommandForSpecificServer(
    serverUrl,
    signerDID,
    domain,
    contractName,
    methodName,
    params,
    timestamp,
    callback
) {
    if (!serverUrl || typeof serverUrl !== "string") {
        throw new Error(`Invalid serverUrl specified`);
    }
    const commandSender = new CommandSender(serverUrl);
    commandSender.generateNoncedCommand(signerDID, domain, contractName, methodName, params, timestamp, callback);
}

module.exports = {
    generateSafeCommand,
    generateNoncedCommand,
    generateSafeCommandForSpecificServer,
    generateNoncedCommandForSpecificServer,
};

},{"../utils/getBaseURL":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/utils/getBaseURL.js","./utils":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/contracts/utils.js","opendsu":"opendsu"}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/contracts/utils.js":[function(require,module,exports){
(function (Buffer){(function (){
const { fetch, doPost } = require("../http");
const promiseRunner = require("../utils/promise-runner");

class DomainNotSupportedError extends Error {
    constructor(domain, url) {
        super(`Domain '${domain}' not supported for calling URL ${url}`);
        this.name = "DomainNotSupportedError";
    }
}

function getCommandHash(command) {
    const { domain, contractName, methodName, params, type, blockNumber, timestamp } = command;

    const objectToHash = {
        domain,
        contractName,
        methodName,
        params,
    };

    if (type === "nonced") {
        objectToHash.blockNumber = blockNumber;
        objectToHash.timestamp = timestamp;
    }

    const crypto = require("opendsu").loadApi("crypto");
    const hash = crypto.sha256(objectToHash);

    return hash;
}

function getSafeCommandBody(domain, contractName, methodName, params) {
    if (!domain || typeof domain !== "string") {
        throw `Invalid domain specified: ${domain}!`;
    }
    if (!contractName || typeof contractName !== "string") {
        throw `Invalid contractName specified: ${contractName}!`;
    }
    if (!methodName || typeof methodName !== "string") {
        throw `Invalid methodName specified: ${methodName}!`;
    }

    if (params) {
        if (!Array.isArray(params)) {
            throw `Invalid params specified (must be a list): ${params}!`;
        }
    }

    return {
        domain,
        contractName,
        methodName,
        params,
        type: "safe",
    };
}

async function getNoncedCommandBody(domain, contract, method, params, blockNumber, timestamp, signerDID) {
    if (!signerDID) {
        // params field is optional
        signerDID = timestamp;
        timestamp = blockNumber;
        blockNumber = params;
        params = null;
    }

    const commandBody = getSafeCommandBody(domain, contract, method, params);
    commandBody.type = "nonced";
    commandBody.blockNumber = blockNumber;
    commandBody.timestamp = timestamp;
    commandBody.signerDID = signerDID.getIdentifier();

    const hash = getCommandHash(commandBody);
    let signature = await $$.promisify(signerDID.sign)(hash);
    
    if (Buffer.isBuffer(signature)) {
        signature = signature.toString('hex')
    }

    commandBody.requesterSignature = signature;

    return commandBody;
}

function getContractEndpointUrl(baseUrl, domain, contractEndpointPrefix) {
    return `${baseUrl}/contracts/${domain}/${contractEndpointPrefix}`;
}

async function callContractEndpoint(url, method, domain, body) {
    let response;
    if (method === "GET") {
        response = await fetch(url);
        if (response.statusCode === 404) {
            throw new DomainNotSupportedError(domain, url);
        }

        response = await response.json();
    } else {
        try {
            response = await $$.promisify(doPost)(url, body);
        } catch (error) {
            if (error.statusCode === 404) {
                throw new DomainNotSupportedError(domain, url);
            }
            throw error;
        }
    }

    if (response) {
        try {
            response = JSON.parse(response);
        } catch (error) {
            // the response isn't a JSON so we keep it as it is
        }

        if (response.optimisticResult) {
            try {
                response.optimisticResult = JSON.parse(response.optimisticResult);
            } catch (error) {
                // the response isn't a JSON so we keep it as it is
            }
        }
    }

    return response;
}

async function callContractEndpointUsingBdns(method, contractEndpointPrefix, domain, commandBody, callback) {
    let contractServicesArray = [];
    try {
        const bdns = require("opendsu").loadApi("bdns");
        contractServicesArray = await $$.promisify(bdns.getContractServices)(domain);
    } catch (error) {
        return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to get contract services from bdns'`, error));
    }

    if (!contractServicesArray.length) {
        return callback("No contract service provided");
    }
    const runContractMethod = async (service) => {
        const url = getContractEndpointUrl(service, domain, contractEndpointPrefix);
        const response = await callContractEndpoint(url, method, domain, commandBody);
        return response;
    };

    promiseRunner.runOneSuccessful(contractServicesArray, runContractMethod, callback, new Error("get Contract Service"));
}

module.exports = {
    DomainNotSupportedError,
    getSafeCommandBody,
    getNoncedCommandBody,
    getContractEndpointUrl,
    callContractEndpoint,
    callContractEndpointUsingBdns,
};

}).call(this)}).call(this,{"isBuffer":require("../../../node_modules/is-buffer/index.js")})

},{"../../../node_modules/is-buffer/index.js":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/node_modules/is-buffer/index.js","../http":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/http/index.js","../utils/promise-runner":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/utils/promise-runner.js","opendsu":"opendsu"}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/credentials/InstanceReadyMixin.js":[function(require,module,exports){
function InstanceReadyMixin(target) {

	target.isInstanceReady = false;
	target.instanceReadyCallback = null;

	target.onInstanceReady = (callback) => {
		if (target.isInstanceReady) {
			callback(...target.args);
			target.args = null;
			return;
		}

		target.instanceReadyCallback = callback;
	};

	target.notifyInstanceReady = (...args) => {
		target.isInstanceReady = true;
		if (typeof target.instanceReadyCallback === 'function') {
			target.instanceReadyCallback(...args);
			target.isInstanceReady = false;
			target.instanceReadyCallback = null;
		} else {
			target.args = [...args];
		}
	};
}

module.exports = InstanceReadyMixin;
},{}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/credentials/constants.js":[function(require,module,exports){
const JWT_ERRORS = {
	EMPTY_JWT_PROVIDED: 'EMPTY_JWT_PROVIDED',
	INVALID_JWT_FORMAT: 'INVALID_JWT_FORMAT',
	INVALID_JWT_HEADER: 'INVALID_JWT_HEADER',
	INVALID_JWT_HEADER_TYPE: 'INVALID_JWT_HEADER_TYPE',
	INVALID_JWT_PAYLOAD: 'INVALID_JWT_PAYLOAD',
	INVALID_JWT_SIGNATURE: 'INVALID_JWT_SIGNATURE',
	INVALID_ISSUER_FORMAT: 'INVALID_ISSUER_FORMAT',
	INVALID_SUBJECT_FORMAT: 'INVALID_SUBJECT_FORMAT',
	INVALID_EXPIRATION_DATE: 'INVALID_EXPIRATION_DATE',
	INVALID_PUBLIC_CLAIM: 'INVALID_PUBLIC_CLAIM',
	INVALID_SUBJECT_CLAIM: 'INVALID_SUBJECT_CLAIM',
	IMMUTABLE_PUBLIC_CLAIM: 'IMMUTABLE_PUBLIC_CLAIM',
	INVALID_CONTEXT_URI: 'INVALID_CONTEXT_URI',
	INVALID_CONTEXT_TYPE: 'INVALID_CONTEXT_TYPE',
	IMMUTABLE_SUBJECT_CLAIM: 'IMMUTABLE_SUBJECT_CLAIM',
	INVALID_SUBJECT_ID: 'INVALID_SUBJECT_ID',
	PROVIDED_SUBJECT_ID_NOT_PRESENT: 'PROVIDED_SUBJECT_ID_NOT_PRESENT',
	JWT_TOKEN_EXPIRED: 'JWT_TOKEN_EXPIRED',
	JWT_TOKEN_NOT_ACTIVE: 'JWT_TOKEN_NOT_ACTIVE',
	ROOT_OF_TRUST_NOT_VALID: 'ROOT_OF_TRUST_NOT_VALID',
	AUDIENCE_OF_PRESENTATION_NOT_DEFINED: 'AUDIENCE_OF_PRESENTATION_NOT_DEFINED',
	HOLDER_AND_VERIFIER_MUST_BE_DID: 'HOLDER_AND_VERIFIER_MUST_BE_DID'
};


const JWT_DEFAULTS = {
	ALG: 'ES256',
	TYP: 'JWT',
	VC_VP_CONTEXT_CREDENTIALS: 'https://www.w3.org/2018/credentials/v1',
	VC_TYPE: 'VerifiableCredential',
	VP_TYPE: 'VerifiablePresentation',
	EXP: (365 * 24 * 60 * 60), // 1 year default,
	EMPTY_VC_VP: {
		context: [], type: []
	}
};

const LABELS = {
	ISSUER_DID: 'issuerDID',
	ISSUER_SSI: 'issuerSSI',
	SUBJECT_DID: 'subjectDID',
	SUBJECT_SSI: 'subjectSSI'
};

function getDefaultJWTOptions() {
	const now = Date.now();
	return {
		iat: now, nbf: now, exp: now + JWT_DEFAULTS.EXP
	};
}

const IMMUTABLE_PUBLIC_CLAIMS = ['vc', 'vp', 'iss', 'sub', 'iat', 'verifiableCredential', 'holder'];

const VALIDATION_STRATEGIES = {
	DEFAULT: "DEFAULT",
	ROOTS_OF_TRUST: "ROOTS_OF_TRUST",
	INVALID_VALIDATION_STRATEGY: "INVALID_VALIDATION_STRATEGY"
};

module.exports = {
	JWT_DEFAULTS,
	JWT_ERRORS,
	LABELS,
	IMMUTABLE_PUBLIC_CLAIMS,
	getDefaultJWTOptions: getDefaultJWTOptions,
	VALIDATION_STRATEGIES
};
},{}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/credentials/index.js":[function(require,module,exports){
const {createJWTVc, loadJWTVc} = require('./vc/jwtVc');
const {createJWTVp, loadJWTVp} = require('./vp/jwtVp');
const validationStrategies = require('./validationStrategies');
const {parseJWTSegments} = require('./utils');

function createJWTVerifiableCredential(issuer, subject, options, callback) {
    if (typeof options === 'function') {
        callback = options;
        options = {};
    }

    const jwtInstance = createJWTVc(issuer, subject, options);
    jwtInstance.onInstanceReady((err) => {
        if (err) {
            return callback(err);
        }

        callback(undefined, jwtInstance);
    });
}

async function createJWTVerifiableCredentialAsync(issuer, subject, options) {
    return $$.promisify(createJWTVerifiableCredential)(issuer, subject, options);
}

function loadJWTVerifiableCredential(encodedJWTVc, callback) {
    const jwtInstance = loadJWTVc(encodedJWTVc);
    jwtInstance.onInstanceReady((err) => {
        if (err) {
            return callback(err);
        }

        callback(undefined, jwtInstance);
    });
}

async function loadJWTVerifiableCredentialAsync(encodedJWTVc) {
    return $$.promisify(loadJWTVerifiableCredential)(encodedJWTVc);
}

function createJWTVerifiablePresentation(issuer, options, callback) {
    if (typeof options === 'function') {
        callback = options;
        options = {};
    }

    const jwtInstance = createJWTVp(issuer, options);
    jwtInstance.onInstanceReady((err) => {
        if (err) {
            return callback(err);
        }

        callback(undefined, jwtInstance);
    });
}

async function createJWTVerifiablePresentationAsync(issuer, options) {
    return $$.promisify(createJWTVerifiablePresentation)(issuer, options);
}

function loadJWTVerifiablePresentation(encodedJWTVp, callback) {
    const jwtInstance = loadJWTVp(encodedJWTVp);
    jwtInstance.onInstanceReady((err) => {
        if (err) {
            return callback(err);
        }

        callback(undefined, jwtInstance);
    });
}

async function loadJWTVerifiablePresentationAsync(encodedJWTVp) {
    return $$.promisify(loadJWTVerifiablePresentation)(encodedJWTVp);
}

module.exports = {
    createJWTVerifiableCredential,
    createJWTVerifiableCredentialAsync,
    createJWTVerifiablePresentation,
    createJWTVerifiablePresentationAsync,
    loadJWTVerifiableCredential,
    loadJWTVerifiableCredentialAsync,
    loadJWTVerifiablePresentation,
    loadJWTVerifiablePresentationAsync,
    validationStrategies,
    parseJWTSegments,
    JWT_ERRORS: require('./constants').JWT_ERRORS
};
},{"./constants":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/credentials/constants.js","./utils":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/credentials/utils.js","./validationStrategies":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/credentials/validationStrategies/index.js","./vc/jwtVc":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/credentials/vc/jwtVc.js","./vp/jwtVp":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/credentials/vp/jwtVp.js"}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/credentials/jwt/index.js":[function(require,module,exports){
const { JWT_ERRORS, IMMUTABLE_PUBLIC_CLAIMS } = require('../constants');
const { base64UrlEncode } = require('../utils');
const { signJWT } = require('./sign');
const instanceReadyMixin = require('../InstanceReadyMixin');

class JWT {

	constructor() {
		this.jwtHeader = null;
		this.jwtPayload = null;
		instanceReadyMixin(this);
	}

	getEncodedJWT(callback) {
		signJWT(this.jwtHeader, this.jwtPayload, (err, jwtSignature) => {
			if (err) {
				return callback(err);
			}

			const encodedJWT = [base64UrlEncode(JSON.stringify(this.jwtHeader)), base64UrlEncode(JSON.stringify(this.jwtPayload)), jwtSignature].join('.');
			callback(undefined, encodedJWT);
		});
	};

	async getEncodedJWTAsync() {
		return this.asyncMyFunction(this.getEncodedJWT, [...arguments]);
	}

	/**
	 * This method embeds one or more public claims about the JWT. These claims are not reflected within VC body
	 * @param claimName {string} - The name of the public claim. Reserved public claims: "vc", "vp", "iss", "sub", "iat"
	 * @param claimValue - The value of the public claim
	 * @param callback
	 */
	embedClaim(claimName, claimValue, callback) {
		if (typeof claimName !== 'string') {
			return callback(JWT_ERRORS.INVALID_PUBLIC_CLAIM);
		}

		if (IMMUTABLE_PUBLIC_CLAIMS.findIndex(cl => cl === claimName) !== -1) {
			return callback(JWT_ERRORS.IMMUTABLE_PUBLIC_CLAIM);
		}

		this.jwtPayload[claimName] = claimValue;
		callback(undefined, true);
	};

	async embedClaimAsync(claimName, claimValue) {
		return this.asyncMyFunction(this.embedClaim, [...arguments]);
	}

	/**
	 * This method is used to extend the expiration date of a JWT
	 * @param timeInSeconds {Number}
	 * @param callback
	 */
	extendExpirationDate(timeInSeconds, callback) {
		if (typeof timeInSeconds !== 'number' || timeInSeconds <= 0) {
			return callback(JWT_ERRORS.INVALID_EXPIRATION_DATE);
		}

		this.jwtPayload.exp = this.jwtPayload.exp + timeInSeconds * 1000;
		callback(undefined, true);
	};

	async extendExpirationDateAsync(timeInSeconds) {
		return this.asyncMyFunction(this.extendExpirationDate, [...arguments]);
	}

	asyncMyFunction = (func, params) => {
		func = func.bind(this);
		return new Promise((resolve, reject) => {
			func(...params, (err, data) => {
				if (err) {
					return reject(err);
				}
				resolve(data);
			});
		});
	};
}

module.exports = JWT;
},{"../InstanceReadyMixin":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/credentials/InstanceReadyMixin.js","../constants":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/credentials/constants.js","../utils":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/credentials/utils.js","./sign":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/credentials/jwt/sign.js"}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/credentials/jwt/model.js":[function(require,module,exports){
const { JWT_DEFAULTS, JWT_ERRORS, getDefaultJWTOptions } = require('../constants');
const utils = require('../utils');

/**
 * This method creates the header of a JWT according to the W3c Standard
 * @param options
 * @returns {{typ: string, alg: string}}
 */
function getRequiredJWTHeader(options) {
	const { alg, typ, kid } = options; // can be extended with other attributes

	return {
		alg: alg || JWT_DEFAULTS.ALG,
		typ: typ || JWT_DEFAULTS.TYP,
		// Used in case of asymmetric encryption of the signature.
		// Kid is actually the did of the verifier who can validate the signature.
		// This is part of signatureValidationStrategy proposal
		kid: kid
	};
}

/**
 * This method creates the payload of a JWT according to the W3c Standard
 * @param options {Object}
 * @returns {{sub, nbf, iss, exp, iat, aud, nonce}}
 */
function getRequiredJWTPayloadModel(options) {
	let { sub, iss, nbf, exp, iat, aud, jti, nonce } = options; // can be extended with other attributes

	// jti: Unique identifier; can be used to prevent the JWT from being replayed (allows a token to be used only once)
	return {
		sub, iss, nbf, exp, iat, aud, jti, nonce
	};
}

/**
 * This method creates the first signed JWT during a JWT instance initialisation
 * @param issuer
 * @param options
 * @param callback
 */
function defaultJWTBuilder(issuer, options, callback) {
	options = Object.assign({}, getDefaultJWTOptions(), options);

	issuer = utils.getReadableIdentity(issuer);
	if (!issuer) return callback(JWT_ERRORS.INVALID_ISSUER_FORMAT);

	const issuerFormat = utils.getIssuerFormat(issuer);
	if (!issuerFormat) return callback(JWT_ERRORS.INVALID_ISSUER_FORMAT);

	options.iss = issuer;
	const jwtHeader = getRequiredJWTHeader(options);
	const jwtPayload = getRequiredJWTPayloadModel(options);

	callback(undefined, { jwtHeader, jwtPayload, options });
}

/**
 *
 * @param encodedJWT {string}
 * @param callback {Function}
 */
function defaultJWTParser(encodedJWT, callback) {
	utils.parseJWTSegments(encodedJWT, (err, result) => {
		if (err) {
			return callback(err);
		}

		const { jwtHeader, jwtPayload } = result;
		if (!jwtHeader.typ || !jwtHeader.alg) return callback(JWT_ERRORS.INVALID_JWT_HEADER);
		if (!jwtPayload.iss) return callback(JWT_ERRORS.INVALID_JWT_ISSUER);

		callback(undefined, result);
	});
}

module.exports = {
	defaultJWTBuilder, defaultJWTParser
};
},{"../constants":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/credentials/constants.js","../utils":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/credentials/utils.js"}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/credentials/jwt/sign.js":[function(require,module,exports){
const openDSU = require('opendsu');
const w3cDID = openDSU.loadAPI('w3cdid');
const crypto = openDSU.loadAPI('crypto');
const keySSISpace = openDSU.loadApi('keyssi');
const keySSIResolver = require('key-ssi-resolver');
const cryptoRegistry = keySSIResolver.CryptoAlgorithmsRegistry;

const {LABELS, JWT_ERRORS} = require('../constants');
const {base64UrlEncode, getIssuerFormat, asymmetricalEncryption} = require('../utils');

/**
 * This method is signing the encoded header and payload of a JWT and returns the full signed JWT (header.payload.signature)
 * The JWT will be signed according to the type of the issuer (KeySSI, DID)
 * @param jwtHeader
 * @param jwtPayload
 * @param callback {Function}
 */
function signJWT(jwtHeader, jwtPayload, callback) {
    // TODO: If kid attribute is present inside jwtHeader and is a readable DID, the JWT will be asymmetrically signed using kid's value.
    //  This type of signing can be validated only by a verifier that is using Signature Validation Strategy. Also, create verify method for signature validation

    const issuer = jwtPayload.iss;
    const issuerType = getIssuerFormat(issuer);
    let dataToSign = [base64UrlEncode(JSON.stringify(jwtHeader)), base64UrlEncode(JSON.stringify(jwtPayload))].join('.');
    const kidType = getIssuerFormat(jwtHeader.kid);
    if (kidType === LABELS.ISSUER_DID) {
        dataToSign = base64UrlEncode(JSON.stringify({iss: issuer, kid: jwtHeader.kid}));
        return asymmetricalEncryption(issuer, jwtHeader.kid, dataToSign, callback);
    }

    switch (issuerType) {
        case LABELS.ISSUER_SSI: {
            return signUsingSSI(issuer, dataToSign, callback);
        }

        case LABELS.ISSUER_DID: {
            return signUsingDID(issuer, dataToSign, callback);
        }

        default: {
            return callback(JWT_ERRORS.INVALID_ISSUER_FORMAT);
        }
    }
}

/**
 * This method is signing a JWT using KeySSI
 * @param issuer
 * @param dataToSign
 * @param callback {Function}
 */
function signUsingSSI(issuer, dataToSign, callback) {
    try {
        const issuerKeySSI = keySSISpace.parse(issuer);
        const sign = cryptoRegistry.getSignFunction(issuerKeySSI);
        if (typeof sign !== 'function') {
            return callback(new Error('Signing not available for ' + issuerKeySSI.getIdentifier(true)));
        }

        const hashFn = cryptoRegistry.getCryptoFunction(issuerKeySSI, 'hash');
        const hashResult = hashFn(dataToSign);
        const signResult = sign(hashResult, issuerKeySSI.getPrivateKey());
        const encodedSignResult = base64UrlEncode(signResult);
        callback(undefined, encodedSignResult);
    } catch (e) {
        return callback(e);
    }
}

/**
 * This method is signing a JWT using DID
 * @param issuer
 * @param dataToSign
 * @param callback {Function}
 */
function signUsingDID(issuer, dataToSign, callback) {
    w3cDID.resolveDID(issuer, (err, didDocument) => {
        if (err) {
            return callback(`Failed to resolve did ${issuer}`);
        }

        const hashResult = crypto.sha256(dataToSign);
        didDocument.sign(hashResult, (signError, signResult) => {
            if (signError || !signResult) return callback(signError);
            const encodedSignResult = base64UrlEncode(signResult);
            callback(undefined, encodedSignResult);
        });
    });
}

module.exports = {
    signJWT
};
},{"../constants":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/credentials/constants.js","../utils":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/credentials/utils.js","key-ssi-resolver":"key-ssi-resolver","opendsu":"opendsu"}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/credentials/jwt/verify.js":[function(require,module,exports){
const opendsu = require('opendsu');
const w3cDID = opendsu.loadAPI('w3cdid');
const crypto = opendsu.loadAPI('crypto');
const keySSISpace = opendsu.loadApi('keyssi');
const keySSIResolver = require('key-ssi-resolver');
const cryptoRegistry = keySSIResolver.CryptoAlgorithmsRegistry;

const {JWT_ERRORS, LABELS} = require("../constants");
const {parseJWTSegments, asymmetricalDecryption, getIssuerFormat} = require("../utils");

/**
 * This method verifies the encrypted credentials using the private key of the audience. <br />
 * Only the intended audience can decrypt the encrypted credential to validate it.
 * @param jwtPayload
 * @param callback
 */
function verifyEncryptedCredential(jwtPayload, callback) {
    const verifyResult = { verifyResult: true, verifiableCredential: [] };
    const encryptedCredentials = jwtPayload.vp.verifiableCredential;
    const audience = jwtPayload.aud;
    if (!audience) {
        verifyResult.verifyResult = false;
        verifyResult.verifiableCredential.push({
            errorMessage: JWT_ERRORS.AUDIENCE_OF_PRESENTATION_NOT_DEFINED
        });

        return callback(undefined, verifyResult);
    }

    const chain = (index) => {
        if (index === encryptedCredentials.length) {
            return callback(undefined, verifyResult);
        }

        const encryptedCredential = encryptedCredentials[index];
        asymmetricalDecryption(audience, encryptedCredential, (err, decryptedJWTVc) => {
            if (err) {
                verifyResult.verifyResult = false;
                verifyResult.verifiableCredential.push({
                    jwtVc: encryptedCredential,
                    errorMessage: err
                });

                return chain(++index);
            }

            parseJWTSegments(decryptedJWTVc, (err, result) => {
                if (err) {
                    verifyResult.verifyResult = false;
                    verifyResult.verifiableCredential.push({
                        jwtVc: encryptedCredential,
                        errorMessage: err
                    });

                    return chain(++index);
                }

                verifyResult.verifiableCredential.push(result.jwtPayload);
                chain(++index);
            });
        });
    };

    chain(0);
}

/**
 * This method verifies if the roots of trust are the actual issuers of the verifiable credentials
 * @param jwtPayload
 * @param rootsOfTrust
 * @param callback
 */
function verifyRootsOfTrust(jwtPayload, rootsOfTrust, callback) {
    const jwtVcList = jwtPayload.vp.verifiableCredential;
    let verifyResult = { verifyResult: true, verifiableCredential: [] };

    const chain = (index) => {
        if (index === jwtVcList.length) {
            return callback(undefined, verifyResult);
        }

        const jwtVc = jwtVcList[index];
        parseJWTSegments(jwtVc, (err, result) => {
            if (err) {
                verifyResult.verifyResult = false;
                verifyResult.verifiableCredential.push({
                    jwtVc: jwtVc,
                    errorMessage: err
                });
                return chain(++index);
            }

            let jwtPayload = result.jwtPayload;
            const rootOfTrust = rootsOfTrust.find(r => r === jwtPayload.iss);
            if (!rootOfTrust) {
                verifyResult.verifyResult = false;
                verifyResult.verifiableCredential.push({
                    jwtVc: jwtVc,
                    errorMessage: JWT_ERRORS.ROOT_OF_TRUST_NOT_VALID
                });
                return chain(++index);
            }

            verifyResult.verifiableCredential.push(result.jwtPayload);
            chain(++index);
        });
    };

    chain(0);
}

/**
 * This method is verifying the encoded JWT from the current instance according to the issuerType
 * @param issuer
 * @param signature
 * @param signedData
 * @param options
 * @param callback {Function}
 */
function verifyJWT(issuer, signature, signedData, options, callback) {
    if (options.kid) {
        return asymmetricalDecryption(options.kid, signature, callback);
    }

    const issuerType = getIssuerFormat(issuer);
    switch (issuerType) {
        case LABELS.ISSUER_SSI: {
            return verifyUsingSSI(issuer, signature, signedData, callback);
        }

        case LABELS.ISSUER_DID: {
            return verifyUsingDID(issuer, signature, signedData, callback);
        }

        default: {
            callback(JWT_ERRORS.INVALID_ISSUER_FORMAT);
        }
    }
}

/**
 * This method is verifying an SSI signed JWT
 * @param issuer
 * @param signature
 * @param signedData
 * @param callback {Function}
 */
function verifyUsingSSI(issuer, signature, signedData, callback) {
    try {
        const issuerKeySSI = keySSISpace.parse(issuer);
        const publicKey = issuerKeySSI.getPublicKey();
        const hashFn = cryptoRegistry.getCryptoFunction(issuerKeySSI, 'hash');
        const hashResult = hashFn(signedData);

        const verify = cryptoRegistry.getVerifyFunction(issuerKeySSI);
        const verifyResult = verify(hashResult, publicKey, signature);
        callback(undefined, verifyResult);
    } catch (e) {
        return callback(e);
    }
}

/**
 * This method is verifying a DID signed JWT
 * @param issuer
 * @param signature
 * @param signedData
 * @param callback {Function}
 */
function verifyUsingDID(issuer, signature, signedData, callback) {
    w3cDID.resolveDID(issuer, (err, didDocument) => {
        if (err) {
            return callback(`Failed to resolve did ${issuer}`);
        }

        const hashResult = crypto.sha256(signedData);
        didDocument.verify(hashResult, signature, (verifyError, verifyResult) => {
            if (verifyError) {
                return callback(verifyError);
            }

            callback(null, verifyResult);
        });
    });
}

module.exports = {
    verifyJWT,
    verifyRootsOfTrust,
    verifyEncryptedCredential
};
},{"../constants":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/credentials/constants.js","../utils":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/credentials/utils.js","key-ssi-resolver":"key-ssi-resolver","opendsu":"opendsu"}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/credentials/utils.js":[function(require,module,exports){
const opendsu = require('opendsu');
const w3cDID = opendsu.loadAPI('w3cdid');
const scAPI = opendsu.loadAPI('sc');
const keySSIResolver = require('key-ssi-resolver');
const cryptoRegistry = keySSIResolver.CryptoAlgorithmsRegistry;
const SSITypes = keySSIResolver.SSITypes;
const keySSIFactory = keySSIResolver.KeySSIFactory;
const templateSeedSSI = keySSIFactory.createType(SSITypes.SEED_SSI);
templateSeedSSI.load(SSITypes.SEED_SSI, 'default');

const {LABELS, JWT_ERRORS} = require('./constants');

function base58Decode(data, keepBuffer) {
    const decodedValue = cryptoRegistry.getDecodingFunction(templateSeedSSI).call(this, data);
    if (keepBuffer) {
        return decodedValue;
    }
    return decodedValue ? decodedValue.toString() : null;
}

function base64UrlEncode(source) {
    const buffer = $$.Buffer.from(source, 'utf-8');
    return buffer.toString('base64')
        .replace(/=/g, '')
        .replace(/\+/g, '-')
        .replace(/\//g, '_');
}

function base64UrlDecode(source, keepAsBuffer = false) {
    const buffer = $$.Buffer.from(source, 'base64');
    if (keepAsBuffer) {
        return buffer;
    }

    return buffer.toString('utf-8');
}

function dateTimeFormatter(timestamp) {
    if (!timestamp) {
        return null;
    }

    return new Date(timestamp).toISOString().split('.')[0] + 'Z';
}

function isValidURL(str) {
    const pattern = new RegExp('https?:\\/\\/(www\\.)?[-a-zA-Z0-9@:%._\\+~#=]{1,256}\\.[a-zA-Z0-9()]{1,6}\\b([-a-zA-Z0-9()@:%_\\+.~#?&//=]*)', 'i');
    return !!pattern.test(str);
}

/**
 * This method returns the readable format of an SSI or a DID
 * @param identity {string | Object} - The KeySSI instance | readable SSI string | DIDInstance | readable DID string
 */
function getReadableIdentity(identity) {
    if (!identity) return null;

    if (typeof identity === 'string' && (identity.indexOf('ssi') === 0 || identity.indexOf('did') === 0)) {
        // ssi/did is actually the readable ssi/did
        return identity;
    }

    identity = identity.hasOwnProperty('getIdentifier') ? identity.getIdentifier() : identity;
    if (identity.indexOf('did') === 0) {
        return identity;
    }

    let readableSSI = base58Decode(identity);
    if (!readableSSI) {
        // invalid base58 string
        return null;
    }
    if (readableSSI.indexOf('ssi') !== 0) {
        // invalid ssi format
        return null;
    }

    return readableSSI;
}

/**
 * This method is decoding a JSON string and returns the JSON object
 * @param data {string}
 * @param keepBuffer {boolean}
 * @returns {Object|Error}
 */
function safeParseEncodedJson(data, keepBuffer = false) {
    try {
        return JSON.parse(base64UrlDecode(data, keepBuffer));
    } catch (e) {
        return e;
    }
}

/**
 * This method decodes the JWT and returns the segments
 * @param jwt {string}
 * @param callback
 */
function parseJWTSegments(jwt, callback) {
    if (!jwt) return callback(JWT_ERRORS.EMPTY_JWT_PROVIDED);
    if (typeof jwt !== 'string') return callback(JWT_ERRORS.INVALID_JWT_FORMAT);

    const segments = jwt.split('.');
    if (segments.length !== 3) return callback(JWT_ERRORS.INVALID_JWT_FORMAT);

    const jwtHeader = safeParseEncodedJson(segments[0]);
    if (jwtHeader instanceof Error || !jwtHeader) return callback(JWT_ERRORS.INVALID_JWT_HEADER);

    const jwtPayload = safeParseEncodedJson(segments[1]);
    if (jwtPayload instanceof Error || !jwtPayload) return callback(JWT_ERRORS.INVALID_JWT_PAYLOAD);

    const encodedJWTHeaderAndBody = `${segments[0]}.${segments[1]}`;
    const jwtSignature = base64UrlDecode(segments[2], true);
    if (!jwtSignature) {
        return callback(JWT_ERRORS.INVALID_JWT_SIGNATURE);
    }

    callback(undefined, {jwtHeader, jwtPayload, jwtSignature, encodedJWTHeaderAndBody});
}

/**
 * This method provides the format of the issuer in order to be processed accordingly.
 * Allowed formats:
 * DID Identifier format
 * SSI format
 * @param issuer {string}
 * @returns {null | string}
 */
function getIssuerFormat(issuer) {
    if (!issuer) return null;

    if (issuer.indexOf('did') === 0) {
        return LABELS.ISSUER_DID;
    }

    if (issuer.indexOf('ssi') === 0) {
        return LABELS.ISSUER_SSI;
    }

    return null;
}

/**
 * This method provides the format of the subject in order to be processed accordingly.
 * Allowed formats:
 * DID Identifier format
 * sReadSSI format
 * @param subject {string}
 * @returns {null | string}
 */
function getSubjectFormat(subject) {
    if (!subject) return null;

    if (subject.indexOf('did') === 0) {
        return LABELS.SUBJECT_DID;
    }

    if (subject.indexOf('ssi') === 0) {
        return LABELS.SUBJECT_SSI;
    }

    return null;
}

/**
 * This method checks if a JWT is expired
 * @param payload {Object}
 * @param atDate
 * @returns {boolean}
 */
function isJWTExpired(payload, atDate) {
    const atDateTime = new Date(atDate).getTime(),
        expTime = new Date(payload.exp).getTime();
    let isExpired = expTime < atDateTime;
    if (payload.vc) {
        const expirationDateTime = new Date(payload.vc.expirationDate).getTime();
        if (expTime !== expirationDateTime) return false;
    }

    return isExpired;
}

/**
 * This method checks if a JWT is active
 * @param payload {Object}
 * @param atDate
 * @returns {boolean}
 */
function isJWTNotActive(payload, atDate) {
    const atDateTime = new Date(atDate).getTime(),
        nbfTime = new Date(payload.nbf).getTime();
    let isNotActive = nbfTime >= atDateTime;
    if (payload.vc) {
        const issuanceDateTime = new Date(payload.vc.issuanceDate).getTime();
        if (nbfTime !== issuanceDateTime) return false;
    }

    return isNotActive;
}

/**
 * This method is encrypting a string using asymmetric encryption, so only the pair of the DIDs can decrypt the message.
 * @param holder
 * @param verifier
 * @param dataToSign
 * @param callback
 */
function asymmetricalEncryption(holder, verifier, dataToSign, callback) {
    const issuerFormat = getIssuerFormat(holder);
    const audienceFormat = getSubjectFormat(verifier);
    if (issuerFormat !== LABELS.ISSUER_DID || audienceFormat !== LABELS.SUBJECT_DID) {
        return callback(JWT_ERRORS.HOLDER_AND_VERIFIER_MUST_BE_DID);
    }

    const securityContext = scAPI.getSecurityContext();
    const resolveDids = async () => {
        try {
            const holderDidDocument = await $$.promisify(w3cDID.resolveDID)(holder);
            const verifierDidDocument = await $$.promisify(w3cDID.resolveDID)(verifier);

            holderDidDocument.encryptMessage(verifierDidDocument, dataToSign, (err, encryptedData) => {
                if (err) {
                    return callback(err);
                }

                callback(undefined, base64UrlEncode(JSON.stringify(encryptedData)));
            });
        } catch (e) {
            return callback(e);
        }
    };

    if (securityContext.isInitialised()) {
        resolveDids();
    } else {
        securityContext.on('initialised', resolveDids);
    }
}

/**
 * Thi9s method is decrypting a JWT VC which was previously encrypted using asymmetric encryption.
 * @param verifier
 * @param encryptedData
 * @param callback
 */
function asymmetricalDecryption(verifier, encryptedData, callback) {
    const audienceFormat = getSubjectFormat(verifier);
    if (audienceFormat !== LABELS.SUBJECT_DID) {
        return callback(JWT_ERRORS.HOLDER_AND_VERIFIER_MUST_BE_DID);
    }

    const encryptedDataJSON = JSON.parse(base64UrlDecode(encryptedData));
    const securityContext = scAPI.getSecurityContext();
    const resolveDid = async () => {
        try {
            const verifierDidDocument = await $$.promisify(w3cDID.resolveDID)(verifier);
            verifierDidDocument.decryptMessage(encryptedDataJSON, (err, decryptedData) => {
                if (err) {
                    return callback(err);
                }

                callback(undefined, decryptedData);
            });
        } catch (e) {
            return callback(e);
        }
    };

    if (securityContext.isInitialised()) {
        resolveDid();
    } else {
        securityContext.on('initialised', resolveDid);
    }
}

/**
 * This method is validating recursively if the provided environmentDataClaims JSON object is part of jwtClaims JSON object
 * @param environmentDataClaims {Object} The object that must be part of jwtClaims object
 * @param jwtClaims {Object} The object that must contain all the properties from environmentDataClaims object
 * @returns {boolean}
 */
function validateClaims(environmentDataClaims, jwtClaims) {
    if(!environmentDataClaims) return true;

    const envDataClaimsKeys = Object.keys(environmentDataClaims);
    for (let index = 0; index < envDataClaimsKeys.length; ++index) {
        const key = envDataClaimsKeys[index],
            currentClaim = environmentDataClaims[key],
            currentJwtClaim = jwtClaims[key];
        if (typeof currentClaim === "object" && typeof currentJwtClaim === "object") {
            const areCurrentValidClaims = validateClaims(currentClaim, currentJwtClaim);
            if (!areCurrentValidClaims) {
                return false;
            }
        } else if (typeof currentClaim === "object" || typeof currentJwtClaim === "object") {
            return false;
        } else if (currentClaim !== currentJwtClaim) {
            return false;
        }
    }

    return true;
}

module.exports = {
    base64UrlEncode,
    dateTimeFormatter,
    isValidURL,

    getIssuerFormat,
    getSubjectFormat,
    isJWTExpired,
    isJWTNotActive,
    getReadableIdentity,
    parseJWTSegments,
    validateClaims,

    asymmetricalEncryption,
    asymmetricalDecryption
};
},{"./constants":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/credentials/constants.js","key-ssi-resolver":"key-ssi-resolver","opendsu":"opendsu"}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/credentials/validationStrategies/defaultValidationStrategy.js":[function(require,module,exports){
const {JWT_ERRORS} = require("../constants");
const utils = require("../utils");

class DefaultValidationStrategy {

    /**
     * @param verifiableCredential {string|Object} - Either an encoded JWTVc, or decoded JWTVc as result of the verification
     * @param environmentData {Object} object with arbitrary data required for validation
     * @param callback {Function}
     */
    validateCredential(verifiableCredential, environmentData, callback) {
        if (typeof verifiableCredential === "string") {
            return utils.parseJWTSegments(verifiableCredential, (err, result) => {
                if (err) return callback(err, false);
                this.validateCredential(result.jwtPayload, environmentData, callback);
            });
        }

        const {atDate, credentialPublicClaims, subjectClaims} = environmentData;
        const arePublicClaimsValid = utils.validateClaims(credentialPublicClaims, verifiableCredential);
        if (!arePublicClaimsValid) return callback(undefined, false);
        const areSubjectClaimsValid = utils.validateClaims(subjectClaims, verifiableCredential.vc.credentialSubject);
        if (!areSubjectClaimsValid) return callback(undefined, false);

        if (utils.isJWTExpired(verifiableCredential, atDate)) return callback(JWT_ERRORS.JWT_TOKEN_EXPIRED, false);
        if (utils.isJWTNotActive(verifiableCredential, atDate)) return callback(JWT_ERRORS.JWT_TOKEN_NOT_ACTIVE, false);

        callback(undefined, true);
    }

    /**
     * @param verifiablePresentation {string|Object} - Either an encoded JWTVp, or decoded JWTVp as result of the verification
     * @param environmentData {Object} object with arbitrary data required for validation
     * @param callback {Function}
     */
    validatePresentation(verifiablePresentation, environmentData, callback) {
        if (typeof verifiablePresentation === "string") {
            return utils.parseJWTSegments(verifiablePresentation, (err, result) => {
                if (err) return callback(err, false);
                this.validatePresentation(result.jwtPayload, environmentData, callback);
            });
        }

        const {atDate, presentationPublicClaims} = environmentData;
        const arePublicClaimsValid = utils.validateClaims(presentationPublicClaims, verifiablePresentation);
        if (!arePublicClaimsValid) return callback(undefined, false);

        if (utils.isJWTExpired(verifiablePresentation, atDate)) return callback(JWT_ERRORS.JWT_TOKEN_EXPIRED, false);
        if (utils.isJWTNotActive(verifiablePresentation, atDate)) return callback(JWT_ERRORS.JWT_TOKEN_NOT_ACTIVE, false);

        const credentialValidatorChain = (jwtVcList) => {
            if (jwtVcList.length === 0) {
                return callback(undefined, true);
            }

            const jwtVc = jwtVcList.shift();
            this.validateCredential(jwtVc, environmentData, (err, isValidCredential) => {
                if (err) return callback(err);
                if (!isValidCredential) return callback(undefined, false);

                credentialValidatorChain(jwtVcList);
            });
        };
        credentialValidatorChain(verifiablePresentation.vp.verifiableCredential);
    }
}

module.exports = DefaultValidationStrategy;
},{"../constants":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/credentials/constants.js","../utils":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/credentials/utils.js"}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/credentials/validationStrategies/index.js":[function(require,module,exports){
const VALIDATION_STRATEGIES = require('../constants').VALIDATION_STRATEGIES;
const DefaultValidationStrategy = require("./defaultValidationStrategy");
const RootOfTrustValidationStrategy = require("./rootOfTrustValidationStrategy");

const validationStrategies = {};

/**
 * @param validationStrategyName {string} The name of the validation strategy that will be registered
 * @param implementation The implementation of the strategy. Check validationStrategy.interface.js for reference
 */
function registerValidationStrategy(validationStrategyName, implementation) {
    validationStrategies[validationStrategyName] = implementation;
}

/**
 * @param validationStrategyName {string} The name of the validation strategy to be returned
 * @returns {Object} The implementation of the validation strategy
 */
function getValidationStrategy(validationStrategyName) {
    if (!validationStrategies[validationStrategyName]) {
        return callback(VALIDATION_STRATEGIES.INVALID_VALIDATION_STRATEGY);
    }

    return validationStrategies[validationStrategyName];
}

/**
 * @param validationStrategyName {string} The name of the validation strategy that will be used to validate the credential
 * @param environmentData {string} object with arbitrary data required for validation
 * @param credentialSerialization {string} JWT Verifiable Credential
 * @param callback {Function}
 */
function validateCredential(validationStrategyName, environmentData, credentialSerialization, callback) {
    if (!validationStrategies[validationStrategyName]) {
        return callback(VALIDATION_STRATEGIES.INVALID_VALIDATION_STRATEGY);
    }

    validationStrategies[validationStrategyName].validateCredential(credentialSerialization, environmentData, callback);
}

/**
 * Promisified version of validateCredential method
 * @param validationStrategyName {string} The name of the validation strategy that will be used to validate the credential
 * @param environmentData {string} object with arbitrary data required for validation
 * @param credentialSerialization {string} JWT Verifiable Credential
 * @returns {Promise<*>}
 */
async function validateCredentialAsync(validationStrategyName, environmentData, credentialSerialization) {
    return await $$.promisify(validateCredential)(validationStrategyName, environmentData, credentialSerialization);
}

/**
 * @param validationStrategyNamesArray {string|string[]} array of names of validationStrategies that are allowed to validate. If is a string then only that strategy can do it.
 * @param environmentData {Object} object with arbitrary data required for validation
 * @param presentationSerialization {string} JWT Verifiable Presentation
 * @param callback {Function}
 */
function validatePresentation(validationStrategyNamesArray, environmentData, presentationSerialization, callback) {
    if (typeof validationStrategyNamesArray === "string") {
        validationStrategyNamesArray = [validationStrategyNamesArray];
    }

    const validationStrategyChain = (validationStrategyNamesList) => {
        if (validationStrategyNamesList.length === 0) {
            return callback(undefined, true);
        }

        const validationStrategyName = validationStrategyNamesList.shift();
        if (!validationStrategies[validationStrategyName]) {
            return callback(VALIDATION_STRATEGIES.INVALID_VALIDATION_STRATEGY);
        }

        const jwtVp = JSON.parse(JSON.stringify(presentationSerialization));
        validationStrategies[validationStrategyName].validatePresentation(jwtVp, environmentData, (err, isValidPresentation) => {
            if (err) return callback(err);
            if (!isValidPresentation) return callback(undefined, false);

            validationStrategyChain(validationStrategyNamesList);
        });
    };
    validationStrategyChain(validationStrategyNamesArray);
}

/**
 * Promisified version of validatePresentation method
 * @param validationStrategyNamesArray {string|string[]} array of names of validationStrategies that are allowed to validate. If is a string then only that strategy can do it.
 * @param environmentData {Object} object with arbitrary data required for validation
 * @param presentationSerialization {string} JWT Verifiable Presentation
 * @returns {Promise<*>}
 */
async function validatePresentationAsync(validationStrategyNamesArray, environmentData, presentationSerialization) {
    return await $$.promisify(validatePresentation)(validationStrategyNamesArray, environmentData, presentationSerialization);
}

registerValidationStrategy(VALIDATION_STRATEGIES.DEFAULT, new DefaultValidationStrategy());
registerValidationStrategy(VALIDATION_STRATEGIES.ROOTS_OF_TRUST, new RootOfTrustValidationStrategy());

module.exports = {
    getValidationStrategy,
    registerValidationStrategy,

    validateCredential,
    validateCredentialAsync,
    validatePresentation,
    validatePresentationAsync,

    VALIDATION_STRATEGIES
};
},{"../constants":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/credentials/constants.js","./defaultValidationStrategy":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/credentials/validationStrategies/defaultValidationStrategy.js","./rootOfTrustValidationStrategy":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/credentials/validationStrategies/rootOfTrustValidationStrategy.js"}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/credentials/validationStrategies/rootOfTrustValidationStrategy.js":[function(require,module,exports){
const {JWT_ERRORS, LABELS} = require("../constants");
const utils = require("../utils");

class RootOfTrustValidationStrategy {

    /**
     * @param verifiableCredential {string|Object} - Either an encoded JWTVc, or decoded JWTVc as result of the verification
     * @param environmentData {Object} object with arbitrary data required for validation
     * @param callback {Function}
     */
    validateCredential(verifiableCredential, environmentData, callback) {
        if (typeof verifiableCredential === "string") {
            return utils.parseJWTSegments(verifiableCredential, (err, result) => {
                if (err) return callback(err, false);
                this.validateCredential(result.jwtPayload, environmentData, callback);
            });
        }

        const iss = verifiableCredential.iss;
        const issuerFormat = utils.getIssuerFormat(iss);
        const {rootsOfTrust, credentialPublicClaims, subjectClaims} = environmentData;

        const arePublicClaimsValid = utils.validateClaims(credentialPublicClaims, verifiableCredential);
        if (!arePublicClaimsValid) return callback(undefined, false);
        const areSubjectClaimsValid = utils.validateClaims(subjectClaims, verifiableCredential.vc.credentialSubject);
        if (!areSubjectClaimsValid) return callback(undefined, false);

        if (rootsOfTrust.length === 0) return callback(JWT_ERRORS.ROOT_OF_TRUST_NOT_VALID, false);
        if (!iss || issuerFormat !== LABELS.ISSUER_DID) return callback(JWT_ERRORS.INVALID_ISSUER_FORMAT, false);
        if (rootsOfTrust.findIndex(rootOfTrust => rootOfTrust === iss) === -1) return callback(JWT_ERRORS.ROOT_OF_TRUST_NOT_VALID, false);

        callback(undefined, true);
    }

    /**
     * @param verifiablePresentation {string|Object} - Either an encoded JWTVp, or decoded JWTVp as result of the verification
     * @param environmentData {Object} object with arbitrary data required for validation
     * @param callback {Function}
     */
    validatePresentation(verifiablePresentation, environmentData, callback) {
        if (typeof verifiablePresentation === "string") {
            return utils.parseJWTSegments(verifiablePresentation, (err, result) => {
                if (err) return callback(err, false);
                this.validatePresentation(result.jwtPayload, environmentData, callback);
            });
        }

        const {presentationPublicClaims} = environmentData;
        const arePublicClaimsValid = utils.validateClaims(presentationPublicClaims, verifiablePresentation);
        if (!arePublicClaimsValid) return callback(undefined, false);

        const credentialValidatorChain = (jwtVcList) => {
            if (jwtVcList.length === 0) {
                return callback(undefined, true);
            }

            const jwtVc = jwtVcList.shift();
            this.validateCredential(jwtVc, environmentData, (err, isValidCredential) => {
                if (err) return callback(err);
                if (!isValidCredential) return callback(undefined, isValidCredential);

                credentialValidatorChain(jwtVcList);
            });
        };
        credentialValidatorChain(verifiablePresentation.vp.verifiableCredential);
    }
}

module.exports = RootOfTrustValidationStrategy;
},{"../constants":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/credentials/constants.js","../utils":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/credentials/utils.js"}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/credentials/vc/jwtVc.js":[function(require,module,exports){
const JWT = require('../jwt');
const JWT_ERRORS = require('../constants').JWT_ERRORS;
const { dateTimeFormatter, isValidURL } = require('../utils');
const { jwtVcBuilder, jwtVcParser, jwtVcVerifier } = require('./model');

class JwtVC extends JWT {
	constructor(issuer, subject, options, isInitialisation = false) {
		super();

		if (isInitialisation === true) {
			jwtVcBuilder(issuer, subject, options, (err, result) => {
				if (err) {
					return this.notifyInstanceReady(err);
				}

				this.jwtHeader = result.jwtHeader;
				this.jwtPayload = result.jwtPayload;
				this.notifyInstanceReady();
			});
		}
	}

	/**
	 * This method embeds one or more public claims about the JWT. These claims are not reflected within VC body
	 * @param claimName {string} - The name of the public claim. Reserved public claims: "vc", "vp", "iss", "sub", "iat"
	 * @param claimValue - The value of the public claim
	 * @param callback
	 */
	embedClaim(claimName, claimValue, callback) {
		super.embedClaim(claimName, claimValue, (err) => {
			if (err) {
				return callback(err);
			}

			if (claimName === 'nbf') {
				this.jwtPayload.vc.issuanceDate = dateTimeFormatter(claimValue);
			}
			if (claimName === 'exp') {
				this.jwtPayload.vc.expirationDate = dateTimeFormatter(claimValue);
			}

			callback(undefined, true);
		});
	}

	/**
	 * This method is used to extend the expiration date of a JWT
	 * @param timeInSeconds {Number}
	 * @param callback
	 */
	extendExpirationDate(timeInSeconds, callback) {
		super.extendExpirationDate(timeInSeconds, (err) => {
			if (err) {
				return callback(err);
			}

			const newExpirationDate = this.jwtPayload.exp + timeInSeconds * 1000;
			this.jwtPayload.vc.expirationDate = dateTimeFormatter(newExpirationDate);

			callback(undefined, true);
		});
	}

	/**
	 * This method embeds a new claim about the subject(s) of the JWT.
	 * Subject is mandatory if credentialSubject is an array of subjects. (To be extended tp crete JWT based on multiple subjects)
	 * @param context {string} - URI - https://www.w3.org/TR/vc-data-model/#contexts
	 * @param type {string} - Any other custom VC Types must be reflected within @context (a URI with a schema must be added)
	 * @param subjectClaims {Object} - Any claims related to the subject
	 * @param subject {string | Function} - It is mandatory if the credentialSubjects are more than one.
	 * @param callback
	 */
	embedSubjectClaim(context, type, subjectClaims, subject, callback) {
		if (typeof subject === 'function') {
			callback = subject;
			subject = null;
		}

		if (!context || typeof context !== 'string' || !isValidURL(context)) return callback(JWT_ERRORS.INVALID_CONTEXT_URI);
		if (!type || typeof type !== 'string') return callback(JWT_ERRORS.INVALID_CONTEXT_TYPE);
		if (!subjectClaims || typeof subjectClaims !== 'object') return callback(JWT_ERRORS.INVALID_SUBJECT_CLAIM);
		if (subjectClaims.id) return callback(JWT_ERRORS.IMMUTABLE_SUBJECT_CLAIM);

		const vc = this.jwtPayload.vc;
		if (Array.isArray(vc.credentialSubject)) {
			if (!subject || typeof subject !== 'string') {
				return callback(JWT_ERRORS.INVALID_SUBJECT_ID);
			}

			const targetSubjectIndex = vc.credentialSubject.findIndex(subject => subject.id === subject);
			if (targetSubjectIndex === -1) {
				return callback(JWT_ERRORS.PROVIDED_SUBJECT_ID_NOT_PRESENT);
			}

			Object.assign(vc.credentialSubject[targetSubjectIndex], subjectClaims);
		} else {
			Object.assign(vc.credentialSubject, subjectClaims);
		}

		vc['@context'].push(context);
		vc.type.push(type);
		this.jwtPayload.vc = JSON.parse(JSON.stringify(vc));

		callback(undefined, true);
	};

	async embedSubjectClaimAsync(context, type, subjectClaims, subject) {
		return this.asyncMyFunction(this.embedSubjectClaim, [...arguments]);
	}

	loadEncodedJWTVc(encodedJWT) {
		jwtVcParser(encodedJWT, (err, result) => {
			if (err) {
				return this.notifyInstanceReady(err);
			}

			this.jwtHeader = result.jwtHeader;
			this.jwtPayload = result.jwtPayload;
			this.jwtSignature = result.jwtSignature;
			this.notifyInstanceReady();
		});
	};

	verifyJWT(rootsOfTrust, callback) {
		if (typeof rootsOfTrust === 'function') {
			callback = rootsOfTrust;
			rootsOfTrust = [];
		}

		const decodedJWT = { jwtHeader: this.jwtHeader, jwtPayload: this.jwtPayload, jwtSignature: this.jwtSignature };
		jwtVcVerifier(decodedJWT, rootsOfTrust, (err, result) => {
			if (err) {
				return callback(undefined, { verifyResult: false, errorMessage: err });
			}

			callback(undefined, { verifyResult: result, ...JSON.parse(JSON.stringify(this.jwtPayload)) });
		});
	}

	verifyJWTAsync(rootsOfTrust) {
		return this.asyncMyFunction(this.verifyJWT, [...arguments]);
	}
}

/**
 * This method prepares the initial JWT options object based on the inputs. <br />
 * Points to the specific create JWT method according to the subject type
 * @param issuer
 * @param subject
 * @param options {Object}
 */
function createJWTVc(issuer, subject, options = {}) {
	return new JwtVC(issuer, subject, options, true);
}

/**
 * This method is parsing an encoded verifiable credential according to the requested type and returns the instance of the verifiable credential. <br />
 * @param encodedJWTVc {string}
 */
function loadJWTVc(encodedJWTVc) {
	const jwtInstance = new JwtVC();
	jwtInstance.loadEncodedJWTVc(encodedJWTVc);

	return jwtInstance;
}

module.exports = {
	createJWTVc, loadJWTVc
};
},{"../constants":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/credentials/constants.js","../jwt":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/credentials/jwt/index.js","../utils":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/credentials/utils.js","./model":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/credentials/vc/model.js"}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/credentials/vc/model.js":[function(require,module,exports){
const {JWT_DEFAULTS, JWT_ERRORS} = require('../constants');
const {defaultJWTParser, defaultJWTBuilder} = require('../jwt/model');
const utils = require('../utils');
const {verifyJWT} = require("../jwt/verify");

/**
 * This method creates "vc" object from the payload of a JWT according to the W3c Standard
 * @param jwtPayload
 * @param options {Object}
 * @returns {{credentialSubject: {id}, issuanceDate: string, type: *[], "@context": *[], issuer, expirationDate: string}}
 */
function getRequiredJWTVCModel(jwtPayload, options) {
    options = Object.assign({}, options, jwtPayload);
    let {vc, sub, iss, nbf, exp} = options; // can be extended with other attributes
    if (!vc) {
        vc = Object.assign({}, JWT_DEFAULTS.EMPTY_VC_VP);
    }

    return {
        // id: jti reflected - not mandatory
        '@context': [JWT_DEFAULTS.VC_VP_CONTEXT_CREDENTIALS, ...vc.context], // Mandatory and this must be the first URI from the list reference: https://www.w3.org/TR/vc-data-model/#contexts
        type: [JWT_DEFAULTS.VC_TYPE, ...vc.type], // Any other custom VC Types must be reflected within @context (a URI with a schema must be added)
        // Inside "credentialSubject" object are defined all the claims about the subject
        credentialSubject: {
            id: sub
        }, // Either single object, or an array of objects - id is mandatory and is reflected from "sub" attribute,
        issuer: iss, // reflected from "iss" attribute
        issuanceDate: utils.dateTimeFormatter(nbf), // reflected from "nbf" attribute displayed using date-time format https://www.w3.org/TR/xmlschema11-2/#dateTime
        expirationDate: utils.dateTimeFormatter(exp) // reflected from "exp" attribute displayed using date-time format https://www.w3.org/TR/xmlschema11-2/#dateTime
    };
}

function jwtVcBuilder(issuer, subject, options, callback) {
    defaultJWTBuilder(issuer, options, (err, result) => {
        if (err) {
            return callback(err);
        }

        const {jwtHeader, jwtPayload} = result;
        subject = utils.getReadableIdentity(subject);
        if (!subject) return callback(JWT_ERRORS.INVALID_SUBJECT_FORMAT);

        const subjectFormat = utils.getSubjectFormat(subject);
        if (!subjectFormat) return callback(JWT_ERRORS.INVALID_SUBJECT_FORMAT);

        jwtPayload.sub = subject;
        options.sub = subject;
        jwtPayload.vc = getRequiredJWTVCModel(jwtPayload, options);

        callback(undefined, {jwtHeader, jwtPayload});
    });
}

function jwtVcParser(encodedJWTVc, callback) {
    defaultJWTParser(encodedJWTVc, (err, decodedJWT) => {
        if (err) {
            return callback(err);
        }

        if (!decodedJWT.jwtPayload.vc) return callback(JWT_ERRORS.INVALID_JWT_PAYLOAD);
        callback(undefined, decodedJWT);
    });
}

function jwtVcVerifier(decodedJWT, rootsOfTrust, callback) {
    const {jwtHeader, jwtPayload, jwtSignature} = decodedJWT;
    const dataToSign = [utils.base64UrlEncode(JSON.stringify(jwtHeader)), utils.base64UrlEncode(JSON.stringify(jwtPayload))].join('.');

    verifyJWT(jwtPayload.iss, jwtSignature, dataToSign, {kid: jwtHeader.kid}, (err, verifyResult) => {
        if (err) return callback(err);
        if (!verifyResult) return callback(JWT_ERRORS.INVALID_JWT_SIGNATURE);

        callback(undefined, true);
    });
}

module.exports = {
    jwtVcBuilder, jwtVcParser, jwtVcVerifier
};
},{"../constants":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/credentials/constants.js","../jwt/model":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/credentials/jwt/model.js","../jwt/verify":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/credentials/jwt/verify.js","../utils":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/credentials/utils.js"}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/credentials/vp/jwtVp.js":[function(require,module,exports){
const JWT = require('../jwt');
const JWT_ERRORS = require('../constants').JWT_ERRORS;
const { jwtVpBuilder, jwtVpParser, jwtVpVerifier } = require('./model');
const { asymmetricalEncryption } = require('../utils');

class JwtVP extends JWT {
	constructor(issuer, options, isInitialisation = false) {
		super();

		if (isInitialisation === true) {
			jwtVpBuilder(issuer, options, (err, result) => {
				if (err) {
					return this.notifyInstanceReady(err);
				}

				this.jwtHeader = result.jwtHeader;
				this.jwtPayload = result.jwtPayload;
				this.notifyInstanceReady();
			});
		}
	}

	addVerifiableCredential = (encodedJWTVc, callback) => {
		if (!encodedJWTVc) {
			return callback(JWT_ERRORS.INVALID_JWT_FORMAT);
		}

		this.jwtPayload.vp.verifiableCredential.push(encodedJWTVc);
		callback(undefined, true);
	};

	async addVerifiableCredentialAsync(encodedJWTVc) {
		return this.asyncMyFunction(this.addVerifiableCredential, [...arguments]);
	}

	addEncryptedCredential = (encodedJwtVc, callback) => {
		if (!encodedJwtVc) return callback(JWT_ERRORS.INVALID_JWT_FORMAT);
		if (!this.jwtPayload.aud) return callback(JWT_ERRORS.AUDIENCE_OF_PRESENTATION_NOT_DEFINED);

		const { iss, aud } = this.jwtPayload;
		asymmetricalEncryption(iss, aud, encodedJwtVc, (err, encryptedCredential) => {
			if (err) {
				return callback(err);
			}

			this.jwtPayload.vp.verifiableCredential.push(encryptedCredential);
			callback(undefined, true);
		});
	};

	async addEncryptedCredentialAsync(encodedJwtVc) {
		return this.asyncMyFunction(this.addEncryptedCredential, [...arguments]);
	}

	loadEncodedJWTVp(encodedJWTVp) {
		jwtVpParser(encodedJWTVp, (err, result) => {
			if (err) {
				return this.notifyInstanceReady(err);
			}

			this.jwtHeader = result.jwtHeader;
			this.jwtPayload = result.jwtPayload;
			this.jwtSignature = result.jwtSignature;
			this.notifyInstanceReady();
		});
	}

	verifyJWT(rootsOfTrust, callback) {
		if (typeof rootsOfTrust === 'function') {
			callback = rootsOfTrust;
			rootsOfTrust = [];
		}

		const decodedJWT = { jwtHeader: this.jwtHeader, jwtPayload: this.jwtPayload, jwtSignature: this.jwtSignature };
		jwtVpVerifier(decodedJWT, rootsOfTrust, (err, result) => {
			if (err) {
				return callback(undefined, { verifyResult: false, errorMessage: err });
			}

			const verifyResultObj = { verifyResult: true };
			const decodedClaims = JSON.parse(JSON.stringify(this.jwtPayload));
			if (result.verifiableCredential) {
				decodedClaims.vp.verifiableCredential = result.verifiableCredential;
				if (result.verifyResult === false) {
					verifyResultObj.verifyResult = false;
					verifyResultObj.errorMessage = result.verifiableCredential.find(vc => typeof vc.errorMessage === 'string').errorMessage;
				}
			}

			const verifyResult = { ...verifyResultObj, ...decodedClaims };
			callback(undefined, verifyResult);
		});
	}

	async verifyJWTAsync(rootsOfTrust) {
		return this.asyncMyFunction(this.verifyJWT, [...arguments]);
	}
}

/**
 * This method prepares the initial JWT options object based on the inputs. <br />
 * Points to the specific create JWT method according to the subject type
 * @param issuer
 * @param options {Object}
 */
function createJWTVp(issuer, options = {}) {
	return new JwtVP(issuer, options, true);
}

/**
 * This method is parsing an encoded verifiable credential according to the requested type and returns the instance of the verifiable credential. <br />
 * @param encodedJWTVp {string}
 */
function loadJWTVp(encodedJWTVp) {
	const jwtInstance = new JwtVP();
	jwtInstance.loadEncodedJWTVp(encodedJWTVp);

	return jwtInstance;
}

module.exports = {
	createJWTVp, loadJWTVp
};
},{"../constants":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/credentials/constants.js","../jwt":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/credentials/jwt/index.js","../utils":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/credentials/utils.js","./model":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/credentials/vp/model.js"}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/credentials/vp/model.js":[function(require,module,exports){
const {JWT_DEFAULTS, JWT_ERRORS} = require('../constants');
const {defaultJWTParser, defaultJWTBuilder} = require('../jwt/model');
const utils = require('../utils');
const {verifyEncryptedCredential, verifyRootsOfTrust, verifyJWT} = require("../jwt/verify");

/**
 * This method creates "vp" object from the payload of a JWT according to the W3c Standard
 * @param jwtPayload
 * @param options {Object}
 */
function getRequiredJWTVPModel(jwtPayload, options) {
    options = Object.assign({}, options, jwtPayload);
    let {vp, iss, id} = options; // can be extended with other attributes
    if (!vp) {
        vp = Object.assign({}, JWT_DEFAULTS.EMPTY_VC_VP);
    }

    return {
        '@context': [JWT_DEFAULTS.VC_VP_CONTEXT_CREDENTIALS, ...vp.context],
        type: [JWT_DEFAULTS.VP_TYPE, ...vp.type],
        id: id, // uuid of the presentation (optional)
        verifiableCredential: options.credentialsToPresent || [],
        holder: iss // reflected from "iss" attribute
    };
}

function jwtVpBuilder(issuer, options, callback) {
    defaultJWTBuilder(issuer, options, (err, result) => {
        if (err) {
            return callback(err);
        }

        const {jwtHeader, jwtPayload} = result;
        jwtPayload.vp = getRequiredJWTVPModel(jwtPayload, options);

        callback(undefined, {jwtHeader, jwtPayload});
    });
}

function jwtVpParser(encodedJWTVp, callback) {
    defaultJWTParser(encodedJWTVp, (err, decodedJWT) => {
        if (err) {
            return callback(err);
        }

        if (!decodedJWT.jwtPayload.vp) return callback(JWT_ERRORS.INVALID_JWT_PAYLOAD);
        callback(undefined, decodedJWT);
    });
}

function jwtVpVerifier(decodedJWT, rootsOfTrust, callback) {
    const {jwtHeader, jwtPayload, jwtSignature} = decodedJWT;
    const dataToSign = [utils.base64UrlEncode(JSON.stringify(jwtHeader)), utils.base64UrlEncode(JSON.stringify(jwtPayload))].join('.');

    if (jwtPayload.aud) {
        return verifyEncryptedCredential(jwtPayload, callback);
    }

    if (rootsOfTrust.length > 0) {
        return verifyRootsOfTrust(jwtPayload, rootsOfTrust, callback);
    }

    verifyJWT(jwtPayload.iss, jwtSignature, dataToSign, {kid: jwtHeader.kid}, (err, verifyResult) => {
        if (err) return callback(err);
        if (!verifyResult) return callback(JWT_ERRORS.INVALID_JWT_SIGNATURE);

        callback(undefined, true);
    });
}

module.exports = {
    jwtVpBuilder, jwtVpParser, jwtVpVerifier
};
},{"../constants":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/credentials/constants.js","../jwt/model":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/credentials/jwt/model.js","../jwt/verify":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/credentials/jwt/verify.js","../utils":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/credentials/utils.js"}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/crypto/index.js":[function(require,module,exports){
const keySSIResolver = require("key-ssi-resolver");
const crypto = require("pskcrypto");
const cryptoRegistry = keySSIResolver.CryptoAlgorithmsRegistry;
const keySSIFactory = keySSIResolver.KeySSIFactory;
const SSITypes = keySSIResolver.SSITypes;
const CryptoFunctionTypes = keySSIResolver.CryptoFunctionTypes;
const jwtUtils = require("./jwt");
const constants = require("../moduleConstants");
const config = require("./index");
const { Mnemonic } = require("./mnemonic");

const templateSeedSSI = keySSIFactory.createType(SSITypes.SEED_SSI);
templateSeedSSI.load(SSITypes.SEED_SSI, "default");

const {JWT_ERRORS} = jwtUtils;

const getCryptoFunctionForKeySSI = (keySSI, cryptoFunctionType) => {
    return cryptoRegistry.getCryptoFunction(keySSI, cryptoFunctionType);
}
const hash = (keySSI, data, callback) => {
    console.log("This function is obsolete");
    callback(undefined, hashSync(keySSI, data));
};

const hashSync = (keySSI, data) => {
    console.log("This function is obsolete");
    if (typeof data === "object" && !$$.Buffer.isBuffer(data)) {
        data = JSON.stringify(data);
    }
    const hash = cryptoRegistry.getHashFunction(keySSI);
    return hash(data);
}

const encrypt = (data, encryptionKey) => {
    const logger = $$.getLogger("encrypt", "opendsu/crypto");
    logger.info(0x900, "DSUs are encrypted using AES-GCM 256bit");
    const pskEncryption = crypto.createPskEncryption("aes-256-gcm");
    return pskEncryption.encrypt(data, encryptionKey);
};

const decrypt = (data, encryptionKey) => {
    const pskEncryption = crypto.createPskEncryption("aes-256-gcm");
    return pskEncryption.decrypt(data, encryptionKey);
};

const ecies_encrypt_ds = (senderKeySSI, receiverKeySSI, data) => {
    const ecies_encrypt_ds = getCryptoFunctionForKeySSI(senderKeySSI, CryptoFunctionTypes.ECIES_ENCRYPTION_DS);
    return ecies_encrypt_ds(senderKeySSI.getKeyPair(), receiverKeySSI.getPublicKey("raw"), data);
};

const ecies_decrypt_ds = (receiverKeySSI, data) => {
    const ecies_decrypt_ds = getCryptoFunctionForKeySSI(receiverKeySSI, CryptoFunctionTypes.ECIES_DECRYPTION_DS);
    return ecies_decrypt_ds(receiverKeySSI.getPrivateKey(), data);
};

const deriveEncryptionKey = (password) => {
    return crypto.deriveKey(password);
}

const convertDerSignatureToASN1 = (derSignature) => {
    return require('pskcrypto').decodeDerToASN1ETH(derSignature);
};

const sign = (keySSI, data, callback) => {
    const sign = cryptoRegistry.getSignFunction(keySSI);
    if (typeof sign !== "function") {
        throw Error("Signing not available for " + keySSI.getIdentifier(true));
    } else {
        callback(undefined, sign(data, keySSI.getPrivateKey()));
    }
};

const verifySignature = (keySSI, data, signature, publicKey, callback) => {
    if (typeof publicKey === "function") {
        callback = publicKey;
        publicKey = keySSI.getPublicKey();
    }
    const verify = cryptoRegistry.getVerifyFunction(keySSI);
    callback(undefined, verify(data, publicKey, signature));
};

const generateEncryptionKey = (keySSI, callback) => {
    const generateEncryptionKey = cryptoRegistry.getEncryptionKeyGenerationFunction(keySSI);
    callback(undefined, generateEncryptionKey());
};

const encode = (keySSI, data) => {
    console.log("This function is obsolete");
    const encode = cryptoRegistry.getEncodingFunction(keySSI);
    return encode(data);
};

const decode = (keySSI, data) => {
    console.log("This function is obsolete");
    const decode = cryptoRegistry.getDecodingFunction(keySSI);
    return decode(data);
};

const sha256 = (dataObj) => {
    const pskcrypto = require("pskcrypto");
    const hashBuffer = pskcrypto.objectHash("sha256", dataObj);
    return pskcrypto.pskBase58Encode(hashBuffer);
};

const generateRandom = (length) => {
    const pskcrypto = require("pskcrypto");
    const randomBuffer = pskcrypto.randomBytes(length);
    return randomBuffer;
}

const encodeBase58 = (data) => {
    const encodeFn = getCryptoFunctionForKeySSI(templateSeedSSI, "encoding");
    return encodeFn(data);
};

const decodeBase58 = (data) => {
    const decodeFn = getCryptoFunctionForKeySSI(templateSeedSSI, "decoding");
    return decodeFn(data);
};

const generateKeyPair = () => {
    const ecGenerator = crypto.createKeyPairGenerator();
    return ecGenerator.generateKeyPair();
}

/**
 *
 * @param rawPublicKey
 * @param outputFormat - pem or der
 */
const convertPublicKey = (rawPublicKey, outputFormat, curveName) => {
    const ecGenerator = crypto.createKeyPairGenerator();
    return ecGenerator.convertPublicKey(rawPublicKey, {outputFormat, namedCurve: curveName});
};

/**
 *
 * @param rawPrivateKey
 * @param outputFormat - pem or der
 */
const convertPrivateKey = (rawPrivateKey, outputFormat) => {
    const ecGenerator = crypto.createKeyPairGenerator();
    const rawPublicKey = ecGenerator.getPublicKey(rawPrivateKey);
    return ecGenerator.getPemKeys(rawPrivateKey, rawPublicKey, {outputFormat}).privateKey;
}

const getPublicKeyFromPrivateKey = (rawPrivateKey, outputFormat = "raw") => {
    const ecGenerator = crypto.createKeyPairGenerator();
    const rawPublicKey = ecGenerator.getPublicKey(rawPrivateKey);
    return convertPublicKey(rawPublicKey, outputFormat);
};

const createJWT = (seedSSI, scope, credentials, options, callback) => {
    jwtUtils.createJWT(
        {
            seedSSI,
            scope,
            credentials,
            options,
            sign,
        },
        callback
    );
};

const createJWTForDID = (did, scope, credentials, options, callback) => {
    jwtUtils.createJWTForDID(
        {
            did,
            scope,
            credentials,
            options
        },
        callback
    );
};

const verifyJWT = (jwt, rootOfTrustVerificationStrategy, callback) => {
    jwtUtils.verifyJWT(
        {
            jwt,
            rootOfTrustVerificationStrategy,
            verifySignature,
        },
        callback
    );
};

const verifyDID_JWT = (jwt, rootOfTrustVerificationStrategy, callback) => {
    jwtUtils.verifyDID_JWT(
        {
            jwt,
            rootOfTrustVerificationStrategy
        },
        callback
    );
};

const createCredential = (issuerSeedSSI, credentialSubjectSReadSSI, callback) => {
    createJWT(issuerSeedSSI, "", null, {subject: credentialSubjectSReadSSI}, callback);
};

const createCredentialForDID = (did, credentialSubjectDID, callback) => {
    createJWTForDID(did, "", null, {subject: credentialSubjectDID}, callback);
};

const createAuthToken = (holderSeedSSI, scope, credential, callback) => {
    createJWT(holderSeedSSI, scope, credential, null, callback);
};

const createAuthTokenForDID = (holderDID, scope, credential, callback) => {
    createJWTForDID(holderDID, scope, credential, null, callback);
};

const createPresentationToken = (holderSeedSSI, scope, credential, callback) => {
    createJWT(holderSeedSSI, scope, credential, null, callback);
};

function verifyToken(jwt, listOfIssuers, verifyJWTFn, callback) {
    if (!listOfIssuers || !listOfIssuers.length) return callback(JWT_ERRORS.EMPTY_LIST_OF_ISSUERS_PROVIDED);

    // checks every credentials from the JWT's body to see if it has at least one JWT issues by one of listOfIssuers for the current subject
    const rootOfTrustVerificationStrategy = ({body}, verificationCallback) => {
        const {sub: subject, credentials} = body;
        // the JWT doesn't have credentials specified so we cannot check for valid authorizarion
        if (!credentials) return verificationCallback(null, false);

        const currentSubject = jwtUtils.getReadableIdentity(subject);

        const credentialVerifiers = credentials.map((credential) => {
            return new Promise((resolve) => {
                verifyJWTFn(
                    credential,
                    ({body}, credentialVerificationCallback) => {
                        // check if credential was issued for the JWT that we are verifying the authorization for
                        const credentialSubject = jwtUtils.getReadableIdentity(body.sub);
                        const isCredentialIssuedForSubject = !!credentialSubject && credentialSubject === currentSubject;
                        if (!isCredentialIssuedForSubject) return credentialVerificationCallback(null, false);

                        const credentialIssuer = jwtUtils.getReadableIdentity(body.iss);

                        // console.log(`Checking for credentialIssuer ${credentialIssuer} inside `, listOfIssuers);
                        // listOfIssuers.forEach(issuer => {
                        //     console.log(`Valid issuer ${issuer}: ${jwtUtils.getReadableSSI(issuer)}`);
                        // })

                        const isValidIssuer = listOfIssuers.some((issuer) => !!credentialIssuer
                            && jwtUtils.getReadableIdentity(issuer) === credentialIssuer);
                        credentialVerificationCallback(null, isValidIssuer);
                    },
                    (credentialVerifyError, isCredentialValid) => {
                        if (credentialVerifyError) return resolve(false);
                        resolve(isCredentialValid);
                    }
                );
            }).catch(() => {
                // is something went wrong, we deny the JWT
                return false;
            });
        });

        Promise.all(credentialVerifiers)
            .then((credentialVerifierResults) => {
                const hasAtLeastOneValidIssuer = credentialVerifierResults.some((result) => result);
                if (!hasAtLeastOneValidIssuer) return verificationCallback(null, false);
                verificationCallback(null, true);
            })
            .catch(() => {
                // is something went wrong, we deny the JWT
                verificationCallback(null, false);
            });
    };

    verifyJWTFn(jwt, rootOfTrustVerificationStrategy, callback);
}

const verifyAuthToken = (jwt, listOfIssuers, callback) => {
    verifyToken(jwt, listOfIssuers, verifyJWT, callback);
};

const verifyDIDAuthToken = (jwt, listOfIssuers, callback) => {
    verifyToken(jwt, listOfIssuers, verifyDID_JWT, callback);
};


function createBloomFilter(options) {
    const BloomFilter = require("psk-dbf");
    return new BloomFilter(options);
}

const sha256JOSE = (data, encoding) => {
    const pskCrypto = require("pskcrypto");
    return pskCrypto.hash("sha256", data, encoding);
}

const base64UrlEncodeJOSE = (data) => {
    if (typeof data === "string") {
        data = $$.Buffer.from(data);
    }
    return data.toString("base64").replaceAll('+', '-').replaceAll('/', '_').replaceAll('=', '');
}

const convertKeySSIObjectToMnemonic = (keySSIObject) => {

    const mnemonic = new Mnemonic("english");
    const randomBase64 = keySSIObject.getSpecificString();
    const randomBytes = $$.Buffer.from(randomBase64, "base64");
    return mnemonic.toMnemonic(randomBytes, sha256JOSE);
}

const convertMnemonicToKeySSIIdentifier = (phrase, typeName, domain, vn) => {
    const mnemonic = new Mnemonic("english");
    const specificStringHex = mnemonic.toRawEntropyHex(phrase);
    const specificStringBase64 = $$.Buffer.from(specificStringHex, "hex").toString("base64");
    return `ssi:${typeName}:${domain}:${specificStringBase64}::${vn}`
}

module.exports = {
    getCryptoFunctionForKeySSI,
    hash,
    hashSync,
    generateRandom,
    encrypt,
    decrypt,
    sign,
    convertDerSignatureToASN1,
    verifySignature,
    generateEncryptionKey,
    encode,
    decode,
    encodeBase58,
    decodeBase58,
    sha256,
    createJWT,
    verifyJWT,
    createCredential,
    createAuthToken,
    verifyAuthToken,
    createPresentationToken,
    getReadableSSI: jwtUtils.getReadableIdentity,
    parseJWTSegments: jwtUtils.parseJWTSegments,
    createBloomFilter,
    JWT_ERRORS,
    deriveEncryptionKey,
    generateKeyPair,
    convertPrivateKey,
    convertPublicKey,
    getPublicKeyFromPrivateKey,
    ecies_encrypt_ds,
    ecies_decrypt_ds,
    createJWTForDID,
    verifyDID_JWT,
    verifyDIDAuthToken,
    createAuthTokenForDID,
    createCredentialForDID,
    base64UrlEncodeJOSE,
    sha256JOSE,
    joseAPI: require("pskcrypto").joseAPI,
    convertKeySSIObjectToMnemonic,
    convertMnemonicToKeySSIIdentifier
};

},{"../moduleConstants":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/moduleConstants.js","./index":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/crypto/index.js","./jwt":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/crypto/jwt.js","./mnemonic":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/crypto/mnemonic.js","key-ssi-resolver":"key-ssi-resolver","psk-dbf":false,"pskcrypto":"pskcrypto"}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/crypto/jwt.js":[function(require,module,exports){
const keySSIResolver = require("key-ssi-resolver");
const cryptoRegistry = keySSIResolver.CryptoAlgorithmsRegistry;
const SSITypes = keySSIResolver.SSITypes;
const keySSIFactory = keySSIResolver.KeySSIFactory;

const SEED_SSI_HEADER_TYPE = "SeedSSIJWT";
const DID_HEADER_TYPE = "DID_JWT";
const JWT_VALABILITY_SECONDS = 5 * 365 * 24 * 60 * 60; // 5 years default

const JWT_ERRORS = {
    EMPTY_JWT_PROVIDED: "EMPTY_JWT_PROVIDED",
    INVALID_JWT_FORMAT: "INVALID_JWT_FORMAT",
    INVALID_JWT_PRESENTATION: "INVALID_JWT_PRESENTATION",
    INVALID_JWT_HEADER: "INVALID_JWT_HEADER",
    INVALID_JWT_BODY: "INVALID_JWT_BODY",
    INVALID_JWT_HEADER_TYPE: "INVALID_JWT_HEADER_TYPE",
    INVALID_JWT_ISSUER: "INVALID_JWT_ISSUER",
    INVALID_CREDENTIALS_FORMAT: "INVALID_CREDENTIALS_FORMAT",
    JWT_TOKEN_EXPIRED: "JWT_TOKEN_EXPIRED",
    JWT_TOKEN_NOT_ACTIVE: "JWT_TOKEN_NOT_ACTIVE",
    INVALID_JWT_SIGNATURE: "INVALID_JWT_SIGNATURE",
    ROOT_OF_TRUST_VERIFICATION_FAILED: "ROOT_OF_TRUST_VERIFICATION_FAILED",
    EMPTY_LIST_OF_ISSUERS_PROVIDED: "EMPTY_LIST_OF_ISSUERS_PROVIDED",
    INVALID_SSI_PROVIDED: "INVALID_SSI_PROVIDED"
};

const templateSeedSSI = keySSIFactory.createType(SSITypes.SEED_SSI);
templateSeedSSI.load(SSITypes.SEED_SSI, "default");

function encodeBase58(data) {
    return cryptoRegistry.getEncodingFunction(templateSeedSSI)(data).toString();
};

function decodeBase58(data, keepBuffer) {
    const decodedValue = cryptoRegistry.getDecodingFunction(templateSeedSSI)(data);
    if (keepBuffer) {
        return decodedValue;
    }
    return decodedValue ? decodedValue.toString() : null;
};

function nowEpochSeconds() {
    return Math.floor(new Date().getTime() / 1000);
}

function getReadableIdentity(identity) {
    if (typeof identity === "string" && (identity.indexOf('ssi') === 0 || identity.indexOf('did') === 0)) {
        // ssi is actually the readable ssi
        return identity;
    }

    identity = identity.getIdentifier ? identity.getIdentifier() : identity;
    let readableSSI = decodeBase58(identity);
    if (!readableSSI) {
        // invalid base58 string
        return null;
    }
    if (readableSSI.indexOf('ssi') !== 0) {
        // invalid ssi format
        return null;
    }

    return readableSSI;
}

function createJWT({seedSSI, scope, credentials, options, sign}, callback) {
    if (typeof seedSSI === "string") {
        const keyssiSpace = require('opendsu').loadApi("keyssi");
        try {
            seedSSI = keyssiSpace.parse(seedSSI);
        } catch (e) {
            return callback(e);
        }
    }
    seedSSI.derive((err, sReadSSI) => {
        if (err) {
            return callback(err);
        }
        let {subject, valability, ...optionsRest} = options || {};
        valability = valability || JWT_VALABILITY_SECONDS;

        if (subject) {
            subject = getReadableIdentity(subject);
        } else {
            subject = sReadSSI.getIdentifier(true);
        }
        if (!subject) {
            return callback(JWT_ERRORS.INVALID_SSI_PROVIDED);
        }

        const issuer = sReadSSI.getIdentifier(true);
        if (!issuer) {
            return callback(JWT_ERRORS.INVALID_SSI_PROVIDED);
        }

        if (credentials) {
            credentials = Array.isArray(credentials) ? credentials : [credentials];
        }

        const header = {
            typ: SEED_SSI_HEADER_TYPE,
        };

        const now = nowEpochSeconds();
        const body = {
            sub: subject,
            // aud: encodeBase58(scope),
            scope,
            iss: issuer,
            publicKey: seedSSI.getPublicKey(),
            iat: now,
            nbf: now,
            exp: now + valability,
            credentials,
            options: optionsRest,
        };

        const segments = [encodeBase58(JSON.stringify(header)), encodeBase58(JSON.stringify(body))];

        const jwtToSign = segments.join(".");
        const hashFn = require("../crypto").getCryptoFunctionForKeySSI(seedSSI, "hash");
        const hashResult = hashFn(jwtToSign);
        sign(seedSSI, hashResult, (signError, signResult) => {
            if (signError || !signResult) return callback(signError);
            const encodedSignResult = encodeBase58(signResult);

            const jwt = `${jwtToSign}.${encodedSignResult}`;
            callback(null, jwt);
        });
    });
}

function createJWTForDID({did, scope, credentials, options}, callback) {
    let {subject, valability, ...optionsRest} = options || {};
    valability = valability || JWT_VALABILITY_SECONDS;
    const w3cDID = require("opendsu").loadAPI("w3cdid");

    let didDocument;
    if (typeof did === "object") {
        try {
            didDocument = did;
            did = did.getIdentifier();
        } catch (e) {
            return callback(e);
        }
    }

    if (!subject) {
        subject = did;
    }

    if (!subject) {
        return callback(JWT_ERRORS.INVALID_SSI_PROVIDED);
    }

    const issuer = did;

    if (!issuer) {
        return callback(JWT_ERRORS.INVALID_SSI_PROVIDED);
    }

    if (credentials) {
        credentials = Array.isArray(credentials) ? credentials : [credentials];
    }

    const header = {
        typ: DID_HEADER_TYPE,
    };

    const now = nowEpochSeconds();
    const __createAndSignJWT = (didDocument) => {
        didDocument.getPublicKey("pem", (err, publicKey) => {
            if (err) {
                return callback(createOpenDSUErrorWrapper(`Failed to get public key for did ${did}`, err));
            }

            const body = {
                sub: subject,
                // aud: encodeBase58(scope),
                scope,
                iss: issuer,
                publicKey,
                iat: now,
                nbf: now,
                exp: now + valability,
                credentials,
                options: optionsRest,
            };

            const segments = [encodeBase58(JSON.stringify(header)), encodeBase58(JSON.stringify(body))];
            const jwtToSign = segments.join(".");
            const crypto = require("opendsu").loadAPI("crypto");
            const hashResult = crypto.sha256(jwtToSign);

            didDocument.sign(hashResult, (signError, signResult) => {
                if (signError || !signResult) return callback(signError);
                const encodedSignResult = encodeBase58(signResult);

                const jwt = `${jwtToSign}.${encodedSignResult}`;
                callback(null, jwt);
            });
        });
    }
    if (didDocument) {
        __createAndSignJWT(didDocument);
    } else {
        w3cDID.resolveDID(did, (err, didDocument) => {
            if (err) {
                return callback(createOpenDSUErrorWrapper(`Failed to resolve did ${did}`, err));
            }

            __createAndSignJWT(didDocument);
        });
    }
}

function safeParseEncodedJson(data, keepBuffer) {
    try {
        const result = JSON.parse(decodeBase58(data, keepBuffer));
        return result;
    } catch (e) {
        return e;
    }
}

function parseJWTSegments(jwt, callback) {
    if (!jwt) return callback(JWT_ERRORS.EMPTY_JWT_PROVIDED);
    if (typeof jwt !== "string") return callback(JWT_ERRORS.INVALID_JWT_FORMAT);

    const segments = jwt.split(".");
    if (segments.length !== 3) return callback(JWT_ERRORS.INVALID_JWT_FORMAT);

    const header = safeParseEncodedJson(segments[0]);
    if (header instanceof Error || !header) return callback(JWT_ERRORS.INVALID_JWT_HEADER);

    const body = safeParseEncodedJson(segments[1]);
    if (body instanceof Error || !body) return callback(JWT_ERRORS.INVALID_JWT_BODY);

    const signatureInput = `${segments[0]}.${segments[1]}`;
    const signature = decodeBase58(segments[2], true);
    if (!signature) {
        // the signature couldn't be decoded due to an invalid signature
        return callback(JWT_ERRORS.INVALID_JWT_SIGNATURE);
    }

    return callback(null, {header, body, signature, signatureInput});
}

function isJwtExpired(body) {
    return new Date(body.exp * 1000) < new Date();
}

function isJwtNotActive(body) {
    return new Date(body.nbf * 1000) >= new Date();
}

function verifyJWTContent(jwtContent, callback) {
    const {header, body} = jwtContent;

    if (header.typ !== SEED_SSI_HEADER_TYPE && header.typ !== DID_HEADER_TYPE) return callback(JWT_ERRORS.INVALID_JWT_HEADER_TYPE);
    if (!body.iss) return callback(JWT_ERRORS.INVALID_JWT_ISSUER);
    if (isJwtExpired(body)) return callback(JWT_ERRORS.JWT_TOKEN_EXPIRED);
    if (isJwtNotActive(body)) return callback(JWT_ERRORS.JWT_TOKEN_NOT_ACTIVE);

    if (body.credentials && !Array.isArray(body.credentials)) return callback(JWT_ERRORS.INVALID_CREDENTIALS_FORMAT);

    callback(null);
}

const verifyJWT = ({jwt, rootOfTrustVerificationStrategy, verifySignature}, callback) => {
    parseJWTSegments(jwt, (parseError, jwtContent) => {
        if (parseError) return callback(parseError);

        verifyJWTContent(jwtContent, (verifyError) => {
            if (verifyError) return callback(verifyError);

            const {header, body, signatureInput, signature} = jwtContent;
            const {iss: sReadSSIString, publicKey} = body;

            const sReadSSI = keySSIFactory.create(sReadSSIString);
            const hashFn = require("../crypto").getCryptoFunctionForKeySSI(sReadSSI, "hash");
            const hash = hashFn(signatureInput);
            verifySignature(sReadSSI, hash, signature, publicKey, (verifyError, verifyResult) => {
                if (verifyError || !verifyResult) return callback(JWT_ERRORS.INVALID_JWT_SIGNATURE);

                if (typeof rootOfTrustVerificationStrategy === "function") {
                    rootOfTrustVerificationStrategy({header, body}, (verificationError, verificationResult) => {
                        if (verificationError || !verificationResult) {
                            return callback(JWT_ERRORS.ROOT_OF_TRUST_VERIFICATION_FAILED);
                        }
                        callback(null, true);
                    });
                    return;
                }

                callback(null, true);
            });
        });
    });
};

const verifyDID_JWT = ({jwt, rootOfTrustVerificationStrategy, verifySignature}, callback) => {
    parseJWTSegments(jwt, (parseError, jwtContent) => {
        if (parseError) return callback(parseError);

        verifyJWTContent(jwtContent, (verifyError) => {
            if (verifyError) return callback(verifyError);

            const {header, body, signatureInput, signature} = jwtContent;
            const {iss: did, publicKey} = body;

            const openDSU = require("opendsu");
            const crypto = openDSU.loadAPI("crypto");
            const hash = crypto.sha256(signatureInput);

            const w3cDID = openDSU.loadAPI("w3cdid");
            w3cDID.resolveDID(did, (err, didDocument) => {
                if (err) {
                    return callback(createOpenDSUErrorWrapper(`Failed to resolve did ${did}`, err));
                }

                didDocument.verify(hash, signature, (verifyError, verifyResult) => {
                    if (verifyError || !verifyResult) return callback(JWT_ERRORS.INVALID_JWT_SIGNATURE);

                    if (typeof rootOfTrustVerificationStrategy === "function") {
                        rootOfTrustVerificationStrategy({header, body}, (verificationError, verificationResult) => {
                            if (verificationError || !verificationResult) {
                                return callback(JWT_ERRORS.ROOT_OF_TRUST_VERIFICATION_FAILED);
                            }
                            callback(null, true);
                        });
                        return;
                    }

                    callback(null, true);
                });
            });
        });
    });
};

module.exports = {
    createJWT,
    verifyJWT,
    getReadableIdentity,
    parseJWTSegments,
    JWT_ERRORS,
    createJWTForDID,
    verifyDID_JWT
};

},{"../crypto":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/crypto/index.js","key-ssi-resolver":"key-ssi-resolver","opendsu":"opendsu"}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/crypto/mnemonic.js":[function(require,module,exports){
let WORDLISTS = {};
WORDLISTS["english"] = [
    "abandon", "ability", "able", "about", "above", "absent", "absorb", "abstract", "absurd", "abuse",
    "access", "accident", "account", "accuse", "achieve", "acid", "acoustic", "acquire", "across", "act",
    "action", "actor", "actress", "actual", "adapt", "add", "addict", "address", "adjust", "admit",
    "adult", "advance", "advice", "aerobic", "affair", "afford", "afraid", "again", "age", "agent",
    "agree", "ahead", "aim", "air", "airport", "aisle", "alarm", "album", "alcohol", "alert",
    "alien", "all", "alley", "allow", "almost", "alone", "alpha", "already", "also", "alter",
    "always", "amateur", "amazing", "among", "amount", "amused", "analyst", "anchor", "ancient", "anger",
    "angle", "angry", "animal", "ankle", "announce", "annual", "another", "answer", "antenna", "antique",
    "anxiety", "any", "apart", "apology", "appear", "apple", "approve", "april", "arch", "arctic",
    "area", "arena", "argue", "arm", "armed", "armor", "army", "around", "arrange", "arrest",
    "arrive", "arrow", "art", "artefact", "artist", "artwork", "ask", "aspect", "assault", "asset",
    "assist", "assume", "asthma", "athlete", "atom", "attack", "attend", "attitude", "attract", "auction",
    "audit", "august", "aunt", "author", "auto", "autumn", "average", "avocado", "avoid", "awake",
    "aware", "away", "awesome", "awful", "awkward", "axis", "baby", "bachelor", "bacon", "badge",
    "bag", "balance", "balcony", "ball", "bamboo", "banana", "banner", "bar", "barely", "bargain",
    "barrel", "base", "basic", "basket", "battle", "beach", "bean", "beauty", "because", "become",
    "beef", "before", "begin", "behave", "behind", "believe", "below", "belt", "bench", "benefit",
    "best", "betray", "better", "between", "beyond", "bicycle", "bid", "bike", "bind", "biology",
    "bird", "birth", "bitter", "black", "blade", "blame", "blanket", "blast", "bleak", "bless",
    "blind", "blood", "blossom", "blouse", "blue", "blur", "blush", "board", "boat", "body",
    "boil", "bomb", "bone", "bonus", "book", "boost", "border", "boring", "borrow", "boss",
    "bottom", "bounce", "box", "boy", "bracket", "brain", "brand", "brass", "brave", "bread",
    "breeze", "brick", "bridge", "brief", "bright", "bring", "brisk", "broccoli", "broken", "bronze",
    "broom", "brother", "brown", "brush", "bubble", "buddy", "budget", "buffalo", "build", "bulb",
    "bulk", "bullet", "bundle", "bunker", "burden", "burger", "burst", "bus", "business", "busy",
    "butter", "buyer", "buzz", "cabbage", "cabin", "cable", "cactus", "cage", "cake", "call",
    "calm", "camera", "camp", "can", "canal", "cancel", "candy", "cannon", "canoe", "canvas",
    "canyon", "capable", "capital", "captain", "car", "carbon", "card", "cargo", "carpet", "carry",
    "cart", "case", "cash", "casino", "castle", "casual", "cat", "catalog", "catch", "category",
    "cattle", "caught", "cause", "caution", "cave", "ceiling", "celery", "cement", "census", "century",
    "cereal", "certain", "chair", "chalk", "champion", "change", "chaos", "chapter", "charge", "chase",
    "chat", "cheap", "check", "cheese", "chef", "cherry", "chest", "chicken", "chief", "child",
    "chimney", "choice", "choose", "chronic", "chuckle", "chunk", "churn", "cigar", "cinnamon", "circle",
    "citizen", "city", "civil", "claim", "clap", "clarify", "claw", "clay", "clean", "clerk",
    "clever", "click", "client", "cliff", "climb", "clinic", "clip", "clock", "clog", "close",
    "cloth", "cloud", "clown", "club", "clump", "cluster", "clutch", "coach", "coast", "coconut",
    "code", "coffee", "coil", "coin", "collect", "color", "column", "combine", "come", "comfort",
    "comic", "common", "company", "concert", "conduct", "confirm", "congress", "connect", "consider", "control",
    "convince", "cook", "cool", "copper", "copy", "coral", "core", "corn", "correct", "cost",
    "cotton", "couch", "country", "couple", "course", "cousin", "cover", "coyote", "crack", "cradle",
    "craft", "cram", "crane", "crash", "crater", "crawl", "crazy", "cream", "credit", "creek",
    "crew", "cricket", "crime", "crisp", "critic", "crop", "cross", "crouch", "crowd", "crucial",
    "cruel", "cruise", "crumble", "crunch", "crush", "cry", "crystal", "cube", "culture", "cup",
    "cupboard", "curious", "current", "curtain", "curve", "cushion", "custom", "cute", "cycle", "dad",
    "damage", "damp", "dance", "danger", "daring", "dash", "daughter", "dawn", "day", "deal",
    "debate", "debris", "decade", "december", "decide", "decline", "decorate", "decrease", "deer", "defense",
    "define", "defy", "degree", "delay", "deliver", "demand", "demise", "denial", "dentist", "deny",
    "depart", "depend", "deposit", "depth", "deputy", "derive", "describe", "desert", "design", "desk",
    "despair", "destroy", "detail", "detect", "develop", "device", "devote", "diagram", "dial", "diamond",
    "diary", "dice", "diesel", "diet", "differ", "digital", "dignity", "dilemma", "dinner", "dinosaur",
    "direct", "dirt", "disagree", "discover", "disease", "dish", "dismiss", "disorder", "display", "distance",
    "divert", "divide", "divorce", "dizzy", "doctor", "document", "dog", "doll", "dolphin", "domain",
    "donate", "donkey", "donor", "door", "dose", "double", "dove", "draft", "dragon", "drama",
    "drastic", "draw", "dream", "dress", "drift", "drill", "drink", "drip", "drive", "drop",
    "drum", "dry", "duck", "dumb", "dune", "during", "dust", "dutch", "duty", "dwarf",
    "dynamic", "eager", "eagle", "early", "earn", "earth", "easily", "east", "easy", "echo",
    "ecology", "economy", "edge", "edit", "educate", "effort", "egg", "eight", "either", "elbow",
    "elder", "electric", "elegant", "element", "elephant", "elevator", "elite", "else", "embark", "embody",
    "embrace", "emerge", "emotion", "employ", "empower", "empty", "enable", "enact", "end", "endless",
    "endorse", "enemy", "energy", "enforce", "engage", "engine", "enhance", "enjoy", "enlist", "enough",
    "enrich", "enroll", "ensure", "enter", "entire", "entry", "envelope", "episode", "equal", "equip",
    "era", "erase", "erode", "erosion", "error", "erupt", "escape", "essay", "essence", "estate",
    "eternal", "ethics", "evidence", "evil", "evoke", "evolve", "exact", "example", "excess", "exchange",
    "excite", "exclude", "excuse", "execute", "exercise", "exhaust", "exhibit", "exile", "exist", "exit",
    "exotic", "expand", "expect", "expire", "explain", "expose", "express", "extend", "extra", "eye",
    "eyebrow", "fabric", "face", "faculty", "fade", "faint", "faith", "fall", "false", "fame",
    "family", "famous", "fan", "fancy", "fantasy", "farm", "fashion", "fat", "fatal", "father",
    "fatigue", "fault", "favorite", "feature", "february", "federal", "fee", "feed", "feel", "female",
    "fence", "festival", "fetch", "fever", "few", "fiber", "fiction", "field", "figure", "file",
    "film", "filter", "final", "find", "fine", "finger", "finish", "fire", "firm", "first",
    "fiscal", "fish", "fit", "fitness", "fix", "flag", "flame", "flash", "flat", "flavor",
    "flee", "flight", "flip", "float", "flock", "floor", "flower", "fluid", "flush", "fly",
    "foam", "focus", "fog", "foil", "fold", "follow", "food", "foot", "force", "forest",
    "forget", "fork", "fortune", "forum", "forward", "fossil", "foster", "found", "fox", "fragile",
    "frame", "frequent", "fresh", "friend", "fringe", "frog", "front", "frost", "frown", "frozen",
    "fruit", "fuel", "fun", "funny", "furnace", "fury", "future", "gadget", "gain", "galaxy",
    "gallery", "game", "gap", "garage", "garbage", "garden", "garlic", "garment", "gas", "gasp",
    "gate", "gather", "gauge", "gaze", "general", "genius", "genre", "gentle", "genuine", "gesture",
    "ghost", "giant", "gift", "giggle", "ginger", "giraffe", "girl", "give", "glad", "glance",
    "glare", "glass", "glide", "glimpse", "globe", "gloom", "glory", "glove", "glow", "glue",
    "goat", "goddess", "gold", "good", "goose", "gorilla", "gospel", "gossip", "govern", "gown",
    "grab", "grace", "grain", "grant", "grape", "grass", "gravity", "great", "green", "grid",
    "grief", "grit", "grocery", "group", "grow", "grunt", "guard", "guess", "guide", "guilt",
    "guitar", "gun", "gym", "habit", "hair", "half", "hammer", "hamster", "hand", "happy",
    "harbor", "hard", "harsh", "harvest", "hat", "have", "hawk", "hazard", "head", "health",
    "heart", "heavy", "hedgehog", "height", "hello", "helmet", "help", "hen", "hero", "hidden",
    "high", "hill", "hint", "hip", "hire", "history", "hobby", "hockey", "hold", "hole",
    "holiday", "hollow", "home", "honey", "hood", "hope", "horn", "horror", "horse", "hospital",
    "host", "hotel", "hour", "hover", "hub", "huge", "human", "humble", "humor", "hundred",
    "hungry", "hunt", "hurdle", "hurry", "hurt", "husband", "hybrid", "ice", "icon", "idea",
    "identify", "idle", "ignore", "ill", "illegal", "illness", "image", "imitate", "immense", "immune",
    "impact", "impose", "improve", "impulse", "inch", "include", "income", "increase", "index", "indicate",
    "indoor", "industry", "infant", "inflict", "inform", "inhale", "inherit", "initial", "inject", "injury",
    "inmate", "inner", "innocent", "input", "inquiry", "insane", "insect", "inside", "inspire", "install",
    "intact", "interest", "into", "invest", "invite", "involve", "iron", "island", "isolate", "issue",
    "item", "ivory", "jacket", "jaguar", "jar", "jazz", "jealous", "jeans", "jelly", "jewel",
    "job", "join", "joke", "journey", "joy", "judge", "juice", "jump", "jungle", "junior",
    "junk", "just", "kangaroo", "keen", "keep", "ketchup", "key", "kick", "kid", "kidney",
    "kind", "kingdom", "kiss", "kit", "kitchen", "kite", "kitten", "kiwi", "knee", "knife",
    "knock", "know", "lab", "label", "labor", "ladder", "lady", "lake", "lamp", "language",
    "laptop", "large", "later", "latin", "laugh", "laundry", "lava", "law", "lawn", "lawsuit",
    "layer", "lazy", "leader", "leaf", "learn", "leave", "lecture", "left", "leg", "legal",
    "legend", "leisure", "lemon", "lend", "length", "lens", "leopard", "lesson", "letter", "level",
    "liar", "liberty", "library", "license", "life", "lift", "light", "like", "limb", "limit",
    "link", "lion", "liquid", "list", "little", "live", "lizard", "load", "loan", "lobster",
    "local", "lock", "logic", "lonely", "long", "loop", "lottery", "loud", "lounge", "love",
    "loyal", "lucky", "luggage", "lumber", "lunar", "lunch", "luxury", "lyrics", "machine", "mad",
    "magic", "magnet", "maid", "mail", "main", "major", "make", "mammal", "man", "manage",
    "mandate", "mango", "mansion", "manual", "maple", "marble", "march", "margin", "marine", "market",
    "marriage", "mask", "mass", "master", "match", "material", "math", "matrix", "matter", "maximum",
    "maze", "meadow", "mean", "measure", "meat", "mechanic", "medal", "media", "melody", "melt",
    "member", "memory", "mention", "menu", "mercy", "merge", "merit", "merry", "mesh", "message",
    "metal", "method", "middle", "midnight", "milk", "million", "mimic", "mind", "minimum", "minor",
    "minute", "miracle", "mirror", "misery", "miss", "mistake", "mix", "mixed", "mixture", "mobile",
    "model", "modify", "mom", "moment", "monitor", "monkey", "monster", "month", "moon", "moral",
    "more", "morning", "mosquito", "mother", "motion", "motor", "mountain", "mouse", "move", "movie",
    "much", "muffin", "mule", "multiply", "muscle", "museum", "mushroom", "music", "must", "mutual",
    "myself", "mystery", "myth", "naive", "name", "napkin", "narrow", "nasty", "nation", "nature",
    "near", "neck", "need", "negative", "neglect", "neither", "nephew", "nerve", "nest", "net",
    "network", "neutral", "never", "news", "next", "nice", "night", "noble", "noise", "nominee",
    "noodle", "normal", "north", "nose", "notable", "note", "nothing", "notice", "novel", "now",
    "nuclear", "number", "nurse", "nut", "oak", "obey", "object", "oblige", "obscure", "observe",
    "obtain", "obvious", "occur", "ocean", "october", "odor", "off", "offer", "office", "often",
    "oil", "okay", "old", "olive", "olympic", "omit", "once", "one", "onion", "online",
    "only", "open", "opera", "opinion", "oppose", "option", "orange", "orbit", "orchard", "order",
    "ordinary", "organ", "orient", "original", "orphan", "ostrich", "other", "outdoor", "outer", "output",
    "outside", "oval", "oven", "over", "own", "owner", "oxygen", "oyster", "ozone", "pact",
    "paddle", "page", "pair", "palace", "palm", "panda", "panel", "panic", "panther", "paper",
    "parade", "parent", "park", "parrot", "party", "pass", "patch", "path", "patient", "patrol",
    "pattern", "pause", "pave", "payment", "peace", "peanut", "pear", "peasant", "pelican", "pen",
    "penalty", "pencil", "people", "pepper", "perfect", "permit", "person", "pet", "phone", "photo",
    "phrase", "physical", "piano", "picnic", "picture", "piece", "pig", "pigeon", "pill", "pilot",
    "pink", "pioneer", "pipe", "pistol", "pitch", "pizza", "place", "planet", "plastic", "plate",
    "play", "please", "pledge", "pluck", "plug", "plunge", "poem", "poet", "point", "polar",
    "pole", "police", "pond", "pony", "pool", "popular", "portion", "position", "possible", "post",
    "potato", "pottery", "poverty", "powder", "power", "practice", "praise", "predict", "prefer", "prepare",
    "present", "pretty", "prevent", "price", "pride", "primary", "print", "priority", "prison", "private",
    "prize", "problem", "process", "produce", "profit", "program", "project", "promote", "proof", "property",
    "prosper", "protect", "proud", "provide", "public", "pudding", "pull", "pulp", "pulse", "pumpkin",
    "punch", "pupil", "puppy", "purchase", "purity", "purpose", "purse", "push", "put", "puzzle",
    "pyramid", "quality", "quantum", "quarter", "question", "quick", "quit", "quiz", "quote", "rabbit",
    "raccoon", "race", "rack", "radar", "radio", "rail", "rain", "raise", "rally", "ramp",
    "ranch", "random", "range", "rapid", "rare", "rate", "rather", "raven", "raw", "razor",
    "ready", "real", "reason", "rebel", "rebuild", "recall", "receive", "recipe", "record", "recycle",
    "reduce", "reflect", "reform", "refuse", "region", "regret", "regular", "reject", "relax", "release",
    "relief", "rely", "remain", "remember", "remind", "remove", "render", "renew", "rent", "reopen",
    "repair", "repeat", "replace", "report", "require", "rescue", "resemble", "resist", "resource", "response",
    "result", "retire", "retreat", "return", "reunion", "reveal", "review", "reward", "rhythm", "rib",
    "ribbon", "rice", "rich", "ride", "ridge", "rifle", "right", "rigid", "ring", "riot",
    "ripple", "risk", "ritual", "rival", "river", "road", "roast", "robot", "robust", "rocket",
    "romance", "roof", "rookie", "room", "rose", "rotate", "rough", "round", "route", "royal",
    "rubber", "rude", "rug", "rule", "run", "runway", "rural", "sad", "saddle", "sadness",
    "safe", "sail", "salad", "salmon", "salon", "salt", "salute", "same", "sample", "sand",
    "satisfy", "satoshi", "sauce", "sausage", "save", "say", "scale", "scan", "scare", "scatter",
    "scene", "scheme", "school", "science", "scissors", "scorpion", "scout", "scrap", "screen", "script",
    "scrub", "sea", "search", "season", "seat", "second", "secret", "section", "security", "seed",
    "seek", "segment", "select", "sell", "seminar", "senior", "sense", "sentence", "series", "service",
    "session", "settle", "setup", "seven", "shadow", "shaft", "shallow", "share", "shed", "shell",
    "sheriff", "shield", "shift", "shine", "ship", "shiver", "shock", "shoe", "shoot", "shop",
    "short", "shoulder", "shove", "shrimp", "shrug", "shuffle", "shy", "sibling", "sick", "side",
    "siege", "sight", "sign", "silent", "silk", "silly", "silver", "similar", "simple", "since",
    "sing", "siren", "sister", "situate", "six", "size", "skate", "sketch", "ski", "skill",
    "skin", "skirt", "skull", "slab", "slam", "sleep", "slender", "slice", "slide", "slight",
    "slim", "slogan", "slot", "slow", "slush", "small", "smart", "smile", "smoke", "smooth",
    "snack", "snake", "snap", "sniff", "snow", "soap", "soccer", "social", "sock", "soda",
    "soft", "solar", "soldier", "solid", "solution", "solve", "someone", "song", "soon", "sorry",
    "sort", "soul", "sound", "soup", "source", "south", "space", "spare", "spatial", "spawn",
    "speak", "special", "speed", "spell", "spend", "sphere", "spice", "spider", "spike", "spin",
    "spirit", "split", "spoil", "sponsor", "spoon", "sport", "spot", "spray", "spread", "spring",
    "spy", "square", "squeeze", "squirrel", "stable", "stadium", "staff", "stage", "stairs", "stamp",
    "stand", "start", "state", "stay", "steak", "steel", "stem", "step", "stereo", "stick",
    "still", "sting", "stock", "stomach", "stone", "stool", "story", "stove", "strategy", "street",
    "strike", "strong", "struggle", "student", "stuff", "stumble", "style", "subject", "submit", "subway",
    "success", "such", "sudden", "suffer", "sugar", "suggest", "suit", "summer", "sun", "sunny",
    "sunset", "super", "supply", "supreme", "sure", "surface", "surge", "surprise", "surround", "survey",
    "suspect", "sustain", "swallow", "swamp", "swap", "swarm", "swear", "sweet", "swift", "swim",
    "swing", "switch", "sword", "symbol", "symptom", "syrup", "system", "table", "tackle", "tag",
    "tail", "talent", "talk", "tank", "tape", "target", "task", "taste", "tattoo", "taxi",
    "teach", "team", "tell", "ten", "tenant", "tennis", "tent", "term", "test", "text",
    "thank", "that", "theme", "then", "theory", "there", "they", "thing", "this", "thought",
    "three", "thrive", "throw", "thumb", "thunder", "ticket", "tide", "tiger", "tilt", "timber",
    "time", "tiny", "tip", "tired", "tissue", "title", "toast", "tobacco", "today", "toddler",
    "toe", "together", "toilet", "token", "tomato", "tomorrow", "tone", "tongue", "tonight", "tool",
    "tooth", "top", "topic", "topple", "torch", "tornado", "tortoise", "toss", "total", "tourist",
    "toward", "tower", "town", "toy", "track", "trade", "traffic", "tragic", "train", "transfer",
    "trap", "trash", "travel", "tray", "treat", "tree", "trend", "trial", "tribe", "trick",
    "trigger", "trim", "trip", "trophy", "trouble", "truck", "true", "truly", "trumpet", "trust",
    "truth", "try", "tube", "tuition", "tumble", "tuna", "tunnel", "turkey", "turn", "turtle",
    "twelve", "twenty", "twice", "twin", "twist", "two", "type", "typical", "ugly", "umbrella",
    "unable", "unaware", "uncle", "uncover", "under", "undo", "unfair", "unfold", "unhappy", "uniform",
    "unique", "unit", "universe", "unknown", "unlock", "until", "unusual", "unveil", "update", "upgrade",
    "uphold", "upon", "upper", "upset", "urban", "urge", "usage", "use", "used", "useful",
    "useless", "usual", "utility", "vacant", "vacuum", "vague", "valid", "valley", "valve", "van",
    "vanish", "vapor", "various", "vast", "vault", "vehicle", "velvet", "vendor", "venture", "venue",
    "verb", "verify", "version", "very", "vessel", "veteran", "viable", "vibrant", "vicious", "victory",
    "video", "view", "village", "vintage", "violin", "virtual", "virus", "visa", "visit", "visual",
    "vital", "vivid", "vocal", "voice", "void", "volcano", "volume", "vote", "voyage", "wage",
    "wagon", "wait", "walk", "wall", "walnut", "want", "warfare", "warm", "warrior", "wash",
    "wasp", "waste", "water", "wave", "way", "wealth", "weapon", "wear", "weasel", "weather",
    "web", "wedding", "weekend", "weird", "welcome", "west", "wet", "whale", "what", "wheat",
    "wheel", "when", "where", "whip", "whisper", "wide", "width", "wife", "wild", "will",
    "win", "window", "wine", "wing", "wink", "winner", "winter", "wire", "wisdom", "wise",
    "wish", "witness", "wolf", "woman", "wonder", "wood", "wool", "word", "work", "world",
    "worry", "worth", "wrap", "wreck", "wrestle", "wrist", "write", "wrong", "yard", "year",
    "yellow", "you", "young", "youth", "zebra", "zero", "zone", "zoo"];

const Mnemonic = function (language) {

    const RADIX = 2048;

    const self = this;
    let wordlist = [];

    function init() {
        wordlist = WORDLISTS[language];
        if (wordlist.length != RADIX) {
            err = 'Wordlist should contain ' + RADIX + ' words, but it contains ' + wordlist.length + ' words.';
            throw err;
        }
    }

    self.toMnemonic = function (byteArray, hashFunction) {
        if (byteArray.length % 4 > 0) {
            throw 'Data length in bits should be divisible by 32, but it is not (' + byteArray.length + ' bytes = ' + byteArray.length * 8 + ' bits).'
        }

        const data = byteArrayToWordArray(byteArray);
        const hash = byteArrayToWordArray(hashFunction(data));

        const h = fromBits(hash);
        const a = byteArrayToBinaryString(byteArray);
        const c = zfill(hexStringToBinaryString(h), 256);
        const d = c.substring(0, byteArray.length * 8 / 32);

        const b = a + d;

        let result = [];
        const blen = b.length / 11;
        for (let i = 0; i < blen; i++) {
            const idx = parseInt(b.substring(i * 11, (i + 1) * 11), 2);
            result.push(wordlist[idx]);
        }
        return self.joinWords(result);
    }


    self.toRawEntropyHex = function (mnemonic) {
        const b = mnemonicToBinaryString(mnemonic);
        if (b === null)
            return null;
        const d = b.substring(0, b.length / 33 * 32);
        const nd = binaryStringToWordArray(d);

        let h = "";
        for (let i = 0; i < nd.length; i++) {
            h += ('0000000' + nd[i].toString(16)).slice(-8);
        }
        return h;
    }

    self.splitWords = function (mnemonic) {
        return mnemonic.split(/\s/g).filter(function (x) { return x.length; });
    }

    self.joinWords = function (words) {
        // Set space correctly depending on the language
        // see https://github.com/bitcoin/bips/blob/master/bip-0039/bip-0039-wordlists.md#japanese
        let space = " ";
        if (language == "japanese") {
            space = "\u3000"; // ideographic space
        }
        return words.join(space);
    }

    self.normalizeString = function (str) {
        return str.normalize("NFKD");
    }

    function byteArrayToWordArray(data) {
        let a = [];
        for (let i = 0; i < data.length / 4; i++) {
            let v = 0;
            v += data[i * 4 + 0] << 8 * 3;
            v += data[i * 4 + 1] << 8 * 2;
            v += data[i * 4 + 2] << 8 * 1;
            v += data[i * 4 + 3] << 8 * 0;
            a.push(v);
        }
        return a;
    }

    function byteArrayToBinaryString(data) {
        let bin = "";
        for (let i = 0; i < data.length; i++) {
            bin += zfill(data[i].toString(2), 8);
        }
        return bin;
    }

    function hexStringToBinaryString(hexString) {
        let binaryString = "";
        for (let i = 0; i < hexString.length; i++) {
            binaryString += zfill(parseInt(hexString[i], 16).toString(2), 4);
        }
        return binaryString;
    }

    function binaryStringToWordArray(binary) {
        const aLen = binary.length / 32;
        let a = [];
        for (let i = 0; i < aLen; i++) {
            const valueStr = binary.substring(0, 32);
            const value = parseInt(valueStr, 2);
            a.push(value);
            binary = binary.slice(32);
        }
        return a;
    }

    function mnemonicToBinaryString(mnemonicString) {
        const mnemonic = self.splitWords(mnemonicString);
        if (mnemonic.length == 0 || mnemonic.length % 3 > 0) {
            return null;
        }
       
        let idx = [];
        for (let i = 0; i < mnemonic.length; i++) {
            const word = mnemonic[i];
            const wordIndex = wordlist.indexOf(word);
            if (wordIndex == -1) {
                return null;
            }
            const binaryIndex = zfill(wordIndex.toString(2), 11);
            idx.push(binaryIndex);
        }
        return idx.join('');
    }

    // Pad a numeric string on the left with zero digits until the given width
    // is reached.
    // Note this differs to the python implementation because it does not
    // handle numbers starting with a sign.
    function zfill(source, length) {
        source = source.toString();
        while (source.length < length) {
            source = '0' + source;
        }
        return source;
    }

    function bitLength(a){
        let l = a.length, x;
        if (l === 0) { return 0; }
        x = a[l - 1];
        return (l - 1) * 32 + getPartial(x);
    }

    function getPartial(x) {
        return Math.round(x / 0x10000000000) || 32;
    }

    /** Convert from a bitArray to a UTF-8 string. */
    function fromBits(arr) {
        let out = "", i;
        for (i = 0; i < arr.length; i++) {
            out += ((arr[i] | 0) + 0xF00000000000).toString(16).substr(4);
        }
        return out.substr(0, bitLength(arr) / 4);
    }

    init();
}

module.exports = {
    Mnemonic
};

},{}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/db/conflictSolvingStrategies/timestampMergingStrategy.js":[function(require,module,exports){
module.exports.TimestampMergingStrategy = function(){

}
},{}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/db/impl/BasicDB.js":[function(require,module,exports){
/*
    An OpenDSU  BasicDB is a simple noSQL database
    The DB is used with a concept of "table" and rows (records) that have multiple versions
    The support for multiple versions is offered by getVersions function and by automatically managing 2 fields in the records:
         - the "__version" field representing the height of the graph
         - the "__previousRecord" field pointing to the previous version of the record
         - the "__changeId" is unique id, is used to quickly determine the unique id of parent node/s for future conflict solving
         - the "__timestamp" is a timestamp, number of milliseconds elapsed since January 1, 1970 00:00:00 UTC.

    As you can see, nothing is ever really updated, even the deletion is done by marking the record with the field "deleted"
 */

const ObservableMixin = require("../../utils/ObservableMixin");
let bindAutoPendingFunctions = require("../../utils/BindAutoPendingFunctions").bindAutoPendingFunctions;

/*
const crypto = require("crypto"); TODO: if required use from pskcrypto to have a single and portable point in all code

function uid(bytes = 32) {
    // node
    if (process) {
        return crypto.randomBytes(bytes).toString('base64')
    }
    // browser
    else {
        if (!crypto || !crypto.getRandomValues) {
            throw new Error('crypto.getRandomValues not supported by the browser.')
        }
        return btoa(String.fromCharCode(...crypto.getRandomValues(new Uint8Array(bytes))))
    }
}  */


function BasicDB(storageStrategy, conflictSolvingStrategy, options) {
    let self = this;
    options = options || {events: false};
    ObservableMixin(this);

    const errorAPI = require("opendsu").loadAPI("error");

    storageStrategy.on("initialised", () => {
        this.finishInitialisation();
        this.dispatchEvent("initialised");
    });

    this.refresh = (callback) => {
        storageStrategy.refresh(callback);
    }

    this.getAllRecords = (tableName, callback) => {
        storageStrategy.getAllRecords(tableName, callback);
    }

    this.addIndex = function (tableName, fieldName, forceReindex, callback) {
        if (typeof forceReindex === "function") {
            callback = forceReindex;
            forceReindex = false;
        }

        if (typeof forceReindex === "undefined") {
            forceReindex = false;
        }

        storageStrategy.addIndex(tableName, fieldName, forceReindex, callback);
    }
    /*
        Get the whole content of the table and asynchronously return an array with all the  records satisfying the condition tested by the filterFunction
     */
    this.filter = function (tableName, query, sort, limit, callback) {
        storageStrategy.filter(tableName, query, sort, limit, callback);
    };

    this.query = this.filter;

    function getDefaultCallback(message, tableName, key) {
        return function (err, res) {
            if (err) {
                reportUserRelevantError(message + ` with errors in table ${tableName} for key ${key}`, err);
            } else {
                console.log(message, `in table ${tableName} for key ${key}`);
            }
        }
    }

    /*
      Insert a record, return an error if an record with thew same key already exists
    */
    this.insertRecord = function (tableName, key, record, callback) {
        callback = callback ? callback : getDefaultCallback("Inserting a record", tableName, key);

        self.getRecord(tableName, key, function (err, res) {
            if (!err || res) {
                //newRecord = Object.assign(newRecord, {__version:-1});
                return callback(createOpenDSUErrorWrapper("Failed to insert over an existing record", new Error(errorAPI.DB_INSERT_EXISTING_RECORD_ERROR)));
            }
            const sharedDSUMetadata = {}
            sharedDSUMetadata.__version = 0;
            sharedDSUMetadata.pk = key;
            //sharedDSUMetadata.__changeId = uid();
            sharedDSUMetadata.__timestamp = Date.now();
            storageStrategy.insertRecord(tableName, key, Object.assign(sharedDSUMetadata, record), (err, res) => {
                if (err) {
                    return callback(createOpenDSUErrorWrapper(`Failed to insert record with key ${key} in table ${tableName} `, err));
                }

                if (options.events) {
                    self.dispatchEvent("change", JSON.stringify({table: tableName, pk: key}));
                }
                callback(undefined, res);
            });
        });
    };


    /*
        Update a record, return an error if does not exists (does not do an insert)
     */
    this.updateRecord = function (tableName, key, newRecord, callback) {
        callback = callback ? callback : getDefaultCallback("Updating a record", tableName, key);
        let currentRecord;

        function doVersionIncAndUpdate(currentRecord, callback) {
            newRecord.__version++;
            newRecord.__timestamp = Date.now();
            //newRecord.__changeId = uid();

            if (newRecord.__version == 0) {
                storageStrategy.insertRecord(tableName, key, newRecord, callback);
            } else {
                storageStrategy.updateRecord(tableName, key, newRecord, currentRecord, callback);
            }
        }

        self.getRecord(tableName, key, function (err, res) {
            if (err || !res) {
                //newRecord = Object.assign(newRecord, {__version:-1});
                return callback(createOpenDSUErrorWrapper("Failed to update a record that does not exist", err));
            }
            if (res) {
                currentRecord = res;
                newRecord.__version = currentRecord.__version;
                newRecord.pk = key;
            }
            doVersionIncAndUpdate(currentRecord, (err) => {
                if (err) {
                    return callback(createOpenDSUErrorWrapper(`Failed to update record with key ${key} in table ${tableName} `, err));
                }

                if (options.events) {
                    self.dispatchEvent("change", JSON.stringify({table: tableName, pk: key}));
                }
                callback(undefined, newRecord);
            });
        });
    }

    /*
        Get a single row from a table
     */
    this.getRecord = function (tableName, key, callback) {
        storageStrategy.getRecord(tableName, key, function (err, res) {
            if (err || res.__deleted) {
                return callback(createOpenDSUErrorWrapper(`Missing record in table ${tableName} and key ${key}`, err));
            }
            callback(undefined, res);
        });
    };

    /*
      Get the history of a record, including the deleted versions
   */
    this.getHistory = function (tableName, key, callback) {
        storageStrategy.getRecord(tableName, key, function (err, res) {
            if (err) {
                return callback(createOpenDSUErrorWrapper(`No history for table ${tableName} and key ${key}`, err));
            }
            callback(undefined, self.getRecordVersions(res));
        });
    };

    /*
      Delete a record
     */
    this.deleteRecord = function (tableName, key, callback) {
        self.getRecord(tableName, key, function (err, record) {
            if (err) {
                return callback(createOpenDSUErrorWrapper(`Could not retrieve record with key ${key} does not exist ${tableName} `, err));
            }

            const currentRecord = JSON.parse(JSON.stringify(record));
            record.__version++;
            record.__timestamp = Date.now();
            record.__deleted = true;
            storageStrategy.updateRecord(tableName, key, record, currentRecord, (err) => {
                if (err) {
                    return callback(createOpenDSUErrorWrapper(`Failed to update with key ${key} in table ${tableName} `, err));
                }

                if (options.events) {
                    self.dispatchEvent("change", JSON.stringify({table: tableName, pk: key}));
                }
                callback();
            });
        })
    };

    this.getRecordVersions = function (record) {
        let arrRes = []
        while (record) {
            arrRes.unshift(record);
            record = record.__previousRecord;
        }
        return arrRes;
    }

    this.getIndexedFields = function (tableName, callback) {
        storageStrategy.getIndexedFields(tableName, callback);
    }

    this.writeKey = function (key, value, callback) {
        storageStrategy.writeKey(key, value, callback);
    };

    this.readKey = function (key, callback) {
        storageStrategy.readKey(key, callback);
    }
    this.beginBatch = () => {
        storageStrategy.beginBatch()
    }

    this.cancelBatch = (callback) => {
        storageStrategy.cancelBatch(callback)
    }

    this.commitBatch = (callback) => {
        storageStrategy.commitBatch(callback)
    }


    bindAutoPendingFunctions(this, ["on", "off", "dispatchEvent"]);
    //============================================================
    // To not add others property on this object below this call =
    //============================================================
}

module.exports = BasicDB;

},{"../../utils/BindAutoPendingFunctions":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/utils/BindAutoPendingFunctions.js","../../utils/ObservableMixin":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/utils/ObservableMixin.js","opendsu":"opendsu"}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/db/impl/DSUDBUtil.js":[function(require,module,exports){
module.exports = {
    ensure_WalletDB_DSU_Initialisation: function (keySSI, dbName, callback) {
        let resolver = require("../../resolver");
        let keySSIApis = require("../../keyssi");
        let constants = require("../../moduleConstants");

        let doStorageDSUInitialisation = registerMandatoryCallback(
            function (dsu, sharableSSI) {
                callback(undefined, dsu, sharableSSI);
            }, 10000);

        if (typeof keySSI === "string") {
            try {
                keySSI = keySSIApis.parse(keySSI);
            } catch (e) {
                return callback(createOpenDSUErrorWrapper(`Failed to parse keySSI ${keySSI}`, e));
            }
        }
        resolver.loadDSU(keySSI, (err, dsuInstance) => {
            if ((err || !dsuInstance) && keySSI.getTypeName() === constants.KEY_SSIS.SEED_SSI) {
                return createSeedDSU();
            }

            waitForWritableSSI(dsuInstance);
        });

        function createSeedDSU() {
            let writableDSU;

            function createWritableDSU() {
                let writableSSI = keySSIApis.createTemplateKeySSI(constants.KEY_SSIS.SEED_SSI, keySSI.getDLDomain());
                resolver.createDSU(writableSSI, function (err, res) {
                    if (err) {
                        return callback(createOpenDSUErrorWrapper("Failed to create writable DSU while initialising shared database " + dbName, err));
                    }
                    writableDSU = res;
                    createWrapperDSU();
                });
            }

            function createWrapperDSU() {
                resolver.createDSUForExistingSSI(keySSI, function (err, res) {
                    if (err) {
                        return callback(createOpenDSUErrorWrapper("Failed to create wrapper DSU while initialising shared database " + dbName, err));
                    }
                    res.beginBatch();
                    res.mount("/data", writableDSU.getCreationSSI(), function (err, resSSI) {
                        if (err) {
                            return callback(createOpenDSUErrorWrapper("Failed to mount writable DSU in wrapper DSU while initialising shared database " + dbName, err));
                        }
                        res.commitBatch((err) => {
                            if (err) {
                                return callback(createOpenDSUErrorWrapper("Failed to anchor batch", err));
                            }
                            keySSI.derive((err, derivedKeySSI)=>{
                                if (err) {
                                    return callback(createOpenDSUErrorWrapper(`Failed to derive keySSI ${keySSI.getIdentifier()}`, err));
                                }
                                doStorageDSUInitialisation(writableDSU, derivedKeySSI);
                            })
                        });
                    });
                });
            }

            reportUserRelevantWarning("Creating a new shared database");
            createWritableDSU();
        }

        function waitForWritableSSI(dsuInstance) {
            dsuInstance.getArchiveForPath("/data/dsu-metadata-log", (err, result) => {
                if (err) {
                    return callback(createOpenDSUErrorWrapper("Failed to load writable DSU " + dbName, err));
                }

                const keyssiAPI = require("opendsu").loadAPI("keyssi");
                const writableSSI = keyssiAPI.parse(result.archive.getCreationSSI());
                if (writableSSI.getTypeName() === "sread") {
                    console.log("Delaying the loading of DSU based on the fact that current stare not reflecting a DB dsu type structure");
                    return setTimeout(() => {
                        dsuInstance.load(waitForWritableSSI);
                    }, 1000);
                }

                doStorageDSUInitialisation(result.archive, keySSI);
                reportUserRelevantWarning("Loading a shared database");
            });
        }

    },
    initialiseWalletDB: function (dbName, keySSI, callback) {
        if (typeof keySSI === "function") {
            callback = keySSI;
            keySSI = undefined;
        }
        const openDSU = require("opendsu");
        let resolver = openDSU.loadAPI("resolver");
        let scAPI = openDSU.loadAPI("sc");
        let keySSISpace = openDSU.loadAPI("keyssi");
        let storageDSU;
        const DB_KEY_SSI_PATH = `/db/${dbName}`;
        scAPI.getMainDSU(async (err, mainDSU) => {
            if (err) {
                return callback(err);
            }

            if(!keySSI){
                try {
                    keySSI = await $$.promisify(mainDSU.readFile)(DB_KEY_SSI_PATH);
                    keySSI = keySSI.toString();

                } catch (e) {
                    let vaultDomain;
                    try {
                        vaultDomain = await $$.promisify(scAPI.getVaultDomain)();
                    } catch (e) {
                        return callback(createOpenDSUErrorWrapper(`Failed to get vault domain`, e));
                    }
                    try {
                        storageDSU = await $$.promisify(resolver.createSeedDSU)(vaultDomain);
                    } catch (e) {
                        return callback(createOpenDSUErrorWrapper(`Failed to create Seed DSU`, e));
                    }

                    try {
                        keySSI = await $$.promisify(storageDSU.getKeySSIAsObject)();
                    } catch (e) {
                        return callback(createOpenDSUErrorWrapper(`Failed to get storageDSU's keySSI`, e));
                    }

                    try {
                        await $$.promisify(mainDSU.writeFile)(DB_KEY_SSI_PATH, keySSI.getIdentifier());
                    } catch (e) {
                        return callback(createOpenDSUErrorWrapper(`Failed to store key SSI in mainDSU for db <${dbName}>`, e));
                    }

                    return callback(undefined, storageDSU, keySSI);
                }
            }

            try {
                storageDSU = await $$.promisify(resolver.loadDSU)(keySSI)
            } catch (e) {
                return callback(createOpenDSUErrorWrapper(`Failed to load storage DSU for db <${dbName}>`, e));
            }

            if(typeof keySSI === "string") {
                try{
                    keySSI = keySSISpace.parse(keySSI);
                }catch (e) {
                    return callback(createOpenDSUErrorWrapper(`Failed to parse keySSI <${keySSI}>`, e));
                }
            }
            try {
                await $$.promisify(mainDSU.writeFile)(DB_KEY_SSI_PATH, keySSI.getIdentifier());
            } catch (e) {
                return callback(createOpenDSUErrorWrapper(`Failed to store key SSI in mainDSU for db <${dbName}>`, e));
            }

            return callback(undefined, storageDSU, keySSI);
        })
    },
    ensure_MultiUserDB_DSU_Initialisation: function (keySSI, dbName, userId, callback) {
    }
}

},{"../../keyssi":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/keyssi/index.js","../../moduleConstants":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/moduleConstants.js","../../resolver":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/resolver/index.js","opendsu":"opendsu"}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/db/index.js":[function(require,module,exports){
let util = require("./impl/DSUDBUtil")

function getBasicDB(storageStrategy, conflictSolvingStrategy, options) {
    let BasicDB = require("./impl/BasicDB");
    return new BasicDB(storageStrategy, conflictSolvingStrategy, options);
}

function getMultiUserDB(keySSI, dbName) {
    throw "Not implemented yet";
}

let getSharedDB = function (keySSI, dbName, options) {
    let SingleDSUStorageStrategy = require("./storageStrategies/SingleDSUStorageStrategy").SingleDSUStorageStrategy;
    let storageStrategy = new SingleDSUStorageStrategy();
    let ConflictStrategy = require("./conflictSolvingStrategies/timestampMergingStrategy").TimestampMergingStrategy;
    let db = getBasicDB(storageStrategy, new ConflictStrategy(), options);

    util.ensure_WalletDB_DSU_Initialisation(keySSI, dbName, function (err, _storageDSU, sharableSSI) {
        if (err) {
            return OpenDSUSafeCallback()(createOpenDSUErrorWrapper("Failed to initialise WalletDB_DSU " + dbName, err));
        }
        storageStrategy.initialise(_storageDSU, dbName);
        console.log("Finishing initialisation");

        db.getShareableSSI = function () {
            return sharableSSI;
        };
    })

    return db;
};

let getSimpleWalletDB = (dbName, options) => {
    options = options || {};
    let SingleDSUStorageStrategy = require("./storageStrategies/SingleDSUStorageStrategy").SingleDSUStorageStrategy;
    let storageStrategy = new SingleDSUStorageStrategy();
    let ConflictStrategy = require("./conflictSolvingStrategies/timestampMergingStrategy").TimestampMergingStrategy;
    let db = getBasicDB(storageStrategy, new ConflictStrategy(), options);

    util.initialiseWalletDB(dbName, options.keySSI, (err, _storageDSU, keySSI) => {
        if (err) {
            return db.dispatchEvent("error", createOpenDSUErrorWrapper("Failed to initialise WalletDB_DSU " + dbName, err));
        }
        storageStrategy.initialise(_storageDSU, dbName);
        console.log("Finishing initialisation");

        db.getShareableSSI = function () {
            return keySSI;
        };
    })

    return db;
};

const getInMemoryDB = () => {
    const MemoryStorageStrategy = require("./storageStrategies/MemoryStorageStrategy");
    const storageStrategy = new MemoryStorageStrategy();
    return getBasicDB(storageStrategy);
}

const getEnclaveDB = () => {
    throw Error("Not implemented");
};

const mainEnclaveIsInitialised = ()=>{
    const sc = require("opendsu").loadAPI("sc");
    return sc.securityContextIsInitialised();
}

const getMainEnclaveDB = (callback) => {
    require("opendsu").loadAPI("sc").getMainEnclave(callback);
}

const getSharedEnclaveDB = (callback) => {
     require("opendsu").loadAPI("sc").getSharedEnclave(callback);
}
module.exports = {
    getBasicDB,
    getWalletDB(keySSI, dbName) {
        console.warn(`The function "getWalletDB is obsolete. Use getSimpleWalletDB instead`);
        return getSharedDB(keySSI, dbName);
    },
    getSimpleWalletDB,
    getMultiUserDB,
    getSharedDB,
    getInMemoryDB,
    getEnclaveDB,
    getMainEnclaveDB,
    getMainEnclave: getMainEnclaveDB,
    mainEnclaveIsInitialised,
    getSharedEnclave: getSharedEnclaveDB,
    getSharedEnclaveDB
}

},{"./conflictSolvingStrategies/timestampMergingStrategy":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/db/conflictSolvingStrategies/timestampMergingStrategy.js","./impl/BasicDB":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/db/impl/BasicDB.js","./impl/DSUDBUtil":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/db/impl/DSUDBUtil.js","./storageStrategies/MemoryStorageStrategy":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/db/storageStrategies/MemoryStorageStrategy.js","./storageStrategies/SingleDSUStorageStrategy":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/db/storageStrategies/SingleDSUStorageStrategy.js","opendsu":"opendsu"}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/db/storageStrategies/MemoryStorageStrategy.js":[function(require,module,exports){
(function (Buffer){(function (){
function MemoryStorageStrategy() {
    const ObservableMixin = require("../../utils/ObservableMixin");
    const operators = require("./operators");
    let volatileMemory = {}
    let self = this
    let storageDSU, afterInitialisation;
    let dbName;

    ObservableMixin(this);

    function getTable(tableName) {
        let table = volatileMemory[tableName];
        if (!table) {
            table = volatileMemory[tableName] = {};
        }
        return table;
    }

    /*
       Get the whole content of the table and asynchronously returns an array with all the  records satisfying the condition tested by the filterFunction
    */
    this.filterTable = function (tableName, filterFunction, callback) {
        let tbl = getTable(tableName);
        let result = [];
        for (let n in tbl) {
            let item = tbl[n];
            if (filterFunction(item)) {
                item.__key = n;
                result.push(item);
            }
        }
        callback(undefined, result);
    };

    this.filter = function (tableName, conditionsArray, sort, limit, callback) {
        if (typeof conditionsArray === "function") {
            callback = conditionsArray;
            conditionsArray = undefined;
            sort = undefined;
            limit = undefined;
        }

        if (typeof conditionsArray === "undefined") {
            conditionsArray = "__timestamp > 0";
        }

        if (typeof conditionsArray === "string") {
            conditionsArray = [conditionsArray];
        } else if (!Array.isArray(conditionsArray)) {
            return callback(Error(`Condition argument of filter function need to be string or array of strings`));
        }

        if (typeof sort === "function") {
            callback = sort;
            sort = undefined;
            limit = undefined;
        }

        if (typeof limit === "function") {
            callback = limit;
            limit = undefined;
        }

        if (typeof limit === "undefined") {
            limit = Infinity;
        }

        if (typeof sort === "undefined") {
            sort = "asc";
        }

        const tbl = getTable(tableName);
        const records = Object.values(tbl);
        const filteredRecords = [];
        let Query = require("./Query");
        let query = new Query(conditionsArray);
        const conditions = query.getConditions();
        records.forEach(record => {
            let shouldBeAdded = true;
            for (let i = 0; i < conditions.length; i++) {
                if (!operators[conditions[i][1]](record[conditions[i][0]], conditions[i][2])) {
                    shouldBeAdded = false;
                }
            }
            if (shouldBeAdded && filteredRecords.length < limit) {
                filteredRecords.push(record);
            }
        })
        query.sortValues(filteredRecords, sort);
        callback(undefined, filteredRecords);
    }

    this.getAllRecords = (tableName, callback) => {
        const table = getTable(tableName);
        callback(undefined, Object.values(table));
    }
    /*
      Insert a record, return error if already exists
    */
    this.insertRecord = function (tableName, key, record, callback, reInsert = false) {
        let currentParent = getTable(tableName)

        function _insertRecord(currentParent, currentKey) {
            if (!reInsert && currentParent[currentKey] != undefined) {
                return callback(new Error("Can't insert a new record for currentKey " + currentKey))
            }

            currentParent[currentKey] = record;
            callback(undefined, record);
        }

        if (typeof key === 'string') {
            _insertRecord(currentParent, key)
        } else {
            let currentKey = key[0];
            for (let i = 1; i <= key.length; i++) {
                if (currentParent[currentKey] == undefined) {
                    currentParent[currentKey] = i === key.length ? undefined : {}
                }

                if (i === key.length) {
                    break
                } else {
                    currentParent = currentParent[currentKey]
                    currentKey = key[i];
                }
            }

            _insertRecord(currentParent, currentKey)
        }
    };

    /*
        Update a record, return error if does not exists
     */
    this.updateRecord = function (tableName, key, record, currentRecord, callback) {
        function _updateRecord(record, previousRecord, callback) {
            if (!previousRecord) {
                return callback(new Error("Can't update a record for key " + key))
            }

            record.__previousRecord = previousRecord;
            self.insertRecord(tableName, key, record, callback, true);
        }

        if (typeof currentRecord === 'function') {
            callback = currentRecord

            this.getRecord(tableName, key, (err, previousRecord) => {
                if (err) {
                    return callback(err)
                }
                _updateRecord(record, previousRecord, callback)
            })
        } else {
            _updateRecord(record, currentRecord, callback)
        }
    };

    /*
        Get a single row from a table
     */
    this.getRecord = function (tableName, key, callback) {
        let tbl = getTable(tableName);
        let record;
        if (typeof key === 'string') {
            record = tbl[key];
            if (record == undefined) {
                return callback(new Error("Can't retrieve a record for key " + key))
            }
            callback(undefined, record);
        } else {
            record = tbl[key[0]]
            for (let i = 1; i <= key.length; i++) {
                if (record == undefined) {
                    return callback(new Error("Can't retrieve a record for key " + key.concat(".")))
                }

                if (i === key.length) {
                    break
                } else {
                    record = record[key[i]];
                }
            }

            callback(undefined, record);
        }
    };

    this.beginBatch = () => {

    }

    this.commitBatch = (callback) => {
        callback(undefined);
    }

    this.cancelBatch = (callback) => {
        callback(undefined);
    }

    const READ_WRITE_KEY_TABLE = "KeyValueTable";
    this.writeKey = (key, value, callback) => {
        let valueObject = {
            type: typeof value,
            value: value
        };

        if (typeof value === "object") {
            if (Buffer.isBuffer(value)) {
                valueObject = {
                    type: "buffer",
                    value: value.toString()
                }
            } else {
                valueObject = {
                    type: "object",
                    value: JSON.stringify(value)
                }
            }
        }

        this.getRecord(READ_WRITE_KEY_TABLE, key, (err, existingValue) => {
            if (err || !existingValue) {
                this.insertRecord(READ_WRITE_KEY_TABLE, key, valueObject, callback);
            } else {
                this.updateRecord(READ_WRITE_KEY_TABLE, key, valueObject, existingValue, callback);
            }
        })
    };

    this.readKey = (key, callback) => {
        this.getRecord(READ_WRITE_KEY_TABLE, key, (err, record) => {
            if (err) {
                return callback(createOpenDSUErrorWrapper(`Failed to read key ${key}`, err));
            }

            let value;
            switch (record.type) {
                case "buffer":
                    value = Buffer.from(record.value);
                    break;
                case "object":
                    value = JSON.parse(record.value);
                    break;
                default:
                    value = record.value;
            }

            callback(undefined, value);
        });
    }

    setTimeout(() => {
        this.dispatchEvent("initialised");
    })
}

module.exports = MemoryStorageStrategy;
}).call(this)}).call(this,require("buffer").Buffer)

},{"../../utils/ObservableMixin":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/utils/ObservableMixin.js","./Query":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/db/storageStrategies/Query.js","./operators":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/db/storageStrategies/operators.js","buffer":false}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/db/storageStrategies/Query.js":[function(require,module,exports){
function Query(queryArray) {
    let conditions = [];
    const operators = require("./operators");
    const {getCompareFunction} = require("./utils");

    function queryParser(query) {
        query.forEach(fieldQuery => {
            const splitQuery = fieldQuery.split(" ");
            if (splitQuery.length < 3) {
                throw Error(`Invalid query format. A query's format is <field> <operator> <value>`);
            }
            const operatorKeys = Object.keys(operators);
            const operatorIndex = splitQuery.findIndex(operator => {
                return operatorKeys.findIndex(el => el === operator) !== -1;
            });

            if (operatorIndex === -1) {
                throw Error(`The provided query does not contain a valid operator.`);
            }

            const field = splitQuery.slice(0, operatorIndex).join(" ");
            const operator = splitQuery[operatorIndex];
            const value = splitQuery.slice(operatorIndex + 1).join(" ");

            conditions.push([field, operator, value]);
        });

    }

    this.filterValuesForIndex = (valueArray) => {
        let conds = conditions.filter(cond => cond[0] === this.getIndexName());
        return valueArray.filter(val => {
            for (let i = 0; i < conds.length; i++) {
                if (!operators[conds[i][1]](val, conds[i][2])) {
                    return false;
                }
            }

            return true;
        });
    }

    this.filter = (sortedValues, getNextRecordForValue, limit, callback) => {
        let conds = conditions.filter(cond => cond[0] !== this.getIndexName());
        let filteredRecords = [];

        function getNextRecord(currentIndex) {
            if (currentIndex === sortedValues.length) {
                return callback(undefined, filteredRecords);
            }
            getNextRecordForValue(sortedValues[currentIndex], (err, record) => {
                if (record === null || err) {
                    if(err){
                        console.log("We caught an error during record retrieval and we are skipping to the next from the list.", err);
                    }
                    getNextRecord(currentIndex + 1);
                } else {
                    processRecord(record);
                    if (currentIndex === sortedValues.length || filteredRecords.length === limit) {
                        return callback(undefined, filteredRecords);
                    }
                    getNextRecord(currentIndex);
                }
            });
        }

        function processRecord(record) {
            for (let i = 0; i < conds.length; i++) {
                if (!operators[conds[i][1]](record[conds[i][0]], conds[i][2])) {
                    return;
                }
            }
            if (record && !record.__deleted) {
                filteredRecords.push(record);
            }
        }

        getNextRecord(0);
    };

    this.sortValues = (values, sortType) => {
        let compareFn;
        try {
            compareFn = getCompareFunction(sortType);
        } catch (e) {
            throw createOpenDSUErrorWrapper(`Failed to get compare function`, e);
        }

        values.sort(compareFn);
    };

    this.getIndexName = () => {
        return conditions[0][0];
    };

    this.getConditions = () => {
        return conditions;
    }

    queryParser(queryArray);
}

module.exports = Query;
},{"./operators":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/db/storageStrategies/operators.js","./utils":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/db/storageStrategies/utils.js"}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/db/storageStrategies/SingleDSUStorageStrategy.js":[function(require,module,exports){
(function (Buffer){(function (){
const ObservableMixin = require("../../utils/ObservableMixin");
const Query = require("./Query");
const operators = require("./operators");

function SingleDSUStorageStrategy() {
    let volatileMemory = {}
    let self = this
    let storageDSU;
    let shareableSSI;
    let dbName;

    ObservableMixin(this);

    this.initialise = function (_storageDSU, _dbName) {
        storageDSU = _storageDSU;
        dbName = _dbName;
        this.dispatchEvent("initialised");
    }

    this.refresh = (callback) => {
        storageDSU.refresh(callback);
    }

    this.beginBatch = () => {
        storageDSU.beginBatch();
    }

    this.cancelBatch = (callback) => {
        storageDSU.cancelBatch(callback);
    }

    this.commitBatch = (callback) => {
        storageDSU.commitBatch(callback);
    }

    this.getAllRecords = (tableName, callback) => {
        readTheWholeTable(tableName, (err, tbl) => {
            if (err) {
                return callback(err);
            }

            return callback(undefined, Object.values(tbl));
        })
    }

    function readTheWholeTable(tableName, callback) {
        getPrimaryKeys(tableName, (err, recordKeys) => {
            if (err) {
                return callback(createOpenDSUErrorWrapper(`Failed to read the records in table ${tableName}`, err));
            }
            const table = {};
            if (recordKeys.length === 0) {
                return callback(undefined, table);
            }

            const TaskCounter = require("swarmutils").TaskCounter;
            const tc = new TaskCounter(() => {
                return callback(undefined, table);
            });
            tc.increment(recordKeys.length);
            recordKeys.forEach(recordKey => {
                self.getRecord(tableName, recordKey, (err, record) => {
                    if (err) {
                        return callback(createOpenDSUErrorWrapper(`Failed to get record ${recordKey} in table ${tableName}`, err));
                    }

                    table[recordKey] = record;
                    tc.decrement();
                });
            })
        });
    }


    /*
       Get the whole content of the table and asynchronously returns an array with all the  records satisfying the condition tested by the filterFunction
    */
    const filterTable = function (tableName, conditionsArray, sort, limit, callback) {
        readTheWholeTable(tableName, (err, tbl) => {
            if (err) {
                return callback(createOpenDSUErrorWrapper(`Failed to read table ${tableName}`, err));
            }

            const operators = require("./operators");
            const filteredRecords = [];
            const records = Object.values(tbl);
            for (let i = 0; i < records.length; i++) {
                const record = records[i];
                if (record.__deleted) {
                    continue;
                }
                let recordIsValid = true;
                for (let i = 0; i < conditionsArray.length; i++) {
                    const condition = conditionsArray[i];
                    const [field, operator, value] = condition.split(" ");
                    if (!operators[operator](record[field], value)) {
                        recordIsValid = false;
                        break;
                    }
                }

                if (recordIsValid) {
                    filteredRecords.push(record);
                }
            }
            // Object.values(tbl).forEach(record => {
            //     let recordIsValid = true;
            //     for (let i = 0; i < conditionsArray.length; i++) {
            //         const condition = conditionsArray[i];
            //         const [field, operator, value] = condition.split(" ");
            //         if (!operators[operator](record[field], value) || record.__deleted) {
            //             recordIsValid = false;
            //             break;
            //         }
            //     }
            //
            //     if (recordIsValid) {
            //         filteredRecords.push(record);
            //     }
            // })
            const {getCompareFunctionForObjects} = require("./utils");
            filteredRecords.sort(getCompareFunctionForObjects(sort, conditionsArray[0].split(" ")[0]))
            callback(undefined, filteredRecords.slice(0, limit));
        });
    };

    function checkFieldIsIndexed(tableName, fieldName, callback) {
        const path = getIndexPath(tableName, fieldName);
        storageDSU.stat(path, (err, stat) => {
            if (err || typeof stat.type === "undefined") {
                return callback(undefined, false);
            }
            callback(undefined, true);
        });
    }

    this.filter = function (tableName, conditionsArray, sort, limit, callback) {
        if (typeof conditionsArray === "function") {
            callback = conditionsArray;
            conditionsArray = undefined;
            sort = undefined;
            limit = undefined;
        }

        if (typeof conditionsArray === "undefined") {
            conditionsArray = "__timestamp > 0";
        }

        if (typeof conditionsArray === "string") {
            conditionsArray = [conditionsArray];
        } else if (!Array.isArray(conditionsArray)) {
            return callback(Error(`Condition argument of filter function need to be string or array of strings`));
        }
        let Query = require("./Query");
        let query = new Query(conditionsArray);

        if (typeof sort === "function") {
            callback = sort;
            sort = undefined;
            limit = undefined;
        }

        if (typeof limit === "function") {
            callback = limit;
            limit = undefined;
        }

        if (typeof limit === "undefined") {
            limit = Infinity;
        }

        if (typeof sort === "undefined") {
            sort = "asc";
        }

        const indexName = query.getIndexName();

        checkFieldIsIndexed(tableName, indexName, (err, status) => {
            if (err) {
                return callback(createOpenDSUErrorWrapper(`Failed to add index for fields ${indexName} in table ${tableName}`, err));
            }

            const __filterIndexedTable = () => {
                storageDSU.listFiles(getIndexPath(tableName, indexName), (err, values) => {
                    if (err) {
                        return callback(createOpenDSUErrorWrapper(`Failed read values for field ${indexName}`, err));
                    }

                    const pks = [];
                    const uniqueIndexedValues = [];
                    values.forEach(value => {
                        const splitValue = value.split("/");
                        if (pks.indexOf(splitValue[1]) === -1) {
                            pks.push(splitValue[1]);
                            uniqueIndexedValues.push(splitValue[0]);
                        } else {
                            console.warn(`Record with pk ${splitValue[1]} already indexed on field ${indexName}`);
                        }
                    })

                    let filteredValues = query.filterValuesForIndex(uniqueIndexedValues);
                    query.sortValues(filteredValues, sort);
                    const getNextRecordForValue = getNextRecordFunction(tableName, indexName)
                    query.filter(filteredValues, getNextRecordForValue, limit, callback);
                });
            }


            if (status) {
                return __filterIndexedTable();
            }

            console.log(`Warning - You tried filtering the table <${tableName}> on field <${conditionsArray[0].split(' ')[0]}> which is not indexed. This operation can be slow. Try calling addIndex on field <${conditionsArray[0].split(' ')[0]}> first.`);
            filterTable(tableName, conditionsArray, sort, limit, callback);
        });
    }


    function getNextRecordFunction(tableName, fieldName) {
        let currentValue;
        let pksArray;
        let currentPosition;

        function getNext(callback) {
            if (currentPosition >= pksArray.length) {
                return callback(undefined, null);
            }

            self.getRecord(tableName, pksArray[currentPosition++], callback);
        }

        return function (value, callback) {
            if (value !== currentValue) {
                storageDSU.listFiles(getIndexPath(tableName, fieldName, value), (err, pks) => {
                    if (err) {
                        return callback(createOpenDSUErrorWrapper(`No primary key found for value ${value}`, err));
                    }

                    pksArray = pks;
                    currentPosition = 0;
                    currentValue = value

                    getNext(callback);
                });
            } else {
                getNext(callback);
            }
        }

    }

    this.addIndex = function (tableName, fieldName, forceReindex, callback) {
        if (typeof forceReindex === "function") {
            callback = forceReindex;
            forceReindex = false;
        }

        if (typeof forceReindex === "undefined") {
            forceReindex = false;
        }

        if (forceReindex === false) {
            checkFieldIsIndexed(tableName, fieldName, (err, status) => {
                if (err) {
                    return callback(createOpenDSUErrorWrapper(`Failed to check if field ${fieldName} in table ${tableName} is indexed`, err));
                }

                if (status === true) {
                    return callback();
                }

                createIndex(tableName, fieldName, callback);
            });
        } else {
            createIndex(tableName, fieldName, callback);
        }
    }

    this.getIndexedFields = function (tableName, callback) {
        getIndexedFieldsList(tableName, callback);
    };

    function createIndex(tableName, fieldName, callback) {
        getPrimaryKeys(tableName, (err, primaryKeys) => {
            if (err) {
                return callback(createOpenDSUErrorWrapper(`Failed to get primary keys for table ${tableName}`, err));
            }

            const TaskCounter = require("swarmutils").TaskCounter;
            let batchInProgress = false;
            if (storageDSU.batchInProgress()) {
                batchInProgress = true
            } else {
                storageDSU.beginBatch();
            }
            const taskCounter = new TaskCounter(() => {
                if (batchInProgress) {
                    return callback();
                }
                storageDSU.commitBatch(callback);
            })

            if (primaryKeys.length === 0) {
                return storageDSU.createFolder(getIndexPath(tableName, fieldName), (err) => {
                    if (err) {
                        return callback(createOpenDSUErrorWrapper(`Failed to create empty index for field ${fieldName} in table ${tableName}`, err));
                    }

                    if (batchInProgress) {
                        return callback();
                    }
                    storageDSU.commitBatch(callback);
                });
            }

            taskCounter.increment(primaryKeys.length);
            primaryKeys.forEach(pk => {
                self.getRecord(tableName, pk, (err, record) => {
                    if (err) {
                        return callback(createOpenDSUErrorWrapper(`Failed to get record ${pk} from table ${tableName}`));
                    }

                    storageDSU.writeFile(getIndexPath(tableName, fieldName, record[fieldName], pk), undefined, (err) => {
                        if (err) {
                            return callback(createOpenDSUErrorWrapper(`Failed to create index for field ${fieldName} in table ${tableName}`, err));
                        }

                        taskCounter.decrement();
                    });
                });
            })

        });
    }

    function createIndexEntry(tableName, fieldName, pk, value, callback) {
        storageDSU.writeFile(getIndexPath(tableName, fieldName, value, pk), (err) => {
            let retErr = undefined;
            if (err) {
                retErr = createOpenDSUErrorWrapper(`Failed to create file ${getIndexPath(tableName, fieldName, value, pk)}`, err);
            }

            callback(retErr)
        });
    }

    function updateIndexesForRecord(tableName, pk, record, callback) {
        if (record.__deleted) {
            //deleted records don't need to be into indexes
            return callback();
        }
        const fields = Object.keys(record);
        getIndexedFieldsList(tableName, (err, indexedFields) => {
            if (err) {
                return callback(createOpenDSUErrorWrapper(`Failed to get indexed fields list for table ${tableName}`, err));
            }

            if (indexedFields.length === 0) {
                return callback();
            }

            const TaskCounter = require("swarmutils").TaskCounter;
            const taskCounter = new TaskCounter(() => {
                return callback();
            })

            taskCounter.increment(fields.length);
            fields.forEach(field => {
                if (indexedFields.findIndex(indexedField => indexedField === field) !== -1) {
                    createIndexEntry(tableName, field, pk, record[field], (err) => {
                        if (err) {
                            return callback(createOpenDSUErrorWrapper(`Failed to update index for field ${field} in table ${tableName}`, err));
                        }

                        taskCounter.decrement();
                    });
                } else {
                    taskCounter.decrement();
                }
            })
        });
    }

    // pk and value can be undefined and you get only the path to index of fieldName
    function getIndexPath(tableName, fieldName, value, pk) {
        let path = `/${dbName}/${tableName}/indexes/${fieldName}`;
        if (typeof value !== "undefined") {
            path = `${path}/${value}`;
        }

        if (typeof pk !== "undefined") {
            path = `${path}/${pk}`;
        }
        return path;
    }

    function getRecordPath(tableName, pk) {
        return `/${dbName}/${tableName}/records/${pk}`;
    }

    function deleteIndex(tableName, fieldName, pk, value, callback) {
        storageDSU.delete(getIndexPath(tableName, fieldName, value, pk), () => {
            //TODO handle error type
            //ignoring error on purpose
            callback(undefined);
        });
    }

    function deleteIndexesForRecord(tableName, pk, record, callback) {
        const fields = Object.keys(record);
        getIndexedFieldsList(tableName, (err, indexedFields) => {
            if (err) {
                return callback(createOpenDSUErrorWrapper(`Failed to get indexed fields list for table ${tableName}`, err));
            }

            if (indexedFields.length === 0) {
                return callback();
            }

            const TaskCounter = require("swarmutils").TaskCounter;
            const taskCounter = new TaskCounter(() => {
                return callback();
            })

            taskCounter.increment(fields.length);
            fields.forEach(field => {
                if (indexedFields.findIndex(indexedField => indexedField === field) !== -1) {
                    deleteIndex(tableName, field, pk, record[field], (err) => {
                        if (err) {
                            return callback(createOpenDSUErrorWrapper(`Failed to delete index for field ${field} in table ${tableName}`, err));
                        }

                        taskCounter.decrement();
                    });
                } else {
                    taskCounter.decrement();
                }
            })

            function deleteIndexesRecursively(index) {
                const field = fields[index];
                if (typeof field === "undefined") {
                    return callback();
                }
                if (indexedFields.findIndex(indexedField => indexedField === field) !== -1) {
                    deleteIndex(tableName, field, pk, record[field], (err) => {
                        if (err) {
                            return callback(createOpenDSUErrorWrapper(`Failed to delete index for field ${field} in table ${tableName}`, err));
                        }

                        deleteIndexesRecursively(index + 1);
                    });
                } else {
                    deleteIndexesRecursively(index + 1);
                }
            }
        });
    }

    function getIndexedFieldsList(tableName, callback) {
        const indexesFilePath = `/${dbName}/${tableName}/indexes`;
        storageDSU.listFolders(indexesFilePath, (err, indexes) => {
            if (err) {
                return callback(undefined, []);
            }

            callback(undefined, indexes);
        });
    }

    /*
      Insert a record
    */
    this.insertRecord = function (tableName, key, record, callback) {
        this.updateRecord(tableName, key, record, undefined, callback);
    };

    function getPrimaryKeys(tableName, callback) {
        storageDSU.listFiles(`/${dbName}/${tableName}/records`, (err, primaryKeys) => {
            if (err) {
                return storageDSU.createFolder(`/${dbName}/${tableName}/records`, (err) => {
                    if (err) {
                        return callback(createOpenDSUErrorWrapper(`Failed to retrieve primary keys list in table ${tableName}`, err));
                    }
                    callback(undefined, []);
                });
            }

            callback(undefined, primaryKeys);
        });
    }

    /*
        Update a record
     */
    this.updateRecord = function (tableName, key, record, currentRecord, callback) {
        if (typeof record !== "object") {
            return callback(Error(`Invalid record type. Expected "object"`))
        }

        if (Buffer.isBuffer(record)) {
            return callback(Error(`"Buffer" is not a valid record type. Expected "object".`))
        }

        if (Array.isArray(record)) {
            this.writeKey(key, value, callback);
            return callback(Error(`"Array" is not a valid record type. Expected "object".`))
        }

        const recordPath = getRecordPath(tableName, key);
        let batchInProgress = false;
        if (storageDSU.batchInProgress()) {
            batchInProgress = true
        } else {
            storageDSU.beginBatch();
        }
        storageDSU.writeFile(recordPath, JSON.stringify(record), function (err, res) {
            if (err) {
                return callback(createOpenDSUErrorWrapper(`Failed to update record in ${recordPath}`, err));
            }

            if (typeof currentRecord !== "undefined") {
                return deleteIndexesForRecord(tableName, key, currentRecord, (err) => {
                    if (err) {
                        return callback(createOpenDSUErrorWrapper(`Failed to delete index files for record ${JSON.stringify(currentRecord)}`, err));
                    }

                    return updateIndexesForRecord(tableName, key, record, (err) => {
                        if (err) {
                            return callback(createOpenDSUErrorWrapper(`Failed to update indexes for record ${record}`, err));
                        }

                        if (batchInProgress) {
                            return callback(undefined, record);
                        }
                        storageDSU.commitBatch(err => callback(err, record));
                    });
                });
            }

            updateIndexesForRecord(tableName, key, record, (err) => {
                if (err) {
                    return callback(createOpenDSUErrorWrapper(`Failed to update indexes for record ${record}`, err));
                }

                if (batchInProgress) {
                    return callback(undefined, record);
                }
                storageDSU.commitBatch(err => callback(err, record));
            });
        });
    };

    /*
        Get a single row from a table
     */
    this.getRecord = function (tableName, key, callback) {
        const recordPath = getRecordPath(tableName, key);
        storageDSU.readFile(recordPath, function (err, res) {
            let record;
            let retErr = undefined;
            if (err) {
                retErr = createOpenDSUErrorWrapper(`Failed to read record in ${recordPath}`, err);
            } else {
                try {
                    record = JSON.parse(res);
                } catch (newErr) {
                    retErr = createOpenDSUErrorWrapper(`Failed to parse record in ${recordPath}: ${res}`, retErr);
                    //let's try to check if the res contains the record twice... at some point there was a bug on this topic
                    let serializedRecord = res;
                    if (ArrayBuffer.isView(serializedRecord) || serializedRecord.buffer) {
                        serializedRecord = new TextDecoder().decode(serializedRecord);
                    }
                    let halfOfRes = serializedRecord.slice(0, serializedRecord.length / 2);
                    let isDuplicated = (serializedRecord === halfOfRes + halfOfRes);
                    if (isDuplicated) {
                        try {
                            record = JSON.parse(halfOfRes);
                            console.log("We caught an error during record retrieval process and fix it. (duplicate content)");
                            //we ignore the original error because we were able to fix it.
                            retErr = undefined;
                        } catch (err) {
                            console.log("We caught an error during record retrieval process and we failed to fix it!");
                        }
                    } else {
                        console.log(retErr);
                    }
                }
            }
            callback(retErr, record);
        });
    };

    const READ_WRITE_KEY_TABLE = "KeyValueTable";
    this.writeKey = function (key, value, callback) {
        let batchInProgress = false;
        if (storageDSU.batchInProgress()) {
            batchInProgress = true
        } else {
            storageDSU.beginBatch();
        }
        let valueObject = {
            type: typeof value,
            value: value
        };

        if (typeof value === "object") {
            if (Buffer.isBuffer(value)) {
                valueObject = {
                    type: "buffer",
                    value: value.toString()
                }
            } else {
                valueObject = {
                    type: "object",
                    value: JSON.stringify(value)
                }
            }
        }

        const recordPath = getRecordPath(READ_WRITE_KEY_TABLE, key);
        storageDSU.writeFile(recordPath, JSON.stringify(valueObject), err => {
            if (err) {
                return callback(err);
            }
            if (batchInProgress) {
                return callback(undefined);
            }
            storageDSU.commitBatch(callback);
        });
    };

    this.readKey = function (key, callback) {
        this.getRecord(READ_WRITE_KEY_TABLE, key, (err, record) => {
            if (err) {
                return callback(createOpenDSUErrorWrapper(`Failed to read key ${key}`, err));
            }

            let value;
            switch (record.type) {
                case "buffer":
                    value = Buffer.from(record.value);
                    break;
                case "object":
                    value = JSON.parse(record.value);
                    break;
                default:
                    value = record.value;
            }

            callback(undefined, value);
        });
    }
}

module.exports.SingleDSUStorageStrategy = SingleDSUStorageStrategy;
}).call(this)}).call(this,require("buffer").Buffer)

},{"../../utils/ObservableMixin":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/utils/ObservableMixin.js","./Query":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/db/storageStrategies/Query.js","./operators":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/db/storageStrategies/operators.js","./utils":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/db/storageStrategies/utils.js","buffer":false,"swarmutils":"swarmutils"}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/db/storageStrategies/operators.js":[function(require,module,exports){
module.exports = {
    "<": function (x, y) {
        return x < y
    },
    "<=": function (x, y) {
        return x <= y
    },
    ">": function (x, y) {
        return x > y
    },
    ">=": function (x, y) {
        return x >= y
    },
    "==": function (x, y) {
        return x == y
    },
    "!=": function (x, y) {
        if (y === "undefined") {
            y = undefined;
        }
        return x != y;
    },
    "like": function (str, regex) {
        if (typeof regex === "string") {
            let splitRegex = regex.split("/");
            if (splitRegex[0] === '') {
                splitRegex = splitRegex.slice(1);
            }
            let flag = undefined;
            if (splitRegex.length > 1) {
                flag = splitRegex.pop();
            }
            if (flag === '') {
                flag = undefined;
            }
            regex = new RegExp(splitRegex.join('/'), flag);
        }
        // return regex.test(str);
        return str.match(regex);
    }
};

},{}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/db/storageStrategies/utils.js":[function(require,module,exports){
function getCompareFunction(sortOrder) {
    if (sortOrder === "asc" || sortOrder === "ascending") {
        return function (a, b) {
            if (a < b) {
                return -1;
            }

            if (a === b) {
                return 0
            }

            if (a > b) {
                return 1;
            }
        }
    } else if (sortOrder === "dsc" || sortOrder === "descending") {
        return function (a, b) {
            if (a > b) {
                return -1;
            }

            if (a === b) {
                return 0
            }

            if (a < b) {
                return 1;
            }
        }
    } else {
        throw Error(`Invalid sort order provided <${sortOrder}>`);
    }
}

function getCompareFunctionForObjects(sortOrder, fieldName) {
    return function (firstObj, secondObj) {
        const compareFn = getCompareFunction(sortOrder);
        return compareFn(firstObj[fieldName], secondObj[fieldName]);
    }
}
module.exports = {
    getCompareFunction,
    getCompareFunctionForObjects
}
},{}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/dc/index.js":[function(require,module,exports){
/*
html API space
*/
},{}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/dt/AppBuilderService.js":[function(require,module,exports){
/**
 * @module dt
 */

/**
 *
 */
const FileService = require("./FileService");

const DSU_SPECIFIC_FILES = ["dsu-metadata.log", "manifest"]
const {_getResolver, _getKeySSISpace} = require('./commands/utils');

/**
 * Default Options set for the {@link AppBuilderService}
 * <pre>
 *     {
            anchoring: "default",
            publicSecretsKey: '-$Identity-',
            environmentKey: "-$Environment-",
            basePath: "",
            stripBasePathOnInstall: false,
            walletPath: "",
            hosts: "",
            hint: undefined,
            vault: "vault",
            seedFileName: "seed",
            appsFolderName: "apps",
            appFolderName: "app",
            codeFolderName: "code",
            initFile: "init.file",
            environment: {},
            slots:{
                primary: "wallet-patch",
                secondary: "apps-patch"
            }
        }
 * </pre>
 */
const OPTIONS = {
    anchoring: process.env.VAULT_DOMAIN || "vault",
    publicSecretsKey: '-$Identity-',
    environmentKey: "-$Environment-",
    basePath: "",
    stripBasePathOnInstall: false,
    walletPath: "",
    hosts: "",
    hint: undefined,
    vault: "vault",
    seedFileName: "seed",
    appsFolderName: "apps",
    appFolderName: "app",
    codeFolderName: "code",
    initFile: "init.file",
    environment: {},
    slots:{
        primary: "wallet-patch",
        secondary: "apps-patch"
    }
}

/**
 * Convert the Environment object into the Options object
 */
const envToOptions = function(env, opts){
    let options = Object.assign({}, OPTIONS, opts);
    options.environment = env;
    options.vault = env.vault;
    options.anchoring = env.domain;
    options.basePath = env.basePath;
    options.walletPath = env.basePath.split('/').reduce((sum, s) => sum === '' && s !== '/' ? s : sum, '');
    const opendsu = require('opendsu');
    options.hosts = $$.environmentType === 'browser'
        ? `${opendsu.loadApi('system').getEnvironmentVariable(opendsu.constants.BDNS_ROOT_HOSTS)}`
        : `localhost:8080`;
    return options;
}

/**
 *
 * @param {object} environment typically comes from an environment.js file is the ssapps. Overrides some options
 * @param {object} [opts] options object mimicking {@link OPTIONS}
 */
function AppBuilderService(environment, opts) {
    const options = envToOptions(environment, opts);
    const dossierBuilder = new (require("./DossierBuilder"))();

    const fileService = new FileService(options);

    /**
     * Lists a DSUs content
     * @param {KeySSI} keySSI
     * @param {function(err, files, mounts)} callback
     * @private
     */
    const getDSUContent = function (keySSI, callback) {
        _getResolver().loadDSU(keySSI, (err, dsu) => {
            if (err)
                return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Could not load DSU with SSI ${keySSI}`, err));
            dsu.listFiles("/", {ignoreMounts: true}, (err, files) => {
                if (err)
                    return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Could not retrieve DSU content`, err));
                dsu.listMountedDSUs("/", (err, mounts) => {
                    if (err)
                        return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Could not retrieve DSU mounts`, err));
                    callback(undefined, files.filter(f => {
                        return DSU_SPECIFIC_FILES.indexOf(f) === -1;
                    }), mounts, dsu);
                });
            });
        });
    }

    /**
     * Creates an Arrays SSI off a secret list
     *
     * Adds options.hint to hit if available
     * @param {string[]} secrets
     * @param {function(err, ArraySSI)} callback
     * @private
     */
    const createArraySSI = function(secrets, callback){
        const key = _getKeySSISpace().createArraySSI(options.anchoring, secrets, 'v0', options.hint ? JSON.stringify(options.hint) : undefined);
        callback(undefined, key);
    }

    /**
     * Creates a Wallet SSI off a secret list
     *
     * Adds options.hint to hit if available
     * @param {string[]} secrets
     * @param {function(err, ArraySSI)} callback
     */
    const createWalletSSI = function(secrets, callback){
        const key = _getKeySSISpace().createTemplateWalletSSI(options.anchoring, secrets, 'v0', options.hint ? JSON.stringify(options.hint) : undefined);
        callback(undefined, key);
    }

    /**
     * Creates an Arrays SSI off a secret list
     *
     * Adds options.hint to hit if available
     * @param {string} specificString
     * @param {function(err, TemplateSeedSSI)} callback
     */
    const createSSI = function(specificString, callback){
        const key = _getKeySSISpace().createTemplateSeedSSI(options.anchoring, specificString, undefined, 'v0', options.hint ? JSON.stringify(options.hint) : undefined);
        callback(undefined, key);
    }

    /**
     * Creates a DSU of an ArraySSI
     * @param {string[]} secrets
     * @param {object} opts DSU Creation Options
     * @param {function(err, Archive)} callback
     */
    const createWalletDSU = function(secrets, opts, callback){
        createWalletSSI(secrets, (err, keySSI) => {
            _getResolver().createDSUForExistingSSI(keySSI, opts, (err, dsu) => {
                if (err)
                    return callback(`Could not create const DSU ${err}`);
                callback(undefined, dsu);
            });
        });
    }

    /**
     * Creates a DSU of an ArraySSI
     * @param {string} specific String for Seed SSI
     * @param {object} opts DSU Creation Options
     * @param {function(err, Archive)} callback
     */
    const createDSU = function(specific, opts, callback){
        createSSI(specific, (err, keySSI) => {
            _getResolver().createDSU(keySSI, opts, (err, dsu) => {
                if (err)
                    return callback(`Could not create const DSU ${err}`);
                callback(undefined, dsu);
            });
        });
    }

    /**
     * Creates a DSU of an ArraySSI
     * @param {string[]} secrets
     * @param {object} opts DSU Creation Options
     * @param {function(err, Archive)} callback
     */
    const createConstDSU = function(secrets,opts , callback){
        createArraySSI(secrets, (err, keySSI) => {
            _getResolver().createDSUForExistingSSI(keySSI, opts, (err, dsu) => {
                if (err)
                    return callback(`Could not create const DSU ${err}`);
                callback(undefined, dsu);
            });
        });
    }

    const getDSUFactory = function(isConst, isWallet){
        return isConst ? (isWallet ? createWalletDSU : createConstDSU) : createDSU;
    }

    /**
     * Creates a new DSU (Const or not) and clones the content another DSU into it
     * @param {object|string} arg can be a secrets object or a string depending on if it's a const DSU or not. A secrets object is like:
     * <pre>
     *     {
     *         secretName: {
     *             secret: "...",
     *             public: (defaults to false. If true will be made available to the created DSU for use of initialization Scripts)
     *         },
     *         (...)
     *     }
     * </pre>
     * @param {KeySSI} keyForDSUToClone
     * @param {boolean} [isConst] decides if the Created DSU is Const or not. defaults to true
     * @param {function(err, KeySSI)} callback
     */
    this.clone = function (arg, keyForDSUToClone, isConst, callback) {
        if (typeof isConst === 'function'){
            callback = isConst;
            isConst = true;
        }
        parseSecrets(true, arg, (err, keyGenArgs, publicSecrets) => {
            if (err)
                return callback(err);
            getDSUContent(keyForDSUToClone, (err, files, mounts, dsuToClone) => {
                if (err)
                    return callback(err);
                console.log(`Loaded Template DSU with key ${keyForDSUToClone}:\nmounts: ${mounts}`);
                getDSUFactory(isConst)(keyGenArgs, (err, destinationDSU) => {
                    if (err)
                        return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper( err));
                    doClone(dsuToClone, destinationDSU, files, mounts,  publicSecrets,(err, keySSI) => {
                        if (err)
                            return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper( err));
                        console.log(`DSU ${keySSI} as a clone of ${keyForDSUToClone} was created`);
                        // if (publicSecrets)
                        //     return writeToCfg(destinationDSU, publicSecrets, err => callback(err, keySSI));
                        callback(undefined, keySSI);
                    });
                });
            });
        });
    }

    const _getPatchContent = function(appName, callback){
        fileService.getFolderContentAsJSON(appName, (err, content) => {
           if (err)
               return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Could not retrieve patch content for ${appName}`, err));
           try {
               content = JSON.parse(content);
           } catch (e) {
               return callback(`Could not parse content`);
           }
            content['/'][options.seedFileName] = undefined;
            delete content['/'][options.seedFileName];

           callback(undefined, content);
        });
    }

    const filesToCommands = (content) => {
        let commands = [];
        for (let directory in content)
            if (content.hasOwnProperty(directory)){
                let directoryFiles = content[directory];
                for (let fileName in directoryFiles)
                    if (directoryFiles.hasOwnProperty(fileName))
                        commands.push(`createfile ${directory}/${fileName} ${directoryFiles[fileName]}`);
            }
        return commands;
    }

    /**
     * Copies the patch files from the path folder onto the DSU
     * @param {Archive} dsu
     * @param {string} slotPath should be '{@link OPTIONS.slots}[/appName]' when appName is required
     * @param {function(err, Archive, KeySSI)} callback
     */
    const patch = function(dsu, slotPath, callback) {
        // Copy any files found in the RESPECTIVE PATCH FOLDER on the local file system
        // into the app's folder
        _getPatchContent(slotPath, (err, files) => {
            if (err)
                return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper( err));
            let commands = filesToCommands(files);
            if (commands.length === 0){
                console.log(`Application ${slotPath} does not require patching`);
                return callback(undefined, dsu);
            }

            dossierBuilder.buildDossier(dsu, commands, (err, keySSI) => {
                if (err)
                    return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper( err));
                console.log(`Application ${slotPath} successfully patched`);
                callback(undefined, dsu, keySSI);
            });
        });
    }

    /**
     * When writing the env to an SSApp, because she'll run in an iFrame,
     * its basePath will always be '/' unlike the loader, we have the option to strip the base path id that's desirable
     * @param {object} env
     */
    const resetBasePath = function(env){
        if (!env.stripBasePathOnInstall)
            return env;
        return Object.assign({}, env, {basePath: '/'});
    }

    /**
     * Reads from {@link OPTIONS.initFile} and executes the commands founds there via {@link DossierBuilder#buildDossier}
     * @param {Archive} instance
     * @param {object} publicSecrets what elements of the registration elements should be passed onto the SSApp
     * @param {function(err, Archive)} callback
     */
    const initializeInstance = function(instance, publicSecrets, callback){
        instance.readFile(`${options.codeFolderName}/${options.initFile}`, (err, data) => {
            if (err) {
                console.log(`No init file found. Initialization complete`);
                return callback(undefined, instance);
            }

            // embed the environment and identity into in the initializations commands
            let commands = data.toString().replace(options.environmentKey, JSON.stringify(resetBasePath(options.environment)));
            commands = (publicSecrets
                    ? commands.replace(options.publicSecretsKey, JSON.stringify(publicSecrets))
                    : commands)
                .split(/\r?\n/).map(cmd => cmd.trim()).filter(cmd => !!cmd && !cmd.startsWith('##'));

            dossierBuilder.buildDossier(instance, commands, (err, keySSI) => {
                if (err)
                   return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Could not initialize SSApp instance`, err));
                console.log(`Instance successfully initialized: ${keySSI}`);
                callback(undefined, instance);
            });
        });
    }

    /**
     * Parser the secrets object according to if its a wallet or not
     * @param {boolean} isWallet
     * @param {object|string} secrets can be a secrets object or a string depending on if it's a wallet or not. A secrets object is like:
     * <pre>
     *     {
     *         secretName: {
     *             secret: "...",
     *             public: (defaults to false. If true will be made available to the created DSU for use of initialization Scripts)
     *         },
     *         (...)
     *     }
     * </pre>
     * @param {function(err, string|string[], publicSecrets)} callback
     */
    const parseSecrets = function(isWallet, secrets, callback){
        let specificArg = secrets;
        let publicSecrets = undefined;
        if (isWallet && typeof secrets === 'object'){
            specificArg = [];
            publicSecrets = {};
            Object.entries(secrets).forEach(e => {
                if (e[1].public)
                    publicSecrets[e[0]] = e[1].secret;
                specificArg.push(e[1].secret);
            });
        }
        callback(undefined, specificArg, publicSecrets);
    }

    this.parseSecrets = parseSecrets;

    /**
     * Builds an SSApp
     * @param {boolean} isWallet
     * @param {object|string} secrets according to {@link parseSecrets}
     * @param {string} seed
     * @param {string} [name]
     * @param {function(err, KeySSI, Archive)} callback
     */
    const buildApp = function(isWallet, secrets, seed, name, callback){
        if (typeof name === 'function'){
            if (!isWallet)
                return callback(`No SSApp name provided`);
            callback = name;
            name = undefined;
        }

        const patchAndInitialize = function(instance, publicSecrets, callback){
            const patchPath = isWallet ? `${options.slots.primary}` : `${options.slots.secondary}/${name}`;
            patch(instance, patchPath, (err) => {
                if (err)
                    return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Error patching SSApp ${name}`, err));
                initializeInstance(instance, publicSecrets, (err) => {
                    if (err)
                        return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper( err));
                    instance.getKeySSIAsString((err, keySSI) => {
                        if (err)
                            return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper( err));
                        callback(undefined, keySSI);
                    });
                });
            });
        }

        parseSecrets(isWallet, secrets, (err, keyArgs, publicSecrets) => {
            if (err)
                return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper( err));
            getDSUFactory(isWallet, isWallet)(keyArgs, isWallet ? {dsuTypeSSI: seed} : undefined, (err, wallet) => {
                if (err)
                    return callback(`Could not create instance`);

                const instance = isWallet ? wallet.getWritableDSU() : wallet;

                if (isWallet)
                    return patchAndInitialize(instance, publicSecrets, (err, key) => callback(err, key, wallet));

                instance.mount(`${options.codeFolderName}`, seed, (err) => {
                    if (err)
                        return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Could not mount Application code in instance`, err));
                    patchAndInitialize(instance, publicSecrets, (err, key) => callback(err, key, wallet));
                });
            });
        });
    }

    /**
     * Retrieves the list of Applications to be installed
     * @param {function(err, object)} callback
     */
    const getListOfAppsForInstallation = (callback) => {
        fileService.getFolderContentAsJSON(options.slots.secondary, function (err, data) {
            if (err){
                console.log(`No Apps found`)
                return callback(undefined, {});
            }

            let apps;

            try {
                apps = JSON.parse(data);
            } catch (e) {
                return callback(`Could not parse App list`);
            }

            callback(undefined, apps);
        });
    };

    /**
     * Installs all aps in the apps folder in the wallet
     * @param {Archive} wallet
     * @param {function(err, object)} callback returns the apps details
     */
    const installApps = function(wallet, callback){
        const performInstallation = function(wallet, apps, appList, callback){
            if (!appList.length)
                return callback();
            let appName = appList.pop();
            const appInfo = apps[appName];

            if (appName[0] === '/')
                appName = appName.replace('/', '');

            const mountApp = (newAppSeed) => {
                wallet.mount(`/${options.appsFolderName}/${appName}`, newAppSeed, (err) => {
                    if (err)
                        return callback("Failed to mount in folder" + `/apps/${appName}: ${err}`);

                    performInstallation(wallet, apps, appList, callback);
                });
            };

            // If new instance is not demanded just mount (leftover code from privatesky.. when is it not a new instance?)
            if (appInfo.newInstance === false)
                return mountApp(appInfo.seed);

            buildApp(false, undefined, appInfo.seed, appName, (err, keySSI) => {
                if (err)
                    return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to build app ${appName}`, err));
                mountApp(keySSI);
            });
        }

        getListOfAppsForInstallation((err, apps) => {
            if (err)
                return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper( err));
            apps = apps || {};
            let appList = Object.keys(apps).filter(n => n !== '/');
            if(!appList.length)
                return callback(undefined, appList);
            let tempList = [...appList]
            performInstallation(wallet, apps, tempList, (err) => {
                if (err)
                    return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Could not complete installations`, err));
                callback(undefined, appList);
            });
        });
    }

    /**
     * Builds a new SSApp from the provided secrets
     * @param {KeySSI} seed the SSApp's keySSI
     * @param {string} name the SSApp's name
     * @param {function(err, KeySSI, Archive)} callback
     */
    this.buildSSApp = function(seed, name, callback){
        return buildApp(false, seed, name, callback);
    }

    /**
     * Builds a new Wallet from the provided secrets
     * @param {object|string} secrets according to {@link parseSecrets}
     * @param {function(err, KeySSI, Archive)} callback
     */
    this.buildWallet = function(secrets, callback){
        fileService.getWalletSeed((err, seed) => {
            if (err)
                return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper("Could not retrieve template wallet SSI.", err));
            buildApp(true, secrets, seed, (err, keySSI, wallet) => {
                if (err)
                    return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Could not build wallet`, err));
                console.log(`Wallet built with SSI ${keySSI}`);
                installApps(wallet, (err, appList) => {
                    if (err)
                        return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Could not Install Applications ${JSON.stringify(appList)}`, err));
                    if (appList.length)
                        console.log(`Applications installed successfully`);
                    callback(undefined, keySSI, wallet);
                })
            });
        });
    }

    this.loadWallet = function(secrets, callback){
        parseSecrets(true, secrets, (err, keyGenArgs, publicSecrets) => {
            if (err)
                return callback(err);
            createWalletSSI(keyGenArgs, (err, keySSI) => {
                if (err)
                    return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Could not create wallet with ssi ${{keySSI}}`, err));
                console.log(`Loading wallet with ssi ${keySSI.getIdentifier()}`);
                _getResolver().loadDSU(keySSI, (err, wallet) => {
                    if (err)
                        return callback(`Could not load wallet DSU ${err}`);
                    wallet = wallet.getWritableDSU();
                    console.log(`wallet Loaded`);
                    wallet.getKeySSIAsString(callback);
                });
            });
        });
    }
}
module.exports = AppBuilderService;
},{"./DossierBuilder":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/dt/DossierBuilder.js","./FileService":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/dt/FileService.js","./commands/utils":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/dt/commands/utils.js","opendsu":"opendsu"}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/dt/BuildWallet.js":[function(require,module,exports){
const openDSU = require("opendsu");
const resolver = openDSU.loadAPI("resolver");
const keySSISpace = openDSU.loadAPI("keyssi");
const scAPI = openDSU.loadAPI("sc");
const enclaveAPI = openDSU.loadAPI("enclave");

function BuildWallet() {
    const secret = process.env.BUILD_SECRET_KEY || "nosecretfordevelopers";
    const vaultDomain = process.env.VAULT_DOMAIN || "vault";

    let writableDSU;

    const __ensureEnvIsInitialised = (writableDSU, callback) => {
        writableDSU.readFile("/environment.json", async (err, env) => {
            if (err) {
                try {
                    await $$.promisify(writableDSU.writeFile)("/environment.json", JSON.stringify({
                        vaultDomain: vaultDomain,
                        didDomain: vaultDomain
                    }))
                } catch (e) {
                    return callback(e);
                }
            }

            callback();
        });
    }

    this.initialise = (callback) => {
        const walletSSI = keySSISpace.createTemplateWalletSSI(vaultDomain, secret);
        resolver.loadDSU(walletSSI, async (err, wallet) => {
            if (err) {
                let seedSSI;
                try {
                    seedSSI = await $$.promisify(keySSISpace.createSeedSSI)(vaultDomain)
                } catch (e) {
                    return callback(e);
                }
                try {
                    wallet = await $$.promisify(resolver.createDSUForExistingSSI)(walletSSI, {dsuTypeSSI: seedSSI});
                } catch (e) {
                    return callback(e);
                }
            }

            writableDSU = wallet.getWritableDSU();
            for (let prop in writableDSU) {
                this[prop] = writableDSU[prop];
            }

            __ensureEnvIsInitialised(writableDSU, callback);
        })
    }

    const ensureEnclaveExists = (enclaveType, callback) => {
        writableDSU.readFile("/environment.json", async (err, env) => {
            if (err) {
                return callback(err);
            }

            try {
                env = JSON.parse(env.toString());
            } catch (e) {
                return callback(e);
            }

            if (typeof env[openDSU.constants[enclaveType].KEY_SSI] === "undefined") {
                let seedDSU;
                try {
                    seedDSU = await $$.promisify(resolver.createSeedDSU)(vaultDomain);
                } catch (e) {
                    return callback(e);
                }

                let keySSI;
                try {
                    keySSI = await $$.promisify(seedDSU.getKeySSIAsString)();
                } catch (e) {
                    return callback(e);
                }
                const enclave = enclaveAPI.initialiseWalletDBEnclave(keySSI);
                enclave.on("initialised", async () => {
                    try {
                        await $$.promisify(scAPI.setEnclave)(enclave, enclaveType);
                        callback();
                    } catch (e) {
                        callback(createOpenDSUErrorWrapper("Failed to set shared enclave", e));
                    }
                })
            } else {
                callback();
            }
        });
    }

    this.ensureMainEnclaveExists = (callback) => {
        ensureEnclaveExists("MAIN_ENCLAVE", callback);
    }
    this.ensureSharedEnclaveExists = (callback) => {
        ensureEnclaveExists("SHARED_ENCLAVE", callback);
    }

    this.writeFile = (path, data, callback) => {
        writableDSU.writeFile(path, data, callback);
    }

    this.readFile = (path, callback) => {
        writableDSU.readFile(path, callback);
    }
}

const initialiseWallet = (callback) => {
    const scAPI = require("opendsu").loadAPI("sc");
    const buildWallet = new BuildWallet();
    buildWallet.initialise(err => {
        if (err) {
            return callback(err);
        }

        scAPI.setMainDSU(buildWallet);
        buildWallet.ensureMainEnclaveExists(err => {
            if (err) {
                return callback(err);
            }
            buildWallet.ensureSharedEnclaveExists(callback);
        })
    });
}

module.exports = {
    initialiseWallet
};
},{"opendsu":"opendsu"}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/dt/DossierBuilder.js":[function(require,module,exports){
/**
 * @module dt
 */

const {_getByName} = require('./commands');
const {_getSharedEnclave, _getKeySSISpace} = require('./commands/utils');

/**
 * Automates the Dossier Building process
 * Call via
 * <pre>
 *     builder.buildDossier(config, commands, callback)
 * </pre>
 * where the config is as follows (this config is generated by the buildDossier script in octopus given the proper commands):
 * <pre>
 *     {
 *          "seed": "./seed",
 *          "domain": "default",
 *     }
 * </pre>
 *
 * For a Simple SSApp (with only mounting of cardinal/themes and creation of code folder) the commands would be like:
 * <pre>
 *     delete /
 *     addfolder code
 *     mount ../cardinal/seed /cardinal
 *     mount ../themes/'*'/seed /themes/'*'
 * </pre>
 * @param {Archive} [sourceDSU] if provided will perform all OPERATIONS from the sourceDSU as source and not the fs
 * @param {VarStore} [varStore]
 */
const DossierBuilder = function (sourceDSU, varStore) {

    const _varStore = varStore || new (require('./commands/VarStore'))();

    let createDossier = function (conf, commands, callback) {
        console.log("creating a new dossier...")
        _getSharedEnclave((err, sharedEnclave) => {
            if (err) {
                return callback(err);
            }
            sharedEnclave.createDSU(_getKeySSISpace().createTemplateSeedSSI(conf.domain), (err, bar) => {
                if (err)
                    return callback(err);
                updateDossier(bar, conf, commands, callback);
            });
        })
    };

    /**
     * Writes to a file on the filesystem
     * @param filePath
     * @param data
     * @param callback
     */
    const writeFile = function (filePath, data, callback) {
        new (_getByName('createfile'))(_varStore).execute([filePath, data], (err) => err
            ? callback(err)
            : callback(undefined, data));
    }

    /**
     * Reads a file from the filesystem
     * @param filePath
     * @param callback
     */
    const readFile = function (filePath, callback) {
        new (_getByName('readfile'))(_varStore).execute(filePath, callback);
    }

    /**
     * Stores the keySSI to the SEED file when no sourceDSU is provided
     * @param {string} seed_path the path to store in
     * @param {string} keySSI
     * @param {function(err, KeySSI)} callback
     */
    let storeKeySSI = function (seed_path, keySSI, callback) {
        writeFile(seed_path, keySSI, callback);
    };

    /**
     * Runs an operation
     * @param {Archive} bar
     * @param {string|string[]} command
     * @param {string[]} next the remaining commands to be executed
     * @param {function(err, Archive)} callback
     */
    let runCommand = function (bar, command, next, callback) {
        let args = command.split(/\s+/);
        const cmdName = args.shift();
        const cmd = _getByName(cmdName);
        return cmd
            ? new (cmd)(_varStore, this.source).execute(args, bar, next, callback)
            : callback(`Command not recognized: ${cmdName}`);
    };

    /**
     * Retrieves the KeysSSi after save (when applicable)
     * @param {Archive} bar
     * @param {object} cfg is no sourceDSU is provided must contain a seed field
     * @param {function(err, KeySSI)} callback
     */
    let saveDSU = function (bar, cfg, callback) {
        bar.getKeySSIAsString((err, barKeySSI) => {
            if (err)
                return callback(err);
            const scAPI = require("opendsu").loadAPI("sc");
            scAPI.getSharedEnclave((err, sharedEnclave) => {
                if (err) {
                    return callback(err);
                }

                sharedEnclave.getReadForKeySSI(barKeySSI, (err, readSSI) => {
                    if (err) {
                        return callback(err);
                    }

                    if (sourceDSU || cfg.skipFsWrite)
                        return callback(undefined, readSSI);
                    storeKeySSI(cfg.seed, readSSI, callback);
                })
            })
        });
    };

    /**
     * Run a sequence of {@link Command}s on the DSU
     * @param {Archive} bar
     * @param {object} cfg
     * @param {string[]} commands
     * @param {function(err, KeySSI)} callback
     */
    let updateDossier = function (bar, cfg, commands, callback) {
        if (commands.length === 0) {
            return bar.commitBatch((err) => {
                if (err) {
                    return callback(err);
                }

                saveDSU(bar, cfg, callback);
            })
        }

        if (!bar.batchInProgress()) {
            try {
                bar.beginBatch();
            } catch (e) {
                return callback(e);
            }
        }

        let cmd = commands.shift();
        runCommand(bar, cmd, commands, (err, updated_bar) => {
            if (err) {
                return callback(err);
            }
            updateDossier(updated_bar, cfg, commands, callback);
        });
    };

    /**
     * Builds s DSU according to it's building instructions
     * @param {object|Archive} configOrDSU: can be a config file form octopus or the destination DSU when cloning.
     *
     *
     * Example of config file:
     * <pre>
     *     {
     *         seed: path to SEED file in fs
     *     }
     * </pre>
     * @param {string[]|object[]} [commands]
     * @param {function(err, KeySSI)} callback
     */
    this.buildDossier = function (configOrDSU, commands, callback) {
        if (typeof commands === 'function') {
            callback = commands;
            commands = [];
        }

        let builder = function (keySSI) {
            try {
                keySSI = _getKeySSISpace().parse(keySSI);
            } catch (err) {
                console.log("Invalid keySSI");
                return createDossier(configOrDSU, commands, callback);
            }

            if (keySSI.getDLDomain() && keySSI.getDLDomain() !== configOrDSU.domain) {
                console.log("Domain change detected.");
                return createDossier(configOrDSU, commands, callback);
            }

            _getSharedEnclave((err, sharedEnclave) => {
                if (err) {
                    return callback(err);
                }
                sharedEnclave.loadDSU(keySSI, (err, bar) => {
                    configOrDSU.skipFsWrite = true;
                    if (err) {
                        console.log("DSU not available. Creating a new DSU for", keySSI.getIdentifier());

                        return sharedEnclave.createDSU(keySSI, {useSSIAsIdentifier: true}, (err, bar) => {
                            if (err)
                                return callback(err);
                            updateDossier(bar, configOrDSU, commands, callback);
                        });
                    }
                    console.log("Dossier updating...");
                    updateDossier(bar, configOrDSU, commands, callback);
                });
            });
        }

        require("./index").initialiseBuildWallet(err => {
            if (err) {
                return callback(err);
            }
            if (configOrDSU.constructor && configOrDSU.constructor.name === 'Archive')
                return updateDossier(configOrDSU, {skipFsWrite: true}, commands, callback);

            readFile(configOrDSU.seed, (err, content) => {
                if (err || content.length === 0)
                    return createDossier(configOrDSU, commands, callback);
                builder(content.toString());
            });
        });
    };
};

module.exports = DossierBuilder;

},{"./commands":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/dt/commands/index.js","./commands/VarStore":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/dt/commands/VarStore.js","./commands/utils":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/dt/commands/utils.js","./index":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/dt/index.js","opendsu":"opendsu"}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/dt/FileService.js":[function(require,module,exports){
/**
 * @module dt
 */

/**
 * Forked from PrivateSky
 * Provides an environment independent file service to the {@link AppBuilderService}
 */
function FileService(options) {
    const isBrowser = $$.environmentType === 'browser';

    function constructUrlBase(prefix){
        let url, protocol, host;
        prefix = prefix || "";
        let appName = '';
        if (isBrowser){
            let location = window.location;
            const paths = location.pathname.split("/");
            while (paths.length > 0) {
                if (paths[0] === "") {
                    paths.shift();
                } else {
                    break;
                }
            }
            appName = paths[0];
            protocol = location.protocol;
            host = location.host;
            url = `${protocol}//${host}/${prefix}${appName}`;
            return url;
        } else {
            return `http://${options.hosts}/${prefix}${options.walletPath}`;
        }
    }

    this.getWalletSeed = function(callback){
        this.getAppSeed(options.slots.primary, callback);
    }

    this.getAppSeed = function(appName, callback){
        this.getFile(appName, options.seedFileName, (err, data) => {
            if (err)
                return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(err));
           Utf8ArrayToStr(data, callback);
        });
    }

    function doGet(url, options, callback){
        if (typeof options === "function") {
            callback = options;
            options = {};
        }

        const http = require("opendsu").loadApi("http");
        http.fetch(url, {
            method: 'GET'
        }).then((response) => {
            return response.arrayBuffer().then((data) => {
                if (!response.ok)
                    return callback("array data failed")
                callback(undefined, data);
            }).catch(e => callback(e));
        }).catch(err => callback(err));
    }

    /**
     * Returns the content of a file as a uintArray
     * @param {string} appName
     * @param {string} fileName
     * @param {function(err, U8intArray)} callback
     */
    this.getFile = function(appName, fileName, callback){
        const suffix = `${appName}/${fileName}`;
        const base = constructUrlBase();
        const joiner = suffix !== '/' && base[base.length - 1] !== '/' && suffix[0] !== '/'
            ? '/'
            : '';

        let url = base + joiner + suffix;
        doGet(url, callback);
    };


    /**
     *
     * @param innerFolder
     * @param callback
     */
    this.getFolderContentAsJSON = function(innerFolder, callback){
        if (typeof innerFolder === 'function'){
            callback = innerFolder;
            innerFolder = undefined;
        }
        let url = constructUrlBase("directory-summary/") + (innerFolder ? `/${innerFolder}` : '') ;
        doGet(url, (err, data) => {
            if (err)
                return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(err));
            Utf8ArrayToStr(data, callback);
        });
    }

    /**
     * Util method to convert Utf8Arrays to Strings in the browser
     * (simpler methods fail for big content jsons)
     * @param {U8intArray} array
     * @param {function(err, string)} callback
     */
    function Utf8ArrayToStr(array, callback) {
        if (!isBrowser)
            return callback(undefined, array.toString());
        var bb = new Blob([array]);
        var f = new FileReader();
        f.onload = function(e) {
            callback(undefined, e.target.result);
        };
        f.readAsText(bb);
    }
}

module.exports = FileService;
},{"opendsu":"opendsu"}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/dt/commands/Command.js":[function(require,module,exports){
/**
 * @module Commands
 * @memberOf dt
 */
const { _err } = require('./utils');

/**
 * **Every Command must be registered under the index.js file in the commands folder**
 * @param {VarStore} varStore
 * @param {Archive|fs} [source]
 * @param {boolean} [canRunIteratively] defines if the command can expect multiple arguments and run multiple times. defaults to false
 * @class Command
 * @abstract
 */
class Command {
    constructor(varStore, source, canRunIteratively) {
        if (typeof source === 'boolean'){
            canRunIteratively = source;
            source = undefined;
        }
        if (!varStore.checkVariables)
            throw new Error('Cant happen')

        this.varStore = varStore;
        this.source = source;
        this.canRunIteratively = !!canRunIteratively;
    }

    /**
     * Parses the command text and executes the command onto the provided DSU
     * @param {string[]|string} args the arguments of the command split into words
     * @param {Archive|KeySSI} [bar] the destinationDSU or the keySSI
     * @param {string[]} [next] the remaining commands
     * @param {object} [options]
     * @param {function(err, Archive|KeySSI|string|boolean)} callback
     */
    execute(args,bar, next, options, callback){
        if (typeof options === 'function'){
            callback = options;
            options = undefined;
        }
        if (typeof next === 'function'){
            callback = next;
            options = undefined;
            next = undefined;
        }
        if (callback === undefined){
            callback = bar;
            bar = undefined;
        }
        let self = this;
        this._parseCommand(args, next, (err, parsedArgs) => {
            if (err)
                return _err(`Could not parse command ${args}`, err, callback);

            // Tests against variables
            if (self.varStore)
                parsedArgs = self.varStore.checkVariables(parsedArgs);

            if (!self.canRunIteratively || !(parsedArgs instanceof Array))
                return self._runCommand(parsedArgs, bar, options, callback);

            const iterator = function(args, callback){
                let arg = parsedArgs.shift();
                if (!arg)
                    return callback(undefined, bar);
                return self._runCommand(arg, bar, options, (err, dsu) => err
                    ? _err(`Could iterate over Command ${self.constructor.name} with args ${JSON.stringify(arg)}`, err, callback)
                    : iterator(args, callback));
            }

            iterator(args, callback);
        });
    }

    /**
     * Should be overridden by child classes if any argument parsing is required
     *
     * @param {string[]|string|boolean} command the command split into words
     * @param {string[]} next the following Commands
     * @param {function(err, string|string[]|object)} callback
     * @protected
     */
    _parseCommand(command, next, callback){
        if (!callback){
            callback = next;
            next = undefined;
        }
        callback(undefined, command);
    }

    /**
     * @param {string|object} arg the command argument
     * @param {Archive} [bar]
     * @param {object} options
     * @param {function(err, Archive|KeySSI|string)} callback
     * @protected
     */
    _runCommand(arg, bar, options, callback){
        throw new Error("Child classes must implement this");
    }
}

module.exports = Command;
},{"./utils":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/dt/commands/utils.js"}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/dt/commands/Registry.js":[function(require,module,exports){
/**
 * List of all available commands to the Dossier Builder
 * Without being here, they can't be used
 */
const _availableCommands = {
    addfile: require('./addFile'),
    addfolder: require('./addFolder'),
    createdsu: require('./createDSU'),
    createfile: require('./createFile'),
    define: require('./define'),
    delete: require('./delete'),
    derive: require('./derive'),
    endwith: require('./endWith'),
    genkey: require('./genKey'),
    getidentifier: require('./getIndentifier'),
    mount: require('./mount'),
    objtoarray: require('./objToArray'),
    readfile: require('./readFile'),
    with: require('./with')
};

/**
 * return the Command class by its name
 * @param cmdName
 * @return {Command} the command calls to be instanced
 */
const _getByName = function(cmdName){
    if (cmdName in _availableCommands)
        return _availableCommands[cmdName];
    return undefined;
}

module.exports = _getByName;
},{"./addFile":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/dt/commands/addFile.js","./addFolder":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/dt/commands/addFolder.js","./createDSU":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/dt/commands/createDSU.js","./createFile":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/dt/commands/createFile.js","./define":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/dt/commands/define.js","./delete":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/dt/commands/delete.js","./derive":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/dt/commands/derive.js","./endWith":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/dt/commands/endWith.js","./genKey":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/dt/commands/genKey.js","./getIndentifier":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/dt/commands/getIndentifier.js","./mount":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/dt/commands/mount.js","./objToArray":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/dt/commands/objToArray.js","./readFile":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/dt/commands/readFile.js","./with":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/dt/commands/with.js"}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/dt/commands/VarStore.js":[function(require,module,exports){
/**
 * @module commands
 * A simple variable store
 */


const VarStore = function(){
    const _memory = {};
    let _hasVars = false;
    const self = this;

    this.define = function(name, value){
        _memory[name] = value;
        _hasVars = true;
        console.log(`Variable ${name} defined as ${value}`)
    }

    const tryReplace = function(value){
        for (let name in _memory)
            if (value.includes(name)) {
                value = value.replace(name, _memory[name]);
                console.log(`Replaced variable ${name}`)
            }
        return value;
    }

    this.checkVariables = function(args){
        if (!_hasVars)
            return args;
        if (typeof args === 'string')
            return tryReplace(args);
        if (args instanceof Array)
            return args.map(a => self.checkVariables(a));
        if (typeof args !== 'object')
            return args;
        const result = {};
        Object.keys(args).forEach(k => {
            result[k] = self.checkVariables(args[k]);
        });
        return result;
    }
}

module.exports = VarStore;
},{}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/dt/commands/addFile.js":[function(require,module,exports){
/**
 * @module Commands
 * @memberOf dt
 */

/**
 */
const Command = require('./Command');
const { _err } = require('./utils');

/**
 * Copies a File from disk or from a source DSU when provided
 *
 * supports sourceDSU, defaults to fs
 *
 * Can run iteratively
 *
 * @class AddFileCommand
 */
class AddFileCommand extends Command{
    constructor(varStore, source) {
        super(varStore, source, true);
    }

    /**
     * @param {string[]|string} command the command split into words
     * @param {string[]} next discarded
     * @param {function(err, string|object)} [callback] discarded
     * @return {string|object} the command argument
     * <pre>
     *     {
     *         from: (...),
     *         to: (..)
     *     }
     * </pre>
     * @protected
     */
    _parseCommand(command, next, callback){
        if (!callback){
            callback = next;
            next = undefined;
        }
        callback(undefined, {
            "from": command[0],
            "to": command[1]
        });
    }

    /**
     * Copies a file, from disk or another DSU
     * @param {object} arg
     * <pre>
     *     {
     *         from: (...),
     *         to: (..)
     *     }
     * </pre>
     * @param {Archive} bar
     * @param {object} options
     * @param {function(err, Archive)} callback
     * @protected
     */
    _runCommand(arg, bar, options, callback) {
        if (!callback) {
            callback = options;
            options = undefined;
        }

        options = options || {encrypt: true, ignoreMounts: false}
        console.log("Copying file " + arg.from + (this.source ? " from sourceDSU" : "") + " to " + arg.to);

        if (!this.source)
            return bar.addFile(arg.from, arg.to, options, err => err
                ? _err(`Could not read from ${arg.from}`, err, callback)
                : callback(undefined, bar));

        this.source.readFile(arg.from, (err, data) => {
            if (err)
                return _err(`Could not read from ${arg.from}`, err, callback);
            bar.writeFile(arg.to, data, err => err
                ? _err(`Could not write to ${arg.to}`, err, callback)
                : callback(undefined, bar));
        });
    }
}

module.exports = AddFileCommand;
},{"./Command":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/dt/commands/Command.js","./utils":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/dt/commands/utils.js"}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/dt/commands/addFolder.js":[function(require,module,exports){
/**
 * @module Commands
 * @memberOf dt
 */

/**
 */
const Command = require('./Command');
const { _err } = require('./utils');

/**
 * This command copies an entire folder from the filesystem onto the destination DSU
 * (as a single brick for efficiency if I'm not mistaken)
 *
 * Does not Support sourceDSU (yet)
 *
 * Can run iteratively
 *
 * @class AddFolderCommand
 */
class AddFolderCommand extends Command {
    constructor(varStore, source) {
        super(varStore, source, false);
    }

    /**
     * @param {string[]|string} command the command split into words
     * @param {string[]} next the following Commands
     * @param {function(err, string|object)} [callback] for async versatility
     * @return {string|object} the command argument
     * @protected
     */
    _parseCommand(command, next, callback){
        if (!callback){
            callback = next;
            next = undefined;
        }
        callback(undefined, command);
    }

    /**
     * @param {string|object} arg the command argument
     * @param {Archive} bar
     * @param {object} [options]
     * @param {function(err, Archive)} callback
     * @protected
     */
    _runCommand(arg, bar, options, callback){
        if (this.source){
            console.log("The addFolder Method is not supported when reading from a sourceDSU");
            callback(undefined, bar);
        }
        if (!callback) {
            callback = options;
            options = undefined;
        }

        options = options || {batch: false, encrypt: false};
        let src = arg[0];
        let dst = arg[1] || "/";
        let commandLog = "Adding Folder " + src + " to " + dst;
        console.log(commandLog);

        bar.addFolder(src, dst, options, err => err
            ? _err(`Failed to: `+commandLog, err, callback)
            : callback(undefined, bar));
    }
}

module.exports = AddFolderCommand;
},{"./Command":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/dt/commands/Command.js","./utils":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/dt/commands/utils.js"}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/dt/commands/createDSU.js":[function(require,module,exports){
/**
 * @module Commands
 * @memberOf dt
 */

/**
 */
const Command = require('./Command');
const { _err, _getResolver, DSU_TYPE, KEY_TYPE } = require('./utils');
const genKey = require('./genKey');

/**
 * @param {DSU_TYPE} dsuType
 * @return {KEY_TYPE}
 */
const _getKeyType = function(dsuType){
    switch (dsuType){
        case DSU_TYPE.CONST:
            return KEY_TYPE.ARRAY;
        case DSU_TYPE.WALLET:
            return KEY_TYPE.WALLET;
        case DSU_TYPE.SEED:
            return KEY_TYPE.SEED;
        default:
            throw new Error(`Unsupported DSU Type`);
    }
}


/**
 * Creates an Arrays SSI off a secret list
 *
 * Adds options.hint to hit if available
 * @param {string[]} arg
 * @param {function(err, KeySSI)} callback
 */
_createSSI = function(varStore, arg, callback){
    const argToArray = (arg) => {
        return `${arg.type} ${arg.domain} ${typeof arg.args === 'string' ? arg.args : JSON.stringify(arg.hint ? {
            hint: arg.hint,
            args: arg.args
        } : arg.args)}`.split(/\s+/);
    }
    new genKey(varStore).execute(argToArray(arg), callback);
}


/**
 * Creates a DSU of an ArraySSI
 * @param {string[]} arg
 * @param {object} opts DSU Creation Options
 * @param {function(err, Archive)} callback
 */
_createWalletDSU = function(varStore, arg, opts, callback){
    _createSSI(varStore, arg, (err, keySSI) => {
        _getResolver().createDSUForExistingSSI(keySSI, opts, (err, dsu) => {
            if (err)
                return _err(`Could not create wallet DSU`, err, callback);
            callback(undefined, dsu);
        });
    });
}

/**
 * Creates a DSU of an ArraySSI
 * @param {string[]} arg String for Seed SSI
 * @param {object} opts DSU Creation Options
 * @param {function(err, Archive)} callback
 */
_createDSU = function(varStore, arg, opts, callback){
    _createSSI(varStore, arg, (err, keySSI) => {
        _getResolver().createDSU(keySSI, opts, (err, dsu) => {
            if (err)
                return _err(`Could not create DSU`, err, callback);
            callback(undefined, dsu);
        });
    });
}

/**
 * Creates a DSU of an ArraySSI
 * @param {string[]} arg
 * @param {object} opts DSU Creation Options
 * @param {function(err, Archive)} callback
 */
_createConstDSU = function(varStore, arg,opts , callback){
    _createSSI(varStore, arg, (err, keySSI) => {
        _getResolver().createDSUForExistingSSI(keySSI, opts, (err, dsu) => {
            if (err)
                return _err(`Could not create const DSU`, err, callback);
            callback(undefined, dsu);
        });
    });
}

_getDSUFactory = function(isConst, isWallet){
    return isConst ? (isWallet ? _createWalletDSU : _createConstDSU) : _createDSU;
}

/**
 * creates a new DSU of the provided type and with the provided key gen arguments
 *
 * @class CreateDSUCommand
 */
class CreateDSUCommand extends Command{
    constructor(varStore, source) {
        super(varStore, source, false);
    }

    /**
     * @param {string[]|string} command the command split into words
     * @param {string[]} next discarded
     * @param {function(err, string|object)} [callback] discarded
     * @return {string|object} the command argument
     * <pre>
     *     {
     *         type: (...),
     *         domain: (..)
     *         args: {string[]|object},
     *     }
     * </pre>
     * @protected
     */
    _parseCommand(command, next, callback){
        if (!callback){
            callback = next;
            next = undefined;
        }
        try {
            let arg = {
                dsuType: command.shift(),
                domain: command.shift(),
                args: command.length === 1 ? command[0] : JSON.parse(command.join(' '))
            }
            arg.type = _getKeyType(arg.dsuType);
            if (typeof arg.args === 'object' && arg.args.args){
                arg.hint = arg.args.hint;
                arg.args = arg.args.args;
            }
            callback(undefined, arg)
        } catch (e){
            _err(`could not parse json ${command}`, e, callback);
        }
    }

    /**
     * Copies a file, from disk or another DSU
     * @param {object} arg
     * <pre>
     *     {
     *         from: (...),
     *         to: (..)
     *     }
     * </pre>
     * @param {Archive} bar
     * @param {object} options
     * @param {function(err, Archive)} callback
     * @protected
     */
    _runCommand(arg, bar, options, callback) {
        if(!callback){
            callback = options;
            options = bar;
            bar = undefined;
        }
        if (typeof options === 'function'){
            callback = options;
            options = undefined;
        }
        const cb = function(err, dsu){
            if (err)
                return _err(`Could not create DSU with ${JSON.stringify(arg)}`, err, callback);
            console.log(`${arg.dsuType} DSU created`);
            callback(undefined, dsu);
        }

        switch (arg.dsuType){
            case DSU_TYPE.SEED:
                return _createDSU(this.varStore, arg, cb)
            case DSU_TYPE.CONST:
                return _createConstDSU(this.varStore, arg, cb);
            case DSU_TYPE.WALLET:
                return _createWalletDSU(this.varStore, arg, cb);
            default:
                callback(`Unsupported key type`);
        }
    }
}

module.exports = CreateDSUCommand;
},{"./Command":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/dt/commands/Command.js","./genKey":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/dt/commands/genKey.js","./utils":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/dt/commands/utils.js"}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/dt/commands/createFile.js":[function(require,module,exports){
/**
 * @module Commands
 * @memberOf dt
 */

/**
 */
const Command = require('./Command');
const {_getFS, _err} = require('./utils');

/**
 * Creates a file with the provided content on the destination DSU
 * (similar to a touch command with added content)
 *
 * @class CreateFileCommand
 */
class CreateFileCommand extends Command{
    constructor(varStore) {
        super(varStore);
    }

    /**
     * @param {string[]|string} command the command split into words
     * @param {string[]} next the following Commands
     * @param {function(err, string|object)} [callback] for async versatility
     * @return {string|object} the command argument
     * @protected
     */
    _parseCommand(command, next, callback){
        command = typeof command === 'string' ? command.split(' ') : command;
        callback(undefined,  {
            path: command.shift(),
            content: command.join(' ')
        });
    }

    /**
     * Writes a file
     * @param {object} arg the command argument
     * <pre>
     *     {
     *         path: (...),
     *         content: (..)
     *     }
     * </pre>
     * @param {Archive|fs} bar
     * @param {object} options
     * @param {function(err, string)} callback
     * @protected
     */
    _runCommand(arg, bar, options, callback){
        if (typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        if (!bar)
            bar = _getFS();
        options = options || {encrypt: true, ignoreMounts: false};
        bar.writeFile(arg.path, arg.content, options, (err) => err
            ? _err(`Could not create file at ${arg.path}`, err, callback)
            : callback(undefined, bar));
    }
}

module.exports = CreateFileCommand;
},{"./Command":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/dt/commands/Command.js","./utils":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/dt/commands/utils.js"}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/dt/commands/define.js":[function(require,module,exports){
/**
 * @module Commands
 * @memberOf dt
 */

/**
 */
const Command = require('./Command');
const { _err } = require('./utils');

/**
 * Defines a variable that can later be used in the script
 *
 * @class DefineCommand
 */
class DefineCommand extends Command {
    constructor(varStore) {
        super(varStore);
    }

    /**
     * @param {string[]|string} command the command split into words
     * @param {string[]} next the following Commands
     * @param {function(err, string|object)} [callback] for async versatility
     * @return {string|object} the command argument
     * @protected
     */
    _parseCommand(command, next, callback) {
        if (!callback){
            callback = next;
            next = undefined;
        }

        callback(undefined, {
            varName: command.shift(),
            command: command
        });
    }

    /**
     * @param {string[]|object} arg the command argument
     * @param {Archive} bar
     * @param {object} options
     * @param {function(err, Archive)} callback
     * @protected
     */
    _runCommand(arg, bar, options, callback) {
        if (typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        let self = this;
        const _getByName = require('./Registry');

        if (!_getByName(arg.command[0])){
            this.varStore.define(arg.varName, arg.command);
            console.log(`Define executed: ${arg.command}`);
            return callback(undefined, bar);
        }

        const parseCommand = function(command, callback){
            const cmdName = command.shift();
            const actualCmd = _getByName(cmdName);
            if (!actualCmd)
                return callback(`Could not find command`);
            callback(undefined, cmdName, actualCmd, command);
        }

        return parseCommand(arg.command, (err, cmdName, command, args) => err
            ? _err(`Could not parse Command`, err, callback)
            : new (command)(self.varStore, self.source).execute(args, bar, (err, result) => {
                if (err)
                    return _err(`Could not obtain result`, err, callback);
                this.varStore.define(arg.varName, result);
                console.log(`Define executed: ${result}`);
                callback(undefined, bar);
            }));
    }
}

module.exports = DefineCommand;
},{"./Command":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/dt/commands/Command.js","./Registry":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/dt/commands/Registry.js","./utils":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/dt/commands/utils.js"}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/dt/commands/delete.js":[function(require,module,exports){
/**
 * @module Commands
 * @memberOf dt
 */


/**
 */
const Command = require('./Command');
const { _err } = require('./utils');

/**
 * Deletes everything in the specified path of the DSU
 *
 * @class DeleteCommand
 */
class DeleteCommand extends Command {
    constructor(varStore) {
        super(varStore,undefined, false);
    }

    /**
     * @param {string[]|string} command the command split into words
     * @param {string[]} next the following Commands
     * @param {function(err, string|object)} [callback] for async versatility
     * @return {string|object} the command argument
     * @protected
     */
    _parseCommand(command, next, callback){
        callback(undefined, command[0]);
    }

    /**
     * @param {string} arg
     * @param {Archive} bar
     * @param {object} [options]
     * @param {function(err, Archive)} callback
     * @protected
     */
    _runCommand(arg, bar, options, callback){
        if (typeof options === 'function'){
            callback = options;
            options = undefined
        }
        options = options || {ignoreMounts: false, ignoreError: true};
        console.log("Deleting " + arg);
        bar.delete(arg, options, err => err
            ? _err(`Could not delete path '${arg}'`, err, callback)
            : callback(undefined, bar));
    }
}

module.exports = DeleteCommand;

},{"./Command":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/dt/commands/Command.js","./utils":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/dt/commands/utils.js"}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/dt/commands/derive.js":[function(require,module,exports){
/**
 * @module Commands
 * @memberOf dt
 */

/**
 */
const Command = require('./Command');
const { _getKeySSISpace, _err } = require('./utils');

/**
 * Derives the provided keySSI
 *
 * @class DeriveCommand
 */
class DeriveCommand extends Command{
    constructor(varStore) {
        super(varStore);
    }

    _parseCommand(command, next, callback) {
        if (!callback){
            callback = next;
            next = undefined;
        }
        callback(undefined, command
            ? !(command === 'false' || command[0] === 'false')
            : true);
    }

    /**
     * derives the provided keySSI (in the source object)
     * @param {object} arg unused
     * @param {KeySSI} bar
     * @param {object} options unsused
     * @param {function(err, KeySSI)} callback
     * @protected
     */
    _runCommand(arg, bar, options, callback) {
        if (!callback) {
            callback = options;
            options = undefined;
        }

        try{
            const keySSI = _getKeySSISpace().parse(bar);
            keySSI.derive((err, derivedKeySSI) => {
                if (err) {
                    return _err(`Could not derive Key ${JSON.stringify(bar)}`, err, callback)
                }

                callback(undefined, arg ? derivedKeySSI.getIdentifier() : derivedKeySSI);
            });
        } catch (e) {
            _err(`Could not parse Key ${JSON.stringify(bar)}`, e, callback)
        }
    }
}

module.exports = DeriveCommand;
},{"./Command":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/dt/commands/Command.js","./utils":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/dt/commands/utils.js"}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/dt/commands/endWith.js":[function(require,module,exports){
/**
 * @module Commands
 * @memberOf dt
 */

/**
 */
const Command = require('./Command');

/**
 * Allows for more complex logic by allowing you to control the output/input for commands
 * while keeping the commands readable
 *
 * basically sets whatever the result of the with operation into the source portion until it finds the endwith command
 *
 * @class EndWithCommand
 */
class EndWithCommand extends Command{
    constructor(varStore) {
        super(varStore);
    }

    /**
     * Returns the source object
     * @param {string[]|object} arg unused
     * @param {Archive} bar unused
     * @param {object} options unused
     * @param {function(err, Archive|KeySSI)} callback
     * @protected
     */
    _runCommand(arg, bar, options, callback){
        if (!callback) {
            callback = options;
            options = undefined;
        }
        if (!callback){
            callback = bar;
            bar = arg;
            arg = undefined;
        }

        // return whatever the object was
        if (!bar)
            return callback(`Nothing to return. should not be possible`);

        console.log(`Ending With command. Returning to ${JSON.stringify(bar)}`);
        callback(undefined, bar);
    }
}

module.exports = EndWithCommand;
},{"./Command":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/dt/commands/Command.js"}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/dt/commands/genKey.js":[function(require,module,exports){
/**
 * @module Commands
 * @memberOf dt
 */

/**
 */
const Command = require('./Command');
const { _err, _getKeySSISpace, KEY_TYPE } = require('./utils');

/**
 * Generates a KeySSI
 *
 * @class GenKeyCommand
 */
class GenKeyCommand extends Command {
    constructor(varStore) {
        super(varStore,undefined, false);
    }

    /**
     * @param {string[]|string} command the command split into words
     * @param {string[]} next the following Commands
     * @param {function(err, string|object)} [callback] for async versatility
     * @return {string|object} the command argument
     * @protected
     */
    _parseCommand(command, next, callback){
        if (!callback){
            callback = next;
            next = undefined;
        }

        const tryParseJson = function(text){
            try {
                let parsedArgs = JSON.parse(text);
                if (parsedArgs && typeof parsedArgs === 'object')
                    return parsedArgs;
                return text;
            } catch (e) {
                // The argument is just a string. leave it be
                return text;
            }
        }

        try {
            let arg = {
                type: command.shift(),
                domain: command.shift(),
                args: tryParseJson(command.shift())
            }

            if (typeof arg.args === 'object' && arg.args.args){
                arg.hint = arg.args.hint;
                arg.args = tryParseJson(arg.args.args);
            }
            callback(undefined, arg);
        } catch (e){
            _err(`could not parse json ${command}`, e, callback);
        }
    }

    /**
     * Creates an Arrays SSI off a secret list
     *
     * Adds options.hint to hit if available
     * @param {object} args
     * @param {function(err, ArraySSI)} callback
     * @private
     */
    _createArraySSI = function(args, callback){
        const key = _getKeySSISpace().createArraySSI(args.domain, args.args, 'v0', args.hint ? JSON.stringify(args.hint) : undefined);
        callback(undefined, key);
    }

    /**
     * Creates a Wallet SSI off a secret list
     *
     * Adds options.hint to hit if available
     * @param {object} args
     * @param {function(err, ArraySSI)} callback
     */
    _createWalletSSI = function(args, callback){
        const key = _getKeySSISpace().createTemplateWalletSSI(args.domain, args.args, 'v0', args.hint ? JSON.stringify(args.hint) : undefined);
        callback(undefined, key);
    }

    /**
     * Creates an Arrays SSI off a secret list
     *
     * Adds options.hint to hit if available
     * @param {object} args
     * @param {function(err, TemplateSeedSSI)} callback
     */
    _createSSI = function(args, callback){
        const key = _getKeySSISpace().createTemplateSeedSSI(args.domain, args.args, undefined, 'v0', args.hint ? JSON.stringify(args.hint) : undefined);
        callback(undefined, key);
    }

    /**
     * Copies a file, from disk or another DSU
     * @param {object} arg
     * <pre>
     *     {
     *         type: (...),
     *         domain: (..),
     *         args: []| {
     *                  hint: (..)
     *                  args: []
     *         }
     *     }
     * </pre>
     * @param {Archive} bar unused
     * @param {object} options unused
     * @param {function(err, KeySSI)} callback
     * @protected
     */
    _runCommand(arg, bar, options, callback) {
        if(!callback){
            callback = options;
            options = bar;
            bar = undefined;
        }
        if (typeof options === 'function'){
            callback = options;
            options = undefined;
        }
        const cb = function(err, keySSI){
            if (err)
                return _err(`Could not create keySSI with ${JSON.stringify(arg)}`, err, callback);
            console.log(`${arg.type} KeySSI created with SSI ${keySSI.getIdentifier()}`)
            callback(undefined, keySSI);
        }

        switch (arg.type){
            case KEY_TYPE.SEED:
                return this._createSSI(arg, cb)
            case KEY_TYPE.ARRAY:
                return this._createArraySSI(arg, cb);
            case KEY_TYPE.WALLET:
                return this._createWalletSSI(arg, cb);
            default:
                callback(`Unsupported key type`);
        }
    }
}

module.exports = GenKeyCommand;
},{"./Command":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/dt/commands/Command.js","./utils":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/dt/commands/utils.js"}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/dt/commands/getIndentifier.js":[function(require,module,exports){
/**
 * @module Commands
 * @memberOf dt
 */

/**
 */
const Command = require('./Command');
const { _err } = require('./utils');

/**
 * Returns the identifier for the current source object
 *
 * @class GetIdentifierCommand
 */
class GetIdentifierCommand extends Command{
    constructor(varStore) {
        super(varStore);
    }

    /**
     * @param {string[]|string} command the command split into words
     * @param {string[]} next discarded
     * @param {function(err, boolean)} callback
     * @protected
     */
    _parseCommand(command, next, callback){
        if (!callback){
            callback = next;
            next = undefined;
        }
        callback(undefined, command
            ? !(command === 'false' || command[0] === 'false')
            : true);
    }

    /**
     * derives the provided keySSI
     * @param {boolean} arg identifier as string (defaults to false)
     * @param {Archive|KeySSI} bar
     * @param {object} options unused
     * @param {function(err, string|KeySSI)} callback
     * @protected
     */
    _runCommand(arg, bar, options, callback) {
        if (!callback) {
            callback = options;
            options = undefined;
        }
        if (!bar.getIdentifier && !bar.getKeySSIAsString)
            return callback(`The object cannot be derived. It is a KeySSI or a DSU?`);

        // if its a dsu
        if (bar.constructor && bar.constructor.name === 'Archive')
            return (arg ? bar.getKeySSIAsString : bar.getKeySSIAsObject)((err, identifier) => err
                ? _err(`Could not get identifier`, err, callback)
                : callback(undefined, identifier));

        // if its a KeySSI
        try{
            let identifier = arg ? bar.getIdentifier() : bar;
            if (!identifier)
                return callback(`Could not get identifier`);
            callback(undefined, identifier);
        } catch (e){
            _err(`Could not get identifier`, e, callback);
        }
    }
}

module.exports = GetIdentifierCommand;
},{"./Command":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/dt/commands/Command.js","./utils":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/dt/commands/utils.js"}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/dt/commands/index.js":[function(require,module,exports){
/**
 * @module Commands
 * @memberOf dt
 */

module.exports = {
    AddFileCommand: require('./addFile'),
    AddFolderCommand: require('./addFolder'),
    CreateDSUCommand: require('./createDSU'),
    CreateFileCommand: require('./createFile'),
    DefineCommand: require('./define'),
    DeleteCommand: require('./delete'),
    DeriveCommand: require('./derive'),
    EndWithCommand: require('./endWith'),
    GenKeyCommand: require('./genKey'),
    GetIdentifierCommand: require('./getIndentifier'),
    MountCommand: require('./mount'),
    ObjToArrayCommand: require('./objToArray'),
    ReadFileCommand: require('./readFile'),
    WithCommand: require('./with'),
    _getByName: require('./Registry')
}
},{"./Registry":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/dt/commands/Registry.js","./addFile":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/dt/commands/addFile.js","./addFolder":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/dt/commands/addFolder.js","./createDSU":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/dt/commands/createDSU.js","./createFile":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/dt/commands/createFile.js","./define":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/dt/commands/define.js","./delete":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/dt/commands/delete.js","./derive":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/dt/commands/derive.js","./endWith":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/dt/commands/endWith.js","./genKey":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/dt/commands/genKey.js","./getIndentifier":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/dt/commands/getIndentifier.js","./mount":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/dt/commands/mount.js","./objToArray":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/dt/commands/objToArray.js","./readFile":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/dt/commands/readFile.js","./with":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/dt/commands/with.js"}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/dt/commands/mount.js":[function(require,module,exports){
/**
 * @module Commands
 * @memberOf dt
 */

/**
 */
const Command = require('./Command');
const ReadFileCommand = require('./readFile');
const {_err, _getFS, _getKeySSISpace} = require('./utils');

/**
 * Mounts a DSU onto the provided path
 *
 * @class MountCommand
 */
class MountCommand extends Command {
    constructor(varStore, source) {
        super(varStore, source, true);
        if (!source)
            this._getFS = require('./utils');
    }

    /**
     * Lists all the mounts in the provided pattern, either via fs or source dsu
     * @param {object} arg
     * @param {function(err, string[])} callback
     * @private
     */
    _listMounts(arg, callback) {
        let self = this;
        let basePath = arg.seed_path.split("*");
        const listMethod = this.source ? this.source.listMountedDSUs : _getFS().readdir;
        listMethod(basePath[0], (err, args) => err
            ? _err(`Could not list mounts`, err, callback)
            : callback(undefined, self._transform_mount_arguments(arg, args)));
    }

    /**
     * handles the difference between the mount arguments in the 2 cases (with/without sourceDSU)
     * @param arg
     * @param args
     * @return {*}
     * @private
     */
    _transform_mount_arguments(arg, args) {
        return this.source
            ? args.map(m => {
                return {
                    "seed_path": m.identifier,
                    "mount_point": m.path
                }
            })
            : args.map(n => {
                return {
                    "seed_path": arg.seed_path.replace("*", n),
                    "mount_point": arg.mount_point.replace("*", n)
                };
            });
    }

    /**
     * @param {string[]|string} command the command split into words
     * @param {string[]} next the following Commands
     * @param {function(err, string|string[]|object)} callback
     * @protected
     */
    _parseCommand(command, next, callback) {
        let arg = {
            "seed_path": command[0],
            "mount_point": command[1]
        };

        if (!arg.seed_path.match(/[\\/]\*[\\/]/))
            return callback(undefined, arg);   // single mount
        // multiple mount
        this._listMounts(arg, callback);
    }

    /**
     * Mounts a DSu onto a path
     * @param {object} arg
     * <pre>
     *     {
     *         seed_path: (...),
     *         mount_point: (..)
     *     }
     * </pre>
     * @param {Archive} [bar]
     * @param {object} options
     * @param {function(err, Archive)} callback
     * @protected
     */
    _runCommand(arg, bar, options, callback) {
        if (typeof options === 'function') {
            callback = options;
            options = undefined;
        }

        const doMount = function (seed, callback) {
            const scAPI = require("opendsu").loadAPI("sc");
            scAPI.getSharedEnclave((err, sharedEnclave) => {
                if (err) {
                    return callback(err);
                }

                sharedEnclave.getReadForKeySSI(seed, (err, readSSI) => {
                    if (err) {
                        return callback(err);
                    }

                    console.log("Mounting sread " + readSSI + " to " + arg.mount_point);
                    bar.mount(arg.mount_point, readSSI, err => err
                        ? _err(`Could not perform mount of ${readSSI} at ${arg.seed_path}`, err, callback)
                        : callback(undefined, bar));
                })
            })

        };
        try {
            if (_getKeySSISpace().parse(arg.seed_path))
                return doMount(arg.seed_path, callback);
        } catch (e) {
            new ReadFileCommand(this.varStore, this.source).execute(arg.seed_path, (err, seed) => {
                if (err)
                    return _err(`Could not read seed from ${arg.seed_path}`, err, callback);
                seed = seed.toString();
                doMount(seed, callback);
            });
        }
    }
}

module.exports = MountCommand;
},{"./Command":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/dt/commands/Command.js","./readFile":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/dt/commands/readFile.js","./utils":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/dt/commands/utils.js","opendsu":"opendsu"}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/dt/commands/objToArray.js":[function(require,module,exports){
/**
 * @module Commands
 * @memberOf dt
 */

/**
 */
const Command = require('./Command');
const { _err } = require('./utils');

/**
 * Util Command to convert objects to and array with their values
 * @class ObjToArrayCommand
 */
class ObjToArrayCommand extends Command{
    constructor(varStore, source) {
        super(varStore, source, false);
    }

    _parseCommand(command, next, callback){
        if (!callback){
            callback = next;
            next = undefined;
        }
        callback(undefined, typeof command === 'string' ? command : command.shift());
    }

    /**
     * Outputs all args to console
     * @param {object} arg
     * @param {Archive} bar
     * @param {object} options
     * @param {function(err, Archive)} callback
     * @protected
     */
    _runCommand(arg, bar, options, callback) {
        if (!callback) {
            callback = options;
            options = undefined;
        }
        try{
            const obj = JSON.parse(arg);
            if (typeof obj !== 'object')
                return callback(`Provided argument is not an object`);
            if (Array.isArray(obj)){
                console.log(`Object was already an array ${arg}`);
                callback(undefined, obj);
            }
            callback(undefined, JSON.stringify(Object.values(obj)));
        } catch (e) {
            _err(`Could not parse object. Was it a valid json?`, e, callback);
        }
    }
}

module.exports = ObjToArrayCommand;
},{"./Command":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/dt/commands/Command.js","./utils":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/dt/commands/utils.js"}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/dt/commands/readFile.js":[function(require,module,exports){
/**
 * @module Commands
 * @memberOf dt
 */

/**
 */
const Command = require('./Command');
const { _getFS, _err } = require('./utils')

/**
 * Reads The contents of a file from disk or from a sourceDSU
 *
 * supports sourceDSU
 *
 * @class ReadFileCommand
 */
class ReadFileCommand extends Command{
    constructor(varStore, source) {
        super(varStore, source ? source : _getFS());
        this.dataToString = !source;
    }

    /**
     * @param {string[]|string} command the command split into words
     * @param {string[]} next the following Commands
     * @param {function(err, string)} callback
     * @protected
     */
    _parseCommand(command, next, callback){
        if (!callback){
            callback = next;
            next = undefined;
        }
        callback(undefined, command);
    }

    /**
     * @param {Archive} bar unused in this method
     * @param {string} arg the command argument
     * @param {object} options
     * @param {function(err, Archive)} callback
     * @protected
     */
    _runCommand(arg, bar, options, callback){
        if (typeof options === 'function'){
            callback = options;
            options = undefined;
        }
        if (!callback) {
            callback = bar;
            bar = undefined
        }

        this.source.readFile(arg, (err, data) => err
            ? _err(`Could not read file at ${arg}`, err, callback)
            : callback(undefined, this.dataToString ? data : data.toString()));
    }
}

module.exports = ReadFileCommand;
},{"./Command":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/dt/commands/Command.js","./utils":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/dt/commands/utils.js"}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/dt/commands/utils.js":[function(require,module,exports){
/**
 * @module Commands
 */

/**
 * cache of node's fs object
 */

let _fileSystem = undefined;

/**
 * Caches and returns node's fs object if the environment is right
 * @return {fs}
 */
const _getFS = function () {
    if ($$.environmentType !== 'nodejs')
        throw new Error("Wrong environment for this function. Please make sure you know what you are doing...");
    if (!_fileSystem)
        _fileSystem = require('fs');
    return _fileSystem;
}

/**
 * Provides Util functions and Methods as well as caching for the open DSU resolver and {@Link DSUBuilder}
 */

let resolver, keyssi, sharedEnclave;

/**
 * Wrapper around
 * <pre>
 *     OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(msg, err));
 * </pre>
 * @param msg
 * @param err
 * @param callback
 * @protected
 */
const _err = function (msg, err, callback) {
    return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(msg, err));
}

/**
 * for singleton use
 * @returns {function} resolver api
 */
const _getResolver = function (callback) {
    if (!resolver) {
        const scAPI = require("opendsu").loadAPI("sc");
        if (!scAPI.sharedEnclaveExists()) {
            resolver = require('opendsu').loadApi('resolver');
            return callback(undefined, resolver);
        }
        _getSharedEnclave(callback);
        return;
    }
    callback(undefined, resolver);
}

/**
 * for singleton use
 * @returns {function} keyssi api
 */
const _getKeySSISpace = function () {
    if (!keyssi)
        keyssi = require('opendsu').loadApi('keyssi');
    return keyssi;
}

/**
 * for singleton use
 * @returns {function} sc api
 */
const _getSharedEnclave = function (callback) {
    if (!sharedEnclave) {
        const scAPI = require('opendsu').loadApi('sc');
        scAPI.getSharedEnclave((err, _sharedEnclave) => {
            if (err) {
                return callback(err);
            }

            sharedEnclave = _sharedEnclave;
            callback(undefined, sharedEnclave);
        })
        return;
    }
    callback(undefined, sharedEnclave);
}

const KEY_TYPE = {
    ARRAY: "array",
    SEED: "seed",
    WALLET: 'wallet'
}

const DSU_TYPE = {
    CONST: "const",
    WALLET: "wallet",
    SEED: "seed"
}

module.exports = {
    _getFS,
    _getResolver,
    _getKeySSISpace,
    _getSharedEnclave,
    _err,
    KEY_TYPE,
    DSU_TYPE
};
},{"fs":false,"opendsu":"opendsu"}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/dt/commands/with.js":[function(require,module,exports){
/**
 * @module Commands
 * @memberOf dt
 */

/**
 */
const Command = require('./Command');
const { _err } = require('./utils');
const endCommand = 'endwith';
const startCommand = 'with';



/**
 * Allows for more complex logic by allowing you to control the output/input for commands
 * while keeping the commands readable
 *
 * basically sets whatever the result of the with operation into the source portion until it finds the endwith command
 *
 * @class WithCommand
 */
class WithCommand extends Command {
    constructor(varStore, source) {
        super(varStore, source);
    }

    /**
     * @param {string[]|string} command the command split into words
     * @param {string[]} next the following Commands
     * @param {function(err, string|object)} [callback] for async versatility
     * @return {string|object} the command argument
     * @protected
     */
    _parseCommand(command, next, callback) {
        if (!next)
            throw new Error("No next defined");
        const commandsToConsider = [command];
        let cmd;
        let count = 0;
        while (!this._isEndCommand((cmd = next.shift())) && count === 0){
            let c = cmd.split(/\s+/);
            commandsToConsider.push(c);
            if (this._isStartCommand(c[0]))
                count++;
            if (this._isEndCommand(c[0]))
                count--;
        }

        commandsToConsider.push(cmd.split(/\s+/));
        callback(undefined, commandsToConsider);
    }

    _isStartCommand(cmd){
        return cmd.indexOf(startCommand) === 0;
    }

    _isEndCommand(cmd) {
        return cmd.indexOf(endCommand) === 0;
    }

    /**
     * @param {string[]} arg the command argument
     * @param {Archive} bar
     * @param {object} options
     * @param {function(err, Archive)} callback
     * @protected
     */
    _runCommand(arg, bar, options, callback) {
        let self = this;
        if (typeof options === 'function') {
            callback = options;
            options = undefined;
        }
        if (!callback){
            callback = bar;
            bar = undefined;
        }
        const _getByName = require('./Registry');

        const parseCommand = function(command, callback){
            const cmdName = command.shift();
            const actualCmd = _getByName(cmdName);
            if (!actualCmd)
                return callback(`Could not find command`);
            callback(undefined, cmdName, actualCmd, command);
        }

        const performWith = function(newSource, commands, callback){
            const cmd = commands.shift();
            if (!cmd)
                return callback(`No endWith command found. this should not be possible`);
            parseCommand(cmd, (err, cmdName, command, args) => {
                if (err)
                    return _err(`Could not parse the command ${cmd}`, err, callback);
                if (cmdName === endCommand)
                    return new command(self.varStore, self.source).execute(undefined, bar, callback);
                new command(self.varStore, self.source).execute(args, newSource, (err, result) => {
                    if (err)
                        return _err(`Could not execute command ${cmdName}`, err, callback);
                    console.log(`Command ${cmdName} executed with output ${JSON.stringify(result)}`);
                    performWith(newSource, commands, callback);
                });
            });
        }

        const cmdOrVar = arg[0][0];
        const cmd = _getByName(cmdOrVar);

        if (!cmd){
            console.log(`With VARIABLE executed: ${arg[0]}`);
            return performWith(arg.shift().shift(), arg, callback);
        }

        parseCommand(arg.shift(), (err, cmdName, command, args) => err
            ? _err(`Could not parse Command`, err, callback)
            : new (command)(self.varStore, self.source).execute(args, (err, result) => {
                if (err)
                    return _err(`Could not obtain result`, err, callback);
                console.log(`With COMMAND executed: ${JSON.stringify(result)}`);
                performWith(result, arg, callback);
            }));
    }
}

module.exports = WithCommand;
},{"./Command":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/dt/commands/Command.js","./Registry":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/dt/commands/Registry.js","./utils":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/dt/commands/utils.js"}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/dt/index.js":[function(require,module,exports){
/**
 * @module dt
 */


/**
 * Provides a Environment Independent and Versatile Dossier Building API.
 *
 * Meant to be integrated into OpenDSU
 */

/**
 * Returns a DossierBuilder Instance
 * @param {Archive} [sourceDSU] should only be provided when cloning a DSU
 * @param callback
 * @return {DossierBuilder}
 */
const getDossierBuilder = (sourceDSU) => {
    return new (require("./DossierBuilder"))(sourceDSU);
}

const initialiseBuildWallet = (callback) => {
    const BuildWallet = require("./BuildWallet");
    BuildWallet.initialiseWallet(callback);
}

module.exports = {
    getDossierBuilder,
    initialiseBuildWallet,
    Commands: require('./commands'),
    AppBuilderService: require('./AppBuilderService')
}

},{"./AppBuilderService":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/dt/AppBuilderService.js","./BuildWallet":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/dt/BuildWallet.js","./DossierBuilder":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/dt/DossierBuilder.js","./commands":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/dt/commands/index.js"}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/enclave/impl/APIHUBProxy.js":[function(require,module,exports){
const {createCommandObject} = require("./lib/createCommandObject");

function APIHUBProxy(domain, did) {
    const openDSU = require("opendsu");
    const http = openDSU.loadAPI("http");
    const system = openDSU.loadAPI("system");
    const w3cDID = openDSU.loadAPI("w3cdid");
    const scAPI = openDSU.loadAPI("sc");
    const CryptoSkills = w3cDID.CryptographicSkills;
    let initialised = false;
    const ProxyMixin = require("./ProxyMixin");
    ProxyMixin(this);
    let url;
    let didDocument;
    const init = async () => {
        if (typeof did === "undefined") {
            didDocument = CryptoSkills.applySkill("key", CryptoSkills.NAMES.CREATE_DID_DOCUMENT);
            didDocument.on("initialised", () => {
                did = didDocument.getIdentifier();
                url = `${system.getBaseURL()}/runEnclaveCommand/${domain}/${did}`;
                this.finishInitialisation();
                this.dispatchEvent("initialised");
            })
        } else {
            didDocument = await $$.promisify(w3cDID.resolveDID)(did);
            url = `${system.getBaseURL()}/runEnclaveCommand/${domain}/${did}`;
            this.finishInitialisation();
            this.dispatchEvent("initialised");
        }
    }

    this.isInitialised = ()=>{
        return initialised;
    }

    this.getDID = (callback) => {
        callback(undefined, did);
    }

    this.__putCommandObject = (commandName, ...args) => {
        const callback = args.pop();
        const command = createCommandObject(commandName, ...args);
        http.doPut(url, JSON.stringify(command), callback);
    }

    const bindAutoPendingFunctions = require(".././../utils/BindAutoPendingFunctions").bindAutoPendingFunctions;
    bindAutoPendingFunctions(this, ["__putCommandObject", "isInitialised", "on", "off"]);
    init();
}

module.exports = APIHUBProxy;
},{".././../utils/BindAutoPendingFunctions":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/utils/BindAutoPendingFunctions.js","./ProxyMixin":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/enclave/impl/ProxyMixin.js","./lib/createCommandObject":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/enclave/impl/lib/createCommandObject.js","opendsu":"opendsu"}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/enclave/impl/Enclave_Mixin.js":[function(require,module,exports){
const constants = require("./constants");

function Enclave_Mixin(target, did, keySSI) {
    const openDSU = require("opendsu");
    const keySSISpace = openDSU.loadAPI("keyssi")
    const w3cDID = openDSU.loadAPI("w3cdid")
    const errorAPI = openDSU.loadAPI("error");

    const ObservableMixin = require("../../utils/ObservableMixin");
    ObservableMixin(target);
    const CryptoSkills = w3cDID.CryptographicSkills;

    let pathKeyMapping;

    const getPrivateInfoForDID = (did, callback) => {
        target.storageDB.getRecord(constants.TABLE_NAMES.DIDS_PRIVATE_KEYS, did, (err, record) => {
            if (err) {
                return callback(err);
            }

            const privateKeysAsBuff = record.privateKeys.map(privateKey => {
                if (privateKey) {
                    return $$.Buffer.from(privateKey)
                }

                return privateKey;
            });
            callback(undefined, privateKeysAsBuff);
        });
    };

    const getCapableOfSigningKeySSI = (keySSI, callback) => {
        if (typeof keySSI === "undefined") {
            return callback(Error(`A SeedSSI should be specified.`));
        }

        if (typeof keySSI === "string") {
            try {
                keySSI = keySSISpace.parse(keySSI);
            } catch (e) {
                return callback(createOpenDSUErrorWrapper(`Failed to parse keySSI ${keySSI}`, e))
            }
        }

        target.storageDB.getRecord(constants.TABLE_NAMES.KEY_SSIS, keySSI.getIdentifier(), (err, record) => {
            if (err) {
                return callback(createOpenDSUErrorWrapper(`No capable of signing keySSI found for keySSI ${keySSI.getIdentifier()}`, err));
            }

            let capableOfSigningKeySSI;
            try {
                capableOfSigningKeySSI = keySSISpace.parse(record.capableOfSigningKeySSI);
            } catch (e) {
                return callback(createOpenDSUErrorWrapper(`Failed to parse keySSI ${record.capableOfSigningKeySSI}`, e))
            }

            callback(undefined, capableOfSigningKeySSI);
        });
    };

    const getPathKeyMapping = (callback) => {
        if (pathKeyMapping) {
            return callback(undefined, pathKeyMapping);
        }

        const EnclaveHandler = require("./WalletDBEnclaveHandler");
        const PathKeyMapping = require("../impl/PathKeyMapping");

        try {
            target.getKeySSI((err, keySSI) => {
                if (err) {
                    return callback(err);
                }

                const enclaveHandler = new EnclaveHandler(keySSI);
                pathKeyMapping = new PathKeyMapping(enclaveHandler);
                callback(undefined, pathKeyMapping);
            })
        } catch (e) {
            return callback(e);
        }
    }

    target.getDID = (callback) => {
        if (!did) {
            did = CryptoSkills.applySkill("key", CryptoSkills.NAMES.CREATE_DID_DOCUMENT);
            did.on("initialised", () => {
                did = did.getIdentifier();
                callback(undefined, did);
            })
        } else {
            callback(undefined, did);
        }
    }

    target.refresh = (forDID, callback) => {
        if (typeof forDID === "function") {
            callback = forDID;
            forDID = undefined;
        }

        target.storageDB.refresh(callback);
    }

    target.getPrivateKeyForSlot = (forDID, slot, callback) => {
        if (typeof slot === "function") {
            callback = slot;
            slot = forDID;
            forDID = undefined;
        }
        target.storageDB.getRecord(constants.TABLE_NAMES.PATH_KEY_SSI_PRIVATE_KEYS, slot, (err, privateKeyRecord) => {
            if (err) {
                return callback(err);
            }
            let privateKey;
            try {
                privateKey = $$.Buffer.from(privateKeyRecord.privateKey);
            } catch (e) {
                return callback(e);
            }

            callback(undefined, privateKey);
        });
    };

    target.addIndex = (forDID, table, field, forceReindex, callback) => {
        if (typeof forceReindex === "function") {
            callback = forceReindex;
            forceReindex = false;
        }
        target.storageDB.addIndex(table, field, forceReindex, callback);
    }

    target.getIndexedFields = (forDID, table, callback) => {
        target.storageDB.getIndexedFields(table, callback);
    }

    target.insertRecord = (forDID, table, pk, plainRecord, encryptedRecord, callback) => {
        if (typeof encryptedRecord === "function") {
            callback = encryptedRecord;
            encryptedRecord = plainRecord;
        }
        target.storageDB.insertRecord(table, pk, encryptedRecord, callback);
    }

    target.updateRecord = (forDID, table, pk, plainRecord, encryptedRecord, callback) => {
        if (typeof encryptedRecord === "function") {
            callback = encryptedRecord;
            encryptedRecord = plainRecord;
        }
        target.storageDB.updateRecord(table, pk, encryptedRecord, callback);
    }

    target.getRecord = (forDID, table, pk, callback) => {
        target.storageDB.getRecord(table, pk, callback);
    };

    target.filter = (forDID, table, filter, sort, limit, callback) => {
        target.storageDB.filter(table, filter, sort, limit, callback);
    }

    target.deleteRecord = (forDID, table, pk, callback) => {
        target.storageDB.deleteRecord(table, pk, callback);
    }

    target.beginBatch = (forDID) => {
        target.storageDB.beginBatch();
    }

    target.commitBatch = (forDID, callback) => {
        target.storageDB.commitBatch(callback);
    }

    target.cancelBatch = (forDID, callback) => {
        target.storageDB.cancelBatch(callback);
    }

    target.readKey = (forDID, key, callback) => {
        target.storageDB.readKey(key, callback);
    }

    target.writeKey = (forDID, key, value, callback) => {
        target.storageDB.writeKey(key, value, callback);
    }

    target.getAllRecords = (forDID, tableName, callback) => {
        target.storageDB.getAllRecords(tableName, callback);
    }

    target.storeSeedSSI = (forDID, seedSSI, alias, callback) => {
        if (typeof seedSSI === "string") {
            try {
                seedSSI = keySSISpace.parse(seedSSI);
            } catch (e) {
                return callback(createOpenDSUErrorWrapper(`Failed to parse keySSI ${seedSSI}`, e))
            }
        }

        if (typeof alias === "function") {
            callback = alias;
            alias = undefined;
        }

        if (typeof alias === "undefined") {
            const generateUid = require("swarmutils").generateUid;
            alias = generateUid(10).toString("hex");
        }

        const keySSIIdentifier = seedSSI.getIdentifier();
        const isExistingKeyError = (error) => error.originalMessage === errorAPI.DB_INSERT_EXISTING_RECORD_ERROR;

        function registerDerivedKeySSIs(derivedKeySSI, sReadSSIIdentifier) {
            target.storageDB.insertRecord(constants.TABLE_NAMES.KEY_SSIS, derivedKeySSI.getIdentifier(), {capableOfSigningKeySSI: keySSIIdentifier}, (err) => {
                if (err && !isExistingKeyError(err)) {
                    // ignore if KeySSI is already present
                    return callback(err);
                }
                target.storageDB.insertRecord(constants.TABLE_NAMES.SREAD_SSIS, derivedKeySSI.getIdentifier(), {sReadSSI: sReadSSIIdentifier}, (err) => {
                    if (err && !isExistingKeyError(err)) {
                        // ignore if sReadSSI is already present
                        return callback(err);
                    }

                    if (typeof derivedKeySSI.derive !== "function") {
                        return callback();
                    }

                    derivedKeySSI.derive((err, _derivedKeySSI) => {
                        if (err) {
                            return callback(err);
                        }

                        registerDerivedKeySSIs(_derivedKeySSI, sReadSSIIdentifier);
                    })

                });
            });
        }

        seedSSI.derive((err, sReadSSI) => {
            if (err) {
                return callback(err);
            }

            const sReadSSIIdentifier = sReadSSI.getIdentifier();
            return registerDerivedKeySSIs(seedSSI, sReadSSIIdentifier);
        })
    }

    target.storeKeySSI = (forDID, keySSI, callback) => {
        if (typeof keySSI === "function") {
            callback = keySSI;
            keySSI = forDID;
            forDID = undefined;
        }

        if (typeof keySSI === "string") {
            try {
                keySSI = keySSISpace.parse(keySSI);
            } catch (e) {
                return callback(createOpenDSUErrorWrapper(`Failed to parse keySSI ${keySSI}`, e))
            }
        }

        if (keySSI.getTypeName() === openDSU.constants.KEY_SSIS.PATH_SSI) {
            return getPathKeyMapping((err, pathKeyMapping) => {
                if (err) {
                    return callback(err);
                }

                pathKeyMapping.storePathKeySSI(keySSI, callback);
            })
        }

        if (keySSI.getTypeName() === openDSU.constants.KEY_SSIS.SEED_SSI) {
            return target.storeSeedSSI(forDID, keySSI, undefined, callback);
        }
        const keySSIIdentifier = keySSI.getIdentifier();

        target.storageDB.insertRecord(constants.TABLE_NAMES.KEY_SSIS, keySSIIdentifier, {keySSI: keySSIIdentifier}, callback)
    }

    target.storeReadForAliasSSI = (forDID, sReadSSI, aliasSSI, callback) => {
        if (typeof sReadSSI === "string") {
            try {
                sReadSSI = keySSISpace.parse(sReadSSI);
            } catch (e) {
                return callback(createOpenDSUErrorWrapper(`Failed to parse SReadSSI ${sReadSSI}`, e))
            }
        }

        if (typeof aliasSSI === "string") {
            try {
                aliasSSI = keySSISpace.parse(aliasSSI);
            } catch (e) {
                return callback(createOpenDSUErrorWrapper(`Failed to parse SReadSSI ${aliasSSI}`, e))
            }
        }
        const keySSIIdentifier = sReadSSI.getIdentifier();
        target.storageDB.insertRecord(constants.TABLE_NAMES.SREAD_SSIS, aliasSSI.getIdentifier(), {sReadSSI: keySSIIdentifier}, callback)
    }

    target.getReadForKeySSI = (forDID, keySSI, callback) => {
        if (typeof keySSI === "function") {
            callback = keySSI;
            keySSI = forDID;
            forDID = undefined;
        }

        if (typeof keySSI === "string") {
            try {
                keySSI = keySSISpace.parse(keySSI);
            } catch (e) {
                return callback(createOpenDSUErrorWrapper(`Failed to parse keySSI ${keySSI}`, e))
            }
        }

        getPathKeyMapping((err, pathKeyMapping) => {
            if (err) {
                return target.storageDB.getRecord(constants.TABLE_NAMES.SREAD_SSIS, keySSI.getIdentifier(), (err, record) => {
                    if (err) {
                        return callback(err);
                    }

                    callback(undefined, record.sReadSSI);
                });
            }

            pathKeyMapping.getReadForKeySSI(keySSI, (err, readKeySSI) => {
                if (err) {
                    return target.storageDB.getRecord(constants.TABLE_NAMES.SREAD_SSIS, keySSI.getIdentifier(), (err, record) => {
                        if (err) {
                            return callback(err);
                        }

                        callback(undefined, record.sReadSSI);
                    });
                }

                callback(undefined, readKeySSI);
            })
        })
    }

    target.storeDID = (forDID, storedDID, privateKeys, callback) => {
        if (typeof privateKeys === "function") {
            callback = privateKeys;
            privateKeys = storedDID;
            storedDID = forDID;
        }
        if (!Array.isArray(privateKeys)) {
            privateKeys = [privateKeys];
        }

        target.storageDB.getRecord(constants.TABLE_NAMES.DIDS_PRIVATE_KEYS, storedDID.getIdentifier(), (err, res) => {
            if (err || !res) {
                return target.storageDB.insertRecord(constants.TABLE_NAMES.DIDS_PRIVATE_KEYS, storedDID.getIdentifier(), {privateKeys: privateKeys}, callback);
            }

            privateKeys.forEach(privateKey => {
                res.privateKeys.push(privateKey);
            })
            target.storageDB.updateRecord(constants.TABLE_NAMES.DIDS_PRIVATE_KEYS, storedDID.getIdentifier(), res, callback);
        });
    }

    target.addPrivateKeyForDID = (didDocument, privateKey, callback) => {
        const privateKeyObj = {privateKeys: [privateKey]}
        target.storageDB.getRecord(constants.TABLE_NAMES.DIDS_PRIVATE_KEYS, didDocument.getIdentifier(), (err, res) => {
            if (err || !res) {
                return target.storageDB.insertRecord(constants.TABLE_NAMES.DIDS_PRIVATE_KEYS, didDocument.getIdentifier(), privateKeyObj, callback);
            }

            res.privateKeys.push(privateKey);
            target.storageDB.updateRecord(constants.TABLE_NAMES.DIDS_PRIVATE_KEYS, didDocument.getIdentifier(), res, callback);
        });
    }

    target.generateDID = (forDID, didMethod, ...args) => {
        args.unshift(target, didMethod);
        w3cDID.we_createIdentity(...args);
    }

    target.storePrivateKey = (forDID, privateKey, type, alias, callback) => {
        if (typeof alias == "function") {
            callback = alias;
            alias = undefined;
        }

        if (typeof alias === "undefined") {
            const generateUid = require("swarmutils").generateUid;
            alias = generateUid(10).toString("hex");
        }

        target.storageDB.insertRecord(constants.TABLE_NAMES.PRIVATE_KEYS, alias, {
            privateKey: privateKey,
            type: type
        }, callback)

    }

    target.storeSecretKey = (forDID, secretKey, alias, callback) => {
        if (typeof alias == "function") {
            callback = alias;
            alias = undefined;
        }

        if (typeof alias === "undefined") {
            const generateUid = require("swarmutils").generateUid;
            alias = generateUid(10).toString("hex");
        }

        target.storageDB.insertRecord(constants.TABLE_NAMES.SECRET_KEYS, alias, {secretKey: secretKey}, callback)
    };

    target.generateSecretKey = (forDID, secretKeyAlias, callback) => {
        if (typeof secretKeyAlias == "function") {
            callback = secretKeyAlias;
            secretKeyAlias = undefined;
        }

        if (typeof secretKeyAlias === "undefined") {
            const generateUid = require("swarmutils").generateUid;
            secretKeyAlias = generateUid(10).toString("hex");
        }

        const crypto = openDSU.loadAPI("crypto");
        const key = crypto.generateRandom(32);

        target.storeSecretKey(forDID, key, secretKeyAlias, callback);
    }

    target.signForDID = (forDID, didThatIsSigning, hash, callback) => {
        if (typeof hash === "function") {
            callback = hash;
            hash = didThatIsSigning;
            didThatIsSigning = forDID;
        }

        const privateKeys = didThatIsSigning.getPrivateKeys();
        if (typeof privateKeys[privateKeys.length - 1] === "undefined") {
            return getPrivateInfoForDID(didThatIsSigning.getIdentifier(), async (err, privateKeys) => {
                if (err) {
                    return callback(createOpenDSUErrorWrapper(`Failed to get private info for did ${didThatIsSigning.getIdentifier()}`, err));
                }

                const signature = CryptoSkills.applySkill(didThatIsSigning.getMethodName(), CryptoSkills.NAMES.SIGN, hash, privateKeys[privateKeys.length - 1]);
                callback(undefined, signature);
            });
        }

        const signature = CryptoSkills.applySkill(didThatIsSigning.getMethodName(), CryptoSkills.NAMES.SIGN, hash, privateKeys[privateKeys.length - 1]);
        callback(undefined, signature);
    }

    target.verifyForDID = (forDID, didThatIsVerifying, hash, signature, callback) => {
        if (typeof hash === "function") {
            callback = signature;
            signature = hash;
            hash = didThatIsVerifying;
            didThatIsVerifying = forDID;
        }
        didThatIsVerifying.getPublicKey("pem", (err, publicKey) => {
            if (err) {
                return callback(createOpenDSUErrorWrapper(`Failed to read public key for did ${target.getIdentifier()}`, err));
            }

            const verificationResult = CryptoSkills.applySkill(didThatIsVerifying.getMethodName(), CryptoSkills.NAMES.VERIFY, hash, publicKey, signature);
            callback(undefined, verificationResult);
        });
    }

    target.signForKeySSI = (forDID, keySSI, hash, callback) => {
        const __signHashForKeySSI = (keySSI, hash) => {
            getCapableOfSigningKeySSI(keySSI, (err, capableOfSigningKeySSI) => {
                if (err) {
                    return callback(err);
                }
                if (typeof capableOfSigningKeySSI === "undefined") {
                    return callback(Error(`The provided SSI does not grant writing rights`));
                }

                capableOfSigningKeySSI.sign(hash, callback);
            });
        }
        getPathKeyMapping((err, pathKeyMapping) => {
            if (err) {
                return __signHashForKeySSI(keySSI, hash);
            }

            pathKeyMapping.getCapableOfSigningKeySSI(keySSI, (err, capableOfSigningKeySSI) => {
                if (err) {
                    return __signHashForKeySSI(keySSI, hash);
                }

                capableOfSigningKeySSI.sign(hash, callback);
            })
        })
    }

    target.encryptAES = (forDID, secretKeyAlias, message, AESParams, callback) => {

        if (typeof AESParams == "function") {
            callback = AESParams;
            AESParams = undefined;
        }

        target.storageDB.getRecord(constants.TABLE_NAMES.SECRET_KEYS, secretKeyAlias, (err, keyRecord) => {
            if (err !== undefined) {
                callback(err, undefined);
                return;
            }
            const crypto = require("pskcrypto"); // opendsu crypto does not receive aes options
            const pskEncryption = crypto.createPskEncryption('aes-256-gcm');

            const encryptedMessage = pskEncryption.encrypt(message, keyRecord.secretKey, AESParams);
            callback(undefined, encryptedMessage);
        })

    }

    target.decryptAES = (forDID, secretKeyAlias, encryptedMessage, AESParams, callback) => {

        if (typeof AESParams == "function") {
            callback = AESParams;
            AESParams = undefined;
        }

        target.storageDB.getRecord(constants.TABLE_NAMES.SECRET_KEYS, secretKeyAlias, (err, keyRecord) => {
            if (err !== undefined) {
                callback(err, undefined);
                return;
            }
            const crypto = require("pskcrypto"); // opendsu crypto does not receive aes options
            const pskEncryption = crypto.createPskEncryption('aes-256-gcm');

            const decryptedMessage = pskEncryption.decrypt(encryptedMessage, keyRecord.secretKey, 0, AESParams);
            callback(undefined, decryptedMessage);
        })

    }

    target.encryptMessage = (forDID, didFrom, didTo, message, callback) => {
        if (typeof message === "function") {
            callback = message;
            message = didTo;
            didTo = didFrom;
            didFrom = forDID;
        }
        getPrivateInfoForDID(didFrom.getIdentifier(), (err, privateKeys) => {
            if (err) {
                return callback(createOpenDSUErrorWrapper(`Failed to get private info for did ${didFrom.getIdentifier()}`, err));
            }

            CryptoSkills.applySkill(didFrom.getMethodName(), CryptoSkills.NAMES.ENCRYPT_MESSAGE, privateKeys, didFrom, didTo, message, callback);
        });
    }

    target.decryptMessage = (forDID, didTo, encryptedMessage, callback) => {
        if (typeof encryptedMessage === "function") {
            callback = encryptedMessage;
            encryptedMessage = didTo;
            didTo = forDID;
        }
        getPrivateInfoForDID(didTo.getIdentifier(), (err, privateKeys) => {
            if (err) {
                return callback(createOpenDSUErrorWrapper(`Failed to get private info for did ${didTo.getIdentifier()}`, err));
            }

            CryptoSkills.applySkill(didTo.getMethodName(), CryptoSkills.NAMES.DECRYPT_MESSAGE, privateKeys, didTo, encryptedMessage, callback);
        });
    };


    // expose keyssi APIs
    Object.keys(keySSISpace).forEach(fnName => {
        if (fnName.startsWith("we_")) {
            const trimmedFnName = fnName.slice(3);
            target[trimmedFnName] = (...args) => {
                args.shift();
                args.unshift(target);
                keySSISpace[fnName](...args);
            }
        } else if (fnName.startsWith("createTemplate")) {
            target[fnName] = (...args) => {
                args.shift();
                keySSISpace[fnName](...args);
            }
        }
    })

    // expose w3cdid APIs
    Object.keys(w3cDID).forEach(fnName => {
        if (fnName.startsWith("we_")) {
            const trimmedFnName = fnName.slice(3);
            target[trimmedFnName] = (...args) => {
                args.shift();
                args.unshift(target);
                w3cDID[fnName](...args);
            }
        }
    })

    const resolverAPI = openDSU.loadAPI("resolver");

    target.createDSU = (forDID, keySSI, options, callback) => {
        if (typeof options === "function") {
            callback = options;
            options = undefined;
        }
        if (typeof keySSI === "string") {
            try {
                keySSI = keySSISpace.parse(keySSI);
            } catch (e) {
                return callback(e);
            }
        }

        if (keySSI.isAlias()) {
            const scAPI = require("opendsu").loadAPI("sc");
            scAPI.getVaultDomain(async (err, vaultDomain) => {
                if (err) {
                    return callback(err);
                }

                let seedSSI;
                try {
                    seedSSI = await $$.promisify(target.createSeedSSI)(target, vaultDomain);
                    const sReadSSI = await $$.promisify(seedSSI.derive)();
                    await $$.promisify(target.storeReadForAliasSSI)(undefined, sReadSSI, keySSI);
                } catch (e) {
                    return callback(e);
                }

                resolverAPI.createDSUForExistingSSI(seedSSI, callback);
            })
            return
        }

        if (keySSI.withoutCryptoData()) {
            target.createSeedSSI(undefined, keySSI.getDLDomain(), (err, seedSSI) => {
                if (err) {
                    return callback(err);
                }

                resolverAPI.createDSUForExistingSSI(seedSSI, callback);
            })
        } else {
            target.storeKeySSI(undefined, keySSI, (err) => {
                if (err) {
                    return callback(err);
                }

                resolverAPI.createDSU(keySSI, options, callback);
            })
        }
    }

    target.loadDSU = (forDID, keySSI, options, callback) => {
        if (typeof options === "function") {
            callback = options;
            options = undefined;
        }
        if (typeof keySSI === "string") {
            try {
                keySSI = keySSISpace.parse(keySSI);
            } catch (e) {
                return callback(e);
            }
        }

        resolverAPI.loadDSU(keySSI, options, (err, dsu) => {
            if (err) {
                target.getReadForKeySSI(undefined, keySSI.getIdentifier(), (err, sReadSSI) => {
                    if (err) {
                        return callback(err);
                    }
                    resolverAPI.loadDSU(sReadSSI, options, callback);
                });

                return;
            }

            callback(undefined, dsu);
        })
    }

    target.loadDSURecoveryMode = (forDID, ssi, contentRecoveryFnc, callback) => {
        target.loadDSU(forDID, ssi, {contentRecoveryFnc, recoveryMode: true}, callback);
    }
}

module.exports = Enclave_Mixin;
},{"../../utils/ObservableMixin":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/utils/ObservableMixin.js","../impl/PathKeyMapping":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/enclave/impl/PathKeyMapping.js","./WalletDBEnclaveHandler":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/enclave/impl/WalletDBEnclaveHandler.js","./constants":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/enclave/impl/constants.js","opendsu":"opendsu","pskcrypto":"pskcrypto","swarmutils":"swarmutils"}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/enclave/impl/HighSecurityProxy.js":[function(require,module,exports){
(function (Buffer){(function (){
const {createCommandObject} = require("./lib/createCommandObject");

function HighSecurityProxy(domain, did) {
    const openDSU = require("opendsu");
    const system = openDSU.loadAPI("system");
    const w3cDID = openDSU.loadAPI("w3cdid");
    const http = openDSU.loadAPI("http");
    const crypto = openDSU.loadAPI("crypto");
    const scAPI = openDSU.loadAPI("sc");
    const CryptoSkills = w3cDID.CryptographicSkills;
    let didDocument;
    const ProxyMixin = require("./ProxyMixin");
    ProxyMixin(this);

    const init = async () => {
        if (typeof domain === "undefined") {
            domain = await $$.promisify(scAPI.getVaultDomain)();
        }
        if (typeof did === "undefined") {
            didDocument = CryptoSkills.applySkill("key", CryptoSkills.NAMES.CREATE_DID_DOCUMENT);
            didDocument.on("initialised", () => {
                did = didDocument.getIdentifier();
                this.url = `${system.getBaseURL()}/runEnclaveEncryptedCommand/${domain}/${did}`;
                this.finishInitialisation();
                this.dispatchEvent("initialised");
            })
        } else {
            didDocument = await $$.promisify(w3cDID.resolveDID)(did);
            this.url = `${system.getBaseURL()}/runEnclaveEncryptedCommand/${domain}/${did}`;
            this.finishInitialisation();
            this.dispatchEvent("initialised");
        }
    }

    this.getDID = (callback) => {
        callback(undefined, did);
    }

    this.__putCommandObject = (commandName, ...args) => {
        const callback = args.pop();
        const command = createCommandObject(commandName, ...args);
        didDocument.getPublicKey("raw", (err, publicKey) => {
            if (err) {
                return callback(err);
            }

            const encryptionKey = crypto.deriveEncryptionKey(publicKey);
            const encryptedCommand = crypto.encrypt(Buffer.from(JSON.stringify(command)), encryptionKey);
            http.doPut(this.url, encryptedCommand, callback);
        })
    }

    const bindAutoPendingFunctions = require(".././../utils/BindAutoPendingFunctions").bindAutoPendingFunctions;
    bindAutoPendingFunctions(this, ["__putCommandObject", "on", "off"]);
    init();
}

module.exports = HighSecurityProxy;
}).call(this)}).call(this,require("buffer").Buffer)

},{".././../utils/BindAutoPendingFunctions":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/utils/BindAutoPendingFunctions.js","./ProxyMixin":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/enclave/impl/ProxyMixin.js","./lib/createCommandObject":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/enclave/impl/lib/createCommandObject.js","buffer":false,"opendsu":"opendsu"}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/enclave/impl/MemoryEnclave.js":[function(require,module,exports){
function MemoryEnclave() {
    const EnclaveMixin = require("./Enclave_Mixin");
    EnclaveMixin(this);
    const openDSU = require("opendsu");
    const db = openDSU.loadAPI("db");
    let initialised = false;
    const init = () => {
        this.storageDB = db.getInMemoryDB();
        setTimeout(async () => {
            initialised = true;
            this.dispatchEvent("initialised");
        })
    }

    this.getEnclaveType = () => {
        return openDSU.constants.ENCLAVE_TYPES.MEMORY_ENCLAVE;
    };

    this.isInitialised = () => {
        return initialised
    }

    init();
}

module.exports = MemoryEnclave;
},{"./Enclave_Mixin":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/enclave/impl/Enclave_Mixin.js","opendsu":"opendsu"}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/enclave/impl/PathKeyMapping.js":[function(require,module,exports){
function PathKeyMapping(enclaveHandler) {
    const utils = require("./utils");
    const openDSU = require("opendsu");
    const utilsAPI = openDSU.loadAPI("utils");
    const keySSISpace = openDSU.loadAPI("keyssi");
    let pathKeysMapping = {};
    let initialised = false;
    const init = async () => {
        let paths = await $$.promisify(enclaveHandler.loadPaths)();
        pathKeysMapping = await $$.promisify(utils.getKeySSIsMappingFromPathKeys)(paths);

        this.finishInitialisation();
    };

    this.isInitialised = () => {
        return initialised;
    };

    this.storePathKeySSI = (pathKeySSI, callback) => {
        if (typeof pathKeySSI === "string") {
            try {
                pathKeySSI = keySSISpace.parse(pathKeySSI);
            } catch (e) {
                return callback(e);
            }
        }
        pathKeySSI = pathKeySSI.getIdentifier();

        const storePathKeySSI = () => {
            enclaveHandler.storePathKeySSI(pathKeySSI, async err => {
                if (err) {
                    return callback(err);
                }
                try {
                    const derivedKeySSIs = await $$.promisify(utils.getKeySSIMapping)(pathKeySSI);
                    pathKeysMapping = utils.mergeMappings(pathKeysMapping, derivedKeySSIs);
                    callback();
                } catch (e) {
                    callback(e);
                }
            });
        }
        storePathKeySSI();
    };

    this.getCapableOfSigningKeySSI = (keySSI, callback) => {
        if (typeof keySSI === "string") {
            try {
                keySSI = keySSISpace.parse(keySSI);
            } catch (e) {
                return callback(e);
            }
        }
        keySSI = keySSI.getIdentifier();
        let capableOfSigningKeySSI
        try {
            capableOfSigningKeySSI = pathKeysMapping[openDSU.constants.KEY_SSIS.SEED_SSI][keySSI];
        } catch (e) {
            return callback(e);
        }

        if (typeof capableOfSigningKeySSI === "undefined") {
            return callback(Error("The provided key SSI does not have write privileges."));
        }

        try {
            capableOfSigningKeySSI = keySSISpace.parse(capableOfSigningKeySSI);
        } catch (e) {
            return callback(e);
        }
        callback(undefined, capableOfSigningKeySSI);
    };

    this.getReadForKeySSI = (keySSI, callback) => {
        if (typeof keySSI === "string") {
            try {
                keySSI = keySSISpace.parse(keySSI);
            } catch (e) {
                return callback(e);
            }
        }
        keySSI = keySSI.getIdentifier();
        let readKeySSI
        try {
            readKeySSI = pathKeysMapping[openDSU.constants.KEY_SSIS.SREAD_SSI][keySSI];
        } catch (e) {
            return callback(e);
        }

        if (typeof readKeySSI === "undefined") {
            return callback(Error("The provided key SSI does not have read privileges."));
        }

        try {
            readKeySSI = keySSISpace.parse(readKeySSI);
        } catch (e) {
            return callback(e);
        }

        callback(undefined, readKeySSI);
    }

    this._getMapping = (callback) => {
        callback(undefined, pathKeysMapping);
    };

    utilsAPI.bindAutoPendingFunctions(this);
    init();
}

module.exports = PathKeyMapping;
},{"./utils":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/enclave/impl/utils.js","opendsu":"opendsu"}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/enclave/impl/ProxyMixin.js":[function(require,module,exports){
(function (Buffer){(function (){
const {createOpenDSUErrorWrapper} = require("../../error");

function ProxyMixin(target) {
    const commandNames = require("./lib/commandsNames");
    const ObservableMixin = require("../../utils/ObservableMixin");
    ObservableMixin(target);

    target.insertRecord = (forDID, table, pk, plainRecord, encryptedRecord, callback) => {
        if (typeof encryptedRecord === "function") {
            callback = encryptedRecord;
            encryptedRecord = undefined;
        }
        target.__putCommandObject(commandNames.INSERT_RECORD, forDID, table, pk, plainRecord, callback);
    };

    target.updateRecord = (forDID, table, pk, plainRecord, encryptedRecord, callback) => {
        if (typeof encryptedRecord === "function") {
            callback = encryptedRecord;
            encryptedRecord = undefined;
        }
        target.__putCommandObject(commandNames.UPDATE_RECORD, forDID, table, pk, plainRecord, callback);
    }

    target.getRecord = (forDID, table, pk, callback) => {
        target.__putCommandObject(commandNames.GET_RECORD, forDID, table, pk, (err, record) => {
            if (err) {
                return callback(createOpenDSUErrorWrapper(`Failed to get record with pk ${pk}`, err));
            }

            try {
                record = JSON.parse(record);
            } catch (e) {
                return callback(createOpenDSUErrorWrapper(`Failed to parse record with pk ${pk}`, e));
            }

            callback(undefined, record);
        });
    };

    target.filter = (forDID, table, filter, sort, limit, callback) => {
        if (typeof filter === "function") {
            callback = filter;
            filter = undefined;
            sort = undefined;
            limit = undefined;
        }

        if (typeof sort === "function") {
            callback = sort;
            sort = undefined;
            limit = undefined;
        }

        if (typeof limit === "function") {
            callback = limit;
            limit = undefined;
        }
        target.__putCommandObject(commandNames.FILTER_RECORDS, forDID, table, filter, sort, limit, (err, records) => {
            if (err) {
                return callback(createOpenDSUErrorWrapper(`Failed to filter records in table ${table}`, err));
            }

            try {
                records = JSON.parse(records);
            } catch (e) {
                return callback(createOpenDSUErrorWrapper(`Failed to parse record `, e));
            }

            callback(undefined, records);
        });
    }

    target.getAllRecords = (forDID, table, callback) => {
        target.__putCommandObject(commandNames.GET_ALL_RECORDS, forDID, table, (err, records) => {
            if (err) {
                return callback(err);
            }

            try {
                records = JSON.parse(records);
            } catch (e) {
                return callback(createOpenDSUErrorWrapper(`Failed to parse record`, e));
            }

            callback(undefined, records);
        });
    }

    target.deleteRecord = (forDID, table, pk, callback) => {
        target.__putCommandObject(commandNames.DELETE_RECORD, forDID, table, pk, callback);
    }

    target.addInQueue = (forDID, queueName, encryptedObject, callback) => {
        target.__putCommandObject(commandNames.ADD_IN_QUEUE, forDID, queueName, encryptedObject, callback);
    }

    target.queueSize = (forDID, queueName, callback) => {
        target.__putCommandObject(commandNames.QUEUE_SIZE, forDID, queueName, callback);
    }

    target.listQueue = (forDID, queueName, sortAfterInsertTime, onlyFirstN, callback) => {
        target.__putCommandObject(commandNames.LIST_QUEUE, forDID, queueName, sortAfterInsertTime, onlyFirstN, callback);
    };

    target.getObjectFromQueue = (forDID, queueName, hash, callback) => {
        target.__putCommandObject(commandNames.GET_OBJECT_FROM_QUEUE, forDID, queueName, hash, callback);
    }

    target.deleteObjectFromQueue = (forDID, queueName, hash, callback) => {
        target.__putCommandObject(commandNames.DELETE_OBJECT_FROM_QUEUE, forDID, queueName, hash, callback);
    }

    target.beginBatch = (forDID, callback) => {
        callback(undefined);
    }

    target.cancelBatch = (forDID, callback) => {
        callback(undefined);
    }

    target.commitBatch = (forDID, callback) => {
        callback(undefined);
    }

    target.readKey = (forDID, key, callback) => {
        target.__putCommandObject(commandNames.READ_KEY, forDID, key, (err, serializedValue) => {
            if (err) {
                return callback(err);
            }
            let value;
            try {
                serializedValue = JSON.parse(serializedValue);
            } catch (e) {
                return callback(createOpenDSUErrorWrapper(`Failed to parse value`, e));
            }
            switch (serializedValue.type) {
                case "buffer":
                    value = Buffer.from(serializedValue.value);
                    break;
                case "object":
                    value = JSON.parse(serializedValue.value);
                    break;
                default:
                    value = serializedValue.value;
            }
            callback(undefined, value);
        });
    }

    target.writeKey = (forDID, key, value, callback) => {
        target.__putCommandObject(commandNames.WRITE_KEY, forDID, key, value, callback);
    }

    target.storeSeedSSI = (forDID, seedSSI, alias, callback) => {
        target.__putCommandObject(commandNames.STORE_SEED_SSI, forDID, seedSSI.getIdentifier(), alias, callback);
    }

    target.storeDID = (forDID, storedDID, privateKeys, callback) => {
        target.__putCommandObject(commandNames.STORE_DID, forDID.getIdentifier(), storedDID.getIdentifier(), privateKeys, callback);
    }

    target.signForDID = (forDID, didThatIsSigning, hash, callback) => {
        target.__putCommandObject(commandNames.SIGN_FOR_DID, forDID.getIdentifier(), didThatIsSigning.getIdentifier(), hash, (err, signature) => {
            if (err) {
                return callback(err);
            }

            callback(undefined, $$.Buffer.from(JSON.parse(signature)));
        });
    }

    target.verifyForDID = (forDID, didThatIsVerifying, hash, signature, callback) => {
        target.__putCommandObject(commandNames.VERIFY_FOR_DID, forDID.getIdentifier(), didThatIsVerifying.getIdentifier(), hash, signature, (err, verificationResult) => {
            if (err) {
                return callback(err);
            }

            callback(undefined, verificationResult);
        });
    }

    target.signForKeySSI = (forDID, keySSI, hash, callback) => {
        target.__putCommandObject(commandNames.SIGN_FOR_KEY_SSI, forDID.getIdentifier(), keySSI.getIdentifier(), hash, callback);
    }

    target.encryptMessage = (forDID, didFrom, didTo, message, callback) => {
        target.__putCommandObject(commandNames.ENCRYPT_MESSAGE, forDID.getIdentifier(), didFrom.getIdentifier(), didTo.getIdentifier(), message, callback);
    }

    target.decryptMessage = (forDID, didTo, encryptedMessage, callback) => {
        target.__putCommandObject(commandNames.DECRYPT_MESSAGE, forDID.getIdentifier(), didTo.getIdentifier(), encryptedMessage, (err, decryptedMessage) => {
            if (err) {
                return callback(err);
            }

            try {
                decryptedMessage = JSON.parse(decryptedMessage);
            } catch (e) {
                return callback(createOpenDSUErrorWrapper(`Failed to parse decrypted message`, e));
            }
            callback(undefined, decryptedMessage.message);
        });
    }
}

module.exports = ProxyMixin;
}).call(this)}).call(this,require("buffer").Buffer)

},{"../../error":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/error/index.js","../../utils/ObservableMixin":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/utils/ObservableMixin.js","./lib/commandsNames":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/enclave/impl/lib/commandsNames.js","buffer":false}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/enclave/impl/RemoteEnclave.js":[function(require,module,exports){
const { createCommandObject } = require("./lib/createCommandObject");
const ProxyMixin = require("./ProxyMixin");
const openDSU = require('../../index');
const w3cDID = openDSU.loadAPI("w3cdid");

function RemoteEnclave(clientDID, remoteDID, requestTimeout) {
    let initialised = false;
    const DEFAULT_TIMEOUT = 30000;

    this.commandsMap = new Map();
    this.requestTimeout = requestTimeout ?? DEFAULT_TIMEOUT;

    ProxyMixin(this);

    const init = async () => {
        try {
            this.clientDIDDocument = await $$.promisify(w3cDID.resolveDID)(clientDID);
            this.remoteDIDDocument = await $$.promisify(w3cDID.resolveDID)(remoteDID);
        }
        catch (err) {
            console.log(err);
        }
        this.initialised = true;
        this.dispatchEvent("initialised");

    }

    this.isInitialised = () => {
        return initialised;
    }

    this.getDID = (callback) => {
        callback(undefined, did);
    }

    this.__putCommandObject = (commandName, ...args) => {
        const callback = args.pop();
        args.push(clientDID);

        const command = JSON.stringify(createCommandObject(commandName, ...args));
        const commandID = JSON.parse(command).commandID;
        this.commandsMap.set(commandID, { "callback": callback, "time": Date.now() });

        if (this.commandsMap.size == 1) {
            this.subscribe();

        }

        this.clientDIDDocument.sendMessage(command, this.remoteDIDDocument, (err, res) => {
            if (err) {
                console.log(err);
            }
            setTimeout(this.checkTimeout, this.requestTimeout, commandID);
        });
    }

    this.subscribe = () => {
        this.clientDIDDocument.waitForMessages((err, res) => {
            if (err) {
                console.log(err);
                return;
            }

            try {
                const resObj = JSON.parse(res);
                const commandResult = resObj.commandResult;
                const commandID = resObj.commandID;

                if (!this.commandsMap.get(commandID)) return;

                const callback = this.commandsMap.get(commandID).callback;
                callback(err, JSON.stringify(commandResult));

                this.commandsMap.delete(commandID);
                if (this.commandsMap.size == 0) {
                    this.clientDIDDocument.stopWaitingForMessages();
                }
            }
            catch (err) {
                console.log(err);
            }
        })
    }

    this.checkTimeout = (commandID) => {
        if (!this.commandsMap.has(commandID)) return;

        const callback = this.commandsMap.get(commandID).callback;
        callback(createOpenDSUErrorWrapper(`Timeout for command ${commandID}`), undefined);
        this.commandsMap.delete(commandID);
        if (this.commandsMap.size == 0) {
            this.clientDIDDocument.stopWaitingForMessages();
        }
    }

    init();

}

module.exports = RemoteEnclave;
},{"../../index":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/index.js","./ProxyMixin":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/enclave/impl/ProxyMixin.js","./lib/createCommandObject":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/enclave/impl/lib/createCommandObject.js"}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/enclave/impl/WalletDBEnclave.js":[function(require,module,exports){
function WalletDBEnclave(keySSI, did) {
    const openDSU = require("opendsu");
    const constants = require("./constants");
    const db = openDSU.loadAPI("db")
    const scAPI = openDSU.loadAPI("sc");
    const resolver = openDSU.loadAPI("resolver");
    const config = openDSU.loadAPI("config");
    const keySSISpace = openDSU.loadAPI("keyssi");
    const DB_NAME = constants.DB_NAMES.WALLET_DB_ENCLAVE;
    const EnclaveMixin = require("./Enclave_Mixin");
    EnclaveMixin(this, did, keySSI);
    let enclaveDSU;
    let initialised = false;
    const init = async () => {
        if (!keySSI) {
            try {
                keySSI = await $$.promisify(config.getEnv)(openDSU.constants.MAIN_ENCLAVE.KEY_SSI);
            } catch (e) {
            }

            if (!keySSI) {
                let vaultDomain;
                try {
                    vaultDomain = await $$.promisify(scAPI.getVaultDomain)();
                } catch (e) {
                    throw createOpenDSUErrorWrapper(`Failed to get vault domain`, e);
                }

                try {
                    enclaveDSU = await $$.promisify(resolver.createSeedDSU)(vaultDomain);
                } catch (e) {
                    throw createOpenDSUErrorWrapper(`Failed to create Seed DSU`, e);
                }

                try {
                    keySSI = await $$.promisify(enclaveDSU.getKeySSIAsString)();
                } catch (e) {
                    throw createOpenDSUErrorWrapper(`Failed to get enclave DSU KeySSI`, e);
                }
                try {
                    await $$.promisify(config.setEnv)(openDSU.constants.MAIN_ENCLAVE.KEY_SSI, keySSI);
                } catch (e) {
                    throw createOpenDSUErrorWrapper(`Failed to store enclave DSU KeySSI`, e);
                }
            }
        }

        try{
            await $$.promisify(resolver.invalidateDSUCache)(keySSI);
            this.storageDB = db.getSimpleWalletDB(DB_NAME, {keySSI});
        }catch (e) {
            this.dispatchEvent("error", e)
        }
        this.storageDB.on("error", err => {
            this.dispatchEvent("error", err)
        });
        this.storageDB.on("initialised", async () => {
            if (typeof keySSI === "string") {
                keySSI = keySSISpace.parse(keySSI);
            }
            let privateKey;
            try{
                privateKey = await $$.promisify(this.storageDB.getRecord)(constants.TABLE_NAMES.PATH_KEY_SSI_PRIVATE_KEYS, 0);
            } catch (e) {
            }
            if (!privateKey) {
                await $$.promisify(this.storageDB.insertRecord)(constants.TABLE_NAMES.PATH_KEY_SSI_PRIVATE_KEYS, 0, {privateKey: keySSI.getPrivateKey()});
            }

            initialised = true;
            this.finishInitialisation();
            this.dispatchEvent("initialised");
        })
    };

    this.getKeySSI = (forDID, callback) => {
        if (typeof forDID === "function") {
            callback = forDID;
            forDID = undefined;
        }
        callback(undefined, keySSI);
    }

    this.getEnclaveType = () => {
        return openDSU.constants.ENCLAVE_TYPES.WALLET_DB_ENCLAVE;
    };

    this.isInitialised = () => {
        return initialised;
    };

    const bindAutoPendingFunctions = require("../../utils/BindAutoPendingFunctions").bindAutoPendingFunctions;
    bindAutoPendingFunctions(this, ["on", "off", "dispatchEvent", "beginBatch", "isInitialised", "getEnclaveType"]);

    init();
}

module.exports = WalletDBEnclave;
},{"../../utils/BindAutoPendingFunctions":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/utils/BindAutoPendingFunctions.js","./Enclave_Mixin":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/enclave/impl/Enclave_Mixin.js","./constants":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/enclave/impl/constants.js","opendsu":"opendsu"}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/enclave/impl/WalletDBEnclaveHandler.js":[function(require,module,exports){
const pathModule = require("path");
const constants = require("./constants");

function WalletDBEnclaveHandler(walletDBEnclaveKeySSI, config) {
    const defaultConfig = {
        maxNoScatteredKeys: 5000
    }
    Object.assign(defaultConfig, config);
    config = defaultConfig;
    const openDSU = require("opendsu");
    const resolver = openDSU.loadAPI("resolver");
    const utilsAPI = openDSU.loadAPI("utils");
    const keySSISpace = openDSU.loadAPI("keyssi");
    utilsAPI.ObservableMixin(this);
    let enclaveDSU;
    let initialised = false;
    const init = async ()=>{
        try {
            enclaveDSU = await $$.promisify(resolver.loadDSU)(walletDBEnclaveKeySSI);
        } catch (e) {
            throw createOpenDSUErrorWrapper(`Failed to load enclave DSU`, e);
        }

        this.finishInitialisation();
    }

    this.isInitialised = () => {
        return initialised;
    };

    this.storePathKeySSI = (pathKeySSI, callback) => {
        if (typeof pathKeySSI === "string") {
            try{
                pathKeySSI = keySSISpace.parse(pathKeySSI);
            }catch (e) {
                return callback(e);
            }
        }
        const __storePathKeySSI = () => {
            const filePath = pathModule.join(constants.PATHS.SCATTERED_PATH_KEYS, pathKeySSI.getSpecificString(), pathKeySSI.getIdentifier());
            enclaveDSU.writeFile(filePath, async err => {
                if (err) {
                    return callback(err);
                }

                try {
                    const files = await $$.promisify(enclaveDSU.listFiles)(constants.PATHS.SCATTERED_PATH_KEYS);
                    if (files.length === config.maxNoScatteredKeys) {
                        try {
                            await compactPathKeys();
                        } catch (e) {
                            return callback(e);
                        }
                    }
                    callback();
                } catch (e) {
                    callback(e);
                }
            })
        };

        __storePathKeySSI();
    };

    const compactPathKeys = async () => {
        let compactedContent = "";
        const crypto = require("opendsu").loadAPI("crypto");
        const files = await $$.promisify(enclaveDSU.listFiles)(constants.PATHS.SCATTERED_PATH_KEYS);

        for (let i = 0; i < files.length; i++) {
            const {key, value} = getKeyValueFromPath(files[i]);
            compactedContent = `${compactedContent}${key} ${value}\n`;
        }

        compactedContent = compactedContent.slice(0, compactedContent.length - 1);
        const fileName = crypto.encodeBase58(crypto.generateRandom(16));
        await $$.promisify(enclaveDSU.writeFile)(pathModule.join(constants.PATHS.COMPACTED_PATH_KEYS, fileName), compactedContent);

        for (let i = 0; i < files.length; i++) {
            const filePath = pathModule.join(constants.PATHS.SCATTERED_PATH_KEYS, files[i]);
            await $$.promisify(enclaveDSU.delete)(filePath);
        }
    }

    const getKeyValueFromPath = (pth) => {
        const lastSegmentIndex = pth.lastIndexOf("/");
        const key = pth.slice(0, lastSegmentIndex);
        const value = pth.slice(lastSegmentIndex + 1);
        return {
            key, value
        }
    }

    this.loadPaths = (callback) => {
        const __loadPaths = ()=> {
            loadCompactedPathKeys((err, compactedKeys) => {
                if (err) {
                    return callback(err);
                }

                loadScatteredPathKeys(async (err, scatteredKeys) => {
                    if (err) {
                        return callback(err);
                    }


                    callback(undefined, {...compactedKeys, ...scatteredKeys});
                })
            });
        }
        __loadPaths();
    }

    const loadScatteredPathKeys = (callback) => {
        const pathKeyMap = {};
        enclaveDSU.listFiles(constants.PATHS.SCATTERED_PATH_KEYS, async (err, files) => {
            if (err) {
                return callback(err);
            }

            for (let i = 0; i < files.length; i++) {
                const {key, value} = getKeyValueFromPath(files[i]);
                pathKeyMap[key] = value;
            }

            callback(undefined, pathKeyMap);
        });
    }

    const loadCompactedPathKeys = (callback) => {
        let pathKeyMap = {};
        const compactedValuesLocation = constants.PATHS.COMPACTED_PATH_KEYS;
        enclaveDSU.listFiles(compactedValuesLocation, async (err, files) => {
            if (err) {
                return callback(err);
            }

            try {
                for (let i = 0; i < files.length; i++) {
                    const filePath = pathModule.join(compactedValuesLocation, files[i]);
                    let compactedFileContent = await $$.promisify(enclaveDSU.readFile)(filePath);
                    compactedFileContent = compactedFileContent.toString();
                    const partialKeyMap = mapFileContent(compactedFileContent);
                    pathKeyMap = {...pathKeyMap, ...partialKeyMap};
                }
            } catch (e) {
                return callback(e);
            }


            callback(undefined, pathKeyMap);
        });
    }

    const mapFileContent = (fileContent) => {
        const pathKeyMap = {};
        const fileLines = fileContent.split("\n");
        for (let i = 0; i < fileLines.length; i++) {
            const splitLine = fileLines[i].split(" ");
            pathKeyMap[splitLine[0]] = splitLine[1];
        }

        return pathKeyMap;
    }

    utilsAPI.bindAutoPendingFunctions(this);
    init();
}

module.exports = WalletDBEnclaveHandler;
},{"./constants":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/enclave/impl/constants.js","opendsu":"opendsu","path":false}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/enclave/impl/constants.js":[function(require,module,exports){
module.exports = {
    TABLE_NAMES: {
        KEY_SSIS: "keyssis",
        SREAD_SSIS: "sreadssis",
        SEED_SSIS: "seedssis",
        DIDS_PRIVATE_KEYS: "dids_private",
        PATH_KEY_SSI_PRIVATE_KEYS: "path-keyssi-private-keys",
        PRIVATE_KEYS: "private-keys",
        SECRET_KEYS: "secret-keys"
    },
    PATHS: {
        SCATTERED_PATH_KEYS: "/paths/scatteredPathKeys",
        COMPACTED_PATH_KEYS: "/paths/compactedPathKeys"
    },
    DB_NAMES: {
        WALLET_DB_ENCLAVE: "walletdb_enclave"
    }
};
},{}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/enclave/impl/lib/commandsNames.js":[function(require,module,exports){
module.exports = {
    INSERT_RECORD: "insertRecord",
    UPDATE_RECORD: "updateRecord",
    GET_RECORD: "getRecord",
    DELETE_RECORD: "deleteRecord",
    FILTER_RECORDS: "filter",
    GET_ALL_RECORDS: "getAllRecords",
    BEGIN_BATCH: "beginBatch",
    COMMIT_BATCH: "commitBatch",
    CANCEL_BATCH: "cancelBatch",
    READ_KEY: "readKey",
    WRITE_KEY: "writeKey",
    ADD_IN_QUEUE: "addInQueue",
    QUEUE_SIZE: "queueSize",
    LIST_QUEUE: "listQueue",
    GET_OBJECT_FROM_QUEUE: "getObjectFromQueue",
    DELETE_OBJECT_FROM_QUEUE: "deleteObjectFromQueue",
    STORE_SEED_SSI: "storeSeedSSI",
    SIGN_FOR_KEY_SSI: "signForKeySSI",
    STORE_DID: "storeDID",
    ADD_PRIVATE_KEY_FOR_DID: "addPrivateKeyForDID",
    SIGN_FOR_DID: "signForDID",
    VERIFY_FOR_DID: "verifyForDID",
    ENCRYPT_MESSAGE: "encryptMessage",
    DECRYPT_MESSAGE: "decryptMessage",
    GET_PRIVATE_INFO_FOR_DID:"getPrivateInfoForDID"
}
},{}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/enclave/impl/lib/createCommandObject.js":[function(require,module,exports){
const createCommandObject = (commandName, ...args) => {
    const commandID = require('crypto').randomBytes(32).toString("base64")

    return {
        commandName,
        commandID,
        params: [
            ...args
        ]
    };
}

module.exports = {
    createCommandObject
}
},{"crypto":false}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/enclave/impl/utils.js":[function(require,module,exports){
const openDSU = require("opendsu");
const keySSISpace = openDSU.loadAPI("keyssi");

const mergeMappings = (dest, source) => {
    for (let ssiType in source) {
        if (typeof dest[ssiType] === "undefined") {
            dest[ssiType] = source[ssiType];
        }else{
            dest[ssiType] = {...dest[ssiType], ...source[ssiType]};
        }
    }

    return dest;
}

const getKeySSIsMappingFromPathKeys = (pathKeyMap, callback) => {
    let keySSIMap = {};
    const paths = Object.keys(pathKeyMap);
    if (paths.length === 0) {
        return callback(undefined, keySSIMap);
    }
    const TaskCounter = require("swarmutils").TaskCounter;
    const taskCounter = new TaskCounter(()=>{
        return callback(undefined, keySSIMap);
    })
    taskCounter.increment(paths.length);
    paths.forEach(pth => {
        const pathSSIIdentifier = pathKeyMap[pth];
        let keySSI;
        try {
            keySSI = keySSISpace.parse(pathSSIIdentifier);
        } catch (e) {
            return callback(e);
        }

        getKeySSIMapping(keySSI, (err, derivedKeySSIs) => {
            if (err) {
                return callback(err);
            }

            keySSIMap = mergeMappings(keySSIMap, derivedKeySSIs);
            taskCounter.decrement();
        })
    })
}

const getKeySSIMapping = (keySSI, callback) => {
    if (typeof keySSI === "string") {
        try {
            keySSI = keySSISpace.parse(keySSI);
        } catch (e) {
            return callback(e);
        }
    }
    const keySSIsMap = {};

    const __getDerivedKeySSIsRecursively = (currentKeySSI, derivedKeySSIsObj, callback) => {
        derivedKeySSIsObj[currentKeySSI.getTypeName()] = currentKeySSI.getIdentifier();
        try {
            currentKeySSI.derive((err, derivedKeySSI) => {
                if (err) {
                    return callback(err);
                }

                currentKeySSI = derivedKeySSI;
                __getDerivedKeySSIsRecursively(currentKeySSI, derivedKeySSIsObj, callback);
            });
        } catch (e) {
            return callback(undefined, derivedKeySSIsObj);
        }
    }

    __getDerivedKeySSIsRecursively(keySSI, {}, (err, _derivedKeySSIsObj)=>{
        if (err) {
            return callback(err);
        }

        for (let ssiType in _derivedKeySSIsObj) {
            keySSIsMap[ssiType] = {};
            const derivedKeySSIsList = Object.values(_derivedKeySSIsObj);
            for (let i = 0; i < derivedKeySSIsList.length; i++) {
                keySSIsMap[ssiType][derivedKeySSIsList[i]] = _derivedKeySSIsObj[ssiType];
            }
        }

        callback(undefined, keySSIsMap);
    })
}

module.exports = {
    getKeySSIsMappingFromPathKeys,
    getKeySSIMapping,
    mergeMappings
}
},{"opendsu":"opendsu","swarmutils":"swarmutils"}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/enclave/index.js":[function(require,module,exports){
const constants = require("../moduleConstants");

function initialiseWalletDBEnclave(keySSI, did) {
    const WalletDBEnclave = require("./impl/WalletDBEnclave");
    return new WalletDBEnclave(keySSI);
}

function initialiseMemoryEnclave() {
    const MemoryEnclave = require("./impl/MemoryEnclave");
    return new MemoryEnclave();
}

function initialiseAPIHUBProxy(domain, did) {
    const APIHUBProxy = require("./impl/APIHUBProxy");
    return new APIHUBProxy(domain, did);}

function initialiseHighSecurityProxy(domain, did) {
    const HighSecurityProxy = require("./impl/HighSecurityProxy");
    return new HighSecurityProxy(domain, did)
}

function initialiseRemoteEnclave(clientDID, remoteDID) {
    const RemoteEnclave = require("./impl/RemoteEnclave");
    return new RemoteEnclave(clientDID, remoteDID);}

function connectEnclave(forDID, enclaveDID, ...args) {
    throw Error("Not implemented");
}

const enclaveConstructors = {};
function createEnclave(enclaveType, ...args) {
    if (typeof enclaveConstructors[enclaveType] !== "function") {
        throw Error(`No constructor function registered for enclave type ${enclaveType}`);
    }

    return enclaveConstructors[enclaveType](...args);
}

function registerEnclave(enclaveType, enclaveConstructor) {
    if (typeof enclaveConstructors[enclaveType] !== "undefined") {
        throw Error(`A constructor function already registered for enclave type ${enclaveType}`);
    }
    enclaveConstructors[enclaveType] = enclaveConstructor;
}

registerEnclave(constants.ENCLAVE_TYPES.MEMORY_ENCLAVE, initialiseMemoryEnclave);
registerEnclave(constants.ENCLAVE_TYPES.WALLET_DB_ENCLAVE, initialiseWalletDBEnclave);
registerEnclave(constants.ENCLAVE_TYPES.APIHUB_ENCLAVE, initialiseAPIHUBProxy);
registerEnclave(constants.ENCLAVE_TYPES.HIGH_SECURITY_ENCLAVE, initialiseHighSecurityProxy);
registerEnclave(constants.ENCLAVE_TYPES.MQ_PROXY_ENCLAVE, initialiseRemoteEnclave)

module.exports = {
    initialiseWalletDBEnclave,
    initialiseMemoryEnclave,
    initialiseAPIHUBProxy,
    initialiseHighSecurityProxy,
    initialiseRemoteEnclave,
    connectEnclave,
    createEnclave,
    registerEnclave,
    EnclaveMixin: require("./impl/Enclave_Mixin"),
    ProxyMixin: require("./impl/ProxyMixin")
}

},{"../moduleConstants":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/moduleConstants.js","./impl/APIHUBProxy":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/enclave/impl/APIHUBProxy.js","./impl/Enclave_Mixin":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/enclave/impl/Enclave_Mixin.js","./impl/HighSecurityProxy":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/enclave/impl/HighSecurityProxy.js","./impl/MemoryEnclave":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/enclave/impl/MemoryEnclave.js","./impl/ProxyMixin":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/enclave/impl/ProxyMixin.js","./impl/RemoteEnclave":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/enclave/impl/RemoteEnclave.js","./impl/WalletDBEnclave":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/enclave/impl/WalletDBEnclave.js"}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/error/index.js":[function(require,module,exports){
const constants = require("../moduleConstants");

function detectRootCauseType(arr, priorityList){
    for(let errorType of priorityList){
        const index = arr.findIndex(e => {
            return e.rootCause && e.rootCause !== errorType
        });
        if (index !== -1) {
            return arr[index].rootCause;
        }
    }

    return constants.ERROR_ROOT_CAUSE.UNKNOWN_ERROR;
}

function ErrorWrapper(message, err, otherErrors, rootCause) {
    if (typeof rootCause === "undefined" && typeof otherErrors === "string") {
        rootCause = otherErrors;
        otherErrors = undefined;
    }
    let newErr = {};
    err = err || {rootCause: constants.ERROR_ROOT_CAUSE.UNKNOWN_ERROR};
    if (!err.rootCause) {
        err.rootCause = constants.ERROR_ROOT_CAUSE.UNKNOWN_ERROR;
    }

    if (!rootCause && otherErrors) {
        const errorTypes = constants.ERROR_ROOT_CAUSE;
        rootCause = detectRootCauseType(otherErrors, [errorTypes.DATA_INPUT, errorTypes.MISSING_DATA, errorTypes.BUSINESS_ERROR, errorTypes.THROTTLER_ERROR, errorTypes.NETWORK_ERROR]);
    }

    if (err.message || otherErrors) {
        if (err.originalMessage) {
            newErr.originalMessage = err.originalMessage;
        } else {
            newErr.originalMessage = err.message;
            if (otherErrors) {
                if (typeof otherErrors === "string") {
                    newErr.originalMessage += otherErrors;
                }

                if (Array.isArray(otherErrors)) {
                    otherErrors.forEach(e => newErr.originalMessage += `[${e.message}]`);
                }
            }
            if (typeof newErr.originalMessage === "string") {
                newErr.originalMessage = newErr.originalMessage.replace(/\n/g, " ");
            }
        }

    }

    try {
        if (err.originalMessage) {
            newErr = new Error(message + `(${err.originalMessage})`);
            newErr.originalMessage = err.originalMessage;
        } else {
            newErr = new Error(newErr.originalMessage);
            newErr.originalMessage = newErr.message;
        }
        throw newErr;
    } catch (e) {
        newErr = e;
    }
    newErr.previousError = err;
    newErr.debug_message = message;
    if (err.rootCause) {
        newErr.rootCause = err.rootCause;
    }
    if (rootCause) {
        newErr.rootCause = rootCause;
    }
    if (err.stack) {
        newErr.debug_stack = err.stack;
    }
    if (otherErrors) {
        newErr.otherErrors = otherErrors;
    }
    return newErr;
}

function createOpenDSUErrorWrapper(message, err, otherErrors, rootCause) {
    if (typeof message !== "string") {
        if (typeof err != "undefined") {
            err = message;
            message = "Wrong usage of createErrorWrapper";
        } else {
            message = "Wrong usage of createErrorWrapper";
        }
    }
    if(otherErrors && !Array.isArray(otherErrors) && typeof otherErrors !== "string"){
        otherErrors = [otherErrors];
    }
    return ErrorWrapper(message, err, otherErrors, rootCause);
}

function registerMandatoryCallback(callback, timeout) {
    if (timeout == undefined) {
        timeout = 5000; //5 seconds
    }
    let callStackErr = false;
    try {
        throw new Error("Callback should be called");
    } catch (err) {
        callStackErr = err;
    }
    const timeoutId = setTimeout(function () {
        reportUserRelevantError("Expected callback not called after " + timeout + " seconds. The calling stack is here: ", callStackErr);
    }, timeout);

    return function (...args) {
        clearTimeout(timeoutId);
        callback(...args);
    };
}

function OpenDSUSafeCallback(callback) {
    if (callback && typeof callback === 'function') {
        return callback;
    } else return function (err, res) {
        if (err) {
            reportUserRelevantError("Unexpected error happened without proper handling:", err);
        } else {
            reportUserRelevantWarning("Ignored result. Please add a proper callback when using this function! " + res)
        }
    }
}

let observable = require("./../utils/observable").createObservable();
let devObservers = [];

function reportUserRelevantError(message, err, showIntermediateErrors) {
    observable.dispatchEvent("error", {message, err});
    console.log(message);
    if (err && typeof err.debug_message != "undefined") {
        printErrorWrapper(err, showIntermediateErrors);
    }
}

function reportUserRelevantWarning(message) {
    observable.dispatchEvent("warn", message);
    console.log(">>>", message);
}


function reportUserRelevantInfo(message) {
    observable.dispatchEvent("info", message);
    console.log(">>>", message);
}

function reportDevRelevantInfo(message) {
    devObservers.forEach(c => {
        c(message);
    })
    console.log(">>>", message);
}

function unobserveUserRelevantMessages(type, callback) {
    switch (type) {
        case "error":
            observable.off(type, callback);
            break;
        case "info":
            observable.off(type, callback);
            break;
        case "warn":
            observable.off(type, callback);
            break;
        default:
            let index = devObservers.indexOf(callback);
            if (index !== -1) {
                devObservers.splice(index, 1);
            }
    }
}

function observeUserRelevantMessages(type, callback) {
    switch (type) {
        case "error":
            observable.on(type, callback);
            break;
        case "info":
            observable.on(type, callback);
            break;
        case "warn":
            observable.on(type, callback);
            break;
        case "dev":
            devObservers.push(callback);
            break;
        default:
            devObservers.push(callback);
            break;
    }
}

function printErrorWrapper(ew, showIntermediateErrors) {
    let level = 0;
    console.log("Top level error:", ew.debug_message, ew.debug_stack);
    let firstError;
    ew = ew.previousError;
    while (ew) {
        if (showIntermediateErrors && ew.previousError) {
            console.log("Error at layer ", level, " :", ew.debug_message, ew.debug_stack);
        }
        level++;
        firstError = ew;
        ew = ew.previousError;
    }
    console.log("\tFirst error in the ErrorWrapper at level ", level, " :", firstError);
}

function printOpenDSUError(...args) {
    for (let elem of args) {
        if (typeof elem.previousError != "undefined") {
            printErrorWrapper(elem);
        } else {
            console.log(elem);
        }
    }
}

function httpToRootCauseErrorCode(httpRes) {
    if (!httpRes) {
        return constants.ERROR_ROOT_CAUSE.UNKNOWN_ERROR;
    }

    if (!httpRes.statusCode) {
        return constants.ERROR_ROOT_CAUSE.NETWORK_ERROR;
    }

    if (httpRes.statusCode === 429) {
        return constants.ERROR_ROOT_CAUSE.THROTTLER_ERROR;
    }

    if (httpRes.statusCode === 404) {
        return constants.ERROR_ROOT_CAUSE.MISSING_DATA;
    }

    if (httpRes.statusCode < 500) {
        return constants.ERROR_ROOT_CAUSE.BUSINESS_ERROR;
    }

    return constants.ERROR_ROOT_CAUSE.UNKNOWN_ERROR;
}

const DB_INSERT_EXISTING_RECORD_ERROR = "Trying to insert into existing record";

module.exports = {
    createOpenDSUErrorWrapper,
    reportUserRelevantError,
    reportUserRelevantWarning,
    reportUserRelevantInfo,
    reportDevRelevantInfo,
    observeUserRelevantMessages,
    unobserveUserRelevantMessages,
    OpenDSUSafeCallback,
    registerMandatoryCallback,
    printOpenDSUError,
    DB_INSERT_EXISTING_RECORD_ERROR,
    httpToRootCauseErrorCode
}

},{"../moduleConstants":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/moduleConstants.js","./../utils/observable":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/utils/observable.js"}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/http/browser/index.js":[function(require,module,exports){
function callGlobalHandler(res){
	if($$.httpUnknownResponseGlobalHandler){
		$$.httpUnknownResponseGlobalHandler(res);
	}
}

function generateMethodForRequestWithData(httpMethod) {
	return function (url, data, options, callback) {
		if(typeof options === "function"){
			callback = options;
			options = {};
		}

		const xhr = new XMLHttpRequest();

		xhr.onload = function () {
			if (xhr.readyState === 4 && (xhr.status >= 200 && xhr.status < 300)) {
				const data = xhr.response;
				callback(undefined, data);
			} else {
				if(xhr.status >= 400){
					const error = new Error("An error occured. StatusCode: " + xhr.status);
					callback({error: error, statusCode: xhr.status});
				} else {
					if(xhr.status >= 300 && xhr.status < 400){
						callGlobalHandler(xhr);
					}else{
						console.log(`Status code ${xhr.status} received, response is ignored.`);
					}
				}
			}
		};

		xhr.onerror = function (e) {
			callback(new Error("A network error occurred"));
		};

		xhr.open(httpMethod, url, true);
		//xhr.setRequestHeader("Content-Type", "application/json;charset=UTF-8");
		if(typeof options.headers !== "undefined"){
			for(let name in options.headers){
				xhr.setRequestHeader(name, options.headers[name]);
			}
		}

		if(data && data.pipe && typeof data.pipe === "function"){
			const buffers = [];
			data.on("data", function(data) {
				buffers.push(data);
			});
			data.on("end", function() {
				const actualContents = $$.Buffer.concat(buffers);
				xhr.send(actualContents);
			});
		}
		else {
			if(ArrayBuffer.isView(data) || data instanceof ArrayBuffer) {
				xhr.setRequestHeader('Content-Type', 'application/octet-stream');

				/**
				 * Content-Length is an unsafe header and we cannot set it.
				 * When browser is making a request that is intercepted by a service worker,
				 * the Content-Length header is not set implicitly.
				 */
				xhr.setRequestHeader('X-Content-Length', data.byteLength);
			}
			xhr.send(data);
		}
	};
}

function customFetch(...args){
	return fetch(...args).then(res=>{
		if(res.status >= 300 && res.status < 400){
			callGlobalHandler(res);
		}
		return res;
	}).catch(err=>{
		callGlobalHandler({status: 503, err});
		throw err;
	});
}

function doGet(url, options, callback){
	if (typeof options === "function") {
		callback = options;
		options = undefined;
	}

	customFetch(url, options)
		.then(response => response.text())
		.then(data => callback(undefined, data))
		.catch(err => callback(err));
}

module.exports = {
	fetch: customFetch,
	doPost: generateMethodForRequestWithData('POST'),
	doPut: generateMethodForRequestWithData('PUT'),
	doGet
}
},{}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/http/index.js":[function(require,module,exports){
/**
 * http API space
 */
const or = require('overwrite-require');

switch ($$.environmentType) {
	case or.constants.BROWSER_ENVIRONMENT_TYPE:
		module.exports = require("./browser");
		break;
	case or.constants.WEB_WORKER_ENVIRONMENT_TYPE:
	case or.constants.SERVICE_WORKER_ENVIRONMENT_TYPE:
		module.exports = require("./serviceWorker");
		break;
	default:
		module.exports = require("./node");
}

//enable support for http interceptors.
require("./utils/interceptors").enable(module.exports);

const PollRequestManager = require("./utils/PollRequestManager");
const rm = new PollRequestManager(module.exports.fetch);

module.exports.poll = function (url, options, connectionTimeout, delayStart) {
	connectionTimeout = connectionTimeout || 10000;
	rm.setConnectionTimeout(connectionTimeout);
	const request = rm.createRequest(url, options, delayStart);
	return request;
};

module.exports.unpoll = function(request){
	rm.cancelRequest(request);
}

},{"./browser":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/http/browser/index.js","./node":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/http/node/index.js","./serviceWorker":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/http/serviceWorker/index.js","./utils/PollRequestManager":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/http/utils/PollRequestManager.js","./utils/interceptors":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/http/utils/interceptors.js","overwrite-require":"overwrite-require"}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/http/node/common.js":[function(require,module,exports){
const userAgent = 'PSK NodeAgent/0.0.1';
const signatureHeaderName = process.env.vmq_signature_header_name || "x-signature";

function getNetworkForOptions(options) {
	const httpModuleName = "http";
	const http = require(httpModuleName);
	const https = require(httpModuleName + "s");

	let network;
	switch (options.protocol) {
		case "http:":
			network = http;
			break;
		case "https:":
			network = https;
			break;
		default:
			throw new Error(`Can't handle protocol ${options.protocol}`);
	}

	return network;
}

function buildOptions(url, method, opts){
	const urlModuleName = "url";
	const URL = require(urlModuleName);
	const innerUrl = URL.parse(url);

	const options = {
		hostname: innerUrl.hostname,
		path: innerUrl.pathname,
		protocol: innerUrl.protocol,
		port: parseInt(innerUrl.port),
		headers: {
			'User-Agent': userAgent,
			[signatureHeaderName]: 'replaceThisPlaceholderSignature'
		},
		method
	};

	//if no port is specified we need to set the default ones
	if(!options.port){
		options.port = innerUrl.protocol === "http:" ? 80 : 443
	}

	if(opts){
		if(opts.useProxy){
			let proxy = URL.parse(opts.useProxy);
			//setting proxy hostname
			options.hostname = proxy.hostname;

			//setting proxy port
			if(Number.isNaN(proxy.port)){
				options.port = proxy.protocol === "http:" ? 80 : 443;
			}else{
				options.port = proxy.port;
			}

			//updating the path
			options.path = url;
		}

		for(let name in opts.headers){
			options.headers[name] = opts.headers[name];
		}
	}

	return options;
}

function setContentTypeByData(options, data){
	if(typeof data === "undefined"){
		return;
	}
	if (ArrayBuffer.isView(data) || $$.Buffer.isBuffer(data) || data instanceof ArrayBuffer) {
		if (!$$.Buffer.isBuffer(data)) {
			data = $$.Buffer.from(data);
		}

		options.headers['Content-Type'] = 'application/octet-stream';
		options.headers['Content-Length'] = data.length;
	}
}

module.exports = {
	setContentTypeByData,
	buildOptions,
	getNetworkForOptions
}
},{}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/http/node/fetch.js":[function(require,module,exports){
const http = require("http");
const https = require("https");
const URL = require("url");

function getProtocol(url, options) {
	let protocol;

	// const urlObject = new URL(url).catch((err) => { throw new Error(err) });
	// return urlObject.protocol === 'http:' ? http : https

	if (typeof options !== "undefined") {
		if (options.protocol === 'http') {
			protocol = http;
		} else if (options.protocol === 'https') {
			protocol = https;
		} else {
			if (url.startsWith("https:")) {
				protocol = https;
			} else if (url.startsWith("http:")) {
				protocol = http;
			}
		}
	} else {
		if (url.startsWith("https:")) {
			protocol = https;
		} else if (url.startsWith("http:")) {
			protocol = http;
		}
	}

	if (typeof protocol === "undefined") {
		throw new Error(`Unable to determine the protocol`);
	}

	return protocol;
}

function decipherUrl(url, options) {
	const innerUrl = URL.parse(url);

	options.hostname = innerUrl.hostname;
	options.path = innerUrl.pathname + (innerUrl.search || '');
	options.port = parseInt(innerUrl.port);
}

function getMethod(options) {
	let method = 'get';
	if (typeof options !== "undefined") {
		method = options.method;
	}
	return method;
}

function convertOptions(options = {}) {
	//convert from fetch options into xhr options

	if (typeof options.method === "undefined") {
		options.method = 'GET';
	}

	return options;
}

function fetch(url, options = {}) {
	const protocol = getProtocol(url, options);

	let promise = new Promise((resolve, reject) => {
		decipherUrl(url, options);

		let request = protocol.request(url, options, (response) => {
			resolve(new Response(request, response));
		});

		if (options.body) {
			let body = options.body;
			if (typeof body.pipe === 'function') {
				body.pipe(request);
			} else {
				if (typeof body !== 'string' && !$$.Buffer.isBuffer(body) && !ArrayBuffer.isView(body)) {
					body = JSON.stringify(body);
				}

				request.write(body);
			}
		}

		request.on("error", (error) => {
			reject(error);
		});

		request.end();
	});

	return promise;
}

function Response(httpRequest, httpResponse) {
	let handlers = {};

	let readingInProgress = false;
	function readResponse(callback) {
		if (readingInProgress) {
			throw new Error("Response reading in progress");
		}

		readingInProgress = true;

		//data collecting
		let rawData;
		const contentType = httpResponse.headers['content-type'];
        const isPartialContent = httpResponse.statusCode === 206;

		if (contentType === "application/octet-stream" || isPartialContent) {
			rawData = [];
		} else {
			rawData = '';
		}

		httpResponse.on('data', (chunk) => {
			if (Array.isArray(rawData)) {
				rawData.push(...chunk);
			} else {
				rawData += chunk;
			}
		});

		httpResponse.on('end', () => {
			try {
				if (Array.isArray(rawData)) {
					rawData = $$.Buffer.from(rawData);
				}
				callback(undefined, rawData);
			} catch (err) {
				OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to process raw data`, err));
			} finally {
				//trying to prevent getting ECONNRESET error after getting our response
				httpRequest.abort();
			}
		});
	}

	this.ok = httpResponse.statusCode >= 200 && httpResponse.statusCode < 300 ? true : false;
	this.status = httpResponse.statusCode;
	this.statusMessage = httpResponse.statusMessage;

	function Headers(headers) {
		headers = headers || {};

		this.get = (headerKey)=>{
			return headers[headerKey];
		}
	}

	this.headers = new Headers(httpResponse.headers);

	this.arrayBuffer = function () {
		let promise = new Promise((resolve, reject) => {
			readResponse((err, responseBody) => {
				if (err) {
					return reject(err);
				}
				//endure responseBody has the wright type of ArrayBuffer
				resolve(responseBody);
			});
		});
		return promise;
	}

	this.blob = function () {
		let promise = new Promise((resolve, reject) => {
			readResponse((err, responseBody) => {
				if (err) {
					return reject(err);
				}
				resolve(responseBody);
			});
		});
		return promise;
	}

	this.text = function () {
		let promise = new Promise((resolve, reject) => {
			readResponse((err, responseBody) => {
				if (err) {
					return reject(err);
				}
				resolve(responseBody);
			});
		});
		return promise;
	}

	this.formData = function () {
		let promise = new Promise((resolve, reject) => {
			readResponse((err, responseBody) => {
				if (err) {
					return reject(err);
				}
				resolve(responseBody);
			});
		});
		return promise;
	}

	this.json = function () {
		let promise = new Promise((resolve, reject) => {
			readResponse((err, responseBody) => {
				if (err) {
					return reject(err);
				}
				let jsonContent;
				try {
					//do we really need this if ?!
					if ($$.Buffer.isBuffer(responseBody)) {
						responseBody = responseBody.toString();
					}
					jsonContent = responseBody ? JSON.parse(responseBody) : responseBody;
				} catch (e) {
					return reject(e);
				}
				resolve(jsonContent);
			});
		});
		return promise;
	}

	return this;
}

module.exports = {
	fetch
}

},{"http":false,"https":false,"url":false}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/http/node/index.js":[function(require,module,exports){

const {setContentTypeByData,buildOptions,getNetworkForOptions} = require("./common.js");
const {httpToRootCauseErrorCode, createOpenDSUErrorWrapper} = require("../../error");
const constants = require("opendsu").constants;
function generateMethodForRequestWithData(httpMethod) {
	return function (url, data, reqOptions, callback) {
		if(typeof reqOptions === "function"){
			callback = reqOptions;
			reqOptions = {};
		}

		const options = buildOptions(url, httpMethod, reqOptions);
		const network = getNetworkForOptions(options);

		setContentTypeByData(options, data);

		const req = network.request(options, (res) => {
			const {statusCode} = res;

			let error;
			if (statusCode >= 400) {
				error = new Error('Request Failed.\n' +
					`Status Code: ${statusCode}\n` +
					`URL: ${options.hostname}:${options.port}${options.path}`);

				error = createOpenDSUErrorWrapper("HTTP request failed", error, httpToRootCauseErrorCode(res));
			}

			let rawData = '';
			res.on('data', (chunk) => {
				rawData += chunk;
			});
			res.on('end', () => {
                if (error) {
					error = createOpenDSUErrorWrapper(rawData, error, httpToRootCauseErrorCode(res));
					error.statusCode = statusCode;
					callback(error);
                    return;
                }

                callback(undefined, rawData, res.headers);
                //trying to prevent getting ECONNRESET error after getting our response
                // req.abort();
			});
		}).on("error", (error) => {
			const errorWrapper = createOpenDSUErrorWrapper(`Network error`, error, constants.ERROR_ROOT_CAUSE.NETWORK_ERROR);
			console.log(`[POST] ${url}`, errorWrapper);
			callback(errorWrapper);
		})

		if (data && data.pipe && typeof data.pipe === "function") {
			data.pipe(req);
			return;
		}

		if (typeof data !== 'string' && !$$.Buffer.isBuffer(data) && !ArrayBuffer.isView(data)) {
			data = JSON.stringify(data);
		}

		if(data){
			req.write(data);
		}
		req.end();
	};
}

function doGet(url, options, callback) {
	let fnc = generateMethodForRequestWithData('GET');
	return fnc(url, undefined, options, callback);
}
module.exports = {
	fetch: require("./fetch").fetch,
	doGet,
	doPost: generateMethodForRequestWithData('POST'),
	doPut: generateMethodForRequestWithData('PUT')
}

},{"../../error":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/error/index.js","./common.js":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/http/node/common.js","./fetch":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/http/node/fetch.js","opendsu":"opendsu"}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/http/serviceWorker/index.js":[function(require,module,exports){
function generateMethodForRequestWithData(httpMethod) {
	return function (url, data, options, callback) {
		if(typeof options === "function"){
			callback = options;
			options = {};
		}
		const headers = options.headers || {};
		if(ArrayBuffer.isView(data) || data instanceof ArrayBuffer) {
			headers['Content-Type'] = 'application/octet-stream';

			/**
			 * Content-Length is an unsafe header and we cannot set it.
			 * When browser is making a request that is intercepted by a service worker,
			 * the Content-Length header is not set implicitly.
			 */
			headers['X-Content-Length'] = data.byteLength;
		}

		fetch(url, {
			method: httpMethod,
			mode: 'cors',
			headers,
			body: data
		}).then(function (response) {
			if (response.status >= 400) {
				throw new Error(`An error occurred ${response.statusText}`);
			}
			return response.text().catch((err) => {
				// This happens when the response is empty
				let emptyResponse = {message: ""}
				return JSON.stringify(emptyResponse);
			});
		}).then(function (data) {
			callback(null, data)
		}).catch(error => {
			callback(error);
		});
	};
}

module.exports = {
	fetch: fetch,
	doPost: generateMethodForRequestWithData('POST'),
	doPut: generateMethodForRequestWithData('PUT'),
	doGet: require("./../browser").doGet
}

},{"./../browser":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/http/browser/index.js"}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/http/utils/PollRequestManager.js":[function(require,module,exports){
function PollRequestManager(fetchFunction,  connectionTimeout = 10000, pollingTimeout = 1000){

	const requests = new Map();

	function Request(url, options, delay = 0) {
		let promiseHandlers = {};
		let currentState = undefined;
		let timeout;
		this.url = url;
		let abortController;
		let previousAbortController;

		this.execute = function() {
			if (typeof AbortController !== "undefined") {
				if (typeof abortController === "undefined") {
					previousAbortController = new AbortController()
				} else {
                    previousAbortController = abortController;
                }
				abortController = new AbortController();
				options.signal = previousAbortController.signal;
			}
			if (!currentState && delay) {
				currentState = new Promise((resolve, reject) => {
					timeout = setTimeout(() => {
						fetchFunction(url, options).then((response) => {
							resolve(response);
						}).catch((err) => {
							reject(err);
						})
					}, delay);
				});
			} else {
				currentState = fetchFunction(url, options);
			}
			return currentState;
		}

		this.cancelExecution = function() {
			clearTimeout(timeout);
			timeout = undefined;
			if(typeof currentState !== "undefined"){
				currentState = undefined;
			}
			promiseHandlers.resolve = (...args) => {console.log("(not important) Resolve called after cancel execution with the following args", ...args)};
			promiseHandlers.reject = (...args) => {console.log("(not important) Reject called after cancel execution with the following args", ...args)};
		}

		this.setExecutor = function(resolve, reject) {
			if(promiseHandlers.resolve){
				return reject(new Error("Request already in progress"));
			}
			promiseHandlers.resolve = resolve;
			promiseHandlers.reject = reject;
		}

		this.resolve = function(...args) {
			promiseHandlers.resolve(...args);
			this.destroy();
			promiseHandlers = {};
		}

		this.reject = function(...args) {
			if(promiseHandlers.reject){
				promiseHandlers.reject(...args);
			}
			this.destroy();
			promiseHandlers = {};
		}

		this.destroy = function(removeFromPool = true) {
			this.cancelExecution();

			if (!removeFromPool) {
				return;
			}

			// Find our identifier
			const requestsEntries = requests.entries()
			let identifier;
			for (const [key, value] of requestsEntries) {
				if (value === this) {
					identifier = key;
					break;
				}
			}

			if (identifier) {
				requests.delete(identifier);
			}
		}

		this.abort = () => {
            if (typeof previousAbortController !== "undefined") {
				previousAbortController.abort();
            }
		}
	}

	this.createRequest = function (url, options, delayedStart = 0) {
		const request = new Request(url, options, delayedStart);

		const promise = new Promise((resolve, reject) => {
			request.setExecutor(resolve, reject);
			createPollingTask(request);
		});
		promise.abort = () => {
			this.cancelRequest(promise);
		};

		requests.set(promise, request);
		return promise;
	};

	this.cancelRequest = function(promiseOfRequest){
		if(typeof promiseOfRequest === "undefined"){
			console.log("No active request found.");
			return;
		}

		const request = requests.get(promiseOfRequest);
		if (request) {
			request.destroy(false);
			requests.delete(promiseOfRequest);
		}
	}

	this.setConnectionTimeout = (_connectionTimeout)=>{
		connectionTimeout = _connectionTimeout;
	}

	/* *************************** polling zone ****************************/
	function createPollingTask(request) {
		let safePeriodTimeoutHandler;
		let serverResponded = false;
		/**
		 * default connection timeout in api-hub is @connectionTimeout
		 * we wait double the time before aborting the request
		 */
		function beginSafePeriod() {
			safePeriodTimeoutHandler = setTimeout(() => {
				if (!serverResponded) {
					request.abort();
				}
				serverResponded = false;
				beginSafePeriod()
			}, connectionTimeout * 2);
			reArm();
		}

		function endSafePeriod(serverHasResponded) {
			serverResponded = serverHasResponded;

			clearTimeout(safePeriodTimeoutHandler);
		}

		function reArm() {
			request.execute().then( (response) => {
				if (!response.ok) {
					endSafePeriod(true);

					//todo check for http errors like 404
					if (response.status === 403) {
						request.reject(Error("Token expired"));
						return
					}
					return beginSafePeriod();
				}

				if (response.status === 204) {
					endSafePeriod(true);
					beginSafePeriod();
					return;
				}

				if (safePeriodTimeoutHandler) {
					clearTimeout(safePeriodTimeoutHandler);
				}

				request.resolve(response);
			}).catch( (err) => {
				switch (err.code) {
					case "ETIMEDOUT":
					case "ECONNREFUSED":
						endSafePeriod(true);
						beginSafePeriod();
						break;
					case 20:
					case "ERR_NETWORK_IO_SUSPENDED":
					//reproduced when user is idle on ios (chrome).
					case "ERR_INTERNET_DISCONNECTED":
						//indicates a general network failure.
						break;
					default:
						console.log("abnormal error: ", err);
						endSafePeriod(true);
						request.reject(err);
				}
			});

		}

		beginSafePeriod();
	}

}

module.exports = PollRequestManager;

},{}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/http/utils/interceptors.js":[function(require,module,exports){
let interceptors = [];

function registerInterceptor(interceptor){
    if(typeof interceptor !== "function"){
        throw new Error('interceptor argument should be a function');
    }
    interceptors.push(interceptor);
}

function unregisterInterceptor(interceptor){
    let index = interceptors.indexOf(interceptor);
    if(index !== -1){
        interceptors.splice(index, 1);
    }
}

function callInterceptors(target, callback){
    let index = -1;
    function executeInterceptor(result){
        index++;
        if(index >= interceptors.length){
            return callback(undefined, result);
        }
        let interceptor = interceptors[index];
        interceptor(target, (err, result)=>{
            if(err){
                return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to execute interceptor`, err));
            }
            return executeInterceptor(result);
        });
    }
    executeInterceptor(target);
}

function setupInterceptors(handler){
    const interceptMethods = [{name: "doPost", position: 2}, {name:"doPut", position: 2}, {name:"doGet", position: 1}];
    interceptMethods.forEach(function(target){
        let method = handler[target.name];
        handler[target.name] = function(...args){
            let headers = {};
            let optionsAvailable = false;
            if(args.length > target.position+1 && ["function", "undefined"].indexOf(typeof args[target.position]) === -1){
                headers = args[target.position]["headers"];
                optionsAvailable = true;
            }

            let data = {url: args[0], headers};
            callInterceptors(data, function(err, result){
                if(optionsAvailable){
                    args[target.position]["headers"] = result.headers;
                }else{
                    args.splice(target.position, 0, {headers: result.headers});
                }

                return method(...args);
            });
        }
    });

    const promisedBasedInterceptors = [{name: "fetch", position: 1}];
    promisedBasedInterceptors.forEach(function(target){
        let method = handler[target.name];
        handler[target.name] = function(...args){
            return new Promise((resolve, reject) => {
                if (args.length === 1) {
                    args.push({headers: {}});
                }

                if (args.length === 2 && typeof args[1] === "undefined") {
                    args[1] = {};
                }

                if(typeof args[1].headers === "undefined"){
                    args[1].headers = {};
                }
                let headers = args[1].headers;

                let data = {url: args[0], headers};
                callInterceptors(data, function(err, result) {

                    let options = args[target.position];
                    options.headers = result.headers;

                    method(...args)
                        .then((...args) => {
                            resolve(...args);
                        })
                        .catch((...args) => {
                            reject(...args);
                        });
                });
            });
        };
    });
}

function enable(handler){
    //exposing working methods
    handler.registerInterceptor = registerInterceptor;
    handler.unregisterInterceptor = unregisterInterceptor;
    //setting up the interception mechanism
    setupInterceptors(handler);
}

module.exports = {enable};
},{}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/keyssi/index.js":[function(require,module,exports){
const keySSIResolver = require("key-ssi-resolver");
const keySSIFactory = keySSIResolver.KeySSIFactory;
const SSITypes = keySSIResolver.SSITypes;
const openDSU = require("opendsu");
const parse = (ssiString, options) => {
    return keySSIFactory.create(ssiString, options);
};

const createSeedSSI = (domain, vn, hint, callback) => {
    return we_createSeedSSI(openDSU.loadAPI("sc").getMainEnclave(), domain, vn, hint, callback);
};

const we_createSeedSSI = (enclave, domain, vn, hint, callback) => {
    if (typeof vn == "function") {
        callback = vn;
        vn = undefined;
    }

    if (typeof hint == "function") {
        callback = hint;
        hint = undefined;
    }

    let seedSSI = keySSIFactory.createType(SSITypes.SEED_SSI);

    if (typeof callback === "function") {
        seedSSI.initialize(domain, undefined, undefined, vn, hint, (err => {
            if (err) {
                return callback(err);
            }

            if (enclave) {
                enclave.storeKeySSI(seedSSI, (err) => callback(err, seedSSI));
            } else {
                callback(undefined, seedSSI);
            }
        }));
    } else {
        seedSSI.initialize(domain, undefined, undefined, vn, hint);
    }
    return seedSSI;
};

const buildSeedSSI = function () {
    throw new Error("Obsoleted, use buildTemplateSeedSSI");
}

const buildTemplateSeedSSI = (domain, specificString, control, vn, hint, callback) => {
    console.log("This function is obsolete. Use createTemplateSeedSSI instead.");
    return createTemplateKeySSI(SSITypes.SEED_SSI, domain, specificString, control, vn, hint, callback);
};

const createTemplateSeedSSI = (domain, specificString, control, vn, hint, callback) => {
    return createTemplateKeySSI(SSITypes.SEED_SSI, domain, specificString, control, vn, hint, callback);
};

const we_createPathKeySSI = (enclave, domain, path, vn, hint, callback) => {
    if (typeof vn == "function") {
        callback = vn;
        vn = undefined;
    }

    if (typeof hint == "function") {
        callback = hint;
        hint = undefined;
    }

    let pathKeySSI = keySSIFactory.createType(SSITypes.PATH_SSI, enclave);
    pathKeySSI.load(SSITypes.PATH_SSI, domain, path, '', vn, hint);
    if (typeof callback === "function") {
        return enclave.storeKeySSI(pathKeySSI, err => {
            if (err) {
                return callback(err);
            }

            callback(undefined, pathKeySSI);
        });
    }
    return pathKeySSI;
}

const createPathKeySSI = (domain, path, vn, hint) => {
    return we_createPathKeySSI(openDSU.loadAPI("sc").getMainEnclave(), domain, path, vn, hint);
};

const createHashLinkSSI = (domain, hash, vn, hint) => {
    const hashLinkSSI = keySSIFactory.createType(SSITypes.HASH_LINK_SSI)
    hashLinkSSI.initialize(domain, hash, vn, hint);
    return hashLinkSSI;
};

const createTemplateKeySSI = (ssiType, domain, specificString, control, vn, hint, callback) => {
    //only ssiType and domain are mandatory arguments
    if (typeof specificString === "function") {
        callback = specificString;
        specificString = undefined;
    }
    if (typeof control === "function") {
        callback = control;
        control = undefined;
    }
    if (typeof vn === "function") {
        callback = vn;
        specificString = undefined;
    }
    if (typeof hint === "function") {
        callback = hint;
        hint = undefined;
    }
    const keySSI = keySSIFactory.createType(ssiType);
    keySSI.load(ssiType, domain, specificString, control, vn, hint);
    if (typeof callback === "function") {
        callback(undefined, keySSI);
    }
    return keySSI;
};

const buildTemplateWalletSSI = (domain, arrayWIthCredentials, hint) => {
    console.log("This function is obsolete. Use createTemplateWalletSSI instead.");
    try {
        let ssi = createArraySSI(domain, arrayWIthCredentials, undefined, hint);
        ssi.cast(SSITypes.WALLET_SSI);
        return parse(ssi.getIdentifier());
    } catch (err) {
        console.log("Failing to build WalletSSI");
    }
};

const createTemplateWalletSSI = (domain, arrayWIthCredentials, hint) => {
    if (!Array.isArray(arrayWIthCredentials)) {
        arrayWIthCredentials = [arrayWIthCredentials];
    }
    try {
        let ssi = createArraySSI(domain, arrayWIthCredentials, undefined, hint);
        ssi.cast(SSITypes.WALLET_SSI);
        return parse(ssi.getIdentifier());
    } catch (err) {
        console.log("Failing to build WalletSSI");
    }
};

const createConstSSI = (domain, constString, vn, hint) => {
    return we_createConstSSI(openDSU.loadAPI("sc").getMainEnclave(), domain, constString, vn, hint)
};

const we_createConstSSI = (enclave, domain, constString, vn, hint, callback) => {
    const constSSI = keySSIFactory.createType(SSITypes.CONST_SSI);
    constSSI.initialize(domain, constString, vn, hint);
    if (typeof callback === "function") {
        if (enclave) {
            enclave.storeKeySSI(undefined, constSSI, (err) => callback(err, constSSI));
        } else {
            callback(undefined, constSSI);
        }
    }
    return constSSI;
};

const createArraySSI = (domain, arr, vn, hint, callback) => {
    return we_createArraySSI(openDSU.loadAPI("sc").getMainEnclave(), domain, arr, vn, hint);
}

const we_createArraySSI = (enclave, domain, arr, vn, hint, callback) => {
    const arraySSI = keySSIFactory.createType(SSITypes.ARRAY_SSI);
    arraySSI.initialize(domain, arr, vn, hint);
    if (typeof callback === "function") {
        if (enclave) {
            enclave.storeKeySSI(undefined, arraySSI, (err) => callback(err, arraySSI));
        } else {
            callback(undefined, arraySSI);
        }
    }
    return arraySSI;
};

const buildSymmetricalEncryptionSSI = (domain, encryptionKey, control, vn, hint, callback) => {
    console.log("This function is obsolete. Use createTemplateSymmetricalEncryptionSSI instead.");
    return createTemplateKeySSI(SSITypes.SYMMETRICAL_ENCRYPTION_SSI, domain, encryptionKey, control, vn, hint, callback);
};

const createTemplateSymmetricalEncryptionSSI = (domain, encryptionKey, control, vn, hint, callback) => {
    return createTemplateKeySSI(SSITypes.SYMMETRICAL_ENCRYPTION_SSI, domain, encryptionKey, control, vn, hint, callback);
};

const createToken = (domain, amountOrSerialNumber, vn, hint, callback) => {
    if (typeof vn === "function") {
        callback = vn;
        vn = undefined;
        hint = undefined
    }

    if (typeof hint === "function") {
        callback = hint;
        hint = undefined
    }
    // the tokenSSI is closely linked with an ownershipSSI
    // the tokenSSI must have the ownershipSSI's public key hash
    // the ownershipSSI must have the tokenSSI's base58 ssi
    const ownershipSSI = keySSIFactory.createType(SSITypes.OWNERSHIP_SSI);
    ownershipSSI.initialize(domain, undefined, undefined, vn, hint, (err) => {

        const ownershipPublicKeyHash = ownershipSSI.getPublicKeyHash();
        const ownershipPrivateKey = ownershipSSI.getPrivateKey();

        const tokenSSI = keySSIFactory.createType(SSITypes.TOKEN_SSI);
        tokenSSI.initialize(domain, amountOrSerialNumber, ownershipPublicKeyHash, vn, hint);

        // update ownershipSSI to set level and token
        const ownershipLevelAndToken = `0/${tokenSSI.getIdentifier()}`;
        ownershipSSI.load(SSITypes.OWNERSHIP_SSI, domain, ownershipPrivateKey, ownershipLevelAndToken, vn, hint);

        // create a TRANSFER_SSI, since the token's ownership is first transfered to the owner itself
        const transferTimestamp = new Date().getTime();

        // get signature by sign(lastEntryInAnchor, transferTimestamp, ownershipPublicKeyHash)
        const transferDataToSign = `${transferTimestamp}${ownershipPublicKeyHash}`;
        ownershipSSI.sign(transferDataToSign, (err, signature) => {
            if (err) {
                return callback(createOpenDSUErrorWrapper("Failed to signed transfer data", err));
            }

            let transferSSI = createTransferSSI(domain, ownershipPublicKeyHash, transferTimestamp, signature);
            const {createAnchor, appendToAnchor} = require("../anchoring");
            createAnchor(ownershipSSI, (err) => {
                if (err) {
                    return callback(createOpenDSUErrorWrapper("Failed to anchor ownershipSSI", err));
                }

                appendToAnchor(ownershipSSI, transferSSI, (err) => {
                    if (err) {
                        return callback(createOpenDSUErrorWrapper("Failed to anchor transferSSI", err));
                    }

                    const result = {
                        tokenSSI: tokenSSI,
                        ownershipSSI: ownershipSSI,
                        transferSSI: transferSSI
                    }

                    callback(undefined, result);
                });
            });
        });
    });
};

const createOwnershipSSI = (domain, levelAndToken, vn, hint, callback) => {
    let ownershipSSI = keySSIFactory.createType(SSITypes.OWNERSHIP_SSI);
    ownershipSSI.initialize(domain, undefined, levelAndToken, vn, hint, callback);
    return ownershipSSI;
};

const createTransferSSI = (domain, hashNewPublicKey, timestamp, signatureCurrentOwner, vn, hint, callback) => {
    let transferSSI = keySSIFactory.createType(SSITypes.TRANSFER_SSI);
    transferSSI.initialize(domain, hashNewPublicKey, timestamp, signatureCurrentOwner, vn, hint, callback);
    return transferSSI;
};

const createTemplateTransferSSI = (domain, hashNewPublicKey, vn, hint) => {
    let transferSSI = keySSIFactory.createType(SSITypes.TRANSFER_SSI);
    transferSSI.load(domain, hashNewPublicKey, undefined, vn, hint);
    return transferSSI;
};

const createSignedHashLinkSSI = (domain, hashLink, timestamp, signature, vn, hint) => {
    let signedHashLink = keySSIFactory.createType(SSITypes.SIGNED_HASH_LINK_SSI);
    signedHashLink.initialize(domain, hashLink, timestamp, signature, vn, hint);
    return signedHashLink;
};

const createPublicKeySSI = (compatibleFamilyName, publicKey, vn) => {
    let publicKeySSI = keySSIFactory.createType(SSITypes.PUBLIC_KEY_SSI);
    publicKeySSI.initialize(compatibleFamilyName, publicKey, vn);
    return publicKeySSI;
};

const createAliasSSI = (domain, alias, callback) => {
    const aliasSSI = keySSIFactory.createType(SSITypes.ALIAS_SSI);
    aliasSSI.initialize(domain, alias, callback);
    return aliasSSI;
}

const createSizeSSI = (domain, totalSize, bufferSize) => {
    const sizeSSI = keySSIFactory.createType(SSITypes.SIZE_SSI);
    sizeSSI.initialize(domain, totalSize, bufferSize);
    return sizeSSI;
}

const createEmbedSSI = (domain, data) => {
    const embedSSI = keySSIFactory.createType(SSITypes.EMBED_SSI);
    embedSSI.initialize(domain, data);
    return embedSSI;
}

module.exports = {
    parse,
    createSeedSSI,
    buildSeedSSI,
    buildTemplateSeedSSI,
    buildTemplateWalletSSI,
    createTemplateSeedSSI,
    createTemplateSymmetricalEncryptionSSI,
    createTemplateWalletSSI,
    createTemplateKeySSI,
    createHashLinkSSI,
    createConstSSI,
    createArraySSI,
    buildSymmetricalEncryptionSSI,
    createToken,
    createOwnershipSSI,
    createTransferSSI,
    createTemplateTransferSSI,
    createSignedHashLinkSSI,
    createPublicKeySSI,
    we_createSeedSSI,
    we_createConstSSI,
    we_createArraySSI,
    createAliasSSI,
    createSizeSSI,
    createPathKeySSI,
    we_createPathKeySSI,
    createEmbedSSI
};

},{"../anchoring":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/anchoring/index.js","key-ssi-resolver":"key-ssi-resolver","opendsu":"opendsu"}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/m2dsu/apisRegistry.js":[function(require,module,exports){
const apis = {};
function defineApi(name, implementation){
	if(typeof implementation !== "function"){
		throw Error("second argument of the defineApi should be a function that will represent the implementation for that api");
	}
	apis[name] = implementation;
}

function getApis(){
	return apis;
}

module.exports = {defineApi, getApis}
},{}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/m2dsu/defaultApis/index.js":[function(require,module,exports){
const registry = require("../apisRegistry");

/*
* based on jsonIndications Object {attributeName1: "DSU_file_path", attributeName2: "DSU_file_path"}
* the this of the mapping will be populated with the data extracted from the DSU
* */
registry.defineApi("loadJSONS", async function (dsu, jsonIndications) {
    for (let prop in jsonIndications) {
        try {
            let data;
            data = await dsu.readFile(jsonIndications[prop]);
            this[prop] = JSON.parse(data);
        } catch (e) {
            console.log("Failed to load JSON due to ", e.message);
        }
    }
});

/*
* based on jsonIndications Object {attributeName1: "DSU_file_path", attributeName2: "DSU_file_path"}
* the data from the this of the mapping will be saved into the DSU
* */
registry.defineApi("saveJSONS", async function (dsu, jsonIndications) {
    for (let prop in jsonIndications) {
        let data = JSON.stringify(this[prop]);
        await dsu.writeFile(jsonIndications[prop], data);
    }
});

function promisifyDSUAPIs(dsu) {
    //this API method list will be promisify on the fly with the help of the registerDSU method and a Proxy over DSU instance
    const promisifyAPIs = [
        "addFile",
        "addFiles",
        "addFolder",
        "appendToFile",
        "batch",
        "beginBatch",
        "cancelBatch",
        "cloneFolder",
        "commitBatch",
        "createFolder",
        "delete",
        "dsuLog",
        "extractFile",
        "extractFolder",
        "getKeySSI",
        "getKeySSIAsObject",
        "getKeySSIAsString",
        "getSSIForMount",
        "init",
        "listFiles",
        "listFolders",
        "listMountedDossiers",
        "load",
        "mount",
        "readDir",
        "readFile",
        "rename",
        "stat",
        "unmount",
        "writeFile",
        "listMountedDSUs",
        "refresh"
    ];

    const promisifyHandler = {
        get: function (target, prop, receiver) {
            if (promisifyAPIs.indexOf(prop) !== -1) {
                return $$.promisify(target[prop]);
            }
            return target[prop];
        }
    };

    //we create a proxy over the normal DSU / Archive instance
    //in order to promisify on the fly the public API to be easier to work with in the mapping functions
    return new Proxy(dsu, promisifyHandler);
}

//all DSUs that are created with different exposed APIs need to be registered
// in order to control the batch operations and promisify the API on them
registry.defineApi("registerDSU", function (dsu) {
    if (typeof dsu === "undefined" || typeof dsu.beginBatch !== "function") {
        throw Error("registerDSU needs a DSU instance");
    }
    if (typeof this.registeredDSUs === "undefined") {
        this.registeredDSUs = [];
    }

    //TODO: temporary fix, this apiRegistry is now instantiated for each mapping message
    if (!dsu.batchInProgress()) {
        this.registeredDSUs.push(dsu);
        dsu.beginBatch();
    }

    return promisifyDSUAPIs(dsu);
});

registry.defineApi("loadConstSSIDSU", async function (constSSI, options) {
    const resolver = await this.getResolver();

    let dsu;
    try {
        dsu = await resolver.loadDSU(constSSI);
    } catch (e) {
        //TODO check error type
        //on purpose if DSU does not exists an error gets throw
    }

    if (dsu) {
        //take note that this.registerDSU returns a Proxy Object over the DSU and this Proxy we need to return also
        return {dsu: this.registerDSU(dsu), alreadyExists: true};
    }

    dsu = await resolver.createDSUForExistingSSI(constSSI, options);

    //take note that this.registerDSU returns a Proxy Object over the DSU and this Proxy we need to return also
    return {dsu: this.registerDSU(dsu), alreadyExists: false};
});

registry.defineApi("loadArraySSIDSU", async function (domain, arr) {
    const opendsu = require("opendsu");
    const resolver = await this.getResolver();
    const keySSISpace = opendsu.loadApi("keyssi");

    const keySSI = keySSISpace.createArraySSI(domain, arr);
    let dsu = await resolver.loadDSU(keySSI);
    if (dsu) {
        //take note that this.registerDSU returns a Proxy Object over the DSU and this Proxy we need to return also
        return {dsu: this.registerDSU(dsu), alreadyExists: true};
    }

    dsu = await resolver.createArrayDSU(domain, arr);
    //take note that this.registerDSU returns a Proxy Object over the DSU and this Proxy we need to return also
    return {dsu: this.registerDSU(dsu), alreadyExists: false};
});

registry.defineApi("createDSU", async function (domain, ssiType, options) {
    const template = require("opendsu").loadApi("keyssi").createTemplateKeySSI(ssiType, domain);
    let resolver = await this.getResolver();
    let dsu = await resolver.createDSU(template, options);
    //take note that this.registerDSU returns a Proxy Object over the DSU and this Proxy we need to return also
    return this.registerDSU(dsu);
});

registry.defineApi("createPathSSI", async function (domain, path, options) {
    const scAPI = require("opendsu").loadAPI("sc");
    let enclave;
    try{
        enclave = await $$.promisify(scAPI.getSharedEnclave)();
    }catch (e) {
        enclave = await $$.promisify(scAPI.getMainEnclave)();
    }
    const pathKeySSI = await $$.promisify(enclave.createPathKeySSI)(domain, path);
    const seedSSI = await $$.promisify(pathKeySSI.derive)();

    return seedSSI;
});

registry.defineApi("createPathSSIDSU", async function (domain, path, options) {
    const seedSSI = await this.createPathSSI(domain, path, options);
    let resolver = await this.getResolver();
    let dsu = await resolver.createDSUForExistingSSI(seedSSI, options);
    //take note that this.registerDSU returns a Proxy Object over the DSU and this Proxy we need to return also
    return this.registerDSU(dsu);
});

registry.defineApi("loadDSU", async function (keySSI, options) {
    let resolver = await this.getResolver();
    let dsu = await resolver.loadDSU(keySSI, options);
    if (!dsu) {
        throw new Error("No DSU found for " + keySSI);
    }
    //take note that this.registerDSU returns a Proxy Object over the DSU and this Proxy we need to return also
    return this.registerDSU(dsu);
});


//an api that returns an OpenDSU Resolver instance that has promisified methods
// to be used in mappings easier
registry.defineApi("getResolver", function (domain, ssiType, options) {
    return new Promise((resolve, reject) => {

        const resolverInherited = ["createDSUx",
            "createSeedDSU",
            "createArrayDSU",
            "createDSUForExistingSSI"];

        const promisify = ["createDSU", "loadDSU"];

        const scApi = require("opendsu").loadApi("sc");
        scApi.getSharedEnclave((err, sharedEnclave) => {
            const defaultResolver = require("opendsu").loadApi("resolver");
            let resolver = defaultResolver;
            if (err) {
                console.log("SharedEnclave not available. Fallback to standard resolver.");
            } else {
                resolver = sharedEnclave;
            }

            const instance = {};
            instance.__proto__ = resolver;

            for (let i = 0; i < promisify.length; i++) {
                let methodName = promisify[i];
                instance[methodName] = $$.promisify(resolver[methodName]);
            }

            for (let i = 0; i < resolverInherited.length; i++) {
                let methodName = resolverInherited[i];
                instance[methodName] = $$.promisify(defaultResolver[methodName]);
            }


            resolve(instance);
        });
    });

});


registry.defineApi("recoverDSU", function (ssi, recoveryFnc, callback) {
    if(!this.storageService.loadDSURecoveryMode){
        return callback(new Error("Not able to run recovery mode due to misconfiguration of mapping engine."));
    }

    this.storageService.loadDSURecoveryMode(ssi, recoveryFnc, (err, dsu)=>{
        if(err){
            return callback(err);
        }

        return callback(undefined, this.registerDSU(dsu));
    });
});


},{"../apisRegistry":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/m2dsu/apisRegistry.js","opendsu":"opendsu"}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/m2dsu/defaultMappings/index.js":[function(require,module,exports){
const mappingRegistry = require("./../mappingRegistry.js");

async function validateMessage(message){
	return !!(message.messageType === "standard");
}

async function digestMessage(message){
	throw Error("Not implemented yet!");
}

mappingRegistry.defineMapping(validateMessage, digestMessage);
},{"./../mappingRegistry.js":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/m2dsu/mappingRegistry.js"}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/m2dsu/errorsMap.js":[function(require,module,exports){
errorTypes = {
  "UNKNOWN": {
    errorCode: 0,
    message: "Unknown error",
    getDetails: function (data) {
      return [{
        errorType: this.errorCode,
        errorMessage: this.message,
        errorDetails: data,
        errorField: data.errorField || "unknown"
      }]
    }
  },
  "INVALID_MESSAGE_FORMAT": {
    errorCode: 1,
    message: "Invalid message format",
    getDetails: function (data) {
      return data.map(item => {
        return {
          errorType: this.errorCode,
          errorMessage: this.message,
          errorDetails: `${item.field} - ${item.message}`,
          errorField: item.field
        }
      })
    }
  },
  "DB_OPERATION_FAIL": {
    errorCode: 2,
    message: "Database operation failed",
    getDetails: function (data) {
      return [
        {
          errorType: this.errorCode,
          errorMessage: this.message,
          errorDetails: "Missing from the wallet database or database is corrupted",
          errorField: data
        }
      ]
    }
  },
  "MESSAGE_IS_NOT_AN_OBJECT": {
    errorCode: 3,
    message: "Message is not an Object",
    getDetails: function (data) {
      return data.map(item => {
        return {
          errorType: this.errorCode,
          errorMessage: this.message,
          errorDetails: item.errorDetails,
          errorField: data.errorField || "unknown"
        }
      })
    }
  },
  "DIGESTING_MESSAGES": {
    errorCode: 4,
    message: "Mapping Engine is digesting messages for the moment",
    getDetails: function (data) {
      return [{
        errorType: this.errorCode,
        errorMessage: this.message,
        errorDetails: data.errorDetails || "",
        errorField: data.errorField || "unknown"
      }]
    }
  },
  "MISSING_MAPPING": {
    errorCode: 5,
    message: "Not able to digest message due to missing mapping",
    getDetails: function (data) {
      return data.map(item => {
        return {
          errorType: this.errorCode,
          errorMessage: this.message,
          errorDetails: item.errorDetails,
          errorField: data.errorField || "messageType"
        }
      })
    }
  },
  "MAPPING_ERROR": {
    errorCode: 6,
    message: "Caught error during mapping",
    getDetails: function (data) {
      return [{
        errorType: this.errorCode,
        errorMessage: this.message,
        errorDetails: data.errorDetails || "",
        errorField: data.errorField || "unknown"
      }]
    }
  }
}

function getErrorCodes() {
  let errCodes = Object.values(errorTypes).map(item => {
    return item.errorCode
  });
  return errCodes;
}

function getErrorKeyByCode(errCode) {
  try {
    let errObj = Object.values(errorTypes).find(item => item.errorCode === errCode)
    if (errObj) {
      return errObj;
    }
  } catch (e) {

  }

  return errorTypes.UNKNOWN
}

function getErrorKeyByMessage(errMessage) {
  try {
    let errObj = Object.values(errorTypes).find(item => item.message === errMessage);
    if (errObj) {
      return errObj
    }
  } catch (e) {
    console.log('Could not find mapping for ', errMessage);
  }

  return errorTypes.UNKNOWN.getDetails(errMessage)
}

function newCustomError(errorObj, detailsObj) {
  return createOpenDSUErrorWrapper(errorObj.message, null, {
    code: errorObj.errorCode,
    details: errorObj.getDetails(detailsObj)
  });
}

function addNewErrorType(key, code, message, detailsFn) {
  errorTypes[key] = {
    errorCode: code,
    message: message,
    getDetails: detailsFn || function (data) {
      return [{
        errorType: this.errorCode,
        errorMessage: this.message,
        errorDetails: "",
        errorField: data || "unknown"
      }]
    }
  }

}

function setErrorMessage(key, message) {
  errorTypes[key].message = message;
}

module.exports = {
  errorTypes,
  newCustomError,
  getErrorKeyByCode,
  getErrorKeyByMessage,
  setErrorMessage,
  addNewErrorType
}

},{}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/m2dsu/index.js":[function(require,module,exports){
const mappingRegistry = require("./mappingRegistry.js");
const apisRegistry = require("./apisRegistry.js");
const errMap = require("./errorsMap.js")

//loading defaultApis
require("./defaultApis");

//loading defaultMappings
require("./defaultMappings");

function MappingEngine(storageService, options) {
  if (typeof storageService === "undefined"
    || typeof storageService.beginBatch !== "function"
    || typeof storageService.commitBatch !== "function"
    || typeof storageService.cancelBatch !== "function") {
    throw Error("The MappingEngine requires a storage service that exposes beginBatch, commitBatch, cancelBatch apis!");
  }

  const errorHandler = require("opendsu").loadApi("error");

  //the purpose of the method is to create a "this" instance to be used during a message mapping process
  function buildMappingInstance() {
    let instance = {storageService, options};

    let recoveryMode = false;
    instance.setRecovery = function(value){
      recoveryMode = !!value;
    }

    instance.isRecoveryActive = function(){
      return recoveryMode;
    }

    const apis = apisRegistry.getApis();

    //we inject all the registered apis on the instance that will become the "this" for a mapping
    for (let prop in apis) {
      if (typeof instance[prop] !== "undefined") {
        console.log(`Take note that an overwriting processing is in place for the api named ${prop}.`);
      }
      instance[prop] = (...args) => {
        return apis[prop].call(instance, ...args);
      }
    }

    return instance;
  }

  async function getMappingFunction(message) {
    const knownMappings = mappingRegistry.getMappings();

    for (let i = 0; i < knownMappings.length; i++) {
      let mapping = knownMappings[i];
      let {matchFunction, mappingFunction} = mapping;
      let applyMapping = await matchFunction(message);

      if (applyMapping) {
        return mappingFunction;
      }
    }
  }

  function commitMapping(mappingInstance) {
    let touchedDSUs = mappingInstance.registeredDSUs;
    return new Promise((resolve, reject) => {
      //if all good until this point, we need to commit any registeredDSU during the message mapping
      const commitPromises = [];
      for (let i = 0; i < touchedDSUs.length; i++) {
        const commitBatch = $$.promisify(touchedDSUs[i].commitBatch);
        commitPromises.push(commitBatch());
      }

      Promise.all(commitPromises)
        .then(async results => {
            for (let i = 0; i < results.length; i++) {
              let result = results[i];
              if (result && result.status === "rejected") {
                await $$.promisify(touchedDSUs[i].cancelBatch)();
                let getDSUIdentifier = $$.promisify(touchedDSUs[i].getKeySSIAsString);
                return reject(errorHandler.createOpenDSUErrorWrapper(`Cancel batch on dsu identified with ${await getDSUIdentifier()}`, error));
              }
            }
            resolve(true);
          }
        ).catch(err => {
        return reject(errorHandler.createOpenDSUErrorWrapper(`Caught error during commit batch on registered DSUs`, err));
      });
    });
  }

  function executeMappingFor(message) {
    return new Promise(async (resolve, reject) => {

      const mappingFnc = await getMappingFunction(message);
      if (mappingFnc) {
        const instance = buildMappingInstance();
        try {
          instance.setRecovery(message.force);
          await mappingFnc.call(instance, message);
        } catch (err) {
          //we need to return the list of touched DSUs for partial rollback procedure
          err.mappingInstance = {registeredDSUs: instance.registeredDSUs};
          return reject(err);
        }
        return resolve({registeredDSUs: instance.registeredDSUs});
      } else {
        let messageString = JSON.stringify(message);
        const maxDisplayLength = 1024;
        console.log(`Unable to find a suitable mapping to handle the following message: ${messageString.length < maxDisplayLength ? messageString : messageString.slice(0, maxDisplayLength) + "..."}`);
        return reject(errMap.newCustomError(errMap.errorTypes.MISSING_MAPPING, [{
          errorField: "messageType",
          errorDetails: `Couldn't find any mapping for ${message.messageType}`
        }]));
      }
    });
  }

  let inProgress = false;
  this.digestMessages = (messages) => {
    if (!Array.isArray(messages)) {
      messages = [messages];
    }

    async function rollback() {
      const cancelBatch = $$.promisify(storageService.cancelBatch);
      try {
        await cancelBatch();
      } catch (e) {
        console.log("Not able to cancel batch", e)
      }
      inProgress = false;

    }

    async function finish() {
      const commitBatch = $$.promisify(storageService.commitBatch);
      try {
        await commitBatch();
      } catch (e) {
        console.log("Not able to commit batch", e)
      }

      inProgress = false;
    }

    return new Promise(async (resolve, reject) => {
        if (inProgress) {
          throw errMap.newCustomError(errMap.errorTypes.DIGESTING_MESSAGES);
        }
        inProgress = true;
        storageService.beginBatch();

        //commitPromisses will contain promises for each of message
        let commitPromisses = [];
        let mappingsInstances = [];
        //we will use this array to keep all the failed mapping instance in order to cancel batch operations on touched DSUs
        let failedMappingInstances = [];

        let failedMessages = [];

        function handleErrorsDuringPromiseResolving(err) {
          reject(err);
        }

        for (let i = 0; i < messages.length; i++) {
          let message = messages[i];
          if (typeof message !== "object") {
            let err = errMap.newCustomError(errMap.errorTypes.MESSAGE_IS_NOT_AN_OBJECT, [{errorDetails: `Found type: ${typeof message} expected type object`}]);
            failedMessages.push({
              message: message,
              reason: err.message,
              error: err
            });

            //wrong message type... so we log, and then we continue the execution with the rest of the messages
            continue;
          }

          try {
            let mappingInstance = await executeMappingFor(message);
            mappingsInstances.push(mappingInstance);
          } catch (err) {
            //this .mappingInstance prop is artificial injected from the executeMappingFor function in case of an error during mapping execution
            //isn't too nice, but it does the job
            if (err.mappingInstance) {
              failedMappingInstances.push(err.mappingInstance);
            }

            errorHandler.reportUserRelevantError("Caught error during message digest", err);
            failedMessages.push({
              message: message,
              reason: err.message,
              error: err
            });
          }
        }

        function digestConfirmation(results) {

          for (let index = 0; index < results.length; index++) {
            let result = results[index];
            switch (result.status) {
              case "fulfilled" :
                if (result.value === false) {
                  // message digest failed
                  failedMessages.push({
                    message: messages[index],
                    reason: `Not able to digest message due to missing suitable mapping`,
                    error: errMap.errorTypes.MISSING_MAPPING
                  });
                }
                break;
              case "rejected" :
                failedMessages.push({
                  message: messages[index],
                  reason: result.reason,
                  error: result.reason
                });
                break;
            }
          }

          finish().then(async () => {
            //in case that we have failed messages we need to reset touched DSUs of that mapping;
            //the reason being that a DSU can be kept in a local cache and later on this fact that the DSU is in a "batch" state creates a strange situation
            for (let j = 0; j < failedMappingInstances.length; j++) {
              let mapInstance = failedMappingInstances[j];
              if (mapInstance.registeredDSUs) {
                for (let i = 0; i < mapInstance.registeredDSUs.length; i++) {
                  let touchedDSU = mapInstance.registeredDSUs[i];
                  try {
                    await $$.promisify(touchedDSU.cancelBatch, touchedDSU)();
                  } catch (err) {
                    //we ignore any cancel errors for the moment
                  }
                }
              }
            }

            //now that we finished with the partial rollback we can return the failed messages
            resolve(failedMessages);
          }).catch(async (err) => {
            await rollback();
            reject(err);
          });
        }

        for (let i = 0; i < mappingsInstances.length; i++) {
          commitPromisses.push(commitMapping(mappingsInstances[i]));
        }

        Promise.allSettled(commitPromisses)
          .then(digestConfirmation)
          .catch(handleErrorsDuringPromiseResolving);
      }
    );
  }

  return this;
}

module.exports = {
  getMappingEngine: function (persistenceDSU, options) {
    return new MappingEngine(persistenceDSU, options);
  },
  getMessagesPipe: function () {
    return require("./messagesPipe");
  },
  getErrorsMap: function () {
    return errMap;
  },
  defineMapping: mappingRegistry.defineMapping,
  defineApi: apisRegistry.defineApi
}

},{"./apisRegistry.js":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/m2dsu/apisRegistry.js","./defaultApis":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/m2dsu/defaultApis/index.js","./defaultMappings":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/m2dsu/defaultMappings/index.js","./errorsMap.js":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/m2dsu/errorsMap.js","./mappingRegistry.js":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/m2dsu/mappingRegistry.js","./messagesPipe":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/m2dsu/messagesPipe/index.js","opendsu":"opendsu"}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/m2dsu/mappingRegistry.js":[function(require,module,exports){
const mappingRegistry = [];
function defineMapping(matchFunction, mappingFunction){
	mappingRegistry.push({matchFunction, mappingFunction});
}

function getMappings(){
	return mappingRegistry;
}

module.exports = {
	defineMapping,
	getMappings
}
},{}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/m2dsu/messagesPipe/index.js":[function(require,module,exports){
module.exports = function (maxGroupSize, maxQueuingTime, groupingFunction) {

    this.queue = [];
    let newGroupCallback;
    let pipeIsWaiting = false;
    let waitingIntervalId;

    let startWaitingMessages = () => {
        if(pipeIsWaiting === false){
            pipeIsWaiting = true;
            waitingIntervalId = setInterval(async()=>{
                if (this.queue.length > 0) {
                    await checkPipeMessages(true);
                }
            }, maxQueuingTime);
        }
    }

    let stopWaitingMessages = () =>{
        pipeIsWaiting = false;
        if(waitingIntervalId){
            clearInterval(waitingIntervalId);
        }
    }

    this.addInQueue =  async (messages) => {

        if (!Array.isArray(messages)) {
            messages = [messages]
        }

        for (let i = 0; i < messages.length; i++) {
            this.queue.push(messages[i]);
        }

        await checkPipeMessages();

    }

    this.onNewGroup = (__newGroupCallback) => {
         newGroupCallback = __newGroupCallback;
    };

    let checkPipeMessages = async (forceFlush) =>{

        let messageGroup = await $$.promisify(groupingFunction)(this.queue);

        if (messageGroup.length < this.queue.length || maxGroupSize <= this.queue.length || forceFlush) {
            messageGroup = [...messageGroup];
            //TODO we are loosing messages that are not properly digested
            this.queue.splice(0,messageGroup.length);
            stopWaitingMessages();
            await newGroupCallback(messageGroup);
        }
        startWaitingMessages();
    }

    startWaitingMessages();

}
},{}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/moduleConstants.js":[function(require,module,exports){
const ENVIRONMENT_TYPES = require("../overwrite-require/moduleConstants");

let cachedKeySSIResolver = undefined;


module.exports = {
	ENVIRONMENT_TYPES,
	CODE_FOLDER: "/code",
	CONSTITUTION_FOLDER: '/code/constitution',
	BLOCKCHAIN_FOLDER: '/blockchain',
	APP_FOLDER: '/app',
	DOMAIN_IDENTITY_FILE: '/domain_identity',
	ASSETS_FOLDER: "/assets",
	TRANSACTIONS_FOLDER: "/transactions",
	APPS_FOLDER: "/apps",
	DATA_FOLDER: "/data",
	MANIFEST_FILE: "/manifest",
	BDNS_ROOT_HOSTS: "BDNS_ROOT_HOSTS",
	ENVIRONMENT_PATH: "/environment.json",
	SECURITY_CONTEXT_KEY_SSI: "scKeySSI",
	VAULT_DOMAIN: "vaultDomain",
	DOMAIN: "domain",
	DID_DOMAIN: "didDomain",
	MAIN_APP_DID: "mainAppDID",
	MAIN_ENCLAVE: {
		TYPE: "enclaveType",
		DID: "enclaveDID",
		KEY_SSI: "enclaveKeySSI"
	},
	SHARED_ENCLAVE: {
		TYPE: "sharedEnclaveType",
		DID: "sharedEnclaveDID",
		KEY_SSI: "sharedEnclaveKeySSI",
	},
	ENCLAVE_TYPES: {
		WALLET_DB_ENCLAVE: "WalletDBEnclave",
		MEMORY_ENCLAVE: "MemoryEnclave",
		APIHUB_ENCLAVE: "ApihubEnclave",
		HIGH_SECURITY_ENCLAVE: "HighSecurityEnclave"
	},
	CACHE: {
		FS: "fs",
		MEMORY: "memory",
		INDEXED_DB: "cache.indexedDB",
		VAULT_TYPE: "cache.vaultType",
		BASE_FOLDER: "internal-volume/cache",
		BASE_FOLDER_CONFIG_PROPERTY: "fsCache.baseFolder",
		ENCRYPTED_BRICKS_CACHE: "encrypted-bricks-cache",
		ANCHORING_CACHE: "anchoring-cache",
		NO_CACHE: "no-cache"
	},
	DOMAINS: {
		VAULT: "vault"
	},
	VAULT:{
		BRICKS_STORE: "bricks",
		ANCHORS_STORE: "anchors"
	},
	BRICKS_DOMAIN_KEY: "bricksDomain",
	LOADER_ENVIRONMENT_JSON:{
		AGENT: "agent",
		SERVER: "server",
		VAULT: "vault",
		MOBILE: "mobile",
	},
    BOOT_CONFIG_FILE: 'boot-cfg.json',
    ERROR_ROOT_CAUSE: {
        UNKNOWN_ERROR: "unknown",
        NETWORK_ERROR: "network",
        THROTTLER_ERROR: "throttler",
        BUSINESS_ERROR: "business",
		DATA_INPUT: "dataInput",
		MISSING_DATA: "missingData"
    },
	 get KEY_SSIS(){
		if(cachedKeySSIResolver === undefined){
			cachedKeySSIResolver = require("key-ssi-resolver");
		}
		 return cachedKeySSIResolver.SSITypes;
	 },
	get CRYPTO_FUNCTION_TYPES(){
		if(cachedKeySSIResolver === undefined){
			cachedKeySSIResolver = require("key-ssi-resolver");
		}
		return cachedKeySSIResolver.CryptoFunctionTypes;
	}
}




},{"../overwrite-require/moduleConstants":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/overwrite-require/moduleConstants.js","key-ssi-resolver":"key-ssi-resolver"}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/mq/mqClient.js":[function(require,module,exports){
/*
Message Queues API space
*/

let http = require("../http");
let bdns = require("../bdns")

function send(keySSI, message, callback) {
    console.log("Send method from OpenDSU.loadApi('mq') is absolute. Adapt your code to use the new getMQHandlerForDID");
    bdns.getAnchoringServices(keySSI, (err, endpoints) => {
        if (err) {
            return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to get anchoring services from bdns`, err));
        }
        let url = endpoints[0] + `/mq/send-message/${keySSI}`;
        let options = { body: message };

        let request = http.poll(url, options, timeout);

        request.then((response) => {
            callback(undefined, response);
        }).catch((err) => {
            return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to send message`, err));
        });
    });
}

let requests = {};

function getHandler(keySSI, timeout) {
    console.log("getHandler method from OpenDSU.loadApi('mq') is absolute. Adapt your code to use the new getMQHandlerForDID");
    let obs = require("../utils/observable").createObservable();
    bdns.getMQEndpoints(keySSI, (err, endpoints) => {
        if (err || endpoints.length === 0) {
            return callback(new Error("Not available!"));
        }

        let createChannelUrl = endpoints[0] + `/mq/create-channel/${keySSI}`;
        http.doPost(createChannelUrl, undefined, (err, response) => {
            if (err) {
                if (err.statusCode === 409) {
                    //channels already exists. no problem :D
                } else {
                    get
                    obs.dispatch("error", err);
                    return;
                }
            }

            function makeRequest() {
                let url = endpoints[0] + `/mq/receive-message/${keySSI}`;
                let options = {};

                let request = http.poll(url, options, timeout);

                request.then((response) => {
                    obs.dispatch("message", response);
                    makeRequest();
                }).catch((err) => {
                    obs.dispatch("error", err);
                });

                requests[obs] = request;
            }

            makeRequest();

        });
    });

    return obs;
}

function unsubscribe(keySSI, observable) {
    console.log("unsubscribe method from OpenDSU.loadApi('mq') is obsolete. Adapt your code to use the new getMQHandlerForDID");
    http.unpoll(requests[observable]);
}

function MQHandler(didDocument, domain, pollingTimeout) {
    let connectionTimeout;
    let timeout = pollingTimeout || 1000;
    let token;
    let expiryTime;
    let queueName = didDocument.getHash();

    function getURL(queueName, action, signature, messageID, callback) {
        let url
        if (typeof signature === "function") {
            callback = signature;
            signature = undefined;
            messageID = undefined;
        }

        if (typeof messageID === "function") {
            callback = messageID;
            messageID = undefined;
        }

        domain = didDocument.getDomain();

        if (!domain) {
            const sc = require("opendsu").loadAPI("sc");
            sc.getDIDDomain((err, didDomain) => {
                if (err) {
                    return callback(err);
                }

                domain = didDomain;
                __createURL();
            })
        } else {
            __createURL();
        }

        function __createURL() {
            bdns.getMQEndpoints(domain, (err, mqEndpoints) => {
                if (err) {
                    return callback(err);
                }

                url = `${mqEndpoints[0]}/mq/${domain}`
                switch (action) {
                    case "token":
                        url = `${url}/${queueName}/token`;
                        break;
                    case "get":
                        url = `${url}/get/${queueName}/${signature}`;
                        break;
                    case "put":
                        url = `${url}/put/${queueName}`;
                        break;
                    case "take":
                        url = `${url}/take/${queueName}/${signature}`;
                        break;
                    case "delete":
                        url = `${url}/delete/${queueName}/${messageID}/${signature}`;
                        break;
                    default:
                        throw Error(`Invalid action received ${action}`);
                }

                callback(undefined, url);
            })
        }
    }

    function ensureAuth(callback) {
        getURL(queueName, "token", (err, url) => {
            if (err) {
                return callback(err);
            }

            if (!token || (expiryTime && Date.now() + 2000 > expiryTime)) {
                callback = $$.makeSaneCallback(callback);
                return http.fetch(url)
                    .then(response => {
                        connectionTimeout = parseInt(response.headers.get("connection-timeout"));
                        return response.json()
                    })
                    .then(data => {
                        token = data.token;
                        expiryTime = data.expires;
                        callback(undefined, token);
                    })
                    .catch(err => callback(err));
            }

            callback(undefined, token);
        });
    }

    this.writeMessage = (message, callback) => {
        ensureAuth((err, token) => {
            if (err) {
                return callback(err);
            }

            getURL(queueName, "put", (err, url) => {
                if (err) {
                    return callback(err);
                }

                http.doPut(url, message, { headers: { "Authorization": token } }, callback);
            });
        })

    }

    function consumeMessage(action, waitForMore, callback) {
        if (typeof waitForMore === "function") {
            callback = waitForMore;
            waitForMore = false;
        }
        callback.__requestInProgress = true;
        ensureAuth((err, token) => {
            if (err) {
                return callback(err);
            }
            //somebody called abort before the ensureAuth resolved
            if (!callback.__requestInProgress) {
                return;
            }
            didDocument.sign(token, (err, signature) => {
                if (err) {
                    return callback(createOpenDSUErrorWrapper(`Failed to sign token`, err));
                }

                getURL(queueName, action, signature.toString("hex"), (err, url) => {
                    if (err) {
                        return callback(err);
                    }
                    let originalCb = callback;
                    //callback = $$.makeSaneCallback(callback);

                    let options = { headers: { Authorization: token } };

                    function makeRequest() {
                        let request = http.poll(url, options, connectionTimeout, timeout);
                        originalCb.__requestInProgress = request;

                        request.then(response => response.json())
                            .then((response) => {
                                //the return value of the listing callback helps to stop the polling mechanism in case that
                                //we need to stop to listen for more messages
                                let stop = callback(undefined, response);
                                if (waitForMore && !stop) {
                                    makeRequest();
                                }
                            })
                            .catch((err) => {
                                callback(err);
                            });
                    }

                    //somebody called abort before we arrived here
                    if (!originalCb.__requestInProgress) {
                        return;
                    }
                    makeRequest();
                })
            })
        })
    }

    this.waitForMessages = (callback) => {
        callback.__requestInProgress = true;

        ensureAuth((err, token) => {
            if (err) {
                return callback(err);
            }
            //somebody called abort before the ensureAuth resolved
            if (!callback.__requestInProgress) {
                return;
            }
            didDocument.sign(token, (err, signature) => {
                if (err) {
                    return callback(createOpenDSUErrorWrapper(`Failed to sign token`, err));
                }

                getURL(queueName, "take", signature.toString("hex"), (err, url) => {
                    if (err) {
                        return callback(err);
                    }

                    let options = { headers: { Authorization: token } };

                    async function makeRequest() {
                        let request = http.poll(url, options, connectionTimeout, timeout);
                        callback.__requestInProgress = request;

                        request.then(response => response.json())
                            .then((response) => {
                                callback(undefined, response);
                                if (callback.on) {
                                    makeRequest();
                                }
                            })
                            .catch((err) => {
                                if (callback.on) {
                                    makeRequest();
                                }
                            });
                    }

                    //somebody called abort before we arrived here
                    if (!callback.__requestInProgress) {
                        return;
                    }
                    makeRequest();
                })
            })
        })

    }

    this.previewMessage = (callback) => {
        consumeMessage("get", callback);
    };

    this.readMessage = (callback) => {
        consumeMessage("take", callback);
    };

    this.readAndWaitForMessages = (callback) => {
        consumeMessage("take", true, callback);
    };

    this.subscribe = this.readAndWaitForMessages;

    this.abort = (callback) => {
        let request = callback.__requestInProgress;
        //if we have an object it means that a http.poll request is in progress
        if (typeof request === "object") {
            request.abort();
            callback.__requestInProgress = undefined;
            delete callback.__requestInProgress;
            console.log("A request was aborted programmatically");
        } else {
            //if we have true value it means that an ensureAuth is in progress
            if (request) {
                callback.__requestInProgress = false;
                console.log("A request was aborted programmatically");
            }
        }
    }

    this.deleteMessage = (messageID, callback) => {
        ensureAuth((err, token) => {
            if (err) {
                return callback(err);
            }
            didDocument.sign(token, (err, signature) => {
                if (err) {
                    return callback(createOpenDSUErrorWrapper(`Failed to sign token`, err));
                }

                getURL(queueName, "delete", signature.toString("hex"), messageID, (err, url) => {
                    if (err) {
                        return callback(err);
                    }

                    http.fetch(url, {
                        method: "DELETE",
                        headers: { "Authorization": token }
                    })
                        .then(response => callback())
                        .catch(e => callback(e));
                });
            });
        });
    };
}

function getMQHandlerForDID(didDocument, domain, timeout) {
    return new MQHandler(didDocument, domain, timeout);
}

module.exports = {
    send,
    getHandler,
    unsubscribe,
    getMQHandlerForDID
}

},{"../bdns":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/bdns/index.js","../http":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/http/index.js","../utils/observable":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/utils/observable.js","opendsu":"opendsu"}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/notifications/index.js":[function(require,module,exports){
/*
KeySSI Notification API space
*/

let http = require("../http");
let bdns = require("../bdns");

function publish(keySSI, message, timeout, callback) {
    if (typeof timeout === 'function') {
        callback = timeout;
        timeout = 0;
    }
    bdns.getNotificationEndpoints(keySSI.getDLDomain(), (err, endpoints) => {
        if (err) {
            throw new Error(err);
        }

        if (!endpoints.length) {
            throw new Error("No notification endpoints are available!");
        }
        keySSI.getAnchorId((err, anchorId) => {
            if (err) {
                return callback(err);
            }
            let url = endpoints[0] + `/notifications/publish/${anchorId}`;

            if (typeof message !== 'string' && !$$.Buffer.isBuffer(message) && !ArrayBuffer.isView(message)) {
                message = JSON.stringify(message);
            }

            let options = {body: message, method: 'PUT'};

            let request = http.poll(url, options, undefined, timeout);

            request.then((response) => {
                callback(undefined, response);
            }).catch((err) => {
                return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to publish message`, err));
            });
        });
    });
}

let requests = new Map();

function getObservableHandler(keySSI, timeout) {
    timeout = timeout || 0;
    let obs = require("../utils/observable").createObservable();

    bdns.getNotificationEndpoints(keySSI.getDLDomain(), (err, endpoints) => {
        if (err) {
            throw new Error(err);
        }

        if (!endpoints.length) {
            throw new Error("No notification endpoints are available!");
        }

        keySSI.getAnchorId((err, anchorId) => {
            if (err) {
                return callback(err);
            }

            function makeRequest() {
                let url = endpoints[0] + `/notifications/subscribe/${anchorId}`;
                let options = {
                    method: 'POST'
                };
                let request = http.poll(url, options, undefined, timeout);

                request.then((response) => {
                    obs.dispatchEvent("message", response);

                    // If a subscription still exists, continue polling for messages
                    if (requests.has(obs)) {
                        makeRequest();
                    }
                }).catch((err) => {
                    obs.dispatchEvent("error", err);
                });

                requests.set(obs, request);
            }

            makeRequest();
        })
    })

    return obs;
}

function unsubscribe(observable) {
    const request = requests.get(observable);
    if (!request) {
        return;
    }
    http.unpoll(request);
    requests.delete(observable);
}

function isSubscribed(observable) {
    return requests.has(observable);
}

module.exports = {
    publish,
    getObservableHandler,
    unsubscribe,
    isSubscribed
}

},{"../bdns":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/bdns/index.js","../http":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/http/index.js","../utils/observable":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/utils/observable.js"}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/oauth/index.js":[function(require,module,exports){
const createOIDC = (options) => {
    const OIDC = require("./src/oidc/OIDC");
    return new OIDC(options);
}

module.exports = {
    createOIDC,
    getStorage: require("./src/util/Storage").getStorage,
    constants: require("./src/oidc/constants"),

}
},{"./src/oidc/OIDC":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/oauth/src/oidc/OIDC.js","./src/oidc/constants":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/oauth/src/oidc/constants.js","./src/util/Storage":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/oauth/src/util/Storage.js"}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/oauth/src/oidc/Client.js":[function(require,module,exports){
class Client {
    constructor(options) {
        this.options = options;
    }


    get clientId() {
        return this.options['clientId'] || this.options['client_id'];
    }


    get redirectPath() {
        return this.options['redirectPath'] || this.options['redirect_path'];
    }


    get redirectUri() {
        return location.protocol + '//' + location.host + this.redirectPath;
    }


    get scope() {
        return this.options['scope'];
    }
}


module.exports = Client;
},{}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/oauth/src/oidc/Issuer.js":[function(require,module,exports){
class Issuer {
    constructor(options) {
        this.options = options;
    }


    get issuer() {
        return this.options['issuer'];
    }


    get authorizationEndpoint() {
        return this.options['authorizationEndpoint'] || this.options['authorization_endpoint'];
    }


    get tokenEndpoint() {
        return this.options['tokenEndpoint'] || this.options['token_endpoint'];
    }
}


module.exports = Issuer;
},{}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/oauth/src/oidc/OIDC.js":[function(require,module,exports){
const RedirectInteraction = require('./interactions/Redirect');
const IFrameInteraction = require('./interactions/IFrame');
const PopupInteraction = require('./interactions/Popup');
const AuthorizationCodeGrant = require('./grants/AuthorizationCode');
const RefreshTokenGrant = require('./grants/RefreshToken');

const Browser = require('../util/Browser');
const Crypto = require('../util/Crypto');
const Storage = require('../util/Storage');
const Issuer = require('./Issuer');
const Client = require('./Client');


const ID_TOKEN = 'session.idToken';
const ACCESS_TOKEN = 'session.accessToken';
const REFRESH_TOKEN = 'session.refreshToken';
const EXPIRATION_TIMESTAMP = 'session.expirationTimestamp';
const AUTHORIZATION_CODE_VERIFIER = 'session.codeVerifier';
const AUTHORIZATION_STATE = 'session.state';
const INTERACTION = 'session.interaction';
const INTERACTION_IFRAME = 'iframe';
const INTERACTION_POPUP = 'popup';
const INTERACTION_REDIRECT = 'redirect';
const INTERACTION_REFRESH = 'refresh';
const BROWSER_LOCATION = 'browser.current.location';


const TOKEN_CHECK_INTERVAL = 1000 * 30;
const TOKEN_EXPIRATION_THRESHOLD = 1000 * 60;


class OIDC {
    issuer;
    client;
    storage;


    constructor(options) {
        this.storage = options.storage || Storage.getStorage();
        this.issuer = new Issuer(options.issuer);
        this.client = new Client(options.client);
        this.options = options;
        this.setPeriodicRefreshTimeout();
    }


    setPeriodicRefreshTimeout() {
        setTimeout(() => this.periodicRefresh(), this.options.tokenCheckInterval || TOKEN_CHECK_INTERVAL);
    }


    async periodicRefresh() {
        if (!this.isTokenSetExpiring(TOKEN_EXPIRATION_THRESHOLD)) {
            return this.setPeriodicRefreshTimeout();
        }

        //todo: dispatch error: event, register handler
        try {
            await this.refreshTokenSet();
        } catch (err) {
            console.log('periodicRefresh.tokenSetError', err);
        } finally {
            this.setPeriodicRefreshTimeout();
        }
    }


    async reconcile() {
        if (this.isCallbackPhaseActive()) {
            console.log('callbackPhaseActive');
            return this.resumeAuthentication()
                .catch((err) => this.resetAuthentication(err));
        }

        if (this.isAccessTokenInStorage()) {
            if (this.isTokenSetExpiring(TOKEN_EXPIRATION_THRESHOLD)) {
                try {
                    await this.refreshTokenSet();
                } catch (err) {
                    console.log('refreshTokenSetError', err);
                    return this.beginAuthentication();
                }
            }
        } else {
            return this.beginAuthentication();
        }
    }


    getToken(decoded) {
        const token = this.storage.get(ACCESS_TOKEN);
        return decoded ? this.decodeToken(token) : token;
    }


    getIdToken(decoded) {
        const token = this.storage.get(ID_TOKEN);
        return decoded ? this.decodeToken(token) : token;
    }


    isAccessTokenInStorage() {
        return !!this.storage.get(ACCESS_TOKEN);
    }


    isTokenSetExpiring(threshold = 0) {
        const expirationTimestamp = parseInt(this.storage.get(EXPIRATION_TIMESTAMP)) || 0;
        return Date.now() + threshold >= expirationTimestamp;
    }


    isCallbackPhaseActive() {
        return !!location.toString().includes(this.client.redirectPath) || !!location.toString().includes("/#code=");
    }


    refreshTokenSet() {
        console.log('refreshSession');
        return this.refreshWithRefreshToken()
            .catch((err) => this.refreshWithIFrame())
            .catch((err) => {
                //todo: improve error detection
                const loginRequired = err.message.includes('login_required');
                return this.refreshWithPopup(loginRequired ? 'login' : 'none')
            })
            .finally(() => this.storage.remove(INTERACTION));
    }


    refreshWithRefreshToken() {
        console.log('refresh.refreshToken');
        if (!this.storage.get(REFRESH_TOKEN)) {
            return Promise.reject(Error('Refresh token not found'));
        }
        const options = {
            refreshToken: this.storage.get(REFRESH_TOKEN)
        }

        this.storage.set(INTERACTION, INTERACTION_REFRESH);
        return RefreshTokenGrant.refreshToken(this.issuer, this.client, options)
            .then((response) => this.handleOAuthHttpResponse(response))
            .then((tokenSet) => this.updateStorageWithTokenSet(tokenSet));
    }


    refreshWithIFrame() {
        console.log('refresh.iframe');
        const authorizationContext = AuthorizationCodeGrant.getAuthorizationUrl(this.issuer, this.client, {prompt: 'none'});
        const context = {
            state: authorizationContext.state,
            codeVerifier: authorizationContext.codeVerifier,
        }

        this.storage.set(INTERACTION, INTERACTION_IFRAME);
        return this.getInteraction(INTERACTION_IFRAME)
            .run(authorizationContext.url)
            .then((response) => this.handleOAuthHttpResponse(response))
            .then((authorizationResponse) => this.handleAuthorizationResponse(context, authorizationResponse))
            .finally(() => this.storage.remove(INTERACTION));
    }


    refreshWithPopup(prompt) {
        console.log('refresh.popup');
        const authorizationContext = AuthorizationCodeGrant.getAuthorizationUrl(this.issuer, this.client, {prompt});
        const context = {
            state: authorizationContext.state,
            codeVerifier: authorizationContext.codeVerifier,
        }

        this.storage.set(INTERACTION, INTERACTION_POPUP);
        return this.getInteraction(INTERACTION_POPUP)
            .run(authorizationContext.url)
            .then((response) => this.handleOAuthHttpResponse(response))
            .then((authorizationResponse) => this.handleAuthorizationResponse(context, authorizationResponse))
            .finally(() => this.storage.remove(INTERACTION));
    }


    isRedirectInProgress() {
        return this.storage.get(INTERACTION) === INTERACTION_REDIRECT
    }


    beginAuthentication() {
        console.log('beginAuthentication');
        this.cleanUpAuthorizationStorage();
        this.cleanUpTokenStorage();

        this.storage.set(BROWSER_LOCATION, Browser.getCurrentLocation());

        const authorizationContext = AuthorizationCodeGrant.getAuthorizationUrl(this.issuer, this.client);
        this.storage.set(AUTHORIZATION_CODE_VERIFIER, authorizationContext.codeVerifier);
        this.storage.set(AUTHORIZATION_STATE, authorizationContext.state);

        this.storage.set(INTERACTION, INTERACTION_REDIRECT);
        return this.getInteraction(INTERACTION_REDIRECT).run(authorizationContext.url);
    }


    async resumeAuthentication() {
        const interactionType = this.storage.get(INTERACTION);
        const interaction = this.getInteraction(interactionType);
        console.log('resumeAuthentication', interactionType);
        if (!interaction) {
            throw new Error('Interaction not found');
        }
        const authorizationResponse = await interaction.resume();

        if (!interaction.allowResumeAuthentication) {
            return console.log('interaction will be handled at source');
        }

        const context = {
            state: this.storage.get(AUTHORIZATION_STATE),
            codeVerifier: this.storage.get(AUTHORIZATION_CODE_VERIFIER),
            redirect: this.storage.get(BROWSER_LOCATION)
        }

        // clear storage to prevent replay attacks
        this.cleanUpAuthorizationStorage();

        return this.handleOAuthHttpResponse(authorizationResponse)
            .then(() => this.handleAuthorizationResponse(context, authorizationResponse));
    }


    handleAuthorizationResponse(context, authorizationResponse) {
        if (context.state !== authorizationResponse.state) {
            console.log('invalidStateError', context.state, authorizationResponse.state);
            return Promise.reject(new Error('Invalid state'));
        }

        const options = {
            code: authorizationResponse.code,
            codeVerifier: context.codeVerifier
        };
        return AuthorizationCodeGrant.getToken(this.issuer, this.client, options)
            .then((response) => this.handleOAuthHttpResponse(response))
            .then((tokenSet) => this.updateStorageWithTokenSet(tokenSet))
            .then(() => this.cleanUpAuthorizationStorage())
            .then(() => {
                if (context.redirect) {
                    location.assign(context.redirect);
                }
            });
    }


    getInteraction(type) {
        let interaction;
        switch (type) {
            case INTERACTION_IFRAME:
                interaction = new IFrameInteraction();
                break;
            case INTERACTION_POPUP:
                interaction = new PopupInteraction();
                break;
            case INTERACTION_REDIRECT:
                interaction = new RedirectInteraction();
                break;
        }
        return interaction;
    }


    handleOAuthHttpResponse(response) {
        if (response['error']) {
            console.log('oauthError', response['error'], response['error_description'])
            return Promise.reject(Error(`OAuth Error[${response['error']}]: ${response['error_description']}`));
        }

        return Promise.resolve(response);
    }


    updateStorageWithTokenSet(tokenSet) {
        this.storage.set(EXPIRATION_TIMESTAMP, Date.now() + (tokenSet['expires_in'] * 1000));
        this.storage.set(ACCESS_TOKEN, tokenSet['access_token']);
        this.storage.set(REFRESH_TOKEN, tokenSet['refresh_token']);
        if (tokenSet['id_token']) {
            this.storage.set(ID_TOKEN, tokenSet['id_token']);
        }
    }


    decodeToken(token) {
        if (!token) {
            return null;
        }
        const [header, payload, signature] = token.split('.');
        return {
            header: JSON.parse(Crypto.decodeBase64EncodedData(header)),
            payload: JSON.parse(Crypto.decodeBase64EncodedData(payload)),
            signature
        }
    }


    cleanUpAuthorizationStorage() {
        this.storage.remove(INTERACTION);
        this.storage.remove(AUTHORIZATION_STATE);
        this.storage.remove(AUTHORIZATION_CODE_VERIFIER);
        this.storage.remove(BROWSER_LOCATION);
    }


    cleanUpTokenStorage() {
        this.storage.remove(ACCESS_TOKEN);
        this.storage.remove(ID_TOKEN);
        this.storage.remove(REFRESH_TOKEN);
        this.storage.remove(EXPIRATION_TIMESTAMP);
    }


    resetAuthentication(err) {
        console.log('resetAuthentication', err);
        this.cleanUpAuthorizationStorage();
        this.cleanUpTokenStorage();
        history.replaceState(null, null, ' ');
        if (err) {
            throw err;
        }
    }
}


OIDC.utils = {Browser};
module.exports = OIDC;
},{"../util/Browser":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/oauth/src/util/Browser.js","../util/Crypto":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/oauth/src/util/Crypto.js","../util/Storage":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/oauth/src/util/Storage.js","./Client":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/oauth/src/oidc/Client.js","./Issuer":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/oauth/src/oidc/Issuer.js","./grants/AuthorizationCode":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/oauth/src/oidc/grants/AuthorizationCode.js","./grants/RefreshToken":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/oauth/src/oidc/grants/RefreshToken.js","./interactions/IFrame":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/oauth/src/oidc/interactions/IFrame.js","./interactions/Popup":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/oauth/src/oidc/interactions/Popup.js","./interactions/Redirect":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/oauth/src/oidc/interactions/Redirect.js"}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/oauth/src/oidc/constants.js":[function(require,module,exports){
module.exports = {
    ID_TOKEN: 'session.idToken',
    ACCESS_TOKEN: 'session.accessToken',
    REFRESH_TOKEN: 'session.refreshToken',
    EXPIRATION_TIMESTAMP: 'session.expirationTimestamp',
    AUTHORIZATION_CODE_VERIFIER: 'session.codeVerifier',
    AUTHORIZATION_STATE: 'session.state',
    INTERACTION: 'session.interaction',
    INTERACTION_IFRAME: 'iframe',
    INTERACTION_POPUP: 'popup',
    INTERACTION_REDIRECT: 'redirect',
    INTERACTION_REFRESH: 'refresh',
    BROWSER_LOCATION: 'browser.current.location',
    TOKEN_CHECK_INTERVAL: 1000 * 30,
    TOKEN_EXPIRATION_THRESHOLD: 1000 * 60,
}
},{}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/oauth/src/oidc/grants/AuthorizationCode.js":[function(require,module,exports){
const Crypto = require('../../util/Crypto');


class AuthorizationCode {
    static getAuthorizationUrl(issuer, client, options = {}) {
        const codeVerifier = Crypto.generateCodeVerifier();
        const codeChallenge = Crypto.generateCodeChallenge(codeVerifier);
        const state = Crypto.generateState();

        const authorizationUrl = new URL(issuer.authorizationEndpoint);
        const query = authorizationUrl.searchParams;

        query.set('client_id', client.clientId);
        query.set('scope', client.scope);
        query.set('redirect_uri', client.redirectUri);
        query.set('response_type', 'code');
        query.set('response_mode', 'fragment');
        query.set('code_challenge_method', 'S256');
        query.set('code_challenge', codeChallenge);
        query.set('state', state);

        if (options.prompt) {
            query.set('prompt', options.prompt);
        }

        authorizationUrl.search = query.toString();
        return {state, codeVerifier, url: authorizationUrl.toString()};
    }


    static getToken(issuer, client, options) {
        const params = new URLSearchParams();
        params.append('grant_type', 'authorization_code');
        params.append('client_id', client.clientId);
        params.append('redirect_uri', client.redirectUri);
        params.append('code', options.code);
        params.append('code_verifier', options.codeVerifier);

        const payload = {
            method: 'POST',
            headers: {'Content-Type': 'application/x-www-form-urlencoded'},
            body: params
        }

        return fetch(issuer.tokenEndpoint, payload).then((response) => response.json())
    }
}


module.exports = AuthorizationCode;
},{"../../util/Crypto":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/oauth/src/util/Crypto.js"}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/oauth/src/oidc/grants/RefreshToken.js":[function(require,module,exports){
class RefreshToken {
    static refreshToken(issuer, client, options) {
        const params = new URLSearchParams();
        params.append('grant_type', 'refresh_token');
        params.append('client_id', client.clientId);
        params.append('redirect_uri', client.redirectUri);
        params.append('refresh_token', options.refreshToken);

        const payload = {
            method: 'POST',
            headers: {'Content-Type': 'application/x-www-form-urlencoded'},
            body: params
        }

        return fetch(issuer.tokenEndpoint, payload).then((response) => response.json())
    }
}


module.exports = RefreshToken;
},{}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/oauth/src/oidc/interactions/IFrame.js":[function(require,module,exports){
const Promises = require('../../util/Promises');
const Interaction = require('./Interaction');


const IFRAME_ID = 'oidc-sso-iframe';
const IFRAME_STYLE = 'visibility: hidden;';


class IFrame extends Interaction {
    createIFrame(url) {
        const iframe = document.createElement('iframe');
        iframe.setAttribute('id', IFRAME_ID);
        iframe.setAttribute('src', url);
        iframe.setAttribute('style', IFRAME_STYLE);
        iframe.addEventListener('load', () => {
            this.extractParamsFromContext(iframe.contentWindow.location,
                (params) => this.completed(params),
                (err) => this.failed(err));
        });

        document.getElementsByTagName('body')[0].appendChild(iframe);

        setTimeout(() => {
            this.failed(new Error('Loading IFrame timed out'));
        }, 5000);
    }


    cleanUp() {
        const element = document.getElementById(IFRAME_ID);
        element.parentNode.removeChild(element);
    }


    failed(err) {
        if (!this.isCompleted) {
            if (this.reject && typeof this.reject === 'function') {
                this.reject(err);
            }
            this.isCompleted = true;
            this.cleanUp();
        }
    }


    completed(response) {
        if (!this.isCompleted) {
            if (this.resolve && typeof this.resolve === 'function') {
                this.resolve(response);
            }
            this.isCompleted = true;
            this.cleanUp();
        }
    }


    resume() {
    }


    run(url) {
        const {promise, resolve, reject} = Promises.flatPromise();
        this.resolve = resolve;
        this.reject = reject;

        this.createIFrame(url);

        return promise;
    }
}


module.exports = IFrame;
},{"../../util/Promises":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/oauth/src/util/Promises.js","./Interaction":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/oauth/src/oidc/interactions/Interaction.js"}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/oauth/src/oidc/interactions/Interaction.js":[function(require,module,exports){
const Browser = require('../../util/Browser');


class Interaction {
    constructor(allowResumeAuthentication = false) {
        this.allowResumeAuthentication = allowResumeAuthentication;
    }


    extractParamsFromContext(context, resolve, reject) {
        let params = null;
        try {
            if (context.hash) {
                params = Browser.parseUrlHash(context.hash);
            } else if (context.search) {
                params = Browser.parseUrlQuery(context.search);
            }

            if (params !== null) {
                resolve(params);
            } else {
                reject(new Error(`Failed to extract params value from context[${this.constructor.name}]`))
            }
        } catch (err) {
            reject(err);
        }
    }
}


module.exports = Interaction;
},{"../../util/Browser":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/oauth/src/util/Browser.js"}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/oauth/src/oidc/interactions/Popup.js":[function(require,module,exports){
const Interaction = require('./Interaction');
const Promises = require('../../util/Promises');


const POPUP_NAME = 'oidc-sso-popup';
const POPUP_FEATURES = 'height=600,width=800';


class Popup extends Interaction {
    run(url) {
        const {promise, resolve, reject} = Promises.flatPromise();

        window.popupCompleted = () => {
            popupWindow.completed = true;
            this.extractParamsFromContext(popupWindow.location, resolve, reject);
        }

        const popupWindow = window.open(url, POPUP_NAME, POPUP_FEATURES);
        if (popupWindow === null) {
            throw new Error('Error loading authentication popup window');
        }

        const popupInterval = setInterval(() => {
            if (popupWindow.closed && !popupWindow.completed) {
                clearInterval(popupInterval);
                reject(new Error('Authentication popup window closed'));
            }
        });

        if (window.focus) {
            popupWindow.focus()
        }

        return promise;
    }


    cleanUp() {
        window.opener.popupCompleted();
        window.close();
    }


    resume() {
        if (window.opener) {
            this.cleanUp();
        } else {
            window.onload = () => this.cleanUp();
        }
    }
}


module.exports = Popup;
},{"../../util/Promises":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/oauth/src/util/Promises.js","./Interaction":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/oauth/src/oidc/interactions/Interaction.js"}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/oauth/src/oidc/interactions/Redirect.js":[function(require,module,exports){
const Interaction = require('./Interaction');
const Promises = require('../../util/Promises');


class Redirect extends Interaction {
    constructor() {
        super(true);
    }


    run(url) {
        window.location = url;
    }


    resume() {
        const {promise, resolve, reject} = Promises.flatPromise();
        this.extractParamsFromContext(location, resolve, reject);
        return promise;
    }
}


module.exports = Redirect;
},{"../../util/Promises":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/oauth/src/util/Promises.js","./Interaction":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/oauth/src/oidc/interactions/Interaction.js"}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/oauth/src/util/Browser.js":[function(require,module,exports){
function parseUrlHash(hash) {
    return parseUrlParams(hash.substring(1));
}


function parseUrlQuery(query) {
    return parseUrlParams(query.substring(1));
}


function parseUrlParams(value) {
    const params = {};
    const searchParams = new URLSearchParams(value);
    for (let [key, value] of searchParams.entries()) {
        params[key] = value;
    }
    return params;
}


function parseUrlParamsFallback(value) {
    const urlParams = {};
    const a = /\+/g;
    const r = /([^&;=]+)=?([^&;]*)/g;
    const decode = function (s) {
        return decodeURIComponent(s.replace(a, " "))
    };

    let search;
    while (search = r.exec(value)) {
        urlParams[decode(search[1])] = decode(search[2]);
    }

    return urlParams;
}


function getCurrentLocation() {
    return location.href.substring(location.origin.length)
}


function isItMe() {
    if (window.opener) {
        return false;
    } else if (window.top !== window.self) {
        return false
    } else {
        return true;
    }
}


module.exports = {
    parseUrlHash,
    parseUrlQuery,
    getCurrentLocation,
    isItMe
};
},{}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/oauth/src/util/Crypto.js":[function(require,module,exports){
const openDSU = require("opendsu");
const crypto = openDSU.loadAPI("crypto");

function getRandomValues(len) {
    const buff = crypto.generateRandom(len);
    const str = crypto.base64UrlEncodeJOSE(buff);
    return str.substring(0, len);
}

function generateState() {
    return getRandomValues(32);
}

function generateCodeVerifier() {
    return getRandomValues(64);
}

function generateCodeChallenge(verifier) {
    return crypto.base64UrlEncodeJOSE(crypto.sha256JOSE(verifier));
}

function decodeBase64EncodedData(data) {
   return $$.Buffer.from(data, "base64").toString();
}

module.exports = {
    generateState,
    generateCodeVerifier,
    generateCodeChallenge,
    decodeBase64EncodedData
}
},{"opendsu":"opendsu"}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/oauth/src/util/Promises.js":[function(require,module,exports){
function flatPromise() {
    let resolve, reject;
    let promise = new Promise((_resolve, _reject) => {
        resolve = _resolve;
        reject = _reject;
    });

    return {promise, resolve, reject};
}


module.exports = {
    flatPromise
}
},{}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/oauth/src/util/Storage.js":[function(require,module,exports){
const {prettyByte} = require("@msgpack/msgpack/dist/utils/prettyByte");

class Storage {
    get(key) {
        return localStorage.getItem(key);
    }


    getJSON(key) {
        return JSON.parse(this.get(key));
    }


    set(key, value) {
        localStorage.setItem(key, value);
    }


    setJSON(key, value) {
        this.set(key, JSON.stringify(value));
    }


    remove(key) {
        localStorage.removeItem(key);
    }
}

const getStorage = () => {
    if (!$$.storage) {
        $$.storage = new Storage();
    }

    return $$.storage;
}

module.exports = {
    getStorage
};
},{"@msgpack/msgpack/dist/utils/prettyByte":false}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/resolver/index.js":[function(require,module,exports){
(function (Buffer){(function (){
const KeySSIResolver = require("key-ssi-resolver");
const keySSISpace = require("opendsu").loadApi("keyssi");
const constants = require("../moduleConstants");

let {ENVIRONMENT_TYPES, KEY_SSIS} = require("../moduleConstants.js");
const {getWebWorkerBootScript, getNodeWorkerBootScript} = require("./resolver-utils");
const cache = require("../cache");
const {createOpenDSUErrorWrapper} = require("../error");
let dsuCache = cache.getWeakRefMemoryCache("mainDSUsCache");

const getResolver = (options) => {
    options = options || {};
    return KeySSIResolver.initialize(options);
};

const registerDSUFactory = (type, factory) => {
    KeySSIResolver.DSUFactory.prototype.registerDSUType(type, factory);
};

const createDSU = (templateKeySSI, options, callback) => {
    if (typeof options === "function") {
        callback = options;
        options = {addLog: true};
    }

    if (typeof options === "undefined") {
        options = {};
    }

    if (typeof options.addLog === "undefined") {
        options.addLog = true;
    }

    if (typeof templateKeySSI === "string") {
        try {
            templateKeySSI = keySSISpace.parse(templateKeySSI);
        } catch (e) {
            return callback(createOpenDSUErrorWrapper(`Failed to parse keySSI ${templateKeySSI}`, e));
        }
    }

    const keySSIResolver = getResolver(options);
    keySSIResolver.createDSU(templateKeySSI, options, (err, dsuInstance) => {
        if (err) {
            return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to create DSU instance`, err));
        }

        addDSUInstanceInCache(dsuInstance, callback);
    });
};

const createDSUx = (domain, ssiType, options, callback) => {
    const templateKeySSI = keySSISpace.createTemplateKeySSI(ssiType, domain);
    createDSU(templateKeySSI, options, callback);
}

const createSeedDSU = (domain, options, callback) => {
    const seedSSI = keySSISpace.createTemplateSeedSSI(domain);
    createDSU(seedSSI, options, callback);
}

const createArrayDSU = (domain, arr, options, callback) => {
    const arraySSI = keySSISpace.createArraySSI(domain, arr);
    createDSUForExistingSSI(arraySSI, options, callback);
}

const createConstDSU = (domain, constString, options, callback) => {
    const constSSI = keySSISpace.createConstSSI(domain, constString);
    createDSUForExistingSSI(constSSI, options, callback);
}

const createDSUForExistingSSI = (ssi, options, callback) => {
    if (typeof options === "function") {
        callback = options;
        options = {};
    }
    if (!options) {
        options = {};
    }
    options.useSSIAsIdentifier = true;
    createDSU(ssi, options, callback);
};

/**
 * Check if the DSU is up to date by comparing its
 * current anchored HashLink with the latest anchored version.
 * If a new anchor is detected refresh the DSU
 */
const getLatestDSUVersion = (dsu, callback) => {
    dsu.getCurrentAnchoredHashLink((err, current) => {
        if (err) {
            return callback(err);
        }

        dsu.getLatestAnchoredHashLink((err, latest) => {
            if (err) {
                return callback(err);
            }

            if (current && current.getHash() === latest.getHash()) {
                // No new version detected
                return callback(undefined, dsu);
            }

            dsu.hasUnanchoredChanges((err, result) => {
                if (err) {
                    return callback(err);
                }

                if (result) {
                    // The DSU is in the process of anchoring - don't refresh it
                    return callback(undefined, dsu);
                }

                // A new version is detected, refresh the DSU content
                dsu.refresh((err) => {
                    if (err) {
                        return callback(err);
                    }
                    return callback(undefined, dsu);
                });
            })
        });
    });
}

const loadDSUVersion = (keySSI, versionHashlink, options, callback) => {
    if (typeof options === "function") {
        callback = options;
        options = {};
    }

    if (typeof keySSI === "string") {
        try {
            keySSI = keySSISpace.parse(keySSI);
        } catch (e) {
            return callback(createOpenDSUErrorWrapper(`Failed to parse keySSI ${keySSI}`, e));
        }
    }

    const keySSIResolver = getResolver(options);
    options.versionHashlink = versionHashlink;
    keySSIResolver.loadDSU(keySSI, options, callback);
}

const getDSUVersionHashlink = (keySSI, versionNumber, callback) => {
    if (typeof keySSI === "string") {
        try {
            keySSI = keySSISpace.parse(keySSI);
        } catch (e) {
            return callback(createOpenDSUErrorWrapper(`Failed to parse keySSI ${keySSI}`, e));
        }
    }
    const anchoringAPI = require("opendsu").loadAPI("anchoring");
    const anchoringX = anchoringAPI.getAnchoringX();
    keySSI.getAnchorId((err, anchorId) => {
        if (err) {
            return callback(err);
        }
        anchoringX.getAllVersions(anchorId, (err, versions) => {
            if (err) {
                return callback(err);
            }

            if (!versions || !versions.length) {
                return callback(createOpenDSUErrorWrapper(`No versions found for anchor ${anchorId}`));
            }
            const versionHashLink = versions[versionNumber];
            if (!versionHashLink) {
                return callback(createOpenDSUErrorWrapper(`Version number ${versionNumber} for anchor ${anchorId} does not exist.`));
            }

            callback(undefined, versionHashLink);
        })
    })
}

const getVersionNumberFromKeySSI = (keySSI) => {
    let versionNumber;
    try {
        versionNumber = parseInt(keySSI.getHint());
    } catch (e) {
        return undefined;
    }

    if (versionNumber < 0) {
        return undefined;
    }

    return versionNumber;
}

const loadDSUVersionBasedOnVersionNumber = (keySSI, versionNumber, callback) => {
    getDSUVersionHashlink(keySSI, versionNumber, (err, versionHashLink) => {
        if (err) {
            return callback(err);
        }

        loadDSUVersion(keySSI, versionHashLink, callback);
    })
}

let tryToRunRecoveryContentFnc = (keySSI, recoveredInstance, options, anchorFakeHistory, anchorFakeLastVersion, callback) => {
    if (typeof options.contentRecoveryFnc === "function") {
        let ignoreError = false;
        try {
            let cb = (err) => {
                ignoreError = true;
                if (err) {
                    return callback(createOpenDSUErrorWrapper(`Failed to recover fallback DSU for keySSI ${keySSI.getIdentifier()}`, err));
                }

                return callback(undefined, recoveredInstance);
            };
            keySSI.getAnchorId((err, anchorId) => {
                if (err) {
                    throw createOpenDSUErrorWrapper(`Surprise error!`, err);
                }
                let {
                    markAnchorForRecovery,
                    unmarkAnchorForRecovery
                } = require("opendsu").loadApi("anchoring").getAnchoringX();
                markAnchorForRecovery(anchorId, anchorFakeHistory, anchorFakeLastVersion);
                options.contentRecoveryFnc(recoveredInstance, (err, dsu) => {
                    if (!err) {
                        //we clean the fake history after the successful recovery in order to let
                        unmarkAnchorForRecovery(anchorId);
                    }
                    cb(err, dsu);
                });
            });

        } catch (err) {
            if (!ignoreError) {
                return callback(createOpenDSUErrorWrapper(`Caught an error in contentRecoveryFunction`, err));
            }
            throw err;
        }
        //callback already called above
        return;
    }
    callback(undefined, recoveredInstance);
}

const loadFallbackDSU = (keySSI, options, callback) => {
    if (typeof keySSI === "string") {
        try {
            keySSI = keySSISpace.parse(keySSI);
        } catch (e) {
            return callback(createOpenDSUErrorWrapper(`Failed to parse keySSI ${keySSI}`, e));
        }
    }
    const anchoringAPI = require("opendsu").loadAPI("anchoring");
    const anchoringX = anchoringAPI.getAnchoringX();

    keySSI.getAnchorId((err, anchorId) => {
        if (err) {
            return callback(createOpenDSUErrorWrapper(`Failed to get anchorId for keySSI ${keySSI.getIdentifier()}`, err));
        }

        anchoringX.getAllVersions(anchorId, (err, versions) => {
            if (err) {
                return callback(createOpenDSUErrorWrapper(`Failed to get versions for anchorId ${anchorId}`, err));
            }

            if (!versions || !versions.length) {
                return callback(createOpenDSUErrorWrapper(`No versions found for anchorId ${anchorId}`));
            }

            const __loadFallbackDSURecursively = (index) => {
                const versionHashlink = versions[index];
                if (typeof versionHashlink === "undefined") {
                    //we weren't able to load any version of the dsu (const or not)
                    options.addLog = false;
                    return createDSUForExistingSSI(keySSI, options, (err, recoveredInstance) => {
                        if (err) {
                            return callback(err);
                        }

                        return tryToRunRecoveryContentFnc(keySSI, recoveredInstance, options, [], versions[versions.length - 1], callback);
                    });
                }

                loadDSUVersion(keySSI, versionHashlink, options, (err, dsuInstance) => {
                    if (err) {
                        return __loadFallbackDSURecursively(index - 1);
                    }
                    if (index < versions.length - 1) {
                        return tryToRunRecoveryContentFnc(keySSI, dsuInstance, options, versions.slice(0, index), versions[versions.length - 1], callback);
                    }
                    callback(undefined, dsuInstance);
                })
            }

            __loadFallbackDSURecursively(versions.length - 1);
        })
    })
}

const loadDSU = (keySSI, options, callback) => {
    if (typeof options === "function") {
        callback = options;
        options = {};
    }

    if (typeof keySSI === "string") {
        try {
            keySSI = keySSISpace.parse(keySSI);
        } catch (e) {
            return callback(createOpenDSUErrorWrapper(`Failed to parse keySSI ${keySSI}`, e));
        }
    }

    const versionNumber = keySSI.getDSUVersionHint();
    if (Number.isInteger(versionNumber)) {
        return loadDSUVersionBasedOnVersionNumber(keySSI, versionNumber, callback);
    }

    if (options && options.recoveryMode) {
        return loadFallbackDSU(keySSI, options, callback);
    }

    const loadDSU = (addInCache) => {

        const keySSIResolver = getResolver(options);
        keySSIResolver.loadDSU(keySSI, options, (err, dsuInstance) => {
            if (err) {
                return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to load DSU`, err));
            }

            if (addInCache) {
                return addDSUInstanceInCache(dsuInstance, callback);
            }

            callback(undefined, dsuInstance);
        });
    };

    if (typeof options === 'object' && options !== null && options.skipCache) {
        return loadDSU(false);
    }

    keySSI.getAnchorId((err, cacheKey) => {
        if (err) {
            return callback(err);
        }
        const cachedDSU = dsuCache.get(cacheKey);
        if (cachedDSU) {
            return getLatestDSUVersion(cachedDSU, callback);
        }
        loadDSU(true);
    })
};

/*
    boot the DSU in a thread
 */
const getDSUHandler = (dsuKeySSI) => {
    if (typeof dsuKeySSI === "string") {
        // validate the dsuKeySSI to ensure it's valid
        try {
            keySSISpace.parse(dsuKeySSI);
        } catch (error) {
            const errorMessage = `Cannot parse keySSI ${dsuKeySSI}`;
            console.error(errorMessage, error);
            throw new Error(errorMessage);
        }
    }

    const syndicate = require("syndicate");

    function DSUHandler() {
        switch ($$.environmentType) {
            case ENVIRONMENT_TYPES.SERVICE_WORKER_ENVIRONMENT_TYPE:
                throw new Error(`service-worker environment is not supported!`);
            case ENVIRONMENT_TYPES.BROWSER_ENVIRONMENT_TYPE:
                if (!window.Worker) {
                    throw new Error("Current environment does not support Web Workers!");
                }

                console.log("[Handler] starting web worker...");

                let blobURL = getWebWorkerBootScript(dsuKeySSI);
                workerPool = syndicate.createWorkerPool({
                    bootScript: blobURL,
                    maximumNumberOfWorkers: 1,
                    workerStrategy: syndicate.WorkerStrategies.WEB_WORKERS,
                });

                setTimeout(() => {
                    // after usage, the blob must be removed in order to avoit memory leaks
                    // it requires a timeout in order for syndicate to be able to get the blob script before it's removed
                    URL.revokeObjectURL(blobURL);
                });

                break;
            case ENVIRONMENT_TYPES.NODEJS_ENVIRONMENT_TYPE: {
                console.log("[Handler] starting node worker...");

                const script = getNodeWorkerBootScript(dsuKeySSI);
                workerPool = syndicate.createWorkerPool({
                    bootScript: script,
                    maximumNumberOfWorkers: 1,
                    workerOptions: {
                        eval: true,
                    },
                });

                break;
            }
            default:
                throw new Error(`Unknown environment ${$$.environmentType}!`);
        }

        const sendTaskToWorker = (task, callback) => {
            workerPool.addTask(task, (err, message) => {
                if (err) {
                    return callback(err);
                }

                let {error, result} =
                    typeof Event !== "undefined" && message instanceof Event ? message.data : message;

                if (error) {
                    return callback(error);
                }

                if (result) {
                    if (result instanceof Uint8Array) {
                        // the buffers sent from the worker will be converted to Uint8Array when sending to parent
                        result = Buffer.from(result);
                    } else {
                        try {
                            result = JSON.parse(result);
                        } catch (error) {
                            // if parsing fails then the string must be an ordinary one so we leave it as it is
                        }
                    }
                }

                callback(error, result);
            });
        };

        this.callDSUAPI = function (fn, ...args) {
            const fnArgs = [...args];
            const callback = fnArgs.pop();

            const parseResult = (error, result) => {
                if (error) {
                    return callback(error);
                }

                // try to recreate keyssi
                try {
                    result = keySSISpace.parse(result);
                } catch (error) {
                    // if it fails, then the result is not a valid KeySSI
                }
                callback(undefined, result);
            };

            sendTaskToWorker({fn, args: fnArgs}, parseResult);
        };

        this.callApi = function (fn, ...args) {
            const apiArgs = [...args];
            const callback = apiArgs.pop();
            sendTaskToWorker({api: fn, args: apiArgs}, callback);
        };
    }

    let res = new DSUHandler();
    let availableFunctions = [
        "addFile",
        "addFiles",
        "addFolder",
        "appendToFile",
        "createFolder",
        "delete",
        //"extractFile",
        //"extractFolder",
        "listFiles",
        "listFolders",
        "mount",
        "readDir",
        "readFile",
        "rename",
        "unmount",
        "writeFile",
        "listMountedDSUs",
        "beginBatch",
        "commitBatch",
        "cancelBatch",
    ];

    function getWrapper(functionName) {
        return function (...args) {
            res.callDSUAPI(functionName, ...args);
        }.bind(res);
    }

    for (let f of availableFunctions) {
        res[f] = getWrapper(f);
    }

    return res;
};

const getRemoteHandler = (dsuKeySSI, remoteURL, presentation) => {
    throw Error("Not available yet");
};

function invalidateDSUCache(dsuKeySSI, callback) {
    try {
        if (typeof dsuKeySSI === "string") {
            dsuKeySSI = keySSISpace.parse(dsuKeySSI);
        }
    } catch (e) {
        console.error(e);
    }
    dsuKeySSI.getAnchorId((err, cacheKey) => {
        if (err) {
            return callback(err);
        }
        if (cacheKey) {
            delete dsuCache.set(cacheKey, undefined);
        }

        callback();
    });
}

function addDSUInstanceInCache(dsuInstance, callback) {
    dsuInstance.getKeySSIAsObject((err, keySSI) => {
        if (err) {
            return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to retrieve keySSI`, err));
        }
        keySSI.getAnchorId((err, cacheKey) => {
            if (err) {
                return callback(err);
            }
            dsuCache.set(cacheKey, dsuInstance);
            callback(undefined, dsuInstance);
        });
    });
}

/**
 *
 * @param keySSI
 * @param callback
 * @returns: (error -> error.rootCause: network | throttler | business | unknown, result: true | false)
 */
function dsuExists(keySSI, callback) {
    const anchoringAPI = require("opendsu").loadAPI("anchoring");
    const anchoringX = anchoringAPI.getAnchoringX();
    if (typeof keySSI === "string") {
        try {
            keySSI = keySSISpace.parse(keySSI);
        } catch (e) {
            return callback(createOpenDSUErrorWrapper(`Failed to parse KeySSI <${keySSI}>`, e, constants.ERROR_ROOT_CAUSE.DATA_INPUT));
        }
    }
    keySSI.getAnchorId((err, anchorId) => {
        if (err) {
            return callback(createOpenDSUErrorWrapper(`Failed get anchor id`, err));
        }

        anchoringX.getLastVersion(anchorId, (err, anchorVersion) => {
            if (err) {
                if (err.rootCause === constants.ERROR_ROOT_CAUSE.MISSING_DATA) {
                    return callback(undefined, false);
                }

                return callback(createOpenDSUErrorWrapper(`Failed to get version for anchor id <${anchorId}>`, err));
            }

            if (typeof anchorVersion === "undefined" || anchorVersion === "") {
                return callback(undefined, false);
            }

            callback(undefined, true);
        })
    })
}

module.exports = {
    createDSU,
    createDSUx,
    createSeedDSU,
    createConstDSU,
    createArrayDSU,
    createDSUForExistingSSI,
    loadDSU,
    getDSUHandler,
    registerDSUFactory,
    invalidateDSUCache,
    loadDSUVersion,
    dsuExists
};

}).call(this)}).call(this,require("buffer").Buffer)

},{"../cache":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/cache/index.js","../error":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/error/index.js","../moduleConstants":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/moduleConstants.js","../moduleConstants.js":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/moduleConstants.js","./resolver-utils":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/resolver/resolver-utils.js","buffer":false,"key-ssi-resolver":"key-ssi-resolver","opendsu":"opendsu","syndicate":"syndicate"}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/resolver/resolver-utils.js":[function(require,module,exports){
(function (global){(function (){
function getWebWorkerBootScript(dsuKeySSI) {
    const scriptLocation = document.currentScript
        ? document.currentScript
        : new Error().stack.match(/([^ ^(\n])*([a-z]*:\/\/\/?)*?[a-z0-9\/\\]*\.js/gi)[0];
    let blobURL = URL.createObjectURL(
        new Blob(
            [
                `
                (function () {
                    importScripts("${scriptLocation}");
                    require("opendsu").loadApi("boot")("${dsuKeySSI}");                                    
                })()
                `,
            ],
            { type: "application/javascript" }
        )
    );
    return blobURL;
}

function getNodeWorkerBootScript(dsuKeySSI) {
    const openDSUScriptPath = global.bundlePaths.openDSU.replace(/\\/g, "\\\\").replace(".js", "");
    const script = `require("${openDSUScriptPath}");require('opendsu').loadApi('boot')('${dsuKeySSI}')`;
    return script;
}

module.exports = {
    getWebWorkerBootScript,
    getNodeWorkerBootScript,
};

}).call(this)}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/sc/index.js":[function(require,module,exports){
/*
    Security Context related functionalities

 */

    const constants = require("../moduleConstants");
    const openDSU = require("opendsu");
    const config = openDSU.loadAPI("config")
    const crypto = openDSU.loadAPI("crypto")
    const MainDSU = require("./lib/MainDSU");
    const SecurityContext = require("./lib/SecurityContext");
    
    const getVaultDomain = (callback) => {
        config.getEnv(constants.VAULT_DOMAIN, (err, vaultDomain) => {
            if (err || !vaultDomain) {
                console.log(`The property <${constants.DOMAIN}> is deprecated in environment.js. Use the property <${constants.VAULT_DOMAIN}> instead`)
                return config.getEnv(constants.DOMAIN, callback);
            }
    
            callback(undefined, vaultDomain);
        });
    }
    
    const getDIDDomain = (callback) => {
        config.getEnv(constants.DID_DOMAIN, callback);
    }
    
    const securityContextIsInitialised = () => {
        if (typeof $$.sc === "undefined") {
            return false;
        }
    
        return $$.sc.isInitialised();
    }
    
    const getSecurityContext = () => {
        if (typeof $$.sc === "undefined") {
            $$.sc = new SecurityContext();
        }
    
        return $$.sc;
    };
    
    const refreshSecurityContext = (pin) => {
        $$.sc = new SecurityContext(undefined, pin);
        return $$.sc;
    };
    
    const getMainEnclave = (callback) => {
        if (!$$.sc && !callback) {
            return;
        }
        const sc = getSecurityContext();
        if (sc.isInitialised()) {
            return sc.getMainEnclaveDB(callback);
        } else {
            sc.on("initialised", () => {
                sc.getMainEnclaveDB(callback);
            });
        }
    }
    
    const getSharedEnclave = (callback) => {
        const sc = getSecurityContext();
        if (sc.isInitialised()) {
            sc.getSharedEnclaveDB(callback);
        } else {
            sc.on("initialised", () => {
                sc.getSharedEnclaveDB(callback);
            });
        }
    }
    
    const sharedEnclaveExists = () => {
        const sc = getSecurityContext();
        return sc.sharedEnclaveExists();
    }
    
    const configEnvironment = (config, refreshSC, callback) => {
        if (typeof refreshSC === "function") {
            callback = refreshSC;
            refreshSC = true;
        }
        MainDSU.getMainDSU((err, mainDSU) => {
            if (err) {
                return callback(createOpenDSUErrorWrapper("Failed to get main DSU", err));
            }
    
            mainDSU.writeFile(constants.ENVIRONMENT_PATH, JSON.stringify(config), (err) => {
                if (err) {
                    return callback(createOpenDSUErrorWrapper("Failed to write env", err));
                }
    
                if (refreshSC) {
                    const pin = getSecurityContext().getPaddedPIN();
                    const sc = refreshSecurityContext(pin);
                    sc.on("initialised", () => callback(undefined, sc));
                } else {
                    const sc = getSecurityContext();
                    if (securityContextIsInitialised()) {
                        return callback(undefined, sc);
                    }
    
                    sc.on("initialised", () => {
                        callback(undefined, sc)
                    });
                }
            });
        });
    }
    
    const setEnclave = (enclave, type, callback) => {
        config.readEnvFile((err, config) => {
            if (err) {
                return callback(err);
            }
            enclave.getDID((err, did) => {
                if (err) {
                    return callback(err);
                }
    
                config[openDSU.constants[type].DID] = did;
                enclave.getKeySSI((err, keySSI) => {
                    if (err) {
                        return callback(err);
                    }
    
                    setEnclaveKeySSI(type, keySSI, config);
    
                    config[openDSU.constants[type].TYPE] = enclave.getEnclaveType();
                    configEnvironment(config, callback);
    
                })
            })
        })
    }
    
    const setEnclaveKeySSI = (type, keySSI, config) => {
        const sc = getSecurityContext();
        const pin = sc.getPaddedPIN();
    
        if (type != "SHARED_ENCLAVE" || pin == undefined) {
            config[openDSU.constants[type].KEY_SSI] = keySSI;
            return;
        }
    
        const decodedBase58 = crypto.decodeBase58(keySSI);
        const encryptedKey = crypto.encrypt(decodedBase58, pin)
        const base58EncryptedKey = crypto.encodeBase58(encryptedKey);
        config[openDSU.constants[type].KEY_SSI] = base58EncryptedKey;
    
    }
    
    const deleteEnclave = (type, callback) => {
        config.readEnvFile((err, env) => {
            if (err) {
                return callback(err);
            }
    
            delete env[openDSU.constants[type].DID];
            delete env[openDSU.constants[type].KEY_SSI];
            delete env[openDSU.constants[type].TYPE];
            configEnvironment(env, callback);
        })
    }
    
    const deleteSharedEnclave = (callback) => {
        deleteEnclave("SHARED_ENCLAVE", callback);
    }
    
    const setMainEnclave = (enclave, callback) => {
        setEnclave(enclave, "MAIN_ENCLAVE", callback);
    };
    
    const setSharedEnclave = (enclave, callback) => {
        setEnclave(enclave, "SHARED_ENCLAVE", callback);
    };
    
    const setPIN = (pin) => {
        const sc = getSecurityContext();
        sc.setPIN(pin);
    }

    const isPINNeeded = async () => {
        const sc = getSecurityContext();
        return await sc.isPINNeeded();
    }
    
    
    module.exports = {
        setMainDSU: MainDSU.setMainDSU,
        getMainDSU: MainDSU.getMainDSU,
        getVaultDomain,
        getSecurityContext,
        refreshSecurityContext,
        getDIDDomain,
        securityContextIsInitialised,
        getMainEnclave,
        setMainEnclave,
        getSharedEnclave,
        setSharedEnclave,
        setEnclave,
        deleteSharedEnclave,
        configEnvironment,
        sharedEnclaveExists,
        setPIN,
        setEnclaveKeySSI,
        isPINNeeded
    };
    
},{"../moduleConstants":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/moduleConstants.js","./lib/MainDSU":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/sc/lib/MainDSU.js","./lib/SecurityContext":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/sc/lib/SecurityContext.js","opendsu":"opendsu"}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/sc/lib/InMemoryMainDSU.js":[function(require,module,exports){
(function (Buffer){(function (){
function InMemoryMainDSU() {
    const obj = {};
    obj["/environment.json"] = Buffer.from(JSON.stringify({
        vaultDomain: "vault",
        didDomain: "vault"
    }))

    obj["environment.json"] = obj["/environment.json"];

    this.writeFile = (path, data, callback) => {
        if (!path.startsWith("/")) {
            path = `/${path}`;
        }
        obj[path] = data;
        callback();
    }

    this.readFile = (path, callback) => {
        if (!path.startsWith("/")) {
            path = `/${path}`;
        }
        callback(undefined, obj[path]);
    }

    this.refresh = (callback)=>{
        callback();
    }
}

module.exports = InMemoryMainDSU;
}).call(this)}).call(this,require("buffer").Buffer)

},{"buffer":false}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/sc/lib/MainDSU.js":[function(require,module,exports){
const constants = require("../../moduleConstants");
const {getURLForSsappContext} = require("../../utils/getURLForSsappContext");
const openDSU = require("opendsu");
const http = openDSU.loadAPI("http")
const keySSISpace = openDSU.loadAPI("keyssi");
const resolver = openDSU.loadAPI("resolver");

const setMainDSU = (mainDSU) => {
    return setGlobalVariable("rawDossier", mainDSU);
};

function getMainDSU(callback) {
    callback = $$.makeSaneCallback(callback);
    if (globalVariableExists("rawDossier")) {
        return callback(undefined, getGlobalVariable("rawDossier"));
    }
    switch ($$.environmentType) {
        case constants.ENVIRONMENT_TYPES.WEB_WORKER_ENVIRONMENT_TYPE:
        case constants.ENVIRONMENT_TYPES.SERVICE_WORKER_ENVIRONMENT_TYPE:

        function __getMainDSUFromSw() {
            if (!globalVariableExists("rawDossier")) {
                setTimeout(() => {
                    __getMainDSUFromSw()
                }, 100);
                return;
            }
            return callback(undefined, getGlobalVariable("rawDossier"));
        }

            return __getMainDSUFromSw();
        case constants.ENVIRONMENT_TYPES.BROWSER_ENVIRONMENT_TYPE:
            return getMainDSUForIframe(callback);
        case constants.ENVIRONMENT_TYPES.NODEJS_ENVIRONMENT_TYPE:
            return getMainDSUForNode(callback);
        default:
            return callback(Error("Main DSU does not exist in the current context."));
    }
}

function getMainDSUForNode(callback) {
    if (process.env.MAIN_WALLET) {
        const resolver = require("opendsu").loadAPI("resolver");
        return resolver.loadDSU(process.env.MAIN_WALLET, (err, mainDSU) => {
            if (err) {
                return callback(err);
            }

            setMainDSU(mainDSU);
            callback(undefined, mainDSU);
        });
    }
    const InMemoryMainDSU = require("./InMemoryMainDSU");
    const mainDSU = new InMemoryMainDSU();
    console.log("Warning: Initializing in memory wallet ...");
    setMainDSU(mainDSU);
    callback(undefined, mainDSU);
}

function getMainDSUForIframe(callback) {
    let mainDSU = getGlobalVariable("rawDossier");
    if (mainDSU) {
        return callback(undefined, mainDSU);
    }

    http.doGet(getURLForSsappContext("/getSSIForMainDSU"), (err, res) => {
        if (err || res.length === 0) {
            return callback(createOpenDSUErrorWrapper("Failed to get main DSU SSI", err));
        }

        let mainSSI = keySSISpace.parse(res);
        resolver.loadDSU(mainSSI, (err, mainDSU) => {
            if (err) {
                return callback(createOpenDSUErrorWrapper("Failed to load main DSU ", err));
            }

            setMainDSU(mainDSU);
            callback(undefined, mainDSU);
        });
    });
}

module.exports = {
    getMainDSU,
    setMainDSU
}

},{"../../moduleConstants":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/moduleConstants.js","../../utils/getURLForSsappContext":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/utils/getURLForSsappContext.js","./InMemoryMainDSU":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/sc/lib/InMemoryMainDSU.js","opendsu":"opendsu"}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/sc/lib/SecurityContext.js":[function(require,module,exports){
const constants = require("../../moduleConstants");

function SecurityContext(target, PIN) {
    target = target || this;

    const ObservableMixin = require("../../utils/ObservableMixin");
    ObservableMixin(target);
    const openDSU = require("opendsu");
    const config = openDSU.loadAPI("config");
    const enclaveAPI = openDSU.loadAPI("enclave");
    const keySSIApi = openDSU.loadAPI("keyssi");
    const crypto = openDSU.loadAPI("crypto");
    let enclave;
    let sharedEnclave;
    let storageDSU;
    let scDSUKeySSI;
    let mainDID;
    let paddedPIN;

    let initialised = false;
    let pinNeeded = false;

    const initSharedEnclave = async () => {
        let sharedEnclaveType;
        let sharedEnclaveKeySSI;
        try {
            sharedEnclaveType = await $$.promisify(config.getEnv)(constants.SHARED_ENCLAVE.TYPE);
        } catch (e) {
            return;
        }
        if (!sharedEnclaveType) {
            return;
        }
        try {
            sharedEnclaveKeySSI = await $$.promisify(config.getEnv)(constants.SHARED_ENCLAVE.KEY_SSI);
        } catch (e) {
            if (sharedEnclaveType === constants.ENCLAVE_TYPES.WALLET_DB_ENCLAVE) {
                throw Error(`A key SSI should be provided when creating a WalletDB enclave`);
            }
        }

        if (PIN == undefined) {
            try {
                keySSIApi.parse(sharedEnclaveKeySSI);
                sharedEnclave = enclaveAPI.createEnclave(sharedEnclaveType, sharedEnclaveKeySSI);
                return sharedEnclave;
            }
            catch (err) {
                pinNeeded = true;
                sharedEnclave = new Promise((res, rej) => {
                    target.on("pinSet", async () => {
                        await initSharedEnclave();
                        pinNeeded = false;
                        res(sharedEnclave)
                    })
                })
                return;
            }
        } else {
            const decodedBase58 = crypto.decodeBase58(sharedEnclaveKeySSI);
            const decryptedKey = crypto.decrypt(decodedBase58, paddedPIN);
            const keySSI = crypto.encodeBase58(decryptedKey);
            try {
                sharedEnclave = enclaveAPI.createEnclave(sharedEnclaveType, keySSI);
            }
            catch (e) {
                throw Error(e);
            }
        }
    }

    target.init = async () => {
        let enclaveType;
        let enclaveDID;
        try {
            enclaveType = await $$.promisify(config.getEnv)(constants.MAIN_ENCLAVE.TYPE);
        } catch (e) {
            throw createOpenDSUErrorWrapper(`Failed to get env enclaveType`, e);
        }

        if (typeof enclaveType === "undefined") {
            enclaveType = constants.ENCLAVE_TYPES.MEMORY_ENCLAVE;
        }

        try {
            enclaveDID = await $$.promisify(config.getEnv)(constants.MAIN_ENCLAVE.DID);
        } catch (e) {
            throw createOpenDSUErrorWrapper(`Failed to get env enclaveDID`, e);
        }

        enclave = enclaveAPI.createEnclave(enclaveType);
        await initSharedEnclave();
        const __saveEnclaveDIDAndFinishInit = async () => {
            if (typeof enclaveDID === "undefined") {
                enclaveDID = await $$.promisify(enclave.getDID)();
                try {
                    await $$.promisify(config.setEnv)(constants.MAIN_ENCLAVE.DID, enclaveDID)
                } catch (e) {
                    throw createOpenDSUErrorWrapper(`Failed to set env enclaveDID`, e);
                }
            }

            if (!sharedEnclave || isPromise(sharedEnclave)) {
                return finishInit();
            }
            if (!sharedEnclave.isInitialised()) {
                sharedEnclave.on("initialised", () => {
                    finishInit();
                });
            } else {
                finishInit();
            }
        }

        if (enclave.isInitialised()) {
            __saveEnclaveDIDAndFinishInit()
        } else {
            enclave.on("initialised", async () => {
                __saveEnclaveDIDAndFinishInit();
            });
        }
    }

    const finishInit = () => {
        initialised = true;
        target.finishInitialisation();
        target.dispatchEvent("initialised")
    }

    target.registerDID = (didDocument, callback) => {
        let privateKeys = didDocument.getPrivateKeys();
        if (!Array.isArray(privateKeys)) {
            privateKeys = [privateKeys]
        }
        enclave.storeDID(didDocument, didDocument, privateKeys, callback);
    };

    target.addPrivateKeyForDID = (didDocument, privateKey, callback) => {
        enclave.addPrivateKeyForDID(didDocument, privateKey, callback);
    }

    target.registerKeySSI = (forDID, keySSI, callback) => {
        const generateUid = require("swarmutils").generateUid;
        const alias = generateUid(10).toString("hex");
        if (sharedEnclave) {
            sharedEnclave.storeSeedSSI(forDID, keySSI, alias, err => {
                if (err) {
                    return callback(err);
                }

                callback(undefined, alias);
            })
        } else {
            enclave.storeSeedSSI(forDID, keySSI, alias, err => {
                if (err) {
                    return callback(err);
                }

                callback(undefined, alias);
            })
        }
    };

    target.signForKeySSI = (forDID, keySSI, data, callback) => {
        enclave.signForKeySSI(forDID, keySSI, data, (err, signature) => {
            if (err) {
                sharedEnclave.signForKeySSI(forDID, keySSI, data, callback);
                return;
            }

            callback(undefined, signature);
        });
    }

    target.signAsDID = (didDocument, data, callback) => {
        enclave.signForDID(didDocument, didDocument, data, callback);
    }

    target.verifyForDID = (didDocument, data, signature, callback) => {
        enclave.verifyForDID(didDocument, didDocument, data, signature, callback);
    }


    target.encryptForDID = (senderDIDDocument, receiverDIDDocument, message, callback) => {
        enclave.encryptMessage(senderDIDDocument, senderDIDDocument, receiverDIDDocument, message, callback);
    };

    target.decryptAsDID = (didDocument, encryptedMessage, callback) => {
        enclave.decryptMessage(didDocument, didDocument, encryptedMessage, callback)
    }

    target.isInitialised = () => {
        return initialised;
    }

    target.getDB = (callback) => {
        const dbApi = openDSU.loadAPI("db");
        const db = dbApi.getWalletDB(scDSUKeySSI, "defaultDB")
        db.on("initialised", () => {
            callback(undefined, db);
        })
    }

    target.getDSU = (callback) => {
        callback(undefined, storageDSU);
    }

    const wrapEnclave = (asDID, enclave) => {
        const wrappedEnclave = {};
        let asyncDBMethods = ["insertRecord", "updateRecord", "getRecord", "deleteRecord", "filter", "commitBatch", "cancelBatch", "getKeySSI", "readKey", "writeKey", "getAllRecords", "addIndex"];
        for (let i = 0; i < asyncDBMethods.length; i++) {
            wrappedEnclave[asyncDBMethods[i]] = (...args) => {
                enclave[asyncDBMethods[i]](asDID, ...args);
            }

            wrappedEnclave[`${asyncDBMethods[i]}Async`] = $$.promisify(wrappedEnclave[asyncDBMethods[i]]);
        }

        Object.keys(enclave).forEach(methodName => {
            if (typeof wrappedEnclave[methodName] === "undefined") {
                wrappedEnclave[methodName] = (...args) => {
                    enclave[methodName](asDID, ...args);
                }
            }
        })
        return wrappedEnclave;
    }
    target.getMainEnclaveDB = (asDID, callback) => {
        if (typeof asDID === "function") {
            callback = asDID;
            asDID = mainDID;
        }

        let mainEnclaveDB;
        if (target.isInitialised()) {
            mainEnclaveDB = wrapEnclave(asDID, enclave);
            if (typeof callback === "function") {
                callback(undefined, mainEnclaveDB);
            }
            return mainEnclaveDB;
        } else {
            enclave.on("initialised", () => {
                mainEnclaveDB = wrapEnclave(asDID, enclave);
                callback(undefined, mainEnclaveDB);
            })
        }
    }

    target.getSharedEnclaveDB = (asDID, callback) => {
        if (typeof asDID === "function") {
            callback = asDID;
            asDID = mainDID;
        }

        let sharedEnclaveDB;
        const __getWrappedEnclave = () => {
            if (!sharedEnclave) {
                return callback(Error(`No shared db found`))
            }
            if (isPromise(sharedEnclave)) {
                sharedEnclave.then((sharedEnclave) => {
                    sharedEnclaveDB = wrapEnclave(asDID, sharedEnclave);
                    callback(undefined, sharedEnclaveDB);
                })
                return;
            }
            sharedEnclaveDB = wrapEnclave(asDID, sharedEnclave);
            callback(undefined, sharedEnclaveDB);
        }
        if (target.isInitialised()) {
            __getWrappedEnclave();
        } else {
            enclave.on("initialised", () => {
                __getWrappedEnclave();
            })
        }
    }

    target.sharedEnclaveExists = () => {
        if (typeof sharedEnclave === "undefined") {
            return false;
        }

        return true;
    }

    target.setPIN = (pin) => {
        PIN = pin;
        if (PIN == undefined) return;
        paddedPIN = pad(pin, 32);
        target.dispatchEvent("pinSet");
    }

    target.getPIN = () => {
        return PIN;
    }

    target.getPaddedPIN = () => {
        return paddedPIN;
    }

    target.isPINNeeded = async () => {

        return new Promise((res, rej) => {
            if (initialised) {
                res(pinNeeded);
            }
            else {
                target.on("initialised", async () => {
                    res(pinNeeded)
                })
            }
        })

    }

    const pad = (key, length) => {
        if (key == undefined) return;
        const padding = "0".repeat(length - key.length);
        return key + padding;
    }

    function isPromise(p) {
        if (typeof p === 'object' && typeof p.then === 'function') {
            return true;
        }
        return false;
    }

    paddedPIN = pad(PIN, 32);

    const bindAutoPendingFunctions = require("../../utils/BindAutoPendingFunctions").bindAutoPendingFunctions;
    bindAutoPendingFunctions(target, ["on", "off", "isInitialised", "init", "sharedEnclaveExists", "dispatchEvent", "isPINNeeded"]);
    target.init();
    return target;
}

module.exports = SecurityContext;

},{"../../moduleConstants":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/moduleConstants.js","../../utils/BindAutoPendingFunctions":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/utils/BindAutoPendingFunctions.js","../../utils/ObservableMixin":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/utils/ObservableMixin.js","opendsu":"opendsu","swarmutils":"swarmutils"}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/storage/DSUStorage.js":[function(require,module,exports){
const { fetch } = require("./utils");

// helpers

function doDownload(url, expectedResultType, callback) {
  fetch(url)
    .then((response) => {
      if (!response.ok) {
        throw new Error(response.statusText);
      }
      response[expectedResultType]()
        .then((data) => {
          return callback(undefined, data);
        })
        .catch((err) => {
          throw err;
        });
    })
    .catch((err) => {
      return callback(err);
    });
}

function doUpload(url, data, callback) {
  fetch(url, {
    method: "POST",
    body: data,
  })
    .then((response) => {
      return response.json().then((data) => {
        if (!response.ok || response.status != 201) {
          let errorMessage = "";
          if (Array.isArray(data) && data.length) {
            errorMessage = `${data[0].error.message}. Code: ${data[0].error.code}`;
          } else if (typeof data === "object") {
            errorMessage = data.message ? data.message : JSON.stringify(data);
          }

          let error = new Error(errorMessage);
          error.data = data;
          throw error;
        }

        if (Array.isArray(data)) {
          let responses = [];
          for (const item of data) {
            console.log(`Uploaded ${item.file.name} to ${item.result.path}`);
            responses.push(item.result.path);
          }
          callback(undefined, responses.length > 1 ? responses : responses[0]);
        }
      });
    })
    .catch((err) => {
      return callback(err);
    });
}

function doFileUpload(path, files, options, callback) {
  if (typeof options === "function") {
    callback = options;
    options = undefined;
  }

  const formData = new FormData();
  let inputType = "file";

  if (Array.isArray(files)) {
    for (const attachment of files) {
      inputType = "files[]";
      formData.append(inputType, attachment);
    }
  } else {
    formData.append(inputType, files);
  }

  let url = `/upload?path=${path}&input=${inputType}`;
  if (typeof options !== "undefined" && options.preventOverwrite) {
    url += "&preventOverwrite=true";
  }
  doUpload(url, formData, callback);
}

function doRemoveFile(url, callback) {
  fetch(url, { method: "DELETE" })
    .then((response) => {
      if (!response.ok) {
        throw new Error(response.statusText);
      }
      callback();
    })
    .catch((err) => {
      return callback(err);
    });
}

function performRemoval(filePathList, callback) {
  if (!Array.isArray(filePathList)) {
    filePathList = [filePathList];
  }

  let errors = [];
  let deletedFiles = [];

  let deleteFile = (path) => {
    let filename = path;
    if (path[0] !== "/") {
      path = "/" + path;
    }
    let url = "/delete" + path;
    doRemoveFile(url, (err) => {
      if (err) {
        //console.log(err);
        errors.push({
          filename: filename,
          message: err.message,
        });
      } else {
        deletedFiles.push(filename);
      }

      if (filePathList.length > 0) {
        return deleteFile(filePathList.shift());
      }
      callback(errors.length ? errors : undefined, deletedFiles);
    });
  };

  deleteFile(filePathList.shift());
}

// service

class DSUStorage {
  constructor() {
    this.directAccessEnabled = false;
  }

  enableDirectAccess(callback) {
    let self = this;

    function addFunctionsFromMainDSU() {
      if (!self.directAccessEnabled) {
        let sc = require("opendsu").loadAPI("sc");
        let availableFunctions = [
          "addFile",
          "addFiles",
          "addFolder",
          "appendToFile",
          "createFolder",
          "delete",
          "extractFile",
          "extractFolder",
          "getArchiveForPath",
          "getCreationSSI",
          "getKeySSI",
          "listFiles",
          "listFolders",
          "mount",
          "readDir",
          "readFile",
          "rename",
          "unmount",
          "writeFile",
          "listMountedDSUs",
          "beginBatch",
          "commitBatch",
          "cancelBatch",
        ];

        sc.getMainDSU((err, mainDSU) => {
          for (let f of availableFunctions) {
            self[f] = mainDSU[f];
          }
          self.directAccessEnabled = true;
          callback(undefined, true);
        });
      } else {
        callback(undefined, true);
      }
    }

    addFunctionsFromMainDSU();
  }

  call(name, ...args) {
    if (args.length === 0) {
      throw Error(
        "Missing arguments. Usage: call(functionName, arg1, arg2 ... callback)"
      );
    }

    const callback = args.pop();
    const url =
      "/api?" +
      new URLSearchParams({ name: name, arguments: JSON.stringify(args) });
    fetch(url, { method: "GET" })
      .then((response) => {
        if (!response.ok) {
          throw new Error(response.statusText);
        }
        return response.json();
      })
      .then((result) => {
        callback(...result);
      })
      .catch((err) => {
        return callback(err);
      });
  }

  setObject(path, data, callback) {
    try {
      let dataSerialized = JSON.stringify(data);
      this.setItem(path, dataSerialized, callback);
    } catch (e) {
      callback(createOpenDSUErrorWrapper("setObject failed", e));
    }
  }

  getObject(path, callback) {
    this.getItem(path, "json", function (err, res) {
      if (err || !res) {
        return callback(undefined, undefined);
      }
      callback(undefined, res);
    });
  }

  setItem(path, data, callback) {
    if (!this.directAccessEnabled) {
      let segments = path.split("/");
      let fileName = segments.splice(segments.length - 1, 1)[0];
      path = segments.join("/");
      if (!path) {
        path = "/";
      }
      let url = `/upload?path=${path}&filename=${fileName}`;
      doUpload(url, data, callback);
    } else {
      this.writeFile(path, data, callback);
    }
  }

  getItem(path, expectedResultType, callback) {
    if (typeof expectedResultType === "function") {
      callback = expectedResultType;
      expectedResultType = "arrayBuffer";
    }

    if (!this.directAccessEnabled) {
      if (path[0] !== "/") {
        path = "/" + path;
      }

      path = "/download" + path;
      doDownload(path, expectedResultType, callback);
    } else {
      this.readFile(path, function (err, res) {
        if (err) {
          return callback(err);
        }
        try {
          if (expectedResultType == "json") {
            res = JSON.parse(res.toString());
          }
        } catch (err) {
          return callback(err);
        }
        callback(undefined, res);
      });
    }
  }

  uploadFile(path, file, options, callback) {
    doFileUpload(...arguments);
  }

  uploadMultipleFiles(path, files, options, callback) {
    doFileUpload(...arguments);
  }

  deleteObjects(objects, callback) {
    performRemoval(objects, callback);
  }

  removeFile(filePath, callback) {
    console.log("[Warning] - obsolete. Use DSU.deleteObjects");
    performRemoval([filePath], callback);
  }

  removeFiles(filePathList, callback) {
    console.log("[Warning] - obsolete. Use DSU.deleteObjects");
    performRemoval(filePathList, callback);
  }
}

let dsuStorageInstance;

function getDSUStorage() {
  if (typeof dsuStorageInstance === "undefined") {
    dsuStorageInstance = new DSUStorage();
  }

  return dsuStorageInstance;
}

module.exports = getDSUStorage;

},{"./utils":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/storage/utils.js","opendsu":"opendsu"}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/storage/index.js":[function(require,module,exports){
module.exports = {
  getDSUStorage: require("./DSUStorage")
};

},{"./DSUStorage":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/storage/DSUStorage.js"}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/storage/utils.js":[function(require,module,exports){
function promisify(fun) {
  return function (...args) {
    return new Promise((resolve, reject) => {
      function callback(err, result) {
        if (err) {
          reject(err);
        } else {
          resolve(result);
        }
      }

      args.push(callback);

      fun.call(this, ...args);
    });
  };
}

function executeFetch(url, ...args) {
  // check if we need to add the BASE_URL to the prefix of the url
  const isBaseUrlSet =
    $$ &&
    $$.SSAPP_CONTEXT &&
    $$.SSAPP_CONTEXT.BASE_URL &&
    $$.SSAPP_CONTEXT.SEED &&
    url.indexOf($$.SSAPP_CONTEXT.BASE_URL) !== 0;
  if (isBaseUrlSet && url.indexOf("data:image") !== 0) {
    // BASE_URL ends with / so make sure that url doesn't already start with /
    url = `${$$.SSAPP_CONTEXT.BASE_URL}${
      url.indexOf("/") === 0 ? url.substr(1) : url
    }`;
  }

  const http = require("opendsu").loadAPI("http");
  return http.fetch(url, ...args);
}

module.exports = {
  promisify,
  fetch: executeFetch,
};

},{"opendsu":"opendsu"}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/system/index.js":[function(require,module,exports){
const envVariables = {};
function getEnvironmentVariable(name){
    if (typeof envVariables[name] !== "undefined") {
        return envVariables[name];
    }
    return process.env[name];
}
function setEnvironmentVariable(name, value){
    envVariables[name] = value;
}

function getFS(){
    const fsName = "fs";
    return require(fsName);
}

function getPath(){
    const pathName = "path";
    return require(pathName);
}
function getBaseURL(){
    const baseURL = require("../utils/getBaseURL");
    return baseURL();
}
module.exports = {
    getEnvironmentVariable,
    setEnvironmentVariable,
    getFS,
    getPath,
    getBaseURL
}

},{"../utils/getBaseURL":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/utils/getBaseURL.js"}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/utils/BindAutoPendingFunctions.js":[function(require,module,exports){
const PendingCallMixin = require("./PendingCallMixin");
/*
    Utility to make classes that depend on some initialisation easier to use.
    By using the PendingCallMixin, the member function can be used but will be called in order only after proper initialisation
 */

module.exports.bindAutoPendingFunctions = function(obj, exceptionList){
    let originalFunctions = {};

    for(let m in obj){
        if(typeof obj[m] == "function"){
            if(!exceptionList || exceptionList.indexOf(m) === -1){
                originalFunctions[m] = obj[m];
            }
        }
    }
    PendingCallMixin(obj);
    let isInitialised = false;

    obj.finishInitialisation = function(){
        isInitialised = true;
        obj.executeSerialPendingCalls();
    };

   function getWrapper(func){
       return function(...args){
           if(isInitialised){
              return func(...args);
           } else {
               obj.addSerialPendingCall( function(next){
                   let callback = args[args.length -1];
                   if(typeof callback === "function"){
                       args[args.length -1] = function(...args){
                           callback(...args);
                           next();
                       }
                   } else {
                       next();
                   }
                  return func(...args);
               })
           }
       }.bind(obj);
   }

    for(let m in originalFunctions){
        obj[m] = getWrapper(originalFunctions[m]);
    }
    return obj;
};

module.exports.bindParallelAutoPendingFunctions = function(obj, exceptionList){
    let originalFunctions = {};

    for(let m in obj){
        if(typeof obj[m] == "function"){
            if(!exceptionList || exceptionList.indexOf(m) === -1){
                originalFunctions[m] = obj[m];
            }
        }
    }
    PendingCallMixin(obj);
    let isInitialised = false;

    obj.finishInitialisation = function(){
        isInitialised = true;
        obj.executePendingCalls();
    };

    function getWrapper(func){
        return function(...args){
            if(isInitialised){
                return func(...args);
            } else {
                obj.addPendingCall( function(){
                    return func(...args);
                })
            }
        }.bind(obj);
    }

    for(let m in originalFunctions){
        obj[m] = getWrapper(originalFunctions[m]);
    }
    return obj;
};

},{"./PendingCallMixin":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/utils/PendingCallMixin.js"}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/utils/ObservableMixin.js":[function(require,module,exports){
function ObservableMixin(target) {
    let observers = {};

    target.on = function(eventType, callback){
        let arr = observers[eventType];
        if(!arr){
            arr = observers[eventType] = [];
        }
        arr.push(callback);
    }

    target.off = function(eventType, callback){
        let arr = observers[eventType];
        if(!arr){
            //nothing to do...
            reportDevRelevantInfo("Off-ing an unknown observer");
            return;
        }
        let index = observers[eventType].indexOf(callback);
        if(index === -1){
            reportDevRelevantInfo("Observer not found into the list of known observers.");
            return;
        }

        observers[eventType].splice(index, 1);
    }

    target.dispatchEvent = function(eventType, message){
        let arr = observers[eventType];
        if(!arr){
            //no handlers registered
            reportDevRelevantInfo(`No observers found for event type ${eventType}`);
            return;
        }

        arr.forEach( c => {
            try{
                c(message);
            }catch(err){
				console.error(err);
                reportDevRelevantInfo(`Caught an error during the delivery of ${eventType} to ${c.toString()}`);
            }

        });
    }

    target.removeAllObservers = function (eventType){
        if(observers[eventType]){
            delete observers[eventType];
        } else {
            reportDevRelevantInfo("No observers found in the list of known observers.");
        }
    }
}

module.exports = ObservableMixin;

},{}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/utils/PendingCallMixin.js":[function(require,module,exports){
function PendingCallMixin(target) {
    let pendingCalls = [];
    let serialPendingCalls = [];
    let isSerialExecutionReady = false;
    let isExecutionReady = false;
    target.addPendingCall = (pendingFn) => {
        if (isExecutionReady) {
            pendingFn();
        } else {
            pendingCalls.push(pendingFn);
        }
    };

    target.executePendingCalls = () => {
        isExecutionReady = true;
        pendingCalls.forEach(fn => fn());
        pendingCalls = [];
    };

    target.addSerialPendingCall = (pendingFn) => {
        serialPendingCalls.push(pendingFn);
        if (isSerialExecutionReady) {
            next();
        }
    };

    function next() {
        const fn = serialPendingCalls.shift();
        if (typeof fn !== "undefined") {
            try {
                fn(function () {
                    setTimeout(() => {
                        next();
                    }, 0);
                });
            } catch (e) {
                console.log(e);
            }
        }
    }

    target.executeSerialPendingCalls = () => {
        isSerialExecutionReady = true;
        next();
    };
}

module.exports = PendingCallMixin;
},{}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/utils/SmartUrl.js":[function(require,module,exports){
function SmartUrl(bdnsEntry){
    const {fetch, doPut, doPost, doGet} = require("opendsu").loadAPI("http");
    let url = typeof bdnsEntry === "string" ? bdnsEntry : bdnsEntry.url;

    if(!url){
        console.debug(`<${JSON.stringify(bdnsEntry)}> BDNS entry wrong configuration.`);
        throw new Error(`<${JSON.stringify(bdnsEntry)}> BDNS entry wrong configuration.`);
    }

    function getOptions(options){
        let opts = options || {};
        if(url !== bdnsEntry && bdnsEntry.headers){
            if(!opts.headers){
                opts.headers = {};
            }
            Object.assign(opts.headers, bdnsEntry.headers);
        }
        return opts;
    }

    this.fetch = (options)=>{
        return fetch(url, getOptions(options));
    }

    this.doPut = (body, options, callback)=>{
        if(typeof options === "function"){
            callback = options;
            options = undefined;
        }
       return doPut(url, body, getOptions(options), callback);
    }

    this.doPost = (body, options, callback)=>{
        if(typeof options === "function"){
            callback = options;
            options = undefined;
        }
       return doPost(url, body, getOptions(options), callback);
    }

    this.doGet = (options, callback)=>{
        if(typeof options === "function"){
            callback = options;
            options = undefined;
        }
        return doGet(url, getOptions(options), callback);
    }

    function concatUrls(base, path){
        let returnUrl = base;
        if(returnUrl.endsWith("/") && path.startsWith("/")){
            returnUrl = returnUrl.slice(0, returnUrl.length-1);
        }
        returnUrl += path;
        return returnUrl;
    }

    this.concatWith = (path) => {
        return new SmartUrl(bdnsEntry === url ? concatUrls(url, path) :{url: concatUrls(url, path), headers:bdnsEntry.headers});
    }
}

module.exports = SmartUrl;
},{"opendsu":"opendsu"}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/utils/array.js":[function(require,module,exports){
function shuffle(array) {
  for (let i = array.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [array[i], array[j]] = [array[j], array[i]];
  }
}

module.exports.shuffle = shuffle;

},{}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/utils/getBaseURL.js":[function(require,module,exports){
const constants = require("../moduleConstants");
const system = require("../system");
function getBaseURL(){
    switch ($$.environmentType) {
        case constants.ENVIRONMENT_TYPES.SERVICE_WORKER_ENVIRONMENT_TYPE:
            let scope = self.registration.scope;

            let parts = scope.split("/");
            return `${parts[0]}//${parts[2]}`;

        case constants.ENVIRONMENT_TYPES.BROWSER_ENVIRONMENT_TYPE:            
            const protocol = window.location.protocol;
            const host = window.location.hostname;
            const port = window.location.port;

            return `${protocol}//${host}:${port}`;

        case constants.ENVIRONMENT_TYPES.WEB_WORKER_ENVIRONMENT_TYPE:            
            return self.location.origin;

        case constants.ENVIRONMENT_TYPES.NODEJS_ENVIRONMENT_TYPE:
            let baseUrl = system.getEnvironmentVariable(constants.BDNS_ROOT_HOSTS);
            if (typeof baseUrl === "undefined") {
                baseUrl = "http://127.0.0.1:8080";
            } else {
                const myURL = new URL(baseUrl);
                baseUrl = myURL.origin;
            }
            if (baseUrl.endsWith("/")) {
                baseUrl = baseUrl.slice(0, -1);
            }
            return baseUrl;

        default:
    }
}

module.exports = getBaseURL;
},{"../moduleConstants":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/moduleConstants.js","../system":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/system/index.js"}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/utils/getURLForSsappContext.js":[function(require,module,exports){
function getURLForSsappContext(relativePath) {
    if (window["$$"] && $$.SSAPP_CONTEXT && $$.SSAPP_CONTEXT.BASE_URL && $$.SSAPP_CONTEXT.SEED) {
        // if we have a BASE_URL then we prefix the fetch url with BASE_URL
        return `${new URL($$.SSAPP_CONTEXT.BASE_URL).pathname}${
            relativePath.indexOf("/") === 0 ? relativePath.substring(1) : relativePath
        }`;
    }
    return relativePath;
}

module.exports = {
    getURLForSsappContext
}

},{}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/utils/index.js":[function(require,module,exports){
module.exports = {
    bindAutoPendingFunctions: require("./BindAutoPendingFunctions").bindAutoPendingFunctions,
    bindParallelAutoPendingFunctions: require("./BindAutoPendingFunctions").bindParallelAutoPendingFunctions,
    ObservableMixin: require("./ObservableMixin"),
    PendingCallMixin: require('./PendingCallMixin'),
    SmartUrl: require("./SmartUrl"),
    promiseRunner: require("./promise-runner")
}
},{"./BindAutoPendingFunctions":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/utils/BindAutoPendingFunctions.js","./ObservableMixin":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/utils/ObservableMixin.js","./PendingCallMixin":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/utils/PendingCallMixin.js","./SmartUrl":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/utils/SmartUrl.js","./promise-runner":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/utils/promise-runner.js"}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/utils/observable.js":[function(require,module,exports){
module.exports.createObservable = function(){
	let observableMixin = require("./ObservableMixin");
	let obs = {};

	observableMixin(obs);
	return obs;
}
},{"./ObservableMixin":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/utils/ObservableMixin.js"}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/utils/promise-runner.js":[function(require,module,exports){
const arrayUtils = require("./array");
const { OpenDSUSafeCallback, createOpenDSUErrorWrapper } = require('./../error')

function validateMajorityRunAllWithSuccess(successResults, errorResults, totalCount) {
  const successCount = successResults.length;
  const errorCount = errorResults.length;

  if (totalCount == null) {
    // totalCount was not provided, so we consider to be the sum of the other results
    totalCount = successCount + errorCount;
  }

  const isMajorityWithSuccess = successCount >= Math.ceil(totalCount / 2);
  return isMajorityWithSuccess;
}

function runSinglePromise(executePromise, promiseInput) {
  return executePromise(promiseInput)
    .then((result) => {
      return {
        success: true,
        result,
      };
    })
    .catch((error) => {
      return {
        error,
      };
    });
}

async function runAll(listEntries, executeEntry, validateResults, callback, debugInfo) {
  if (typeof validateResults !== "function") {
    validateResults = validateMajorityRunAllWithSuccess;
  }

  const allInitialExecutions = listEntries.map((entry) => {
    return runSinglePromise(executeEntry, entry);
  });

  let results;

  try {
    results = await Promise.all(allInitialExecutions)
  } catch (e) {
    return callback(e);
  }

  const successExecutions = results.filter((run) => run.success);
  let errorExecutions = results.filter((run) => !run.success);
  errorExecutions = errorExecutions.map(e => {
    if (e.error && e.error.error) {
      return e.error.error;
    }else {
      return e;
    }
  });
  const isConsideredSuccessfulRun = validateResults(successExecutions, errorExecutions);
  if (isConsideredSuccessfulRun) {
    const successExecutionResults = successExecutions.map((run) => run.result);
    return callback(null, successExecutionResults);
  }

  let baseError = debugInfo;
  if(errorExecutions.length){
    if(baseError){
      baseError = OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper("Error found during runAll", errorExecutions[0], errorExecutions));
    }
  }
  return OpenDSUSafeCallback(callback)((createOpenDSUErrorWrapper("FAILED to runAll " , baseError)));
}

function runOneSuccessful(listEntries, executeEntry, callback, debugInfo) {
  if (!listEntries.length) {
    return callback("EMPTY_LIST");
  }

  let availableListEntries = [...listEntries];
  arrayUtils.shuffle(availableListEntries);

  const entry = availableListEntries.shift();

  const executeForSingleEntry = async (entry) => {
      let result;
      try {
          result = await executeEntry(entry);
      } catch (err) {
          if (!availableListEntries.length) {
              return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to execute entry`+debugInfo, err));
          }

          const nextEntry = availableListEntries.shift();
          return executeForSingleEntry(nextEntry);
      }

     return callback(undefined, result);
  };

  executeForSingleEntry(entry);
}

async function runEnoughForMajority(listEntries, executeEntry, initialRunCount, validateResults, callback, debugInfo) {
  const totalCount = listEntries.length;

  if (!initialRunCount || typeof initialRunCount !== "number") {
    // no initiaRunCount was specified, so we execute half of them initially
    initialRunCount = Math.ceil(totalCount / 2);
  }
  initialRunCount = Math.min(initialRunCount, totalCount);

  if (typeof validateResults !== "function") {
    validateResults = validateMajorityRunAllWithSuccess;
  }

  let allExecutedRunResults = [];
  const initialEntries = listEntries.slice(0, initialRunCount);
  const remainingEntries = listEntries.slice(initialRunCount);

  const checkAllExecutedRunResults = async () => {
    const successExecutions = allExecutedRunResults.filter((run) => run.success);
    const errorExecutions = allExecutedRunResults.filter((run) => !run.success);

    const isConsideredSuccessfulRun = validateResults(successExecutions, errorExecutions, totalCount);
    if (isConsideredSuccessfulRun) {
      const successExecutionResults = successExecutions.map((run) => run.result);
      return callback(null, successExecutionResults);
    }

    if (!remainingEntries.length) {
      // the results weren't validated, but we don't have any other entry to run
      return callback(new Error("FAILED to run enough in majority"+debugInfo));
    }

    const nextEntry = remainingEntries.shift();

    const nextEntryResult = await runSinglePromise(executeEntry, nextEntry);
    allExecutedRunResults.push(nextEntryResult);
    checkAllExecutedRunResults();
  };

  const allInitialExecutions = initialEntries.map((entry) => {
    return runSinglePromise(executeEntry, entry);
  });

  try {
    allExecutedRunResults = await Promise.all(allInitialExecutions);
  } catch (e) {
    return callback(e);
  }
  checkAllExecutedRunResults();
}

module.exports = {
  runAll,
  runOneSuccessful,
  runEnoughForMajority,
};

},{"./../error":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/error/index.js","./array":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/utils/array.js"}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/w3cdid/CryptographicSkills/CryptographicSkills.js":[function(require,module,exports){
const cryptoSkillsRegistry = {};
const methodsNames = require("../didMethodsNames");
const KeyDID_CryptographicSkills = require("./KeyDID_CryptographicSkills");
const NameDID_CryptographicSkills = require("./NameDID_CryptographicSkills");
const GroupDID_CryptographicSkills = require("./GroupDID_CryptographicSkills");
const SReadDID_CryptographicSkills = require("./SReadDID_CryptographicSkills");
const SSI_KeyDID_CryptographicSkills = require("./SSI_KeyDID_CryptographicSkills");

const registerSkills = (didMethod, skills) => {
    cryptoSkillsRegistry[didMethod] = skills;
}

const applySkill = (didMethod, skillName, ...args) => {
    return cryptoSkillsRegistry[didMethod][skillName](...args);
}

registerSkills(methodsNames.NAME_SUBTYPE, new NameDID_CryptographicSkills());
registerSkills(methodsNames.GROUP_METHOD_NAME, new GroupDID_CryptographicSkills());
registerSkills(methodsNames.S_READ_SUBTYPE, new SReadDID_CryptographicSkills());
registerSkills(methodsNames.SSI_KEY_SUBTYPE, new SSI_KeyDID_CryptographicSkills());
registerSkills(methodsNames.KEY_SUBTYPE, new KeyDID_CryptographicSkills());

module.exports = {
    registerSkills,
    applySkill,
    NAMES: require("./cryptographicSkillsNames"),
    CryptographicSkillsMixin: require("./CryptographicSkillsMixin")
};
},{"../didMethodsNames":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/w3cdid/didMethodsNames.js","./CryptographicSkillsMixin":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/w3cdid/CryptographicSkills/CryptographicSkillsMixin.js","./GroupDID_CryptographicSkills":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/w3cdid/CryptographicSkills/GroupDID_CryptographicSkills.js","./KeyDID_CryptographicSkills":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/w3cdid/CryptographicSkills/KeyDID_CryptographicSkills.js","./NameDID_CryptographicSkills":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/w3cdid/CryptographicSkills/NameDID_CryptographicSkills.js","./SReadDID_CryptographicSkills":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/w3cdid/CryptographicSkills/SReadDID_CryptographicSkills.js","./SSI_KeyDID_CryptographicSkills":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/w3cdid/CryptographicSkills/SSI_KeyDID_CryptographicSkills.js","./cryptographicSkillsNames":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/w3cdid/CryptographicSkills/cryptographicSkillsNames.js"}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/w3cdid/CryptographicSkills/CryptographicSkillsMixin.js":[function(require,module,exports){
function CryptographicSkillsMixin(target) {
    target = target || {};
    const crypto = require("pskcrypto");
    const openDSU = require("opendsu");
    const keySSISpace = openDSU.loadAPI("keyssi");
    const cryptoSpace = openDSU.loadAPI("crypto");

    let config = {
        curveName: 'secp256k1',
        encodingFormat: 'base64',
        macAlgorithmName: 'sha256',
        macKeySize: 16,
        hashFunctionName: 'sha256',
        hashSize: 32,
        signAlgorithmName: 'sha256',
        symmetricCipherName: 'aes-128-cbc',
        symmetricCipherKeySize: 16,
        ivSize: 16
    };

    target.getConfigForIES = () => {
        return config;
    };

    target.hash = (data) => {
        return target.encoding(crypto.hash('sha256', data));
    }

    target.keyDerivation = (password, iterations) => {
        return crypto.deriveKey('aes-256-gcm', password, iterations);
    }

    target.encryptionKeyGeneration = () => {
        const pskEncryption = crypto.createPskEncryption('aes-256-gcm');
        return pskEncryption.generateEncryptionKey();
    }

    target.encryption = (plainData, encryptionKey, options) => {
        const pskEncryption = crypto.createPskEncryption('aes-256-gcm');
        return pskEncryption.encrypt(plainData, encryptionKey, options);
    }

    target.decryption = (encryptedData, decryptionKey, authTagLength, options) => {
        const pskEncryption = crypto.createPskEncryption('aes-256-gcm');
        const utils = require("swarmutils");
        if (!$$.Buffer.isBuffer(decryptionKey) && (decryptionKey instanceof ArrayBuffer || ArrayBuffer.isView(decryptionKey))) {
            decryptionKey = utils.ensureIsBuffer(decryptionKey);
        }
        if (!$$.Buffer.isBuffer(encryptedData) && (decryptionKey instanceof ArrayBuffer || ArrayBuffer.isView(decryptionKey))) {
            encryptedData = utils.ensureIsBuffer(encryptedData);
        }
        return pskEncryption.decrypt(encryptedData, decryptionKey, 16, options);
    }

    target.encoding = (data) => {
        return crypto.pskBase58Encode(data);
    }

    target.decoding = (data) => {
        return crypto.pskBase58Decode(data);
    }

    target.keyPairGenerator = () => {
        return crypto.createKeyPairGenerator();
    }

    target.convertPublicKey = (rawPublicKey, options) => {
        const keyGenerator = crypto.createKeyPairGenerator();
        return keyGenerator.convertPublicKey(rawPublicKey, options);
    };

    target.sign = (data, privateKey) => {
        const keyGenerator = crypto.createKeyPairGenerator();
        const rawPublicKey = keyGenerator.getPublicKey(privateKey, 'secp256k1');
        return crypto.sign('sha256', data, keyGenerator.getPemKeys(privateKey, rawPublicKey).privateKey);
    }

    target.verify = (data, publicKey, signature) => {
        return crypto.verify('sha256', data, publicKey, signature);
    }

    target.ecies_encryption = (receiverPublicKey, message) => {
        return crypto.ecies_encrypt(receiverPublicKey, message, target.getConfigForIES())
    };

    target.ecies_decryption = (receiverPrivateKey, encEnvelope) => {
        return crypto.ecies_decrypt(receiverPrivateKey, encEnvelope, target.getConfigForIES());
    };

    const saveNewKeyPairInSC = async (didDocument, compatibleSSI) => {
        const securityContext = openDSU.loadAPI("sc").getSecurityContext();

        try {
            await $$.promisify(securityContext.addPrivateKeyForDID)(
                didDocument,
                compatibleSSI.getPrivateKey("raw")
            );
            // await $$.promisify(securityContext.addPublicKeyForDID)(
            //   didDocument,
            //   compatibleSSI.getPublicKey("raw")
            // );
        } catch (e) {
            throw createOpenDSUErrorWrapper(`Failed to save new private key and public key in security context`, e);
        }

        try {
            await $$.promisify(didDocument.addPublicKey)(
                compatibleSSI.getPublicKey("raw")
            );
        } catch (e) {
            throw createOpenDSUErrorWrapper(`Failed to save new private key and public key in security context`, e);
        }
    };

    target.encryptMessage = (privateKeys, didFrom, didTo, message, callback) => {
        const senderSeedSSI = keySSISpace.createTemplateSeedSSI(didFrom.getDomain());
        senderSeedSSI.initialize(didFrom.getDomain(), privateKeys[0]);

        didTo.getPublicKey("raw", async (err, receiverPublicKey) => {
            if (err) {
                return callback(createOpenDSUErrorWrapper(`Failed to get sender publicKey`, err));
            }

            const publicKeySSI = keySSISpace.createPublicKeySSI("seed", receiverPublicKey);

            const __encryptMessage = (senderKeySSI) => {
                let encryptedMessage;
                try {
                    encryptedMessage = cryptoSpace.ecies_encrypt_ds(senderKeySSI, publicKeySSI, message);
                } catch (e) {
                    return callback(createOpenDSUErrorWrapper(`Failed to encrypt message`, e));
                }

                callback(undefined, encryptedMessage);
            };

            // let compatibleSSI;
            // try {
            //     compatibleSSI = await $$.promisify(publicKeySSI.generateCompatiblePowerfulKeySSI)();
            // } catch (e) {
            //     return callback(createOpenDSUErrorWrapper(`Failed to create compatible seed ssi`, e));
            // }
            //
            // try {
            //     await saveNewKeyPairInSC(didFrom, compatibleSSI);
            // } catch (e) {
            //     return callback(createOpenDSUErrorWrapper(`Failed to save compatible seed ssi`, e));
            // }

            __encryptMessage(senderSeedSSI);
        });
    };

    target.decryptMessage = (privateKeys, didTo, encryptedMessage, callback) => {
        let decryptedMessageObj;
        const decryptMessageRecursively = (privateKeyIndex) => {
            const privateKey = privateKeys[privateKeyIndex];
            if (typeof privateKey === "undefined") {
                return callback(createOpenDSUErrorWrapper(`Failed to decrypt message`, Error(`Private key is undefined`)));
            }

            const receiverSeedSSI = keySSISpace.createTemplateSeedSSI(didTo.getDomain());
            receiverSeedSSI.initialize(didTo.getDomain(), privateKey);
            try {
                decryptedMessageObj = cryptoSpace.ecies_decrypt_ds(receiverSeedSSI, encryptedMessage);
            } catch (e) {
                return decryptMessageRecursively(privateKeyIndex + 1);
            }

            callback(undefined, decryptedMessageObj.message.toString());
        };

        decryptMessageRecursively(0);
    };
    target.ecies_encryption_ds = (senderKeyPair, receiverPublicKey, message) => {
        return crypto.ecies_encrypt_ds(senderKeyPair, receiverPublicKey, message, target.getConfigForIES())
    };

    target.ecies_decryption_ds = (receiverPrivateKey, encEnvelope) => {
        return crypto.ecies_decrypt_ds(receiverPrivateKey, encEnvelope, target.getConfigForIES());
    };

    target.ecies_encryption_kmac = (senderKeyPair, receiverPublicKey, message) => {
        return crypto.ecies_encrypt_kmac(senderKeyPair, receiverPublicKey, message, target.getConfigForIES())
    };

    target.ecies_decryption_kmac = (receiverPrivateKey, encEnvelope) => {
        return crypto.ecies_decrypt_kmac(receiverPrivateKey, encEnvelope, target.getConfigForIES());
    };

    return target;
}

module.exports = CryptographicSkillsMixin;

},{"opendsu":"opendsu","pskcrypto":"pskcrypto","swarmutils":"swarmutils"}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/w3cdid/CryptographicSkills/GroupDID_CryptographicSkills.js":[function(require,module,exports){
const didDocumentsFactory = require("../didDocumentsFactory");
const didMethodsNames = require("../didMethodsNames");
function GroupDID_CryptographicSkills() {
    const CryptoGraphicSkillsMixin = require("./CryptographicSkillsMixin");
    CryptoGraphicSkillsMixin(this);

    this.createDID_Document = (domain, groupName) => {
        return didDocumentsFactory.createDID_Document(didMethodsNames.GROUP_METHOD_NAME, domain, groupName);
    }
}

module.exports = GroupDID_CryptographicSkills;
},{"../didDocumentsFactory":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/w3cdid/didDocumentsFactory.js","../didMethodsNames":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/w3cdid/didMethodsNames.js","./CryptographicSkillsMixin":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/w3cdid/CryptographicSkills/CryptographicSkillsMixin.js"}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/w3cdid/CryptographicSkills/KeyDID_CryptographicSkills.js":[function(require,module,exports){
const didDocumentsFactory = require("../didDocumentsFactory");
const didMethodsNames = require("../didMethodsNames");
function KeyDID_CryptographicSkills() {
    const CryptoGraphicSkillsMixin = require("./CryptographicSkillsMixin");
    CryptoGraphicSkillsMixin(this);

    this.createDID_Document = () => {
        return didDocumentsFactory.createDID_Document(didMethodsNames.KEY_SUBTYPE);
    }
}

module.exports = KeyDID_CryptographicSkills;
},{"../didDocumentsFactory":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/w3cdid/didDocumentsFactory.js","../didMethodsNames":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/w3cdid/didMethodsNames.js","./CryptographicSkillsMixin":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/w3cdid/CryptographicSkills/CryptographicSkillsMixin.js"}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/w3cdid/CryptographicSkills/NameDID_CryptographicSkills.js":[function(require,module,exports){
const didDocumentsFactory = require("../didDocumentsFactory");
const didMethodsNames = require("../didMethodsNames");
function NameDID_CryptographicSkills() {
    const CryptoGraphicSkillsMixin = require("./CryptographicSkillsMixin");
    CryptoGraphicSkillsMixin(this);

    this.createDID_Document = (domain, name) => {
        return didDocumentsFactory.createDID_Document(didMethodsNames.NAME_SUBTYPE, domain, name);
    }
}

module.exports = NameDID_CryptographicSkills;
},{"../didDocumentsFactory":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/w3cdid/didDocumentsFactory.js","../didMethodsNames":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/w3cdid/didMethodsNames.js","./CryptographicSkillsMixin":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/w3cdid/CryptographicSkills/CryptographicSkillsMixin.js"}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/w3cdid/CryptographicSkills/SReadDID_CryptographicSkills.js":[function(require,module,exports){
const didDocumentsFactory = require("../didDocumentsFactory");
const didMethodsNames = require("../didMethodsNames");
function SReadDID_CryptographicSkills() {
    const CryptoGraphicSkillsMixin = require("./CryptographicSkillsMixin");
    CryptoGraphicSkillsMixin(this);

    this.createDID_Document = (seedSSI) => {
        return didDocumentsFactory.createDID_Document(didMethodsNames.S_READ_SUBTYPE, seedSSI);
    }
}

module.exports = SReadDID_CryptographicSkills;
},{"../didDocumentsFactory":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/w3cdid/didDocumentsFactory.js","../didMethodsNames":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/w3cdid/didMethodsNames.js","./CryptographicSkillsMixin":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/w3cdid/CryptographicSkills/CryptographicSkillsMixin.js"}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/w3cdid/CryptographicSkills/SSI_KeyDID_CryptographicSkills.js":[function(require,module,exports){
const didDocumentsFactory = require("../didDocumentsFactory");
const didMethodsNames = require("../didMethodsNames");
function SSI_KeyDID_CryptographicSkills() {
    const CryptoGraphicSkillsMixin = require("./CryptographicSkillsMixin");
    CryptoGraphicSkillsMixin(this);

    this.createDID_Document = (seedSSI) => {
        return didDocumentsFactory.createDID_Document(didMethodsNames.SSI_KEY_SUBTYPE, seedSSI);
    }
}

module.exports = SSI_KeyDID_CryptographicSkills;
},{"../didDocumentsFactory":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/w3cdid/didDocumentsFactory.js","../didMethodsNames":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/w3cdid/didMethodsNames.js","./CryptographicSkillsMixin":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/w3cdid/CryptographicSkills/CryptographicSkillsMixin.js"}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/w3cdid/CryptographicSkills/cryptographicSkillsNames.js":[function(require,module,exports){
module.exports = {
    CREATE_DID_DOCUMENT:"createDID_Document",
    SIGN: "sign",
    VERIFY: "verify",
    ENCRYPT_MESSAGE: "encryptMessage",
    DECRYPT_MESSAGE: "decryptMessage"
}
},{}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/w3cdid/W3CDID_Mixin.js":[function(require,module,exports){
/*
    W3CDID Minxin is abstracting the DID document for OpenDSU compatible DID methods

    did:whatever   resolved to an OpenDSU abstraction: W3CDIDDocument
    verify signatures
    sign
    send and receive encrypted messages


 */

function W3CDID_Mixin(target, enclave) {
    const openDSU = require("opendsu");
    const dbAPI = openDSU.loadAPI("db");
    const crypto = openDSU.loadAPI("crypto");
    target.findPrivateKeysInSecurityContext = function (callback) {

    };

    const __ensureEnclaveExistsThenExecute = (fnName, ...args) => {
        const callback = args[args.length - 1];
        if (typeof enclave === "undefined") {
            dbAPI.getMainEnclave((err, mainEnclave) => {
                if (err) {
                    return callback(err);
                }

                enclave = mainEnclave;
                enclave[fnName](...args);
            })
        } else {
            enclave[fnName](...args);
        }
    }

    target.sign = function (hash, callback) {
        __ensureEnclaveExistsThenExecute("signForDID", target, hash, callback);
    };

    target.verify = function (hash, signature, callback) {
        __ensureEnclaveExistsThenExecute("verifyForDID", target, hash, signature, callback);
    };

    /*Elliptic Curve Integrated Encryption Scheme
     * https://github.com/bin-y/standard-ecies/blob/master/main.js
     * https://www.npmjs.com/package/ecies-lite  //try to use functions from SSI and from crypto
     * https://github.com/ecies/js
     * https://github.com/sigp/ecies-parity
     * https://github.com/pedrouid/eccrypto-js
     *
     * annoncrypt  - symertric enc (IES)
     * authcrypt   -  asymetric enc + sign
     * plaintext   + asym sign
     *
     * A -> B   sign(enc( ASYM_PK_B, M), PK_A)
     * */

    target.encryptMessage = function (receiverDID, message, callback) {
        __ensureEnclaveExistsThenExecute("encryptMessage", target, receiverDID, message, callback);
    };

    target.decryptMessage = function (encryptedMessage, callback) {
        __ensureEnclaveExistsThenExecute("decryptMessage", target, encryptedMessage, callback);
    };

    /* messages to the APiHUb MQ compatible APIs

      * */

    target.getHash = () => {
        return crypto.sha256(target.getIdentifier());
    };

    target.sendMessage = function (message, toOtherDID, callback) {
        if (typeof message === "object") {
            try {
                message = message.getSerialisation();
            } catch (e) {
                message = JSON.stringify(message);
            }
        }

        const __sendMessage = () => {
            const mqHandler = require("opendsu")
                .loadAPI("mq")
                .getMQHandlerForDID(toOtherDID);
            target.encryptMessage(toOtherDID, message, (err, encryptedMessage) => {
                if (err) {
                    return callback(
                        createOpenDSUErrorWrapper(`Failed to encrypt message`, err)
                    );
                }

                mqHandler.writeMessage(JSON.stringify(encryptedMessage), callback);
            });
        }

        if (typeof toOtherDID === "string") {
            enclave.resolveDID(toOtherDID, (err, didDocument) => {
                if (err) {
                    return callback(err);
                }

                toOtherDID = didDocument;
                __sendMessage();
            })
        } else {
            __sendMessage();
        }
    };

    target.readMessage = function (callback) {
        const mqHandler = require("opendsu")
            .loadAPI("mq")
            .getMQHandlerForDID(target);
        mqHandler.previewMessage((err, encryptedMessage) => {
            if (err) {
                return callback(createOpenDSUErrorWrapper(`Failed to read message`, err));
            }

            let message;
            try {
                message = JSON.parse(encryptedMessage.message);
            } catch (e) {
                return callback(createOpenDSUErrorWrapper(`Failed to parse received message`, err));
            }

            mqHandler.deleteMessage(encryptedMessage.messageId, (err) => {
                if (err) {
                    return callback(createOpenDSUErrorWrapper(`Failed to delete message`, err));
                }
                target.decryptMessage(message, callback);
            })
        });
    };

    target.subscribe = function (callback) {
        const mqHandler = require("opendsu")
            .loadAPI("mq")
            .getMQHandlerForDID(target);
        mqHandler.subscribe((err, encryptedMessage) => {
            if (err) {
                return callback(createOpenDSUErrorWrapper(`Failed to read message`, err));
            }
            let message;
            try {
                message = JSON.parse(encryptedMessage.message);
            } catch (e) {
                return callback(createOpenDSUErrorWrapper(`Failed to parse received message`, err));
            }

            target.decryptMessage(message, callback);
        });
    };

    target.waitForMessages = function (callback) {
        const mqHandler = require("opendsu")
            .loadAPI("mq")
            .getMQHandlerForDID(target);

        target.onCallback = (err, encryptedMessage) => {
            if (err) {
                return callback(createOpenDSUErrorWrapper(`Failed to read message`, err));
            }
            let message;
            try {
                message = JSON.parse(encryptedMessage.message);
            } catch (e) {
                return callback(createOpenDSUErrorWrapper(`Failed to parse received message`, err));
            }

            target.decryptMessage(message, callback);
        }
        target.onCallback.on = true;
        mqHandler.waitForMessages(target.onCallback);
    };

    target.stopWaitingForMessages = function () {
        target.onCallback.on = false;
    }

    target.getEnclave = () => {
        return enclave;
    }

    target.on = function (callback) {
    };

    target.revokeDID = function (callback) {
    };

    target.revokeKey = function (key, callback) {
    };

    target.getControllerKey = function (callback) {
    };

    target.getPublicKeys = function (callback) {
    };

    target.getDomain = function () {
    }
}

module.exports = W3CDID_Mixin;

},{"opendsu":"opendsu"}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/w3cdid/W3CVC_Mixin.js":[function(require,module,exports){

/*
    W3CVC Mixin is abstracting a JWT based credential
    The same approach/interface can be used with credentials represented in other formats
 */

function W3CVC_Mixin(){
    let serialisation;
    /*
        Verify that the signature of the issuer is correct
     */
    this.load = function(vcSerialisationDocument, callback){
        serialisation = vcSerialisationDocument;
    };

    /*
        Verify that the signature of the issuer is correct
     */
    this.verify = function(callback){

    };

}

module.exports = W3CVC_Mixin;

},{}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/w3cdid/didDocumentsFactory.js":[function(require,module,exports){
const methodsNames = require("./didMethodsNames");
const createNameDIDDocument = require("./didssi/NameDID_Document").initiateDIDDocument;
const createGroupDID_Document = require("./didssi/GroupDID_Document").initiateDIDDocument;
const createSReadDID_Document = require("./didssi/SReadDID_Document").initiateDIDDocument;
const createSSI_KeyDID_Document = require("./didssi/KeyDID_Document").initiateDIDDocument;
const createKeyDID_Document = require("./w3cdids/KeyDID_Document").initiateDIDDocument;

const didsConstructors = {};

const registerDID_Document_Constructor = (didMethod, didConstructor) => {
    didsConstructors[didMethod] = didConstructor;
}

const createDID_Document = (didMethod, ...args) => {
    return didsConstructors[didMethod](...args);
}

registerDID_Document_Constructor(methodsNames.NAME_SUBTYPE, createNameDIDDocument);
registerDID_Document_Constructor(methodsNames.GROUP_METHOD_NAME, createGroupDID_Document);
registerDID_Document_Constructor(methodsNames.S_READ_SUBTYPE, createSReadDID_Document);
registerDID_Document_Constructor(methodsNames.SSI_KEY_SUBTYPE, createSSI_KeyDID_Document);
registerDID_Document_Constructor(methodsNames.KEY_SUBTYPE, createKeyDID_Document);

module.exports = {
    registerDID_Document_Constructor,
    createDID_Document
}
},{"./didMethodsNames":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/w3cdid/didMethodsNames.js","./didssi/GroupDID_Document":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/w3cdid/didssi/GroupDID_Document.js","./didssi/KeyDID_Document":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/w3cdid/didssi/KeyDID_Document.js","./didssi/NameDID_Document":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/w3cdid/didssi/NameDID_Document.js","./didssi/SReadDID_Document":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/w3cdid/didssi/SReadDID_Document.js","./w3cdids/KeyDID_Document":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/w3cdid/w3cdids/KeyDID_Document.js"}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/w3cdid/didMethodsNames.js":[function(require,module,exports){
module.exports = {
    OPENDSU_METHOD_NAME: "ssi",
    KEY_SUBTYPE: "key",
    SSI_KEY_SUBTYPE: "ssi:key",
    S_READ_SUBTYPE: "ssi:sread",
    NAME_SUBTYPE: "ssi:name",
    GROUP_METHOD_NAME: "ssi:group",
    DEMO_METHOD_NAME: "demo"
}
},{}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/w3cdid/didssi/ConstDID_Document_Mixin.js":[function(require,module,exports){
(function (Buffer){(function (){
const {createOpenDSUErrorWrapper} = require("../../error");

function ConstDID_Document_Mixin(target, enclave, domain, name, isInitialisation) {
    if (arguments.length === 4) {
        isInitialisation = name;
        name = domain;
        domain = undefined;
    }
    let mixin = require("../W3CDID_Mixin");
    const observableMixin = require("../../utils/ObservableMixin")
    mixin(target, enclave);
    observableMixin(target);

    const openDSU = require("opendsu");
    const dbAPI = openDSU.loadAPI("db");
    const scAPI = openDSU.loadAPI("sc");
    const crypto = openDSU.loadAPI("crypto");
    const keySSISpace = openDSU.loadAPI("keyssi");
    const resolver = openDSU.loadAPI("resolver");

    const WRITABLE_DSU_PATH = "writableDSU";
    const PUB_KEYS_PATH = "publicKeys";

    const generatePublicKey = async () => {
        let seedSSI;
        try {
            seedSSI = await $$.promisify(keySSISpace.createSeedSSI)(domain);
        } catch (e) {
            throw createOpenDSUErrorWrapper(`Failed to create SeedSSI`, e);
        }

        target.privateKey = seedSSI.getPrivateKey();
        return seedSSI.getPublicKey("raw");
    };

    const createDSU = async () => {
        let constDSU;
        try {
            constDSU = await $$.promisify(resolver.createConstDSU)(domain, name);
        } catch (e) {
            throw createOpenDSUErrorWrapper(`Failed to create constDSU`, e);
        }

        constDSU.beginBatch();
        try {
            target.dsu = await $$.promisify(resolver.createSeedDSU)(domain);
        } catch (e) {
            throw createOpenDSUErrorWrapper(`Failed to create writableDSU`, e);
        }

        let publicKey = await generatePublicKey();
        try {
            await $$.promisify(target.addPublicKey)(publicKey);
        } catch (e) {
            throw createOpenDSUErrorWrapper(`Failed to save public key`, e);
        }
        let seedSSI;
        try {
            seedSSI = await $$.promisify(target.dsu.getKeySSIAsString)();
        } catch (e) {
            throw createOpenDSUErrorWrapper(`Failed to get seedSSI`, e);
        }

        try {
            await $$.promisify(constDSU.mount)(WRITABLE_DSU_PATH, seedSSI);
        } catch (e) {
            throw createOpenDSUErrorWrapper(`Failed to mount writable DSU`, e);
        }

        try {
            await $$.promisify(constDSU.commitBatch)();
        } catch (e) {
            throw createOpenDSUErrorWrapper(`Failed to commit batch in Const DSU`, e);
        }

        target.finishInitialisation();
        target.dispatchEvent("initialised");
    };

    let init = async () => {
        if (!domain) {
            try {
                domain = await $$.promisify(scAPI.getDIDDomain)();
            } catch (e) {
                throw createOpenDSUErrorWrapper(`Failed to get did domain`, e);
            }
        }
        resolver.loadDSU(keySSISpace.createConstSSI(domain, name), async (err, constDSUInstance) => {
            if (err) {
                if (isInitialisation === false) {
                    return target.dispatchEvent("error", err);
                }
                try {
                    await createDSU(domain, name);
                } catch (e) {
                    throw createOpenDSUErrorWrapper(`Failed to create DSU`, e);
                }
                return;
            }

            try {
                const dsuContext = await $$.promisify(constDSUInstance.getArchiveForPath)(WRITABLE_DSU_PATH);
                target.dsu = dsuContext.archive;
            } catch (e) {
                throw createOpenDSUErrorWrapper(`Failed to load writableDSU`, e);
            }

            target.finishInitialisation();
            target.dispatchEvent("initialised");
        });
    }

    target.init = () => {
        //this settimeout is to allow proper event setup before initialization
        setTimeout(init, 0);
    }

    target.getPrivateKeys = () => {
        return [target.privateKey];
    };

    target.getPublicKey = (format, callback) => {
        target.dsu.listFiles(PUB_KEYS_PATH, (err, pubKeys) => {
            if (err) {
                return callback(createOpenDSUErrorWrapper(`Failed to read public key for did ${target.getIdentifier()}`, err));
            }

            let pubKey = Buffer.from(pubKeys[pubKeys.length - 1], "hex");
            if (format === "raw") {
                return callback(undefined, pubKey);
            }

            try {
                pubKey = crypto.convertPublicKey(pubKey, format);
            } catch (e) {
                return callback(createOpenDSUErrorWrapper(`Failed to convert raw public key to pem`, e));
            }

            callback(undefined, pubKey);
        });
    };

    target.getDomain = () => {
        return domain;
    };

    target.addPublicKey = (publicKey, callback) => {
        target.dsu.writeFile(`${PUB_KEYS_PATH}/${publicKey.toString("hex")}`, callback);
    }
}

module.exports = ConstDID_Document_Mixin;

}).call(this)}).call(this,require("buffer").Buffer)

},{"../../error":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/error/index.js","../../utils/ObservableMixin":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/utils/ObservableMixin.js","../W3CDID_Mixin":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/w3cdid/W3CDID_Mixin.js","buffer":false,"opendsu":"opendsu"}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/w3cdid/didssi/GroupDID_Document.js":[function(require,module,exports){
const methodsNames = require("../didMethodsNames");

function GroupDID_Document(enclave, domain, groupName, isInitialisation) {
    if (typeof domain === "undefined" || typeof groupName === "undefined") {
        throw Error(`Invalid number of arguments. Expected blockchain domain and group name.`);
    }

    let mixin = require("./ConstDID_Document_Mixin");
    mixin(this, enclave, domain, groupName, isInitialisation);
    const bindAutoPendingFunctions = require("../../utils/BindAutoPendingFunctions").bindAutoPendingFunctions;
    const openDSU = require("opendsu");
    const MEMBERS_FILE = "members";

    this.getMethodName = () => {
        return methodsNames.GROUP_METHOD_NAME;
    }

    this.addMember = (identity, memberInfo, callback) => {
        if (typeof memberInfo === "function") {
            callback = memberInfo;
            memberInfo = identity;
        }
        updateMembers("add", [identity], [memberInfo], callback);
    };

    this.addMembers = (identities, aliases, callback) => {
        updateMembers("add", identities, aliases, callback);
    };

    this.removeMember = (identity, callback) => {
        updateMembers("remove", [identity], callback);
    };

    this.removeMembers = (identities, callback) => {
        updateMembers("remove", identities, callback);
    };

    this.listMembersInfo = (callback) => {
        readMembers((err, members) => {
            if (err) {
                return callback(err);
            }

            callback(undefined, Object.values(members));
        });
    };

    this.listMembersByIdentity = (callback) => {
        readMembers((err, members) => {
            if (err) {
                return callback(err);
            }

            callback(undefined, Object.keys(members));
        });
    };

    this.getMemberIdentity = (name, callback) => {
        readMembers((err, members) => {
            if (err) {
                return callback(err);
            }

            const member = Object.keys(members).find(identifier => members[identifier] === name);
            if (typeof member === "undefined") {
                return callback(Error(`Failed to find member with alias ${name}`));
            }
            callback(undefined, Object.keys(member)[0]);
        });
    };

    this.getMemberInfo = (identity, callback) => {
        readMembers((err, members) => {
            if (err) {
                return callback(err);
            }

            const memberInfo = members[identity];
            if (typeof memberInfo === "undefined") {
                return callback(Error(`Failed to find member with id ${identity}`));
            }
            callback(undefined, memberInfo);
        });
    };

    this.getMembers = (callback) => {
        readMembers(callback);
    }

    this.getIdentifier = () => {
        return `did:ssi:group:${domain}:${groupName}`;
    };

    this.getGroupName = () => {
        return groupName;
    };

    this.sendMessage = (message, callback) => {
        const w3cDID = openDSU.loadAPI("w3cdid");
        if (typeof message === "object") {
            try {
                message = message.getSerialisation();
            } catch (e) {
                return callback(e);
            }
        }
        readMembers(async (err, members) => {
            if (err) {
                return callback(err);
            }

            const membersIds = Object.keys(members);
            const noMembers = membersIds.length;
            let senderDIDDocument;
            try{
                senderDIDDocument = await $$.promisify(w3cDID.resolveDID)(membersIds[0]);
            }
            catch (e) {
                return callback(e);
            }
            let counter = noMembers;
            for (let i = 0; i < noMembers; i++) {
                try {
                    const receiverDIDDocument = await $$.promisify(w3cDID.resolveDID)(membersIds[i]);
                    await $$.promisify(senderDIDDocument.sendMessage)(message, receiverDIDDocument)
                } catch (e) {
                    return callback(e);
                }

                counter--;
                if (counter === 0) {
                    return callback();
                }
            }
        });
    };

    const readMembers = (callback) => {
        this.dsu.readFile(MEMBERS_FILE, (err, members) => {
            if (err || typeof members === "undefined") {
                members = {};
            } else {
                try {
                    members = JSON.parse(members.toString());
                } catch (e) {
                    return callback(e);
                }
            }

            callback(undefined, members);
        });
    };

    const updateMembers = (operation, identities, info, callback) => {
        if (typeof info === "function") {
            callback = info;
            info = identities;
        }

        if (!Array.isArray(identities)) {
            return callback(Error(`Invalid format for identities. Expected array.`));
        }

        if (operation === "remove" && !Array.isArray(info)) {
            return callback(Error(`Invalid format for info. Expected array.`));
        }

        readMembers((err, members) => {
            if (err) {
                return callback(err);
            }

            if (operation === "remove") {
                identities.forEach(id => {
                    if (typeof members[id] !== "undefined") {
                        delete members[id];
                    }
                });

                return this.dsu.writeFile(MEMBERS_FILE, JSON.stringify(members), callback);
            } else if (operation === "add") {
                identities.forEach((id, index) => {
                    if (typeof id === "object") {
                        id = id.getIdentifier();
                    }
                    if (typeof members[id] === "undefined") {
                        members[id] = info[index];
                    }
                });
                return this.dsu.writeFile(MEMBERS_FILE, JSON.stringify(members), callback);
            } else {
                callback(Error(`Invalid operation ${operation}`));
            }
        });
    };

    bindAutoPendingFunctions(this, ["init", "getIdentifier", "getGroupName", "addPublicKey", "on", "off", "dispatchEvent", "removeAllObservers"]);

    this.init();
    return this;
}


module.exports = {
    initiateDIDDocument: function (enclave, domain, groupName) {
        return new GroupDID_Document(enclave, domain, groupName)
    },
    createDIDDocument: function (enclave, tokens) {
        return new GroupDID_Document(enclave, tokens[3], tokens[4], false);
    }
};

},{"../../utils/BindAutoPendingFunctions":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/utils/BindAutoPendingFunctions.js","../didMethodsNames":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/w3cdid/didMethodsNames.js","./ConstDID_Document_Mixin":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/w3cdid/didssi/ConstDID_Document_Mixin.js","opendsu":"opendsu"}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/w3cdid/didssi/KeyDID_Document.js":[function(require,module,exports){
const methodsNames = require("../didMethodsNames");
const {bindAutoPendingFunctions} = require("../../utils/BindAutoPendingFunctions");

function KeyDID_Document(enclave, isInitialisation, seedSSI) {
    let DID_mixin = require("../W3CDID_Mixin");
    DID_mixin(this, enclave);

    const openDSU = require("opendsu");
    const dbAPI = openDSU.loadAPI("db");
    const keySSISpace = openDSU.loadAPI("keyssi");
    const crypto = openDSU.loadAPI("crypto");

    let tokens;
    const __init = async () => {
        if (!isInitialisation) {
            tokens = seedSSI;
            seedSSI = undefined;
        }

        if (typeof seedSSI === "string") {
            try {
                seedSSI = keySSISpace.parse(seedSSI);
            } catch (e) {
                throw createOpenDSUErrorWrapper(`Failed to parse ssi ${seedSSI}`);
            }
        }
    }

    this.getMethodName = () => {
        return methodsNames.SSI_KEY_SUBTYPE;
    }

    this.getDomain = () => {
        let domain;
        if (!isInitialisation) {
            domain = tokens[0];
        } else {
            domain = seedSSI.getDLDomain();
        }

        return domain;
    }

    const getRawPublicKey = () => {
        let publicKey;
        if (!isInitialisation) {
            publicKey = crypto.decodeBase58(tokens[1])
        } else {
            publicKey = seedSSI.getPublicKey("raw");
        }

        return publicKey;
    }

    this.getPublicKey = (format, callback) => {
        let pubKey = getRawPublicKey();
        try {
            pubKey = crypto.convertPublicKey(pubKey, format);
        } catch (e) {
            return callback(createOpenDSUErrorWrapper(`Failed to convert public key to ${format}`, e));
        }

        callback(undefined, pubKey);
    };

    this.getIdentifier = () => {
        const domain = this.getDomain();
        let publicKey = getRawPublicKey();
        publicKey = crypto.encodeBase58(publicKey);
        return `did:ssi:key:${domain}:${publicKey}`;
    };

    this.getPrivateKeys = () => {
        return [seedSSI.getPrivateKey()];
    };

    __init();
    return this;
}

module.exports = {
    initiateDIDDocument: function (enclave, seedSSI) {
        return new KeyDID_Document(enclave, true, seedSSI);
    },
    createDIDDocument: function (enclave, tokens) {
        return new KeyDID_Document(enclave, false,  [tokens[3], tokens[4]]);
    }
};

},{"../../utils/BindAutoPendingFunctions":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/utils/BindAutoPendingFunctions.js","../W3CDID_Mixin":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/w3cdid/W3CDID_Mixin.js","../didMethodsNames":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/w3cdid/didMethodsNames.js","opendsu":"opendsu"}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/w3cdid/didssi/NameDID_Document.js":[function(require,module,exports){
const methodsNames = require("../didMethodsNames");

function NameDID_Document(enclave, domain, name, isInitialisation) {
    if (arguments.length === 3) {
        isInitialisation = name;
        name = domain;
        domain = undefined;
    }
    if (typeof name === "undefined") {
        throw Error(`Argument name is missing`);
    }

    let mixin = require("./ConstDID_Document_Mixin");
    mixin(this, enclave, domain, name, isInitialisation);
    const bindAutoPendingFunctions = require("../../utils/BindAutoPendingFunctions").bindAutoPendingFunctions;

    this.getMethodName = () => {
        return methodsNames.NAME_SUBTYPE;
    }

    this.getIdentifier = () => {
        return `did:ssi:name:${this.getDomain()}:${name}`;
    };

    this.getName = () => {
        return name;
    };

    bindAutoPendingFunctions(this, ["init", "getIdentifier", "getName", "on", "off", "dispatchEvent", "removeAllObservers", "addPublicKey", "readMessage", "getDomain", "getHash"]);
    this.init();
    return this;
}


module.exports = {
    initiateDIDDocument: function (enclave, domain, name) {
        return new NameDID_Document(enclave, domain, name, true);
    },
    createDIDDocument: function (enclave, tokens) {
        return new NameDID_Document(enclave, tokens[3], tokens[4], false);
    }
};

},{"../../utils/BindAutoPendingFunctions":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/utils/BindAutoPendingFunctions.js","../didMethodsNames":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/w3cdid/didMethodsNames.js","./ConstDID_Document_Mixin":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/w3cdid/didssi/ConstDID_Document_Mixin.js"}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/w3cdid/didssi/SReadDID_Document.js":[function(require,module,exports){
const methodsNames = require("../didMethodsNames");

function SReadDID_Document(enclave, isInitialisation, seedSSI) {
    const DID_mixin = require("./ConstDID_Document_Mixin");
    const ObservableMixin = require("../../utils/ObservableMixin");
    let tokens;
    let sReadSSI;

    const PUB_KEYS_PATH = "publicKeys";
    DID_mixin(this, enclave);
    ObservableMixin(this);
    const openDSU = require("opendsu");
    const keySSISpace = openDSU.loadAPI("keyssi");
    const resolver = openDSU.loadAPI("resolver");
    const dbAPI = openDSU.loadAPI("db");

    const createSeedDSU = async () => {
        try {
            this.dsu = await $$.promisify(resolver.createDSUForExistingSSI)(seedSSI);
        } catch (e) {
            throw createOpenDSUErrorWrapper(`Failed to create seed dsu`, e);
        }

        let ssi;
        try {
            ssi = await $$.promisify(keySSISpace.createSeedSSI)(seedSSI.getDLDomain());
        } catch (e) {
            throw createOpenDSUErrorWrapper(`Failed to create seed ssi`, e);
        }

        this.privateKey = ssi.getPrivateKey();
        const publicKey = ssi.getPublicKey("raw");

        try {
            await $$.promisify(this.dsu.writeFile)(`${PUB_KEYS_PATH}/${publicKey.toString("hex")}`);
        } catch (e) {
            throw createOpenDSUErrorWrapper(`Failed to write public key in dsu`, e);
        }
    };

    this.init = async () => {
        if (typeof seedSSI === "string") {
            try {
                seedSSI = keySSISpace.parse(seedSSI);
            } catch (e) {
                throw createOpenDSUErrorWrapper(`Failed to parse ssi ${seedSSI}`, e);
            }
        }

        if (isInitialisation) {
            try {
                sReadSSI = await $$.promisify(seedSSI.derive)();
            } catch (e) {
                throw createOpenDSUErrorWrapper(`Failed to derive seedSSI ${seedSSI.getIdentifier()}`, e);
            }
            await createSeedDSU();
            this.finishInitialisation();
            this.dispatchEvent("initialised");
        } else {
            tokens = seedSSI;
            sReadSSI = tokens.join(":");
            sReadSSI = keySSISpace.parse(sReadSSI);
            seedSSI = undefined;

            try {
                this.dsu = await $$.promisify(resolver.loadDSU)(sReadSSI);
            } catch (e) {
                throw createOpenDSUErrorWrapper(`Failed to load dsu`, e);
            }

            this.finishInitialisation();
            this.dispatchEvent("initialised");
        }
    };

    this.getMethodName = () => {
        return methodsNames.S_READ_SUBTYPE;
    }

    this.getDomain = () => {
        let domain;
        if (!isInitialisation) {
            domain = sReadSSI.getDLDomain();
        } else {
            domain = seedSSI.getDLDomain();
        }

        return domain;
    }

    this.getIdentifier = () => {
        return `did:${sReadSSI.getIdentifier(true)}`
    };

    const bindAutoPendingFunctions = require("../../utils/BindAutoPendingFunctions").bindAutoPendingFunctions;
    bindAutoPendingFunctions(this, ["init", "getIdentifier", "getDomain", "on", "off", "addPublicKey"]);

    this.init();
    return this;
}

module.exports = {
    initiateDIDDocument: function (enclave, seedSSI) {
        return new SReadDID_Document(enclave, true, seedSSI)
    },
    createDIDDocument: function (enclave, tokens) {
        return new SReadDID_Document(enclave, false, tokens.slice(1));
    }
};

},{"../../utils/BindAutoPendingFunctions":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/utils/BindAutoPendingFunctions.js","../../utils/ObservableMixin":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/utils/ObservableMixin.js","../didMethodsNames":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/w3cdid/didMethodsNames.js","./ConstDID_Document_Mixin":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/w3cdid/didssi/ConstDID_Document_Mixin.js","opendsu":"opendsu"}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/w3cdid/didssi/ssiMethods.js":[function(require,module,exports){
function storeDIDInSC(didDocument, callback) {
    const securityContext = require("opendsu").loadAPI("sc").getSecurityContext();
    const __registerDID = () => {
        securityContext.registerDID(didDocument, (err) => {
            if (err) {
                return callback(createOpenDSUErrorWrapper(`failed to register did ${didDocument.getIdentifier()} in security context`, err));
            }

            callback(null, didDocument);
        })
    }
    if (securityContext.isInitialised()) {
        __registerDID();
    } else {
        securityContext.on("initialised", () => {
            __registerDID()
        })
    }
}

const openDSU = require("opendsu");
const dbAPI = openDSU.loadAPI("db")
const __ensureEnclaveExistsThenExecute = (fn, enclave, ...args) => {
    if (typeof enclave === "undefined") {
        dbAPI.getMainEnclave((err, mainEnclave) => {
            if (err) {
                return callback(err);
            }

            enclave = mainEnclave;
            fn(mainEnclave, ...args);
        })
    } else {
        fn(enclave, ...args);
    }
}

function SReadDID_Method() {
    let SReadDID_Document = require("./SReadDID_Document");
    this.create = (enclave, seedSSI, callback) => {
        const sReadDIDDocument = SReadDID_Document.initiateDIDDocument(enclave, seedSSI);
        sReadDIDDocument.on("error", (err) => {
            callback(err);
        });

        sReadDIDDocument.on("initialised", () => {
            callback(undefined, sReadDIDDocument);
        });
    }
    this.resolve = function (enclave, tokens, callback) {
        const sReadDIDDocument = SReadDID_Document.createDIDDocument(enclave, tokens);
        sReadDIDDocument.on("initialised", () => {
            callback(undefined, sReadDIDDocument);
        });
    }
}

function KeyDID_Method() {
    let KeyDIDDocument = require("./KeyDID_Document");
    this.create = function (enclave, seedSSI, callback) {
        const keyDIDDocument = KeyDIDDocument.initiateDIDDocument(enclave, seedSSI);
        callback(undefined, keyDIDDocument);
    }

    this.resolve = function (enclave, tokens, callback) {
        callback(null, KeyDIDDocument.createDIDDocument(enclave, tokens))
    }
}

function NameDID_Method() {
    const NameDIDDocument = require("./NameDID_Document");

    this.create = (enclave, domain, publicName, callback) => {
        if (typeof publicName === "function") {
            callback = publicName;
            publicName = domain;
            domain = undefined;
        }
        const nameDIDDocument = NameDIDDocument.initiateDIDDocument(enclave, domain, publicName);

        nameDIDDocument.on("error", (err) => {
            return callback(err);
        })

        nameDIDDocument.on("initialised", () => {
            callback(undefined, nameDIDDocument);
        });
    }

    this.resolve = (enclave, tokens, callback) => {
        const nameDIDDocument = NameDIDDocument.createDIDDocument(enclave, tokens);
        nameDIDDocument.on("error", (err) => {
            return callback(err);
        })

        nameDIDDocument.on("initialised", () => {
            callback(null, nameDIDDocument)
        });
    }
}

function GroupDID_Method() {
    const GroupDIDDocument = require("./GroupDID_Document");

    this.create = (enclave, domain, groupName, callback) => {
        const groupDIDDocument = GroupDIDDocument.initiateDIDDocument(enclave, domain, groupName);

        groupDIDDocument.on("error", (err) => {
            return callback(err);
        })

        groupDIDDocument.on("initialised", () => {
            callback(undefined, groupDIDDocument);
        })
    }

    this.resolve = (enclave, tokens, callback) => {
        const groupDIDDocument = GroupDIDDocument.createDIDDocument(enclave, tokens);

        groupDIDDocument.on("error", (err) => {
            return callback(err);
        })

        groupDIDDocument.on("initialised", () => {
            return callback(undefined, groupDIDDocument);
        })
    }
}

function create_KeyDID_Method() {
    return new KeyDID_Method();
}

function create_SReadDID_Method() {
    return new SReadDID_Method();
}

function create_NameDID_Method() {
    return new NameDID_Method();
}

function create_GroupDID_Method() {
    return new GroupDID_Method();
}


module.exports = {
    create_KeyDID_Method,
    create_SReadDID_Method,
    create_NameDID_Method,
    create_GroupDID_Method
}

},{"./GroupDID_Document":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/w3cdid/didssi/GroupDID_Document.js","./KeyDID_Document":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/w3cdid/didssi/KeyDID_Document.js","./NameDID_Document":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/w3cdid/didssi/NameDID_Document.js","./SReadDID_Document":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/w3cdid/didssi/SReadDID_Document.js","opendsu":"opendsu"}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/w3cdid/hubs/CommunicationHub.js":[function(require,module,exports){
function CommunicationHub() {
    const pubSub = require("soundpubsub").soundPubSub;
    const didAPI = require("opendsu").loadAPI("w3cdid");
    const connectedToMQ = {};
    let strongPubSub;
    const getChannelName = (did, messageType) => {
        return `${did.getIdentifier()}/${messageType}`;
    }

    const ensureDIDDocumentIsLoadedThenExecute = (did, fnToExecute) => {
        if (typeof did === "string") {
            return didAPI.resolveDID(did, (err, resolvedDID) => {
                if (err) {
                    console.error(err);
                    return;
                }

                did = resolvedDID;
                fnToExecute(did);
            })
        }

        fnToExecute(did);
    }

    this.subscribe = (did, messageType, callback) => {
        const __subscribe = (did) => {
            if (!connectedToMQ[did.getIdentifier()]) {
                connectedToMQ[did.getIdentifier()] = true;
                did.waitForMessages((err, message) => {
                    if (err) {
                        console.error(err);
                        return;
                    }

                    try {
                        message = JSON.parse(message);
                    } catch (e) {
                        console.error(e);
                        return;
                    }

                    const channelName = getChannelName(did, message.messageType);
                    if (!pubSub.hasChannel(channelName)) {
                        pubSub.addChannel(channelName);
                    }

                    pubSub.publish(channelName, message);
                });
            }
            const channel = getChannelName(did, messageType);
            pubSub.subscribe(channel, callback);
        }

        ensureDIDDocumentIsLoadedThenExecute(did, __subscribe);
    };

    this.unsubscribe = (did, messageType, callback) => {
        const stopWaitingForMessages = (did) => {
            did.stopWaitingForMessages();
            const channel = getChannelName(did, messageType);
            delete connectedToMQ[did.getIdentifier()];
            pubSub.unsubscribe(channel, callback);
        }

        ensureDIDDocumentIsLoadedThenExecute(did, stopWaitingForMessages);
    };

    const subscribers = {};
    // soundpubSub keeps WeakRefs
    this.strongSubscribe = (did, messageType, callback) => {
        const __strongSubscribe = (did) => {
            const channelName = getChannelName(did, messageType);
            if (!subscribers[channelName]) {
                subscribers[channelName] = [];
            }

            const index = subscribers[channelName].findIndex(sub => sub === callback);
            if (index === -1) {
                subscribers[channelName].push(callback);
            }

            this.subscribe(did, messageType, callback);
        }

        ensureDIDDocumentIsLoadedThenExecute(did, __strongSubscribe);
    }

    this.strongUnsubscribe = (did, messageType, callback) => {
        const channelName = getChannelName(did, messageType);
        const __strongUnsubscribe = (did) => {
            if (!subscribers[channelName]) {
                return callback();
            }

            const index = subscribers[channelName].findIndex(sub => sub === callback);
            if (index === -1) {
                return callback();
            }

            subscribers[channelName].splice(index);
            if (subscribers[channelName].length === 0) {
                delete subscribers[channelName];
                return callback();
            }

            this.unsubscribe(did, messageType, callback);
        }

        ensureDIDDocumentIsLoadedThenExecute(did, __strongUnsubscribe);
    }

    this.getPubSub = () => {
        return pubSub;
    }

    const createStrongPubSub = (_pubSub) => {
        const strongPubSub = Object.assign({}, _pubSub);
        strongPubSub.subscribe = (target, callback, waitForMore, filter) => {
            if (!subscribers[target]) {
                subscribers[target] = [];
            }

            const index = subscribers[target].findIndex(sub => sub === callback);
            if (index === -1) {
                subscribers[target].push(callback);
            }

            if (!_pubSub.hasChannel(target)) {
                _pubSub.addChannel(target);
            }

            _pubSub.subscribe(target, callback, waitForMore, filter);
        }

        strongPubSub.unsubscribe = (target, callback, filter) => {
            if (!strongPubSub[target]) {
                return callback();
            }

            const index = subscribers[target].findIndex(sub => sub === callback);
            if (index === -1) {
                return callback();
            }

            subscribers[target].splice(index);
            if (subscribers[target].length === 0) {
                delete subscribers[target];
                return callback();
            }

            _pubSub.unsubscribe(target, callback, filter);
        }

        return strongPubSub;
    }

    this.getStrongPubSub = () => {
        if (!strongPubSub) {
            strongPubSub = createStrongPubSub(pubSub);
        }

        return strongPubSub;
    }
}

const getCommunicationHub = () => {
    if (!$$.CommunicationHub) {
        $$.CommunicationHub = new CommunicationHub();
    }

    return $$.CommunicationHub;
}

module.exports = {
    getCommunicationHub
}

},{"opendsu":"opendsu","soundpubsub":"soundpubsub"}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/w3cdid/hubs/TypicalBusinessLogicHub.js":[function(require,module,exports){
const {createOpenDSUErrorWrapper} = require("../../error");
const getCheckVariableFunction = function (envVariableName, hubContext, selector,  callback) {
    if (hubContext[selector]) {
        hubContext.self.finishInitialisation();
        return callback(undefined, hubContext[selector]);
    }
    hubContext.configAPI.getEnv(envVariableName, (err, envValue) => {
        if (err || !envValue) {
            return callback(undefined, false);
        }

        hubContext[selector] = envValue;
        hubContext.self.finishInitialisation();
        callback(undefined, envValue);
    });
};

const setVariable = function (envVariableName, value, hubContext, selector, callback) {
    hubContext[selector] = value;
    hubContext.configAPI.setEnv(envVariableName, value, err => {
        if (err) {
            return callback(createOpenDSUErrorWrapper(`Failed to initialise app`, err));
        }

        hubContext.self.finishInitialisation();
        callback(undefined);
    });
};
function TypicalBusinessLogicHub() {
    const openDSU = require("opendsu");
    const didAPI = openDSU.loadAPI("w3cdid");
    const configAPI = openDSU.loadAPI("config");
    const utilsAPI = openDSU.loadAPI("utils");
    const constants = openDSU.constants;
    const APP_MAIN_DID = "appMainDID";
    const SHARED_ENCLAVE = "sharedEnclave";
    let hubContext = {
        appMainDID: undefined,
        sharedEnclave: undefined,
        self: this,
        configAPI
    }
    const commHub = didAPI.getCommunicationHub();

    this.mainDIDCreated = (callback) => {
        getCheckVariableFunction(constants.MAIN_APP_DID, hubContext, APP_MAIN_DID, callback);
    }

    this.setMainDID = (appMainDID, callback) => {
        setVariable(constants.MAIN_APP_DID, appMainDID, hubContext, APP_MAIN_DID, callback);
    }

    this.sharedEnclaveIsSet = (callback) => {
        getCheckVariableFunction(constants.SHARED_ENCLAVE, hubContext, SHARED_ENCLAVE, callback);
    }

    this.setSharedEnclave = (sharedEnclaveKeySSI, callback) => {
        setVariable(constants.SHARED_ENCLAVE, sharedEnclaveKeySSI, hubContext, SHARED_ENCLAVE, callback);
    }

    this.subscribe = (messageType, checkSecurityMethod, callback) => {
        commHub.subscribe(hubContext.appMainDID, messageType, checkSecurityMethod, callback);
    }

    this.unsubscribe = (messageType, callback) => {
        commHub.unsubscribe(hubContext.appMainDID, messageType, callback);
    }

    this.strongSubscribe = (messageType, callback) => {
        commHub.strongSubscribe(hubContext.appMainDID, messageType, callback);
    }

    this.strongUnsubscribe = (messageType, callback) => {
        commHub.strongUnsubscribe(hubContext.appMainDID, messageType, callback);
    }

    utilsAPI.bindParallelAutoPendingFunctions(this, ["mainDIDCreated", "setMainDID", "sharedEnclaveIsSet", "setSharedEnclave"]);
}

const getTypicalBusinessLogicHub = () => {
    if (!$$.TypicalBusinessLogicHub) {
        $$.TypicalBusinessLogicHub = new TypicalBusinessLogicHub();
    }

    return $$.TypicalBusinessLogicHub;
}

module.exports = {
    getTypicalBusinessLogicHub
}
},{"../../error":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/error/index.js","opendsu":"opendsu"}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/w3cdid/index.js":[function(require,module,exports){
/*
    OpenDSU W3C compatible  ID pluginisable resolver  that can resolve arbitrary DID methods.

        1. SeedSSI compatible DID method that does not need anchoring or external DSUs
            did:ssi:key:blockchain_domain::publicKey:v2:

        2.  DID method storing the public key in an anchored DSU. It is a SeedSSI compatible DID method.
            did:ssi:sread:blockchain_domain:hash_privateKey:hash_publicKey:

        3.  DID method storing the public key in an immutable DSU that is mounting another mutable DSU to store the keys
            did:ssi:name:blockchain_domain:public-name:::

        4. Group DID
            did:ssi:group:blockchain_domain:const_string

        5. DID Web Method
            did:web:internet_domain.

        6. SSI DID_KEY
            did:key:public_key

        7. DID DEMO
            did:demo:const_string
        TODO: analise the implementation of resolvers  masquerading as DSUs anchored in the BDNS central root:  did:ethereum:whatever

 */

const methodsNames = require("./didMethodsNames");
let methodRegistry = {};

const openDSU = require("opendsu");
const dbAPI = openDSU.loadAPI("db");

/*
    Create a new W3CDID based on SeedSSI
 */
function createIdentity(didMethod, ...args) {
    we_createIdentity(undefined, didMethod, ...args);
}

function we_createIdentity(enclave, didMethod, ...args) {
    let callback = args.pop();

    const __createAndStoreDID = (enclave) => {
        methodRegistry[didMethod].create(enclave, ...args, (err, didDocument) => {
            if (err) {
                return callback(err);
            }

            enclave.storeDID(didDocument, didDocument.getPrivateKeys(), err => callback(err, didDocument));
        });
    }
    if (typeof enclave === "undefined") {
        if (!dbAPI.mainEnclaveIsInitialised()) {
            return methodRegistry[didMethod].create(enclave, ...args, callback);
        }
        dbAPI.getMainEnclave((err, mainEnclave) => {
            if (err) {
                return callback(err);
            }

            __createAndStoreDID(mainEnclave);
        });
    } else {
        __createAndStoreDID(enclave);
    }
}

/*
    Returns an error or an instance of W3CDID
 */
function resolveDID(identifier, callback) {
    we_resolveDID(undefined, identifier, callback);
}

function we_resolveDID(enclave, identifier, callback) {
    let tokens = identifier.split(":");
    if (tokens[0] !== "did") {
        return callback(Error("Wrong identifier format. Missing did keyword."));
    }
    let method = tokens[1];
    if (tokens[1] === methodsNames.OPENDSU_METHOD_NAME) {
        method = `${tokens[1]}:${tokens[2]}`;
    }

    if (typeof enclave === "undefined") {
        if (!dbAPI.mainEnclaveIsInitialised()) {
            methodRegistry[method].resolve(undefined, tokens, callback);
            return;
        }
        dbAPI.getMainEnclave((err, mainEnclave) => {
            if (err) {
                return callback(err);
            }

            methodRegistry[method].resolve(mainEnclave, tokens, callback);
        })
    } else {
        methodRegistry[method].resolve(enclave, tokens, callback);
    }
}


function registerDIDMethod(method, implementation) {
    methodRegistry[method] = implementation;
}


registerDIDMethod(methodsNames.S_READ_SUBTYPE, require("./didssi/ssiMethods").create_SReadDID_Method());
registerDIDMethod(methodsNames.SSI_KEY_SUBTYPE, require("./didssi/ssiMethods").create_KeyDID_Method());
registerDIDMethod(methodsNames.NAME_SUBTYPE, require("./didssi/ssiMethods").create_NameDID_Method());

registerDIDMethod(methodsNames.GROUP_METHOD_NAME, require("./didssi/ssiMethods").create_GroupDID_Method());
registerDIDMethod(methodsNames.KEY_SUBTYPE, require("./w3cdids/didMethods").create_KeyDID_Method());

registerDIDMethod(methodsNames.DEMO_METHOD_NAME, require("./w3cdids/didMethods").create_KeyDID_Method());
// registerDIDMethod(methodsNames.DEMO_METHOD_NAME, require("./demo/diddemo").create_demo_DIDMethod());

module.exports = {
    createIdentity,
    we_createIdentity,
    resolveDID,
    we_resolveDID,
    registerDIDMethod,
    CryptographicSkills: require("./CryptographicSkills/CryptographicSkills"),
    W3CDIDMixin: require('./W3CDID_Mixin'),
    W3CCVCMixin: require('./W3CVC_Mixin'),
    getCommunicationHub: require("./hubs/CommunicationHub").getCommunicationHub,
    getTypicalBusinessLogicHub: require("./hubs/TypicalBusinessLogicHub").getTypicalBusinessLogicHub
}

},{"./CryptographicSkills/CryptographicSkills":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/w3cdid/CryptographicSkills/CryptographicSkills.js","./W3CDID_Mixin":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/w3cdid/W3CDID_Mixin.js","./W3CVC_Mixin":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/w3cdid/W3CVC_Mixin.js","./didMethodsNames":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/w3cdid/didMethodsNames.js","./didssi/ssiMethods":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/w3cdid/didssi/ssiMethods.js","./hubs/CommunicationHub":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/w3cdid/hubs/CommunicationHub.js","./hubs/TypicalBusinessLogicHub":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/w3cdid/hubs/TypicalBusinessLogicHub.js","./w3cdids/didMethods":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/w3cdid/w3cdids/didMethods.js","opendsu":"opendsu"}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/w3cdid/w3cdids/KeyDID_Document.js":[function(require,module,exports){
(function (Buffer){(function (){
const methodsNames = require("../didMethodsNames");

function KeyDID_Document(enclave, isInitialisation, publicKey, privateKey) {
    const DID_mixin = require("../W3CDID_Mixin");
    const ObservableMixin = require("../../utils/ObservableMixin");
    DID_mixin(this, enclave);
    ObservableMixin(this);
    let domain;
    const openDSU = require("opendsu");
    const crypto = openDSU.loadAPI("crypto");

    const create = () => {
        if (typeof privateKey === "undefined") {
            if (typeof publicKey === "undefined") {
                const keyPair = crypto.generateKeyPair();
                privateKey = keyPair.privateKey;
                publicKey = crypto.encodeBase58(keyPair.publicKey);
            }
        } else {
            if (typeof privateKey === "string") {
                privateKey = Buffer.from(privateKey);
            }
            publicKey = crypto.encodeBase58(crypto.getPublicKeyFromPrivateKey(privateKey));
        }
    }

    const load = () => {
        if (!publicKey) {
            throw Error("Public key is missing from argument list.")
        }
        publicKey = publicKey.slice(4);
    }

    const init = () => {
        if (isInitialisation) {
            create();
        } else {
            load();
        }
        setTimeout(() => {
            this.dispatchEvent("initialised");
        })
    };

    const getRawPublicKey = () => {
        return crypto.decodeBase58(publicKey);
    }

    this.getPublicKey = (format, callback) => {
        let pubKey = getRawPublicKey();
        if (format === "raw") {
            return callback(undefined, pubKey);
        }
        try {
            pubKey = crypto.convertPublicKey(pubKey, format);
        } catch (e) {
            return callback(createOpenDSUErrorWrapper(`Failed to convert public key to ${format}`, e));
        }

        callback(undefined, pubKey);
    };

    this.getMethodName = () => {
        return methodsNames.KEY_SUBTYPE;
    }

    this.getDomain = () => {
        return domain;
    }

    this.getIdentifier = () => {
        return `did:key:zQ3s${publicKey}`;
    };

    this.getPrivateKeys = () => {
        return [privateKey];
    };

    init();
}

module.exports = {
    initiateDIDDocument: function (enclave, publicKey, privateKey) {
        return new KeyDID_Document(enclave, true, publicKey, privateKey);
    }, createDIDDocument: function (enclave, tokens) {
        return new KeyDID_Document(enclave, false, tokens[2]);
    }
};

}).call(this)}).call(this,require("buffer").Buffer)

},{"../../utils/ObservableMixin":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/utils/ObservableMixin.js","../W3CDID_Mixin":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/w3cdid/W3CDID_Mixin.js","../didMethodsNames":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/w3cdid/didMethodsNames.js","buffer":false,"opendsu":"opendsu"}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/w3cdid/w3cdids/didMethods.js":[function(require,module,exports){
function KeyDID_Method() {
    let KeyDIDDocument = require("./KeyDID_Document");
    this.create = function (enclave, publicKey, privateKey, callback) {
        if (typeof privateKey === "function") {
            callback = privateKey;
            privateKey = undefined;
        }

        if (typeof publicKey === "function") {
            callback = publicKey;
            publicKey = undefined;
        }

        const keyDIDDocument = KeyDIDDocument.initiateDIDDocument(enclave,  publicKey, privateKey);
        keyDIDDocument.on("initialised", () => {
            callback(undefined, keyDIDDocument);
        });
    }

    this.resolve = function (enclave, tokens, callback) {
        callback(null, KeyDIDDocument.createDIDDocument(enclave, tokens));
    }
}

module.exports = {
    create_KeyDID_Method() {
        return new KeyDID_Method();
    }
}
},{"./KeyDID_Document":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/w3cdid/w3cdids/KeyDID_Document.js"}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/workers/bootScript/node.js":[function(require,module,exports){
module.exports = () => {
    const worker_threads = "worker_threads";
    const { parentPort } = require(worker_threads);

    parentPort.postMessage("ready");

    parentPort.on("message", ({ functionName, payload }) => {
        console.log(`[workers] node worker activated by function "${functionName}"`);

        try {
            const result = require("opendsu").loadAPI("workers").getFunctionsRegistry()[functionName](payload);
            parentPort.postMessage({ result });
        } catch (error) {
            parentPort.postMessage({ error });
        }
    });

    process.on("uncaughtException", (error) => {
        console.error("[workers] uncaughtException inside node worker", error);

        setTimeout(() => process.exit(1), 100);
    });
}
},{"opendsu":"opendsu"}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/workers/bootScript/web.js":[function(require,module,exports){
module.exports = () => {
    addEventListener('message', (event) => {
        const { functionName, payload } = event.data;

        console.log(`[workers] web worker activated by function "${functionName}"`);

        try {
            const result = require("opendsu").loadAPI("workers").getFunctionsRegistry()[functionName](payload);
            postMessage({ result });
        } catch (error) {
            postMessage({ error });
        }
    });

    addEventListener('error', (event) => {
        const error = event.data;

        console.error("[workers] web worker error", error);
    });
}
},{"opendsu":"opendsu"}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/workers/functions.js":[function(require,module,exports){
function runSyncFunction({ apiSpaceName, functionName, params }) {
    const openDSU = require("opendsu");
    const api = openDSU.loadAPI(apiSpaceName);

    if (!api[functionName]) {
        throw Error(`function "${functionName}" does not exists in "${apiSpaceName}"!`)
    }

    return api[functionName].apply(undefined, params);
}

function runSyncFunctionOnlyFromWorker({ apiSpaceName, functionName, params }) {
    return runSyncFunction({ apiSpaceName, functionName, params })
}

module.exports = {
    runSyncFunction,
    runSyncFunctionOnlyFromWorker
}
},{"opendsu":"opendsu"}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/workers/index.js":[function(require,module,exports){
(function (global){(function (){
function getWebWorkerBootScript() {
    const scriptLocation = document.currentScript
        ? document.currentScript
        : new Error().stack.match(/([^ ^(\n])*([a-z]*:\/\/\/?)*?[a-z0-9\/\\]*\.js/gi)[0];
    return URL.createObjectURL(
        new Blob(
            [
                `
                (function () {
                    importScripts("${scriptLocation}");
                    (${require("./bootScript/web").toString()})();     
                })()
                `
            ],
            { type: "application/javascript" }
        )
    );
}

function getNodeWorkerBootScript() {
    const openDSUScriptPath = global.bundlePaths.openDSU.replace(/\\/g, "\\\\").replace(".js", "");
    return `
        require("${openDSUScriptPath}");
        (${require("./bootScript/node").toString()})();
    `;
}

function createPoolOfWebWorkers(options = {}) {
    if (!window.Worker) {
        return;
    }

    console.log("[workers] starting web worker...");

    const syndicate = require("syndicate");
    const blobURL = getWebWorkerBootScript();
    const workerPool = syndicate.createWorkerPool({
        bootScript: blobURL,
        workerStrategy: syndicate.WorkerStrategies.WEB_WORKERS,
        ...options
    });

    setTimeout(() => {
        // after usage, the blob must be removed in order to avoid memory leaks
        // it requires a timeout in order for syndicate to be able to get the blob script before it's removed
        URL.revokeObjectURL(blobURL);
    });

    return workerPool;
}

function createPoolOfNodeWorkers(options = {}) {
    const worker_threads = "worker_threads";
    const { isMainThread } = require(worker_threads);

    if (!isMainThread) {
        return;
    }

    console.log("[workers] starting node worker...");

    return require("syndicate").createWorkerPool({
        bootScript: getNodeWorkerBootScript(),
        workerOptions: { eval: true },
        ...options,
    });
}

function callbackForWorker(callback) {
    return (error, result) => {
        if (error) {
            return callback(error);
        }

        // this is quite a hack or workaround made for portability
        // in WebWorkers messages are transmitted through "Events" (event.data)
        // but in NodeWorkers messages are send as "Objects" (data)
        const {
            error: taskError,
            result: taskResult
        } = typeof Event !== "undefined" && result instanceof Event ? result.data : result;

        if (taskError) {
            return callback(taskError);
        }

        return callback(undefined, taskResult);
    }
}

function runTask(functionName, payload, callback) {
    // task is executed if there is a worker available
    const isExecuted = this.workerPool.runTaskImmediately({ functionName, payload }, callbackForWorker(callback));

    if (!isExecuted) {
        try {
            const result = require("opendsu").loadAPI("workers").getFunctionsRegistry()[functionName](payload);
            return callback(undefined, result);
        } catch (error) {
            return callback(error);
        }
    }
}

function addTask(functionName, payload, callback) {
    // task is queued if there is no worker available
    this.workerPool.addTask({ functionName, payload }, callbackForWorker(callback));
}


/**
 * Cross Environment wrapper over syndicate
 */
class CrossEnvironmentWorkerPool {
    constructor(options) {
        const { ENVIRONMENT_TYPES } = require("../moduleConstants.js");
        this.workerPool = undefined;
        this.environmentType = undefined;

        switch ($$.environmentType) {
            case ENVIRONMENT_TYPES.BROWSER_ENVIRONMENT_TYPE:
                this.workerPool = createPoolOfWebWorkers(options);
                this.environmentType = ENVIRONMENT_TYPES.BROWSER_ENVIRONMENT_TYPE;
                break;
            case ENVIRONMENT_TYPES.NODEJS_ENVIRONMENT_TYPE:
                this.workerPool = createPoolOfNodeWorkers(options);
                this.environmentType = ENVIRONMENT_TYPES.NODEJS_ENVIRONMENT_TYPE;
                break;
        }
    }

    runSyncFunction(apiSpaceName, functionName, ...params) {
        const currentFunctionName = "runSyncFunction";
        const callback = params.pop();
        const payload = { apiSpaceName, functionName, params };

        if (typeof callback !== 'function') {
            console.error(`[workers] function ${currentFunctionName} must receive a callback!`);
            return;
        }

        runTask.call(this, currentFunctionName, payload, callback);
    }

    runSyncFunctionOnlyByWorker(apiSpaceName, functionName, ...params) {
        const currentFunctionName = "runSyncFunctionOnlyFromWorker";
        const callback = params.pop();
        const payload = { apiSpaceName, functionName, params };

        if (typeof callback !== 'function') {
            console.error(`[workers] function ${currentFunctionName} must receive a callback!`);
            return;
        }

        addTask.call(this, "runSyncFunctionOnlyFromWorker", payload, callback);
    }

    get environment() {
        return this.environmentType;
    }
}

function createPool(options) {
    const pool = new CrossEnvironmentWorkerPool(options);
    return pool.environment ? pool : undefined;
}

function getFunctionsRegistry() {
    return require("./functions");
}

module.exports = {
    createPool,
    getFunctionsRegistry
}
}).call(this)}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../moduleConstants.js":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/moduleConstants.js","./bootScript/node":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/workers/bootScript/node.js","./bootScript/web":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/workers/bootScript/web.js","./functions":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/workers/functions.js","opendsu":"opendsu","syndicate":"syndicate"}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/overwrite-require/Logger.js":[function(require,module,exports){
const envTypes = require("./moduleConstants");
const originalConsole = Object.assign({}, console);
const IS_DEV_MODE = process.env.DEV === "true" || typeof process.env.DEV === "undefined";
if (typeof process.env.OPENDSU_ENABLE_DEBUG === "undefined") {
    process.env.OPENDSU_ENABLE_DEBUG = IS_DEV_MODE.toString();
}
const DEBUG_LOG_ENABLED = process.env.OPENDSU_ENABLE_DEBUG === "true";
if ($$.environmentType === envTypes.NODEJS_ENVIRONMENT_TYPE) {
    const logger = new Logger("Logger", "overwrite-require");
    if (DEBUG_LOG_ENABLED) {
        logger.log = logger.debug;
    } else {
        logger.log = () => {
        }
    }
    Object.assign(console, logger);
} else {
    $$.memoryLogger = new MemoryFileMock();
    const logger = new Logger("Logger", "overwrite-require", $$.memoryLogger);
    Object.assign(console, logger);
}

function MemoryFileMock() {
    let arr = [];
    this.append = (logLine) => {
        arr.push(logLine);
    }
    this.dump = () => {
        return JSON.stringify(arr);
    }
}

function Logger(className, moduleName, logFile) {
    const MAX_STRING_LENGTH = 11;
    const getPaddingForArg = (arg, maxLen = MAX_STRING_LENGTH) => {
        let noSpaces = Math.abs(maxLen - arg.length);
        let spaces = String(" ").repeat(noSpaces);
        return spaces;
    };

    const convertIntToHexString = (number) => {
        let hexString = number.toString("16");
        if (hexString.length === 1) {
            hexString = "0" + hexString;
        }
        return "0x" + hexString;
    }

    const normalizeArg = (arg) => {
        if (arg.length >= MAX_STRING_LENGTH) {
            return arg.substring(0, MAX_STRING_LENGTH);
        } else {
            return `${arg}${getPaddingForArg(arg)}`;
        }
    }

    const getLogMessage = (data) => {
        let msg;
        try {
            if (typeof data === "object") {
                msg = JSON.stringify(data) + " ";
            } else {
                msg = data + " "
            }
        } catch (e) {
            msg = e.message + " ";
        }
        return msg;
    }
    const createLogObject = (functionName, code = 0, ...args) => {
        let message = "";
        for (let i = 0; i < args.length; i++) {
            message += getLogMessage(args[i]);
        }

        message = message.trimEnd();
        const logObject = {
            severity: functionName.toUpperCase(),
            timestamp: new Date().toISOString(),
            eventTypeId: convertIntToHexString(code),
            component: moduleName,
            className: className,
            message
        }
        return logObject;
    }

    const getLogStringFromObject = (logObject, appendEOL = false) => {
        let logString;
        if (IS_DEV_MODE) {
            logObject.message = logObject.message.replaceAll("\n", "\n\t");
            logString = `${logObject.severity}${getPaddingForArg(logObject.severity, 9)}${logObject.eventTypeId}${getPaddingForArg(logObject.eventTypeId, 3)} ${logObject.timestamp}`;

            if (typeof logObject.component !== "undefined") {
                logString = `${logString} ${normalizeArg(logObject.component)}`;
            }
            if (typeof logObject.className !== "undefined") {
                logString = `${logString} ${normalizeArg(logObject.className)}`;
            }

            logString = `${logString} ${logObject.message}`;

            if (appendEOL) {
                logString += require("os").EOL;
            }
        } else {
            logObject.message = logObject.message.replaceAll("\n", "\\n");
            logObject.message = logObject.message.replaceAll("\r", "\\r");
            logString = JSON.stringify(logObject);
        }
        return logString;
    }

    const getLogAsString = (functionName, appendEOL = false, ...args) => {
        const res = stripCodeFromArgs(...args);
        let logObject = createLogObject(functionName, res.code, ...res.args);
        let logString = getLogStringFromObject(logObject, appendEOL);
        return logString;
    }

    const stripCodeFromArgs = (...args) => {
        let code = args[0];
        if (typeof code !== "number" || args.length === 1) {
            code = 0;
        } else {
            args.shift();
        }

        return {
            code,
            args
        }
    }

    const getConsoleFunction = (functionName) => {
        if (functionName === functions.CRITICAL) {
            functionName = functions.ERROR;
        }

        if (functionName === functions.AUDIT) {
            functionName = functions.LOG;
        }

        return functionName;
    }

    const executeFunctionFromConsole = (functionName, ...args) => {
        if ($$.memoryLogger) {
            originalConsole[getConsoleFunction(functionName)](...args);
        } else {
            const log = getLogAsString(functionName, false, ...args);
            originalConsole[getConsoleFunction(functionName)](log);
        }
    }

    const writeToFile = (functionName, ...args) => {
        const fs = require("fs");
        const path = require("path");
        if (typeof logFile === "undefined") {
            return;
        }

        let log = getLogAsString(functionName, true, ...args);
        if (logFile instanceof MemoryFileMock) {
            logFile.append(log);
            return;
        }
        try {
            fs.accessSync(path.dirname(logFile));
        } catch (e) {
            fs.mkdirSync(path.dirname(logFile), {recursive: true});
        }

        fs.appendFileSync(logFile, log);
    }

    const printToConsoleAndFile = (functionName, ...args) => {
        executeFunctionFromConsole(functionName, ...args);
        writeToFile(functionName, ...args);
    }

    const functions = {
        LOG: "log",
        INFO: "info",
        WARN: "warn",
        TRACE: "trace",
        DEBUG: "debug",
        ERROR: "error",
        CRITICAL: "critical",
        AUDIT: "audit"
    }

    for (let fnName in functions) {
        this[functions[fnName]] = (...args) => {
            printToConsoleAndFile(functions[fnName], ...args);
        }
    }

    if (!DEBUG_LOG_ENABLED) {
        this[functions.TRACE] = this[functions.DEBUG] = () => {
        };
    }
}

const getLogger = (className, moduleName, criticalLogFile) => {
    return new Logger(className, moduleName, criticalLogFile);
}

module.exports = {
    getLogger
}

},{"./moduleConstants":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/overwrite-require/moduleConstants.js","fs":false,"os":false,"path":false}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/overwrite-require/moduleConstants.js":[function(require,module,exports){
module.exports = {
  BROWSER_ENVIRONMENT_TYPE: 'browser',
  MOBILE_BROWSER_ENVIRONMENT_TYPE: 'mobile-browser',
  WEB_WORKER_ENVIRONMENT_TYPE: 'web-worker',
  SERVICE_WORKER_ENVIRONMENT_TYPE: 'service-worker',
  ISOLATE_ENVIRONMENT_TYPE: 'isolate',
  THREAD_ENVIRONMENT_TYPE: 'thread',
  NODEJS_ENVIRONMENT_TYPE: 'nodejs'
};

},{}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/overwrite-require/standardGlobalSymbols.js":[function(require,module,exports){
(function (global){(function (){
let logger = console;

if(typeof $$.Buffer === "undefined"){
    $$.Buffer = require("buffer").Buffer;
}

if (typeof global.$$.uidGenerator == "undefined") {
    $$.uidGenerator = {};
    $$.uidGenerator.safe_uuid = require("swarmutils").safe_uuid;
}

if (!global.process || process.env.NO_LOGS !== 'true') {
    try {
        const zmqName = "zeromq";
        require(zmqName);
        const PSKLoggerModule = require('psklogger');
        const PSKLogger = PSKLoggerModule.PSKLogger;

        logger = PSKLogger.getLogger();

        console.log('Logger init successful', process.pid);
    } catch (e) {
        if(e.message.indexOf("psklogger")!==-1 || e.message.indexOf("zeromq")!==-1){
            console.log('Logger not available, using console');
            logger = console;
        }else{
            console.log(e);
        }
    }
} else {
    console.log('Environment flag NO_LOGS is set, logging to console');
}

$$.registerGlobalSymbol = function (newSymbol, value) {
    if (typeof $$[newSymbol] == "undefined") {
        Object.defineProperty($$, newSymbol, {
            value: value,
            writable: false
        });
    } else {
        logger.error("Refusing to overwrite $$." + newSymbol);
    }
};

console.warn = (...args)=>{
    console.log(...args);
};

/**
 * @method
 * @name $$#autoThrow
 * @param {Error} err
 * @throws {Error}
 */

$$.registerGlobalSymbol("autoThrow", function (err) {
    if (!err) {
        throw err;
    }
});

/**
 * @method
 * @name $$#propagateError
 * @param {Error} err
 * @param {function} callback
 */
$$.registerGlobalSymbol("propagateError", function (err, callback) {
    if (err) {
        callback(err);
        throw err; //stop execution
    }
});

/**
 * @method
 * @name $$#logError
 * @param {Error} err
 */
$$.registerGlobalSymbol("logError", function (err) {
    if (err) {
        console.log(err);
        $$.err(err);
    }
});

/**
 * @method
 * @name $$#fixMe
 * @param {...*} args
 */

$$.registerGlobalSymbol("fixMe", function (...args) {
    console.log("Fix this:", ...args);
});

/**
 * @method - Throws an error
 * @name $$#exception
 * @param {string} message
 * @param {*} type
 */
$$.registerGlobalSymbol("exception", function (message, type) {
    throw new Error(message);
});

/**
 * @method - Throws an error
 * @name $$#throw
 * @param {string} message
 * @param {*} type
 */
$$.registerGlobalSymbol("throw", function (message, type) {
    throw new Error(message);
});


/**
 * @method - Warns that method is not implemented
 * @name $$#incomplete
 * @param {...*} args
 */
/* signal a  planned feature but not implemented yet (during development) but
also it could remain in production and should be flagged asap*/
$$.incomplete = function (...args) {
    args.unshift("Incomplete feature touched:");
    logger.warn(...args);
};

/**
 * @method - Warns that method is not implemented
 * @name $$#notImplemented
 * @param {...*} args
 */
$$.notImplemented = $$.incomplete;


/**
 * @method Throws if value is false
 * @name $$#assert
 * @param {boolean} value - Value to assert against
 * @param {string} explainWhy - Reason why assert failed (why value is false)
 */
/* used during development and when trying to discover elusive errors*/
$$.registerGlobalSymbol("assert", function (value, explainWhy) {
    if (!value) {
        throw new Error("Assert false " + explainWhy);
    }
});

/**
 * @method
 * @name $$#flags
 * @param {string} flagName
 * @param {*} value
 */
/* enable/disabale flags that control psk behaviour*/
$$.registerGlobalSymbol("flags", function (flagName, value) {
    $$.incomplete("flags handling not implemented");
});

/**
 * @method - Warns that a method is obsolete
 * @name $$#obsolete
 * @param {...*} args
 */
$$.registerGlobalSymbol("obsolete", function (...args) {
    args.unshift("Obsolete feature:");
    logger.log(...args);
    console.log(...args);
});

/**
 * @method - Uses the logger to log a message of level "log"
 * @name $$#log
 * @param {...*} args
 */
$$.registerGlobalSymbol("log", function (...args) {
    args.unshift("Log:");
    logger.log(...args);
});

/**
 * @method - Uses the logger to log a message of level "info"
 * @name $$#info
 * @param {...*} args
 */
$$.registerGlobalSymbol("info", function (...args) {
    args.unshift("Info:");
    logger.log(...args);
    console.log(...args);
});

/**
 * @method - Uses the logger to log a message of level "error"
 * @name $$#err
 * @param {...*} args
 */
$$.registerGlobalSymbol("err", function (...args) {
    args.unshift("Error:");
    logger.error(...args);
    console.error(...args);
});

/**
 * @method - Uses the logger to log a message of level "error"
 * @name $$#err
 * @param {...*} args
 */
$$.registerGlobalSymbol("error", function (...args) {
    args.unshift("Error:");
    logger.error(...args);
    console.error(...args);
});

/**
 * @method - Uses the logger to log a message of level "warning"
 * @name $$#warn
 * @param {...*} args
 */
$$.registerGlobalSymbol("warn", function (...args) {
    args.unshift("Warn:");
    logger.warn(...args);
    console.log(...args);
});

/**
 * @method - Uses the logger to log a message of level "syntexError"
 * @name $$#syntexError
 * @param {...*} args
 */
$$.registerGlobalSymbol("syntaxError", function (...args) {
    args.unshift("Syntax error:");
    logger.error(...args);
    try{
        throw new Error("Syntax error or misspelled symbol!");
    }catch(err){
        console.error(...args);
        console.error(err.stack);
    }

});

/**
 * @method - Logs an invalid member name for a swarm
 * @name $$#invalidMemberName
 * @param {string} name
 * @param {Object} swarm
 */
$$.invalidMemberName = function (name, swarm) {
    let swarmName = "unknown";
    if (swarm && swarm.meta) {
        swarmName = swarm.meta.swarmTypeName;
    }
    const text = "Invalid member name " + name + "in swarm " + swarmName;
    console.error(text);
    logger.err(text);
};

/**
 * @method - Logs an invalid swarm name
 * @name $$#invalidSwarmName
 * @param {string} name
 * @param {Object} swarm
 */
$$.registerGlobalSymbol("invalidSwarmName", function (swarmName) {
    const text = "Invalid swarm name " + swarmName;
    console.error(text);
    logger.err(text);
});

/**
 * @method - Logs unknown exceptions
 * @name $$#unknownException
 * @param {...*} args
 */
$$.registerGlobalSymbol("unknownException", function (...args) {
    args.unshift("unknownException:");
    logger.err(...args);
    console.error(...args);
});

/**
 * @method - PrivateSky event, used by monitoring and statistics
 * @name $$#event
 * @param {string} event
 * @param {...*} args
 */
$$.registerGlobalSymbol("event", function (event, ...args) {
    if (logger.hasOwnProperty('event')) {
        logger.event(event, ...args);
    } else {
        if(event === "status.domains.boot"){
            console.log("Failing to console...", event, ...args);
        }
    }
});

/**
 * @method -
 * @name $$#redirectLog
 * @param {string} event
 * @param {...*} args
 */
$$.registerGlobalSymbol("redirectLog", function (logType, logObject) {
    if(logger.hasOwnProperty('redirect')) {
        logger.redirect(logType, logObject);
    }
});

/**
 * @method - log throttling event // it is just an event?
 * @name $$#throttlingEvent
 * @param {...*} args
 */
$$.registerGlobalSymbol("throttlingEvent", function (...args) {
    logger.log(...args);
});

}).call(this)}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"buffer":false,"psklogger":false,"swarmutils":"swarmutils"}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/psk-cache/lib/Cache.js":[function(require,module,exports){
const DEFAULT_ITEMS_LIMIT = 1000;
const DEFAULT_STORAGE_LEVELS = 3;

/**
 * @param {object} options
 * @param {Number} options.maxLevels Number of storage levels. Defaults to 3
 * @param {Number} options.limit Number of max items the cache can store per level.
 *                               Defaults to 1000
 */
function Cache(options) {
    options = options || {};
    this.limit = parseInt(options.limit, 10) || DEFAULT_ITEMS_LIMIT;
    this.maxLevels = parseInt(options.maxLevels, 10) || DEFAULT_STORAGE_LEVELS;
    this.storage = null;

    if (this.limit < 0) {
        throw new Error('Limit must be a positive number');
    }
    if (this.maxLevels < 1) {
        throw new Error('Cache needs at least one storage level');
    }


    /**
     * Create an array of Map objects for storing items
     *
     * @param {Number} maxLevels
     * @return {Array.<Map>}
     */
    this.createStorage = function (maxLevels) {
        const storage = [];
        for (let i = 0; i < maxLevels; i++) {
            storage.push(new Map());
        }

        return storage;
    }

    this.storage = this.createStorage(this.maxLevels);

    this.resetCache = ()=>{
        this.storage = this.createStorage(this.maxLevels);
    }

    /**
     * @param {*} key
     * @param {*} value
     */
    this.set = function (key, value) {
        if (this.cacheIsFull()) {
            this.makeRoom();
        }

        this.storage[0].set(key, value);
    }

    /**
     * @param {*} key
     * @return {Boolean}
     */
    this.has = function (key) {
        for (let i = 0; i < this.storage.length; i++) {
            if (this.storage[i].has(key)) {
                return true;
            }
        }

        return false;
    }

    /**
     * @param {*} key
     * @return {*}
     */
    this.get = function (key) {
        if (this.storage[0].has(key)) {
            return this.storage[0].get(key);
        }

        return this.getFromLowerLevels(key);
    }

    /**
     * Get an item from the lower levels.
     * If one is found added it to the first level as well
     *
     * @param {*} key
     * @return {*}
     */
    this.getFromLowerLevels = function (key) {
        for (let i = 1; i < this.storage.length; i++) {
            const storageLevel = this.storage[i];
            if (!storageLevel.has(key)) {
                continue;
            }
            const value = storageLevel.get(key);
            this.set(key, value);
            return value;
        }
    }

    /**
     * @return {Boolean}
     */
    this.cacheIsFull = function () {
        return this.storage[0].size >= this.limit;
    }

    /**
     * Move all the items down by one level
     * and clear the first one to make room for new items
     */
    this.makeRoom = function () {
        for (let i = this.storage.length - 1; i > 0; i--) {
            this.storage[i] = this.storage[i - 1];
        }
        this.storage[0] = new Map();
    }
}

module.exports = Cache;

},{}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/psk-http-client/index.js":[function(require,module,exports){
//to look nice the requireModule on Node
require("./lib/psk-abstract-client");
const or = require('overwrite-require');
if ($$.environmentType === or.constants.BROWSER_ENVIRONMENT_TYPE) {
	require("./lib/psk-browser-client");
} else {
	require("./lib/psk-node-client");
}
},{"./lib/psk-abstract-client":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/psk-http-client/lib/psk-abstract-client.js","./lib/psk-browser-client":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/psk-http-client/lib/psk-browser-client.js","./lib/psk-node-client":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/psk-http-client/lib/psk-node-client.js","overwrite-require":"overwrite-require"}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/psk-http-client/lib/psk-abstract-client.js":[function(require,module,exports){
/**********************  utility class **********************************/
function RequestManager(pollingTimeOut) {
    if (!pollingTimeOut) {
        pollingTimeOut = 1000; //1 second by default
    }

    const self = this;

    function Request(endPoint, initialSwarm, delayedStart) {
        let onReturnCallbacks = [];
        let onErrorCallbacks = [];
        let onCallbacks = [];
        const requestId = initialSwarm ? initialSwarm.meta.requestId : "weneedarequestid";
        initialSwarm = null;

        this.getRequestId = function () {
            return requestId;
        };

        this.on = function (phaseName, callback) {
            if (typeof phaseName != "string" && typeof callback != "function") {
                throw new Error("The first parameter should be a string and the second parameter should be a function");
            }

            onCallbacks.push({
                callback: callback,
                phase: phaseName
            });

            if (typeof delayedStart === "undefined") {
                self.poll(endPoint, this);
            }

            return this;
        };

        this.onReturn = function (callback) {
            onReturnCallbacks.push(callback);
            if (typeof delayedStart === "undefined") {
                self.poll(endPoint, this);
            }
            return this;
        };

        this.onError = function (callback) {
            if (onErrorCallbacks.indexOf(callback) !== -1) {
                onErrorCallbacks.push(callback);
            } else {
                console.log("Error callback already registered!");
            }
        };

        this.start = function () {
            if (typeof delayedStart !== "undefined") {
                self.poll(endPoint, this);
            }
        };

        this.dispatch = function (err, result) {
            if (result instanceof ArrayBuffer) {
                result = SwarmPacker.unpack(result);
            }

            result = typeof result === "string" ? JSON.parse(result) : result;

            result = OwM.prototype.convert(result);
            const resultReqId = result.getMeta("requestId");
            const phaseName = result.getMeta("phaseName");
            let onReturn = false;

            if (resultReqId === requestId) {
                onReturnCallbacks.forEach(function (c) {
                    c(null, result);
                    onReturn = true;
                });
                if (onReturn) {
                    onReturnCallbacks = [];
                    onErrorCallbacks = [];
                }

                onCallbacks.forEach(function (i) {
                    //console.log("XXXXXXXX:", phaseName , i);
                    if (phaseName === i.phase || i.phase === '*') {
                        i.callback(err, result);
                    }
                });
            }

            if (onReturnCallbacks.length === 0 && onCallbacks.length === 0) {
                self.unpoll(endPoint, this);
            }
        };

        this.dispatchError = function (err) {
            for (let i = 0; i < onErrorCallbacks.length; i++) {
                const errCb = onErrorCallbacks[i];
                errCb(err);
            }
        };

        this.off = function () {
            self.unpoll(endPoint, this);
        };
    }

    this.createRequest = function (remoteEndPoint, swarm, delayedStart) {
        return new Request(remoteEndPoint, swarm, delayedStart);
    };

    /* *************************** polling zone ****************************/

    const pollSet = {};

    const activeConnections = {};

    this.poll = function (remoteEndPoint, request) {
        let requests = pollSet[remoteEndPoint];
        if (!requests) {
            requests = {};
            pollSet[remoteEndPoint] = requests;
        }
        requests[request.getRequestId()] = request;
        pollingHandler();
    };

    this.unpoll = function (remoteEndPoint, request) {
        const requests = pollSet[remoteEndPoint];
        if (requests) {
            delete requests[request.getRequestId()];
            if (Object.keys(requests).length === 0) {
                delete pollSet[remoteEndPoint];
            }
        } else {
            console.log("Unpolling wrong request:", remoteEndPoint, request);
        }
    };

    function createPollThread(remoteEndPoint) {
        function reArm() {
            $$.remote.doHttpGet(remoteEndPoint, function (err, res) {
                let requests = pollSet[remoteEndPoint];
                if (err) {
                    for (const req_id in requests) {
                        if (!requests.hasOwnProperty(req_id)) {
                            return;
                        }

                        let err_handler = requests[req_id].dispatchError;
                        if (err_handler) {
                            err_handler(err);
                        }
                    }
                    activeConnections[remoteEndPoint] = false;
                } else {

                    for (const k in requests) {
                        if (!requests.hasOwnProperty(k)) {
                            return;
                        }

                        requests[k].dispatch(null, res);
                    }

                    if (Object.keys(requests).length !== 0) {
                        reArm();
                    } else {
                        delete activeConnections[remoteEndPoint];
                        console.log("Ending polling for ", remoteEndPoint);
                    }
                }
            });
        }

        reArm();
    }

    function pollingHandler() {
        let setTimer = false;
        for (const remoteEndPoint in pollSet) {
            if (!pollSet.hasOwnProperty(remoteEndPoint)) {
                return;
            }

            if (!activeConnections[remoteEndPoint]) {
                createPollThread(remoteEndPoint);
                activeConnections[remoteEndPoint] = true;
            }
            setTimer = true;
        }
        if (setTimer) {
            setTimeout(pollingHandler, pollingTimeOut);
        }
    }

    setTimeout(pollingHandler, pollingTimeOut);
}

function urlEndWithSlash(url) {
    if (url[url.length - 1] !== "/") {
        url += "/";
    }
    return url;
}

/********************** main APIs on working with virtualMQ channels **********************************/
function HttpChannelClient(remoteEndPoint, channelName, options) {

    let clientType;
    const opts = {
        autoCreate: true,
        publicSignature: "no_signature_provided"
    };

    Object.keys(options).forEach((optName) => {
        opts[optName] = options[optName];
    });

    let channelCreated = false;
    function readyToBeUsed(){
        let res = false;

        if(clientType === HttpChannelClient.prototype.PRODUCER_CLIENT_TYPE){
            res = true;
        }
        if(clientType === HttpChannelClient.prototype.CONSUMER_CLIENT_TYPE){
            if(!options.autoCreate){
                res = true;
            }else{
                res = channelCreated;
            }
        }

        return res;
    }

    function encryptChannelName(channelName) {
        return $$.remote.base64Encode(channelName);
    }

    function CatchAll(swarmName, phaseName, callback) { //same interface as Request
        const requestId = requestsCounter++;
        this.getRequestId = function () {
            return "swarmName" + "phaseName" + requestId;
        };

        this.dispatch = function (err, result) {
            /*result = OwM.prototype.convert(result);
            const currentPhaseName = result.getMeta("phaseName");
            const currentSwarmName = result.getMeta("swarmTypeName");
            if ((currentSwarmName === swarmName || swarmName === '*') && (currentPhaseName === phaseName || phaseName === '*')) {
                return callback(err, result);
            }*/
            return callback(err, result);
        };
    }

    this.setSenderMode = function () {
        if (typeof clientType !== "undefined") {
            throw new Error(`HttpChannelClient is set as ${clientType}`);
        }
        clientType = HttpChannelClient.prototype.PRODUCER_CLIENT_TYPE;

        this.sendSwarm = function (swarmSerialization) {
            $$.remote.doHttpPost(getRemoteToSendMessage(remoteEndPoint, channelName), swarmSerialization, (err, res)=>{
                if(err){
                    console.log("Sending swarm failed", err);
                }else{
                    console.log("Swarm sent");
                }
            });
        };
    };

    this.setReceiverMode = function () {
        if (typeof clientType !== "undefined") {
            throw new Error(`HttpChannelClient is set as ${clientType}`);
        }
        clientType = HttpChannelClient.prototype.CONSUMER_CLIENT_TYPE;

        function createChannel(callback){
            if (!readyToBeUsed()) {
                $$.remote.doHttpPut(getRemoteToCreateChannel(), opts.publicSignature, (err) => {
                    if (err) {
                        if (err.statusCode !== 409) {
                            return callback(err);
                        }
                    }
                    channelCreated = true;
                    if(opts.enableForward){
                        console.log("Enabling forward");
                        $$.remote.doHttpPost(getUrlToEnableForward(), opts.publicSignature, (err, res)=>{
                            if(err){
                                console.log("Request to enable forward to zeromq failed", err);
                            }
                        });
                    }
                    return callback();
                });
            }
        }

        this.getReceiveAddress = function(){
            return getRemoteToSendMessage();
        };

        this.on = function (swarmId, swarmName, phaseName, callback) {
            const c = new CatchAll(swarmName, phaseName, callback);
            allCatchAlls.push({
                s: swarmName,
                p: phaseName,
                c: c
            });

           /* if (!readyToBeUsed()) {
                createChannel((err)=>{
                    $$.remote.requestManager.poll(getRemoteToReceiveMessage(), c);
                });
            } else {*/
                $$.remote.requestManager.poll(getRemoteToReceiveMessage(), c);
            /*}*/
        };

        this.off = function (swarmName, phaseName) {
            allCatchAlls.forEach(function (ca) {
                if ((ca.s === swarmName || swarmName === '*') && (phaseName === ca.p || phaseName === '*')) {
                    $$.remote.requestManager.unpoll(getRemoteToReceiveMessage(remoteEndPoint, domainInfo.domain), ca.c);
                }
            });
        };

        createChannel((err) => {
            if(err){
                console.log(err);
            }
        });

        $$.remote.createRequestManager();
    };

    const allCatchAlls = [];
    let requestsCounter = 0;

    this.uploadCSB = function (cryptoUid, binaryData, callback) {
        $$.remote.doHttpPost(baseOfRemoteEndPoint + "/CSB/" + cryptoUid, binaryData, callback);
    };

    this.downloadCSB = function (cryptoUid, callback) {
        $$.remote.doHttpGet(baseOfRemoteEndPoint + "/CSB/" + cryptoUid, callback);
    };

    function getRemoteToReceiveMessage() {
        return [urlEndWithSlash(remoteEndPoint), urlEndWithSlash(HttpChannelClient.prototype.RECEIVE_API_NAME), urlEndWithSlash(encryptChannelName(channelName))].join("");
    }

    function getRemoteToSendMessage() {
        return [urlEndWithSlash(remoteEndPoint), urlEndWithSlash(HttpChannelClient.prototype.SEND_API_NAME), urlEndWithSlash(encryptChannelName(channelName))].join("");
    }

    function getRemoteToCreateChannel() {
        return [urlEndWithSlash(remoteEndPoint), urlEndWithSlash(HttpChannelClient.prototype.CREATE_CHANNEL_API_NAME), urlEndWithSlash(encryptChannelName(channelName))].join("");
    }

    function getUrlToEnableForward() {
        return [urlEndWithSlash(remoteEndPoint), urlEndWithSlash(HttpChannelClient.prototype.FORWARD_CHANNEL_API_NAME), urlEndWithSlash(encryptChannelName(channelName))].join("");
    }
}

/********************** constants **********************************/
HttpChannelClient.prototype.RECEIVE_API_NAME = "receive-message";
HttpChannelClient.prototype.SEND_API_NAME = "send-message";
HttpChannelClient.prototype.CREATE_CHANNEL_API_NAME = "create-channel";
HttpChannelClient.prototype.FORWARD_CHANNEL_API_NAME = "forward-zeromq";
HttpChannelClient.prototype.PRODUCER_CLIENT_TYPE = "producer";
HttpChannelClient.prototype.CONSUMER_CLIENT_TYPE = "consumer";

/********************** initialisation stuff **********************************/
if (typeof $$ === "undefined") {
    $$ = {};
}

if (typeof $$.remote === "undefined") {
    $$.remote = {};

    function createRequestManager(timeOut) {
        const newRequestManager = new RequestManager(timeOut);
        Object.defineProperty($$.remote, "requestManager", {value: newRequestManager});
    }

    function registerHttpChannelClient(alias, remoteEndPoint, channelName, options) {
        $$.remote[alias] = new HttpChannelClient(remoteEndPoint, channelName, options);
    }

    Object.defineProperty($$.remote, "createRequestManager", {value: createRequestManager});
    Object.defineProperty($$.remote, "registerHttpChannelClient", {value: registerHttpChannelClient});

    $$.remote.doHttpPost = function (url, data, callback) {
        throw new Error("Overwrite this!");
    };

    $$.remote.doHttpPut = function (url, data, callback) {
        throw new Error("Overwrite this!");
    };

    $$.remote.doHttpGet = function doHttpGet(url, callback) {
        throw new Error("Overwrite this!");
    };

    $$.remote.base64Encode = function base64Encode(stringToEncode) {
        throw new Error("Overwrite this!");
    };

    $$.remote.base64Decode = function base64Decode(encodedString) {
        throw new Error("Overwrite this!");
    };
}


//new implementation in order to expose as much as possible APIHUB services
$$.apihub = {connections:{}};
$$.apihub.createConnection = function(alias, url, ssi){

    $$.apihub.connections[alias] = {
        //mq apis
        createMQ: function(queueName, callback){

        },
        sendMessageToQueue: function(queueName, message, callback){

        },
        receiveMessageFromQueue: function(queueName, callback){
            // integrate request manager from above in order to have long pooling mechanism enabled
        },

        //notifications apis
        subscribe: function(topic, callback){
            // integrate request manager from above in order to have long pooling mechanism enabled
        },

        unsubscribe: function(topic, callback){

        },

        publish: function(topic, message, callback){

        },

        //authentication apis
        getAuthToken: function(expiration, callback){

        },

        setQuota: function(quota, targetSSI, callback){

        },

        setTagPolicy: function(tag, requireAuthToken, callback){

        },

        addUserInTag: function(targetSSI, callback){

        },

        addAdmin: function(targetSSI, callback){

        },

        removeAdmin: function(callback){

        }

    }

    return $$.apihub.connections[alias];
}

},{}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/psk-http-client/lib/psk-browser-client.js":[function(require,module,exports){
function generateMethodForRequestWithData(httpMethod) {
    return function (url, data, callback) {
        const xhr = new XMLHttpRequest();

        xhr.onload = function () {
            if (xhr.readyState === 4 && (xhr.status >= 200 && xhr.status < 300)) {
                const data = xhr.response;
                callback(undefined, data);
            } else {
                if(xhr.status>=400){
                    const error = new Error("An error occured. StatusCode: " + xhr.status);
                    callback({error: error, statusCode: xhr.status});
                } else {
                    console.log(`Status code ${xhr.status} received, response is ignored.`);
                }
            }
        };

        xhr.onerror = function (e) {
            callback(new Error("A network error occurred"));
        };

        xhr.open(httpMethod, url, true);
        //xhr.setRequestHeader("Content-Type", "application/json;charset=UTF-8");

        if(data && data.pipe && typeof data.pipe === "function"){
            const buffers = [];
            data.on("data", function(data) {
                buffers.push(data);
            });
            data.on("end", function() {
                const actualContents = $$.Buffer.concat(buffers);
                xhr.send(actualContents);
            });
        }
        else {
            if(data instanceof ArrayBuffer){
                data = new DataView(data);
            }

            if(ArrayBuffer.isView(data)) {
                xhr.setRequestHeader('Content-Type', 'application/octet-stream');

                /**
                 * Content-Length is an unsafe header and we cannot set it.
                 * When browser is making a request that is intercepted by a service worker,
                 * the Content-Length header is not set implicitly.
                 */
                xhr.setRequestHeader('X-Content-Length', data.byteLength);
            }
            xhr.send(data);
        }
    };
}


$$.remote.doHttpPost = generateMethodForRequestWithData('POST');

$$.remote.doHttpPut = generateMethodForRequestWithData('PUT');


$$.remote.doHttpGet = function doHttpGet(url, callback) {

    var xhr = new XMLHttpRequest();

    xhr.onreadystatechange = function () {
        //check if headers were received and if any action should be performed before receiving data
        if (xhr.readyState === 2) {
            var contentType = xhr.getResponseHeader("Content-Type");
            if (contentType === "application/octet-stream") {
                xhr.responseType = 'arraybuffer';
            }
        }
    };

    xhr.onload = function () {
        if (xhr.readyState === 4 && xhr.status == "200") {
            var contentType = xhr.getResponseHeader("Content-Type");
            if (contentType === "application/octet-stream") {
                let responseBuffer = this.response;

                let buffer = new $$.Buffer(responseBuffer.byteLength);
                let view = new Uint8Array(responseBuffer);
                for (let i = 0; i < buffer.length; ++i) {
                    buffer[i] = view[i];
                }
                callback(undefined, buffer);
            }
            else{
                callback(undefined, xhr.response);
            }
        } else {
            const error = new Error("An error occurred. StatusCode: " + xhr.status);

            callback({error: error, statusCode: xhr.status});
        }
    };
    xhr.onerror = function (e) {
        callback(new Error("A network error occurred"));
    };

    xhr.open("GET", url);
    xhr.send();
};


function CryptoProvider(){

    this.generateSafeUid = function(){
        let uid = "";
        var array = new Uint32Array(10);
        window.crypto.getRandomValues(array);


        for (var i = 0; i < array.length; i++) {
            uid += array[i].toString(16);
        }

        return uid;
    };

    this.signSwarm = function(swarm, agent){
        swarm.meta.signature = agent;
    };
}



$$.remote.cryptoProvider = new CryptoProvider();

$$.remote.base64Encode = function base64Encode(stringToEncode){
    return window.btoa(stringToEncode);
};

$$.remote.base64Decode = function base64Decode(encodedString){
    return window.atob(encodedString);
};

},{}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/psk-http-client/lib/psk-node-client.js":[function(require,module,exports){
require("./psk-abstract-client");

const http = require("http");
const https = require("https");
const URL = require("url");
const userAgent = 'PSK NodeAgent/0.0.1';
const signatureHeaderName = process.env.vmq_signature_header_name || "x-signature";


console.log("PSK node client loading");

function getNetworkForOptions(options) {
	if(options.protocol === 'http:') {
		return http;
	} else if(options.protocol === 'https:') {
		return https;
	} else {
		throw new Error(`Can't handle protocol ${options.protocol}`);
	}

}

function generateMethodForRequestWithData(httpMethod) {
	return function (url, data, callback) {
		const innerUrl = URL.parse(url);

		const options = {
			hostname: innerUrl.hostname,
			path: innerUrl.pathname,
			port: parseInt(innerUrl.port),
			headers: {
				'User-Agent': userAgent,
				[signatureHeaderName]: 'replaceThisPlaceholderSignature'
			},
			method: httpMethod
		};

		const network = getNetworkForOptions(innerUrl);

		if (ArrayBuffer.isView(data) || $$.Buffer.isBuffer(data) || data instanceof ArrayBuffer) {
			if (!$$.Buffer.isBuffer(data)) {
				data = $$.Buffer.from(data);
			}

			options.headers['Content-Type'] = 'application/octet-stream';
			options.headers['Content-Length'] = data.length;
		}

		const req = network.request(options, (res) => {
			const {statusCode} = res;

			let error;
			if (statusCode >= 400) {
				error = new Error('Request Failed.\n' +
					`Status Code: ${statusCode}\n` +
					`URL: ${options.hostname}:${options.port}${options.path}`);
			}

			if (error) {
				callback({error: error, statusCode: statusCode});
				// free up memory
				res.resume();
				return;
			}

			let rawData = '';
			res.on('data', (chunk) => {
				rawData += chunk;
			});
			res.on('end', () => {
				try {
					callback(undefined, rawData, res.headers);
				} catch (err) {
                    console.error(err);
				}finally {
					//trying to prevent getting ECONNRESET error after getting our response
					req.abort();
				}
			});
		}).on("error", (error) => {
			console.log(`[POST] ${url}`, error);
			callback(error);
		});

		if (data && data.pipe && typeof data.pipe === "function") {
			data.pipe(req);
			return;
		}

		if (typeof data !== 'string' && !$$.Buffer.isBuffer(data) && !ArrayBuffer.isView(data)) {
			data = JSON.stringify(data);
		}

		req.write(data);
		req.end();
	};
}

$$.remote.doHttpPost = generateMethodForRequestWithData('POST');

$$.remote.doHttpPut = generateMethodForRequestWithData('PUT');

$$.remote.doHttpGet = function doHttpGet(url, callback){
    const innerUrl = URL.parse(url);

	const options = {
		hostname: innerUrl.hostname,
		path: innerUrl.pathname + (innerUrl.search || ''),
		port: parseInt(innerUrl.port),
		headers: {
			'User-Agent': userAgent,
            [signatureHeaderName]: 'someSignature'
		},
		method: 'GET'
	};

	const network = getNetworkForOptions(innerUrl);
	const req = network.request(options, (res) => {
		const { statusCode } = res;

		let error;
		if (statusCode !== 200) {
			error = new Error('Request Failed.\n' +
				`Status Code: ${statusCode}`);
			error.code = statusCode;
		}

		if (error) {
			callback({error:error, statusCode:statusCode});
			// free up memory
			res.resume();
			return
		}

		let rawData;
		const contentType = res.headers['content-type'];

		if(contentType === "application/octet-stream"){
			rawData = [];
		}else{
			rawData = '';
		}

		res.on('data', (chunk) => {
			if(Array.isArray(rawData)){
				rawData.push(...chunk);
			}else{
				rawData += chunk;
			}
		});
		res.on('end', () => {
			try {
				if(Array.isArray(rawData)){
					rawData = $$.Buffer.from(rawData);
				}
				callback(null, rawData, res.headers);
			} catch (err) {
				console.log("Client error:", err);
			}finally {
				//trying to prevent getting ECONNRESET error after getting our response
				req.abort();
			}
		});
	});

	req.on("error", (error) => {
		if(error && error.code !== 'ECONNRESET'){
        	console.log(`[GET] ${url}`, error);
		}

		callback(error);
	});

	req.end();
};

$$.remote.base64Encode = function base64Encode(stringToEncode){
    return $$.Buffer.from(stringToEncode).toString('base64');
};

$$.remote.base64Decode = function base64Decode(encodedString){
    return $$.Buffer.from(encodedString, 'base64').toString('ascii');
};

},{"./psk-abstract-client":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/psk-http-client/lib/psk-abstract-client.js","http":false,"https":false,"url":false}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/pskcrypto/js-mutual-auth-ecies/common/index.js":[function(require,module,exports){
'use strict';

const mycrypto = require('../crypto')
const config = require('../config')
const crypto = require('crypto');

// Prevent benign malleability
function computeKDFInput(ephemeralPublicKey, sharedSecret) {
    return $$.Buffer.concat([ephemeralPublicKey, sharedSecret],
        ephemeralPublicKey.length + sharedSecret.length)
}

function computeSymmetricEncAndMACKeys(kdfInput, options) {
    let kdfKey = mycrypto.KDF(kdfInput, options.symmetricCipherKeySize + options.macKeySize, options.hashFunctionName, options.hashSize)
    const symmetricEncryptionKey = kdfKey.slice(0, options.symmetricCipherKeySize);
    const macKey = kdfKey.slice(options.symmetricCipherKeySize)
    return {
        symmetricEncryptionKey,
        macKey
    };
}

function getDecodedECDHPublicKeyFromEncEnvelope(encEnvelope) {
    if (encEnvelope.to_ecdh === undefined) {
        throw new Error("Receiver ECDH public key property not found in input encrypted envelope")
    }
    return mycrypto.PublicKeyDeserializer.deserializeECDHPublicKey(encEnvelope.to_ecdh)
}

function checkEncryptedEnvelopeMandatoryProperties(encryptedEnvelope) {
    const mandatoryProperties = ["to_ecdh", "r", "ct", "iv", "tag"];
    mandatoryProperties.forEach((property) => {
        if (typeof encryptedEnvelope[property] === 'undefined') {
            throw new Error("Mandatory property " + property + " is missing from input encrypted envelope");
        }
    })
}

function createEncryptedEnvelopeObject(receiverECDHPublicKey, ephemeralECDHPublicKey, ciphertext, iv, tag, options) {
    return {
        to_ecdh: mycrypto.PublicKeySerializer.serializeECDHPublicKey(receiverECDHPublicKey, options),
        r: mycrypto.PublicKeySerializer.serializeECDHPublicKey(ephemeralECDHPublicKey, options),
        ct: ciphertext.toString(options.encodingFormat),
        iv: iv.toString(options.encodingFormat),
        tag: tag.toString(options.encodingFormat)
    }
}

function checkKeyPairMandatoryProperties(keyPairObject) {
    const mandatoryProperties = ["publicKey", "privateKey"];
    mandatoryProperties.forEach((property) => {
        if (typeof keyPairObject[property] === 'undefined') {
            throw new Error("Mandatory property " + property + " is missing from input key pair object");
        }
    })
}

function convertKeysToKeyObjects(keysArray, type) {
    let createKey;
    if (!type) {
        type = "public";
    }

    if (type === "private") {
        createKey = crypto.createPrivateKey;
    }

    if (type === "public") {
        createKey = crypto.createPublicKey;
    }

    if (typeof createKey !== "function") {
        throw Error(`The specified type is invalid.`);
    }

    if (!Array.isArray(keysArray)) {
        keysArray = [keysArray];
    }

    const keyObjectsArr = keysArray.map(key => {
        if (typeof key === "string") {
            return createKey(key)
        } else {
            return key;
        }
    });

    if (keyObjectsArr.length === 1) {
        return keyObjectsArr[0];
    }

    return keyObjectsArr;
}

module.exports = {
    computeKDFInput,
    computeSymmetricEncAndMACKeys,
    getDecodedECDHPublicKeyFromEncEnvelope,
    checkEncryptedEnvelopeMandatoryProperties,
    createEncryptedEnvelopeObject,
    checkKeyPairMandatoryProperties,
    convertKeysToKeyObjects
}

},{"../config":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/pskcrypto/js-mutual-auth-ecies/config.js","../crypto":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/pskcrypto/js-mutual-auth-ecies/crypto/index.js","crypto":false}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/pskcrypto/js-mutual-auth-ecies/config.js":[function(require,module,exports){
module.exports = {
    curveName: 'secp256k1',
    encodingFormat: 'base64',
    macAlgorithmName: 'sha256',
    macKeySize: 16,
    hashFunctionName: 'sha256',
    hashSize: 32,
    signAlgorithmName: 'sha256',
    symmetricCipherName: 'aes-128-cbc',
    symmetricCipherKeySize: 16,
    ivSize: 16,
    publicKeyFormat: 'pem',
    publicKeyType: 'spki'
};

},{}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/pskcrypto/js-mutual-auth-ecies/crypto/cipher.js":[function(require,module,exports){
'use strict';

const crypto = require('crypto');
const config = require('../config')


function symmetricEncrypt(key, plaintext, iv, options) {
    if (key.length !== options.symmetricCipherKeySize) {
        throw new Error('Invalid length of input symmetric encryption key')
    }
    if (iv === undefined) {
        iv = null
    }
    let cipher = crypto.createCipheriv(options.symmetricCipherName, key, iv);
    const firstChunk = cipher.update(plaintext);
    const secondChunk = cipher.final();
    return $$.Buffer.concat([firstChunk, secondChunk]);
}

function symmetricDecrypt(key, ciphertext, iv, options) {
    if (key.length !== options.symmetricCipherKeySize) {
        throw new Error('Invalid length of input symmetric decryption key')
    }
    if (iv === undefined) {
        iv = null
    }
    let cipher = crypto.createDecipheriv(options.symmetricCipherName, key, iv);
    const firstChunk = cipher.update(ciphertext);
    const secondChunk = cipher.final();
    return $$.Buffer.concat([firstChunk, secondChunk]);
}

module.exports = {
    symmetricEncrypt,
    symmetricDecrypt
}

},{"../config":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/pskcrypto/js-mutual-auth-ecies/config.js","crypto":false}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/pskcrypto/js-mutual-auth-ecies/crypto/digitalsig.js":[function(require,module,exports){
'use strict';

const crypto = require('crypto');
const config = require('../config');

function computeDigitalSignature(privateECSigningKey, buffer, options) {
    options = options || {};
    const defaultOpts = config;
    Object.assign(defaultOpts, options);
    options = defaultOpts;

    let encodingFormat = options.encodingFormat;
    let signObject = crypto.createSign(config.signAlgorithmName)
    signObject.update(buffer)
    signObject.end();
    return signObject.sign(privateECSigningKey, encodingFormat)

}

function verifyDigitalSignature(publicECVerificationKey, signature, buffer, options) {
    options = options || {};
    const defaultOpts = config;
    Object.assign(defaultOpts, options);
    options = defaultOpts;

    let verifyObject = crypto.createVerify(options.signAlgorithmName)
    verifyObject.update(buffer)
    verifyObject.end()
    return verifyObject.verify(publicECVerificationKey, signature)
}

module.exports = {
    computeDigitalSignature,
    verifyDigitalSignature
}

},{"../config":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/pskcrypto/js-mutual-auth-ecies/config.js","crypto":false}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/pskcrypto/js-mutual-auth-ecies/crypto/ecephka.js":[function(require,module,exports){
'use strict';

const crypto = require('crypto');
const config = require('../config');

class ECEphemeralKeyAgreement {

    constructor(options) {
        options = options || {};
        const defaultOpts = config;
        Object.assign(defaultOpts, options);
        options = defaultOpts;

        this.ecdh = crypto.createECDH(options.curveName);
    }

    generateEphemeralPublicKey = () => {
        return this.ecdh.generateKeys();
    }

    generateSharedSecretForPublicKey = (theirECDHPublicKey) => {
        try {
            this.ecdh.getPublicKey()
        } catch(error) {
            throw new Error('You cannot generate a shared secret for another public key without calling generateEphemeralPublicKey() first')
        }
        return this.ecdh.computeSecret(theirECDHPublicKey);
    }

    computeSharedSecretFromKeyPair = (myECDHPrivateKey, theirECDHPublicKey) => {
        this.ecdh.setPrivateKey(myECDHPrivateKey);
        return this.ecdh.computeSecret(theirECDHPublicKey);
    }
}

module.exports = ECEphemeralKeyAgreement

},{"../config":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/pskcrypto/js-mutual-auth-ecies/config.js","crypto":false}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/pskcrypto/js-mutual-auth-ecies/crypto/index.js":[function(require,module,exports){
'use strict';

const cipher = require('./cipher')
const kdf = require('./kdf')
const kmac = require('./kmac')
const sig = require('./digitalsig')
const crypto = require('crypto')

module.exports = {
    timingSafeEqual: function(a, b){
        const hashA = crypto.createHash("sha256");
        const digestA = hashA.update(a).digest("hex");

        const hashB = crypto.createHash("sha256");
        const digestB = hashB.update(b).digest("hex");
        return digestA === digestB;
    },
    getRandomBytes: crypto.randomBytes,
    computeDigitalSignature: sig.computeDigitalSignature,
    verifyDigitalSignature: sig.verifyDigitalSignature,
    symmetricEncrypt: cipher.symmetricEncrypt,
    symmetricDecrypt: cipher.symmetricDecrypt,
    KMAC: kmac,
    ECEphemeralKeyAgreement: require('./ecephka'),
    KDF: kdf.KDF2,
    PublicKeySerializer: require('./pkserializer'),
    PublicKeyDeserializer: require('./pkdeserializer')
}

},{"./cipher":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/pskcrypto/js-mutual-auth-ecies/crypto/cipher.js","./digitalsig":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/pskcrypto/js-mutual-auth-ecies/crypto/digitalsig.js","./ecephka":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/pskcrypto/js-mutual-auth-ecies/crypto/ecephka.js","./kdf":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/pskcrypto/js-mutual-auth-ecies/crypto/kdf.js","./kmac":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/pskcrypto/js-mutual-auth-ecies/crypto/kmac.js","./pkdeserializer":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/pskcrypto/js-mutual-auth-ecies/crypto/pkdeserializer.js","./pkserializer":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/pskcrypto/js-mutual-auth-ecies/crypto/pkserializer.js","crypto":false}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/pskcrypto/js-mutual-auth-ecies/crypto/kdf.js":[function(require,module,exports){
'use strict';

const crypto = require('crypto');
const config = require('../config')

// Implementation of KDF2 as defined in ISO/IEC 18033-2
function KDF2(x, outputByteSize, hashFunction = config.hashFunctionName, hashSize = config.hashSize) {
    if (outputByteSize < 0) {
        throw new Error("KDF output key byte size needs to be >= 0, not " + outputByteSize)
    } //silly optimization here
    else if (outputByteSize === 0) {
        return $$.Buffer.alloc(0)
    }
    let k = Math.ceil(outputByteSize / hashSize)
    k++;
    let derivedKeyBuffer = $$.Buffer.alloc(outputByteSize)
    let iBuffer = $$.Buffer.alloc(4)
    for (let i = 1; i < k; i++) {
        iBuffer.writeInt32BE(i)
        let roundInput = $$.Buffer.concat([x, iBuffer], x.length + iBuffer.length)
        let roundHash = crypto.createHash(hashFunction).update(roundInput).digest()
        roundHash.copy(derivedKeyBuffer, (i - 1) * hashSize)
    }
    return derivedKeyBuffer
}

module.exports = {
    KDF2
}

},{"../config":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/pskcrypto/js-mutual-auth-ecies/config.js","crypto":false}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/pskcrypto/js-mutual-auth-ecies/crypto/kmac.js":[function(require,module,exports){
'use strict';

const crypto = require('crypto');
const config = require('../config');

function computeKMAC(key, data, options) {
    if (key.length !== options.macKeySize) {
        throw new Error('Invalid length of input MAC key')
    }
    return crypto.createHmac(options.hashFunctionName, key).update(data).digest();
}

function verifyKMAC(tag, key, data, options) {
    if (key.length !== options.macKeySize) {
        throw new Error('Invalid length of input MAC key')
    }
    const timingSafeEqual = require('./index').timingSafeEqual;
    const computedTag = computeKMAC(key, data, options)
    return timingSafeEqual(computedTag, tag)
}

module.exports = {
    computeKMAC,
    verifyKMAC
}

},{"../config":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/pskcrypto/js-mutual-auth-ecies/config.js","./index":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/pskcrypto/js-mutual-auth-ecies/crypto/index.js","crypto":false}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/pskcrypto/js-mutual-auth-ecies/crypto/pkdeserializer.js":[function(require,module,exports){
'use strict';

const crypto = require('crypto')
const config = require('../config');

function PublicKeyDeserializer() {
    this.deserializeECDHPublicKey = (ecdhPublicKeySerialized, options) => {
        options = options || {};
        const defaultOpts = config;
        Object.assign(defaultOpts, options);
        options = defaultOpts;

        let encodingFormat = options.encodingFormat;
        return $$.Buffer.from(ecdhPublicKeySerialized, encodingFormat)
    }

    this.deserializeECSigVerPublicKey = (ecSigVerPublicKeySerialized, options) => {
        options = options || {};
        const defaultOpts = config;
        Object.assign(defaultOpts, options);
        options = defaultOpts;

        let encodingFormat = options.encodingFormat;
        // let publicKey = $$.Buffer.from(ecSigVerPublicKeySerialized, encodingFormat);
        const ecKeyGenerator = require("../../lib/ECKeyGenerator").createECKeyGenerator();
        const publicKey = ecKeyGenerator.convertPublicKey(ecSigVerPublicKeySerialized, {originalFormat: "der", outputFormat: "pem", encodingFormat});
        return publicKey;
    }

}

module.exports = new PublicKeyDeserializer()

},{"../../lib/ECKeyGenerator":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/pskcrypto/lib/ECKeyGenerator.js","../config":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/pskcrypto/js-mutual-auth-ecies/config.js","crypto":false}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/pskcrypto/js-mutual-auth-ecies/crypto/pkserializer.js":[function(require,module,exports){
const config = require('../config');

function PublicKeySerializer() {
    this.serializeECDHPublicKey = (ecdhPublicKey, options) => {
        options = options || {};
        const defaultOpts =  config;
        Object.assign(defaultOpts, options);
        options = defaultOpts;

        let encodingFormat = options.encodingFormat;
        return ecdhPublicKey.toString(encodingFormat);
    }

    this.serializeECSigVerPublicKey = (ecSigVerPublicKey, options) => {
        options = options || {};
        const defaultOpts = config;
        Object.assign(defaultOpts, options);
        options = defaultOpts;

        let encodingFormat = options.encodingFormat;
        const ecKeyGenerator = require("../../lib/ECKeyGenerator").createECKeyGenerator();
        const derPublicKey = ecKeyGenerator.convertPublicKey(ecSigVerPublicKey, {originalFormat: "pem", outputFormat: "der", encodingFormat});
        return derPublicKey.toString(encodingFormat)
    }
}

module.exports = new PublicKeySerializer()

},{"../../lib/ECKeyGenerator":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/pskcrypto/lib/ECKeyGenerator.js","../config":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/pskcrypto/js-mutual-auth-ecies/config.js"}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/pskcrypto/js-mutual-auth-ecies/ecies-doa-ds/decrypt.js":[function(require,module,exports){
'use strict';

const mycrypto = require('../crypto')
const common = require('../common')
const config = require('../config')

function checkWrappedMessageMandatoryProperties(wrappedMessage) {
    const mandatoryProperties = ["from_ecsig", "msg", "sig"];
    mandatoryProperties.forEach((property) => {
        if (typeof wrappedMessage[property] === 'undefined') {
            throw new Error("Mandatory property " + property + " is missing from wrapped message");
        }
    })
}

module.exports.decrypt = function (receiverECDHPrivateKey, encEnvelope, options) {
    options = options || {};
    const defaultOpts = config;
    Object.assign(defaultOpts, options);
    options = defaultOpts;
    if (typeof encEnvelope === "string") {
        try{
            encEnvelope = JSON.parse(encEnvelope);
        }   catch (e) {
            throw Error(`Could not parse encEnvelope ${encEnvelope}`);
        }
    }

    if (typeof encEnvelope !== "object") {
        throw Error(`encEnvelope should be an object. Received ${typeof encEnvelope}`);
    }

    common.checkEncryptedEnvelopeMandatoryProperties(encEnvelope);
    const ephemeralPublicKey = $$.Buffer.from(encEnvelope.r, options.encodingFormat)

    const ephemeralKeyAgreement = new mycrypto.ECEphemeralKeyAgreement(options)
    const sharedSecret = ephemeralKeyAgreement.computeSharedSecretFromKeyPair(receiverECDHPrivateKey, ephemeralPublicKey)

    const kdfInput = common.computeKDFInput(ephemeralPublicKey, sharedSecret)
    const { symmetricEncryptionKey, macKey } = common.computeSymmetricEncAndMACKeys(kdfInput, options)

    const ciphertext = $$.Buffer.from(encEnvelope.ct, options.encodingFormat)
    const tag = $$.Buffer.from(encEnvelope.tag, options.encodingFormat)
    const iv = $$.Buffer.from(encEnvelope.iv, options.encodingFormat)

    if (!mycrypto.KMAC.verifyKMAC(tag,
        macKey,
        $$.Buffer.concat([ciphertext, iv],
            ciphertext.length + iv.length), options)
    ) {
        throw new Error("Bad MAC")
    }

    let wrappedMessageObject = JSON.parse(mycrypto.symmetricDecrypt(symmetricEncryptionKey, ciphertext, iv, options).toString())
    checkWrappedMessageMandatoryProperties(wrappedMessageObject)
    const senderECSigVerPublicKey = mycrypto.PublicKeyDeserializer.deserializeECSigVerPublicKey(wrappedMessageObject.from_ecsig)

    if (!mycrypto.verifyDigitalSignature(senderECSigVerPublicKey,
        $$.Buffer.from(wrappedMessageObject.sig, options.encodingFormat),
        sharedSecret, options)) {
        throw new Error("Bad signature")
    }
    return {
        from_ecsig: senderECSigVerPublicKey,
        message: $$.Buffer.from(wrappedMessageObject.msg, options.encodingFormat)
    };
}

},{"../common":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/pskcrypto/js-mutual-auth-ecies/common/index.js","../config":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/pskcrypto/js-mutual-auth-ecies/config.js","../crypto":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/pskcrypto/js-mutual-auth-ecies/crypto/index.js"}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/pskcrypto/js-mutual-auth-ecies/ecies-doa-ds/encrypt.js":[function(require,module,exports){
'use strict';

const mycrypto = require('../crypto')
const common = require('../common');
const config = require('../config');

function senderMessageWrapAndSerialization(senderECSigVerPublicKey, message, signature, options) {
    options = options || {};
    const defaultOpts = config;
    Object.assign(defaultOpts, options);
    options = defaultOpts;

    return JSON.stringify({
        from_ecsig: mycrypto.PublicKeySerializer.serializeECSigVerPublicKey(senderECSigVerPublicKey, options),
        msg: message.toString(options.encodingFormat),
        sig: signature.toString(options.encodingFormat)
    });
}

module.exports.encrypt = function (senderECSigningKeyPair, receiverECDHPublicKey, message, options) {
    options = options || {};
    const defaultOpts = config;
    Object.assign(defaultOpts, options);
    options = defaultOpts;

    if (typeof message === "object" && !$$.Buffer.isBuffer(message)) {
        message = JSON.stringify(message);
    }

    if (typeof message === "string") {
        message = $$.Buffer.from(message);
    }

    if (!$$.Buffer.isBuffer(message)) {
        throw new Error('Input message has to be of type Buffer');
    }

    common.checkKeyPairMandatoryProperties(senderECSigningKeyPair)

    const ephemeralKeyAgreement = new mycrypto.ECEphemeralKeyAgreement(options)
    const ephemeralPublicKey = ephemeralKeyAgreement.generateEphemeralPublicKey()
    const sharedSecret = ephemeralKeyAgreement.generateSharedSecretForPublicKey(receiverECDHPublicKey)

    const signature = mycrypto.computeDigitalSignature(senderECSigningKeyPair.privateKey, sharedSecret, options)
    const senderAuthMsgEnvelopeSerialized = senderMessageWrapAndSerialization(senderECSigningKeyPair.publicKey, message, signature, options)

    const kdfInput = common.computeKDFInput(ephemeralPublicKey, sharedSecret)
    const { symmetricEncryptionKey, macKey } = common.computeSymmetricEncAndMACKeys(kdfInput, options)

    const iv = mycrypto.getRandomBytes(options.ivSize)
    const ciphertext = mycrypto.symmetricEncrypt(symmetricEncryptionKey, senderAuthMsgEnvelopeSerialized, iv, options)
    const tag = mycrypto.KMAC.computeKMAC(macKey,
        $$.Buffer.concat([ciphertext, iv],
            ciphertext.length + iv.length), options
    )

    return common.createEncryptedEnvelopeObject(receiverECDHPublicKey, ephemeralPublicKey, ciphertext, iv, tag, options)
};

},{"../common":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/pskcrypto/js-mutual-auth-ecies/common/index.js","../config":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/pskcrypto/js-mutual-auth-ecies/config.js","../crypto":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/pskcrypto/js-mutual-auth-ecies/crypto/index.js"}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/pskcrypto/js-mutual-auth-ecies/ecies-doa-ds/index.js":[function(require,module,exports){
'use strict';

module.exports = {
  encrypt: require('./encrypt').encrypt,
  decrypt: require('./decrypt').decrypt,
  getDecodedECDHPublicKeyFromEncEnvelope: require('../common').getDecodedECDHPublicKeyFromEncEnvelope
}
},{"../common":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/pskcrypto/js-mutual-auth-ecies/common/index.js","./decrypt":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/pskcrypto/js-mutual-auth-ecies/ecies-doa-ds/decrypt.js","./encrypt":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/pskcrypto/js-mutual-auth-ecies/ecies-doa-ds/encrypt.js"}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/pskcrypto/js-mutual-auth-ecies/ecies-doa-kmac/decrypt.js":[function(require,module,exports){
'use strict';

const mycrypto = require('../crypto');
const common = require('../common')
const config = require('../config')

function checkWrappedMessageMandatoryProperties(wrappedMessage) {
    const mandatoryProperties = ["from_ecdh", "msg"];
    mandatoryProperties.forEach((property) => {
        if (typeof wrappedMessage[property] === 'undefined') {
            throw new Error("Mandatory property " + property + " is missing from wrapped message");
        }
    })
}

module.exports.decrypt = function (receiverECDHPrivateKey, encEnvelope, options) {
    options = options || {};
    const defaultOpts = config;
    Object.assign(defaultOpts, options);
    options = defaultOpts;

    if (typeof encEnvelope === "string") {
        try{
            encEnvelope = JSON.parse(encEnvelope);
        }   catch (e) {
            throw Error(`Could not parse encEnvelope ${encEnvelope}`);
        }
    }

    if (typeof encEnvelope !== "object") {
        throw Error(`encEnvelope should be an object. Received ${typeof encEnvelope}`);
    }

    common.checkEncryptedEnvelopeMandatoryProperties(encEnvelope)
    const ephemeralPublicKey = mycrypto.PublicKeyDeserializer.deserializeECDHPublicKey(encEnvelope.r, options)

    const ephemeralKeyAgreement = new mycrypto.ECEphemeralKeyAgreement(options)
    const sharedSecret = ephemeralKeyAgreement.computeSharedSecretFromKeyPair(receiverECDHPrivateKey, ephemeralPublicKey)

    const kdfInput = common.computeKDFInput(ephemeralPublicKey, sharedSecret)
    const { symmetricEncryptionKey, macKey } = common.computeSymmetricEncAndMACKeys(kdfInput, options)

    const ciphertext = $$.Buffer.from(encEnvelope.ct, options.encodingFormat)
    const tag = $$.Buffer.from(encEnvelope.tag, options.encodingFormat)
    const iv = $$.Buffer.from(encEnvelope.iv, options.encodingFormat)

    const wrappedMessageObject = JSON.parse(mycrypto.symmetricDecrypt(symmetricEncryptionKey, ciphertext, iv, options).toString())
    checkWrappedMessageMandatoryProperties(wrappedMessageObject)
    const senderPublicKey = mycrypto.PublicKeyDeserializer.deserializeECDHPublicKey(wrappedMessageObject.from_ecdh, options);

    const senderKeyAgreement = new mycrypto.ECEphemeralKeyAgreement(options)
    const senderDerivedSharedSecret = senderKeyAgreement.computeSharedSecretFromKeyPair(receiverECDHPrivateKey, senderPublicKey)
    // **TODO**: This does not seem correct, need to think about it.
    mycrypto.KMAC.verifyKMAC(tag, macKey,
        $$.Buffer.concat([ciphertext, iv, senderDerivedSharedSecret],
            ciphertext.length + iv.length + senderDerivedSharedSecret.length), options
    )

    return {
        from_ecdh: senderPublicKey,
        message: $$.Buffer.from(wrappedMessageObject.msg, options.encodingFormat)
    };
}

},{"../common":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/pskcrypto/js-mutual-auth-ecies/common/index.js","../config":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/pskcrypto/js-mutual-auth-ecies/config.js","../crypto":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/pskcrypto/js-mutual-auth-ecies/crypto/index.js"}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/pskcrypto/js-mutual-auth-ecies/ecies-doa-kmac/encrypt.js":[function(require,module,exports){
'use strict';

const mycrypto = require('../crypto');
const common = require('../common')
const config = require('../config')

function senderMessageWrapAndSerialization(senderECDHPublicKey, message) {
    return JSON.stringify({
        from_ecdh: mycrypto.PublicKeySerializer.serializeECDHPublicKey(senderECDHPublicKey),
        msg: message
    });
}

module.exports.encrypt = function (senderECDHKeyPair, receiverECDHPublicKey, message, options) {
    options = options || {};
    const defaultOpts = config;
    Object.assign(defaultOpts, options);
    options = defaultOpts;

    if (typeof message === "object" && !$$.Buffer.isBuffer(message)) {
        message = JSON.stringify(message);
    }

    if (typeof message === "string") {
        message = $$.Buffer.from(message);
    }

    if (!$$.Buffer.isBuffer(message)) {
        throw new Error('Input message has to be of type Buffer');
    }
    common.checkKeyPairMandatoryProperties(senderECDHKeyPair)
    const senderKeyAgreement = new mycrypto.ECEphemeralKeyAgreement(options)
    const senderDerivedSharedSecret = senderKeyAgreement.computeSharedSecretFromKeyPair(senderECDHKeyPair.privateKey, receiverECDHPublicKey)

    const senderAuthMsgEnvelopeSerialized = senderMessageWrapAndSerialization(senderECDHKeyPair.publicKey, message);

    const ephemeralKeyAgreement = new mycrypto.ECEphemeralKeyAgreement(options)
    const ephemeralPublicKey = ephemeralKeyAgreement.generateEphemeralPublicKey()
    const ephemeralSharedSecret = ephemeralKeyAgreement.generateSharedSecretForPublicKey(receiverECDHPublicKey)

    const kdfInput = common.computeKDFInput(ephemeralPublicKey, ephemeralSharedSecret)
    const {symmetricEncryptionKey, macKey} = common.computeSymmetricEncAndMACKeys(kdfInput, options)

    const iv = mycrypto.getRandomBytes(options.ivSize)
    const ciphertext = mycrypto.symmetricEncrypt(symmetricEncryptionKey, senderAuthMsgEnvelopeSerialized, iv, options)
    // **TODO**: This does not seem correct, need to think about it.
    const tag = mycrypto.KMAC.computeKMAC(macKey,
        $$.Buffer.concat([ciphertext, iv, senderDerivedSharedSecret],
            ciphertext.length + iv.length + senderDerivedSharedSecret.length), options
    )

    return common.createEncryptedEnvelopeObject(receiverECDHPublicKey, ephemeralPublicKey, ciphertext, iv, tag, options)
};

},{"../common":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/pskcrypto/js-mutual-auth-ecies/common/index.js","../config":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/pskcrypto/js-mutual-auth-ecies/config.js","../crypto":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/pskcrypto/js-mutual-auth-ecies/crypto/index.js"}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/pskcrypto/js-mutual-auth-ecies/ecies-doa-kmac/index.js":[function(require,module,exports){
arguments[4]["/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/pskcrypto/js-mutual-auth-ecies/ecies-doa-ds/index.js"][0].apply(exports,arguments)
},{"../common":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/pskcrypto/js-mutual-auth-ecies/common/index.js","./decrypt":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/pskcrypto/js-mutual-auth-ecies/ecies-doa-kmac/decrypt.js","./encrypt":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/pskcrypto/js-mutual-auth-ecies/ecies-doa-kmac/encrypt.js"}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/pskcrypto/js-mutual-auth-ecies/ecies-group-encryption/ecies-ge-anon/decrypt.js":[function(require,module,exports){
'use strict';

const mycrypto = require('../../crypto')
const utils = require('../utils')
const common = require('../../common')
const config = require('../../config')

function checkEncryptedEnvelopeMandatoryProperties(encryptedEnvelope) {
    const mandatoryProperties = ["recvs", "rtag", "ct", "iv", "tag"];
    mandatoryProperties.forEach((property) => {
        if (typeof encryptedEnvelope[property] === 'undefined') {
            throw new Error("Mandatory property " + property + " is missing from input group encrypted envelope");
        }
    })
}

module.exports.decrypt = function (receiverECDHKeyPair, encEnvelope, options) {
    options = options || {};
    const defaultOpts = config;
    Object.assign(defaultOpts, options);
    options = defaultOpts;

    checkEncryptedEnvelopeMandatoryProperties(encEnvelope)
    common.checkKeyPairMandatoryProperties(receiverECDHKeyPair)
    const receiverECIESInstancesBuffer = $$.Buffer.from(encEnvelope.recvs, options.encodingFormat)

    const keyBuffer = utils.receiverMultiRecipientECIESDecrypt(receiverECDHKeyPair, receiverECIESInstancesBuffer)
    const {symmetricCipherKey, ciphertextMacKey, recvsMacKey} = utils.parseKeyBuffer(keyBuffer)

    const ciphertext = $$.Buffer.from(encEnvelope.ct, options.encodingFormat)
    const tag = $$.Buffer.from(encEnvelope.tag, options.encodingFormat)
    const iv = $$.Buffer.from(encEnvelope.iv, options.encodingFormat)
    const recvsTag = $$.Buffer.from(encEnvelope.rtag, options.encodingFormat)

    if (!mycrypto.KMAC.verifyKMAC(tag,
        ciphertextMacKey,
        $$.Buffer.concat([ciphertext, iv],
            ciphertext.length + iv.length), options)
    ) {
        throw new Error("Bad ciphertext MAC")
    }
    if (!mycrypto.KMAC.verifyKMAC(recvsTag,
        recvsMacKey,
        receiverECIESInstancesBuffer, options)
    ) {
        throw new Error("Bad recipient ECIES MAC")
    }

    return mycrypto.symmetricDecrypt(symmetricCipherKey, ciphertext, iv, options)
}

},{"../../common":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/pskcrypto/js-mutual-auth-ecies/common/index.js","../../config":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/pskcrypto/js-mutual-auth-ecies/config.js","../../crypto":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/pskcrypto/js-mutual-auth-ecies/crypto/index.js","../utils":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/pskcrypto/js-mutual-auth-ecies/ecies-group-encryption/utils/index.js"}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/pskcrypto/js-mutual-auth-ecies/ecies-group-encryption/ecies-ge-anon/encrypt.js":[function(require,module,exports){
'use strict';

const utils = require('../utils')
const mycrypto = require('../../crypto')
const config = require('../../config')

module.exports.encrypt = function (message, ...receiverECDHPublicKeys) {
    let options;
    const lastArg = receiverECDHPublicKeys[receiverECDHPublicKeys.length - 1];
    if (typeof lastArg === "object" && !Array.isArray(lastArg) && !$$.Buffer.isBuffer(lastArg) && !(lastArg instanceof Uint8Array)) {
        options = receiverECDHPublicKeys.pop();
    } else {
        options = {};
    }

    const defaultOpts = config;
    Object.assign(defaultOpts, options);
    options = defaultOpts;

    if (typeof message === "object" && !$$.Buffer.isBuffer(message)) {
        message = JSON.stringify(message);
    }

    if (typeof message === "string") {
        message = $$.Buffer.from(message);
    }

    if (!$$.Buffer.isBuffer(message)) {
        throw new Error('Input message has to be of type Buffer');
    }

    if (receiverECDHPublicKeys.length === 0) {
        throw new Error('Need to specify at least one receiver public key')
    }

    receiverECDHPublicKeys.push(options);
    const { symmetricCipherKey, ciphertextMacKey, recvsMacKey } = utils.generateKeyBufferParams(options)
    const multiRecipientECIESBuffer = utils.senderMultiRecipientECIESEncrypt(
        $$.Buffer.concat([symmetricCipherKey, ciphertextMacKey, recvsMacKey],
            symmetricCipherKey.length + ciphertextMacKey.length + recvsMacKey.length),
        ...receiverECDHPublicKeys)

    const iv = mycrypto.getRandomBytes(options.ivSize)
    const ciphertext = mycrypto.symmetricEncrypt(symmetricCipherKey, message, iv, options)
    const tag = mycrypto.KMAC.computeKMAC(ciphertextMacKey,
        $$.Buffer.concat(
            [ciphertext, iv],
            ciphertext.length + iv.length), options
    );
    const recvsTag = mycrypto.KMAC.computeKMAC(recvsMacKey, multiRecipientECIESBuffer, options)

    return {
        recvs: multiRecipientECIESBuffer.toString(options.encodingFormat),
        rtag: recvsTag.toString(options.encodingFormat),
        ct: ciphertext.toString(options.encodingFormat),
        iv: iv.toString(options.encodingFormat),
        tag: tag.toString(options.encodingFormat)
    }
}

},{"../../config":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/pskcrypto/js-mutual-auth-ecies/config.js","../../crypto":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/pskcrypto/js-mutual-auth-ecies/crypto/index.js","../utils":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/pskcrypto/js-mutual-auth-ecies/ecies-group-encryption/utils/index.js"}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/pskcrypto/js-mutual-auth-ecies/ecies-group-encryption/ecies-ge-anon/index.js":[function(require,module,exports){
'use strict';

module.exports = {
  encrypt: require('./encrypt').encrypt,
  decrypt: require('./decrypt').decrypt,
  getRecipientECDHPublicKeysFromEncEnvelope: require('../utils').getRecipientECDHPublicKeysFromEncEnvelope
}

},{"../utils":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/pskcrypto/js-mutual-auth-ecies/ecies-group-encryption/utils/index.js","./decrypt":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/pskcrypto/js-mutual-auth-ecies/ecies-group-encryption/ecies-ge-anon/decrypt.js","./encrypt":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/pskcrypto/js-mutual-auth-ecies/ecies-group-encryption/ecies-ge-anon/encrypt.js"}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/pskcrypto/js-mutual-auth-ecies/ecies-group-encryption/ecies-ge-doa/decrypt.js":[function(require,module,exports){
'use strict';

const mycrypto = require('../../crypto')
const config = require('../../config')
const common = require('../../common')
const eciesGEAnon = require('../ecies-ge-anon')

function checkEncryptedEnvelopeMandatoryProperties(encryptedEnvelope) {
    const mandatoryProperties = ["from_ecsig", "sig"];
    mandatoryProperties.forEach((property) => {
        if (typeof encryptedEnvelope[property] === 'undefined') {
            throw new Error("Mandatory property " + property + " is missing from input encrypted envelope");
        }
    })
}

module.exports.decrypt = function (receiverECDHKeyPair, encEnvelope, options) {
    options = options || {};
    const defaultOpts = config;
    Object.assign(defaultOpts, options);
    options = defaultOpts;

    checkEncryptedEnvelopeMandatoryProperties(encEnvelope)
    common.checkKeyPairMandatoryProperties(receiverECDHKeyPair)

    let tempGEAnonEnvelope = Object.assign({}, encEnvelope)
    delete tempGEAnonEnvelope.from_ecsig;
    delete tempGEAnonEnvelope.sig;
    const message = eciesGEAnon.decrypt(receiverECDHKeyPair, tempGEAnonEnvelope, options)
    tempGEAnonEnvelope = null;

    const senderECSigVerPublicKey = mycrypto.PublicKeyDeserializer.deserializeECSigVerPublicKey(encEnvelope.from_ecsig, options)

    const recvsTagBuffer = $$.Buffer.from(encEnvelope.rtag, options.encodingFormat)
    const tagBuffer = $$.Buffer.from(encEnvelope.tag, options.encodingFormat)
    const signature = $$.Buffer.from(encEnvelope.sig, options.encodingFormat)
    if (!mycrypto.verifyDigitalSignature(senderECSigVerPublicKey,
        signature,
        $$.Buffer.concat([recvsTagBuffer, tagBuffer],
            recvsTagBuffer.length + tagBuffer.length), options)
    ) {
        throw new Error("Bad signature")
    }

    return {
        from: senderECSigVerPublicKey,
        message: message
    }
}

},{"../../common":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/pskcrypto/js-mutual-auth-ecies/common/index.js","../../config":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/pskcrypto/js-mutual-auth-ecies/config.js","../../crypto":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/pskcrypto/js-mutual-auth-ecies/crypto/index.js","../ecies-ge-anon":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/pskcrypto/js-mutual-auth-ecies/ecies-group-encryption/ecies-ge-anon/index.js"}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/pskcrypto/js-mutual-auth-ecies/ecies-group-encryption/ecies-ge-doa/encrypt.js":[function(require,module,exports){
'use strict';

const mycrypto = require('../../crypto')
const common = require('../../common')
const config = require('../../config')
const eciesGEAnon = require('../ecies-ge-anon')

module.exports.encrypt = function (senderECSigningKeyPair, message, ...receiverECDHPublicKeys) {
    let options;
    const lastArg = receiverECDHPublicKeys[receiverECDHPublicKeys.length - 1];
    if (typeof lastArg === "object" && !Array.isArray(lastArg) && !$$.Buffer.isBuffer(lastArg) && !(lastArg instanceof Uint8Array)) {
        options = receiverECDHPublicKeys.pop();
    } else {
        options = {};
    }

    const defaultOpts = config;
    Object.assign(defaultOpts, options);
    options = defaultOpts;

    if (typeof message === "object" && !$$.Buffer.isBuffer(message)) {
        message = JSON.stringify(message);
    }

    if (typeof message === "string") {
        message = $$.Buffer.from(message);
    }

    if (!$$.Buffer.isBuffer(message)) {
        throw new Error('Input message has to be of type Buffer');
    }

    common.checkKeyPairMandatoryProperties(senderECSigningKeyPair);
    receiverECDHPublicKeys.push(options);
    let eciesGEEnvelope = eciesGEAnon.encrypt(message, ...receiverECDHPublicKeys)

    const recvsTagBuffer = $$.Buffer.from(eciesGEEnvelope.rtag, options.encodingFormat)
    const tagBuffer = $$.Buffer.from(eciesGEEnvelope.tag, options.encodingFormat)
    const signature = mycrypto.computeDigitalSignature(senderECSigningKeyPair.privateKey,
        $$.Buffer.concat([recvsTagBuffer, tagBuffer],
            recvsTagBuffer.length + tagBuffer.length), options)

    eciesGEEnvelope.sig = signature.toString(options.encodingFormat)
    eciesGEEnvelope.from_ecsig = mycrypto.PublicKeySerializer.serializeECSigVerPublicKey(senderECSigningKeyPair.publicKey, options)

    return eciesGEEnvelope;
}

},{"../../common":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/pskcrypto/js-mutual-auth-ecies/common/index.js","../../config":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/pskcrypto/js-mutual-auth-ecies/config.js","../../crypto":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/pskcrypto/js-mutual-auth-ecies/crypto/index.js","../ecies-ge-anon":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/pskcrypto/js-mutual-auth-ecies/ecies-group-encryption/ecies-ge-anon/index.js"}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/pskcrypto/js-mutual-auth-ecies/ecies-group-encryption/ecies-ge-doa/index.js":[function(require,module,exports){
arguments[4]["/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/pskcrypto/js-mutual-auth-ecies/ecies-group-encryption/ecies-ge-anon/index.js"][0].apply(exports,arguments)
},{"../utils":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/pskcrypto/js-mutual-auth-ecies/ecies-group-encryption/utils/index.js","./decrypt":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/pskcrypto/js-mutual-auth-ecies/ecies-group-encryption/ecies-ge-doa/decrypt.js","./encrypt":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/pskcrypto/js-mutual-auth-ecies/ecies-group-encryption/ecies-ge-doa/encrypt.js"}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/pskcrypto/js-mutual-auth-ecies/ecies-group-encryption/utils/index.js":[function(require,module,exports){
'use strict';

const sender = require('./sender')
const recipient = require('./recipient')

module.exports = {
    generateKeyBufferParams: sender.generateKeyBufferParams,
    senderMultiRecipientECIESEncrypt: sender.senderMultiRecipientECIESEncrypt,
    getRecipientECDHPublicKeysFromEncEnvelope: recipient.getRecipientECDHPublicKeysFromEncEnvelope,
    receiverMultiRecipientECIESDecrypt: recipient.receiverMultiRecipientECIESDecrypt,
    parseKeyBuffer: recipient.parseKeyBuffer
}



},{"./recipient":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/pskcrypto/js-mutual-auth-ecies/ecies-group-encryption/utils/recipient.js","./sender":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/pskcrypto/js-mutual-auth-ecies/ecies-group-encryption/utils/sender.js"}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/pskcrypto/js-mutual-auth-ecies/ecies-group-encryption/utils/recipient.js":[function(require,module,exports){
'use strict';

const mycrypto = require('../../crypto')
const common = require('../../common')
const ecies = require('../../ecies')
const config = require('../../config')

module.exports.getRecipientECDHPublicKeysFromEncEnvelope = function (encEnvelope, options) {
    options = options || {};
    const defaultOpts = config;
    Object.assign(defaultOpts, options);
    options = defaultOpts;

    if (encEnvelope.recvs === undefined) {
        throw new Error('Mandatory property recvs not found in encrypted envelope')
    }
    let multiRecipientECIESEnvelopeArray = JSON.parse($$.Buffer.from(encEnvelope.recvs, options.encodingFormat))
    if (multiRecipientECIESEnvelopeArray.length === 0) {
        throw new Error('Invalid receiver array in encrypted envelope')
    }
    let recipientECDHPublicKeyArray = [];
    multiRecipientECIESEnvelopeArray.forEach(function (curRecipientECIESEnvelope) {
        common.checkEncryptedEnvelopeMandatoryProperties(curRecipientECIESEnvelope)
        let curRecipientECDHPublicKey = common.getDecodedECDHPublicKeyFromEncEnvelope(curRecipientECIESEnvelope, options)
        recipientECDHPublicKeyArray.push(curRecipientECDHPublicKey)
    })
    if (recipientECDHPublicKeyArray.length === 0) {
        throw new Error('Unable to parse any of the receivers\' ECIES instances')
    }
    return recipientECDHPublicKeyArray;
}

function isECIESEnvelopeForInputECDHPublicKey(eciesEnvelope, ecdhPublicKey, options) {
    const ecdhPublicKeyBuffer = $$.Buffer.from(mycrypto.PublicKeySerializer.serializeECDHPublicKey(ecdhPublicKey, options))
    const envelopeECDHPublicKey = $$.Buffer.from(eciesEnvelope.to_ecdh)
    return mycrypto.timingSafeEqual(envelopeECDHPublicKey, ecdhPublicKeyBuffer);
}

module.exports.receiverMultiRecipientECIESDecrypt = function(receiverECDHKeyPair, multiRecipientECIESBuffer, options) {
    options = options || {};
    const defaultOpts = config;
    Object.assign(defaultOpts, options);
    options = defaultOpts;

    let multiRecipientECIESEnvelopeArray = JSON.parse(multiRecipientECIESBuffer)
    if (multiRecipientECIESEnvelopeArray.length === 0) {
        throw new Error("Parsed an empty receivers ECIES instances array")
    }
    let myECIESInstanceFound = false;
    let message;
    multiRecipientECIESEnvelopeArray.forEach(function (curRecipientECIESEnvelope) {
        common.checkEncryptedEnvelopeMandatoryProperties(curRecipientECIESEnvelope)
        if (isECIESEnvelopeForInputECDHPublicKey(curRecipientECIESEnvelope, receiverECDHKeyPair.publicKey, options)) {
            message = ecies.decrypt(receiverECDHKeyPair.privateKey, curRecipientECIESEnvelope, options)
            myECIESInstanceFound = true;
            return;
        }
    })
    if (!myECIESInstanceFound) {
        throw new Error("Unable to decrypt input envelope with input EC key pair")
    }
    return message;
}

module.exports.parseKeyBuffer = function (keyBuffer, options) {
    options = options || {};
    const defaultOpts = config;
    Object.assign(defaultOpts, options);

    options = defaultOpts;
    if (keyBuffer.length !== (options.symmetricCipherKeySize + (2*options.macKeySize))) {
        throw new Error("Invalid length of decrypted key buffer")
    }
    const symmetricCipherKey = keyBuffer.slice(0, options.symmetricCipherKeySize)
    const ciphertextMacKey = keyBuffer.slice(options.symmetricCipherKeySize, options.symmetricCipherKeySize + options.macKeySize)
    const recvsMacKey = keyBuffer.slice(options.symmetricCipherKeySize + options.macKeySize)
    return {
        symmetricCipherKey,
        ciphertextMacKey,
        recvsMacKey
    }
}

},{"../../common":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/pskcrypto/js-mutual-auth-ecies/common/index.js","../../config":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/pskcrypto/js-mutual-auth-ecies/config.js","../../crypto":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/pskcrypto/js-mutual-auth-ecies/crypto/index.js","../../ecies":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/pskcrypto/js-mutual-auth-ecies/ecies/index.js"}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/pskcrypto/js-mutual-auth-ecies/ecies-group-encryption/utils/sender.js":[function(require,module,exports){
'use strict';

const mycrypto = require('../../crypto')
const ecies = require('../../ecies')
const config = require('../../config')

module.exports.generateKeyBufferParams = function (options) {
    const symmetricCipherKey = mycrypto.getRandomBytes(options.symmetricCipherKeySize)
    const ciphertextMacKey = mycrypto.getRandomBytes(options.macKeySize)
    const recvsMacKey = mycrypto.getRandomBytes(options.macKeySize)
    return {
        symmetricCipherKey,
        ciphertextMacKey,
        recvsMacKey
    }
}

module.exports.senderMultiRecipientECIESEncrypt = function(message, ...receiverECDHPublicKeyArray) {
    let options;
    const lastArg = receiverECDHPublicKeyArray[receiverECDHPublicKeyArray.length - 1];
    if (typeof lastArg === "object" && !Array.isArray(lastArg) && !$$.Buffer.isBuffer(lastArg) && !(lastArg instanceof Uint8Array)) {
        options = receiverECDHPublicKeyArray.pop();
    } else {
        options = {};
    }

    const defaultOpts = config;
    Object.assign(defaultOpts, options);
    options = defaultOpts;

    let eciesInstancesArray = []
    receiverECDHPublicKeyArray.forEach(function (curReceiverECDHPublicKey) {
        eciesInstancesArray.push(ecies.encrypt(curReceiverECDHPublicKey, message, options))
    })
    return $$.Buffer.from(JSON.stringify(eciesInstancesArray))
}

},{"../../config":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/pskcrypto/js-mutual-auth-ecies/config.js","../../crypto":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/pskcrypto/js-mutual-auth-ecies/crypto/index.js","../../ecies":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/pskcrypto/js-mutual-auth-ecies/ecies/index.js"}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/pskcrypto/js-mutual-auth-ecies/ecies/decrypt.js":[function(require,module,exports){
'use strict';

const mycrypto = require('../crypto')
const common = require('../common')
const config = require('../config')


module.exports.decrypt = function (receiverECDHPrivateKey, encEnvelope, options) {
    options = options || {};
    const defaultOpts = config;
    Object.assign(defaultOpts, options);
    options = defaultOpts;

    if (typeof encEnvelope === "string") {
        try{
            encEnvelope = JSON.parse(encEnvelope);
        }   catch (e) {
            throw Error(`Could not parse encEnvelope ${encEnvelope}`);
        }
    }

    if (typeof encEnvelope !== "object") {
        throw Error(`encEnvelope should be an object. Received ${typeof encEnvelope}`);
    }

    common.checkEncryptedEnvelopeMandatoryProperties(encEnvelope)

    const ephemeralPublicKey = mycrypto.PublicKeyDeserializer.deserializeECDHPublicKey(encEnvelope.r, options)

    const ephemeralKeyAgreement = new mycrypto.ECEphemeralKeyAgreement(options)
    const sharedSecret = ephemeralKeyAgreement.computeSharedSecretFromKeyPair(receiverECDHPrivateKey, ephemeralPublicKey)

    const kdfInput = common.computeKDFInput(ephemeralPublicKey, sharedSecret)
    const { symmetricEncryptionKey, macKey } = common.computeSymmetricEncAndMACKeys(kdfInput, options)

    const ciphertext = $$.Buffer.from(encEnvelope.ct, options.encodingFormat)
    const tag = $$.Buffer.from(encEnvelope.tag, options.encodingFormat)
    const iv = $$.Buffer.from(encEnvelope.iv, options.encodingFormat)

    if (!mycrypto.KMAC.verifyKMAC(tag,
        macKey,
        $$.Buffer.concat([ciphertext, iv],
            ciphertext.length + iv.length), options)
    ) {
        throw new Error("Bad MAC")
    }

    return mycrypto.symmetricDecrypt(symmetricEncryptionKey, ciphertext, iv, options)
}

},{"../common":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/pskcrypto/js-mutual-auth-ecies/common/index.js","../config":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/pskcrypto/js-mutual-auth-ecies/config.js","../crypto":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/pskcrypto/js-mutual-auth-ecies/crypto/index.js"}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/pskcrypto/js-mutual-auth-ecies/ecies/encrypt.js":[function(require,module,exports){
'use strict';

const mycrypto = require('../crypto')
const common = require('../common')
const config = require('../config');

module.exports.encrypt = function (receiverECDHPublicKey, message, options) {
    options = options || {};
    const defaultOpts = config;
    Object.assign(defaultOpts, options);
    options = defaultOpts;

    if (typeof message === "object" && !$$.Buffer.isBuffer(message)) {
        message = JSON.stringify(message);
    }

    if (typeof message === "string") {
        message = $$.Buffer.from(message);
    }

    if (!$$.Buffer.isBuffer(message)) {
        throw new Error('Input message has to be of type Buffer');
    }

    const ephemeralKeyAgreement = new mycrypto.ECEphemeralKeyAgreement(options)
    const ephemeralPublicKey = ephemeralKeyAgreement.generateEphemeralPublicKey()
    const sharedSecret = ephemeralKeyAgreement.generateSharedSecretForPublicKey(receiverECDHPublicKey)

    const kdfInput = common.computeKDFInput(ephemeralPublicKey, sharedSecret)
    const { symmetricEncryptionKey, macKey } = common.computeSymmetricEncAndMACKeys(kdfInput, options)

    const iv = mycrypto.getRandomBytes(options.ivSize)
    const ciphertext = mycrypto.symmetricEncrypt(symmetricEncryptionKey, message, iv, options)
    const tag = mycrypto.KMAC.computeKMAC(macKey,
        $$.Buffer.concat([ciphertext, iv],
            ciphertext.length + iv.length), options
    )

    return common.createEncryptedEnvelopeObject(receiverECDHPublicKey, ephemeralPublicKey, ciphertext, iv, tag, options)
}

},{"../common":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/pskcrypto/js-mutual-auth-ecies/common/index.js","../config":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/pskcrypto/js-mutual-auth-ecies/config.js","../crypto":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/pskcrypto/js-mutual-auth-ecies/crypto/index.js"}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/pskcrypto/js-mutual-auth-ecies/ecies/index.js":[function(require,module,exports){
arguments[4]["/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/pskcrypto/js-mutual-auth-ecies/ecies-doa-ds/index.js"][0].apply(exports,arguments)
},{"../common":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/pskcrypto/js-mutual-auth-ecies/common/index.js","./decrypt":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/pskcrypto/js-mutual-auth-ecies/ecies/decrypt.js","./encrypt":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/pskcrypto/js-mutual-auth-ecies/ecies/encrypt.js"}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/pskcrypto/js-mutual-auth-ecies/index.js":[function(require,module,exports){
module.exports = {
    ecies_encrypt: require("./ecies").encrypt,
    ecies_decrypt: require("./ecies").decrypt,
    ecies_encrypt_ds: require("./ecies-doa-ds").encrypt,
    ecies_decrypt_ds: require("./ecies-doa-ds").decrypt,
    ecies_encrypt_kmac: require("./ecies-doa-kmac").encrypt,
    ecies_decrypt_kmac: require("./ecies-doa-kmac").decrypt,
    ecies_getDecodedECDHPublicKeyFromEncEnvelope: require("./ecies/index").getDecodedECDHPublicKeyFromEncEnvelope,
    ecies_group_encrypt: require("./ecies-group-encryption/ecies-ge-anon").encrypt,
    ecies_group_decrypt: require("./ecies-group-encryption/ecies-ge-anon").decrypt,
    ecies_group_encrypt_ds: require("./ecies-group-encryption/ecies-ge-doa").encrypt,
    ecies_group_decrypt_ds: require("./ecies-group-encryption/ecies-ge-doa").decrypt,
    ecies_group_getRecipientECDHPublicKeysFromEncEnvelope: require("./ecies-group-encryption/ecies-ge-doa").getRecipientECDHPublicKeysFromEncEnvelope
}

},{"./ecies":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/pskcrypto/js-mutual-auth-ecies/ecies/index.js","./ecies-doa-ds":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/pskcrypto/js-mutual-auth-ecies/ecies-doa-ds/index.js","./ecies-doa-kmac":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/pskcrypto/js-mutual-auth-ecies/ecies-doa-kmac/index.js","./ecies-group-encryption/ecies-ge-anon":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/pskcrypto/js-mutual-auth-ecies/ecies-group-encryption/ecies-ge-anon/index.js","./ecies-group-encryption/ecies-ge-doa":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/pskcrypto/js-mutual-auth-ecies/ecies-group-encryption/ecies-ge-doa/index.js","./ecies/index":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/pskcrypto/js-mutual-auth-ecies/ecies/index.js"}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/pskcrypto/jsonWebToken/decode.js":[function(require,module,exports){
var jws = require('./jws');

module.exports = function (jwt, options) {
    options = options || {};
    var decoded = jws.decode(jwt, options);
    if (!decoded) { return null; }
    var payload = decoded.payload;

    //try parse the payload
    if(typeof payload === 'string') {
        try {
            var obj = JSON.parse(payload);
            if(obj !== null && typeof obj === 'object') {
                payload = obj;
            }
        } catch (e) { }
    }

    //return header if `complete` option is enabled.  header includes claims
    //such as `kid` and `alg` used to select the key within a JWKS needed to
    //verify the signature
    if (options.complete === true) {
        return {
            header: decoded.header,
            payload: payload,
            signature: decoded.signature
        };
    }
    return payload;
};
},{"./jws":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/pskcrypto/jsonWebToken/jws/index.js"}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/pskcrypto/jsonWebToken/index.js":[function(require,module,exports){
module.exports = {
    verify: require('./verify'),
    sign: require('./sign'),
};

Object.defineProperty(module.exports, 'decode', {
    enumerable: false,
    value: require('./decode'),
});

},{"./decode":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/pskcrypto/jsonWebToken/decode.js","./sign":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/pskcrypto/jsonWebToken/sign.js","./verify":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/pskcrypto/jsonWebToken/verify.js"}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/pskcrypto/jsonWebToken/jwa/ecdsa-sig-formatter.js":[function(require,module,exports){
var getParamBytesForAlg = require('./param-bytes-for-alg');

var MAX_OCTET = 0x80,
    CLASS_UNIVERSAL = 0,
    PRIMITIVE_BIT = 0x20,
    TAG_SEQ = 0x10,
    TAG_INT = 0x02,
    ENCODED_TAG_SEQ = (TAG_SEQ | PRIMITIVE_BIT) | (CLASS_UNIVERSAL << 6),
    ENCODED_TAG_INT = TAG_INT | (CLASS_UNIVERSAL << 6);

function base64Url(base64) {
    return base64
        .replace(/=/g, '')
        .replace(/\+/g, '-')
        .replace(/\//g, '_');
}

function signatureAsBuffer(signature) {
    if ($$.Buffer.isBuffer(signature)) {
        return signature;
    } else if ('string' === typeof signature) {
        return $$.Buffer.from(signature, 'base64');
    }

    throw new TypeError('ECDSA signature must be a Base64 string or a $$.Buffer');
}

function derToJose(signature, alg) {
    signature = signatureAsBuffer(signature);
    var paramBytes = getParamBytesForAlg(alg);

    // the DER encoded param should at most be the param size, plus a padding
    // zero, since due to being a signed integer
    var maxEncodedParamLength = paramBytes + 1;

    var inputLength = signature.length;

    var offset = 0;
    if (signature[offset++] !== ENCODED_TAG_SEQ) {
        throw new Error('Could not find expected "seq"');
    }

    var seqLength = signature[offset++];
    if (seqLength === (MAX_OCTET | 1)) {
        seqLength = signature[offset++];
    }

    if (inputLength - offset < seqLength) {
        throw new Error('"seq" specified length of "' + seqLength + '", only "' + (inputLength - offset) + '" remaining');
    }

    if (signature[offset++] !== ENCODED_TAG_INT) {
        throw new Error('Could not find expected "int" for "r"');
    }

    var rLength = signature[offset++];

    if (inputLength - offset - 2 < rLength) {
        throw new Error('"r" specified length of "' + rLength + '", only "' + (inputLength - offset - 2) + '" available');
    }

    if (maxEncodedParamLength < rLength) {
        throw new Error('"r" specified length of "' + rLength + '", max of "' + maxEncodedParamLength + '" is acceptable');
    }

    var rOffset = offset;
    offset += rLength;

    if (signature[offset++] !== ENCODED_TAG_INT) {
        throw new Error('Could not find expected "int" for "s"');
    }

    var sLength = signature[offset++];

    if (inputLength - offset !== sLength) {
        throw new Error('"s" specified length of "' + sLength + '", expected "' + (inputLength - offset) + '"');
    }

    if (maxEncodedParamLength < sLength) {
        throw new Error('"s" specified length of "' + sLength + '", max of "' + maxEncodedParamLength + '" is acceptable');
    }

    var sOffset = offset;
    offset += sLength;

    if (offset !== inputLength) {
        throw new Error('Expected to consume entire buffer, but "' + (inputLength - offset) + '" bytes remain');
    }

    var rPadding = paramBytes - rLength,
        sPadding = paramBytes - sLength;

    var dst = $$.Buffer.allocUnsafe(rPadding + rLength + sPadding + sLength);

    for (offset = 0; offset < rPadding; ++offset) {
        dst[offset] = 0;
    }
    signature.copy(dst, offset, rOffset + Math.max(-rPadding, 0), rOffset + rLength);

    offset = paramBytes;

    for (var o = offset; offset < o + sPadding; ++offset) {
        dst[offset] = 0;
    }
    signature.copy(dst, offset, sOffset + Math.max(-sPadding, 0), sOffset + sLength);

    dst = dst.toString('base64');
    dst = base64Url(dst);

    return dst;
}

function countPadding(buf, start, stop) {
    var padding = 0;
    while (start + padding < stop && buf[start + padding] === 0) {
        ++padding;
    }

    var needsSign = buf[start + padding] >= MAX_OCTET;
    if (needsSign) {
        --padding;
    }

    return padding;
}

function joseToDer(signature, alg) {
    signature = signatureAsBuffer(signature);
    var paramBytes = getParamBytesForAlg(alg);

    var signatureBytes = signature.length;
    if (signatureBytes !== paramBytes * 2) {
        throw new TypeError('"' + alg + '" signatures must be "' + paramBytes * 2 + '" bytes, saw "' + signatureBytes + '"');
    }

    var rPadding = countPadding(signature, 0, paramBytes);
    var sPadding = countPadding(signature, paramBytes, signature.length);
    var rLength = paramBytes - rPadding;
    var sLength = paramBytes - sPadding;

    var rsBytes = 1 + 1 + rLength + 1 + 1 + sLength;

    var shortLength = rsBytes < MAX_OCTET;

    var dst = $$.Buffer.allocUnsafe((shortLength ? 2 : 3) + rsBytes);

    var offset = 0;
    dst[offset++] = ENCODED_TAG_SEQ;
    if (shortLength) {
        // Bit 8 has value "0"
        // bits 7-1 give the length.
        dst[offset++] = rsBytes;
    } else {
        // Bit 8 of first octet has value "1"
        // bits 7-1 give the number of additional length octets.
        dst[offset++] = MAX_OCTET	| 1;
        // length, base 256
        dst[offset++] = rsBytes & 0xff;
    }
    dst[offset++] = ENCODED_TAG_INT;
    dst[offset++] = rLength;
    if (rPadding < 0) {
        dst[offset++] = 0;
        offset += signature.copy(dst, offset, 0, paramBytes);
    } else {
        offset += signature.copy(dst, offset, rPadding, paramBytes);
    }
    dst[offset++] = ENCODED_TAG_INT;
    dst[offset++] = sLength;
    if (sPadding < 0) {
        dst[offset++] = 0;
        signature.copy(dst, offset, paramBytes);
    } else {
        signature.copy(dst, offset, paramBytes + sPadding);
    }

    return dst;
}

module.exports = {
    derToJose: derToJose,
    joseToDer: joseToDer
};
},{"./param-bytes-for-alg":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/pskcrypto/jsonWebToken/jwa/param-bytes-for-alg.js"}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/pskcrypto/jsonWebToken/jwa/index.js":[function(require,module,exports){
var crypto = require('crypto');
var formatEcdsa = require('./ecdsa-sig-formatter');
var util = require('util');

var MSG_INVALID_ALGORITHM = '"%s" is not a valid algorithm.\n  Supported algorithms are:\n  "HS256", "HS384", "HS512", "RS256", "RS384", "RS512", "PS256", "PS384", "PS512", "ES256", "ES384", "ES512" and "none".'
var MSG_INVALID_SECRET = 'secret must be a string or buffer';
var MSG_INVALID_VERIFIER_KEY = 'key must be a string or a buffer';
var MSG_INVALID_SIGNER_KEY = 'key must be a string, a buffer or an object';

var supportsKeyObjects = typeof crypto.createPublicKey === 'function';
if (supportsKeyObjects) {
    MSG_INVALID_VERIFIER_KEY += ' or a KeyObject';
    MSG_INVALID_SECRET += 'or a KeyObject';
}

function checkIsPublicKey(key) {
    if ($$.Buffer.isBuffer(key)) {
        return;
    }

    if (typeof key === 'string') {
        return;
    }

    if (!supportsKeyObjects) {
        throw typeError(MSG_INVALID_VERIFIER_KEY);
    }

    if (typeof key !== 'object') {
        throw typeError(MSG_INVALID_VERIFIER_KEY);
    }

    if (typeof key.type !== 'string') {
        throw typeError(MSG_INVALID_VERIFIER_KEY);
    }

    if (typeof key.asymmetricKeyType !== 'string') {
        throw typeError(MSG_INVALID_VERIFIER_KEY);
    }

    if (typeof key.export !== 'function') {
        throw typeError(MSG_INVALID_VERIFIER_KEY);
    }
};

function checkIsPrivateKey(key) {
    if ($$.Buffer.isBuffer(key)) {
        return;
    }

    if (typeof key === 'string') {
        return;
    }

    if (typeof key === 'object') {
        return;
    }

    throw typeError(MSG_INVALID_SIGNER_KEY);
};

function checkIsSecretKey(key) {
    if ($$.Buffer.isBuffer(key)) {
        return;
    }

    if (typeof key === 'string') {
        return key;
    }

    if (!supportsKeyObjects) {
        throw typeError(MSG_INVALID_SECRET);
    }

    if (typeof key !== 'object') {
        throw typeError(MSG_INVALID_SECRET);
    }

    if (key.type !== 'secret') {
        throw typeError(MSG_INVALID_SECRET);
    }

    if (typeof key.export !== 'function') {
        throw typeError(MSG_INVALID_SECRET);
    }
}

function fromBase64(base64) {
    return base64
        .replace(/=/g, '')
        .replace(/\+/g, '-')
        .replace(/\//g, '_');
}

function toBase64(base64url) {
    base64url = base64url.toString();

    var padding = 4 - base64url.length % 4;
    if (padding !== 4) {
        for (var i = 0; i < padding; ++i) {
            base64url += '=';
        }
    }

    return base64url
        .replace(/\-/g, '+')
        .replace(/_/g, '/');
}

function typeError(template) {
    var args = [].slice.call(arguments, 1);
    var errMsg = util.format.bind(util, template).apply(null, args);
    return new TypeError(errMsg);
}

function bufferOrString(obj) {
    return $$.Buffer.isBuffer(obj) || typeof obj === 'string';
}

function normalizeInput(thing) {
    if (!bufferOrString(thing))
        thing = JSON.stringify(thing);
    return thing;
}

function createHmacSigner(bits) {
    return function sign(thing, secret) {
        checkIsSecretKey(secret);
        thing = normalizeInput(thing);
        var hmac = crypto.createHmac('sha' + bits, secret);
        var sig = (hmac.update(thing), hmac.digest('base64'))
        return fromBase64(sig);
    }
}

function createHmacVerifier(bits) {
    return function verify(thing, signature, secret) {
        var computedSig = createHmacSigner(bits)(thing, secret);
        return $$.Buffer.from(signature).equals($$.Buffer.from(computedSig));
    }
}

function createKeySigner(bits) {
    return function sign(thing, privateKey) {
        checkIsPrivateKey(privateKey);
        thing = normalizeInput(thing);
        // Even though we are specifying "RSA" here, this works with ECDSA
        // keys as well.
        var signer = crypto.createSign('RSA-SHA' + bits);
        var sig = (signer.update(thing), signer.sign(privateKey, 'base64'));
        return fromBase64(sig);
    }
}

function createKeyVerifier(bits) {
    return function verify(thing, signature, publicKey) {
        checkIsPublicKey(publicKey);
        thing = normalizeInput(thing);
        signature = toBase64(signature);
        var verifier = crypto.createVerify('RSA-SHA' + bits);
        verifier.update(thing);
        return verifier.verify(publicKey, signature, 'base64');
    }
}

function createPSSKeySigner(bits) {
    return function sign(thing, privateKey) {
        checkIsPrivateKey(privateKey);
        thing = normalizeInput(thing);
        var signer = crypto.createSign('RSA-SHA' + bits);
        var sig = (signer.update(thing), signer.sign({
            key: privateKey,
            padding: crypto.constants.RSA_PKCS1_PSS_PADDING,
            saltLength: crypto.constants.RSA_PSS_SALTLEN_DIGEST
        }, 'base64'));
        return fromBase64(sig);
    }
}

function createPSSKeyVerifier(bits) {
    return function verify(thing, signature, publicKey) {
        checkIsPublicKey(publicKey);
        thing = normalizeInput(thing);
        signature = toBase64(signature);
        var verifier = crypto.createVerify('RSA-SHA' + bits);
        verifier.update(thing);
        return verifier.verify({
            key: publicKey,
            padding: crypto.constants.RSA_PKCS1_PSS_PADDING,
            saltLength: crypto.constants.RSA_PSS_SALTLEN_DIGEST
        }, signature, 'base64');
    }
}

function createECDSASigner(bits) {
    var inner = createKeySigner(bits);
    return function sign() {
        var signature = inner.apply(null, arguments);
        signature = formatEcdsa.derToJose(signature, 'ES' + bits);
        return signature;
    };
}

function createECDSAVerifer(bits) {
    var inner = createKeyVerifier(bits);
    return function verify(thing, signature, publicKey) {
        signature = formatEcdsa.joseToDer(signature, 'ES' + bits).toString('base64');
        var result = inner(thing, signature, publicKey);
        return result;
    };
}

function createNoneSigner() {
    return function sign() {
        return '';
    }
}

function createNoneVerifier() {
    return function verify(thing, signature) {
        return signature === '';
    }
}

module.exports = function jwa(algorithm) {
    var signerFactories = {
        hs: createHmacSigner,
        rs: createKeySigner,
        ps: createPSSKeySigner,
        es: createECDSASigner,
        none: createNoneSigner,
    }
    var verifierFactories = {
        hs: createHmacVerifier,
        rs: createKeyVerifier,
        ps: createPSSKeyVerifier,
        es: createECDSAVerifer,
        none: createNoneVerifier,
    }
    var match = algorithm.match(/^(RS|PS|ES|HS)(256|384|512)$|^(none)$/);
    if (!match)
        throw typeError(MSG_INVALID_ALGORITHM, algorithm);
    var algo = (match[1] || match[3]).toLowerCase();
    var bits = match[2];

    return {
        sign: signerFactories[algo](bits),
        verify: verifierFactories[algo](bits),
    }
};
},{"./ecdsa-sig-formatter":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/pskcrypto/jsonWebToken/jwa/ecdsa-sig-formatter.js","crypto":false,"util":false}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/pskcrypto/jsonWebToken/jwa/param-bytes-for-alg.js":[function(require,module,exports){
'use strict';

function getParamSize(keySize) {
    var result = ((keySize / 8) | 0) + (keySize % 8 === 0 ? 0 : 1);
    return result;
}

var paramBytesForAlg = {
    ES256: getParamSize(256),
    ES384: getParamSize(384),
    ES512: getParamSize(521)
};

function getParamBytesForAlg(alg) {
    var paramBytes = paramBytesForAlg[alg];
    if (paramBytes) {
        return paramBytes;
    }

    throw new Error('Unknown algorithm "' + alg + '"');
}

module.exports = getParamBytesForAlg;
},{}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/pskcrypto/jsonWebToken/jwkToPemConverter/factor.js":[function(require,module,exports){
var asn = require('../../lib/asn1/asn1');
var crypto = require('crypto')
var BN = asn.bignum

var zero = new BN(0)
var one = new BN(1)
var two = new BN(2)

function rand(low, high) {
    do {
        var b = new BN(crypto.randomBytes(high.byteLength()))
    } while(b.cmp(low) <= 0 || b.cmp(high) >= 0)
    return b
}

function odd(n) {
    if (n.cmp(zero) === 0) { return zero }
    var r = n
    while (r.isEven()) {
        r = r.div(two)
    }
    return r
}

function rootOne(x, r, n) {
    var i = x.toRed(BN.red(n)).redPow(r).fromRed()
    var o = zero
    while (i.cmp(one) !== 0) {
        o = i
        i = i.mul(i).mod(n)
    }
    if (o.cmp(n.sub(one)) === 0) {
        return zero
    }
    return o
}

function factor(e, d, n) {
    var k = e.mul(d).sub(one)
    var r = odd(k)
    do {
        var y = rootOne(rand(two, n), r, n)
    } while (y.cmp(zero) === 0)

    var p = y.sub(one).gcd(n)
    return {
        p: p,
        q: n.div(p)
    }
}

module.exports = factor
},{"../../lib/asn1/asn1":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/pskcrypto/lib/asn1/asn1.js","crypto":false}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/pskcrypto/jsonWebToken/jwkToPemConverter/index.js":[function(require,module,exports){
(function (Buffer){(function (){
var asn = require('../../lib/asn1/asn1')
var factor = require('./factor')
var one = new asn.bignum(1)

function urlize(base64) {
    return base64.replace(/\+/g, '-')
        .replace(/\//g, '_')
        .replace(/=/g, '')
}

function hex2b64url(str) {
    return urlize(Buffer.from(str, 'hex').toString('base64'))
}

function fromPEM(data) {
    var text = data.toString().split(/(\r\n|\r|\n)+/g);
    text = text.filter(function(line) {
        return line.trim().length !== 0;
    });
    text = text.slice(1, -1).join('');
    return Buffer.from(text.replace(/[^\w\d\+\/=]+/g, ''), 'base64');
}

var RSAPublicKey = asn.define('RSAPublicKey', function () {
    this.seq().obj(
        this.key('n').int(),
        this.key('e').int()
    )
})

var AlgorithmIdentifier = asn.define('AlgorithmIdentifier', function () {
    this.seq().obj(
        this.key('algorithm').objid(),
        this.key('parameters').optional().any()
    )
})

var PublicKeyInfo = asn.define('PublicKeyInfo', function () {
    this.seq().obj(
        this.key('algorithm').use(AlgorithmIdentifier),
        this.key('publicKey').bitstr()
    )
})

var Version = asn.define('Version', function () {
    this.int({
        0: 'two-prime',
        1: 'multi'
    })
})

var OtherPrimeInfos = asn.define('OtherPrimeInfos', function () {
    this.seq().obj(
        this.key('ri').int(),
        this.key('di').int(),
        this.key('ti').int()
    )
})

var RSAPrivateKey = asn.define('RSAPrivateKey', function () {
    this.seq().obj(
        this.key('version').use(Version),
        this.key('n').int(),
        this.key('e').int(),
        this.key('d').int(),
        this.key('p').int(),
        this.key('q').int(),
        this.key('dp').int(),
        this.key('dq').int(),
        this.key('qi').int(),
        this.key('other').optional().use(OtherPrimeInfos)
    )
})

var PrivateKeyInfo = asn.define('PrivateKeyInfo', function () {
    this.seq().obj(
        this.key('version').use(Version),
        this.key('algorithm').use(AlgorithmIdentifier),
        this.key('privateKey').bitstr()
    )
})

const RSA_OID = '1.2.840.113549.1.1.1'

function addExtras(obj, extras) {
    extras = extras || {}
    Object.keys(extras).forEach(
        function (key) {
            obj[key] = extras[key]
        }
    )
    return obj
}

function pad(hex) {
    return (hex.length % 2 === 1) ? '0' + hex : hex
}

function decodeRsaPublic(buffer, extras) {
    var key = RSAPublicKey.decode(buffer, 'der')
    var e = pad(key.e.toString(16))
    var jwk = {
        kty: 'RSA',
        n: bn2base64url(key.n),
        e: hex2b64url(e)
    }
    return addExtras(jwk, extras)
}

function decodeRsaPrivate(buffer, extras) {
    var key = RSAPrivateKey.decode(buffer, 'der')
    var e = pad(key.e.toString(16))
    var jwk = {
        kty: 'RSA',
        n: bn2base64url(key.n),
        e: hex2b64url(e),
        d: bn2base64url(key.d),
        p: bn2base64url(key.p),
        q: bn2base64url(key.q),
        dp: bn2base64url(key.dp),
        dq: bn2base64url(key.dq),
        qi: bn2base64url(key.qi)
    }
    return addExtras(jwk, extras)
}

function decodePublic(buffer, extras) {
    var info = PublicKeyInfo.decode(buffer, 'der')
    return decodeRsaPublic(info.publicKey.data, extras)
}

function decodePrivate(buffer, extras) {
    var info = PrivateKeyInfo.decode(buffer, 'der')
    return decodeRsaPrivate(info.privateKey.data, extras)
}

function getDecoder(header) {
    var match = /^-----BEGIN (RSA )?(PUBLIC|PRIVATE) KEY-----$/.exec(header)
    if (!match) { return null }
    var isRSA = !!(match[1])
    var isPrivate = (match[2] === 'PRIVATE')
    if (isPrivate) {
        return isRSA ? decodeRsaPrivate : decodePrivate
    }
    else {
        return isRSA ? decodeRsaPublic : decodePublic
    }
}

function pem2jwk(pem, extras) {
    var text = pem.toString().split(/(\r\n|\r|\n)+/g)
    text = text.filter(function(line) {
        return line.trim().length !== 0
    });
    var decoder = getDecoder(text[0])

    text = text.slice(1, -1).join('')
    return decoder(Buffer.from(text.replace(/[^\w\d\+\/=]+/g, ''), 'base64'), extras)
}

function recomputePrimes(jwk) {
    var pq = factor(jwk.e, jwk.d, jwk.n)
    var p = pq.p
    var q = pq.q
    var dp = jwk.d.mod(p.sub(one))
    var dq = jwk.d.mod(q.sub(one))
    var qi = q.invm(p)
    return {
        n: jwk.n,
        e: jwk.e,
        d: jwk.d,
        p: p,
        q: q,
        dp: dp,
        dq: dq,
        qi: qi
    }
}

function parse(jwk) {
    return {
        n: string2bn(jwk.n),
        e: string2bn(jwk.e),
        d: jwk.d && string2bn(jwk.d),
        p: jwk.p && string2bn(jwk.p),
        q: jwk.q && string2bn(jwk.q),
        dp: jwk.dp && string2bn(jwk.dp),
        dq: jwk.dq && string2bn(jwk.dq),
        qi: jwk.qi && string2bn(jwk.qi)
    }
}

function jwk2pem(json) {
    var jwk = parse(json)
    var isPrivate = !!(jwk.d)
    var t = isPrivate ? 'PRIVATE' : 'PUBLIC'
    var header = '-----BEGIN RSA ' + t + ' KEY-----\n'
    var footer = '\n-----END RSA ' + t + ' KEY-----\n'
    var data = null
    if (isPrivate) {
        if (!jwk.p) {
            jwk = recomputePrimes(jwk)
        }
        jwk.version = 'two-prime'
        data = RSAPrivateKey.encode(jwk, 'der')
    }
    else {
        data = RSAPublicKey.encode(jwk, 'der')
    }
    var body = data.toString('base64').match(/.{1,64}/g).join('\n')
    return header + body + footer
}

function bn2base64url(bn) {
    return hex2b64url(pad(bn.toString(16)))
}

function base64url2bn(str) {
    return new asn.bignum(Buffer.from(str, 'base64'))
}

function string2bn(str) {
    if (/^[0-9]+$/.test(str)) {
        return new asn.bignum(str, 10)
    }
    return base64url2bn(str)
}

module.exports = {
    pem2jwk: pem2jwk,
    jwk2pem: jwk2pem,
    BN: asn.bignum
}
}).call(this)}).call(this,require("buffer").Buffer)

},{"../../lib/asn1/asn1":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/pskcrypto/lib/asn1/asn1.js","./factor":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/pskcrypto/jsonWebToken/jwkToPemConverter/factor.js","buffer":false}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/pskcrypto/jsonWebToken/jws/data-stream.js":[function(require,module,exports){
/*global module, process*/
var Stream = require('stream');
var util = require('util');

function DataStream(data) {
    this.buffer = null;
    this.writable = true;
    this.readable = true;

    // No input
    if (!data) {
        this.buffer = $$.Buffer.alloc(0);
        return this;
    }

    // Stream
    if (typeof data.pipe === 'function') {
        this.buffer = $$.Buffer.alloc(0);
        data.pipe(this);
        return this;
    }

    // $$.Buffer or String
    // or Object (assumedly a passworded key)
    if (data.length || typeof data === 'object') {
        this.buffer = data;
        this.writable = false;
        process.nextTick(function () {
            this.emit('end', data);
            this.readable = false;
            this.emit('close');
        }.bind(this));
        return this;
    }

    throw new TypeError('Unexpected data type ('+ typeof data + ')');
}
util.inherits(DataStream, Stream);

DataStream.prototype.write = function write(data) {
    this.buffer = $$.Buffer.concat([this.buffer, $$.Buffer.from(data)]);
    this.emit('data', data);
};

DataStream.prototype.end = function end(data) {
    if (data)
        this.write(data);
    this.emit('end', data);
    this.emit('close');
    this.writable = false;
    this.readable = false;
};

module.exports = DataStream;
},{"stream":false,"util":false}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/pskcrypto/jsonWebToken/jws/index.js":[function(require,module,exports){
/*global exports*/
var SignStream = require('./sign-stream');
var VerifyStream = require('./verify-stream');

var ALGORITHMS = [
    'HS256', 'HS384', 'HS512',
    'RS256', 'RS384', 'RS512',
    'PS256', 'PS384', 'PS512',
    'ES256', 'ES384', 'ES512'
];

exports.ALGORITHMS = ALGORITHMS;
exports.sign = SignStream.sign;
exports.verify = VerifyStream.verify;
exports.decode = VerifyStream.decode;
exports.isValid = VerifyStream.isValid;
exports.createSign = function createSign(opts) {
    return new SignStream(opts);
};
exports.createVerify = function createVerify(opts) {
    return new VerifyStream(opts);
};
},{"./sign-stream":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/pskcrypto/jsonWebToken/jws/sign-stream.js","./verify-stream":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/pskcrypto/jsonWebToken/jws/verify-stream.js"}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/pskcrypto/jsonWebToken/jws/sign-stream.js":[function(require,module,exports){
var DataStream = require('./data-stream');
var jwa = require('../jwa');
var Stream = require('stream');
var toString = require('./tostring');
var util = require('util');

function base64url(string, encoding) {
    return $$.Buffer
        .from(string, encoding)
        .toString('base64')
        .replace(/=/g, '')
        .replace(/\+/g, '-')
        .replace(/\//g, '_');
}

function jwsSecuredInput(header, payload, encoding) {
    encoding = encoding || 'utf8';
    var encodedHeader = base64url(toString(header), 'binary');
    var encodedPayload = base64url(toString(payload), encoding);
    return util.format('%s.%s', encodedHeader, encodedPayload);
}

function jwsSign(opts) {
    var header = opts.header;
    var payload = opts.payload;
    var secretOrKey = opts.secret || opts.privateKey;
    var encoding = opts.encoding;
    var algo = jwa(header.alg);
    var securedInput = jwsSecuredInput(header, payload, encoding);
    var signature = algo.sign(securedInput, secretOrKey);
    return util.format('%s.%s', securedInput, signature);
}

function SignStream(opts) {
    var secret = opts.secret||opts.privateKey||opts.key;
    var secretStream = new DataStream(secret);
    this.readable = true;
    this.header = opts.header;
    this.encoding = opts.encoding;
    this.secret = this.privateKey = this.key = secretStream;
    this.payload = new DataStream(opts.payload);
    this.secret.once('close', function () {
        if (!this.payload.writable && this.readable)
            this.sign();
    }.bind(this));

    this.payload.once('close', function () {
        if (!this.secret.writable && this.readable)
            this.sign();
    }.bind(this));
}
util.inherits(SignStream, Stream);

SignStream.prototype.sign = function sign() {
    try {
        var signature = jwsSign({
            header: this.header,
            payload: this.payload.buffer,
            secret: this.secret.buffer,
            encoding: this.encoding
        });
        this.emit('done', signature);
        this.emit('data', signature);
        this.emit('end');
        this.readable = false;
        return signature;
    } catch (e) {
        this.readable = false;
        this.emit('error', e);
        this.emit('close');
    }
};

SignStream.sign = jwsSign;

module.exports = SignStream;
},{"../jwa":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/pskcrypto/jsonWebToken/jwa/index.js","./data-stream":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/pskcrypto/jsonWebToken/jws/data-stream.js","./tostring":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/pskcrypto/jsonWebToken/jws/tostring.js","stream":false,"util":false}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/pskcrypto/jsonWebToken/jws/tostring.js":[function(require,module,exports){
module.exports = function toString(obj) {
    if (typeof obj === 'string')
        return obj;
    if (typeof obj === 'number' || $$.Buffer.isBuffer(obj))
        return obj.toString();
    return JSON.stringify(obj);
};
},{}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/pskcrypto/jsonWebToken/jws/verify-stream.js":[function(require,module,exports){
/*global module*/
var DataStream = require('./data-stream');
var jwa = require('../jwa');
var Stream = require('stream');
var toString = require('./tostring');
var util = require('util');
var JWS_REGEX = /^[a-zA-Z0-9\-_]+?\.[a-zA-Z0-9\-_]+?\.([a-zA-Z0-9\-_]+)?$/;

function isObject(thing) {
    return Object.prototype.toString.call(thing) === '[object Object]';
}

function safeJsonParse(thing) {
    if (isObject(thing))
        return thing;
    try { return JSON.parse(thing); }
    catch (e) { return undefined; }
}

function headerFromJWS(jwsSig) {
    var encodedHeader = jwsSig.split('.', 1)[0];
    return safeJsonParse($$.Buffer.from(encodedHeader, 'base64').toString('binary'));
}

function securedInputFromJWS(jwsSig) {
    return jwsSig.split('.', 2).join('.');
}

function signatureFromJWS(jwsSig) {
    return jwsSig.split('.')[2];
}

function payloadFromJWS(jwsSig, encoding) {
    encoding = encoding || 'utf8';
    var payload = jwsSig.split('.')[1];
    return $$.Buffer.from(payload, 'base64').toString(encoding);
}

function isValidJws(string) {
    return JWS_REGEX.test(string) && !!headerFromJWS(string);
}

function jwsVerify(jwsSig, algorithm, secretOrKey) {
    if (!algorithm) {
        var err = new Error("Missing algorithm parameter for jws.verify");
        err.code = "MISSING_ALGORITHM";
        throw err;
    }
    jwsSig = toString(jwsSig);
    var signature = signatureFromJWS(jwsSig);
    var securedInput = securedInputFromJWS(jwsSig);
    var algo = jwa(algorithm);
    return algo.verify(securedInput, signature, secretOrKey);
}

function jwsDecode(jwsSig, opts) {
    opts = opts || {};
    jwsSig = toString(jwsSig);

    if (!isValidJws(jwsSig))
        return null;

    var header = headerFromJWS(jwsSig);

    if (!header)
        return null;

    var payload = payloadFromJWS(jwsSig);
    if (header.typ === 'JWT' || opts.json)
        payload = JSON.parse(payload, opts.encoding);

    return {
        header: header,
        payload: payload,
        signature: signatureFromJWS(jwsSig)
    };
}

function VerifyStream(opts) {
    opts = opts || {};
    var secretOrKey = opts.secret||opts.publicKey||opts.key;
    var secretStream = new DataStream(secretOrKey);
    this.readable = true;
    this.algorithm = opts.algorithm;
    this.encoding = opts.encoding;
    this.secret = this.publicKey = this.key = secretStream;
    this.signature = new DataStream(opts.signature);
    this.secret.once('close', function () {
        if (!this.signature.writable && this.readable)
            this.verify();
    }.bind(this));

    this.signature.once('close', function () {
        if (!this.secret.writable && this.readable)
            this.verify();
    }.bind(this));
}
util.inherits(VerifyStream, Stream);
VerifyStream.prototype.verify = function verify() {
    try {
        var valid = jwsVerify(this.signature.buffer, this.algorithm, this.key.buffer);
        var obj = jwsDecode(this.signature.buffer, this.encoding);
        this.emit('done', valid, obj);
        this.emit('data', valid);
        this.emit('end');
        this.readable = false;
        return valid;
    } catch (e) {
        this.readable = false;
        this.emit('error', e);
        this.emit('close');
    }
};

VerifyStream.decode = jwsDecode;
VerifyStream.isValid = isValidJws;
VerifyStream.verify = jwsVerify;

module.exports = VerifyStream;
},{"../jwa":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/pskcrypto/jsonWebToken/jwa/index.js","./data-stream":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/pskcrypto/jsonWebToken/jws/data-stream.js","./tostring":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/pskcrypto/jsonWebToken/jws/tostring.js","stream":false,"util":false}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/pskcrypto/jsonWebToken/lib/JsonWebTokenError.js":[function(require,module,exports){
var JsonWebTokenError = function (message, error) {
    Error.call(this, message);
    if(Error.captureStackTrace) {
        Error.captureStackTrace(this, this.constructor);
    }
    this.name = 'JsonWebTokenError';
    this.message = message;
    if (error) this.inner = error;
};

JsonWebTokenError.prototype = Object.create(Error.prototype);
JsonWebTokenError.prototype.constructor = JsonWebTokenError;

module.exports = JsonWebTokenError;
},{}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/pskcrypto/jsonWebToken/lib/NotBeforeError.js":[function(require,module,exports){
var JsonWebTokenError = require('./JsonWebTokenError');

var NotBeforeError = function (message, date) {
    JsonWebTokenError.call(this, message);
    this.name = 'NotBeforeError';
    this.date = date;
};

NotBeforeError.prototype = Object.create(JsonWebTokenError.prototype);

NotBeforeError.prototype.constructor = NotBeforeError;

module.exports = NotBeforeError;
},{"./JsonWebTokenError":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/pskcrypto/jsonWebToken/lib/JsonWebTokenError.js"}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/pskcrypto/jsonWebToken/lib/TokenExpiredError.js":[function(require,module,exports){
var JsonWebTokenError = require('./JsonWebTokenError');

var TokenExpiredError = function (message, expiredAt) {
    JsonWebTokenError.call(this, message);
    this.name = 'TokenExpiredError';
    this.expiredAt = expiredAt;
};

TokenExpiredError.prototype = Object.create(JsonWebTokenError.prototype);

TokenExpiredError.prototype.constructor = TokenExpiredError;

module.exports = TokenExpiredError;
},{"./JsonWebTokenError":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/pskcrypto/jsonWebToken/lib/JsonWebTokenError.js"}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/pskcrypto/jsonWebToken/lib/timespan.js":[function(require,module,exports){
module.exports = function (time, iat) {
    var timestamp = iat || Math.floor(Date.now() / 1000);

    if (typeof time === 'number') {
        return timestamp + time;
    } else {
        return;
    }

};
},{}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/pskcrypto/jsonWebToken/sign.js":[function(require,module,exports){
(function (Buffer){(function (){
var timespan = require('./lib/timespan');
var jws = require('./jws');

var options_to_payload = {
    'audience': 'aud',
    'issuer': 'iss',
    'subject': 'sub',
    'jwtid': 'jti'
};

var options_for_objects = [
    'expiresIn',
    'notBefore',
    'noTimestamp',
    'audience',
    'issuer',
    'subject',
    'jwtid',
];

module.exports = function (payload, secretOrPrivateKey, options, callback) {
    if (typeof options === 'function') {
        callback = options;
        options = {};
    } else {
        options = options || {};
    }

    var isObjectPayload = typeof payload === 'object' &&
        !Buffer.isBuffer(payload);

    var header = Object.assign({
        alg: options.algorithm || 'HS256',
        typ: isObjectPayload ? 'JWT' : undefined,
        kid: options.keyid
    }, options.header);

    function failure(err) {
        if (callback) {
            return callback(err);
        }
        throw err;
    }

    if (!secretOrPrivateKey && options.algorithm !== 'none') {
        return failure(new Error('secretOrPrivateKey must have a value'));
    }

    if (typeof payload === 'undefined') {
        return failure(new Error('payload is required'));
    } else if (isObjectPayload) {
        if (!options.mutatePayload) {
            payload = Object.assign({},payload);
        }
    } else {
        var invalid_options = options_for_objects.filter(function (opt) {
            return typeof options[opt] !== 'undefined';
        });

        if (invalid_options.length > 0) {
            return failure(new Error('invalid ' + invalid_options.join(',') + ' option for ' + (typeof payload ) + ' payload'));
        }
    }

    if (typeof payload.exp !== 'undefined' && typeof options.expiresIn !== 'undefined') {
        return failure(new Error('Bad "options.expiresIn" option the payload already has an "exp" property.'));
    }

    if (typeof payload.nbf !== 'undefined' && typeof options.notBefore !== 'undefined') {
        return failure(new Error('Bad "options.notBefore" option the payload already has an "nbf" property.'));
    }

    var timestamp = payload.iat || Math.floor(Date.now() / 1000);

    if (options.noTimestamp) {
        delete payload.iat;
    } else if (isObjectPayload) {
        payload.iat = timestamp;
    }

    if (typeof options.notBefore !== 'undefined') {
        try {
            payload.nbf = timespan(options.notBefore, timestamp);
        }
        catch (err) {
            return failure(err);
        }
        if (typeof payload.nbf === 'undefined') {
            return failure(new Error('"notBefore" should be a number of seconds or string representing a timespan eg: "1d", "20h", 60'));
        }
    }

    if (typeof options.expiresIn !== 'undefined' && typeof payload === 'object') {
        try {
            payload.exp = timespan(options.expiresIn, timestamp);
        }
        catch (err) {
            return failure(err);
        }
        if (typeof payload.exp === 'undefined') {
            return failure(new Error('"expiresIn" should be a number of seconds or string representing a timespan eg: "1d", "20h", 60'));
        }
    }

    Object.keys(options_to_payload).forEach(function (key) {
        var claim = options_to_payload[key];
        if (typeof options[key] !== 'undefined') {
            if (typeof payload[claim] !== 'undefined') {
                return failure(new Error('Bad "options.' + key + '" option. The payload already has an "' + claim + '" property.'));
            }
            payload[claim] = options[key];
        }
    });

    var encoding = options.encoding || 'utf8';

    if (typeof callback === 'function') {
        jws.createSign({
            header: header,
            privateKey: secretOrPrivateKey,
            payload: payload,
            encoding: encoding
        }).once('error', callback)
            .once('done', function (signature) {
                callback(null, signature);
            });
    } else {
        return jws.sign({header: header, payload: payload, secret: secretOrPrivateKey, encoding: encoding});
    }
};
}).call(this)}).call(this,{"isBuffer":require("../../../node_modules/is-buffer/index.js")})

},{"../../../node_modules/is-buffer/index.js":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/node_modules/is-buffer/index.js","./jws":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/pskcrypto/jsonWebToken/jws/index.js","./lib/timespan":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/pskcrypto/jsonWebToken/lib/timespan.js"}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/pskcrypto/jsonWebToken/verify.js":[function(require,module,exports){
var JsonWebTokenError = require('./lib/JsonWebTokenError');
var NotBeforeError = require('./lib/NotBeforeError');
var TokenExpiredError = require('./lib/TokenExpiredError');
var decode = require('./decode');
var timespan = require('./lib/timespan');
const jwkToPemConverter = require("./jwkToPemConverter");
var jws = require('./jws');

var PUB_KEY_ALGS = ['RS256', 'RS384', 'RS512', 'ES256', 'ES384', 'ES512'];
var RSA_KEY_ALGS = ['RS256', 'RS384', 'RS512'];
var HS_ALGS = ['HS256', 'HS384', 'HS512'];


PUB_KEY_ALGS.splice(3, 0, 'PS256', 'PS384', 'PS512');
RSA_KEY_ALGS.splice(3, 0, 'PS256', 'PS384', 'PS512');


module.exports = function (jwtString, secretOrPublicKey, options, callback) {
    if ((typeof options === 'function') && !callback) {
        callback = options;
        options = {};
    }

    if (!options) {
        options = {};
    }

    //clone this object since we are going to mutate it.
    options = Object.assign({}, options);

    secretOrPublicKey = jwkToPemConverter.jwk2pem(secretOrPublicKey);
    var done;

    if (callback) {
        done = callback;
    } else {
        done = function (err, data) {
            if (err) throw err;
            return data;
        };
    }

    if (options.clockTimestamp && typeof options.clockTimestamp !== 'number') {
        return done(new JsonWebTokenError('clockTimestamp must be a number'));
    }

    if (options.nonce !== undefined && (typeof options.nonce !== 'string' || options.nonce.trim() === '')) {
        return done(new JsonWebTokenError('nonce must be a non-empty string'));
    }

    var clockTimestamp = options.clockTimestamp || Math.floor(Date.now() / 1000);

    if (!jwtString) {
        return done(new JsonWebTokenError('jwt must be provided'));
    }

    if (typeof jwtString !== 'string') {
        return done(new JsonWebTokenError('jwt must be a string'));
    }

    var parts = jwtString.split('.');

    if (parts.length !== 3) {
        return done(new JsonWebTokenError('jwt malformed'));
    }

    var decodedToken;

    try {
        decodedToken = decode(jwtString, {complete: true});
    } catch (err) {
        return done(err);
    }

    if (!decodedToken) {
        return done(new JsonWebTokenError('invalid token'));
    }

    var header = decodedToken.header;
    var getSecret;

    if (typeof secretOrPublicKey === 'function') {
        if (!callback) {
            return done(new JsonWebTokenError('verify must be called asynchronous if secret or public key is provided as a callback'));
        }

        getSecret = secretOrPublicKey;
    } else {
        getSecret = function (header, secretCallback) {
            return secretCallback(null, secretOrPublicKey);
        };
    }

    return getSecret(header, function (err, secretOrPublicKey) {
        if (err) {
            return done(new JsonWebTokenError('error in secret or public key callback: ' + err.message));
        }

        var hasSignature = parts[2].trim() !== '';

        if (!hasSignature && secretOrPublicKey) {
            return done(new JsonWebTokenError('jwt signature is required'));
        }

        if (hasSignature && !secretOrPublicKey) {
            return done(new JsonWebTokenError('secret or public key must be provided'));
        }

        if (!hasSignature && !options.algorithms) {
            options.algorithms = ['none'];
        }

        if (!options.algorithms) {
            options.algorithms = secretOrPublicKey.toString().includes('BEGIN CERTIFICATE') ||
            secretOrPublicKey.toString().includes('BEGIN PUBLIC KEY') ? PUB_KEY_ALGS :
                secretOrPublicKey.toString().includes('BEGIN RSA PUBLIC KEY') ? RSA_KEY_ALGS : HS_ALGS;

        }

        if (!~options.algorithms.indexOf(decodedToken.header.alg)) {
            return done(new JsonWebTokenError('invalid algorithm'));
        }

        var valid;

        try {
            valid = jws.verify(jwtString, decodedToken.header.alg, secretOrPublicKey);
        } catch (e) {
            return done(e);
        }

        if (!valid) {
            return done(new JsonWebTokenError('invalid signature'));
        }

        var payload = decodedToken.payload;

        if (typeof payload.nbf !== 'undefined' && !options.ignoreNotBefore) {
            if (typeof payload.nbf !== 'number') {
                return done(new JsonWebTokenError('invalid nbf value'));
            }
            if (payload.nbf > clockTimestamp + (options.clockTolerance || 0)) {
                return done(new NotBeforeError('jwt not active', new Date(payload.nbf * 1000)));
            }
        }

        if (typeof payload.exp !== 'undefined' && !options.ignoreExpiration) {
            if (typeof payload.exp !== 'number') {
                return done(new JsonWebTokenError('invalid exp value'));
            }
            if (clockTimestamp >= payload.exp + (options.clockTolerance || 0)) {
                return done(new TokenExpiredError('jwt expired', new Date(payload.exp * 1000)));
            }
        }

        if (options.audience) {
            var audiences = Array.isArray(options.audience) ? options.audience : [options.audience];
            var target = Array.isArray(payload.aud) ? payload.aud : [payload.aud];

            var match = target.some(function (targetAudience) {
                return audiences.some(function (audience) {
                    return audience instanceof RegExp ? audience.test(targetAudience) : audience === targetAudience;
                });
            });

            if (!match) {
                return done(new JsonWebTokenError('jwt audience invalid. expected: ' + audiences.join(' or ')));
            }
        }

        if (options.issuer) {
            var invalid_issuer =
                (typeof options.issuer === 'string' && payload.iss !== options.issuer) ||
                (Array.isArray(options.issuer) && options.issuer.indexOf(payload.iss) === -1);

            if (invalid_issuer) {
                return done(new JsonWebTokenError('jwt issuer invalid. expected: ' + options.issuer));
            }
        }

        if (options.subject) {
            if (payload.sub !== options.subject) {
                return done(new JsonWebTokenError('jwt subject invalid. expected: ' + options.subject));
            }
        }

        if (options.jwtid) {
            if (payload.jti !== options.jwtid) {
                return done(new JsonWebTokenError('jwt jwtid invalid. expected: ' + options.jwtid));
            }
        }

        if (options.nonce) {
            if (payload.nonce !== options.nonce) {
                return done(new JsonWebTokenError('jwt nonce invalid. expected: ' + options.nonce));
            }
        }

        if (options.maxAge) {
            if (typeof payload.iat !== 'number') {
                return done(new JsonWebTokenError('iat required when maxAge is specified'));
            }

            var maxAgeTimestamp = timespan(options.maxAge, payload.iat);
            if (typeof maxAgeTimestamp === 'undefined') {
                return done(new JsonWebTokenError('"maxAge" should be a number of seconds or string representing a timespan eg: "1d", "20h", 60'));
            }
            if (clockTimestamp >= maxAgeTimestamp + (options.clockTolerance || 0)) {
                return done(new TokenExpiredError('maxAge exceeded', new Date(maxAgeTimestamp * 1000)));
            }
        }

        if (options.complete === true) {
            var signature = decodedToken.signature;

            return done(null, {
                header: header,
                payload: payload,
                signature: signature
            });
        }

        return done(null, payload);
    });
};
},{"./decode":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/pskcrypto/jsonWebToken/decode.js","./jwkToPemConverter":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/pskcrypto/jsonWebToken/jwkToPemConverter/index.js","./jws":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/pskcrypto/jsonWebToken/jws/index.js","./lib/JsonWebTokenError":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/pskcrypto/jsonWebToken/lib/JsonWebTokenError.js","./lib/NotBeforeError":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/pskcrypto/jsonWebToken/lib/NotBeforeError.js","./lib/TokenExpiredError":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/pskcrypto/jsonWebToken/lib/TokenExpiredError.js","./lib/timespan":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/pskcrypto/jsonWebToken/lib/timespan.js"}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/pskcrypto/lib/ECKeyGenerator.js":[function(require,module,exports){
const utils = require("./utils/cryptoUtils");

function ECKeyGenerator() {
    const crypto = require('crypto');
    const KeyEncoder = require('./keyEncoder');
    const utils = require("./utils/cryptoUtils");
    this.generateKeyPair = (namedCurve, callback) => {
        if (typeof namedCurve === "undefined") {
            callback = undefined;
            namedCurve = 'secp256k1';
        } else {
            if (typeof namedCurve === "function") {
                callback = namedCurve;
                namedCurve = 'secp256k1';
            }
        }

        const ec = crypto.createECDH(namedCurve);
        const publicKey = ec.generateKeys();
        const privateKey = ec.getPrivateKey();
        if(callback) {
            callback(undefined, publicKey, privateKey);
        }
        return {publicKey, privateKey};
    };

    this.getPemKeys = (privateKey, publicKey, options) => {
        const defaultOpts = {format: 'pem', namedCurve: 'secp256k1'};
        Object.assign(defaultOpts, options);
        options = defaultOpts;

        const result = {};
        const ECPrivateKeyASN = KeyEncoder.ECPrivateKeyASN;
        const SubjectPublicKeyInfoASN = KeyEncoder.SubjectPublicKeyInfoASN;
        const keyEncoder = new KeyEncoder(options.namedCurve);

        const privateKeyObject = keyEncoder.privateKeyObject(privateKey, publicKey);
        const publicKeyObject = keyEncoder.publicKeyObject(publicKey)

        result.privateKey = ECPrivateKeyASN.encode(privateKeyObject, options.format, privateKeyObject.pemOptions);
        result.publicKey = SubjectPublicKeyInfoASN.encode(publicKeyObject, options.format, publicKeyObject.pemOptions);

        return result;
    }

    this.getPublicKey = (privateKey, namedCurve) => {
        namedCurve = namedCurve || 'secp256k1';
        const ecdh = crypto.createECDH(namedCurve);
        ecdh.setPrivateKey(privateKey);
        return ecdh.getPublicKey();
    };

    this.convertPublicKey = (publicKey, options) => {
        options = options || {};
        options = removeUndefinedPropsInOpt(options)
        const defaultOpts = {originalFormat: 'raw', outputFormat: 'pem', encodingFormat:"hex", namedCurve: 'secp256k1'};
        Object.assign(defaultOpts, options);
        options = defaultOpts;
        const keyEncoder = new KeyEncoder(options.namedCurve);
        return keyEncoder.encodePublic(publicKey, options.originalFormat, options.outputFormat, options.encodingFormat)
    };

    this.convertPrivateKey = (privateKey, options) => {
        options = options || {};
        options = removeUndefinedPropsInOpt(options)
        const defaultOpts = {originalFormat: 'raw', outputFormat: 'pem', namedCurve: 'secp256k1'};
        Object.assign(defaultOpts, options);
        options = defaultOpts;

        switch (options.outputFormat) {
            case "pem":
                return convertPrivateKeyToPem(privateKey, options);
            case "der":
                return convertPrivateKeyToDer(privateKey, options);
            case "raw":
                return convertPrivateKeyToRaw(privateKey, options);
            default:
                throw Error("Invalid private key output format");
        }

    };

    const convertPrivateKeyToPem = (privateKey, options) => {
        switch (options.originalFormat) {
            case "raw":
                const rawPublicKey = this.getPublicKey(privateKey, options.namedCurve);
                const pemPrivateKey = this.getPemKeys(privateKey, rawPublicKey, options).privateKey;
                return pemPrivateKey;
            case "der":
                const rawPrivateKey =  utils.convertDerPrivateKeyToRaw(privateKey);
                const publicKey = this.getPublicKey(privateKey, options.namedCurve);
                return this.getPemKeys(rawPrivateKey, publicKey, options).privateKey;
            case "pem":
                return privateKey;
            default:
                throw Error("Invalid private key format");
        }
    }

    const convertPrivateKeyToDer = (privateKey, options) => {
        switch (options.originalFormat) {
            case "raw":
                const rawPublicKey = this.getPublicKey(privateKey, options.namedCurve);
                const pemPrivateKey = this.getPemKeys(privateKey, rawPublicKey, options).privateKey;
                return utils.convertPemToDer(pemPrivateKey);
            case "der":
                return privateKey;
            case "pem":
                return utils.convertPemToDer(privateKey);
            default:
                throw Error("Invalid private key format");
        }
    }

    const convertPrivateKeyToRaw = (privateKey, options) => {
        switch (options.originalFormat) {
            case "der":
                return utils.convertDerPrivateKeyToRaw(privateKey);
            case "raw":
                return privateKey;
            case "pem":
                const derPrivateKey = utils.convertPemToDer(privateKey);
                return utils.convertDerPrivateKeyToRaw(derPrivateKey);
            default:
                throw Error("Invalid private key format");
        }
    }

    const removeUndefinedPropsInOpt = (options) => {
        if (options) {
            for (let prop in options) {
                if (typeof options[prop] === "undefined") {
                    delete options[prop];
                }
            }
        }

        return options;
    };
}

exports.createECKeyGenerator = () => {
    return new ECKeyGenerator();
};

},{"./keyEncoder":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/pskcrypto/lib/keyEncoder.js","./utils/cryptoUtils":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/pskcrypto/lib/utils/cryptoUtils.js","crypto":false}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/pskcrypto/lib/PskCrypto.js":[function(require,module,exports){
function PskCrypto() {
    const crypto = require('crypto');
    const utils = require("./utils/cryptoUtils");
    const eth = require("./utils/eth");
    const PskEncryption = require("./PskEncryption");


    this.createPskEncryption = (algorithm) => {
        return new PskEncryption(algorithm);
    };

    this.generateKeyPair = (options, callback) => {
        return this.createKeyPairGenerator().generateKeyPair(options, callback);
    };

    this.createKeyPairGenerator = require("./ECKeyGenerator").createECKeyGenerator;

    this.sign = (algorithm, data, privateKey) => {
        if (typeof data === "string") {
            data = $$.Buffer.from(data);
        }

        const sign = crypto.createSign(algorithm);
        sign.update(data);
        sign.end();
        return sign.sign(privateKey);
    };

    this.verify = (algorithm, data, publicKey, signature) => {
        if (typeof data === "string") {
            data = $$.Buffer.from(data);
        }
        const verify = crypto.createVerify(algorithm);
        verify.update(data);
        verify.end();
        return verify.verify(publicKey, signature);
    };

    this.signETH = eth.sign;

    this.verifyETH = eth.verify;

    this.verifyDefault = (data, publicKey, signature) => {
        return this.verify('sha256', data, publicKey, signature);
    }

    this.privateEncrypt = (privateKey, data) => {
        if (typeof data === "string") {
            data = $$.Buffer.from(data);
        }

        return crypto.privateEncrypt(privateKey, data);
    };

    this.privateDecrypt = (privateKey, encryptedData) => {
        if (typeof encryptedData === "string") {
            encryptedData = $$.Buffer.from(encryptedData);
        }

        return crypto.privateDecrypt(privateKey, encryptedData);
    };

    this.publicEncrypt = (publicKey, data) => {
        if (typeof data === "string") {
            data = $$.Buffer.from(data);
        }

        return crypto.publicEncrypt(publicKey, data);
    };

    this.publicDecrypt = (publicKey, encryptedData) => {
        if (typeof encryptedData === "string") {
            encryptedData = $$.Buffer.from(encryptedData);
        }

        return crypto.publicDecrypt(publicKey, encryptedData);
    };

    this.pskHash = function (data, encoding) {
        if ($$.Buffer.isBuffer(data)) {
            return utils.createPskHash(data, encoding);
        }
        if (data instanceof Object) {
            return utils.createPskHash(JSON.stringify(data), encoding);
        }
        return utils.createPskHash(data, encoding);
    };

    this.hash = (algorithm, data, encoding) => {
        if (typeof data === "object" && !$$.Buffer.isBuffer(data)) {
            data = JSON.stringify(data);
        }
        const hash = crypto.createHash(algorithm);
        hash.update(data);
        return hash.digest(encoding);
    };

    this.objectHash = (algorithm, data, encoding) => {
        if (!$$.Buffer.isBuffer(data)) {
            const ssutils = require("../signsensusDS/ssutil");
            data = ssutils.dumpObjectForHashing(data);
        }
        return this.hash(algorithm, data, encoding);
    };

    this.pskBase58Encode = function (data) {
        return utils.base58Encode(data);
    }

    this.pskBase58Decode = function (data) {
        return utils.base58Decode(data);
    }

    this.pskHashStream = function (readStream, callback) {
        const pskHash = new utils.PskHash();

        readStream.on('data', (chunk) => {
            pskHash.update(chunk);
        });


        readStream.on('end', () => {
            callback(null, pskHash.digest());
        })
    };

    this.generateSafeUid = function (password, additionalData) {
        password = password || $$.Buffer.alloc(0);
        if (!additionalData) {
            additionalData = $$.Buffer.alloc(0);
        }

        if (!$$.Buffer.isBuffer(additionalData)) {
            additionalData = $$.Buffer.from(additionalData);
        }

        return utils.encode(this.pskHash($$.Buffer.concat([password, additionalData])));
    };

    this.deriveKey = function deriveKey(algorithm, password, iterations) {
        if (arguments.length === 2) {
            if (typeof password === "number") {
                iterations = password
                password = algorithm;
                algorithm = "aes-256-gcm";
            } else {
                iterations = 1000;
            }
        }
        if (typeof password === "undefined") {
            iterations = 1000;
            password = algorithm;
            algorithm = "aes-256-gcm";
        }

        const keylen = utils.getKeyLength(algorithm);
        const salt = utils.generateSalt(password, 32);
        return crypto.pbkdf2Sync(password, salt, iterations, keylen, 'sha256');
    };


    this.randomBytes = (len) => {
        if ($$.environmentType === "browser" /*or.constants.BROWSER_ENVIRONMENT_TYPE*/) {
            let randomArray = new Uint8Array(len);

            return window.crypto.getRandomValues(randomArray);
        } else {
            return crypto.randomBytes(len);
        }
    };

    this.xorBuffers = (...args) => {
        if (args.length < 2) {
            throw Error(`The function should receive at least two arguments. Received ${args.length}`);
        }

        if (args.length === 2) {
            __xorTwoBuffers(args[0], args[1]);
            return args[1];
        }

        for (let i = 0; i < args.length - 1; i++) {
            __xorTwoBuffers(args[i], args[i + 1]);
        }

        function __xorTwoBuffers(a, b) {
            if (!$$.Buffer.isBuffer(a) || !$$.Buffer.isBuffer(b)) {
                throw Error("The argument type should be $$.Buffer.");
            }

            const length = Math.min(a.length, b.length);
            for (let i = 0; i < length; i++) {
                b[i] ^= a[i];
            }

            return b;
        }

        return args[args.length - 1];
    };
    this.decodeDerToASN1ETH = (derSignatureBuffer) => eth.decodeDERIntoASN1ETH(derSignatureBuffer);
    this.PskHash = utils.PskHash;

    const ecies = require("../js-mutual-auth-ecies/index");
    this.ecies_encrypt = ecies.ecies_encrypt;
    this.ecies_decrypt = ecies.ecies_decrypt;
    this.ecies_encrypt_kmac = ecies.ecies_encrypt_kmac;
    this.ecies_decrypt_kmac = ecies.ecies_decrypt_kmac;
    this.ecies_encrypt_ds = ecies.ecies_encrypt_ds;
    this.ecies_decrypt_ds = ecies.ecies_decrypt_ds;
    this.joseAPI = require("../jsonWebToken");
    this.pskBase64Encode = utils.base64Encode;
    this.pskBase64Decode = utils.base64Decode;
}

module.exports = new PskCrypto();



},{"../js-mutual-auth-ecies/index":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/pskcrypto/js-mutual-auth-ecies/index.js","../jsonWebToken":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/pskcrypto/jsonWebToken/index.js","../signsensusDS/ssutil":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/pskcrypto/signsensusDS/ssutil.js","./ECKeyGenerator":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/pskcrypto/lib/ECKeyGenerator.js","./PskEncryption":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/pskcrypto/lib/PskEncryption.js","./utils/cryptoUtils":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/pskcrypto/lib/utils/cryptoUtils.js","./utils/eth":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/pskcrypto/lib/utils/eth.js","crypto":false}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/pskcrypto/lib/PskEncryption.js":[function(require,module,exports){
function PskEncryption(algorithm) {
    const crypto = require("crypto");
    const utils = require("./utils/cryptoUtils");

    if (!algorithm) {
        throw Error("No encryption algorithm was provided");
    }

    let iv;
    let aad;
    let tag;
    let data;
    let key;

    let keylen = utils.getKeyLength(algorithm);
    let encryptionIsAuthenticated = utils.encryptionIsAuthenticated(algorithm);

    this.encrypt = (plainData, encryptionKey, options) => {
        if (typeof plainData === "string") {
            plainData = $$.Buffer.from(plainData);
        }

        if (typeof encryptionKey === "string") {
            encryptionKey = $$.Buffer.from(encryptionKey);
        }
        if(options && options.avoidRandom){
            iv = utils.generateSalt(encryptionKey, 16);
        }else{
            iv = iv || crypto.randomBytes(16);
        }

        const cipher = crypto.createCipheriv(algorithm, encryptionKey, iv, options);
        if (encryptionIsAuthenticated) {
            if(options && options.avoidRandom){
                aad = utils.generateSalt(encryptionKey, encryptionKey.length);
            }else{
                aad = crypto.randomBytes(encryptionKey.length);
            }
            cipher.setAAD(aad);
        }

        let encData = $$.Buffer.concat([cipher.update(plainData), cipher.final()]);
        if (encryptionIsAuthenticated) {
            tag = cipher.getAuthTag();
        }

        if (iv) {
            encData = $$.Buffer.concat([encData, iv]);
        }

        if (aad) {
            encData = $$.Buffer.concat([encData, aad]);
        }

        if (tag) {
            encData = $$.Buffer.concat([encData, tag]);
        }

        key = encryptionKey;
        return encData;
    };

    this.decrypt = (encryptedData, decryptionKey, authTagLength = 0, options) => {
        if (typeof encryptedData === "string") {
            encryptedData = $$.Buffer.from(encryptedData);
        }
        if (typeof decryptionKey === "string") {
            decryptionKey = $$.Buffer.from(decryptionKey);
        }
        if (!iv) {
            this.getDecryptionParameters(encryptedData, authTagLength);
        }
        const decipher = crypto.createDecipheriv(algorithm, decryptionKey, iv, options);
        if (encryptionIsAuthenticated) {
            decipher.setAAD(aad);
            decipher.setAuthTag(tag);
        }

        return $$.Buffer.concat([decipher.update(data), decipher.final()]);
    };

    this.getDecryptionParameters = (encryptedData, authTagLength = 0) => {
        let aadLen = 0;
        if (encryptionIsAuthenticated) {
            authTagLength = 16;
            aadLen = keylen;
        }

        const tagOffset = encryptedData.length - authTagLength;
        tag = encryptedData.slice(tagOffset, encryptedData.length);

        const aadOffset = tagOffset - aadLen;
        aad = encryptedData.slice(aadOffset, tagOffset);

        iv = encryptedData.slice(aadOffset - 16, aadOffset);
        data = encryptedData.slice(0, aadOffset - 16);

        return {iv, aad, tag, data};
    };

    this.generateEncryptionKey = () => {
        keylen = utils.getKeyLength(algorithm);
        return crypto.randomBytes(keylen);
    };
}

module.exports = PskEncryption;

},{"./utils/cryptoUtils":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/pskcrypto/lib/utils/cryptoUtils.js","crypto":false}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/pskcrypto/lib/asn1/api.js":[function(require,module,exports){
var asn1 = require('./asn1');
var inherits = require('util').inherits;

var api = exports;

api.define = function define(name, body) {
  return new Entity(name, body);
};

function Entity(name, body) {
  this.name = name;
  this.body = body;

  this.decoders = {};
  this.encoders = {};
};

Entity.prototype._createNamed = function createNamed(base) {
  var named;
  try {
    named = require('vm').runInThisContext(
      '(function ' + this.name + '(entity) {\n' +
      '  this._initNamed(entity);\n' +
      '})'
    );
  } catch (e) {
    named = function (entity) {
      this._initNamed(entity);
    };
  }
  inherits(named, base);
  named.prototype._initNamed = function initnamed(entity) {
    base.call(this, entity);
  };

  return new named(this);
};

Entity.prototype._getDecoder = function _getDecoder(enc) {
  // Lazily create decoder
  if (!this.decoders.hasOwnProperty(enc))
    this.decoders[enc] = this._createNamed(asn1.decoders[enc]);
  return this.decoders[enc];
};

Entity.prototype.decode = function decode(data, enc, options) {
  return this._getDecoder(enc).decode(data, options);
};

Entity.prototype._getEncoder = function _getEncoder(enc) {
  // Lazily create encoder
  if (!this.encoders.hasOwnProperty(enc))
    this.encoders[enc] = this._createNamed(asn1.encoders[enc]);
  return this.encoders[enc];
};

Entity.prototype.encode = function encode(data, enc, /* internal */ reporter) {
  return this._getEncoder(enc).encode(data, reporter);
};

},{"./asn1":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/pskcrypto/lib/asn1/asn1.js","util":false,"vm":false}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/pskcrypto/lib/asn1/asn1.js":[function(require,module,exports){
var asn1 = exports;

asn1.bignum = require('./bignum/bn');

asn1.define = require('./api').define;
asn1.base = require('./base/index');
asn1.constants = require('./constants/index');
asn1.decoders = require('./decoders/index');
asn1.encoders = require('./encoders/index');

},{"./api":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/pskcrypto/lib/asn1/api.js","./base/index":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/pskcrypto/lib/asn1/base/index.js","./bignum/bn":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/pskcrypto/lib/asn1/bignum/bn.js","./constants/index":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/pskcrypto/lib/asn1/constants/index.js","./decoders/index":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/pskcrypto/lib/asn1/decoders/index.js","./encoders/index":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/pskcrypto/lib/asn1/encoders/index.js"}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/pskcrypto/lib/asn1/base/buffer.js":[function(require,module,exports){
const inherits = require('util').inherits;
const Reporter = require('../base').Reporter;

function DecoderBuffer(base, options) {
    Reporter.call(this, options);
    if (!$$.Buffer.isBuffer(base)) {
        this.error('Input not $$.Buffer');
        return;
    }

    this.base = base;
    this.offset = 0;
    this.length = base.length;
}

inherits(DecoderBuffer, Reporter);
exports.DecoderBuffer = DecoderBuffer;

DecoderBuffer.prototype.save = function save() {
    return {offset: this.offset, reporter: Reporter.prototype.save.call(this)};
};

DecoderBuffer.prototype.restore = function restore(save) {
    // Return skipped data
    const res = new DecoderBuffer(this.base);
    res.offset = save.offset;
    res.length = this.offset;

    this.offset = save.offset;
    Reporter.prototype.restore.call(this, save.reporter);

    return res;
};

DecoderBuffer.prototype.isEmpty = function isEmpty() {
    return this.offset === this.length;
};

DecoderBuffer.prototype.readUInt8 = function readUInt8(fail) {
    if (this.offset + 1 <= this.length)
        return this.base.readUInt8(this.offset++, true);
    else
        return this.error(fail || 'DecoderBuffer overrun');
}

DecoderBuffer.prototype.skip = function skip(bytes, fail) {
    if (!(this.offset + bytes <= this.length))
        return this.error(fail || 'DecoderBuffer overrun');

    const res = new DecoderBuffer(this.base);

    // Share reporter state
    res._reporterState = this._reporterState;

    res.offset = this.offset;
    res.length = this.offset + bytes;
    this.offset += bytes;
    return res;
}

DecoderBuffer.prototype.raw = function raw(save) {
    return this.base.slice(save ? save.offset : this.offset, this.length);
}

function EncoderBuffer(value, reporter) {
    if (Array.isArray(value)) {
        this.length = 0;
        this.value = value.map(function (item) {
            if (!(item instanceof EncoderBuffer))
                item = new EncoderBuffer(item, reporter);
            this.length += item.length;
            return item;
        }, this);
    } else if (typeof value === 'number') {
        if (!(0 <= value && value <= 0xff))
            return reporter.error('non-byte EncoderBuffer value');
        this.value = value;
        this.length = 1;
    } else if (typeof value === 'string') {
        this.value = value;
        this.length = $$.Buffer.byteLength(value);
    } else if ($$.Buffer.isBuffer(value)) {
        this.value = value;
        this.length = value.length;
    } else {
        return reporter.error('Unsupported type: ' + typeof value);
    }
}

exports.EncoderBuffer = EncoderBuffer;

EncoderBuffer.prototype.join = function join(out, offset) {
    if (!out)
        out = $$.Buffer.alloc(this.length);
    if (!offset)
        offset = 0;

    if (this.length === 0)
        return out;

    if (Array.isArray(this.value)) {
        this.value.forEach(function (item) {
            item.join(out, offset);
            offset += item.length;
        });
    } else {
        if (typeof this.value === 'number')
            out[offset] = this.value;
        else if (typeof this.value === 'string')
            out.write(this.value, offset);
        else if ($$.Buffer.isBuffer(this.value))
            this.value.copy(out, offset);
        offset += this.length;
    }

    return out;
};

},{"../base":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/pskcrypto/lib/asn1/base/index.js","util":false}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/pskcrypto/lib/asn1/base/index.js":[function(require,module,exports){
var base = exports;

base.Reporter = require('./reporter').Reporter;
base.DecoderBuffer = require('./buffer').DecoderBuffer;
base.EncoderBuffer = require('./buffer').EncoderBuffer;
base.Node = require('./node');

},{"./buffer":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/pskcrypto/lib/asn1/base/buffer.js","./node":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/pskcrypto/lib/asn1/base/node.js","./reporter":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/pskcrypto/lib/asn1/base/reporter.js"}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/pskcrypto/lib/asn1/base/node.js":[function(require,module,exports){
var Reporter = require('../base').Reporter;
var EncoderBuffer = require('../base').EncoderBuffer;
//var assert = require('double-check').assert;

// Supported tags
var tags = [
  'seq', 'seqof', 'set', 'setof', 'octstr', 'bitstr', 'objid', 'bool',
  'gentime', 'utctime', 'null_', 'enum', 'int', 'ia5str', 'utf8str'
];

// Public methods list
var methods = [
  'key', 'obj', 'use', 'optional', 'explicit', 'implicit', 'def', 'choice',
  'any'
].concat(tags);

// Overrided methods list
var overrided = [
  '_peekTag', '_decodeTag', '_use',
  '_decodeStr', '_decodeObjid', '_decodeTime',
  '_decodeNull', '_decodeInt', '_decodeBool', '_decodeList',

  '_encodeComposite', '_encodeStr', '_encodeObjid', '_encodeTime',
  '_encodeNull', '_encodeInt', '_encodeBool'
];

function Node(enc, parent) {
  var state = {};
  this._baseState = state;

  state.enc = enc;

  state.parent = parent || null;
  state.children = null;

  // State
  state.tag = null;
  state.args = null;
  state.reverseArgs = null;
  state.choice = null;
  state.optional = false;
  state.any = false;
  state.obj = false;
  state.use = null;
  state.useDecoder = null;
  state.key = null;
  state['default'] = null;
  state.explicit = null;
  state.implicit = null;

  // Should create new instance on each method
  if (!state.parent) {
    state.children = [];
    this._wrap();
  }
}
module.exports = Node;

var stateProps = [
  'enc', 'parent', 'children', 'tag', 'args', 'reverseArgs', 'choice',
  'optional', 'any', 'obj', 'use', 'alteredUse', 'key', 'default', 'explicit',
  'implicit'
];

Node.prototype.clone = function clone() {
  var state = this._baseState;
  var cstate = {};
  stateProps.forEach(function(prop) {
    cstate[prop] = state[prop];
  });
  var res = new this.constructor(cstate.parent);
  res._baseState = cstate;
  return res;
};

Node.prototype._wrap = function wrap() {
  var state = this._baseState;
  methods.forEach(function(method) {
    this[method] = function _wrappedMethod() {
      var clone = new this.constructor(this);
      state.children.push(clone);
      return clone[method].apply(clone, arguments);
    };
  }, this);
};

Node.prototype._init = function init(body) {
  var state = this._baseState;

  //assert.equal(state.parent,null,'state.parent should be null');
  body.call(this);

  // Filter children
  state.children = state.children.filter(function(child) {
    return child._baseState.parent === this;
  }, this);
  // assert.equal(state.children.length, 1, 'Root node can have only one child');
};

Node.prototype._useArgs = function useArgs(args) {
  var state = this._baseState;

  // Filter children and args
  var children = args.filter(function(arg) {
    return arg instanceof this.constructor;
  }, this);
  args = args.filter(function(arg) {
    return !(arg instanceof this.constructor);
  }, this);

  if (children.length !== 0) {
    // assert.equal(state.children, null, 'state.children should be null');
    state.children = children;

    // Replace parent to maintain backward link
    children.forEach(function(child) {
      child._baseState.parent = this;
    }, this);
  }
  if (args.length !== 0) {
    // assert.equal(state.args, null, 'state.args should be null');
    state.args = args;
    state.reverseArgs = args.map(function(arg) {
      if (typeof arg !== 'object' || arg.constructor !== Object)
        return arg;

      var res = {};
      Object.keys(arg).forEach(function(key) {
        if (key == (key | 0))
          key |= 0;
        var value = arg[key];
        res[value] = key;
      });
      return res;
    });
  }
};

//
// Overrided methods
//

overrided.forEach(function(method) {
  Node.prototype[method] = function _overrided() {
    var state = this._baseState;
    throw new Error(method + ' not implemented for encoding: ' + state.enc);
  };
});

//
// Public methods
//

tags.forEach(function(tag) {
  Node.prototype[tag] = function _tagMethod() {
    var state = this._baseState;
    var args = Array.prototype.slice.call(arguments);

    // assert.equal(state.tag, null, 'state.tag should be null');
    state.tag = tag;

    this._useArgs(args);

    return this;
  };
});

Node.prototype.use = function use(item) {
  var state = this._baseState;

  // assert.equal(state.use, null, 'state.use should be null');
  state.use = item;

  return this;
};

Node.prototype.optional = function optional() {
  var state = this._baseState;

  state.optional = true;

  return this;
};

Node.prototype.def = function def(val) {
  var state = this._baseState;

  // assert.equal(state['default'], null, "state['default'] should be null");
  state['default'] = val;
  state.optional = true;

  return this;
};

Node.prototype.explicit = function explicit(num) {
  var state = this._baseState;

  // assert.equal(state.explicit,null, 'state.explicit should be null');
  // assert.equal(state.implicit,null, 'state.implicit should be null');

  state.explicit = num;

  return this;
};

Node.prototype.implicit = function implicit(num) {
  var state = this._baseState;

    // assert.equal(state.explicit,null, 'state.explicit should be null');
    // assert.equal(state.implicit,null, 'state.implicit should be null');

    state.implicit = num;

  return this;
};

Node.prototype.obj = function obj() {
  var state = this._baseState;
  var args = Array.prototype.slice.call(arguments);

  state.obj = true;

  if (args.length !== 0)
    this._useArgs(args);

  return this;
};

Node.prototype.key = function key(newKey) {
  var state = this._baseState;

  // assert.equal(state.key, null, 'state.key should be null');
  state.key = newKey;

  return this;
};

Node.prototype.any = function any() {
  var state = this._baseState;

  state.any = true;

  return this;
};

Node.prototype.choice = function choice(obj) {
  var state = this._baseState;

  // assert.equal(state.choice, null,'state.choice should be null');
  state.choice = obj;
  this._useArgs(Object.keys(obj).map(function(key) {
    return obj[key];
  }));

  return this;
};

//
// Decoding
//

Node.prototype._decode = function decode(input) {
  var state = this._baseState;

  // Decode root node
  if (state.parent === null)
    return input.wrapResult(state.children[0]._decode(input));

  var result = state['default'];
  var present = true;

  var prevKey;
  if (state.key !== null)
    prevKey = input.enterKey(state.key);

  // Check if tag is there
  if (state.optional) {
    var tag = null;
    if (state.explicit !== null)
      tag = state.explicit;
    else if (state.implicit !== null)
      tag = state.implicit;
    else if (state.tag !== null)
      tag = state.tag;

    if (tag === null && !state.any) {
      // Trial and Error
      var save = input.save();
      try {
        if (state.choice === null)
          this._decodeGeneric(state.tag, input);
        else
          this._decodeChoice(input);
        present = true;
      } catch (e) {
        present = false;
      }
      input.restore(save);
    } else {
      present = this._peekTag(input, tag, state.any);

      if (input.isError(present))
        return present;
    }
  }

  // Push object on stack
  var prevObj;
  if (state.obj && present)
    prevObj = input.enterObject();

  if (present) {
    // Unwrap explicit values
    if (state.explicit !== null) {
      var explicit = this._decodeTag(input, state.explicit);
      if (input.isError(explicit))
        return explicit;
      input = explicit;
    }

    // Unwrap implicit and normal values
    if (state.use === null && state.choice === null) {
      if (state.any)
        var save = input.save();
      var body = this._decodeTag(
        input,
        state.implicit !== null ? state.implicit : state.tag,
        state.any
      );
      if (input.isError(body))
        return body;

      if (state.any)
        result = input.raw(save);
      else
        input = body;
    }

    // Select proper method for tag
    if (state.choice === null)
      result = this._decodeGeneric(state.tag, input);
    else if(!state.any)
      result = this._decodeChoice(input);

    if (input.isError(result))
      return result;

    // Decode children
    if (!state.any && state.choice === null && state.children !== null) {
      var fail = state.children.some(function decodeChildren(child) {
        // NOTE: We are ignoring errors here, to let parser continue with other
        // parts of encoded data
        child._decode(input);
      });
      if (fail)
        return err;
    }
  }

  // Pop object
  if (state.obj && present)
    result = input.leaveObject(prevObj);

  // Set key
  if (state.key !== null && (result !== null || present === true))
    input.leaveKey(prevKey, state.key, result);

  return result;
};

Node.prototype._decodeGeneric = function decodeGeneric(tag, input) {
  var state = this._baseState;

  if (tag === 'seq' || tag === 'set')
    return null;
  if (tag === 'seqof' || tag === 'setof')
    return this._decodeList(input, tag, state.args[0]);
  else if (tag === 'octstr' || tag === 'bitstr')
    return this._decodeStr(input, tag);
  else if (tag === 'ia5str' || tag === 'utf8str')
    return this._decodeStr(input, tag);
  else if (tag === 'objid' && state.args)
    return this._decodeObjid(input, state.args[0], state.args[1]);
  else if (tag === 'objid')
    return this._decodeObjid(input, null, null);
  else if (tag === 'gentime' || tag === 'utctime')
    return this._decodeTime(input, tag);
  else if (tag === 'null_')
    return this._decodeNull(input);
  else if (tag === 'bool')
    return this._decodeBool(input);
  else if (tag === 'int' || tag === 'enum')
    return this._decodeInt(input, state.args && state.args[0]);
  else if (state.use !== null)
    return this._getUse(state.use, input._reporterState.obj)._decode(input);
  else
    return input.error('unknown tag: ' + tag);
};

Node.prototype._getUse = function _getUse(entity, obj) {

  var state = this._baseState;
  // Create altered use decoder if implicit is set
  state.useDecoder = this._use(entity, obj);
  // assert.equal(state.useDecoder._baseState.parent, null, 'state.useDecoder._baseState.parent should be null');
  state.useDecoder = state.useDecoder._baseState.children[0];
  if (state.implicit !== state.useDecoder._baseState.implicit) {
    state.useDecoder = state.useDecoder.clone();
    state.useDecoder._baseState.implicit = state.implicit;
  }
  return state.useDecoder;
};

Node.prototype._decodeChoice = function decodeChoice(input) {
  var state = this._baseState;
  var result = null;
  var match = false;

  Object.keys(state.choice).some(function(key) {
    var save = input.save();
    var node = state.choice[key];
    try {
      var value = node._decode(input);
      if (input.isError(value))
        return false;

      result = { type: key, value: value };
      match = true;
    } catch (e) {
      input.restore(save);
      return false;
    }
    return true;
  }, this);

  if (!match)
    return input.error('Choice not matched');

  return result;
};

//
// Encoding
//

Node.prototype._createEncoderBuffer = function createEncoderBuffer(data) {
  return new EncoderBuffer(data, this.reporter);
};

Node.prototype._encode = function encode(data, reporter, parent) {
  var state = this._baseState;
  if (state['default'] !== null && state['default'] === data)
    return;

  var result = this._encodeValue(data, reporter, parent);
  if (result === undefined)
    return;

  if (this._skipDefault(result, reporter, parent))
    return;

  return result;
};

Node.prototype._encodeValue = function encode(data, reporter, parent) {
  var state = this._baseState;

  // Decode root node
  if (state.parent === null)
    return state.children[0]._encode(data, reporter || new Reporter());

  var result = null;
  var present = true;

  // Set reporter to share it with a child class
  this.reporter = reporter;

  // Check if data is there
  if (state.optional && data === undefined) {
    if (state['default'] !== null)
      data = state['default']
    else
      return;
  }

  // For error reporting
  var prevKey;

  // Encode children first
  var content = null;
  var primitive = false;
  if (state.any) {
    // Anything that was given is translated to buffer
    result = this._createEncoderBuffer(data);
  } else if (state.choice) {
    result = this._encodeChoice(data, reporter);
  } else if (state.children) {
    content = state.children.map(function(child) {
      if (child._baseState.tag === 'null_')
        return child._encode(null, reporter, data);

      if (child._baseState.key === null)
        return reporter.error('Child should have a key');
      var prevKey = reporter.enterKey(child._baseState.key);

      if (typeof data !== 'object')
        return reporter.error('Child expected, but input is not object');

      var res = child._encode(data[child._baseState.key], reporter, data);
      reporter.leaveKey(prevKey);

      return res;
    }, this).filter(function(child) {
      return child;
    });

    content = this._createEncoderBuffer(content);
  } else {
    if (state.tag === 'seqof' || state.tag === 'setof') {
      // TODO(indutny): this should be thrown on DSL level
      if (!(state.args && state.args.length === 1))
        return reporter.error('Too many args for : ' + state.tag);

      if (!Array.isArray(data))
        return reporter.error('seqof/setof, but data is not Array');

      var child = this.clone();
      child._baseState.implicit = null;
      content = this._createEncoderBuffer(data.map(function(item) {
        var state = this._baseState;

        return this._getUse(state.args[0], data)._encode(item, reporter);
      }, child));
    } else if (state.use !== null) {
      result = this._getUse(state.use, parent)._encode(data, reporter);
    } else {
      content = this._encodePrimitive(state.tag, data);
      primitive = true;
    }
  }

  // Encode data itself
  var result;
  if (!state.any && state.choice === null) {
    var tag = state.implicit !== null ? state.implicit : state.tag;
    var cls = state.implicit === null ? 'universal' : 'context';

    if (tag === null) {
      if (state.use === null)
        reporter.error('Tag could be ommited only for .use()');
    } else {
      if (state.use === null)
        result = this._encodeComposite(tag, primitive, cls, content);
    }
  }

  // Wrap in explicit
  if (state.explicit !== null)
    result = this._encodeComposite(state.explicit, false, 'context', result);

  return result;
};

Node.prototype._encodeChoice = function encodeChoice(data, reporter) {
  var state = this._baseState;

  var node = state.choice[data.type];
  // if (!node) {
  //   assert(
  //       false,
  //       data.type + ' not found in ' +
  //           JSON.stringify(Object.keys(state.choice)));
  // }
  return node._encode(data.value, reporter);
};

Node.prototype._encodePrimitive = function encodePrimitive(tag, data) {
  var state = this._baseState;

  if (tag === 'octstr' || tag === 'bitstr' || tag === 'ia5str')
    return this._encodeStr(data, tag);
  else if (tag === 'utf8str')
    return this._encodeStr(data, tag);
  else if (tag === 'objid' && state.args)
    return this._encodeObjid(data, state.reverseArgs[0], state.args[1]);
  else if (tag === 'objid')
    return this._encodeObjid(data, null, null);
  else if (tag === 'gentime' || tag === 'utctime')
    return this._encodeTime(data, tag);
  else if (tag === 'null_')
    return this._encodeNull();
  else if (tag === 'int' || tag === 'enum')
    return this._encodeInt(data, state.args && state.reverseArgs[0]);
  else if (tag === 'bool')
    return this._encodeBool(data);
  else
    throw new Error('Unsupported tag: ' + tag);
};

},{"../base":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/pskcrypto/lib/asn1/base/index.js"}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/pskcrypto/lib/asn1/base/reporter.js":[function(require,module,exports){
var inherits = require('util').inherits;

function Reporter(options) {
  this._reporterState = {
    obj: null,
    path: [],
    options: options || {},
    errors: []
  };
}
exports.Reporter = Reporter;

Reporter.prototype.isError = function isError(obj) {
  return obj instanceof ReporterError;
};

Reporter.prototype.save = function save() {
  var state = this._reporterState;

  return { obj: state.obj, pathLen: state.path.length };
};

Reporter.prototype.restore = function restore(data) {
  var state = this._reporterState;

  state.obj = data.obj;
  state.path = state.path.slice(0, data.pathLen);
};

Reporter.prototype.enterKey = function enterKey(key) {
  return this._reporterState.path.push(key);
};

Reporter.prototype.leaveKey = function leaveKey(index, key, value) {
  var state = this._reporterState;

  state.path = state.path.slice(0, index - 1);
  if (state.obj !== null)
    state.obj[key] = value;
};

Reporter.prototype.enterObject = function enterObject() {
  var state = this._reporterState;

  var prev = state.obj;
  state.obj = {};
  return prev;
};

Reporter.prototype.leaveObject = function leaveObject(prev) {
  var state = this._reporterState;

  var now = state.obj;
  state.obj = prev;
  return now;
};

Reporter.prototype.error = function error(msg) {
  var err;
  var state = this._reporterState;

  var inherited = msg instanceof ReporterError;
  if (inherited) {
    err = msg;
  } else {
    err = new ReporterError(state.path.map(function(elem) {
      return '[' + JSON.stringify(elem) + ']';
    }).join(''), msg.message || msg, msg.stack);
  }

  if (!state.options.partial)
    throw err;

  if (!inherited)
    state.errors.push(err);

  return err;
};

Reporter.prototype.wrapResult = function wrapResult(result) {
  var state = this._reporterState;
  if (!state.options.partial)
    return result;

  return {
    result: this.isError(result) ? null : result,
    errors: state.errors
  };
};

function ReporterError(path, msg) {
  this.path = path;
  this.rethrow(msg);
};
inherits(ReporterError, Error);

ReporterError.prototype.rethrow = function rethrow(msg) {
  this.message = msg + ' at: ' + (this.path || '(shallow)');
  Error.captureStackTrace(this, ReporterError);

  return this;
};

},{"util":false}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/pskcrypto/lib/asn1/bignum/bn.js":[function(require,module,exports){
(function (module, exports) {

'use strict';

// Utils

function assert(val, msg) {
  if (!val)
    throw new Error(msg || 'Assertion failed');
}

// Could use `inherits` module, but don't want to move from single file
// architecture yet.
function inherits(ctor, superCtor) {
  ctor.super_ = superCtor;
  var TempCtor = function () {};
  TempCtor.prototype = superCtor.prototype;
  ctor.prototype = new TempCtor();
  ctor.prototype.constructor = ctor;
}

// BN

function BN(number, base, endian) {
  // May be `new BN(bn)` ?
  if (number !== null &&
      typeof number === 'object' &&
      Array.isArray(number.words)) {
    return number;
  }

  this.sign = false;
  this.words = null;
  this.length = 0;

  // Reduction context
  this.red = null;

  if (base === 'le' || base === 'be') {
    endian = base;
    base = 10;
  }

  if (number !== null)
    this._init(number || 0, base || 10, endian || 'be');
}
if (typeof module === 'object')
  module.exports = BN;
else
  exports.BN = BN;

BN.BN = BN;
BN.wordSize = 26;

BN.prototype._init = function init(number, base, endian) {
  if (typeof number === 'number') {
    return this._initNumber(number, base, endian);
  } else if (typeof number === 'object') {
    return this._initArray(number, base, endian);
  }
  if (base === 'hex')
    base = 16;
  assert(base === (base | 0) && base >= 2 && base <= 36);

  number = number.toString().replace(/\s+/g, '');
  var start = 0;
  if (number[0] === '-')
    start++;

  if (base === 16)
    this._parseHex(number, start);
  else
    this._parseBase(number, base, start);

  if (number[0] === '-')
    this.sign = true;

  this.strip();

  if (endian !== 'le')
    return;

  this._initArray(this.toArray(), base, endian);
};

  BN.prototype.toArrayLike = function toArrayLike (ArrayType, endian, length) {
    this.strip();

    var byteLength = this.byteLength();
    var reqLength = length || Math.max(1, byteLength);
    assert(byteLength <= reqLength, 'byte array longer than desired length');
    assert(reqLength > 0, 'Requested array length <= 0');

    var res = allocate(ArrayType, reqLength);
    var postfix = endian === 'le' ? 'LE' : 'BE';
    this['_toArrayLike' + postfix](res, byteLength);
    return res;
  };

  var allocate = function allocate (ArrayType, size) {
    if (ArrayType.allocUnsafe) {
      return ArrayType.allocUnsafe(size);
    }
    return new ArrayType(size);
  };

  BN.prototype._toArrayLikeLE = function _toArrayLikeLE (res, byteLength) {
    var position = 0;
    var carry = 0;

    for (var i = 0, shift = 0; i < this.length; i++) {
      var word = (this.words[i] << shift) | carry;

      res[position++] = word & 0xff;
      if (position < res.length) {
        res[position++] = (word >> 8) & 0xff;
      }
      if (position < res.length) {
        res[position++] = (word >> 16) & 0xff;
      }

      if (shift === 6) {
        if (position < res.length) {
          res[position++] = (word >> 24) & 0xff;
        }
        carry = 0;
        shift = 0;
      } else {
        carry = word >>> 24;
        shift += 2;
      }
    }

    if (position < res.length) {
      res[position++] = carry;

      while (position < res.length) {
        res[position++] = 0;
      }
    }
  };

  BN.prototype._toArrayLikeBE = function _toArrayLikeBE (res, byteLength) {
    var position = res.length - 1;
    var carry = 0;

    for (var i = 0, shift = 0; i < this.length; i++) {
      var word = (this.words[i] << shift) | carry;

      res[position--] = word & 0xff;
      if (position >= 0) {
        res[position--] = (word >> 8) & 0xff;
      }
      if (position >= 0) {
        res[position--] = (word >> 16) & 0xff;
      }

      if (shift === 6) {
        if (position >= 0) {
          res[position--] = (word >> 24) & 0xff;
        }
        carry = 0;
        shift = 0;
      } else {
        carry = word >>> 24;
        shift += 2;
      }
    }

    if (position >= 0) {
      res[position--] = carry;

      while (position >= 0) {
        res[position--] = 0;
      }
    }
  };

  if (Math.clz32) {
    BN.prototype._countBits = function _countBits (w) {
      return 32 - Math.clz32(w);
    };
  } else {
    BN.prototype._countBits = function _countBits (w) {
      var t = w;
      var r = 0;
      if (t >= 0x1000) {
        r += 13;
        t >>>= 13;
      }
      if (t >= 0x40) {
        r += 7;
        t >>>= 7;
      }
      if (t >= 0x8) {
        r += 4;
        t >>>= 4;
      }
      if (t >= 0x02) {
        r += 2;
        t >>>= 2;
      }
      return r + t;
    };
  }



BN.prototype._initNumber = function _initNumber(number, base, endian) {
  if (number < 0) {
    this.sign = true;
    number = -number;
  }
  if (number < 0x4000000) {
    this.words = [ number & 0x3ffffff ];
    this.length = 1;
  } else if (number < 0x10000000000000) {
    this.words = [
      number & 0x3ffffff,
      (number / 0x4000000) & 0x3ffffff
    ];
    this.length = 2;
  } else {
    assert(number < 0x20000000000000); // 2 ^ 53 (unsafe)
    this.words = [
      number & 0x3ffffff,
      (number / 0x4000000) & 0x3ffffff,
      1
    ];
    this.length = 3;
  }

  if (endian !== 'le')
    return;

  // Reverse the bytes
  this._initArray(this.toArray(), base, endian);
};

BN.prototype._initArray = function _initArray(number, base, endian) {
  // Perhaps a Uint8Array
  assert(typeof number.length === 'number');
  if (number.length <= 0) {
    this.words = [ 0 ];
    this.length = 1;
    return this;
  }

  this.length = Math.ceil(number.length / 3);
  this.words = new Array(this.length);
  for (var i = 0; i < this.length; i++)
    this.words[i] = 0;

  var off = 0;
  if (endian === 'be') {
    for (var i = number.length - 1, j = 0; i >= 0; i -= 3) {
      var w = number[i] | (number[i - 1] << 8) | (number[i - 2] << 16);
      this.words[j] |= (w << off) & 0x3ffffff;
      this.words[j + 1] = (w >>> (26 - off)) & 0x3ffffff;
      off += 24;
      if (off >= 26) {
        off -= 26;
        j++;
      }
    }
  } else if (endian === 'le') {
    for (var i = 0, j = 0; i < number.length; i += 3) {
      var w = number[i] | (number[i + 1] << 8) | (number[i + 2] << 16);
      this.words[j] |= (w << off) & 0x3ffffff;
      this.words[j + 1] = (w >>> (26 - off)) & 0x3ffffff;
      off += 24;
      if (off >= 26) {
        off -= 26;
        j++;
      }
    }
  }
  return this.strip();
};

function parseHex(str, start, end) {
  var r = 0;
  var len = Math.min(str.length, end);
  for (var i = start; i < len; i++) {
    var c = str.charCodeAt(i) - 48;

    r <<= 4;

    // 'a' - 'f'
    if (c >= 49 && c <= 54)
      r |= c - 49 + 0xa;

    // 'A' - 'F'
    else if (c >= 17 && c <= 22)
      r |= c - 17 + 0xa;

    // '0' - '9'
    else
      r |= c & 0xf;
  }
  return r;
}

BN.prototype._parseHex = function _parseHex(number, start) {
  // Create possibly bigger array to ensure that it fits the number
  this.length = Math.ceil((number.length - start) / 6);
  this.words = new Array(this.length);
  for (var i = 0; i < this.length; i++)
    this.words[i] = 0;

  // Scan 24-bit chunks and add them to the number
  var off = 0;
  for (var i = number.length - 6, j = 0; i >= start; i -= 6) {
    var w = parseHex(number, i, i + 6);
    this.words[j] |= (w << off) & 0x3ffffff;
    this.words[j + 1] |= w >>> (26 - off) & 0x3fffff;
    off += 24;
    if (off >= 26) {
      off -= 26;
      j++;
    }
  }
  if (i + 6 !== start) {
    var w = parseHex(number, start, i + 6);
    this.words[j] |= (w << off) & 0x3ffffff;
    this.words[j + 1] |= w >>> (26 - off) & 0x3fffff;
  }
  this.strip();
};

function parseBase(str, start, end, mul) {
  var r = 0;
  var len = Math.min(str.length, end);
  for (var i = start; i < len; i++) {
    var c = str.charCodeAt(i) - 48;

    r *= mul;

    // 'a'
    if (c >= 49)
      r += c - 49 + 0xa;

    // 'A'
    else if (c >= 17)
      r += c - 17 + 0xa;

    // '0' - '9'
    else
      r += c;
  }
  return r;
}

BN.prototype._parseBase = function _parseBase(number, base, start) {
  // Initialize as zero
  this.words = [ 0 ];
  this.length = 1;

  // Find length of limb in base
  for (var limbLen = 0, limbPow = 1; limbPow <= 0x3ffffff; limbPow *= base)
    limbLen++;
  limbLen--;
  limbPow = (limbPow / base) | 0;

  var total = number.length - start;
  var mod = total % limbLen;
  var end = Math.min(total, total - mod) + start;

  var word = 0;
  for (var i = start; i < end; i += limbLen) {
    word = parseBase(number, i, i + limbLen, base);

    this.imuln(limbPow);
    if (this.words[0] + word < 0x4000000)
      this.words[0] += word;
    else
      this._iaddn(word);
  }

  if (mod !== 0) {
    var pow = 1;
    var word = parseBase(number, i, number.length, base);

    for (var i = 0; i < mod; i++)
      pow *= base;
    this.imuln(pow);
    if (this.words[0] + word < 0x4000000)
      this.words[0] += word;
    else
      this._iaddn(word);
  }
};

BN.prototype.copy = function copy(dest) {
  dest.words = new Array(this.length);
  for (var i = 0; i < this.length; i++)
    dest.words[i] = this.words[i];
  dest.length = this.length;
  dest.sign = this.sign;
  dest.red = this.red;
};

BN.prototype.clone = function clone() {
  var r = new BN(null);
  this.copy(r);
  return r;
};

// Remove leading `0` from `this`
BN.prototype.strip = function strip() {
  while (this.length > 1 && this.words[this.length - 1] === 0)
    this.length--;
  return this._normSign();
};

BN.prototype._normSign = function _normSign() {
  // -0 = 0
  if (this.length === 1 && this.words[0] === 0)
    this.sign = false;
  return this;
};

BN.prototype.inspect = function inspect() {
  return (this.red ? '<BN-R: ' : '<BN: ') + this.toString(16) + '>';
};

/*

var zeros = [];
var groupSizes = [];
var groupBases = [];

var s = '';
var i = -1;
while (++i < BN.wordSize) {
  zeros[i] = s;
  s += '0';
}
groupSizes[0] = 0;
groupSizes[1] = 0;
groupBases[0] = 0;
groupBases[1] = 0;
var base = 2 - 1;
while (++base < 36 + 1) {
  var groupSize = 0;
  var groupBase = 1;
  while (groupBase < (1 << BN.wordSize) / base) {
    groupBase *= base;
    groupSize += 1;
  }
  groupSizes[base] = groupSize;
  groupBases[base] = groupBase;
}

*/

var zeros = [
  '',
  '0',
  '00',
  '000',
  '0000',
  '00000',
  '000000',
  '0000000',
  '00000000',
  '000000000',
  '0000000000',
  '00000000000',
  '000000000000',
  '0000000000000',
  '00000000000000',
  '000000000000000',
  '0000000000000000',
  '00000000000000000',
  '000000000000000000',
  '0000000000000000000',
  '00000000000000000000',
  '000000000000000000000',
  '0000000000000000000000',
  '00000000000000000000000',
  '000000000000000000000000',
  '0000000000000000000000000'
];

var groupSizes = [
  0, 0,
  25, 16, 12, 11, 10, 9, 8,
  8, 7, 7, 7, 7, 6, 6,
  6, 6, 6, 6, 6, 5, 5,
  5, 5, 5, 5, 5, 5, 5,
  5, 5, 5, 5, 5, 5, 5
];

var groupBases = [
  0, 0,
  33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216,
  43046721, 10000000, 19487171, 35831808, 62748517, 7529536, 11390625,
  16777216, 24137569, 34012224, 47045881, 64000000, 4084101, 5153632,
  6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149,
  24300000, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176
];

BN.prototype.toString = function toString(base, padding) {
  base = base || 10;
  if (base === 16 || base === 'hex') {
    var out = '';
    var off = 0;
    var padding = padding | 0 || 1;
    var carry = 0;
    for (var i = 0; i < this.length; i++) {
      var w = this.words[i];
      var word = (((w << off) | carry) & 0xffffff).toString(16);
      carry = (w >>> (24 - off)) & 0xffffff;
      if (carry !== 0 || i !== this.length - 1)
        out = zeros[6 - word.length] + word + out;
      else
        out = word + out;
      off += 2;
      if (off >= 26) {
        off -= 26;
        i--;
      }
    }
    if (carry !== 0)
      out = carry.toString(16) + out;
    while (out.length % padding !== 0)
      out = '0' + out;
    if (this.sign)
      out = '-' + out;
    return out;
  } else if (base === (base | 0) && base >= 2 && base <= 36) {
    // var groupSize = Math.floor(BN.wordSize * Math.LN2 / Math.log(base));
    var groupSize = groupSizes[base];
    // var groupBase = Math.pow(base, groupSize);
    var groupBase = groupBases[base];
    var out = '';
    var c = this.clone();
    c.sign = false;
    while (c.cmpn(0) !== 0) {
      var r = c.modn(groupBase).toString(base);
      c = c.idivn(groupBase);

      if (c.cmpn(0) !== 0)
        out = zeros[groupSize - r.length] + r + out;
      else
        out = r + out;
    }
    if (this.cmpn(0) === 0)
      out = '0' + out;
    if (this.sign)
      out = '-' + out;
    return out;
  } else {
    assert(false, 'Base should be between 2 and 36');
  }
};

BN.prototype.toJSON = function toJSON() {
  return this.toString(16);
};

BN.prototype.toArray = function toArray(endian) {
  this.strip();
  var res = new Array(this.byteLength());
  res[0] = 0;

  var q = this.clone();
  if (endian !== 'le') {
    // Assume big-endian
    for (var i = 0; q.cmpn(0) !== 0; i++) {
      var b = q.andln(0xff);
      q.ishrn(8);

      res[res.length - i - 1] = b;
    }
  } else {
    // Assume little-endian
    for (var i = 0; q.cmpn(0) !== 0; i++) {
      var b = q.andln(0xff);
      q.ishrn(8);

      res[i] = b;
    }
  }

  return res;
};

if (Math.clz32) {
  BN.prototype._countBits = function _countBits(w) {
    return 32 - Math.clz32(w);
  };
} else {
  BN.prototype._countBits = function _countBits(w) {
    var t = w;
    var r = 0;
    if (t >= 0x1000) {
      r += 13;
      t >>>= 13;
    }
    if (t >= 0x40) {
      r += 7;
      t >>>= 7;
    }
    if (t >= 0x8) {
      r += 4;
      t >>>= 4;
    }
    if (t >= 0x02) {
      r += 2;
      t >>>= 2;
    }
    return r + t;
  };
}

BN.prototype._zeroBits = function _zeroBits(w) {
  // Short-cut
  if (w === 0)
    return 26;

  var t = w;
  var r = 0;
  if ((t & 0x1fff) === 0) {
    r += 13;
    t >>>= 13;
  }
  if ((t & 0x7f) === 0) {
    r += 7;
    t >>>= 7;
  }
  if ((t & 0xf) === 0) {
    r += 4;
    t >>>= 4;
  }
  if ((t & 0x3) === 0) {
    r += 2;
    t >>>= 2;
  }
  if ((t & 0x1) === 0)
    r++;
  return r;
};

// Return number of used bits in a BN
BN.prototype.bitLength = function bitLength() {
  var hi = 0;
  var w = this.words[this.length - 1];
  var hi = this._countBits(w);
  return (this.length - 1) * 26 + hi;
};

// Number of trailing zero bits
BN.prototype.zeroBits = function zeroBits() {
  if (this.cmpn(0) === 0)
    return 0;

  var r = 0;
  for (var i = 0; i < this.length; i++) {
    var b = this._zeroBits(this.words[i]);
    r += b;
    if (b !== 26)
      break;
  }
  return r;
};

BN.prototype.byteLength = function byteLength() {
  return Math.ceil(this.bitLength() / 8);
};

// Return negative clone of `this`
BN.prototype.neg = function neg() {
  if (this.cmpn(0) === 0)
    return this.clone();

  var r = this.clone();
  r.sign = !this.sign;
  return r;
};


// Or `num` with `this` in-place
BN.prototype.ior = function ior(num) {
  this.sign = this.sign || num.sign;

  while (this.length < num.length)
    this.words[this.length++] = 0;

  for (var i = 0; i < num.length; i++)
    this.words[i] = this.words[i] | num.words[i];

  return this.strip();
};


// Or `num` with `this`
BN.prototype.or = function or(num) {
  if (this.length > num.length)
    return this.clone().ior(num);
  else
    return num.clone().ior(this);
};


// And `num` with `this` in-place
BN.prototype.iand = function iand(num) {
  this.sign = this.sign && num.sign;

  // b = min-length(num, this)
  var b;
  if (this.length > num.length)
    b = num;
  else
    b = this;

  for (var i = 0; i < b.length; i++)
    this.words[i] = this.words[i] & num.words[i];

  this.length = b.length;

  return this.strip();
};


// And `num` with `this`
BN.prototype.and = function and(num) {
  if (this.length > num.length)
    return this.clone().iand(num);
  else
    return num.clone().iand(this);
};


// Xor `num` with `this` in-place
BN.prototype.ixor = function ixor(num) {
  this.sign = this.sign || num.sign;

  // a.length > b.length
  var a;
  var b;
  if (this.length > num.length) {
    a = this;
    b = num;
  } else {
    a = num;
    b = this;
  }

  for (var i = 0; i < b.length; i++)
    this.words[i] = a.words[i] ^ b.words[i];

  if (this !== a)
    for (; i < a.length; i++)
      this.words[i] = a.words[i];

  this.length = a.length;

  return this.strip();
};


// Xor `num` with `this`
BN.prototype.xor = function xor(num) {
  if (this.length > num.length)
    return this.clone().ixor(num);
  else
    return num.clone().ixor(this);
};


// Set `bit` of `this`
BN.prototype.setn = function setn(bit, val) {
  assert(typeof bit === 'number' && bit >= 0);

  var off = (bit / 26) | 0;
  var wbit = bit % 26;

  while (this.length <= off)
    this.words[this.length++] = 0;

  if (val)
    this.words[off] = this.words[off] | (1 << wbit);
  else
    this.words[off] = this.words[off] & ~(1 << wbit);

  return this.strip();
};


// Add `num` to `this` in-place
BN.prototype.iadd = function iadd(num) {
  // negative + positive
  if (this.sign && !num.sign) {
    this.sign = false;
    var r = this.isub(num);
    this.sign = !this.sign;
    return this._normSign();

  // positive + negative
  } else if (!this.sign && num.sign) {
    num.sign = false;
    var r = this.isub(num);
    num.sign = true;
    return r._normSign();
  }

  // a.length > b.length
  var a;
  var b;
  if (this.length > num.length) {
    a = this;
    b = num;
  } else {
    a = num;
    b = this;
  }

  var carry = 0;
  for (var i = 0; i < b.length; i++) {
    var r = a.words[i] + b.words[i] + carry;
    this.words[i] = r & 0x3ffffff;
    carry = r >>> 26;
  }
  for (; carry !== 0 && i < a.length; i++) {
    var r = a.words[i] + carry;
    this.words[i] = r & 0x3ffffff;
    carry = r >>> 26;
  }

  this.length = a.length;
  if (carry !== 0) {
    this.words[this.length] = carry;
    this.length++;
  // Copy the rest of the words
  } else if (a !== this) {
    for (; i < a.length; i++)
      this.words[i] = a.words[i];
  }

  return this;
};

// Add `num` to `this`
BN.prototype.add = function add(num) {
  if (num.sign && !this.sign) {
    num.sign = false;
    var res = this.sub(num);
    num.sign = true;
    return res;
  } else if (!num.sign && this.sign) {
    this.sign = false;
    var res = num.sub(this);
    this.sign = true;
    return res;
  }

  if (this.length > num.length)
    return this.clone().iadd(num);
  else
    return num.clone().iadd(this);
};

// Subtract `num` from `this` in-place
BN.prototype.isub = function isub(num) {
  // this - (-num) = this + num
  if (num.sign) {
    num.sign = false;
    var r = this.iadd(num);
    num.sign = true;
    return r._normSign();

  // -this - num = -(this + num)
  } else if (this.sign) {
    this.sign = false;
    this.iadd(num);
    this.sign = true;
    return this._normSign();
  }

  // At this point both numbers are positive
  var cmp = this.cmp(num);

  // Optimization - zeroify
  if (cmp === 0) {
    this.sign = false;
    this.length = 1;
    this.words[0] = 0;
    return this;
  }

  // a > b
  var a;
  var b;
  if (cmp > 0) {
    a = this;
    b = num;
  } else {
    a = num;
    b = this;
  }

  var carry = 0;
  for (var i = 0; i < b.length; i++) {
    var r = a.words[i] - b.words[i] + carry;
    carry = r >> 26;
    this.words[i] = r & 0x3ffffff;
  }
  for (; carry !== 0 && i < a.length; i++) {
    var r = a.words[i] + carry;
    carry = r >> 26;
    this.words[i] = r & 0x3ffffff;
  }

  // Copy rest of the words
  if (carry === 0 && i < a.length && a !== this)
    for (; i < a.length; i++)
      this.words[i] = a.words[i];
  this.length = Math.max(this.length, i);

  if (a !== this)
    this.sign = true;

  return this.strip();
};

// Subtract `num` from `this`
BN.prototype.sub = function sub(num) {
  return this.clone().isub(num);
};

/*
// NOTE: This could be potentionally used to generate loop-less multiplications
function _genCombMulTo(alen, blen) {
  var len = alen + blen - 1;
  var src = [
    'var a = this.words, b = num.words, o = out.words, c = 0, w, ' +
        'mask = 0x3ffffff, shift = 0x4000000;',
    'out.length = ' + len + ';'
  ];
  for (var k = 0; k < len; k++) {
    var minJ = Math.max(0, k - alen + 1);
    var maxJ = Math.min(k, blen - 1);

    for (var j = minJ; j <= maxJ; j++) {
      var i = k - j;
      var mul = 'a[' + i + '] * b[' + j + ']';

      if (j === minJ) {
        src.push('w = ' + mul + ' + c;');
        src.push('c = (w / shift) | 0;');
      } else {
        src.push('w += ' + mul + ';');
        src.push('c += (w / shift) | 0;');
      }
      src.push('w &= mask;');
    }
    src.push('o[' + k + '] = w;');
  }
  src.push('if (c !== 0) {',
           '  o[' + k + '] = c;',
           '  out.length++;',
           '}',
           'return out;');

  return src.join('\n');
}
*/

BN.prototype._smallMulTo = function _smallMulTo(num, out) {
  out.sign = num.sign !== this.sign;
  out.length = this.length + num.length;

  var carry = 0;
  for (var k = 0; k < out.length - 1; k++) {
    // Sum all words with the same `i + j = k` and accumulate `ncarry`,
    // note that ncarry could be >= 0x3ffffff
    var ncarry = carry >>> 26;
    var rword = carry & 0x3ffffff;
    var maxJ = Math.min(k, num.length - 1);
    for (var j = Math.max(0, k - this.length + 1); j <= maxJ; j++) {
      var i = k - j;
      var a = this.words[i] | 0;
      var b = num.words[j] | 0;
      var r = a * b;

      var lo = r & 0x3ffffff;
      ncarry = (ncarry + ((r / 0x4000000) | 0)) | 0;
      lo = (lo + rword) | 0;
      rword = lo & 0x3ffffff;
      ncarry = (ncarry + (lo >>> 26)) | 0;
    }
    out.words[k] = rword;
    carry = ncarry;
  }
  if (carry !== 0) {
    out.words[k] = carry;
  } else {
    out.length--;
  }

  return out.strip();
};

BN.prototype._bigMulTo = function _bigMulTo(num, out) {
  out.sign = num.sign !== this.sign;
  out.length = this.length + num.length;

  var carry = 0;
  var hncarry = 0;
  for (var k = 0; k < out.length - 1; k++) {
    // Sum all words with the same `i + j = k` and accumulate `ncarry`,
    // note that ncarry could be >= 0x3ffffff
    var ncarry = hncarry;
    hncarry = 0;
    var rword = carry & 0x3ffffff;
    var maxJ = Math.min(k, num.length - 1);
    for (var j = Math.max(0, k - this.length + 1); j <= maxJ; j++) {
      var i = k - j;
      var a = this.words[i] | 0;
      var b = num.words[j] | 0;
      var r = a * b;

      var lo = r & 0x3ffffff;
      ncarry = (ncarry + ((r / 0x4000000) | 0)) | 0;
      lo = (lo + rword) | 0;
      rword = lo & 0x3ffffff;
      ncarry = (ncarry + (lo >>> 26)) | 0;

      hncarry += ncarry >>> 26;
      ncarry &= 0x3ffffff;
    }
    out.words[k] = rword;
    carry = ncarry;
    ncarry = hncarry;
  }
  if (carry !== 0) {
    out.words[k] = carry;
  } else {
    out.length--;
  }

  return out.strip();
};

BN.prototype.mulTo = function mulTo(num, out) {
  var res;
  if (this.length + num.length < 63)
    res = this._smallMulTo(num, out);
  else
    res = this._bigMulTo(num, out);
  return res;
};

// Multiply `this` by `num`
BN.prototype.mul = function mul(num) {
  var out = new BN(null);
  out.words = new Array(this.length + num.length);
  return this.mulTo(num, out);
};

// In-place Multiplication
BN.prototype.imul = function imul(num) {
  if (this.cmpn(0) === 0 || num.cmpn(0) === 0) {
    this.words[0] = 0;
    this.length = 1;
    return this;
  }

  var tlen = this.length;
  var nlen = num.length;

  this.sign = num.sign !== this.sign;
  this.length = this.length + num.length;
  this.words[this.length - 1] = 0;

  for (var k = this.length - 2; k >= 0; k--) {
    // Sum all words with the same `i + j = k` and accumulate `carry`,
    // note that carry could be >= 0x3ffffff
    var carry = 0;
    var rword = 0;
    var maxJ = Math.min(k, nlen - 1);
    for (var j = Math.max(0, k - tlen + 1); j <= maxJ; j++) {
      var i = k - j;
      var a = this.words[i];
      var b = num.words[j];
      var r = a * b;

      var lo = r & 0x3ffffff;
      carry += (r / 0x4000000) | 0;
      lo += rword;
      rword = lo & 0x3ffffff;
      carry += lo >>> 26;
    }
    this.words[k] = rword;
    this.words[k + 1] += carry;
    carry = 0;
  }

  // Propagate overflows
  var carry = 0;
  for (var i = 1; i < this.length; i++) {
    var w = this.words[i] + carry;
    this.words[i] = w & 0x3ffffff;
    carry = w >>> 26;
  }

  return this.strip();
};

BN.prototype.imuln = function imuln(num) {
  assert(typeof num === 'number');

  // Carry
  var carry = 0;
  for (var i = 0; i < this.length; i++) {
    var w = this.words[i] * num;
    var lo = (w & 0x3ffffff) + (carry & 0x3ffffff);
    carry >>= 26;
    carry += (w / 0x4000000) | 0;
    // NOTE: lo is 27bit maximum
    carry += lo >>> 26;
    this.words[i] = lo & 0x3ffffff;
  }

  if (carry !== 0) {
    this.words[i] = carry;
    this.length++;
  }

  return this;
};

BN.prototype.muln = function muln(num) {
  return this.clone().imuln(num);
};

// `this` * `this`
BN.prototype.sqr = function sqr() {
  return this.mul(this);
};

// `this` * `this` in-place
BN.prototype.isqr = function isqr() {
  return this.mul(this);
};

// Shift-left in-place
BN.prototype.ishln = function ishln(bits) {
  assert(typeof bits === 'number' && bits >= 0);
  var r = bits % 26;
  var s = (bits - r) / 26;
  var carryMask = (0x3ffffff >>> (26 - r)) << (26 - r);

  if (r !== 0) {
    var carry = 0;
    for (var i = 0; i < this.length; i++) {
      var newCarry = this.words[i] & carryMask;
      var c = (this.words[i] - newCarry) << r;
      this.words[i] = c | carry;
      carry = newCarry >>> (26 - r);
    }
    if (carry) {
      this.words[i] = carry;
      this.length++;
    }
  }

  if (s !== 0) {
    for (var i = this.length - 1; i >= 0; i--)
      this.words[i + s] = this.words[i];
    for (var i = 0; i < s; i++)
      this.words[i] = 0;
    this.length += s;
  }

  return this.strip();
};

// Shift-right in-place
// NOTE: `hint` is a lowest bit before trailing zeroes
// NOTE: if `extended` is present - it will be filled with destroyed bits
BN.prototype.ishrn = function ishrn(bits, hint, extended) {
  assert(typeof bits === 'number' && bits >= 0);
  var h;
  if (hint)
    h = (hint - (hint % 26)) / 26;
  else
    h = 0;

  var r = bits % 26;
  var s = Math.min((bits - r) / 26, this.length);
  var mask = 0x3ffffff ^ ((0x3ffffff >>> r) << r);
  var maskedWords = extended;

  h -= s;
  h = Math.max(0, h);

  // Extended mode, copy masked part
  if (maskedWords) {
    for (var i = 0; i < s; i++)
      maskedWords.words[i] = this.words[i];
    maskedWords.length = s;
  }

  if (s === 0) {
    // No-op, we should not move anything at all
  } else if (this.length > s) {
    this.length -= s;
    for (var i = 0; i < this.length; i++)
      this.words[i] = this.words[i + s];
  } else {
    this.words[0] = 0;
    this.length = 1;
  }

  var carry = 0;
  for (var i = this.length - 1; i >= 0 && (carry !== 0 || i >= h); i--) {
    var word = this.words[i];
    this.words[i] = (carry << (26 - r)) | (word >>> r);
    carry = word & mask;
  }

  // Push carried bits as a mask
  if (maskedWords && carry !== 0)
    maskedWords.words[maskedWords.length++] = carry;

  if (this.length === 0) {
    this.words[0] = 0;
    this.length = 1;
  }

  this.strip();

  return this;
};

// Shift-left
BN.prototype.shln = function shln(bits) {
  return this.clone().ishln(bits);
};

// Shift-right
BN.prototype.shrn = function shrn(bits) {
  return this.clone().ishrn(bits);
};

// Test if n bit is set
BN.prototype.testn = function testn(bit) {
  assert(typeof bit === 'number' && bit >= 0);
  var r = bit % 26;
  var s = (bit - r) / 26;
  var q = 1 << r;

  // Fast case: bit is much higher than all existing words
  if (this.length <= s) {
    return false;
  }

  // Check bit and return
  var w = this.words[s];

  return !!(w & q);
};

// Return only lowers bits of number (in-place)
BN.prototype.imaskn = function imaskn(bits) {
  assert(typeof bits === 'number' && bits >= 0);
  var r = bits % 26;
  var s = (bits - r) / 26;

  assert(!this.sign, 'imaskn works only with positive numbers');

  if (r !== 0)
    s++;
  this.length = Math.min(s, this.length);

  if (r !== 0) {
    var mask = 0x3ffffff ^ ((0x3ffffff >>> r) << r);
    this.words[this.length - 1] &= mask;
  }

  return this.strip();
};

// Return only lowers bits of number
BN.prototype.maskn = function maskn(bits) {
  return this.clone().imaskn(bits);
};

// Add plain number `num` to `this`
BN.prototype.iaddn = function iaddn(num) {
  assert(typeof num === 'number');
  if (num < 0)
    return this.isubn(-num);

  // Possible sign change
  if (this.sign) {
    if (this.length === 1 && this.words[0] < num) {
      this.words[0] = num - this.words[0];
      this.sign = false;
      return this;
    }

    this.sign = false;
    this.isubn(num);
    this.sign = true;
    return this;
  }

  // Add without checks
  return this._iaddn(num);
};

BN.prototype._iaddn = function _iaddn(num) {
  this.words[0] += num;

  // Carry
  for (var i = 0; i < this.length && this.words[i] >= 0x4000000; i++) {
    this.words[i] -= 0x4000000;
    if (i === this.length - 1)
      this.words[i + 1] = 1;
    else
      this.words[i + 1]++;
  }
  this.length = Math.max(this.length, i + 1);

  return this;
};

// Subtract plain number `num` from `this`
BN.prototype.isubn = function isubn(num) {
  assert(typeof num === 'number');
  if (num < 0)
    return this.iaddn(-num);

  if (this.sign) {
    this.sign = false;
    this.iaddn(num);
    this.sign = true;
    return this;
  }

  this.words[0] -= num;

  // Carry
  for (var i = 0; i < this.length && this.words[i] < 0; i++) {
    this.words[i] += 0x4000000;
    this.words[i + 1] -= 1;
  }

  return this.strip();
};

BN.prototype.addn = function addn(num) {
  return this.clone().iaddn(num);
};

BN.prototype.subn = function subn(num) {
  return this.clone().isubn(num);
};

BN.prototype.iabs = function iabs() {
  this.sign = false;

  return this;
};

BN.prototype.abs = function abs() {
  return this.clone().iabs();
};

BN.prototype._ishlnsubmul = function _ishlnsubmul(num, mul, shift) {
  // Bigger storage is needed
  var len = num.length + shift;
  var i;
  if (this.words.length < len) {
    var t = new Array(len);
    for (var i = 0; i < this.length; i++)
      t[i] = this.words[i];
    this.words = t;
  } else {
    i = this.length;
  }

  // Zeroify rest
  this.length = Math.max(this.length, len);
  for (; i < this.length; i++)
    this.words[i] = 0;

  var carry = 0;
  for (var i = 0; i < num.length; i++) {
    var w = this.words[i + shift] + carry;
    var right = num.words[i] * mul;
    w -= right & 0x3ffffff;
    carry = (w >> 26) - ((right / 0x4000000) | 0);
    this.words[i + shift] = w & 0x3ffffff;
  }
  for (; i < this.length - shift; i++) {
    var w = this.words[i + shift] + carry;
    carry = w >> 26;
    this.words[i + shift] = w & 0x3ffffff;
  }

  if (carry === 0)
    return this.strip();

  // Subtraction overflow
  assert(carry === -1);
  carry = 0;
  for (var i = 0; i < this.length; i++) {
    var w = -this.words[i] + carry;
    carry = w >> 26;
    this.words[i] = w & 0x3ffffff;
  }
  this.sign = true;

  return this.strip();
};

BN.prototype._wordDiv = function _wordDiv(num, mode) {
  var shift = this.length - num.length;

  var a = this.clone();
  var b = num;

  // Normalize
  var bhi = b.words[b.length - 1];
  var bhiBits = this._countBits(bhi);
  shift = 26 - bhiBits;
  if (shift !== 0) {
    b = b.shln(shift);
    a.ishln(shift);
    bhi = b.words[b.length - 1];
  }

  // Initialize quotient
  var m = a.length - b.length;
  var q;

  if (mode !== 'mod') {
    q = new BN(null);
    q.length = m + 1;
    q.words = new Array(q.length);
    for (var i = 0; i < q.length; i++)
      q.words[i] = 0;
  }

  var diff = a.clone()._ishlnsubmul(b, 1, m);
  if (!diff.sign) {
    a = diff;
    if (q)
      q.words[m] = 1;
  }

  for (var j = m - 1; j >= 0; j--) {
    var qj = a.words[b.length + j] * 0x4000000 + a.words[b.length + j - 1];

    // NOTE: (qj / bhi) is (0x3ffffff * 0x4000000 + 0x3ffffff) / 0x2000000 max
    // (0x7ffffff)
    qj = Math.min((qj / bhi) | 0, 0x3ffffff);

    a._ishlnsubmul(b, qj, j);
    while (a.sign) {
      qj--;
      a.sign = false;
      a._ishlnsubmul(b, 1, j);
      if (a.cmpn(0) !== 0)
        a.sign = !a.sign;
    }
    if (q)
      q.words[j] = qj;
  }
  if (q)
    q.strip();
  a.strip();

  // Denormalize
  if (mode !== 'div' && shift !== 0)
    a.ishrn(shift);
  return { div: q ? q : null, mod: a };
};

BN.prototype.divmod = function divmod(num, mode) {
  assert(num.cmpn(0) !== 0);

  if (this.sign && !num.sign) {
    var res = this.neg().divmod(num, mode);
    var div;
    var mod;
    if (mode !== 'mod')
      div = res.div.neg();
    if (mode !== 'div')
      mod = res.mod.cmpn(0) === 0 ? res.mod : num.sub(res.mod);
    return {
      div: div,
      mod: mod
    };
  } else if (!this.sign && num.sign) {
    var res = this.divmod(num.neg(), mode);
    var div;
    if (mode !== 'mod')
      div = res.div.neg();
    return { div: div, mod: res.mod };
  } else if (this.sign && num.sign) {
    return this.neg().divmod(num.neg(), mode);
  }

  // Both numbers are positive at this point

  // Strip both numbers to approximate shift value
  if (num.length > this.length || this.cmp(num) < 0)
    return { div: new BN(0), mod: this };

  // Very short reduction
  if (num.length === 1) {
    if (mode === 'div')
      return { div: this.divn(num.words[0]), mod: null };
    else if (mode === 'mod')
      return { div: null, mod: new BN(this.modn(num.words[0])) };
    return {
      div: this.divn(num.words[0]),
      mod: new BN(this.modn(num.words[0]))
    };
  }

  return this._wordDiv(num, mode);
};

// Find `this` / `num`
BN.prototype.div = function div(num) {
  return this.divmod(num, 'div').div;
};

// Find `this` % `num`
BN.prototype.mod = function mod(num) {
  return this.divmod(num, 'mod').mod;
};

// Find Round(`this` / `num`)
BN.prototype.divRound = function divRound(num) {
  var dm = this.divmod(num);

  // Fast case - exact division
  if (dm.mod.cmpn(0) === 0)
    return dm.div;

  var mod = dm.div.sign ? dm.mod.isub(num) : dm.mod;

  var half = num.shrn(1);
  var r2 = num.andln(1);
  var cmp = mod.cmp(half);

  // Round down
  if (cmp < 0 || r2 === 1 && cmp === 0)
    return dm.div;

  // Round up
  return dm.div.sign ? dm.div.isubn(1) : dm.div.iaddn(1);
};

BN.prototype.modn = function modn(num) {
  assert(num <= 0x3ffffff);
  var p = (1 << 26) % num;

  var acc = 0;
  for (var i = this.length - 1; i >= 0; i--)
    acc = (p * acc + this.words[i]) % num;

  return acc;
};

// In-place division by number
BN.prototype.idivn = function idivn(num) {
  assert(num <= 0x3ffffff);

  var carry = 0;
  for (var i = this.length - 1; i >= 0; i--) {
    var w = this.words[i] + carry * 0x4000000;
    this.words[i] = (w / num) | 0;
    carry = w % num;
  }

  return this.strip();
};

BN.prototype.divn = function divn(num) {
  return this.clone().idivn(num);
};

BN.prototype.egcd = function egcd(p) {
  assert(!p.sign);
  assert(p.cmpn(0) !== 0);

  var x = this;
  var y = p.clone();

  if (x.sign)
    x = x.mod(p);
  else
    x = x.clone();

  // A * x + B * y = x
  var A = new BN(1);
  var B = new BN(0);

  // C * x + D * y = y
  var C = new BN(0);
  var D = new BN(1);

  var g = 0;

  while (x.isEven() && y.isEven()) {
    x.ishrn(1);
    y.ishrn(1);
    ++g;
  }

  var yp = y.clone();
  var xp = x.clone();

  while (x.cmpn(0) !== 0) {
    while (x.isEven()) {
      x.ishrn(1);
      if (A.isEven() && B.isEven()) {
        A.ishrn(1);
        B.ishrn(1);
      } else {
        A.iadd(yp).ishrn(1);
        B.isub(xp).ishrn(1);
      }
    }

    while (y.isEven()) {
      y.ishrn(1);
      if (C.isEven() && D.isEven()) {
        C.ishrn(1);
        D.ishrn(1);
      } else {
        C.iadd(yp).ishrn(1);
        D.isub(xp).ishrn(1);
      }
    }

    if (x.cmp(y) >= 0) {
      x.isub(y);
      A.isub(C);
      B.isub(D);
    } else {
      y.isub(x);
      C.isub(A);
      D.isub(B);
    }
  }

  return {
    a: C,
    b: D,
    gcd: y.ishln(g)
  };
};

// This is reduced incarnation of the binary EEA
// above, designated to invert members of the
// _prime_ fields F(p) at a maximal speed
BN.prototype._invmp = function _invmp(p) {
  assert(!p.sign);
  assert(p.cmpn(0) !== 0);

  var a = this;
  var b = p.clone();

  if (a.sign)
    a = a.mod(p);
  else
    a = a.clone();

  var x1 = new BN(1);
  var x2 = new BN(0);

  var delta = b.clone();

  while (a.cmpn(1) > 0 && b.cmpn(1) > 0) {
    while (a.isEven()) {
      a.ishrn(1);
      if (x1.isEven())
        x1.ishrn(1);
      else
        x1.iadd(delta).ishrn(1);
    }
    while (b.isEven()) {
      b.ishrn(1);
      if (x2.isEven())
        x2.ishrn(1);
      else
        x2.iadd(delta).ishrn(1);
    }
    if (a.cmp(b) >= 0) {
      a.isub(b);
      x1.isub(x2);
    } else {
      b.isub(a);
      x2.isub(x1);
    }
  }
  if (a.cmpn(1) === 0)
    return x1;
  else
    return x2;
};

BN.prototype.gcd = function gcd(num) {
  if (this.cmpn(0) === 0)
    return num.clone();
  if (num.cmpn(0) === 0)
    return this.clone();

  var a = this.clone();
  var b = num.clone();
  a.sign = false;
  b.sign = false;

  // Remove common factor of two
  for (var shift = 0; a.isEven() && b.isEven(); shift++) {
    a.ishrn(1);
    b.ishrn(1);
  }

  do {
    while (a.isEven())
      a.ishrn(1);
    while (b.isEven())
      b.ishrn(1);

    var r = a.cmp(b);
    if (r < 0) {
      // Swap `a` and `b` to make `a` always bigger than `b`
      var t = a;
      a = b;
      b = t;
    } else if (r === 0 || b.cmpn(1) === 0) {
      break;
    }

    a.isub(b);
  } while (true);

  return b.ishln(shift);
};

// Invert number in the field F(num)
BN.prototype.invm = function invm(num) {
  return this.egcd(num).a.mod(num);
};

BN.prototype.isEven = function isEven() {
  return (this.words[0] & 1) === 0;
};

BN.prototype.isOdd = function isOdd() {
  return (this.words[0] & 1) === 1;
};

// And first word and num
BN.prototype.andln = function andln(num) {
  return this.words[0] & num;
};

// Increment at the bit position in-line
BN.prototype.bincn = function bincn(bit) {
  assert(typeof bit === 'number');
  var r = bit % 26;
  var s = (bit - r) / 26;
  var q = 1 << r;

  // Fast case: bit is much higher than all existing words
  if (this.length <= s) {
    for (var i = this.length; i < s + 1; i++)
      this.words[i] = 0;
    this.words[s] |= q;
    this.length = s + 1;
    return this;
  }

  // Add bit and propagate, if needed
  var carry = q;
  for (var i = s; carry !== 0 && i < this.length; i++) {
    var w = this.words[i];
    w += carry;
    carry = w >>> 26;
    w &= 0x3ffffff;
    this.words[i] = w;
  }
  if (carry !== 0) {
    this.words[i] = carry;
    this.length++;
  }
  return this;
};

BN.prototype.cmpn = function cmpn(num) {
  var sign = num < 0;
  if (sign)
    num = -num;

  if (this.sign && !sign)
    return -1;
  else if (!this.sign && sign)
    return 1;

  num &= 0x3ffffff;
  this.strip();

  var res;
  if (this.length > 1) {
    res = 1;
  } else {
    var w = this.words[0];
    res = w === num ? 0 : w < num ? -1 : 1;
  }
  if (this.sign)
    res = -res;
  return res;
};

// Compare two numbers and return:
// 1 - if `this` > `num`
// 0 - if `this` == `num`
// -1 - if `this` < `num`
BN.prototype.cmp = function cmp(num) {
  if (this.sign && !num.sign)
    return -1;
  else if (!this.sign && num.sign)
    return 1;

  var res = this.ucmp(num);
  if (this.sign)
    return -res;
  else
    return res;
};

// Unsigned comparison
BN.prototype.ucmp = function ucmp(num) {
  // At this point both numbers have the same sign
  if (this.length > num.length)
    return 1;
  else if (this.length < num.length)
    return -1;

  var res = 0;
  for (var i = this.length - 1; i >= 0; i--) {
    var a = this.words[i];
    var b = num.words[i];

    if (a === b)
      continue;
    if (a < b)
      res = -1;
    else if (a > b)
      res = 1;
    break;
  }
  return res;
};

//
// A reduce context, could be using montgomery or something better, depending
// on the `m` itself.
//
BN.red = function red(num) {
  return new Red(num);
};

BN.prototype.toRed = function toRed(ctx) {
  assert(!this.red, 'Already a number in reduction context');
  assert(!this.sign, 'red works only with positives');
  return ctx.convertTo(this)._forceRed(ctx);
};

BN.prototype.fromRed = function fromRed() {
  assert(this.red, 'fromRed works only with numbers in reduction context');
  return this.red.convertFrom(this);
};

BN.prototype._forceRed = function _forceRed(ctx) {
  this.red = ctx;
  return this;
};

BN.prototype.forceRed = function forceRed(ctx) {
  assert(!this.red, 'Already a number in reduction context');
  return this._forceRed(ctx);
};

BN.prototype.redAdd = function redAdd(num) {
  assert(this.red, 'redAdd works only with red numbers');
  return this.red.add(this, num);
};

BN.prototype.redIAdd = function redIAdd(num) {
  assert(this.red, 'redIAdd works only with red numbers');
  return this.red.iadd(this, num);
};

BN.prototype.redSub = function redSub(num) {
  assert(this.red, 'redSub works only with red numbers');
  return this.red.sub(this, num);
};

BN.prototype.redISub = function redISub(num) {
  assert(this.red, 'redISub works only with red numbers');
  return this.red.isub(this, num);
};

BN.prototype.redShl = function redShl(num) {
  assert(this.red, 'redShl works only with red numbers');
  return this.red.shl(this, num);
};

BN.prototype.redMul = function redMul(num) {
  assert(this.red, 'redMul works only with red numbers');
  this.red._verify2(this, num);
  return this.red.mul(this, num);
};

BN.prototype.redIMul = function redIMul(num) {
  assert(this.red, 'redMul works only with red numbers');
  this.red._verify2(this, num);
  return this.red.imul(this, num);
};

BN.prototype.redSqr = function redSqr() {
  assert(this.red, 'redSqr works only with red numbers');
  this.red._verify1(this);
  return this.red.sqr(this);
};

BN.prototype.redISqr = function redISqr() {
  assert(this.red, 'redISqr works only with red numbers');
  this.red._verify1(this);
  return this.red.isqr(this);
};

// Square root over p
BN.prototype.redSqrt = function redSqrt() {
  assert(this.red, 'redSqrt works only with red numbers');
  this.red._verify1(this);
  return this.red.sqrt(this);
};

BN.prototype.redInvm = function redInvm() {
  assert(this.red, 'redInvm works only with red numbers');
  this.red._verify1(this);
  return this.red.invm(this);
};

// Return negative clone of `this` % `red modulo`
BN.prototype.redNeg = function redNeg() {
  assert(this.red, 'redNeg works only with red numbers');
  this.red._verify1(this);
  return this.red.neg(this);
};

BN.prototype.redPow = function redPow(num) {
  assert(this.red && !num.red, 'redPow(normalNum)');
  this.red._verify1(this);
  return this.red.pow(this, num);
};

// Prime numbers with efficient reduction
var primes = {
  k256: null,
  p224: null,
  p192: null,
  p25519: null
};

// Pseudo-Mersenne prime
function MPrime(name, p) {
  // P = 2 ^ N - K
  this.name = name;
  this.p = new BN(p, 16);
  this.n = this.p.bitLength();
  this.k = new BN(1).ishln(this.n).isub(this.p);

  this.tmp = this._tmp();
}

MPrime.prototype._tmp = function _tmp() {
  var tmp = new BN(null);
  tmp.words = new Array(Math.ceil(this.n / 13));
  return tmp;
};

MPrime.prototype.ireduce = function ireduce(num) {
  // Assumes that `num` is less than `P^2`
  // num = HI * (2 ^ N - K) + HI * K + LO = HI * K + LO (mod P)
  var r = num;
  var rlen;

  do {
    this.split(r, this.tmp);
    r = this.imulK(r);
    r = r.iadd(this.tmp);
    rlen = r.bitLength();
  } while (rlen > this.n);

  var cmp = rlen < this.n ? -1 : r.ucmp(this.p);
  if (cmp === 0) {
    r.words[0] = 0;
    r.length = 1;
  } else if (cmp > 0) {
    r.isub(this.p);
  } else {
    r.strip();
  }

  return r;
};

MPrime.prototype.split = function split(input, out) {
  input.ishrn(this.n, 0, out);
};

MPrime.prototype.imulK = function imulK(num) {
  return num.imul(this.k);
};

function K256() {
  MPrime.call(
    this,
    'k256',
    'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f');
}
inherits(K256, MPrime);

K256.prototype.split = function split(input, output) {
  // 256 = 9 * 26 + 22
  var mask = 0x3fffff;

  var outLen = Math.min(input.length, 9);
  for (var i = 0; i < outLen; i++)
    output.words[i] = input.words[i];
  output.length = outLen;

  if (input.length <= 9) {
    input.words[0] = 0;
    input.length = 1;
    return;
  }

  // Shift by 9 limbs
  var prev = input.words[9];
  output.words[output.length++] = prev & mask;

  for (var i = 10; i < input.length; i++) {
    var next = input.words[i];
    input.words[i - 10] = ((next & mask) << 4) | (prev >>> 22);
    prev = next;
  }
  input.words[i - 10] = prev >>> 22;
  input.length -= 9;
};

K256.prototype.imulK = function imulK(num) {
  // K = 0x1000003d1 = [ 0x40, 0x3d1 ]
  num.words[num.length] = 0;
  num.words[num.length + 1] = 0;
  num.length += 2;

  // bounded at: 0x40 * 0x3ffffff + 0x3d0 = 0x100000390
  var hi;
  var lo = 0;
  for (var i = 0; i < num.length; i++) {
    var w = num.words[i];
    hi = w * 0x40;
    lo += w * 0x3d1;
    hi += (lo / 0x4000000) | 0;
    lo &= 0x3ffffff;

    num.words[i] = lo;

    lo = hi;
  }

  // Fast length reduction
  if (num.words[num.length - 1] === 0) {
    num.length--;
    if (num.words[num.length - 1] === 0)
      num.length--;
  }
  return num;
};

function P224() {
  MPrime.call(
    this,
    'p224',
    'ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001');
}
inherits(P224, MPrime);

function P192() {
  MPrime.call(
    this,
    'p192',
    'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff');
}
inherits(P192, MPrime);

function P25519() {
  // 2 ^ 255 - 19
  MPrime.call(
    this,
    '25519',
    '7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed');
}
inherits(P25519, MPrime);

P25519.prototype.imulK = function imulK(num) {
  // K = 0x13
  var carry = 0;
  for (var i = 0; i < num.length; i++) {
    var hi = num.words[i] * 0x13 + carry;
    var lo = hi & 0x3ffffff;
    hi >>>= 26;

    num.words[i] = lo;
    carry = hi;
  }
  if (carry !== 0)
    num.words[num.length++] = carry;
  return num;
};

// Exported mostly for testing purposes, use plain name instead
BN._prime = function prime(name) {
  // Cached version of prime
  if (primes[name])
    return primes[name];

  var prime;
  if (name === 'k256')
    prime = new K256();
  else if (name === 'p224')
    prime = new P224();
  else if (name === 'p192')
    prime = new P192();
  else if (name === 'p25519')
    prime = new P25519();
  else
    throw new Error('Unknown prime ' + name);
  primes[name] = prime;

  return prime;
};

//
// Base reduction engine
//
function Red(m) {
  if (typeof m === 'string') {
    var prime = BN._prime(m);
    this.m = prime.p;
    this.prime = prime;
  } else {
    this.m = m;
    this.prime = null;
  }
}

Red.prototype._verify1 = function _verify1(a) {
  assert(!a.sign, 'red works only with positives');
  assert(a.red, 'red works only with red numbers');
};

Red.prototype._verify2 = function _verify2(a, b) {
  assert(!a.sign && !b.sign, 'red works only with positives');
  assert(a.red && a.red === b.red,
         'red works only with red numbers');
};

Red.prototype.imod = function imod(a) {
  if (this.prime)
    return this.prime.ireduce(a)._forceRed(this);
  return a.mod(this.m)._forceRed(this);
};

Red.prototype.neg = function neg(a) {
  var r = a.clone();
  r.sign = !r.sign;
  return r.iadd(this.m)._forceRed(this);
};

Red.prototype.add = function add(a, b) {
  this._verify2(a, b);

  var res = a.add(b);
  if (res.cmp(this.m) >= 0)
    res.isub(this.m);
  return res._forceRed(this);
};

Red.prototype.iadd = function iadd(a, b) {
  this._verify2(a, b);

  var res = a.iadd(b);
  if (res.cmp(this.m) >= 0)
    res.isub(this.m);
  return res;
};

Red.prototype.sub = function sub(a, b) {
  this._verify2(a, b);

  var res = a.sub(b);
  if (res.cmpn(0) < 0)
    res.iadd(this.m);
  return res._forceRed(this);
};

Red.prototype.isub = function isub(a, b) {
  this._verify2(a, b);

  var res = a.isub(b);
  if (res.cmpn(0) < 0)
    res.iadd(this.m);
  return res;
};

Red.prototype.shl = function shl(a, num) {
  this._verify1(a);
  return this.imod(a.shln(num));
};

Red.prototype.imul = function imul(a, b) {
  this._verify2(a, b);
  return this.imod(a.imul(b));
};

Red.prototype.mul = function mul(a, b) {
  this._verify2(a, b);
  return this.imod(a.mul(b));
};

Red.prototype.isqr = function isqr(a) {
  return this.imul(a, a);
};

Red.prototype.sqr = function sqr(a) {
  return this.mul(a, a);
};

Red.prototype.sqrt = function sqrt(a) {
  if (a.cmpn(0) === 0)
    return a.clone();

  var mod3 = this.m.andln(3);
  assert(mod3 % 2 === 1);

  // Fast case
  if (mod3 === 3) {
    var pow = this.m.add(new BN(1)).ishrn(2);
    var r = this.pow(a, pow);
    return r;
  }

  // Tonelli-Shanks algorithm (Totally unoptimized and slow)
  //
  // Find Q and S, that Q * 2 ^ S = (P - 1)
  var q = this.m.subn(1);
  var s = 0;
  while (q.cmpn(0) !== 0 && q.andln(1) === 0) {
    s++;
    q.ishrn(1);
  }
  assert(q.cmpn(0) !== 0);

  var one = new BN(1).toRed(this);
  var nOne = one.redNeg();

  // Find quadratic non-residue
  // NOTE: Max is such because of generalized Riemann hypothesis.
  var lpow = this.m.subn(1).ishrn(1);
  var z = this.m.bitLength();
  z = new BN(2 * z * z).toRed(this);
  while (this.pow(z, lpow).cmp(nOne) !== 0)
    z.redIAdd(nOne);

  var c = this.pow(z, q);
  var r = this.pow(a, q.addn(1).ishrn(1));
  var t = this.pow(a, q);
  var m = s;
  while (t.cmp(one) !== 0) {
    var tmp = t;
    for (var i = 0; tmp.cmp(one) !== 0; i++)
      tmp = tmp.redSqr();
    assert(i < m);
    var b = this.pow(c, new BN(1).ishln(m - i - 1));

    r = r.redMul(b);
    c = b.redSqr();
    t = t.redMul(c);
    m = i;
  }

  return r;
};

Red.prototype.invm = function invm(a) {
  var inv = a._invmp(this.m);
  if (inv.sign) {
    inv.sign = false;
    return this.imod(inv).redNeg();
  } else {
    return this.imod(inv);
  }
};

Red.prototype.pow = function pow(a, num) {
  var w = [];

  if (num.cmpn(0) === 0)
    return new BN(1);

  var q = num.clone();

  while (q.cmpn(0) !== 0) {
    w.push(q.andln(1));
    q.ishrn(1);
  }

  // Skip leading zeroes
  var res = a;
  for (var i = 0; i < w.length; i++, res = this.sqr(res))
    if (w[i] !== 0)
      break;

  if (++i < w.length) {
    for (var q = this.sqr(res); i < w.length; i++, q = this.sqr(q)) {
      if (w[i] === 0)
        continue;
      res = this.mul(res, q);
    }
  }

  return res;
};

Red.prototype.convertTo = function convertTo(num) {
  var r = num.mod(this.m);
  if (r === num)
    return r.clone();
  else
    return r;
};

Red.prototype.convertFrom = function convertFrom(num) {
  var res = num.clone();
  res.red = null;
  return res;
};

//
// Montgomery method engine
//

BN.mont = function mont(num) {
  return new Mont(num);
};

function Mont(m) {
  Red.call(this, m);

  this.shift = this.m.bitLength();
  if (this.shift % 26 !== 0)
    this.shift += 26 - (this.shift % 26);
  this.r = new BN(1).ishln(this.shift);
  this.r2 = this.imod(this.r.sqr());
  this.rinv = this.r._invmp(this.m);

  this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);
  this.minv.sign = true;
  this.minv = this.minv.mod(this.r);
}
inherits(Mont, Red);

Mont.prototype.convertTo = function convertTo(num) {
  return this.imod(num.shln(this.shift));
};

Mont.prototype.convertFrom = function convertFrom(num) {
  var r = this.imod(num.mul(this.rinv));
  r.red = null;
  return r;
};

Mont.prototype.imul = function imul(a, b) {
  if (a.cmpn(0) === 0 || b.cmpn(0) === 0) {
    a.words[0] = 0;
    a.length = 1;
    return a;
  }

  var t = a.imul(b);
  var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
  var u = t.isub(c).ishrn(this.shift);
  var res = u;
  if (u.cmp(this.m) >= 0)
    res = u.isub(this.m);
  else if (u.cmpn(0) < 0)
    res = u.iadd(this.m);

  return res._forceRed(this);
};

Mont.prototype.mul = function mul(a, b) {
  if (a.cmpn(0) === 0 || b.cmpn(0) === 0)
    return new BN(0)._forceRed(this);

  var t = a.mul(b);
  var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
  var u = t.isub(c).ishrn(this.shift);
  var res = u;
  if (u.cmp(this.m) >= 0)
    res = u.isub(this.m);
  else if (u.cmpn(0) < 0)
    res = u.iadd(this.m);

  return res._forceRed(this);
};

Mont.prototype.invm = function invm(a) {
  // (AR)^-1 * R^2 = (A^-1 * R^-1) * R^2 = A^-1 * R
  var res = this.imod(a._invmp(this.m).mul(this.r2));
  return res._forceRed(this);
};

})(typeof module === 'undefined' || module, this);

},{}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/pskcrypto/lib/asn1/constants/der.js":[function(require,module,exports){
var constants = require('../constants');

exports.tagClass = {
  0: 'universal',
  1: 'application',
  2: 'context',
  3: 'private'
};
exports.tagClassByName = constants._reverse(exports.tagClass);

exports.tag = {
  0x00: 'end',
  0x01: 'bool',
  0x02: 'int',
  0x03: 'bitstr',
  0x04: 'octstr',
  0x05: 'null_',
  0x06: 'objid',
  0x07: 'objDesc',
  0x08: 'external',
  0x09: 'real',
  0x0a: 'enum',
  0x0b: 'embed',
  0x0c: 'utf8str',
  0x0d: 'relativeOid',
  0x10: 'seq',
  0x11: 'set',
  0x12: 'numstr',
  0x13: 'printstr',
  0x14: 't61str',
  0x15: 'videostr',
  0x16: 'ia5str',
  0x17: 'utctime',
  0x18: 'gentime',
  0x19: 'graphstr',
  0x1a: 'iso646str',
  0x1b: 'genstr',
  0x1c: 'unistr',
  0x1d: 'charstr',
  0x1e: 'bmpstr'
};
exports.tagByName = constants._reverse(exports.tag);

},{"../constants":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/pskcrypto/lib/asn1/constants/index.js"}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/pskcrypto/lib/asn1/constants/index.js":[function(require,module,exports){
var constants = exports;

// Helper
constants._reverse = function reverse(map) {
  var res = {};

  Object.keys(map).forEach(function(key) {
    // Convert key to integer if it is stringified
    if ((key | 0) == key)
      key = key | 0;

    var value = map[key];
    res[value] = key;
  });

  return res;
};

constants.der = require('./der');

},{"./der":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/pskcrypto/lib/asn1/constants/der.js"}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/pskcrypto/lib/asn1/decoders/der.js":[function(require,module,exports){
var inherits = require('util').inherits;

var asn1 = require('../asn1');
var base = asn1.base;
var bignum = asn1.bignum;

// Import DER constants
var der = asn1.constants.der;

function DERDecoder(entity) {
  this.enc = 'der';
  this.name = entity.name;
  this.entity = entity;

  // Construct base tree
  this.tree = new DERNode();
  this.tree._init(entity.body);
};
module.exports = DERDecoder;

DERDecoder.prototype.decode = function decode(data, options) {
  if (!(data instanceof base.DecoderBuffer))
    data = new base.DecoderBuffer(data, options);

  return this.tree._decode(data, options);
};

// Tree methods

function DERNode(parent) {
  base.Node.call(this, 'der', parent);
}
inherits(DERNode, base.Node);

DERNode.prototype._peekTag = function peekTag(buffer, tag, any) {
  if (buffer.isEmpty())
    return false;

  var state = buffer.save();
  var decodedTag = derDecodeTag(buffer, 'Failed to peek tag: "' + tag + '"');
  if (buffer.isError(decodedTag))
    return decodedTag;

  buffer.restore(state);

  return decodedTag.tag === tag || decodedTag.tagStr === tag || any;
};

DERNode.prototype._decodeTag = function decodeTag(buffer, tag, any) {
  var decodedTag = derDecodeTag(buffer,
                                'Failed to decode tag of "' + tag + '"');
  if (buffer.isError(decodedTag))
    return decodedTag;

  var len = derDecodeLen(buffer,
                         decodedTag.primitive,
                         'Failed to get length of "' + tag + '"');

  // Failure
  if (buffer.isError(len))
    return len;

  if (!any &&
      decodedTag.tag !== tag &&
      decodedTag.tagStr !== tag &&
      decodedTag.tagStr + 'of' !== tag) {
    return buffer.error('Failed to match tag: "' + tag + '"');
  }

  if (decodedTag.primitive || len !== null)
    return buffer.skip(len, 'Failed to match body of: "' + tag + '"');

  // Indefinite length... find END tag
  var state = buffer.save();
  var res = this._skipUntilEnd(
      buffer,
      'Failed to skip indefinite length body: "' + this.tag + '"');
  if (buffer.isError(res))
    return res;

  len = buffer.offset - state.offset;
  buffer.restore(state);
  return buffer.skip(len, 'Failed to match body of: "' + tag + '"');
};

DERNode.prototype._skipUntilEnd = function skipUntilEnd(buffer, fail) {
  while (true) {
    var tag = derDecodeTag(buffer, fail);
    if (buffer.isError(tag))
      return tag;
    var len = derDecodeLen(buffer, tag.primitive, fail);
    if (buffer.isError(len))
      return len;

    var res;
    if (tag.primitive || len !== null)
      res = buffer.skip(len)
    else
      res = this._skipUntilEnd(buffer, fail);

    // Failure
    if (buffer.isError(res))
      return res;

    if (tag.tagStr === 'end')
      break;
  }
};

DERNode.prototype._decodeList = function decodeList(buffer, tag, decoder) {
  var result = [];
  while (!buffer.isEmpty()) {
    var possibleEnd = this._peekTag(buffer, 'end');
    if (buffer.isError(possibleEnd))
      return possibleEnd;

    var res = decoder.decode(buffer, 'der');
    if (buffer.isError(res) && possibleEnd)
      break;
    result.push(res);
  }
  return result;
};

DERNode.prototype._decodeStr = function decodeStr(buffer, tag) {
  if (tag === 'octstr') {
    return buffer.raw();
  } else if (tag === 'bitstr') {
    var unused = buffer.readUInt8();
    if (buffer.isError(unused))
      return unused;

    return { unused: unused, data: buffer.raw() };
  } else if (tag === 'ia5str' || tag === 'utf8str') {
    return buffer.raw().toString();
  } else {
    return this.error('Decoding of string type: ' + tag + ' unsupported');
  }
};

DERNode.prototype._decodeObjid = function decodeObjid(buffer, values, relative) {
  var identifiers = [];
  var ident = 0;
  while (!buffer.isEmpty()) {
    var subident = buffer.readUInt8();
    ident <<= 7;
    ident |= subident & 0x7f;
    if ((subident & 0x80) === 0) {
      identifiers.push(ident);
      ident = 0;
    }
  }
  if (subident & 0x80)
    identifiers.push(ident);

  var first = (identifiers[0] / 40) | 0;
  var second = identifiers[0] % 40;

  if (relative)
    result = identifiers;
  else
    result = [first, second].concat(identifiers.slice(1));

  if (values)
    result = values[result.join(' ')];

  return result;
};

DERNode.prototype._decodeTime = function decodeTime(buffer, tag) {
  var str = buffer.raw().toString();
  if (tag === 'gentime') {
    var year = str.slice(0, 4) | 0;
    var mon = str.slice(4, 6) | 0;
    var day = str.slice(6, 8) | 0;
    var hour = str.slice(8, 10) | 0;
    var min = str.slice(10, 12) | 0;
    var sec = str.slice(12, 14) | 0;
  } else if (tag === 'utctime') {
    var year = str.slice(0, 2) | 0;
    var mon = str.slice(2, 4) | 0;
    var day = str.slice(4, 6) | 0;
    var hour = str.slice(6, 8) | 0;
    var min = str.slice(8, 10) | 0;
    var sec = str.slice(10, 12) | 0;
    if (year < 70)
      year = 2000 + year;
    else
      year = 1900 + year;
  } else {
    return this.error('Decoding ' + tag + ' time is not supported yet');
  }

  return Date.UTC(year, mon - 1, day, hour, min, sec, 0);
};

DERNode.prototype._decodeNull = function decodeNull(buffer) {
  return null;
};

DERNode.prototype._decodeBool = function decodeBool(buffer) {
  var res = buffer.readUInt8();
  if (buffer.isError(res))
    return res;
  else
    return res !== 0;
};

DERNode.prototype._decodeInt = function decodeInt(buffer, values) {
  // Bigint, return as it is (assume big endian)
  var raw = buffer.raw();
  var res = new bignum(raw);

  if (values)
    res = values[res.toString(10)] || res;

  return res;
};

DERNode.prototype._use = function use(entity, obj) {
  if (typeof entity === 'function')
    entity = entity(obj);
  return entity._getDecoder('der').tree;
};

// Utility methods

function derDecodeTag(buf, fail) {
  var tag = buf.readUInt8(fail);
  if (buf.isError(tag))
    return tag;

  var cls = der.tagClass[tag >> 6];
  var primitive = (tag & 0x20) === 0;

  // Multi-octet tag - load
  if ((tag & 0x1f) === 0x1f) {
    var oct = tag;
    tag = 0;
    while ((oct & 0x80) === 0x80) {
      oct = buf.readUInt8(fail);
      if (buf.isError(oct))
        return oct;

      tag <<= 7;
      tag |= oct & 0x7f;
    }
  } else {
    tag &= 0x1f;
  }
  var tagStr = der.tag[tag];

  return {
    cls: cls,
    primitive: primitive,
    tag: tag,
    tagStr: tagStr
  };
}

function derDecodeLen(buf, primitive, fail) {
  var len = buf.readUInt8(fail);
  if (buf.isError(len))
    return len;

  // Indefinite form
  if (!primitive && len === 0x80)
    return null;

  // Definite form
  if ((len & 0x80) === 0) {
    // Short form
    return len;
  }

  // Long form
  var num = len & 0x7f;
  if (num >= 4)
    return buf.error('length octect is too long');

  len = 0;
  for (var i = 0; i < num; i++) {
    len <<= 8;
    var j = buf.readUInt8(fail);
    if (buf.isError(j))
      return j;
    len |= j;
  }

  return len;
}

},{"../asn1":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/pskcrypto/lib/asn1/asn1.js","util":false}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/pskcrypto/lib/asn1/decoders/index.js":[function(require,module,exports){
var decoders = exports;

decoders.der = require('./der');
decoders.pem = require('./pem');

},{"./der":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/pskcrypto/lib/asn1/decoders/der.js","./pem":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/pskcrypto/lib/asn1/decoders/pem.js"}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/pskcrypto/lib/asn1/decoders/pem.js":[function(require,module,exports){
const inherits = require('util').inherits;

const asn1 = require('../asn1');
const DERDecoder = require('./der');

function PEMDecoder(entity) {
    DERDecoder.call(this, entity);
    this.enc = 'pem';
};
inherits(PEMDecoder, DERDecoder);
module.exports = PEMDecoder;

PEMDecoder.prototype.decode = function decode(data, options) {
    const lines = data.toString().split(/[\r\n]+/g);

    const label = options.label.toUpperCase();

    const re = /^-----(BEGIN|END) ([^-]+)-----$/;
    let start = -1;
    let end = -1;
    for (let i = 0; i < lines.length; i++) {
        const match = lines[i].match(re);
        if (match === null)
            continue;

        if (match[2] !== label)
            continue;

        if (start === -1) {
            if (match[1] !== 'BEGIN')
                break;
            start = i;
        } else {
            if (match[1] !== 'END')
                break;
            end = i;
            break;
        }
    }
    if (start === -1 || end === -1)
        throw new Error('PEM section not found for: ' + label);

    const base64 = lines.slice(start + 1, end).join('');
    // Remove excessive symbols
    base64.replace(/[^a-z0-9\+\/=]+/gi, '');
    const input = $$.Buffer.from(base64, 'base64');
    return DERDecoder.prototype.decode.call(this, input, options);
};

},{"../asn1":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/pskcrypto/lib/asn1/asn1.js","./der":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/pskcrypto/lib/asn1/decoders/der.js","util":false}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/pskcrypto/lib/asn1/encoders/der.js":[function(require,module,exports){
const inherits = require('util').inherits;
const asn1 = require('../asn1');
const base = asn1.base;
const bignum = asn1.bignum;

// Import DER constants
const der = asn1.constants.der;

function DEREncoder(entity) {
    this.enc = 'der';
    this.name = entity.name;
    this.entity = entity;

    // Construct base tree
    this.tree = new DERNode();
    this.tree._init(entity.body);
}
module.exports = DEREncoder;

DEREncoder.prototype.encode = function encode(data, reporter) {
    return this.tree._encode(data, reporter).join();
};

// Tree methods

function DERNode(parent) {
    base.Node.call(this, 'der', parent);
}

inherits(DERNode, base.Node);

DERNode.prototype._encodeComposite = function encodeComposite(tag, primitive, cls, content) {
    const encodedTag = encodeTag(tag, primitive, cls, this.reporter);

    // Short form
    if (content.length < 0x80) {
        const header = $$.Buffer.alloc(2);
        header[0] = encodedTag;
        header[1] = content.length;
        return this._createEncoderBuffer([header, content]);
    }

    // Long form
    // Count octets required to store length
    let lenOctets = 1;
    for (let i = content.length; i >= 0x100; i >>= 8)
        lenOctets++;

    const header = $$.Buffer.alloc(1 + 1 + lenOctets);
    header[0] = encodedTag;
    header[1] = 0x80 | lenOctets;

    for (let i = 1 + lenOctets, j = content.length; j > 0; i--, j >>= 8)
        header[i] = j & 0xff;

    return this._createEncoderBuffer([header, content]);
};

DERNode.prototype._encodeStr = function encodeStr(str, tag) {
    if (tag === 'octstr')
        return this._createEncoderBuffer(str);
    else if (tag === 'bitstr')
        return this._createEncoderBuffer([str.unused | 0, str.data]);
    else if (tag === 'ia5str' || tag === 'utf8str')
        return this._createEncoderBuffer(str);
    return this.reporter.error('Encoding of string type: ' + tag +
        ' unsupported');
};

DERNode.prototype._encodeObjid = function encodeObjid(id, values, relative) {
    if (typeof id === 'string') {
        if (!values)
            return this.reporter.error('string objid given, but no values map found');
        if (!values.hasOwnProperty(id))
            return this.reporter.error('objid not found in values map');
        id = values[id].split(/[\s\.]+/g);
        for (let i = 0; i < id.length; i++)
            id[i] |= 0;
    } else if (Array.isArray(id)) {
        id = id.slice();
        for (let i = 0; i < id.length; i++)
            id[i] |= 0;
    }

    if (!Array.isArray(id)) {
        return this.reporter.error('objid() should be either array or string, ' +
            'got: ' + JSON.stringify(id));
    }

    if (!relative) {
        if (id[1] >= 40)
            return this.reporter.error('Second objid identifier OOB');
        id.splice(0, 2, id[0] * 40 + id[1]);
    }

    // Count number of octets
    let size = 0;
    for (let i = 0; i < id.length; i++) {
        let ident = id[i];
        for (size++; ident >= 0x80; ident >>= 7)
            size++;
    }

    const objid = $$.Buffer.alloc(size);
    let offset = objid.length - 1;
    for (let i = id.length - 1; i >= 0; i--) {
        let ident = id[i];
        objid[offset--] = ident & 0x7f;
        while ((ident >>= 7) > 0)
            objid[offset--] = 0x80 | (ident & 0x7f);
    }

    return this._createEncoderBuffer(objid);
};

function two(num) {
    if (num < 10)
        return '0' + num;
    else
        return num;
}

DERNode.prototype._encodeTime = function encodeTime(time, tag) {
    let str;
    const date = new Date(time);

    if (tag === 'gentime') {
        str = [
            two(date.getFullYear()),
            two(date.getUTCMonth() + 1),
            two(date.getUTCDate()),
            two(date.getUTCHours()),
            two(date.getUTCMinutes()),
            two(date.getUTCSeconds()),
            'Z'
        ].join('');
    } else if (tag === 'utctime') {
        str = [
            two(date.getFullYear() % 100),
            two(date.getUTCMonth() + 1),
            two(date.getUTCDate()),
            two(date.getUTCHours()),
            two(date.getUTCMinutes()),
            two(date.getUTCSeconds()),
            'Z'
        ].join('');
    } else {
        this.reporter.error('Encoding ' + tag + ' time is not supported yet');
    }

    return this._encodeStr(str, 'octstr');
};

DERNode.prototype._encodeNull = function encodeNull() {
    return this._createEncoderBuffer('');
};

DERNode.prototype._encodeInt = function encodeInt(num, values) {
    if (typeof num === 'string') {
        if (!values)
            return this.reporter.error('String int or enum given, but no values map');
        if (!values.hasOwnProperty(num)) {
            return this.reporter.error('Values map doesn\'t contain: ' +
                JSON.stringify(num));
        }
        num = values[num];
    }

    // Bignum, assume big endian
    if (typeof num !== 'number' && !$$.Buffer.isBuffer(num)) {
        const numArray = num.toArray();
        if (num.sign === false && numArray[0] & 0x80) {
            numArray.unshift(0);
        }
        num = $$.Buffer.from(numArray);
    }

    if ($$.Buffer.isBuffer(num)) {
        let size = num.length;
        if (num.length === 0)
            size++;

        const out = $$.Buffer.alloc(size);
        num.copy(out);
        if (num.length === 0)
            out[0] = 0
        return this._createEncoderBuffer(out);
    }

    if (num < 0x80)
        return this._createEncoderBuffer(num);

    if (num < 0x100)
        return this._createEncoderBuffer([0, num]);

    let size = 1;
    for (let i = num; i >= 0x100; i >>= 8)
        size++;

    const out = new Array(size);
    for (let i = out.length - 1; i >= 0; i--) {
        out[i] = num & 0xff;
        num >>= 8;
    }
    if (out[0] & 0x80) {
        out.unshift(0);
    }

    return this._createEncoderBuffer($$.Buffer.from(out));
};

DERNode.prototype._encodeBool = function encodeBool(value) {
    return this._createEncoderBuffer(value ? 0xff : 0);
};

DERNode.prototype._use = function use(entity, obj) {
    if (typeof entity === 'function')
        entity = entity(obj);
    return entity._getEncoder('der').tree;
};

DERNode.prototype._skipDefault = function skipDefault(dataBuffer, reporter, parent) {
    const state = this._baseState;
    let i;
    if (state['default'] === null)
        return false;

    const data = dataBuffer.join();
    if (state.defaultBuffer === undefined)
        state.defaultBuffer = this._encodeValue(state['default'], reporter, parent).join();

    if (data.length !== state.defaultBuffer.length)
        return false;

    for (i = 0; i < data.length; i++)
        if (data[i] !== state.defaultBuffer[i])
            return false;

    return true;
};

// Utility methods

function encodeTag(tag, primitive, cls, reporter) {
    let res;

    if (tag === 'seqof')
        tag = 'seq';
    else if (tag === 'setof')
        tag = 'set';

    if (der.tagByName.hasOwnProperty(tag))
        res = der.tagByName[tag];
    else if (typeof tag === 'number' && (tag | 0) === tag)
        res = tag;
    else
        return reporter.error('Unknown tag: ' + tag);

    if (res >= 0x1f)
        return reporter.error('Multi-octet tag encoding unsupported');

    if (!primitive)
        res |= 0x20;

    res |= (der.tagClassByName[cls || 'universal'] << 6);

    return res;
}

},{"../asn1":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/pskcrypto/lib/asn1/asn1.js","util":false}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/pskcrypto/lib/asn1/encoders/index.js":[function(require,module,exports){
var encoders = exports;

encoders.der = require('./der');
encoders.pem = require('./pem');

},{"./der":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/pskcrypto/lib/asn1/encoders/der.js","./pem":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/pskcrypto/lib/asn1/encoders/pem.js"}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/pskcrypto/lib/asn1/encoders/pem.js":[function(require,module,exports){
var inherits = require('util').inherits;

var asn1 = require('../asn1');
var DEREncoder = require('./der');

function PEMEncoder(entity) {
  DEREncoder.call(this, entity);
  this.enc = 'pem';
};
inherits(PEMEncoder, DEREncoder);
module.exports = PEMEncoder;

PEMEncoder.prototype.encode = function encode(data, options) {
  var buf = DEREncoder.prototype.encode.call(this, data);

  var p = buf.toString('base64');
  var out = [ '-----BEGIN ' + options.label + '-----' ];
  for (var i = 0; i < p.length; i += 64)
    out.push(p.slice(i, i + 64));
  out.push('-----END ' + options.label + '-----');
  return out.join('\n');
};

},{"../asn1":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/pskcrypto/lib/asn1/asn1.js","./der":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/pskcrypto/lib/asn1/encoders/der.js","util":false}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/pskcrypto/lib/keyEncoder.js":[function(require,module,exports){
'use strict'

const asn1 = require('./asn1/asn1');
const BN = require('./asn1/bignum/bn');

const ECPrivateKeyASN = asn1.define('ECPrivateKey', function () {
    this.seq().obj(
        this.key('version').int(),
        this.key('privateKey').octstr(),
        this.key('parameters').explicit(0).objid().optional(),
        this.key('publicKey').explicit(1).bitstr().optional()
    )
})

const SubjectPublicKeyInfoASN = asn1.define('SubjectPublicKeyInfo', function () {
    this.seq().obj(
        this.key('algorithm').seq().obj(
            this.key("id").objid(),
            this.key("curve").objid()
        ),
        this.key('pub').bitstr()
    )
})

const ECDSASignature = asn1.define('ECDSASignature', function () {
    return this.seq().obj(
        this.key('r').int(),
        this.key('s').int()
    );
});

const curves = {
    secp256k1: {
        curveParameters: [1, 3, 132, 0, 10],
        privatePEMOptions: {label: 'EC PRIVATE KEY'},
        publicPEMOptions: {label: 'PUBLIC KEY'}
    }
}

function assert(val, msg) {
    if (!val) {
        throw new Error(msg || 'Assertion failed')
    }
}

function KeyEncoder(options) {
    if (typeof options === 'string') {
        assert(curves.hasOwnProperty(options), 'Unknown curve ' + options);
        options = curves[options]
    }
    this.options = options;
    this.algorithmID = [1, 2, 840, 10045, 2, 1]
}

KeyEncoder.ECPrivateKeyASN = ECPrivateKeyASN;
KeyEncoder.SubjectPublicKeyInfoASN = SubjectPublicKeyInfoASN;
KeyEncoder.ECDSASignature = ECDSASignature;

KeyEncoder.prototype.privateKeyObject = function (rawPrivateKey, rawPublicKey, encodingFormat = "hex") {
    const privateKeyObject = {
        version: new BN(1),
        privateKey: $$.Buffer.from(rawPrivateKey, encodingFormat),
        parameters: this.options.curveParameters,
        pemOptions: {label: "EC PRIVATE KEY"}
    };

    if (rawPublicKey) {
        privateKeyObject.publicKey = {
            unused: 0,
            data: $$.Buffer.from(rawPublicKey, encodingFormat)
        }
    }

    return privateKeyObject
};

KeyEncoder.prototype.publicKeyObject = function (rawPublicKey, encodingFormat = "hex") {
    return {
        algorithm: {
            id: this.algorithmID,
            curve: this.options.curveParameters
        },
        pub: {
            unused: 0,
            data: rawPublicKey
        },
        pemOptions: {label: "PUBLIC KEY"}
    }
}

KeyEncoder.prototype.encodePrivate = function (privateKey, originalFormat, destinationFormat, encodingFormat = "hex") {
    let privateKeyObject;

    /* Parse the incoming private key and convert it to a private key object */
    if (originalFormat === 'raw') {
        if (!$$.Buffer.isBuffer(privateKey)) {
            throw Error('private key must be a buffer');
        }
        let privateKeyObject = this.options.curve.keyFromPrivate(privateKey, encodingFormat),
            rawPublicKey = privateKeyObject.getPublic(encodingFormat)
        privateKeyObject = this.privateKeyObject(privateKey, rawPublicKey)
    } else if (originalFormat === 'der') {
        if ($$.Buffer.isBuffer(privateKey)) {
            // do nothing
        } else if (typeof privateKey === 'string') {
            privateKey = $$.Buffer.from(privateKey, encodingFormat);
        } else {
            throw Error('private key must be a buffer or a string');
        }
        privateKeyObject = ECPrivateKeyASN.decode(privateKey, 'der')
    } else if (originalFormat === 'pem') {
        if (typeof privateKey !== 'string') {
            throw Error('private key must be a string');
        }
        privateKeyObject = ECPrivateKeyASN.decode(privateKey, 'pem', this.options.privatePEMOptions)
    } else {
        throw Error('invalid private key format');
    }

    /* Export the private key object to the desired format */
    if (destinationFormat === 'raw') {
        return privateKeyObject.privateKey;
    } else if (destinationFormat === 'der') {
        return ECPrivateKeyASN.encode(privateKeyObject, 'der').toString(encodingFormat)
    } else if (destinationFormat === 'pem') {
        return ECPrivateKeyASN.encode(privateKeyObject, 'pem', this.options.privatePEMOptions)
    } else {
        throw Error('invalid destination format for private key');
    }
}

KeyEncoder.prototype.encodePublic = function (publicKey, originalFormat, destinationFormat, encodingFormat = "hex") {
    let publicKeyObject;

    /* Parse the incoming public key and convert it to a public key object */
    if (originalFormat === 'raw') {
        if (!$$.Buffer.isBuffer(publicKey)) {
            throw Error('public key must be a buffer');
        }
        publicKeyObject = this.publicKeyObject(publicKey)
    } else if (originalFormat === 'der') {
        if ($$.Buffer.isBuffer(publicKey)) {
            // do nothing
        } else if (typeof publicKey === 'string') {
            publicKey = $$.Buffer.from(publicKey, encodingFormat)
        } else {
            throw Error('public key must be a buffer or a string');
        }
        publicKeyObject = SubjectPublicKeyInfoASN.decode(publicKey, 'der')
    } else if (originalFormat === 'pem') {
        if (!(typeof publicKey === 'string')) {
            throw Error('public key must be a string');
        }
        publicKeyObject = SubjectPublicKeyInfoASN.decode(publicKey, 'pem', this.options.publicPEMOptions)
    } else {
        throw Error('invalid public key format');
    }

    /* Export the private key object to the desired format */
    if (destinationFormat === 'raw') {
        return publicKeyObject.pub.data;
    } else if (destinationFormat === 'der') {
        return SubjectPublicKeyInfoASN.encode(publicKeyObject, 'der').toString(encodingFormat)
    } else if (destinationFormat === 'pem') {
        return SubjectPublicKeyInfoASN.encode(publicKeyObject, 'pem', this.options.publicPEMOptions)
    } else {
        throw Error('invalid destination format for public key');
    }
}

module.exports = KeyEncoder;

},{"./asn1/asn1":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/pskcrypto/lib/asn1/asn1.js","./asn1/bignum/bn":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/pskcrypto/lib/asn1/bignum/bn.js"}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/pskcrypto/lib/utils/DuplexStream.js":[function(require,module,exports){
const stream = require('stream');
const util = require('util');

const Duplex = stream.Duplex;

function DuplexStream(options) {
	if (!(this instanceof DuplexStream)) {
		return new DuplexStream(options);
	}
	Duplex.call(this, options);
}
util.inherits(DuplexStream, Duplex);

DuplexStream.prototype._write = function (chunk, enc, cb) {
	this.push(chunk);
	cb();
};


DuplexStream.prototype._read = function (n) {

};

module.exports = DuplexStream;
},{"stream":false,"util":false}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/pskcrypto/lib/utils/base58.js":[function(require,module,exports){
const ALPHABET = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
const BASE = ALPHABET.length;
const LEADER = ALPHABET.charAt(0);
const FACTOR = Math.log(BASE) / Math.log(256); // log(BASE) / log(256), rounded up
const iFACTOR = Math.log(256) / Math.log(BASE); // log(256) / log(BASE), rounded up

const BASE_MAP = $$.Buffer.alloc(256);
for (let j = 0; j < BASE_MAP.length; j++) {
    BASE_MAP[j] = 255
}
for (let i = 0; i < ALPHABET.length; i++) {
    let x = ALPHABET.charAt(i);
    let xc = x.charCodeAt(0);
    if (BASE_MAP[xc] !== 255) {
        throw new TypeError(x + ' is ambiguous');
    }
    BASE_MAP[xc] = i;
}

function encode(source) {
    if (Array.isArray(source) || source instanceof Uint8Array || typeof source === "string") {
        source = $$.Buffer.from(source);
    }
    if (!$$.Buffer.isBuffer(source)) {
        throw new TypeError('Expected $$.Buffer');
    }
    if (source.length === 0) {
        return '';
    }
    // Skip & count leading zeroes.
    let zeroes = 0;
    let length = 0;
    let pbegin = 0;
    const pend = source.length;
    while (pbegin !== pend && source[pbegin] === 0) {
        pbegin++;
        zeroes++;
    }
    // Allocate enough space in big-endian base58 representation.
    const size = ((pend - pbegin) * iFACTOR + 1) >>> 0;
    const b58 = $$.Buffer.alloc(size);
    // Process the bytes.
    while (pbegin !== pend) {
        let carry = source[pbegin];
        // Apply "b58 = b58 * 256 + ch".
        let i = 0;
        for (let it1 = size - 1; (carry !== 0 || i < length) && (it1 !== -1); it1--, i++) {
            carry += (256 * b58[it1]) >>> 0;
            b58[it1] = (carry % BASE) >>> 0;
            carry = (carry / BASE) >>> 0;
        }
        if (carry !== 0) {
            throw new Error('Non-zero carry');
        }
        length = i;
        pbegin++;
    }
    // Skip leading zeroes in base58 result.
    let it2 = size - length;
    while (it2 !== size && b58[it2] === 0) {
        it2++;
    }
    // Translate the result into a string.
    let str = LEADER.repeat(zeroes);
    for (; it2 < size; ++it2) {
        str += ALPHABET.charAt(b58[it2]);
    }
    return str;
}

function decode(source) {
    if (typeof source !== 'string') {
        throw new TypeError('Expected String');
    }
    if (source.length === 0) {
        return $$.Buffer.alloc(0);
    }
    let psz = 0;
    // Skip leading spaces.
    if (source[psz] === ' ') {
        return;
    }
    // Skip and count leading '1's.
    let zeroes = 0;
    let length = 0;
    while (source[psz] === LEADER) {
        zeroes++;
        psz++;
    }
    // Allocate enough space in big-endian base256 representation.
    const size = (((source.length - psz) * FACTOR) + 1) >>> 0; // log(58) / log(256), rounded up.
    const b256 = $$.Buffer.alloc(size);
    // Process the characters.
    while (source[psz]) {
        // Decode character
        let carry = BASE_MAP[source.charCodeAt(psz)];
        // Invalid character
        if (carry === 255) {
            return;
        }
        let i = 0;
        for (let it3 = size - 1; (carry !== 0 || i < length) && (it3 !== -1); it3--, i++) {
            carry += (BASE * b256[it3]) >>> 0;
            b256[it3] = (carry % 256) >>> 0;
            carry = (carry / 256) >>> 0;
        }
        if (carry !== 0) {
            throw new Error('Non-zero carry');
        }
        length = i;
        psz++;
    }
    // Skip trailing spaces.
    if (source[psz] === ' ') {
        return;
    }
    // Skip leading zeroes in b256.
    let it4 = size - length;
    while (it4 !== size && b256[it4] === 0) {
        it4++;
    }
    const vch = $$.Buffer.alloc(zeroes + (size - it4));
    vch.fill(0x00, 0, zeroes);
    let j = zeroes;
    while (it4 !== size) {
        vch[j++] = b256[it4++];
    }
    return vch;
}

module.exports = {
    encode,
    decode
};
},{}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/pskcrypto/lib/utils/base64.js":[function(require,module,exports){
(function (Buffer){(function (){
const ALPHABET = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
const BASE_MAP = {};
for (let i = 0; i < ALPHABET.length; i++) {
    BASE_MAP[ALPHABET[i]] = i;
}

function encode(source) {
    if (typeof source !== "string") {
        source = source.toString();
    }
    let digits = [];
    let length = 0;
    let b64 = '';
    for (let i = 0; i <= source.length; i += 3) {
        let number = 0;
        let j;
        for (j = i; j < i + 3 && j < source.length; j++) {
            number = number * 256 + source.charCodeAt(j);
        }

        if (j % 3 === 1) {
            number *= 16;
        } else if (j % 3 === 2) {
            number *= 4;
        }

        let previousLength = length;
        while (number > 0) {
            digits[length] = number % 64;
            length++;
            number = Math.floor(number / 64);
        }
        for (let k = previousLength; k < length; k++) {
            b64 += ALPHABET[digits[length + previousLength - 1 - k]];
        }
    }
    let paddingLength = 0;
    if (length % 4 > 0) {
        paddingLength = 4 - length % 4;
    }
    for (let i = 0; i < paddingLength; i++) {
        b64 += "=";
    }
    return b64;
}

function decode(source) {
    if (typeof source !== "string") {
        source = source.toString();
    }
    let paddingLength = 0;
    for (let i = 0; i < source.length; i++) {
        if (source.charAt(i) === "=") {
            paddingLength++;
        }
    }
    let digits = [];
    let length = 0;
    let rest = (source.length - paddingLength) % 4;
    let size = (source.length - paddingLength - rest) * 3 / 4;
    if (paddingLength === 2) {
        size++;
    } else if (paddingLength === 1) {
        size += 2;
    }

    let b256 = '';
    for (let i = 0; i <= source.length - paddingLength; i += 4) {
        let number = 0;
        let j;
        for (j = i; j < i + 4 && j < source.length - paddingLength - 1; j++) {
            number = number * 64 + BASE_MAP[source.charAt(j)];
        }

        if (j % 4 === 1) {
            number = number * 4 + Math.floor(BASE_MAP[source.charAt(j)] / 16);
        } else if (j % 4 === 2) {
            number = number * 16 + Math.floor(BASE_MAP[source.charAt(j)] / 4);
        } else if (j % 4 === 3) {
            number = number * 64 + BASE_MAP[source.charAt(j)];
        }

        let previousLength = length;
        while (length - previousLength < 3 && length < size) {
            digits[length] = number % 256;
            length++;
            number = Math.floor(number / 256);
        }
        for (let k = previousLength; k < length; k++) {
            b256 += String.fromCharCode(digits[length + previousLength - 1 - k]);
        }
    }

    return Buffer.from(b256);
}

function encodeBase64(data) {
    if (!Buffer.isBuffer(data)) {
        data = Buffer.from(data);
    }

    return data.toString("base64");
}

function decodeBase64(data) {
    if (!Buffer.isBuffer(data)) {
        data = Buffer.from(data);
    }

    return Buffer.from(data.toString(), "base64");
}

module.exports = {
    encode: encodeBase64,
    decode: decodeBase64
}
}).call(this)}).call(this,require("buffer").Buffer)

},{"buffer":false}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/pskcrypto/lib/utils/cryptoUtils.js":[function(require,module,exports){
const base58 = require('./base58');
const base64 = require('./base64');
const keyEncoder = require("../keyEncoder");

const keySizes = [128, 192, 256];
const authenticationModes = ["ocb", "ccm", "gcm"];

function encode(buffer) {
    return buffer.toString('base64')
        .replace(/\+/g, '')
        .replace(/\//g, '')
        .replace(/=+$/, '');
}

function createPskHash(data, encoding) {
    const pskHash = new PskHash();
    pskHash.update(data);
    return pskHash.digest(encoding);
}

function PskHash() {
    const crypto = require('crypto');

    const sha512 = crypto.createHash('sha512');
    const sha256 = crypto.createHash('sha256');

    function update(data) {
        sha512.update(data);
    }

    function digest(encoding) {
        sha256.update(sha512.digest());
        return sha256.digest(encoding);
    }

    return {
        update, digest
    }
}


function generateSalt(inputData, saltLen) {
    const crypto = require('crypto');
    const hash = crypto.createHash('sha512');
    hash.update(inputData);
    const digest = $$.Buffer.from(hash.digest('hex'), 'binary');

    return digest.slice(0, saltLen);
}

function encryptionIsAuthenticated(algorithm) {
    for (const mode of authenticationModes) {
        if (algorithm.includes(mode)) {
            return true;
        }
    }

    return false;
}

function getKeyLength(algorithm) {
    for (const len of keySizes) {
        if (algorithm.includes(len.toString())) {
            return len / 8;
        }
    }

    throw new Error("Invalid encryption algorithm.");
}

function base58Encode(data) {
    return base58.encode(data);
}

function base58Decode(data) {
    return base58.decode(data);
}

function base64Encode(data) {
    return base64.encode(data);
}

function base64Decode(data) {
    return base64.decode(data);
}

const PEM_TYPES = ["PRIVATE KEY", "PUBLIC KEY", "CERTIFICATE"];
const isPemEncoded = (key) => {
    if (typeof key !== "string") {
        return false;
    }

    for (let i = 0; i < PEM_TYPES.length; i++) {
        if (key.includes(PEM_TYPES[i])) {
            return true;
        }
    }

    return false;
}

const convertPemToDer = (str) => {
    const SEP = "-----";
    const slicedValue = str.slice(SEP.length, str.length - SEP.length);
    const firstIndex = slicedValue.indexOf(SEP) + SEP.length;
    const lastIndex = slicedValue.lastIndexOf(SEP);
    return $$.Buffer.from(slicedValue.slice(firstIndex, lastIndex), "base64");
}

const convertDerPrivateKeyToRaw = (privateKey) => {
    const keyEncoder = require("../keyEncoder");
    const asn1PrivateKey = keyEncoder.ECPrivateKeyASN.decode(privateKey, "der");
    return asn1PrivateKey.privateKey;
};

const convertPemPrivateKeyToRaw = (privateKey) => {
    const derPrivateKey = convertPemToDer(privateKey);
    return convertDerPrivateKeyToRaw(derPrivateKey);
};

module.exports = {
    createPskHash,
    encode,
    generateSalt,
    PskHash,
    base58Encode,
    base58Decode,
    getKeyLength,
    encryptionIsAuthenticated,
    base64Encode,
    base64Decode,
    isPemEncoded,
    convertPemToDer,
    convertDerPrivateKeyToRaw,
    convertPemPrivateKeyToRaw
};


},{"../keyEncoder":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/pskcrypto/lib/keyEncoder.js","./base58":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/pskcrypto/lib/utils/base58.js","./base64":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/pskcrypto/lib/utils/base64.js","crypto":false}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/pskcrypto/lib/utils/eth.js":[function(require,module,exports){
(function (Buffer){(function (){
const keyEncoder = require("../keyEncoder");
const BN = require('../asn1/bignum/bn');
const ECKeyGenerator = require("../ECKeyGenerator");
const utils = require("../utils/cryptoUtils");

function bnToBuffer(bn) {
    return stripZeros($$.Buffer.from(padToEven(bn.toString(16)), 'hex'));
}

function padToEven(str) {
    return str.length % 2 ? '0' + str : str;
}

function padToLength(buff, len) {
    const buffer = Buffer.alloc(len);

    buffer.fill(0);
    const offset = len - buff.length;
    for (let i = 0; i < len - offset; i++) {
        buffer[i + offset] = buff[i]
    }
    return buffer;
}

function stripZeros(buffer) {
    var i = 0; // eslint-disable-line
    for (i = 0; i < buffer.length; i++) {
        if (buffer[i] !== 0) {
            break;
        }
    }
    return i > 0 ? buffer.slice(i) : buffer;
}

function decodeDERIntoASN1ETH(derSignatureBuffer) {
    const rsSig = keyEncoder.ECDSASignature.decode(derSignatureBuffer, 'der');
    let rBuffer = padToLength(bnToBuffer(rsSig.r), 32);
    let sBuffer = padToLength(bnToBuffer(rsSig.s), 32);
    //build signature
    return '0x' + $$.Buffer.concat([rBuffer, sBuffer]).toString('hex');
}

function getRSFromSignature(signature) {
    const rsSig = keyEncoder.ECDSASignature.decode(signature, 'der');
    let r = padToLength(bnToBuffer(rsSig.r), 32);
    let s = padToLength(bnToBuffer(rsSig.s), 32);
    return {r, s}
}

function convertRSSignatureToDer(rsvSignature) {
    const r = new BN(rsvSignature.slice(0, 32).toString("hex"), 16);
    const s = new BN(rsvSignature.slice(32).toString("hex"), 16);
    const derEncodedSignature = keyEncoder.ECDSASignature.encode({r, s}, "der");
    return derEncodedSignature;
}

function sign(data, privateKey) {
    const keyPairGenerator = ECKeyGenerator.createECKeyGenerator();
    const pemPrivateKey = keyPairGenerator.convertPrivateKey(privateKey);
    const pskcrypto = require("../PskCrypto");
    const signature = pskcrypto.sign("sha256", data, pemPrivateKey);
    const {r, s} = getRSFromSignature(signature);
    return $$.Buffer.concat([r, s]);
}

function verify(data, signature, publicKey) {
    if (!$$.Buffer.isBuffer(data)) {
        data = $$.Buffer.from(data);
    }

    const keyPairGenerator = ECKeyGenerator.createECKeyGenerator();
    const pskcrypto = require("../PskCrypto");

    const derSignature = convertRSSignatureToDer(signature);
    let pemPublicKey;
    if (utils.isPemEncoded(publicKey)) {
        pemPublicKey = publicKey;
    } else {
        pemPublicKey = keyPairGenerator.convertPublicKey(publicKey);
    }
    return pskcrypto.verify("sha256", data, pemPublicKey, derSignature);
}

module.exports = {
    decodeDERIntoASN1ETH,
    sign,
    verify
};

}).call(this)}).call(this,require("buffer").Buffer)

},{"../ECKeyGenerator":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/pskcrypto/lib/ECKeyGenerator.js","../PskCrypto":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/pskcrypto/lib/PskCrypto.js","../asn1/bignum/bn":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/pskcrypto/lib/asn1/bignum/bn.js","../keyEncoder":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/pskcrypto/lib/keyEncoder.js","../utils/cryptoUtils":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/pskcrypto/lib/utils/cryptoUtils.js","buffer":false}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/pskcrypto/lib/utils/isStream.js":[function(require,module,exports){
const stream = require('stream');


function isStream (obj) {
	return obj instanceof stream.Stream || obj instanceof stream.Duplex;
}


function isReadable (obj) {
	return isStream(obj) && typeof obj._read === 'function' && typeof obj._readableState === 'object'
}


function isWritable (obj) {
	return isStream(obj) && typeof obj._write === 'function' && typeof obj._writableState === 'object'
}


function isDuplex (obj) {
	return isReadable(obj) && isWritable(obj)
}


module.exports            = isStream;
module.exports.isReadable = isReadable;
module.exports.isWritable = isWritable;
module.exports.isDuplex   = isDuplex;
},{"stream":false}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/pskcrypto/signsensusDS/ssutil.js":[function(require,module,exports){
/*
 SignSens helper functions
 */
exports.wipeOutsidePayload = function wipeOutsidePayload(hashStringHexa, pos, size){
    var result;
    var sz = hashStringHexa.length;

    var end = (pos + size) % sz;

    if(pos < end){
        result = '0'.repeat(pos) +  hashStringHexa.substring(pos, end) + '0'.repeat(sz - end);
    }
    else {
        result = hashStringHexa.substring(0, end) + '0'.repeat(pos - end) + hashStringHexa.substring(pos, sz);
    }
    return result;
}



exports.extractPayload = function extractPayload(hashStringHexa, pos, size){
    var result;

    var sz = hashStringHexa.length;
    var end = (pos + size) % sz;

    if( pos < end){
        result = hashStringHexa.substring(pos, pos + size);
    } else{

        if(0 != end){
            result = hashStringHexa.substring(0, end)
        }  else {
            result = "";
        }
        result += hashStringHexa.substring(pos, sz);
    }
    return result;
}



exports.fillPayload = function fillPayload(payload, pos, size){
    var sz = 64;
    var result = "";

    var end = (pos + size) % sz;

    if( pos < end){
        result = '0'.repeat(pos) + payload + '0'.repeat(sz - end);
    } else{
        result = payload.substring(0,end);
        result += '0'.repeat(pos - end);
        result += payload.substring(end);
    }
    return result;
}



exports.generatePosHashXTimes = function generatePosHashXTimes(buffer, pos, size, count){ //generate positional hash
    var result  = buffer.toString("hex");

    /*if(pos != -1 )
        result[pos] = 0; */
    const crypto = require('crypto');
    for(var i = 0; i < count; i++){
        var hash = crypto.createHash('sha256');
        result = exports.wipeOutsidePayload(result, pos, size);
        hash.update(result);
        result = hash.digest('hex');
    }
    return exports.wipeOutsidePayload(result, pos, size);
}

exports.hashStringArray = function (counter, arr, payloadSize){
    const crypto = require('crypto');
    const hash = crypto.createHash('sha256');
    var result = counter.toString(16);

    for(var i = 0 ; i < 64; i++){
        result += exports.extractPayload(arr[i],i, payloadSize);
    }

    hash.update(result);
    var result = hash.digest('hex');
    return result;
}






function dumpMember(obj){
    var type = Array.isArray(obj) ? "array" : typeof obj;
    if(obj === null){
        return "null";
    }
    if(obj === undefined){
        return "undefined";
    }

    switch(type){
        case "number":
        case "string":return obj.toString(); break;
        case "object": return exports.dumpObjectForHashing(obj); break;
        case "boolean": return  obj? "true": "false"; break;
        case "array":
            var result = "";
            for(var i=0; i < obj.length; i++){
                result += exports.dumpObjectForHashing(obj[i]);
            }
            return result;
            break;
        default:
            throw new Error("Type " +  type + " cannot be cryptographically digested");
    }

}


exports.dumpObjectForHashing = function(obj){
    var result = "";

    if(obj === null){
        return "null";
    }
    if(obj === undefined){
        return "undefined";
    }

    var basicTypes = {
        "array"     : true,
        "number"    : true,
        "boolean"   : true,
        "string"    : true,
        "object"    : false
    }

    var type = Array.isArray(obj) ? "array" : typeof obj;
    if( basicTypes[type]){
        return dumpMember(obj);
    }

    var keys = Object.keys(obj);
    keys.sort();


    for(var i=0; i < keys.length; i++){
        result += dumpMember(keys[i]);
        result += dumpMember(obj[keys[i]]);
    }

    return result;
}


exports.hashValues  = function (values){
    const crypto = require('crypto');
    const hash = crypto.createHash('sha256');
    var result = exports.dumpObjectForHashing(values);
    hash.update(result);
    return hash.digest('hex');
};

exports.getJSONFromSignature = function getJSONFromSignature(signature, size){
    var result = {
        proof:[]
    };
    var a = signature.split(":");
    result.agent        = a[0];
    result.counter      =  parseInt(a[1], "hex");
    result.nextPublic   =  a[2];

    var proof = a[3]


    if(proof.length/size != 64) {
        throw new Error("Invalid signature " + proof);
    }

    for(var i = 0; i < 64; i++){
        result.proof.push(exports.fillPayload(proof.substring(i * size,(i+1) * size ), i, size))
    }

    return result;
}

exports.createSignature = function (agent,counter, nextPublic, arr, size){
    var result = "";

    for(var i = 0; i < arr.length; i++){
        result += exports.extractPayload(arr[i], i , size);
    }

    return agent + ":" + counter + ":" + nextPublic + ":" + result;
}
},{"crypto":false}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/soundpubsub/lib/soundPubSub.js":[function(require,module,exports){
/*
Initial License: (c) Axiologic Research & Alboaie Snic.
Contributors: Axiologic Research , PrivateSky project
Code License: LGPL or MIT.
*/


/**
 *   Usually an event could cause execution of other callback events . We say that is a level 1 event if is causeed by a level 0 event and so on
 *
 *      SoundPubSub provides intuitive results regarding to asynchronous calls of callbacks and computed values/expressions:
 *   we prevent immediate execution of event callbacks to ensure the intuitive final result is guaranteed as level 0 execution
 *   we guarantee that any callback function is "re-entrant"
 *   we are also trying to reduce the number of callback execution by looking in queues at new messages published by
 *   trying to compact those messages (removing duplicate messages, modifying messages, or adding in the history of another event ,etc)
 *
 *      Example of what can be wrong without non-sound asynchronous calls:
 *
 *  Step 0: Initial state:
 *   a = 0;
 *   b = 0;
 *
 *  Step 1: Initial operations:
 *   a = 1;
 *   b = -1;
 *
 *  // an observer reacts to changes in a and b and compute CORRECT like this:
 *   if( a + b == 0) {
 *       CORRECT = false;
 *       notify(...); // act or send a notification somewhere..
 *   } else {
 *      CORRECT = false;
 *   }
 *
 *    Notice that: CORRECT will be true in the end , but meantime, after a notification was sent and CORRECT was wrongly, temporarily false!
 *    soundPubSub guarantee that this does not happen because the syncronous call will before any observer (bot asignation on a and b)
 *
 *   More:
 *   you can use blockCallBacks and releaseCallBacks in a function that change a lot a collection or bindable objects and all
 *   the notifications will be sent compacted and properly
 */

// TODO: optimisation!? use a more efficient queue instead of arrays with push and shift!?
// TODO: see how big those queues can be in real applications
// for a few hundreds items, queues made from array should be enough
//*   Potential TODOs:
//    *     prevent any form of problem by calling callbacks in the expected order !?
//*     preventing infinite loops execution cause by events!?
//*
//*
// TODO: detect infinite loops (or very deep propagation) It is possible!?

const Queue = require('queue');

function SoundPubSub(){

	let subscriberCbkRefHandler = new SubscriberCallbackReferenceHandler();

	/**
	 * publish
	 *      Publish a message {Object} to a list of subscribers on a specific topic
	 *
	 * @params {String|Number} target,  {Object} message
	 * @return number of channel subscribers that will be notified
	 */
	this.publish = function(target, message){
		if(!invalidChannelName(target) && !invalidMessageType(message) && (typeof channelSubscribers[target] != 'undefined')){
			compactAndStore(target, message);
			setTimeout(dispatchNext, 0);
			return channelSubscribers[target].length;
		} else{
			return null;
		}
	};

	/**
	 * subscribe
	 *      Subscribe / add a {Function} callBack on a {String|Number}target channel subscribers list in order to receive
	 *      messages published if the conditions defined by {Function}waitForMore and {Function}filter are passed.
	 *
	 * @params {String|Number}target, {Function}callBack, {Function}waitForMore, {Function}filter
	 *
	 *          target      - channel name to subscribe
	 *          callback    - function to be called when a message was published on the channel
	 *          waitForMore - a intermediary function that will be called after a successfuly message delivery in order
	 *                          to decide if a new messages is expected...
	 *          filter      - a function that receives the message before invocation of callback function in order to allow
	 *                          relevant message before entering in normal callback flow
	 * @return
	 */
	this.subscribe = function(target, callBack, waitForMore, filter){
		if(!invalidChannelName(target) && !invalidFunction(callBack)){
			let subscriber = {"waitForMore": waitForMore, "filter": filter};
			if(typeof channelSubscribers[target] === 'undefined'){
				channelSubscribers[target] = [];
			}
			subscriberCbkRefHandler.setSubscriberCallback(subscriber, target, callBack);
			channelSubscribers[target].push(subscriber);
		}
	};

	/**
	 * unsubscribe
	 *      Unsubscribe/remove {Function} callBack from the list of subscribers of the {String|Number} target channel
	 *
	 * @params {String|Number} target, {Function} callBack, {Function} filter
	 *
	 *          target      - channel name to unsubscribe
	 *          callback    - reference of the original function that was used as subscribe
	 *          filter      - reference of the original filter function
	 * @return
	 */
	this.unsubscribe = function(target, callBack, filter){
		if(!invalidFunction(callBack)){
			//let gotIt = false;
			if(channelSubscribers[target]){
				for(let i = 0; i < channelSubscribers[target].length;i++){
					let subscriber =  channelSubscribers[target][i];
					let callback = subscriberCbkRefHandler.getSubscriberCallback(subscriber);

					if(callback === callBack && ( typeof filter === 'undefined' || subscriber.filter === filter )){
						//gotIt = true;
						subscriber.forDelete = true;
						subscriber.callBack = undefined;
						subscriber.filter = undefined;
					}
				}
			}
			//not valid always since we introduced WeakRef. A subscriber callback could not exists
			// if(!gotIt){
			// 	console.log("Unable to unsubscribe a callback that was not subscribed!");
			// }
		}
	};

	/**
	 * blockCallBacks
	 *
	 * @params
	 * @return
	 */
	this.blockCallBacks = function(){
		level++;
	};

	/**
	 * releaseCallBacks
	 *
	 * @params
	 * @return
	 */
	this.releaseCallBacks = function(){
		level--;
		//hack/optimisation to not fill the stack in extreme cases (many events caused by loops in collections,etc)
		while(level === 0 && dispatchNext(true)){
			//nothing
		}

		while(level === 0 && callAfterAllEvents()){
            //nothing
		}
	};

	/**
	 * afterAllEvents
	 *
	 * @params {Function} callback
	 *
	 *          callback - function that needs to be invoked once all events are delivered
	 * @return
	 */
	this.afterAllEvents = function(callBack){
		if(!invalidFunction(callBack)){
			afterEventsCalls.push(callBack);
		}
		this.blockCallBacks();
		this.releaseCallBacks();
	};

	/**
	 * hasChannel
	 *
	 * @params {String|Number} channel
	 *
	 *          channel - name of the channel that need to be tested if present
	 * @return
	 */
	this.hasChannel = function(channel){
		return !invalidChannelName(channel) && (typeof channelSubscribers[channel] != 'undefined') ? true : false;
	};

	/**
	 * addChannel
	 *
	 * @params {String} channel
	 *
	 *          channel - name of a channel that needs to be created and added to soundpubsub repository
	 * @return
	 */
	this.addChannel = function(channel){
		if(!invalidChannelName(channel) && !this.hasChannel(channel)){
			channelSubscribers[channel] = [];
		}
	};

	/* ---------------------------------------- protected stuff ---------------------------------------- */
	var self = this;
	// map channelName (object local id) -> array with subscribers
	var channelSubscribers = {};

	// map channelName (object local id) -> queue with waiting messages
	var channelsStorage = {};

	// object
	var typeCompactor = {};

	// channel names
	var executionQueue = new Queue();
	var level = 0;



	/**
	 * registerCompactor
	 *
	 *       An compactor takes a newEvent and and oldEvent and return the one that survives (oldEvent if
	 *  it can compact the new one or the newEvent if can't be compacted)
	 *
	 * @params {String} type, {Function} callBack
	 *
	 *          type        - channel name to unsubscribe
	 *          callBack    - handler function for that specific event type
	 * @return
	 */
	this.registerCompactor = function(type, callBack) {
		if(!invalidFunction(callBack)){
			typeCompactor[type] = callBack;
		}
	};

	/**
	 * dispatchNext
	 *
	 * @param fromReleaseCallBacks: hack to prevent too many recursive calls on releaseCallBacks
	 * @return {Boolean}
	 */
	function dispatchNext(fromReleaseCallBacks){
		if(level > 0) {
			return false;
		}
		const channelName = executionQueue.front();
		if(typeof channelName != 'undefined'){
			self.blockCallBacks();
			try{
				let message;
				if(!channelsStorage[channelName].isEmpty()) {
					message = channelsStorage[channelName].front();
				}
				if(typeof message == 'undefined'){
					if(!channelsStorage[channelName].isEmpty()){
						console.log("Can't use as message in a pub/sub channel this object: " + message);
					}
					executionQueue.pop();
				} else {
					if(typeof message.__transmisionIndex == 'undefined'){
						message.__transmisionIndex = 0;
						for(var i = channelSubscribers[channelName].length-1; i >= 0 ; i--){
							var subscriber =  channelSubscribers[channelName][i];
							if(subscriber.forDelete === true){
								channelSubscribers[channelName].splice(i,1);
							}
						}
					} else{
						message.__transmisionIndex++;
					}
					//TODO: for immutable objects it will not work also, fix for shape models
					if(typeof message.__transmisionIndex == 'undefined'){
						console.log("Can't use as message in a pub/sub channel this object: " + message);
					}
					subscriber = channelSubscribers[channelName][message.__transmisionIndex];
					if(typeof subscriber == 'undefined'){
						delete message.__transmisionIndex;
						channelsStorage[channelName].pop();
					} else{
						if(subscriber.filter === null || typeof subscriber.filter === "undefined" || (!invalidFunction(subscriber.filter) && subscriber.filter(message))){
							if (!subscriber.forDelete) {
								let callback = subscriberCbkRefHandler.getSubscriberCallback(subscriber);
								if (typeof callback === "undefined") {
									subscriber.forDelete = true;
								} else {
									callback(message);
									if (subscriber.waitForMore && !invalidFunction(subscriber.waitForMore) && !subscriber.waitForMore(message)) {
										subscriber.forDelete = true;
									}
								}
							}
						}
					}
				}
			} catch(err){
				console.log("Event callback failed: "+ subscriber.callBack +"error: " + err.stack);
			}
			//
			if(fromReleaseCallBacks){
				level--;
			} else{
				self.releaseCallBacks();
			}
			return true;
		} else{
			return false;
		}
	}

	function compactAndStore(target, message){
		var gotCompacted = false;
		var arr = channelsStorage[target];
		if(typeof arr == 'undefined'){
			arr = new Queue();
			channelsStorage[target] = arr;
		}

		if(message && typeof message.type != 'undefined'){
			var typeCompactorCallBack = typeCompactor[message.type];

			if(typeof typeCompactorCallBack != 'undefined'){
				for(let channel of arr) {
					if(typeCompactorCallBack(message, channel) === channel) {
						if(typeof channel.__transmisionIndex == 'undefined') {
							gotCompacted = true;
							break;
						}
					}
				}
			}
		}

		if(!gotCompacted && message){
			arr.push(message);
			executionQueue.push(target);
		}
	}

	var afterEventsCalls = new Queue();
	function callAfterAllEvents (){
		if(!afterEventsCalls.isEmpty()){
			var callBack = afterEventsCalls.pop();
			//do not catch exceptions here..
			callBack();
		}
		return !afterEventsCalls.isEmpty();
	}

	function invalidChannelName(name){
		var result = false;
		if(!name || (typeof name != "string" && typeof name != "number")){
			result = true;
			console.log("Invalid channel name: " + name);
		}

		return result;
	}

	function invalidMessageType(message){
		var result = false;
		if(!message || typeof message != "object"){
			result = true;
			console.log("Invalid messages types: " + message);
		}
		return result;
	}

	function invalidFunction(callback){
		var result = false;
		if(!callback || typeof callback != "function"){
			result = true;
			console.log("Expected to be function but is: " + callback);
		}
		return result;
	}

	//weak references are not supported by all browsers
	function SubscriberCallbackReferenceHandler(){
		let finalizationRegistry;
		let hasWeakReferenceSupport = weakReferencesAreSupported();


		if (hasWeakReferenceSupport) {
			finalizationRegistry = new FinalizationRegistry((heldValue) => {
		   		//console.log(`Cleanup ${heldValue}`);
			});
		}

		this.setSubscriberCallback  = function (subscriber, target, callback){
			if(hasWeakReferenceSupport){
				subscriber.callBack = new WeakRef(callback);
				finalizationRegistry.register(subscriber.callBack, target);
			}
			else{
				subscriber.callBack = callback;
			}
		}

		this.getSubscriberCallback = function (subscriber){
			if(hasWeakReferenceSupport){
				if(subscriber.callBack){
					return subscriber.callBack.deref();
				}
				return undefined;

			}
			return subscriber.callBack;
		}

		function weakReferencesAreSupported() {
			return typeof FinalizationRegistry === "function" && typeof WeakRef === "function";
		}
	}


}

exports.soundPubSub = new SoundPubSub();

},{"queue":"queue"}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/swarm-engine/SwarmEngine.js":[function(require,module,exports){
function SwarmEngine(identity) {
    let myOwnIdentity = identity || SwarmEngine.prototype.ANONYMOUS_IDENTITY;

    const protectedFunctions = {};

    const SwarmPacker = require("swarmutils").SwarmPacker;
    //serializationType used when starting a swarm from this SwarmEngine instance
    let serializationType = SwarmPacker.prototype.JSON;

    const swarmInstancesCache = new Map();
    const powerCordCollection = new Map();

    this.updateIdentity = function (identify) {
        if (myOwnIdentity === SwarmEngine.prototype.ANONYMOUS_IDENTITY) {
            console.log("Updating my identity with", identify);
            myOwnIdentity = identify;
        } else {
            $$.err(`Trying to changing identity from "${myOwnIdentity}" to "${identify}"`);
        }
    };

    this.setSerializationType = function (type) {
        if (typeof SwarmPacker.getSerializer(type) !== "undefined") {
            serializationType = type;
        } else {
            $$.throw(`Unknown serialization type "${type}"`);
        }
    };

    this.plug = function (identity, powerCordImpl) {
        makePluggable(powerCordImpl);
        powerCordImpl.plug(identity, relay);

        powerCordCollection.set(identity, powerCordImpl);
    };

    this.unplug = function (identity) {
        const powerCord = powerCordCollection.get(identity);

        if (!powerCord) {
            //silent fail
            return;
        }

        powerCord.unplug();
        powerCordCollection.delete(identity);
    };

    function relay(swarmSerialization, ignoreMyIdentity) {
        try {

            const swarmutils = require('swarmutils');

            const OwM = swarmutils.OwM;
            const SwarmPacker = swarmutils.SwarmPacker;

            const swarmHeader = SwarmPacker.getHeader(swarmSerialization);
            const swarmTargetIdentity = swarmHeader.swarmTarget;

            if(typeof ignoreMyIdentity === "undefined" || !ignoreMyIdentity){
                if (myOwnIdentity === swarmTargetIdentity || myOwnIdentity === "*") {
                    const deserializedSwarm = OwM.prototype.convert(SwarmPacker.unpack(swarmSerialization));
                    protectedFunctions.execute_swarm(deserializedSwarm);
                    return;
                }
            }

            const targetPowerCord = powerCordCollection.get(swarmTargetIdentity) || powerCordCollection.get(SwarmEngine.prototype.WILD_CARD_IDENTITY);

            if (targetPowerCord) {
                //console.log(myOwnIdentity, "calling powercord", swarmTargetIdentity);
                targetPowerCord.sendSwarm(swarmSerialization);
                return;
            } else {
                $$.err(`Bad Swarm Engine configuration. No PowerCord for identity "${swarmTargetIdentity}" found.`);
            }
        } catch (superError) {
            console.log(superError);
        }
    }

    function getPowerCord(identity) {
        const powerCord = powerCordCollection.get(identity);

        if (!powerCord) {
            //should improve the search of powerCord based on * and self :D

            $$.throw(`No powerCord found for the identity "${identity}"`);
        }

        return powerCord;
    }

    /* ???
    swarmCommunicationStrategy.enableSwarmExecution(function(swarm){

    }); */

    function serialize(swarm) {
        const beesHealer = require("swarmutils").beesHealer;
        const simpleJson = beesHealer.asJSON(swarm, swarm.meta.phaseName, swarm.meta.args);
        const serializer = SwarmPacker.getSerializer(swarm.meta.serializationType || serializationType);
        return SwarmPacker.pack(simpleJson, serializer);
    }

    function createBaseSwarm(swarmTypeName) {
        const swarmutils = require('swarmutils');
        const OwM = swarmutils.OwM;

        const swarm = new OwM();
        swarm.setMeta("swarmId", $$.uidGenerator.safe_uuid());
        swarm.setMeta("requestId", swarm.getMeta("swarmId"));
        swarm.setMeta("swarmTypeName", swarmTypeName);
        swarm.setMeta(SwarmEngine.META_SECURITY_HOME_CONTEXT, myOwnIdentity);

        return swarm;
    }

    function cleanSwarmWaiter(swarmSerialisation) { // TODO: add better mechanisms to prevent memory leaks
        let swarmId = swarmSerialisation.meta.swarmId;
        let watcher = swarmInstancesCache[swarmId];

        if (!watcher) {
            $$.warn("Invalid swarm received: " + swarmId);
            return;
        }

        let args = swarmSerialisation.meta.args;
        args.push(swarmSerialisation);

        watcher.callback.apply(null, args);
        if (!watcher.keepAliveCheck()) {
            delete swarmInstancesCache[swarmId];
        }
    }

    protectedFunctions.startSwarmAs = function (identity, swarmTypeName, phaseName, ...args) {
        const swarm = createBaseSwarm(swarmTypeName);
        swarm.setMeta($$.swarmEngine.META_SECURITY_HOME_CONTEXT, myOwnIdentity);

        protectedFunctions.sendSwarm(swarm, SwarmEngine.EXECUTE_PHASE_COMMAND, identity, phaseName, args);
        return swarm;
    };

    protectedFunctions.sendSwarm = function (swarmAsVO, command, identity, phaseName, args) {

        swarmAsVO.setMeta("phaseName", phaseName);
        swarmAsVO.setMeta("target", identity);
        swarmAsVO.setMeta("command", command);
        swarmAsVO.setMeta("args", args);

        relay(serialize(swarmAsVO), true);
    };

    protectedFunctions.waitForSwarm = function (callback, swarm, keepAliveCheck) {

        function doLogic() {
            let swarmId = swarm.getInnerValue().meta.swarmId;
            let watcher = swarmInstancesCache.get(swarmId);
            if (!watcher) {
                watcher = {
                    swarm: swarm,
                    callback: callback,
                    keepAliveCheck: keepAliveCheck
                };
                swarmInstancesCache.set(swarmId, watcher);
            }
        }

        function filter() {
            return swarm.getInnerValue().meta.swarmId;
        }

        //$$.uidGenerator.wait_for_condition(condition,doLogic);
        swarm.observe(doLogic, null, filter);
    };

    protectedFunctions.execute_swarm = function (swarmOwM) {

        const swarmCommand = swarmOwM.getMeta('command');

        //console.log("Switching on command ", swarmCommand);
        switch (swarmCommand) {
            case SwarmEngine.prototype.EXECUTE_PHASE_COMMAND:
                let swarmId = swarmOwM.getMeta('swarmId');
                let swarmType = swarmOwM.getMeta('swarmTypeName');
                let instance = swarmInstancesCache.get(swarmId);

                let swarm;

                if (instance) {
                    swarm = instance.swarm;
                    swarm.actualize(swarmOwM);

                } else {
                    if (typeof $$.blockchain !== "undefined") {
                        swarm = $$.swarm.startWithContext($$.blockchain, swarmType);
                    } else {
                        swarm = $$.swarm.start(swarmType);
                    }

                    if (!swarm) {
                        throw new Error(`Unknown swarm with type <${swarmType}>. Check if this swarm is defined in the domain constitution!`);
                    } else {
                        swarm.actualize(swarmOwM);
                    }

                    /*swarm = $$.swarm.start(swarmType, swarmSerialisation);*/
                }
                swarm.runPhase(swarmOwM.meta.phaseName, swarmOwM.meta.args);
                break;
            case SwarmEngine.prototype.EXECUTE_INTERACT_PHASE_COMMAND:
                is.dispatch(swarmOwM);
                break;
            case SwarmEngine.prototype.RETURN_PHASE_COMMAND:
                is.dispatch(swarmOwM);
                break;
            default:
                $$.err(`Unrecognized swarm command ${swarmCommand}`);
        }
    };

    protectedFunctions.acknowledge = function(method, swarmId, swarmName, swarmPhase, cb){
        powerCordCollection.forEach((powerCord, identity)=>{
            if(typeof powerCord[method] === "function"){
                powerCord[method].call(powerCord, swarmId, swarmName, swarmPhase, cb);
            }
        });
    };

    require("./swarms")(protectedFunctions);
    const is = require("./interactions")(protectedFunctions);
}

Object.defineProperty(SwarmEngine.prototype, "EXECUTE_PHASE_COMMAND", {value: "executeSwarmPhase"});
Object.defineProperty(SwarmEngine.prototype, "EXECUTE_INTERACT_PHASE_COMMAND", {value: "executeInteractPhase"});
Object.defineProperty(SwarmEngine.prototype, "RETURN_PHASE_COMMAND", {value: "__return__"});

Object.defineProperty(SwarmEngine.prototype, "META_RETURN_CONTEXT", {value: "returnContext"});
Object.defineProperty(SwarmEngine.prototype, "META_SECURITY_HOME_CONTEXT", {value: "homeSecurityContext"});
Object.defineProperty(SwarmEngine.prototype, "META_WAITSTACK", {value: "waitStack"});

Object.defineProperty(SwarmEngine.prototype, "ANONYMOUS_IDENTITY", {value: "anonymous"});
Object.defineProperty(SwarmEngine.prototype, "SELF_IDENTITY", {value: "self"});
Object.defineProperty(SwarmEngine.prototype, "WILD_CARD_IDENTITY", {value: "*"});

function makePluggable(powerCord) {
    powerCord.plug = function (identity, powerTransfer) {
        powerCord.transfer = powerTransfer;
        powerCord.identity = identity;
    };

    powerCord.unplug = function () {
        powerCord.transfer = null;
    };

    Object.defineProperty(powerCord, "identity", {
        set: (value) => {
            if(typeof powerCord.__identity === "undefined"){
                powerCord.__identity = value;
            }
            return true;
        }, get: () => {
            return powerCord.__identity;
        }
    });

    return powerCord;
}

module.exports = SwarmEngine;

},{"./interactions":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/swarm-engine/interactions/index.js","./swarms":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/swarm-engine/swarms/index.js","swarmutils":"swarmutils"}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/swarm-engine/bootScripts/BootEngine.js":[function(require,module,exports){
(function (global){(function (){
function BootEngine(getKeySSI, initializeSwarmEngine, runtimeBundles, constitutionBundles) {

	if (typeof getKeySSI !== "function") {
		throw new Error("getSeed missing or not a function");
	}
	getKeySSI = promisify(getKeySSI);

	if (typeof initializeSwarmEngine !== "function") {
		throw new Error("initializeSwarmEngine missing or not a function");
	}
	initializeSwarmEngine = promisify(initializeSwarmEngine);

	if (typeof runtimeBundles !== "undefined" && !Array.isArray(runtimeBundles)) {
		throw new Error("runtimeBundles is not array");
	}

	if (typeof constitutionBundles !== "undefined" && !Array.isArray(constitutionBundles)) {
		throw new Error("constitutionBundles is not array");
	}

	const openDSU = require('opendsu');
	const resolver = openDSU.loadApi('resolver');
	const pskPath = require("swarmutils").path;

	const evalBundles = async (bundles, ignore) => {
		const listFiles = promisify(this.rawDossier.listFiles);
		const readFile = promisify(this.rawDossier.readFile);

		let fileList = await listFiles(openDSU.constants.CONSTITUTION_FOLDER);
		fileList = bundles.filter(bundle => fileList.includes(bundle) || fileList.includes(`/${bundle}`))
			.map(bundle => pskPath.join(openDSU.constants.CONSTITUTION_FOLDER, bundle));

		if (fileList.length !== bundles.length) {
			const message = `Some bundles missing. Expected to have ${JSON.stringify(bundles)} but got only ${JSON.stringify(fileList)}`;
			if (!ignore) {
				throw new Error(message);
			} else {
				console.log(message);
			}
		}


		for (let i = 0; i < fileList.length; i++) {
			var fileContent = await readFile(fileList[i]);
			try {
				eval(fileContent.toString());
			}catch(e){
				console.log("Failed to eval file", fileList[i], e);
			}
		}
	};

	this.boot = function (callback) {
		const __boot = async () => {
            const keySSI = await getKeySSI();
            const loadRawDossier = promisify(resolver.loadDSU);
            try {
                this.rawDossier = await loadRawDossier(keySSI);
				global.rawDossier = this.rawDossier;
				require("opendsu").loadAPI("sc").getSecurityContext();
            } catch (err) {
                console.log(err);
            }

            try {
                await evalBundles(runtimeBundles);
            } catch(err) {
            	if(err.type !== "PSKIgnorableError"){
					console.log(err);
				}
            }
            await initializeSwarmEngine();
            if (typeof constitutionBundles !== "undefined") {
                try {
                    await evalBundles(constitutionBundles, true);
                } catch(err) {
                    console.log(err);
                }
            }
		};

		__boot()
			.then(() => callback(undefined, this.rawDossier))
			.catch(callback);
	};
}

function promisify(fn) {
	return function (...args) {
		return new Promise((resolve, reject) => {
			fn(...args, (err, ...res) => {
				if (err) {
					console.log(err);
					reject(err);
				} else {
					resolve(...res);
				}
			});
		});
	}
}

module.exports = BootEngine;

}).call(this)}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"opendsu":"opendsu","swarmutils":"swarmutils"}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/swarm-engine/bootScripts/IsolateBootScript.js":[function(require,module,exports){

async function getIsolatesWorker({workerData: {constitutions}, externalApi}) {
    const swarmUtils = require('swarmutils');
    const beesHealer = swarmUtils.beesHealer;
    const OwM = swarmUtils.OwM;
    const SwarmPacker = swarmUtils.SwarmPacker;
    const pskIsolatesModuleName = "pskisolates";
    const IsolatedVM = require(pskIsolatesModuleName);
    const {EventEmitter} = require('events');

    const config = IsolatedVM.IsolateConfig.defaultConfig;
    config.logger = {
        send([logChannel, logObject]) {
            $$.redirectLog(logChannel, logObject)
        }
    };

    const fs = require('fs');

    constitutions = constitutions.map(constitution => fs.readFileSync(constitution, 'utf8'));

    const isolate = await IsolatedVM.getDefaultIsolate({
        shimsBundle: constitutions[0],
        browserifyBundles: constitutions.slice(1),
        config: config,
        externalApi: externalApi
    });

    class IsolatesWrapper extends EventEmitter {
        postMessage(packedSwarm) {
            const swarm = SwarmPacker.unpack(packedSwarm);

            const phaseName = OwM.prototype.getMetaFrom(swarm, 'phaseName');
            const args = OwM.prototype.getMetaFrom(swarm, 'args');
            const serializedSwarm = beesHealer.asJSON(swarm, phaseName, args);
            const stringifiedSwarm = JSON.stringify(serializedSwarm);

            isolate.run(`
                if(typeof global.identitySet === "undefined"){
                    global.identitySet = true;
                  
				    $$.swarmEngine.updateIdentity(getIdentity.applySync(undefined, []));
				}
            `).then(() => {
                const powerCordRef = isolate.context.global.getSync('powerCord');
                const transferFnRef = powerCordRef.getSync('transfer');
                const swarmAsRef = new isolate.ivm.ExternalCopy(new Uint8Array(packedSwarm)).copyInto();
                // console.log(transferFnRef, swarmAsRef);

                transferFnRef.applyIgnored(powerCordRef.derefInto(), [swarmAsRef]);
            }).catch((err) => {
                this.emit('error', err);
            });

        }
    }

    const isolatesWrapper = new IsolatesWrapper();
    isolatesWrapper.globalSetSync = isolate.globalSetSync;

    isolate.globalSetSync('returnSwarm', (err, swarm) => {
        try {
            isolatesWrapper.emit('message', swarm);
        } catch (e) {
            console.log('Caught error', e);
        }
    });

    await isolate.run(`
            const se = require("swarm-engine");
            global.powerCord = new se.InnerIsolatePowerCord();
            $$.swarmEngine.plug($$.swarmEngine.WILD_CARD_IDENTITY, global.powerCord);
		`);

    //TODO: this might cause a memory leak
    setInterval(async () => {
        const rawIsolate = isolate.rawIsolate;
        const cpuTime = rawIsolate.cpuTime;
        const wallTime = rawIsolate.wallTime;

        const heapStatistics = await rawIsolate.getHeapStatistics();
        const activeCPUTime = (cpuTime[0] + cpuTime[1] / 1e9) * 1000;
        const totalCPUTime = (wallTime[0] + wallTime[1] / 1e9) * 1000;
        const idleCPUTime = totalCPUTime - activeCPUTime;
        $$.event('sandbox.metrics', {heapStatistics, activeCPUTime, totalCPUTime, idleCPUTime});

    }, 10 * 1000); // 10 seconds


    return isolatesWrapper;
}

module.exports = getIsolatesWorker;

},{"events":false,"fs":false,"swarmutils":"swarmutils"}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/swarm-engine/bootScripts/ThreadWorkerBootScript.js":[function(require,module,exports){
function boot() {
    const worker_threads ='worker_threads';
    const {parentPort, workerData} = require(worker_threads);

    process.on("uncaughtException", (err) => {
        console.error('unchaughtException inside worker', err);
        setTimeout(() => {
            process.exit(1);
        }, 100);
    });

    function getKeySSI(callback){
        let err;
        if (!workerData.hasOwnProperty('constitutionSeed') || typeof workerData.constitutionSeed !== "string") {
            err = new Error(`Missing or wrong type of constitutionSeed in worker data configuration: ${JSON.stringify(workerData)}`);
            if(!callback){
                throw err;
            }
        }
        if(callback){
            return callback(err, workerData.constitutionSeed);
        }
        return workerData.constitutionSeed;
    }

    const openDSU = require("opendsu");
    const resolver = openDSU.loadApi("resolver");
    function initializeSwarmEngine(callback){
        require('callflow').initialise();
        const swarmEngine = require('swarm-engine');

        swarmEngine.initialise(process.env.IDENTITY);
        const powerCord = new swarmEngine.InnerThreadPowerCord();

        $$.swarmEngine.plug($$.swarmEngine.WILD_CARD_IDENTITY, powerCord);

        parentPort.on('message', (packedSwarm) => {
            powerCord.transfer(packedSwarm);
        });

        resolver.loadDSU(workerData.constitutionSeed, (err, rawDossier) => {
            if (err) {
                $$.throwError(err);
            }

            rawDossier.start((err) =>{
                if(err){
                    $$.throwError(err);
                }
                callback(undefined);
            });
        });
    }

    const BootEngine = require("./BootEngine.js");

    const booter = new BootEngine(getKeySSI, initializeSwarmEngine, ["pskruntime.js", "blockchain.js"], ["domain.js"]);

    booter.boot((err) => {
        if(err){
            throw err;
        }
        parentPort.postMessage('ready');
    });
}

boot();
//module.exports = boot.toString();

},{"./BootEngine.js":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/swarm-engine/bootScripts/BootEngine.js","callflow":"callflow","opendsu":"opendsu","swarm-engine":"swarm-engine"}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/swarm-engine/bootScripts/domainBootScript.js":[function(require,module,exports){
const path = require('path');
//enabling life line to parent process
require(path.join(process.env.PSK_ROOT_INSTALATION_FOLDER, "psknode/core/utils/pingpongFork.js")).enableLifeLine();

const keySSI = process.env.PSK_DOMAIN_KEY_SSI;
//preventing children to access the env parameter
process.env.PSK_DOMAIN_KEY_SSI = undefined;

if (process.argv.length > 3) {
    process.env.PRIVATESKY_DOMAIN_NAME = process.argv[2];
} else {
    process.env.PRIVATESKY_DOMAIN_NAME = "AnonymousDomain" + process.pid;
}

process.env.PRIVATESKY_TMP = path.resolve(process.env.PRIVATESKY_TMP || "../tmp");
process.env.DOMAIN_WORKSPACE = path.resolve(process.env.PRIVATESKY_TMP, "domainsWorkspace", process.env.PRIVATESKY_DOMAIN_NAME);

const config = JSON.parse(process.env.config);

if (typeof config.constitution !== "undefined" && config.constitution !== "undefined") {
    process.env.PRIVATESKY_DOMAIN_CONSTITUTION = config.constitution;
}

if (typeof config.workspace !== "undefined" && config.workspace !== "undefined") {
    process.env.DOMAIN_WORKSPACE = config.workspace;
}

function boot() {
    const BootEngine = require("./BootEngine");

    const bootter = new BootEngine(getKeySSI, initializeSwarmEngine, ["pskruntime.js", "pskWebServer.js", "openDSU.js"], ["blockchain.js"]);
    bootter.boot(function (err, archive) {
        if (err) {
            console.log(err);
            return;
        }
        try {
            plugPowerCords();
        } catch (err) {
            console.log("Caught an error will finishing booting process", err);
        }
    })
}

function getKeySSI(callback) {
    callback(undefined, self.keySSI);
}

let self = {keySSI};

function initializeSwarmEngine(callback) {
    const openDSU = require("opendsu");
    const resolver = openDSU.loadApi("resolver");
    resolver.loadDSU(self.keySSI, (err, bar) => {
        if (err) {
            return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to load DSU with keySSI <${self.keySSI}>`, err));
        }

        bar.readFile(openDSU.constants.DOMAIN_IDENTITY_FILE, (err, content) => {
            if (err) {
                return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to read file <${openDSU.constants.DOMAIN_IDENTITY_FILE}>`, err));
            }
            self.domainName = content.toString();
            $$.log(`Domain ${self.domainName} is booting...`);

            $$.PSK_PubSub = require("soundpubsub").soundPubSub;
            const se = require("swarm-engine");
            se.initialise(self.domainName);

            callback();
        });
    });
}

function plugPowerCords() {
    const dossier = require("dossier");
    dossier.load(self.keySSI, "DomainIdentity", function (err, dossierHandler) {
        if (err) {
            throw err;
        }

        dossierHandler.startTransaction("DomainConfigTransaction", "getDomains").onReturn(function (err, domainConfigs) {
            if (err) {
                throw  err;
            }

            const se = require("swarm-engine");
            if (domainConfigs.length === 0) {
                console.log("No domain configuration found in CSB. Boot process will stop here...");
                return;
            }
            self.domainConf = domainConfigs[0];

            for (const alias in self.domainConf.communicationInterfaces) {
                if (self.domainConf.communicationInterfaces.hasOwnProperty(alias)) {
                    let remoteUrls = self.domainConf.communicationInterfaces[alias];
                    let powerCordToDomain = new se.SmartRemoteChannelPowerCord([remoteUrls.virtualMQ + "/"], self.domainConf.alias, remoteUrls.zeroMQ);
                    $$.swarmEngine.plug("*", powerCordToDomain);
                }
            }

            dossierHandler.startTransaction("Agents", "getAgents").onReturn(function (err, agents) {
                if (err) {
                    throw err;
                }

                if (agents.length === 0) {
                    agents.push({alias: 'system'});
                }

                const openDSU = require("opendsu");
                const resolver = openDSU.loadApi("resolver");
                const pskPath = require("swarmutils").path;
                resolver.loadDSU(self.keySSI, (err, rawDossier) => {
                    if (err) {
                        throw err;
                    }

                    rawDossier.readFile(pskPath.join(openDSU.constants.CONSTITUTION_FOLDER , "threadBoot.js"), (err, fileContents) => {
                        if (err) {
                            throw err;
                        }

                        agents.forEach(agent => {
                            const agentPC = new se.OuterThreadPowerCord(fileContents.toString(), true, keySSI);
                            $$.swarmEngine.plug(`${self.domainConf.alias}/agent/${agent.alias}`, agentPC);
                        });

                        $$.event('status.domains.boot', {name: self.domainConf.alias});
                        console.log("Domain boot successfully");
                    });
                });
            });
        })
    });
}

boot();

},{"./BootEngine":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/swarm-engine/bootScripts/BootEngine.js","dossier":"dossier","opendsu":"opendsu","path":false,"soundpubsub":"soundpubsub","swarm-engine":"swarm-engine","swarmutils":"swarmutils"}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/swarm-engine/bootScripts/index.js":[function(require,module,exports){
module.exports = {
    getIsolatesBootScript: function() {
        return require('./IsolateBootScript');
    },
    getThreadBootScript: function() {
        return `(${require("./ThreadWorkerBootScript")})()`;
    },
    executeDomainBootScript: function() {
        return require('./domainBootScript');
    }
};
},{"./IsolateBootScript":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/swarm-engine/bootScripts/IsolateBootScript.js","./ThreadWorkerBootScript":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/swarm-engine/bootScripts/ThreadWorkerBootScript.js","./domainBootScript":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/swarm-engine/bootScripts/domainBootScript.js"}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/swarm-engine/interactions/InteractionSpace.js":[function(require,module,exports){
function InteractionSpace(swarmEngineApi) {
    const listeners = {};
    const interactionTemplate = require('./interaction_template').getTemplateHandler(swarmEngineApi);

    function createThis(swarm) {
        const thisObj = interactionTemplate.createForObject(swarm);
        //todo: implement a proxy for public and private vars...
        return thisObj;
    }

    this.dispatch = function (swarm) {
        const {swarmId, swarmTypeName, phaseName, args} = swarm.meta;

        const genericKey = `*/${swarmTypeName}/${phaseName}`;
        const particularKey = `${swarmId}/${swarmTypeName}/${phaseName}`;

        const handlers = listeners[particularKey] || listeners[genericKey] || [];

        handlers.forEach(fn => {
            fn.call(createThis(swarm), ...args);
        });

        if (phaseName === $$.swarmEngine.RETURN_PHASE_COMMAND) {
            delete listeners[particularKey];
        }

        if (handlers.length === 0) {
            console.log(`No implementation for phase "${phaseName}" was found`);
        }
    };

    this.on = function (swarmId, swarmTypeName, phaseName, handler) {
        const key = `${swarmId}/${swarmTypeName}/${phaseName}`;
        if (typeof listeners[key] === "undefined") {
            listeners[key] = [];
        }
        listeners[key].push(handler);
        swarmEngineApi.acknowledge("on", swarmId, swarmTypeName, phaseName, handler);
    };

    this.off = function (swarmId = '*', swarmTypeName = '*', phaseName = '*', handler) {

        function escapeIfStar(str) {
            return str.replace("*", "\\*")
        }

        swarmId = escapeIfStar(swarmId);
        swarmTypeName = escapeIfStar(swarmTypeName);
        phaseName = escapeIfStar(phaseName);

        const regexString = `(${swarmId})\\/(${swarmTypeName})\\/(${phaseName})`;
        const reg = new RegExp(regexString);

        const keys = Object.keys(listeners);
        keys.forEach(key => {
            if (key.match(reg)) {
                const handlers = listeners[key];

                if (!handler) {
                    listeners[key] = [];
                } else {
                    listeners[key] = handlers.filter(fn => fn !== handler);
                }
            }
        });
        swarmEngineApi.acknowledge("off", swarmId, swarmTypeName, phaseName, handler);
    };
}

module.exports = InteractionSpace;

},{"./interaction_template":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/swarm-engine/interactions/interaction_template.js"}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/swarm-engine/interactions/index.js":[function(require,module,exports){
module.exports = function (swarmEngineApi) {
    let cm = require("callflow");
    const InteractionSpace = require("./InteractionSpace");
    const is = new InteractionSpace(swarmEngineApi);

    $$.interactions = {};
    //cm.createSwarmEngine("interaction", require("./interaction_template"));
    $$.interaction = $$.interactions;

    $$.interactions.attachTo = function (swarmTypeName, interactionDescription) {
        Object.keys(interactionDescription).forEach(phaseName => {
            is.on('*', swarmTypeName, phaseName, interactionDescription[phaseName]);
        });
    };

    $$.interactions.startSwarmAs = function (identity, swarmTypeName, phaseName, ...args) {
        const swarm = swarmEngineApi.startSwarmAs(identity, swarmTypeName, phaseName, ...args);
        let swarmId = swarm.getMeta('swarmId');

        return {
            on: function (interactionDescription) {
                Object.keys(interactionDescription).forEach(phaseName => {
                    is.on(swarmId, swarmTypeName, phaseName, interactionDescription[phaseName]);
                });

                return this;
            },
            off: function (interactionDescription) {
                is.off(interactionDescription);

                return this;
            },
            onReturn: function (callback) {
                is.on(swarmId, swarmTypeName, $$.swarmEngine.RETURN_PHASE_COMMAND, callback);

                return this;
            }
        }
    };

    return is;
};

},{"./InteractionSpace":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/swarm-engine/interactions/InteractionSpace.js","callflow":"callflow"}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/swarm-engine/interactions/interaction_template.js":[function(require,module,exports){
exports.getTemplateHandler = function (swarmEngineApi) {

    return {
        createForObject: function (valueObject, thisObject, localId) {
            let cm = require("callflow");

            let swarmFunction = function (destinationContext, phaseName, ...args) {
                //make the execution at level 0  (after all pending events) and wait to have a swarmId
                ret.observe(function () {
                    swarmEngineApi.sendSwarm(valueObject, $$.swarmEngine.EXECUTE_PHASE_COMMAND, destinationContext, phaseName, args);
                }, null, null);
                ret.notify();
                return thisObject;
            };

            function off() {
                const swarmId = valueObject.getMeta('swarmId');
                const swarmTypeName = valueObject.getMeta('swarmTypeName');

                swarmEngineApi.off(swarmId, swarmTypeName);
            }


            let ret = cm.createStandardAPIsForSwarms(valueObject, thisObject, localId);

            ret.swarm = swarmFunction;
            ret.swarmAs = swarmFunction;
            ret.off = off;

            delete ret.home;
            delete ret.onReturn;
            delete ret.onResult;

            delete ret.asyncReturn;
            delete ret.return;

            delete ret.autoInit;

            return ret;
        }
    }
};

},{"callflow":"callflow"}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/swarm-engine/powerCords/InnerIsolatePowerCord.js":[function(require,module,exports){
(function (global){(function (){
function InnerIsolatePowerCord() {

    let setterTransfer;

    function transfer(...args) {

        args = args.map(arg => {
            if(arg.buffer) {
                // transforming UInt8Array to ArrayBuffer
                arg = arg.buffer;
            }

            return arg;
        });

        return setterTransfer(...args);
    }

    Object.defineProperty(this, "transfer", {
        set: (fn) => {
            setterTransfer = fn;
        }, get: () => {
            return setterTransfer ? transfer : undefined;
        }
    });

    this.sendSwarm = function (swarmSerialization) {
        try{
            if(swarmSerialization instanceof ArrayBuffer) {
                swarmSerialization = global.createCopyIntoExternalCopy(new Uint8Array(swarmSerialization));
            }

            returnSwarm.apply(undefined, [null, swarmSerialization])
                .catch((err) => {
                    console.log(err);
                })
        }catch(err){
           console.log(err);
        }

    };

}

module.exports = InnerIsolatePowerCord;

}).call(this)}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/swarm-engine/powerCords/InnerThreadPowerCord.js":[function(require,module,exports){
function InnerThreadPowerCord() {
    const worker_threads = 'worker_threads';
    const {parentPort} = require(worker_threads);

    this.sendSwarm = function (swarmSerialization) {
        parentPort.postMessage(swarmSerialization);
    };

}

module.exports = InnerThreadPowerCord;

},{}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/swarm-engine/powerCords/OuterIsolatePowerCord.js":[function(require,module,exports){
function OuterIsolatePowerCord(energySource, numberOfWires = 1, apis) { // seed or array of constitution bundle paths
    const syndicate = require('syndicate');
    const bootScripts = require('../bootScripts');
    const pskIsolatesModuleName = "pskisolates";
    const pskisolates = require(pskIsolatesModuleName);
    let pool = null;


    function connectToEnergy() {
        const WorkerStrategies = syndicate.WorkerStrategies;

        if(!apis) {
            apis = {};
        }

        if(typeof apis.require === "undefined"){
            apis.require = function(name) {
                console.log('Creating proxy for', name);
                return pskisolates.createDeepReference(require(name));
            };
        }

        const config = {
            bootScript: bootScripts.getIsolatesBootScript(),
            maximumNumberOfWorkers: numberOfWires,
            workerStrategy: WorkerStrategies.ISOLATES,
            workerOptions: {
                workerData: {
                    constitutions: energySource
                },
                externalApi: apis
            }
        };

        pool = syndicate.createWorkerPool(config, (isolate) => {

            isolate.globalSetSync("getIdentity", () => {
                return superThis.identity;
            });
        });

    }

    let superThis = this;
    connectToEnergy();


    this.sendSwarm = function (swarmSerialization) {
        pool.addTask(swarmSerialization, (err, msg) => {
            if (err instanceof Error) {
                throw err;
            }

            this.transfer(msg.buffer || msg);
        });
    };

}

module.exports = OuterIsolatePowerCord;

},{"../bootScripts":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/swarm-engine/bootScripts/index.js","syndicate":"syndicate"}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/swarm-engine/powerCords/OuterThreadPowerCord.js":[function(require,module,exports){
function OuterThreadPowerCord(threadBootScript, evaluate= false, energySourceSeed, numberOfWires = 1) { // seed or array of constitution bundle paths
    const syndicate = require('syndicate');
    let pool = null;
    let self = this;

    function connectToEnergy() {
        const config = {
            maximumNumberOfWorkers: numberOfWires,
            workerStrategy: syndicate.WorkerStrategies.THREADS,
            bootScript: threadBootScript,
            workerOptions: {
                // cwd: process.env.DOMAIN_WORKSPACE,
                eval: evaluate,
                env: {
                    IDENTITY: self.identity
                },
                workerData: {
                    constitutionSeed: energySourceSeed
                }
            }
        };

        pool = syndicate.createWorkerPool(config);

    }

    this.sendSwarm = function (swarmSerialization) {
        pool.addTask(swarmSerialization, (err, msg) => {
            if (err instanceof Error) {
                throw err;
            }

            this.transfer(msg.buffer || msg);
        });
    };

    return new Proxy(this, {
        set(target, p, value, receiver) {
            target[p] = value;
            if(p === 'identity') {
                connectToEnergy();
            }
        }
    })
}

module.exports = OuterThreadPowerCord;

},{"syndicate":"syndicate"}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/swarm-engine/powerCords/RemoteChannelPairPowerCord.js":[function(require,module,exports){
const outbound = "outbound";
const inbound = "inbound";

function RemoteChannelPairPowerCord(host, channelName, receivingHost, receivingChannelName){

    receivingHost = receivingHost || host;
    receivingChannelName = receivingChannelName || generateChannelName();

    function setup(){
        //injecting necessary http methods
        require("../../psk-http-client");

        //this should be a channel that exists... we don't try to create
        $$.remote.registerHttpChannelClient(outbound, host, channelName, {autoCreate: false});
        $$.remote[outbound].setSenderMode();

        //maybe instead of receivingChannelName we sould use our identity? :-??
        $$.remote.registerHttpChannelClient(inbound, receivingHost, receivingChannelName, {autoCreate: true});
        $$.remote[inbound].setReceiverMode();

        $$.remote[inbound].on("*", "*", "*", function (err, swarmSerialization){
            const swarmUtils = require("swarmutils");
            const SwarmPacker = swarmUtils.SwarmPacker;
            let header = SwarmPacker.getHeader(swarmSerialization);
            if(header.swarmTarget === $$.remote[inbound].getReceiveAddress() && startedSwarms[header.swarmId] === true){
                //it is a swarm that we started
                let message = swarmUtils.OwM.prototype.convert(SwarmPacker.unpack(swarmSerialization));
                //we set the correct target
                message.setMeta("target", identityOfOurSwarmEngineInstance);
                //... and transfer to our swarm engine instance
                self.transfer(SwarmPacker.pack(message, SwarmPacker.getSerializer(header.serializationType)));
            }else{
                self.transfer(swarmSerialization);
            }
        });
    }

    let identityOfOurSwarmEngineInstance;
    let startedSwarms = {};
    const self = this;
    this.sendSwarm = function (swarmSerialization) {
        const swarmUtils = require("swarmutils");
        const SwarmPacker = swarmUtils.SwarmPacker;
        let header = SwarmPacker.getHeader(swarmSerialization);
        let message = swarmUtils.OwM.prototype.convert(SwarmPacker.unpack(swarmSerialization));

        if(typeof message.publicVars === "undefined"){
            startedSwarms[message.getMeta("swarmId")] = true;

            //it is the start of swarm...
            if(typeof identityOfOurSwarmEngineInstance === "undefined"){
                identityOfOurSwarmEngineInstance = message.getMeta("homeSecurityContext");
            }
            //we change homeSecurityContext with a url in order to get back the swarm when is done.
            message.setMeta("homeSecurityContext", $$.remote[inbound].getReceiveAddress());
            //send the updated version of it
            $$.remote[outbound].sendSwarm(SwarmPacker.pack(message, SwarmPacker.getSerializer(header.serializationType)));
        }else{
            //the swarm was not started from our pair swarm engine so we just send it
            $$.remote[outbound].sendSwarm(swarmSerialization);
        }
    };

    function generateChannelName(){
        return Math.random().toString(36).substr(2, 9);
    }

    return new Proxy(this, {
        set(target, p, value, receiver) {
            target[p] = value;
            if(p === 'identity') {
                setup();
            }
        }
    });
}

module.exports = RemoteChannelPairPowerCord;
},{"../../psk-http-client":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/psk-http-client/index.js","swarmutils":"swarmutils"}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/swarm-engine/powerCords/RemoteChannelPowerCord.js":[function(require,module,exports){
const inbound = "inbound";

function RemoteChannelPowerCord(receivingHost, receivingChannelName){

    receivingHost = receivingHost || host;
    receivingChannelName = receivingChannelName || generateChannelName();

    let setup = ()=>{
        //injecting necessary http methods
        require("../../psk-http-client");

        //maybe instead of receivingChannelName we sould use our identity? :-??
        $$.remote.registerHttpChannelClient(inbound, receivingHost, receivingChannelName, {autoCreate: true});
        $$.remote[inbound].setReceiverMode();

        this.on("*", "*", "*", (err, result)=>{
            if(!err){
                console.log("We got a swarm for channel");
                this.transfer(result);
            }else{
                console.log("Got an error from our channel", err);
            }
        });
    };

    this.on = function(swarmId, swarmName, swarmPhase, callback){
        $$.remote[inbound].on(swarmId, swarmName, swarmPhase, callback);
    };

    this.off = function(swarmId, swarmName, swarmPhase, callback){

    };

    this.sendSwarm = function (swarmSerialization) {
        const SwarmPacker = require("swarmutils").SwarmPacker;
        let header = SwarmPacker.getHeader(swarmSerialization);
        let target = header.swarmTarget;
        console.log("Sending swarm to", target);
        //test if target is an url... else complain
        if(true){
            $$.remote.doHttpPost(target, swarmSerialization, (err, res)=>{

            });
        }else{

        }
    };

    function generateChannelName(){
        return Math.random().toString(36).substr(2, 9);
    }

    return new Proxy(this, {
        set(target, p, value, receiver) {
            target[p] = value;
            if(p === 'identity') {
                setup();
            }
        }
    });
}

module.exports = RemoteChannelPowerCord;
},{"../../psk-http-client":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/psk-http-client/index.js","swarmutils":"swarmutils"}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/swarm-engine/powerCords/SmartRemoteChannelPowerCord.js":[function(require,module,exports){
const inbound = "inbound";

function SmartRemoteChannelPowerCord(communicationAddrs, receivingChannelName, zeroMQAddress) {

    //here are stored, for later use, fav hosts for different identities
    const favoriteHosts = {};
    let receivingHost = Array.isArray(communicationAddrs) && communicationAddrs.length > 0 ? communicationAddrs[0] : "http://127.0.0.1";
    receivingChannelName = receivingChannelName || generateChannelName();

    function testIfZeroMQAvailable(suplimentaryCondition){
        let available = true;
        let zmqModule;
        try{
            let zmqName = "zeromq";
            zmqModule = require(zmqName);
        }catch(err){
            console.log("Zeromq not available at this moment.");
        }
        available = typeof zmqModule !== "undefined";
        if(typeof suplimentaryCondition !== "undefined"){
            available = available && suplimentaryCondition;
        }
        return available;
    }

    let setup = () => {
        //injecting necessary http methods
        require("../../psk-http-client");

        const opts = {autoCreate: true, enableForward: testIfZeroMQAvailable(typeof zeroMQAddress !== "undefined"), publicSignature: "none"};

        console.log(`\n[***] Using channel "${receivingChannelName}" on "${receivingHost}".\n`);
        //maybe instead of receivingChannelName we sould use our identity? :-??
        $$.remote.registerHttpChannelClient(inbound, receivingHost, receivingChannelName, opts);
        $$.remote[inbound].setReceiverMode();

        function toArrayBuffer(buffer) {
            const ab = new ArrayBuffer(buffer.length);
            const view = new Uint8Array(ab);
            for (let i = 0; i < buffer.length; ++i) {
                view[i] = buffer[i];
            }
            return ab;
        }


        if (testIfZeroMQAvailable(typeof zeroMQAddress !== "undefined")) {
            //let's connect to zmq
            const reqFactory = require("apihub").getVMQRequestFactory(receivingHost, zeroMQAddress);
            reqFactory.receiveMessageFromZMQ($$.remote.base64Encode(receivingChannelName), opts.publicSignature, (...args) => {
                console.log("zeromq connection established");
            }, (channelName, swarmSerialization) => {
                console.log("Look", channelName, swarmSerialization);
                handlerSwarmSerialization(swarmSerialization);
            });
        } else {
            $$.remote[inbound].on("*", "*", "*", (err, swarmSerialization) => {
                if (err) {
                    console.log("Got an error from our channel", err);
                    return;
                }

                if($$.Buffer && $$.Buffer.isBuffer(swarmSerialization)){
                    swarmSerialization = toArrayBuffer(swarmSerialization);
                }

                handlerSwarmSerialization(swarmSerialization);
            });
        }
    };

    /* this.on = function(swarmId, swarmName, swarmPhase, callback){
         $$.remote[inbound].on(swarmId, swarmName, swarmPhase, callback);
     };

     this.off = function(swarmId, swarmName, swarmPhase, callback){

     };*/

    function getMetaFromIdentity(identity){
        const vRegex = /([a-zA-Z0-9]*|.)*\/agent\/([a-zA-Z0-9]+(\/)*)+/g;

        if(!identity.match(vRegex)){
            throw new Error("Invalid format. (Eg. domain[.subdomain]*/agent/[organisation/]*agentId)");
        }

        const separatorKeyword = "/agent/";
        let domain;
        let agentIdentity;

        const splitPoint = identity.indexOf(separatorKeyword);
        if(splitPoint !== -1){
            domain = identity.slice(0, splitPoint);
            agentIdentity = identity.slice(splitPoint+separatorKeyword.length);
        }

        return {domain, agentIdentity};
    }

    function handlerSwarmSerialization(swarmSerialization) {
        const swarmUtils = require("swarmutils");
        const SwarmPacker = swarmUtils.SwarmPacker;
        let header = SwarmPacker.getHeader(swarmSerialization);
        if (header.swarmTarget === $$.remote[inbound].getReceiveAddress() && startedSwarms[header.swarmId] === true) {
            //it is a swarm that we started
            let message = swarmUtils.OwM.prototype.convert(SwarmPacker.unpack(swarmSerialization));
            //we set the correct target
            message.setMeta("target", identityOfOurSwarmEngineInstance);
            //... and transfer to our swarm engine instance
            self.transfer(SwarmPacker.pack(message, SwarmPacker.getSerializer(header.serializationType)));
        } else {
            self.transfer(swarmSerialization);
        }
    }

    let identityOfOurSwarmEngineInstance;
    let startedSwarms = {};
    const self = this;
    this.sendSwarm = function (swarmSerialization) {
        const swarmUtils = require("swarmutils");
        const SwarmPacker = swarmUtils.SwarmPacker;
        let header = SwarmPacker.getHeader(swarmSerialization);
        let message = swarmUtils.OwM.prototype.convert(SwarmPacker.unpack(swarmSerialization));

        if (typeof message.publicVars === "undefined") {
            startedSwarms[message.getMeta("swarmId")] = true;

            //it is the start of swarm...
            if (typeof identityOfOurSwarmEngineInstance === "undefined") {
                identityOfOurSwarmEngineInstance = message.getMeta("homeSecurityContext");
            }
            //we change homeSecurityContext with a url in order to get back the swarm when is done.
            message.setMeta("homeSecurityContext", $$.remote[inbound].getReceiveAddress());

            swarmSerialization = SwarmPacker.pack(message, SwarmPacker.getSerializer(header.serializationType));
        }

        let target = header.swarmTarget;
        console.log("Sending swarm to", target);
        const urlRegex = new RegExp(/^(www|http:|https:)+[^\s]+[\w]/);

        if (urlRegex.test(target)) {
            $$.remote.doHttpPost(target, swarmSerialization, (err, res) => {
                if (err) {
                    console.log(err);
                }
            });
        } else {
            deliverSwarmToRemoteChannel(target, swarmSerialization, 0);
        }
    };

    function deliverSwarmToRemoteChannel(target, swarmSerialization, remoteIndex) {
        let identityMeta;
        try{
            identityMeta = getMetaFromIdentity(target);
        }catch(err){
            //identityMeta = {};
            console.log(err);
        }

        if (remoteIndex >= communicationAddrs.length) {
            //end of the line
            console.log(`Unable to deliver swarm to target "${target}" on any of the remote addresses provided.`);
            return;
        }
        const currentAddr = communicationAddrs[remoteIndex];
        //if we don't have a fav host for target then lets start discovery process...
        const remoteChannelAddr = favoriteHosts[identityMeta.domain] || [currentAddr, "send-message/", $$.remote.base64Encode(identityMeta.domain) + "/"].join("");

        $$.remote.doHttpPost(remoteChannelAddr, swarmSerialization, (err, res) => {
            if (err) {
                setTimeout(() => {
                    deliverSwarmToRemoteChannel(target, swarmSerialization, ++remoteIndex);
                }, 10);
            } else {
                //success: found fav host for target
                favoriteHosts[identityMeta.domain] = remoteChannelAddr;
                console.log("Found our fav", remoteChannelAddr, "for target", target);
            }
        });
    }

    function generateChannelName() {
        return Math.random().toString(36).substr(2, 9);
    }

    return new Proxy(this, {
        set(target, p, value, receiver) {
            target[p] = value;
            if (p === 'identity') {
                setup();
            }
            return true;
        }
    });
}

module.exports = SmartRemoteChannelPowerCord;

},{"../../psk-http-client":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/psk-http-client/index.js","apihub":"apihub","swarmutils":"swarmutils"}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/swarm-engine/powerCords/browser/SSAppPowerCord.js":[function(require,module,exports){
/*
	This type of PowerCord can be used from outer and inner SSApp in order to facilitate the SWARM communication
	@param reference can be the parent (SSApp or wallet environment) or the iframe in which the SSApp gets loaded
*/
function SSAppPowerCord(reference){

	this.sendSwarm = function (swarmSerialization){
		//console.log("Sending swarm using", reference);
		reference.postMessage(swarmSerialization, "*");
	};

	let receivedMessageHandler  = (event)=>{
		console.log("SSAppPowerCord caught event", event);
		/*if(event.source !== reference){
			console.log("Not my message to handle");
			return;
		}
		console.log("Message received from ssapp", event.source);
		*/
		let swarmSerialization = event.data;
		this.transfer(swarmSerialization);
	};

	let setupConnection = () => {
		if(typeof window.powerCordHandler === "undefined"){
			//console.log("SSAPP PC listener set up");
			window.powerCordHandler = receivedMessageHandler;
			window.addEventListener("message", window.powerCordHandler);
		}else{
			//console.log("SSAPP handler already set.");
		}
	};

	return new Proxy(this, {
		set(target, p, value, receiver) {
			target[p] = value;
			if(p === 'identity') {
				setupConnection();
			}
			return true;
		}
	});
}

module.exports = SSAppPowerCord;

},{}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/swarm-engine/swarms/index.js":[function(require,module,exports){
module.exports = function(swarmEngineApi){
    const cm = require("callflow");
    const swarmUtils = require("./swarm_template-se");

    $$.swarms           = cm.createSwarmEngine("swarm", swarmUtils.getTemplateHandler(swarmEngineApi));
    $$.swarm            = $$.swarms;

    $$.swarms.startAs = function(identity, swarmName, ctor, ...params){
        swarmEngineApi.startSwarmAs(identity, swarmName, ctor, ...params);
    };
};
},{"./swarm_template-se":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/swarm-engine/swarms/swarm_template-se.js","callflow":"callflow"}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/swarm-engine/swarms/swarm_template-se.js":[function(require,module,exports){
exports.getTemplateHandler = function (swarmEngine) {
    let cm = require("callflow");

    let beesHealer = require("swarmutils").beesHealer;
    return {
        createForObject: function (valueObject, thisObject, localId) {

            function messageIdentityFilter(valueObject) {
                return valueObject.meta.swarmId;
            }

            let swarmFunction = function (destinationContext, phaseName, ...args) {
                //make the execution at level 0  (after all pending events) and wait to have a swarmId
                ret.observe(function () {
                    swarmEngine.sendSwarm(valueObject, $$.swarmEngine.EXECUTE_PHASE_COMMAND, destinationContext, phaseName, args);
                }, null, null);
                ret.notify();
                return thisObject;
            };

            let asyncReturn = function (err, result) {

                let destinationContext = valueObject.meta[$$.swarmEngine.META_SECURITY_HOME_CONTEXT];
                if (!destinationContext && valueObject.meta[$$.swarmEngine.META_WAITSTACK]) {
                    destinationContext = valueObject.meta[$$.swarmEngine.META_WAITSTACK].pop();
                }
                if (!destinationContext) {
                    destinationContext = valueObject.meta[$$.swarmEngine.META_SECURITY_HOME_CONTEXT];
                }

                const {OwM} = require("swarmutils");
                const swarmClone = OwM.prototype.convert(JSON.parse(JSON.stringify(valueObject)));

                swarmEngine.sendSwarm(swarmClone, $$.swarmEngine.RETURN_PHASE_COMMAND, destinationContext, $$.swarmEngine.RETURN_PHASE_COMMAND, [err, result]);
            };

            function interact(phaseName, ...args) {
                const {OwM} = require("swarmutils");
                const swarmClone = OwM.prototype.convert(JSON.parse(JSON.stringify(valueObject)));
                let destinationContext = valueObject.meta[$$.swarmEngine.META_SECURITY_HOME_CONTEXT];

                swarmEngine.sendSwarm(swarmClone, $$.swarmEngine.EXECUTE_INTERACT_PHASE_COMMAND, destinationContext, phaseName, args);
            }

            function home(err, result) {
                let homeContext = valueObject.meta[$$.swarmEngine.META_SECURITY_HOME_CONTEXT];
                swarmEngine.sendSwarm(valueObject, $$.swarmEngine.RETURN_PHASE_COMMAND, homeContext, $$.swarmEngine.RETURN_PHASE_COMMAND, [err, result]);
            }

            function waitResults(callback, keepAliveCheck, swarm) {
                if (!swarm) {
                    swarm = this;
                }
                if (!keepAliveCheck) {
                    keepAliveCheck = function () {
                        return false;
                    }
                }
                var inner = swarm.getInnerValue();
                if (!inner.meta[$$.swarmEngine.META_WAITSTACK]) {
                    inner.meta[$$.swarmEngine.META_WAITSTACK] = [];
                    inner.meta[$$.swarmEngine.META_WAITSTACK].push($$.HRN_securityContext)
                }
                swarmEngine.waitForSwarm(callback, swarm, keepAliveCheck);
            }


            let ret = cm.createStandardAPIsForSwarms(valueObject, thisObject, localId);

            ret.interact        = interact;
            ret.swarm           = swarmFunction;
            ret.home            = home;
            ret.onReturn        = waitResults;
            ret.onResult        = waitResults;
            ret.asyncReturn     = asyncReturn;
            ret.return          = asyncReturn;

            ret.autoInit = function (someContext) {

            };

            return ret;
        }
    }
};
},{"callflow":"callflow","swarmutils":"swarmutils"}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/swarmutils/lib/Combos.js":[function(require,module,exports){
function product(args) {
    if(!args.length){
        return [ [] ];
    }
    var prod = product(args.slice(1)), r = [];
    args[0].forEach(function(x) {
        prod.forEach(function(p) {
            r.push([ x ].concat(p));
        });
    });
    return r;
}

function objectProduct(obj) {
    var keys = Object.keys(obj),
        values = keys.map(function(x) { return obj[x]; });

    return product(values).map(function(p) {
        var e = {};
        keys.forEach(function(k, n) { e[k] = p[n]; });
        return e;
    });
}

module.exports = objectProduct;
},{}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/swarmutils/lib/OwM.js":[function(require,module,exports){
var meta = "meta";

function OwM(serialized){

    if(serialized){
        return OwM.prototype.convert(serialized);
    }

    Object.defineProperty(this, meta, {
        writable: false,
        enumerable: true,
        value: {}
    });

    Object.defineProperty(this, "setMeta", {
        writable: false,
        enumerable: false,
        configurable:false,
        value: function(prop, value){
            if(typeof prop == "object" && typeof value == "undefined"){
                for(var p in prop){
                    this[meta][p] = prop[p];
                }
                return prop;
            }
            this[meta][prop] = value;
            return value;
        }
    });

    Object.defineProperty(this, "getMeta", {
        writable: false,
        value: function(prop){
            return this[meta][prop];
        }
    });
}

function testOwMSerialization(obj){
    let res = false;

    if(obj){
        res = typeof obj[meta] != "undefined" && !(obj instanceof OwM);
    }

    return res;
}

OwM.prototype.convert = function(serialized){
    const owm = new OwM();

    for(var metaProp in serialized.meta){
        if(!testOwMSerialization(serialized[metaProp])) {
            owm.setMeta(metaProp, serialized.meta[metaProp]);
        }else{
            owm.setMeta(metaProp, OwM.prototype.convert(serialized.meta[metaProp]));
        }
    }

    for(var simpleProp in serialized){
        if(simpleProp === meta) {
            continue;
        }

        if(!testOwMSerialization(serialized[simpleProp])){
            owm[simpleProp] = serialized[simpleProp];
        }else{
            owm[simpleProp] = OwM.prototype.convert(serialized[simpleProp]);
        }
    }

    return owm;
};

OwM.prototype.getMetaFrom = function(obj, name){
    var res;
    if(!name){
        res = obj[meta];
    }else{
        res = obj[meta][name];
    }
    return res;
};

OwM.prototype.setMetaFor = function(obj, name, value){
    obj[meta][name] = value;
    return obj[meta][name];
};

module.exports = OwM;
},{}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/swarmutils/lib/Queue.js":[function(require,module,exports){
function QueueElement(content) {
	this.content = content;
	this.next = null;
}

function Queue() {
	this.head = null;
	this.tail = null;
	this.length = 0;
	this.push = function (value) {
		const newElement = new QueueElement(value);
		if (!this.head) {
			this.head = newElement;
			this.tail = newElement;
		} else {
			this.tail.next = newElement;
			this.tail = newElement;
		}
		this.length++;
	};

	this.pop = function () {
		if (!this.head) {
			return null;
		}
		const headCopy = this.head;
		this.head = this.head.next;
		this.length--;

		//fix???????
		if(this.length === 0){
            this.tail = null;
		}

		return headCopy.content;
	};

	this.front = function () {
		return this.head ? this.head.content : undefined;
	};

	this.isEmpty = function () {
		return this.head === null;
	};

    this.remove = function (el) {
        if (this.length === 1 && el === this.front()) {
            this.head = this.tail = null;
            this.length--;
            return;
        }

        if (el === this.front()) {
            this.pop();
            return;
        }

        let head = this.head;
        let prev = null;
        while (head !== null) {
            if (head.content !== el) {
                prev = head;
                head = head.next;
                continue;
            }

            prev.next = head.next;
            this.length--;

            if (head === this.tail) {
                this.tail = prev;
            }
            return;
        }

    }

	this[Symbol.iterator] = function* () {
		let head = this.head;
		while(head !== null) {
			yield head.content;
			head = head.next;
		}
	}.bind(this);
}

Queue.prototype.toString = function () {
	let stringifiedQueue = '';
	let iterator = this.head;
	while (iterator) {
		stringifiedQueue += `${JSON.stringify(iterator.content)} `;
		iterator = iterator.next;
	}
	return stringifiedQueue;
};

Queue.prototype.inspect = Queue.prototype.toString;

module.exports = Queue;

},{}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/swarmutils/lib/SwarmPacker.js":[function(require,module,exports){
const HEADER_SIZE_RESEARVED = 4;

function SwarmPacker(){
}

function copyStringtoArrayBuffer(str, buffer){
    if(typeof str !== "string"){
        throw new Error("Wrong param type received");
    }
    for(var i = 0; i < str.length; i++) {
        buffer[i] = str.charCodeAt(i);
    }
    return buffer;
}

function copyFromBuffer(target, source){
    for(let i=0; i<source.length; i++){
        target[i] = source[i];
    }
    return target;
}

let serializers = {};

SwarmPacker.registerSerializer = function(name, implementation){
    if(serializers[name]){
        throw new Error("Serializer name already exists");
    }
    serializers[name] = implementation;
};

function getSerializer(name){
    return serializers[name];
}

SwarmPacker.getSerializer = getSerializer;

Object.defineProperty(SwarmPacker.prototype, "JSON", {value: "json"});
Object.defineProperty(SwarmPacker.prototype, "MSGPACK", {value: "msgpack"});

SwarmPacker.registerSerializer(SwarmPacker.prototype.JSON, {
    serialize: JSON.stringify,
    deserialize: (serialization)=>{
        if(typeof serialization !== "string"){
            serialization = String.fromCharCode.apply(null, serialization);
        }
        return JSON.parse(serialization);
    },
    getType: ()=>{
        return SwarmPacker.prototype.JSON;
    }
});

function registerMsgPackSerializer(){
    const mp = '@msgpack/msgpack';
    let msgpack;

    try{
        msgpack = require(mp);
        if (typeof msgpack === "undefined") {
            throw new Error("msgpack is unavailable.")
        }
    }catch(err){
        console.log("msgpack not available. If you need msgpack serialization include msgpack in one of your bundles");
        //preventing msgPack serializer being register if msgPack dep is not found.
        return;
    }

    SwarmPacker.registerSerializer(SwarmPacker.prototype.MSGPACK, {
        serialize: msgpack.encode,
        deserialize: msgpack.decode,
        getType: ()=>{
            return SwarmPacker.prototype.MSGPACK;
        }
    });
}

registerMsgPackSerializer();

SwarmPacker.pack = function(swarm, serializer){

    let jsonSerializer = getSerializer(SwarmPacker.prototype.JSON);
    if(typeof serializer === "undefined"){
        serializer = jsonSerializer;
    }

    let swarmSerialization = serializer.serialize(swarm);

    let header = {
        command: swarm.getMeta("command"),
        swarmId : swarm.getMeta("swarmId"),
        swarmTypeName: swarm.getMeta("swarmTypeName"),
        swarmTarget: swarm.getMeta("target"),
        serializationType: serializer.getType()
    };

    header = serializer.serialize(header);

    if(header.length >= Math.pow(2, 32)){
        throw new Error("Swarm serialization too big.");
    }

    //arraybuffer construction
    let size = HEADER_SIZE_RESEARVED + header.length + swarmSerialization.length;
    let pack = new ArrayBuffer(size);

    let sizeHeaderView = new DataView(pack, 0);
    sizeHeaderView.setUint32(0, header.length);

    let headerView = new Uint8Array(pack, HEADER_SIZE_RESEARVED);
    copyStringtoArrayBuffer(header, headerView);

    let serializationView = new Uint8Array(pack, HEADER_SIZE_RESEARVED+header.length);
    if(typeof swarmSerialization === "string"){
        copyStringtoArrayBuffer(swarmSerialization, serializationView);
    }else{
        copyFromBuffer(serializationView, swarmSerialization);
    }

    return pack;
};

SwarmPacker.unpack = function(pack){
    let jsonSerialiser = SwarmPacker.getSerializer(SwarmPacker.prototype.JSON);
    let headerSerialization = getHeaderSerializationFromPack(pack);
    let header = jsonSerialiser.deserialize(headerSerialization);

    let serializer = SwarmPacker.getSerializer(header.serializationType);
    let messageView = new Uint8Array(pack, HEADER_SIZE_RESEARVED+headerSerialization.length);

    let swarm = serializer.deserialize(messageView);
    return swarm;
};

function getHeaderSerializationFromPack(pack){
    let headerSize = new DataView(pack).getUint32(0);

    let headerView = new Uint8Array(pack, HEADER_SIZE_RESEARVED, headerSize);
    return headerView;
}

SwarmPacker.getHeader = function(pack){
    let jsonSerialiser = SwarmPacker.getSerializer(SwarmPacker.prototype.JSON);
    let header = jsonSerialiser.deserialize(getHeaderSerializationFromPack(pack));

    return header;
};
module.exports = SwarmPacker;
},{}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/swarmutils/lib/TaskCounter.js":[function(require,module,exports){

function TaskCounter(finalCallback) {
	let results = [];
	let errors = [];

	let started = 0;

	function decrement(err, res) {
		if(err) {
			errors.push(err);
		}

		if(arguments.length > 2) {
			arguments[0] = undefined;
			res = arguments;
		}

		if(typeof res !== "undefined") {
			results.push(res);
		}

		if(--started <= 0) {
            return callCallback();
		}
	}

	function increment(amount = 1) {
		started += amount;
	}

	function callCallback() {
	    if(errors && errors.length === 0) {
	        errors = undefined;
        }

	    if(results && results.length === 0) {
	        results = undefined;
        }

        finalCallback(errors, results);
    }

	return {
		increment,
		decrement
	};
}

module.exports = TaskCounter;
},{}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/swarmutils/lib/beesHealer.js":[function(require,module,exports){
const OwM = require("./OwM");

/*
    Prepare the state of a swarm to be serialised
*/

exports.asJSON = function(valueObj, phaseName, args, callback){

        let valueObject = valueObj.valueOf();
        let res = new OwM();
        res.publicVars          = valueObject.publicVars;
        res.privateVars         = valueObject.privateVars;

        res.setMeta("COMMAND_ARGS",        OwM.prototype.getMetaFrom(valueObject, "COMMAND_ARGS"));
        res.setMeta("SecurityParadigm",        OwM.prototype.getMetaFrom(valueObject, "SecurityParadigm"));
        res.setMeta("swarmTypeName", OwM.prototype.getMetaFrom(valueObject, "swarmTypeName"));
        res.setMeta("swarmId",       OwM.prototype.getMetaFrom(valueObject, "swarmId"));
        res.setMeta("target",        OwM.prototype.getMetaFrom(valueObject, "target"));
        res.setMeta("homeSecurityContext",        OwM.prototype.getMetaFrom(valueObject, "homeSecurityContext"));
        res.setMeta("requestId",        OwM.prototype.getMetaFrom(valueObject, "requestId"));


        if(!phaseName){
            res.setMeta("command", "stored");
        } else {
            res.setMeta("phaseName", phaseName);
            res.setMeta("phaseId", $$.uidGenerator.safe_uuid());
            res.setMeta("args", args);
            res.setMeta("command", OwM.prototype.getMetaFrom(valueObject, "command") || "executeSwarmPhase");
        }

        res.setMeta("waitStack", valueObject.meta.waitStack); //TODO: think if is not better to be deep cloned and not referenced!!!

        if(callback){
            return callback(null, res);
        }
        //console.log("asJSON:", res, valueObject);
        return res;
};

exports.jsonToNative = function(serialisedValues, result){

    for(let v in serialisedValues.publicVars){
        result.publicVars[v] = serialisedValues.publicVars[v];

    };
    for(let l in serialisedValues.privateVars){
        result.privateVars[l] = serialisedValues.privateVars[l];
    };

    for(let i in OwM.prototype.getMetaFrom(serialisedValues)){
        OwM.prototype.setMetaFor(result, i, OwM.prototype.getMetaFrom(serialisedValues, i));
    };

};
},{"./OwM":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/swarmutils/lib/OwM.js"}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/swarmutils/lib/path.js":[function(require,module,exports){
function replaceAll(str, search, replacement) {
    return str.split(search).join(replacement);
}

function resolvePath(pth) {
    let pathSegments = pth.split("/");
    let makeAbsolute = pathSegments[0] === "" ? true : false;
    for (let i = 0; i < pathSegments.length; i++) {
        let segment = pathSegments[i];
        if (segment === "..") {
            let j = 1;
            if (i > 0) {
                j = j + 1;
            }
            // else {
            //     makeAbsolute = true;
            // }
            pathSegments.splice(i + 1 - j, j);
            i = i - j;
        }
    }
    let res = pathSegments.join("/");
    if (makeAbsolute && res !== "") {
        res = __ensureIsAbsolute(res);
    }
    return res;
}

function normalize(pth) {
    if (typeof pth !== "string") {
        throw new TypeError();
    }
    pth = replaceAll(pth, "\\", "/");
    pth = replaceAll(pth, /[/]+/, "/");

    return resolvePath(pth);
}

function join(...args) {
    let pth = "";
    for (let i = 0; i < args.length; i++) {
        if (i !== 0 && args[i - 1] !== "") {
            pth += "/";
        }

        pth += args[i];
    }

    return normalize(pth);
}

function __ensureIsAbsolute(pth) {
    if (pth[0] !== "/") {
        pth = "/" + pth;
    }
    return pth;
}

function isAbsolute(pth) {
    pth = normalize(pth);
    //on windows ":" is used as separator after partition ID
    if (pth[0] !== "/" && pth[1] !== ":") {
        return false;
    }

    return true;
}

function ensureIsAbsolute(pth) {
    pth = normalize(pth);
    return __ensureIsAbsolute(pth);
}

function isSubpath(path, subPath) {
    path = normalize(path);
    subPath = normalize(subPath);
    let result = false;
    if (path.indexOf(subPath) === 0) {
        let char = path[subPath.length];
        if (char === "" || char === "/" || subPath === "/") {
            result = true;
        }
    }

    return result;
}

function dirname(path) {
    if (path === "/") {
        return path;
    }
    const pathSegments = path.split("/");
    pathSegments.pop();
    return ensureIsAbsolute(pathSegments.join("/"));
}

function basename(path) {
    if (path === "/") {
        return path;
    }
    return path.split("/").pop;
}

function relative(from, to) {
    from = normalize(from);
    to = normalize(to);

    const fromSegments = from.split("/");
    const toSegments = to.split("/");
    let splitIndex;
    for (let i = 0; i < fromSegments.length; i++) {
        if (fromSegments[i] !== toSegments[i]) {
            break;
        }
        splitIndex = i;
    }

    if (typeof splitIndex === "undefined") {
        throw Error(`The paths <${from}> and <${to}> have nothing in common`);
    }

    splitIndex++;
    let relativePath = [];
    for (let i = splitIndex; i < fromSegments.length; i++) {
        relativePath.push("..");
    }
    for (let i = splitIndex; i < toSegments.length; i++) {
        relativePath.push(toSegments[i]);
    }

    return relativePath.join("/");
}

function resolve(...pathArr) {
    function __resolvePathRecursively(currentPath) {
        let lastSegment = pathArr.pop();
        if (typeof currentPath === "undefined") {
            currentPath = lastSegment;
        } else {
            currentPath = join(lastSegment, currentPath);
        }
        if (isAbsolute(currentPath)) {
            return currentPath;
        }

        if (pathArr.length === 0) {
            let cwd;
            try {
                cwd = process.cwd();
            } catch (e) {
                cwd = "/";
            }

            return join(cwd, currentPath);
        }

        return __resolvePathRecursively(currentPath);
    }

    return __resolvePathRecursively();
}

function extname(path){
    path = resolvePath(path);
    let ext = path.match(/\.[0-9a-z]+$/i);
    if (Array.isArray(ext)) {
        ext = ext[0];
    } else {
        ext = "";
    }
    return ext;
}

module.exports = {
    normalize,
    join,
    isAbsolute,
    ensureIsAbsolute,
    isSubpath,
    dirname,
    basename,
    relative,
    resolve,
    extname
};

},{}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/swarmutils/lib/pingpongFork.js":[function(require,module,exports){
const PING = "PING";
const PONG = "PONG";

module.exports.fork = function pingPongFork(modulePath, args, options){
    const child_process = require("child_process");
    const defaultStdio = ["inherit", "inherit", "inherit", "ipc"];

    if(!options){
        options = {stdio: defaultStdio};
    }else{
        if(typeof options.stdio === "undefined"){
            options.stdio = defaultStdio;
        }

        let stdio = options.stdio;
        if(stdio.length<3){
            for(let i=stdio.length; i<4; i++){
                stdio.push("inherit");
            }
            stdio.push("ipc");
        }
    }

    let child = child_process.fork(modulePath, args, options);

    child.on("message", (message)=>{
        if(message === PING){
            child.send(PONG);
        }
    });

    return child;
};

module.exports.enableLifeLine = function(timeout){

    if(typeof process.send === "undefined"){
        console.log("\"process.send\" not found. LifeLine mechanism disabled!");
        return;
    }

    let lastConfirmationTime;
    const interval = timeout || 2000;

    // this is needed because new Date().getTime() has reduced precision to mitigate timer based attacks
    // for more information see: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/getTime
    const roundingError = 101;

    function sendPing(){
        try {
            process.send(PING);
        } catch (e) {
            console.log('Parent is not available, shutting down');
            exit(1)
        }
    }

    process.on("message", function (message){
        if(message === PONG){
            lastConfirmationTime = new Date().getTime();
        }
    });

    function exit(code){
        setTimeout(()=>{
            process.exit(code);
        }, 0);
    }

    const exceptionEvents = ["SIGINT", "SIGUSR1", "SIGUSR2", "uncaughtException", "SIGTERM", "SIGHUP"];
    let killingSignal = false;
    for(let i=0; i<exceptionEvents.length; i++){
        process.on(exceptionEvents[i], (event, code)=>{
            killingSignal = true;
            clearInterval(timeoutInterval);
            console.log(`Caught event type [${exceptionEvents[i]}]. Shutting down...`, code, event);
            exit(code);
        });
    }

    const timeoutInterval = setInterval(function(){
        const currentTime = new Date().getTime();

        if(typeof lastConfirmationTime === "undefined" || currentTime - lastConfirmationTime < interval + roundingError && !killingSignal){
            sendPing();
        }else{
            console.log("Parent process did not answer. Shutting down...", process.argv, killingSignal);
            exit(1);
        }
    }, interval);
};
},{"child_process":false}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/swarmutils/lib/pskconsole.js":[function(require,module,exports){
var commands = {};
var commands_help = {};

//global function addCommand
addCommand = function addCommand(verb, adverbe, funct, helpLine){
    var cmdId;
    if(!helpLine){
        helpLine = " ";
    } else {
        helpLine = " " + helpLine;
    }
    if(adverbe){
        cmdId = verb + " " +  adverbe;
        helpLine = verb + " " +  adverbe + helpLine;
    } else {
        cmdId = verb;
        helpLine = verb + helpLine;
    }
    commands[cmdId] = funct;
        commands_help[cmdId] = helpLine;
};

function doHelp(){
    console.log("List of commands:");
    for(var l in commands_help){
        console.log("\t", commands_help[l]);
    }
}

addCommand("-h", null, doHelp, "\t\t\t\t\t\t |just print the help");
addCommand("/?", null, doHelp, "\t\t\t\t\t\t |just print the help");
addCommand("help", null, doHelp, "\t\t\t\t\t\t |just print the help");


function runCommand(){
  var argv = Object.assign([], process.argv);
  var cmdId = null;
  var cmd = null;
  argv.shift();
  argv.shift();

  if(argv.length >=1){
      cmdId = argv[0];
      cmd = commands[cmdId];
      argv.shift();
  }


  if(!cmd && argv.length >=1){
      cmdId = cmdId + " " + argv[0];
      cmd = commands[cmdId];
      argv.shift();
  }

  if(!cmd){
    if(cmdId){
        console.log("Unknown command: ", cmdId);
    }
    cmd = doHelp;
  }

  cmd.apply(null,argv);

}

module.exports = {
    runCommand
};


},{}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/swarmutils/lib/removeDir.js":[function(require,module,exports){
const removeDir = (...args) => {
    const fs = require("fs");
    if (typeof fs.rm !== "function") {
        return fs.rmdir(...args);
    }
    return fs.rm(...args);
}

const removeDirSync = (...args) => {
    const fs = require("fs");
    if (typeof fs.rmSync !== "function") {
        return fs.rmdirSync(...args);
    }
    return fs.rmSync(...args);
}

module.exports = {
    removeDirSync,
    removeDir
}
},{"fs":false}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/swarmutils/lib/safe-uuid.js":[function(require,module,exports){

function encode(buffer) {
    return buffer.toString('base64')
        .replace(/\+/g, '')
        .replace(/\//g, '')
        .replace(/=+$/, '');
};

function stampWithTime(buf, salt, msalt){
    if(!salt){
        salt = 1;
    }
    if(!msalt){
        msalt = 1;
    }
    var date = new Date;
    var ct = Math.floor(date.getTime() / salt);
    var counter = 0;
    while(ct > 0 ){
        //console.log("Counter", counter, ct);
        buf[counter*msalt] = Math.floor(ct % 256);
        ct = Math.floor(ct / 256);
        counter++;
    }
}

/*
    The uid contains around 256 bits of randomness and are unique at the level of seconds. This UUID should by cryptographically safe (can not be guessed)

    We generate a safe UID that is guaranteed unique (by usage of a PRNG to geneate 256 bits) and time stamping with the number of seconds at the moment when is generated
    This method should be safe to use at the level of very large distributed systems.
    The UUID is stamped with time (seconds): does it open a way to guess the UUID? It depends how safe is "crypto" PRNG, but it should be no problem...

 */

var generateUid = null;

exports.init = function(externalGenerator){
    generateUid = externalGenerator.generateUid;
    return module.exports;
};

exports.safe_uuid = function() {
    var buf = generateUid(32);
    stampWithTime(buf, 1000, 3);
    return encode(buf);
};



/*
    Try to generate a small UID that is unique against chance in the same millisecond second and in a specific context (eg in the same choreography execution)
    The id contains around 6*8 = 48  bits of randomness and are unique at the level of milliseconds
    This method is safe on a single computer but should be used with care otherwise
    This UUID is not cryptographically safe (can be guessed)
 */
exports.short_uuid = function(callback) {
    require('crypto').randomBytes(12, function (err, buf) {
        if (err) {
            callback(err);
            return;
        }
        stampWithTime(buf,1,2);
        callback(null, encode(buf));
    });
};
},{"crypto":false}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/swarmutils/lib/uidGenerator.js":[function(require,module,exports){
function UidGenerator(minBuffers, buffersSize) {
    const Queue = require("./Queue");
    var PSKBuffer = typeof $$ !== "undefined" && $$.PSKBuffer ? $$.PSKBuffer : $$.Buffer;

    var buffers = new Queue();
    var lowLimit = .2;

    function fillBuffers(size) {
        //notifyObserver();
        const sz = size || minBuffers;
        if (buffers.length < Math.floor(minBuffers * lowLimit)) {
            for (var i = buffers.length; i < sz; i++) {
                generateOneBuffer(null);
            }
        }
    }

    fillBuffers();

    function generateOneBuffer(b) {
        if (!b) {
            b = PSKBuffer.alloc(0);
        }
        const sz = buffersSize - b.length;
        /*crypto.randomBytes(sz, function (err, res) {
            buffers.push($$.Buffer.concat([res, b]));
            notifyObserver();
        });*/
        buffers.push(PSKBuffer.concat([require('crypto').randomBytes(sz), b]));
        notifyObserver();
    }

    function extractN(n) {
        var sz = Math.floor(n / buffersSize);
        var ret = [];

        for (var i = 0; i < sz; i++) {
            ret.push(buffers.pop());
            setTimeout(generateOneBuffer, 1);
        }


        var remainder = n % buffersSize;
        if (remainder > 0) {
            var front = buffers.pop();
            ret.push(front.slice(0, remainder));
            //generateOneBuffer(front.slice(remainder));
            setTimeout(function () {
                generateOneBuffer(front.slice(remainder));
            }, 1);
        }

        //setTimeout(fillBuffers, 1);

        return $$.Buffer.concat(ret);
    }

    var fillInProgress = false;

    this.generateUid = function (n) {
        var totalSize = buffers.length * buffersSize;
        if (n <= totalSize) {
            return extractN(n);
        } else {
            if (!fillInProgress) {
                fillInProgress = true;
                setTimeout(function () {
                    fillBuffers(Math.floor(minBuffers * 2.5));
                    fillInProgress = false;
                }, 1);
            }
            return require('crypto').randomBytes(n);
        }
    };

    var observer;
    this.registerObserver = function (obs) {
        if (observer) {
            console.error(new Error("One observer allowed!"));
        } else {
            if (typeof obs == "function") {
                observer = obs;
                //notifyObserver();
            }
        }
    };

    function notifyObserver() {
        if (observer) {
            var valueToReport = buffers.length * buffersSize;
            setTimeout(function () {
                observer(null, {"size": valueToReport});
            }, 10);
        }
    }
}

module.exports.createUidGenerator = function (minBuffers, bufferSize) {
    return new UidGenerator(minBuffers, bufferSize);
};

},{"./Queue":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/swarmutils/lib/Queue.js","crypto":false}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/syndicate/lib/AbstractPool.js":[function(require,module,exports){
(function (setImmediate){(function (){
const {assert} = require('./utils');
const util = require('util');
const {EventEmitter} = require('events');

const PoolEvents = {
    RELEASED_WORKER: 'releasedWorker'
};

/** @param {PoolConfig&PoolConfigStorage} options */
function AbstractPool(options) {
    EventEmitter.call(this);

    let pool = [];
    let currentPoolSize = 0;

    /** @returns {Worker|null} */
    this.getAvailableWorker = function () {
        // find first free worker
        const freeWorkerIndex = pool.findIndex(el => !el.isWorking);

        let worker = null;

        // if no free worker is available, try creating one
        if (freeWorkerIndex === -1) {
            _createNewWorker();
            return null;
        } else {
            worker = pool[freeWorkerIndex];
        }

        if (worker === null) {
            return null;
        }

        // if free worker exists, set its state to working
        worker.isWorking = true;
        return worker.workerInstance;
    };

    /** @param {Worker} worker */
    this.returnWorker = function (worker) {
        // find worker that matches one in the pool
        const freeWorkerIndex = pool.findIndex(el => el.workerInstance === worker);

        if (freeWorkerIndex === -1) {
            console.error('Tried to return a worker that is not owned by the pool');
            return;
        }

        // if worker is found, set its state to not working
        pool[freeWorkerIndex].isWorking = false;
        this.emit(PoolEvents.RELEASED_WORKER);
    };

    /** @param {Worker} worker */
    this.removeWorker = function (worker) {
        const localPoolSize = pool.length;

        pool = pool.filter(poolWorker => poolWorker.workerInstance !== worker); // keep elements that are not equal to worker
        currentPoolSize = pool.length;

        assert(currentPoolSize === localPoolSize - 1, {ifFails: `Tried returning a worker that could not be found`});
    };

    this.createNewWorker = function () {
        throw new Error('Not implemented! Overwrite this in subclass.');
    };

    const _createNewWorker = () => {
        // using currentPoolSize instead of pool.length because the creation of workers can be asynchronous
        // and the pool will increase only after the worker is creating, this can cause a situation where
        // more workers are created than the maximumNumberOfWorkers
        if (currentPoolSize >= options.maximumNumberOfWorkers) {
            return;
        }

        currentPoolSize += 1;

        this.createNewWorker((err, newWorker) => {
            if (err) {
                currentPoolSize -= 1;
                console.error('Error creating a new worker', err);
                return;
            }

            const workerObj = {
                isWorking: false,
                workerInstance: newWorker
            };

            pool.push(workerObj);

            // createNewWorker can be synchronous (even though it uses a callback),
            // in that case it will cause scheduling problems if not delayed
            setImmediate(() => {
                this.emit(PoolEvents.RELEASED_WORKER);
            });
        });
    };

}

util.inherits(AbstractPool, EventEmitter);
AbstractPool.prototype.events = PoolEvents;


module.exports = AbstractPool;

}).call(this)}).call(this,require("timers").setImmediate)

},{"./utils":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/syndicate/lib/utils.js","events":false,"timers":false,"util":false}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/syndicate/lib/Pool-Isolates.js":[function(require,module,exports){
const AbstractPool = require('./AbstractPool');
const util = require('util');
/**
 * @param {PoolConfig&PoolConfigStorage} options
 * @param workerCreateHelper
 * @mixes AbstractPool
 */
function PoolIsolates(options, workerCreateHelper) {
    AbstractPool.call(this, options);

    this.createNewWorker = function (callback) {
        const workerOptions = options.workerOptions;

        const getIsolatesWorker = options.bootScript;

        getIsolatesWorker(workerOptions)
            .then((newWorker) => {

                if (typeof workerCreateHelper === "function") {
                    workerCreateHelper(newWorker);
                }

                callback(undefined, newWorker)
            })
            .catch(err => {
                callback(err);
            });
    };

}

util.inherits(PoolIsolates, AbstractPool);

module.exports = PoolIsolates;

},{"./AbstractPool":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/syndicate/lib/AbstractPool.js","util":false}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/syndicate/lib/Pool-Threads.js":[function(require,module,exports){
const AbstractPool = require('./AbstractPool');
const util = require('util');

/**
 * @param {PoolConfig&PoolConfigStorage} options
 * @param {function} workerCreateHelper
 * @mixes AbstractPool
 */
function PoolThreads(options, workerCreateHelper) {
    AbstractPool.call(this, options);

    this.createNewWorker = function (callback) {
        const worker_threads ='worker_threads';
        const {Worker} = require(worker_threads);

        const newWorker = new Worker(options.bootScript, options.workerOptions);

        if (typeof workerCreateHelper === "function") {
            workerCreateHelper(newWorker);
        }

        const callbackWrapper = (...args) => {
            removeListeners();
            callback(...args);
        };

        function onMessage(msg) {
            if(msg !== 'ready') {
                callbackWrapper(new Error('Build script did not respond accordingly, it might be incompatible with current version'));
                return;
            }

            callbackWrapper(undefined, newWorker);
        }

        function removeListeners() {
            newWorker.removeListener('message', onMessage);
            newWorker.removeListener('error', callbackWrapper);
            newWorker.removeListener('exit', callbackWrapper);
        }

        newWorker.on('message', onMessage);
        newWorker.on('error', callbackWrapper);
        newWorker.on('exit', callbackWrapper);
    };

}

util.inherits(PoolThreads, AbstractPool);

module.exports = PoolThreads;

},{"./AbstractPool":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/syndicate/lib/AbstractPool.js","util":false}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/syndicate/lib/Pool-Web-Workers.js":[function(require,module,exports){
const AbstractPool = require('./AbstractPool');
const util = require('util');

/**
 * @param {PoolConfig&PoolConfigStorage} options
 * @param {function} workerCreateHelper
 * @mixes AbstractPool
 */
function PoolWebWorkers(options, workerCreateHelper) {
    AbstractPool.call(this, options);

    this.createNewWorker = function (callback) {

        const envTypes = require("overwrite-require").constants;
        if($$.environmentType !== envTypes.BROWSER_ENVIRONMENT_TYPE){
            return callback(new Error(`Web Worker is not available into current environment type <${$$.environmentType}>`));
        }

        const newWorker = new Worker(options.bootScript, options.workerOptions);

        if (typeof workerCreateHelper === "function") {
            workerCreateHelper(newWorker);
        }

        const callbackWrapper = (...args) => {
            removeListeners();
            callback(...args);
        };

        function onMessage(msg) {
            if(msg.data !== 'ready') {
                callbackWrapper(new Error('Build script did not respond accordingly, it might be incompatible with current version'));
                return;
            }

            callbackWrapper(undefined, newWorker);
        }

        function removeListeners() {
            newWorker.removeEventListener('message', onMessage);
            newWorker.removeEventListener('messageerror', callbackWrapper);
        }

        newWorker.addEventListener('message', onMessage);
        newWorker.addEventListener('messageerror', callbackWrapper);
    };

}

util.inherits(PoolWebWorkers, AbstractPool);

module.exports = PoolWebWorkers;

},{"./AbstractPool":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/syndicate/lib/AbstractPool.js","overwrite-require":"overwrite-require","util":false}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/syndicate/lib/PoolConfig.js":[function(require,module,exports){
const os = require('os');
const util = require('util');
const WorkerStrategies = require('./WorkerStrategies');

function PoolConfigStorage() {
    this.bootScript = ``;
    this.maximumNumberOfWorkers = os.cpus().length;
    this.workerStrategy = WorkerStrategies.THREADS;
    this.workerOptions = {
        eval: false
    };
}

/**
 * This just provides validation for properties on config
 * Substituting this class to PoolConfigStorage should behave exactly the same effect if the config is valid
 * @constructor
 */
function PoolConfig() {
    const storage = new PoolConfigStorage();

    return {
        get bootScript() {
            return storage.bootScript;
        },
        set bootScript(value) {
            storage.bootScript = value;
        },

        get maximumNumberOfWorkers() {
            return storage.maximumNumberOfWorkers;
        },
        set maximumNumberOfWorkers(value) {
            if (!Number.isFinite(value)) {
                throw new TypeError(`Attribute maximumNumberOfWorkers should be a finite number, got ${typeof value}`);
            }

            if (value <= 0) {
                throw new RangeError(`Attribute maximumNumberOfWorkers should have a value bigger than 0, got ${value}`);
            }

            storage.maximumNumberOfWorkers = value;
        },

        get workerStrategy() {
            return storage.workerStrategy
        },
        set workerStrategy(value) {
            if (!Object.values(WorkerStrategies).includes(value)) {
                throw new TypeError(`Value ${value} not allowed for workerStrategy attribute`);
            }

            storage.workerStrategy = value;
        },

        get workerOptions() {
            return storage.workerOptions;
        },
        set workerOptions(value) {
            storage.workerOptions = value;
        },

        toJSON: function () {
            return JSON.stringify(storage);
        },
        [Symbol.toStringTag]: function () {
            return storage.toString()
        },
        [util.inspect.custom]: function () {
            return util.inspect(storage, {colors: true});
        }
    }
}

/**
 * This utility merges a new config to a default one. It is easier to use if you want to overwrite only a subset
 * of properties of the config.
 * @returns {PoolConfig&PoolConfigStorage}
 */
PoolConfig.createByOverwritingDefaults = function (config = {}, options = {allowNewKeys: true, allowUndefined: true}) {
    const defaultConfig = new PoolConfig();

    Object.keys(config).forEach(key => {

        if (!options.allowNewKeys && !defaultConfig.hasOwnProperty(key)) {
            throw new Error(`Tried overwriting property ${key} that does not exist on PoolConfig. ` +
                `If this is intentional, set in options argument "allowNewKeys" to true'`);
        }

        if (!options.allowUndefined && typeof config[key] === 'undefined') {
            throw new Error(`Tried setting value of ${key} to undefined. ` +
                'If this is intentional, set in options argument "allowUndefined" to true');
        }

        defaultConfig[key] = config[key];
    });

    return defaultConfig;
};

module.exports = PoolConfig;
},{"./WorkerStrategies":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/syndicate/lib/WorkerStrategies.js","os":false,"util":false}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/syndicate/lib/QueueShim.js":[function(require,module,exports){
function Queue() {
    const backingStorage = [];

    Object.defineProperty(this, 'length', {
        get() {
            return backingStorage.length
        },
        set(value) {
            backingStorage.length = value;
        }
    });

    Object.defineProperty(this, 'head', {
        get: () => {
            if (backingStorage.length > 0) {
                return backingStorage[0];
            }

            return null;
        }
    });

    Object.defineProperty(this, 'tail', {
        get: () => {
            const length = backingStorage.length;
            if (length > 0) {
                return backingStorage[length - 1];
            }

            return null;
        }
    });


    this.push = (value) => {
        backingStorage.push(value);
    };

    this.pop = () => {
        return backingStorage.shift();
    };

    this.front = function () {
        return this.head;
    };

    this.isEmpty = function () {
        return backingStorage.length === 0;
    };

    this[Symbol.iterator] = backingStorage[Symbol.iterator];

    this.toString = backingStorage.toString;
    this[Symbol.for('nodejs.util.inspect.custom')] = function() {
        return JSON.stringify(backingStorage);
    }

}

module.exports = Queue;

},{}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/syndicate/lib/WorkerPool.js":[function(require,module,exports){
/** @param pool {AbstractPool} */
function WorkerPool(pool) {
    const { assert } = require("./utils");
    let Queue;

    try {
        Queue = require("swarmutils").Queue;
    } catch (e) {
        Queue = require("./QueueShim.js");
    }

    const PoolEvents = pool.events;
    const taskQueue = new Queue();

    this.addTask = function (task, callback) {
        const taskAccepted = this.runTaskImmediately(task, callback);

        if (!taskAccepted) {
            taskQueue.push({ task, callback });
            return false;
        }

        return true;
    };

    /**
     * Tries to run task if a worker is available, if it is not it will simply discard the task
     * @returns {boolean} - True if the task was given to a worker, false if no worker was available for this task
     */
    this.runTaskImmediately = function (task, callback) {
        const worker = pool.getAvailableWorker();

        if (!worker) {
            return false;
        }

        addWorkerListeners(worker, callback);

        worker.postMessage(task);
        return true;
    };

    pool.on(PoolEvents.RELEASED_WORKER, () => {
        if (taskQueue.isEmpty()) {
            return;
        }

        const taskSize = taskQueue.length;
        const nextTask = taskQueue.front();

        const taskWasAcceptedByAWorker = this.runTaskImmediately(nextTask.task, nextTask.callback);

        if (taskWasAcceptedByAWorker) {
            taskQueue.pop();
            const newTaskSize = taskQueue.length;
            assert(newTaskSize === taskSize - 1, {
                ifFails: `The task queue size did not decrease, expected to be ${taskSize - 1} but is ${newTaskSize}`,
            });
        } else {
            const newTaskSize = taskQueue.length;
            assert(newTaskSize === taskSize, {
                ifFails: `The task queue size modified when it shouldn't, expected to be equal but got pair (old: ${taskSize}, new: ${newTaskSize})`,
            });
            // events are propagates synchronously as mentioned in documentation (https://nodejs.org/api/events.html#events_asynchronous_vs_synchronous)
            // one reason why this can happen is if the worker is not properly marked as "not working"
            // another one is that the queue contains a worker that is free but can't accept tasks (it might have been terminated)
            console.error(`This should never happen and it's most likely a bug`);
        }
    });

    /**
     * @param {Worker} worker
     * @param {function} callbackForListeners
     */
    function addWorkerListeners(worker, callbackForListeners) {
        function callbackWrapper(...args) {
            removeListeners();
            if (args[0] instanceof Error) {
                pool.removeWorker(worker);
            } else {
                pool.returnWorker(worker);
            }
            callbackForListeners(...args);
        }

        function onMessage(...args) {
            if (args[0] instanceof Error) {
                callbackWrapper(...args);
            } else {
                callbackWrapper(undefined, ...args);
            }
        }

        function onError(err) {
            callbackWrapper(err);
        }

        function onExit(code) {
            if (code !== 0) {
                callbackWrapper(new Error(`Worker exited unexpectedly with code ${code}`));
            }
        }

        // ensure consistent API across supported workers
        if (!worker.removeListener) {
            worker.removeListener = worker.removeEventListener.bind(worker);
        }

        // ensure consistent API across supported workers
        if (!worker.once) {
            worker.once = (event, callback) => {
                const listener = (...args) => {
                    worker.removeListener(event, listener);
                    callback(...args);
                };
                worker.addEventListener(event, listener);
            };
        }

        worker.once("message", onMessage);
        worker.once("error", onError);
        worker.once("exit", onExit);

        function removeListeners() {
            worker.removeListener("message", onMessage);
            worker.removeListener("error", onError);
            worker.removeListener("exit", onExit);
        }
    }
}

module.exports = WorkerPool;

},{"./QueueShim.js":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/syndicate/lib/QueueShim.js","./utils":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/syndicate/lib/utils.js","swarmutils":"swarmutils"}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/syndicate/lib/WorkerStrategies.js":[function(require,module,exports){
const WorkerStrategies = {
    THREADS: 'threads',
    ISOLATES: 'isolates',
    WEB_WORKERS: 'web-workers'
};

module.exports = Object.freeze(WorkerStrategies);

},{}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/syndicate/lib/utils.js":[function(require,module,exports){
function assert(condition, {ifFails}) {
    if (condition === false) {
        console.error(ifFails);
    }
}

module.exports = {
    assert
};

},{}],"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/node_modules/is-buffer/index.js":[function(require,module,exports){
/*!
 * Determine if an object is a Buffer
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */

// The _isBuffer check is for Safari 5-7 support, because it's missing
// Object.prototype.constructor. Remove this eventually
module.exports = function (obj) {
  return obj != null && (isBuffer(obj) || isSlowBuffer(obj) || !!obj._isBuffer)
}

function isBuffer (obj) {
  return !!obj.constructor && typeof obj.constructor.isBuffer === 'function' && obj.constructor.isBuffer(obj)
}

// For Node v0.10 support. Remove this eventually.
function isSlowBuffer (obj) {
  return typeof obj.readFloatLE === 'function' && typeof obj.slice === 'function' && isBuffer(obj.slice(0, 0))
}

},{}],"apihub":[function(require,module,exports){
const logger = $$.getLogger("HttpServer", "apihub");

process.on('uncaughtException', err => {
	logger.critical('There was an uncaught error', err, err.message, err.stack);
});

process.on('SIGTERM', (signal)=>{
	process.shuttingDown = true;
	logger.info('Received signal:', signal, ". Activating the gracefulTerminationWatcher.");
});

const httpWrapper = require('./libs/http-wrapper');
const Server = httpWrapper.Server;

const CHECK_FOR_RESTART_COMMAND_FILE_INTERVAL = 500;

(function loadDefaultComponents(){
	//next require lines are only for browserify build purpose
	// Remove mock
	require('./components/admin');
	require('./components/config');
	require('./components/contracts');
	require('./components/bricking');
	require('./components/anchoring');
	require('./components/bdns');
	require('./components/fileManager');
	require('./components/bricksFabric');
	require('./components/staticServer');
	require('./components/keySsiNotifications');
	require('./components/debugLogger');
	require('./components/mqHub');
	require('./components/enclave');
	require('./components/secrets');
	require('./components/mainDSU');
	require('./components/cloudWallet');
	require('./components/stream');
	require('./components/requestForwarder');
	//end
})();

function HttpServer({ listeningPort, rootFolder, sslConfig, dynamicPort, restartIntervalCheck, retryTimeout }, callback) {
	if(typeof restartIntervalCheck === "undefined"){
		restartIntervalCheck = CHECK_FOR_RESTART_COMMAND_FILE_INTERVAL;
	}

	let port = listeningPort || 8080;
	const conf =  require('./config').getConfig();
	const server = new Server(sslConfig);
	server.config = conf;
	server.rootFolder = rootFolder;
	let listenCallback = (err) => {
		if (err) {
			logger.error(err);
			if (!dynamicPort && callback) {
				return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to listen on port <${port}>`, err));
			}
			if(dynamicPort && error.code === 'EADDRINUSE'){
				function getRandomPort() {
					const min = 9000;
					const max = 65535;
					return Math.floor(Math.random() * (max - min) + min);
				}
				port = getRandomPort();
				if(Number.isInteger(dynamicPort)){
					dynamicPort -= 1;
				}
				let timeValue = retryTimeout || CHECK_FOR_RESTART_COMMAND_FILE_INTERVAL;
				setTimeout(bootup, timeValue);
			}
		}
	};

	function bootup(){
		logger.debug(`Trying to listen on port ${port}`);
		server.listen(port, conf.host, listenCallback);
	}

	bootup();

	if(restartIntervalCheck){
		setInterval(function(){
			let restartServerFile = server.rootFolder + '/needServerRestart';
			const fsname = "fs";
			const fs = require(fsname);
			fs.readFile(restartServerFile, function(error, content) {
				if (!error && content.toString() !== "") {
					logger.debug(`### Preparing to restart because of the request done by file: <${restartServerFile}> File content: ${content}`);
					server.close();
					server.listen(port, conf.host, () => {
						fs.writeFile(restartServerFile, "", function(){
							//we don't care about this file.. we just clear it's content the prevent recursive restarts
							logger.debug(`### Restart operation finished.`);
						});
					});
				}
			});
		}, restartIntervalCheck);
	}

	server.on('listening', bindFinished);
	server.on('error', listenCallback);

	let accessControlAllowHeaders = new Set();
	accessControlAllowHeaders.add("Content-Type");
	accessControlAllowHeaders.add("Content-Length");
	accessControlAllowHeaders.add("X-Content-Length");
	accessControlAllowHeaders.add("Access-Control-Allow-Origin");
	accessControlAllowHeaders.add("User-Agent");
	accessControlAllowHeaders.add("Authorization");

	server.registerAccessControlAllowHeaders = function(headers){
		if(headers){
			if(Array.isArray(headers)){
				for(let i=0; i<headers.length; i++){
					accessControlAllowHeaders.add(headers[i]);
				}
			}else{
				accessControlAllowHeaders.add(headers);
			}
		}
	}

	server.getAccessControlAllowHeadersAsString = function(){
		let headers = "";
		let notFirst = false;
		for(let header of accessControlAllowHeaders){
			if(notFirst){
				headers += ", ";
			}
			notFirst = true;
			headers += header;
		}
		return headers;
	}

	function bindFinished(err) {
		if (err) {
			logger.error(err);
			if (callback) {
				return OpenDSUSafeCallback(callback)(createOpenDSUErrorWrapper(`Failed to bind on port <${port}>`, err));
			}
			return;
		}

		registerEndpoints(callback);
	}

	let endpointsAlreadyRegistered = false;
	function registerEndpoints(callback) {
		//The purpose of this flag is to prevent endpoints registering again
		//in case of a restart requested by file needServerRestart present in rootFolder
		if(endpointsAlreadyRegistered){
			return ;
		}
		endpointsAlreadyRegistered = true;
		server.use(function (req, res, next) {
			res.setHeader('Access-Control-Allow-Origin', req.headers.origin || req.headers.host || "*");
			res.setHeader('Access-Control-Allow-Methods', 'GET, POST, PUT, DELETE, OPTIONS');
			res.setHeader('Access-Control-Allow-Headers', server.getAccessControlAllowHeadersAsString());
			res.setHeader('Access-Control-Allow-Credentials', true);
			next();
		});

		server.options('/*', function (req, res) {
			const headers = {};
			//origin header maybe missing (eg. Postman call or proxy that doesn't forward the origin header etc.)
			if(req.headers.origin){
				headers['Access-Control-Allow-Origin'] = req.headers.origin;
			}else{
				headers['Access-Control-Allow-Origin'] = '*';
			}
			headers['Access-Control-Allow-Methods'] = 'POST, GET, PUT, DELETE, OPTIONS';
			headers['Access-Control-Allow-Credentials'] = true;
			headers['Access-Control-Max-Age'] = '3600'; //one hour
			headers['Access-Control-Allow-Headers'] = server.getAccessControlAllowHeadersAsString();

			if(conf.CORS){
				logger.debug("Applying custom CORS headers");
				for(let prop in conf.CORS){
					headers[prop] = conf.CORS[prop];
				}
			}

			res.writeHead(200, headers);
			res.end();
        });

        function addRootMiddlewares() {
			const LoggerMiddleware = require('./middlewares/logger');
			const AuthorisationMiddleware = require('./middlewares/authorisation');
			const Throttler = require('./middlewares/throttler');
			const OAuth = require('./middlewares/oauth');
			const FixedUrls = require('./middlewares/fixedUrls');
			const ResponseHeaderMiddleware = require('./middlewares/responseHeader');
			const genericErrorMiddleware = require('./middlewares/genericErrorMiddleware');
			const requestEnhancements = require('./middlewares/requestEnhancements');

			server.use(function gracefulTerminationWatcher(req, res, next) {
				const allowedUrls = ["/installation-details", "/ready-probe"];
				if(process.shuttingDown && allowedUrls.indexOf(req.url) === -1){
					//uncaught exception was caught so server is shutting down gracefully and not accepting any requests
					res.statusCode = 503;
					logger.log(0x02, `Rejecting ${req.url} with status code ${res.statusCode} because process is shutting down.`);
					res.end();
					return;
				}
				//if the url is allowed or shuttingDown flag not present, we let the request go on...
				next();
			});

			if(conf.enableRequestLogger) {
				new LoggerMiddleware(server);
			}

			if(conf.enableErrorCloaking){
				genericErrorMiddleware(server);
			}
			requestEnhancements(server);
			Throttler(server);
			FixedUrls(server);

            if(conf.enableJWTAuthorisation) {
                new AuthorisationMiddleware(server);
            }
			if(conf.enableOAuth && process.env.ENABLE_SSO !== "false") {
                new OAuth(server);
            }
			if(conf.responseHeaders){
				new ResponseHeaderMiddleware(server);
			}
            if(conf.enableInstallationDetails) {
                const enableInstallationDetails = require("./components/installation-details");
                enableInstallationDetails(server);
            }
        }

        function addComponent(componentName, componentConfig, callback) {
            const path = require("swarmutils").path;

            let componentPath = componentConfig.module;
            if (componentPath.startsWith('.') && !conf.isDefaultComponent(componentName)) {
                componentPath = path.resolve(path.join(process.env.PSK_ROOT_INSTALATION_FOLDER, componentPath));
            }
            logger.debug(`Preparing to register middleware from path ${componentPath}`);

            let middlewareImplementation;
            try{
                middlewareImplementation = require(componentPath);
            } catch(e){
                throw e;
            }
			let asyncLodingComponent = false;
			const calledByAsynLoadingComponent = (cb)=>{
				asyncLodingComponent = true;
				//if the component calls before returning this function means that needs more time, is doing async calls etc.
			}

			let arguments = [server];

			if(callback) {
				arguments.push(calledByAsynLoadingComponent);
				arguments.push(callback);
			}

            if (typeof componentConfig.function !== 'undefined') {
                middlewareImplementation[componentConfig.function](...arguments);
            } else {
                middlewareImplementation(...arguments);
            }

			if(!asyncLodingComponent && callback){
				callback();
			}
        }

		function addComponents(cb) {
            const requiredComponentNames = ["config"];
            addComponent("config", {module: "./components/config"});

            // take only the components that have configurations and that are not part of the required components
			const middlewareList = [...conf.activeComponents]
                .filter(activeComponentName => {
                	let include = conf.componentsConfig[activeComponentName];
                	if(!include){
                		logger.debug(`Not able to find config for component called < ${activeComponentName} >. Excluding it from the active components list!`);
					}
                	return include;
				})
                .filter(activeComponentName => !requiredComponentNames.includes(activeComponentName));

            const addRequiredComponent = (componentName) => {
                if(!middlewareList.includes(`${componentName}`)) {
                    logger.warn(`WARNING: ${componentName} component is not configured inside activeComponents!`)
                    logger.warn(`WARNING: temporary adding ${componentName} component to activeComponents! Please make sure to include ${componentName} component inside activeComponents!`)

                    const addComponentToComponentList = (list) => {
                        const indexOfStaticServer = list.indexOf("staticServer");
                        if(indexOfStaticServer !== -1) {
                            // staticServer needs to load last
                            list.splice(indexOfStaticServer, 0, componentName);
                        } else {
                            list.push(componentName);
                        }
                    }

                    addComponentToComponentList(middlewareList);
                    // need to also register to defaultComponents in order to be able to load the module correctly
                    addComponentToComponentList(conf.defaultComponents);
                }
            }

            addRequiredComponent("cloudWallet");
            addRequiredComponent("mainDSU");

			function installNextComponent(componentList){
				const componentName = componentList[0];
				const componentConfig = conf.componentsConfig[componentName];
				addComponent(componentName, componentConfig, ()=>{
					componentList.shift();
					if(componentList.length>0){
						return installNextComponent(componentList);
					}
					if(cb){
						cb();
					}
				});
			}

			if(middlewareList.indexOf("staticServer") === -1) {
				middlewareList.push("staticServer");
			}

			installNextComponent(middlewareList);
		}

        addRootMiddlewares();
		addComponents(()=>{
			//at this point all components were installed and we need to register the fallback handler
			logger.debug("Registering the fallback handler. Any endpoint registered after this one will have zero changes to be executed.");
			server.use(function (req, res) {
				logger.debug("Response handled by fallback handler.");
				res.statusCode = 404;
				res.end();
			});
			if (callback) {
				return callback();
			}
		});
	}

	return server;
}

module.exports.createInstance = function (port, folder, sslConfig, callback) {
	if (typeof sslConfig === 'function') {
		callback = sslConfig;
		sslConfig = undefined;
	}

	return new HttpServer({ listeningPort: port, rootFolder: folder, sslConfig }, callback);
};

module.exports.start = function(options, callback){
	return new HttpServer(options, callback);
}

module.exports.getHttpWrapper = function () {
	return require('./libs/http-wrapper');
};

module.exports.getServerConfig = function () {
	logger.warn(`apihub.getServerConfig() method is deprecated, please use server.config to retrieve necessary info.`);
	const config = require('./config');
	return config.getConfig();
};

module.exports.getDomainConfig = function (domain, ...configKeys) {
	logger.warn(`apihub.getServerConfig() method is deprecated, please use server.config.getDomainConfig(...) to retrieve necessary info.`);
	const config = require('./config');
	return config.getDomainConfig(domain, ...configKeys);
};

module.exports.anchoringStrategies = require("./components/anchoring/strategies");

},{"./components/admin":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/apihub/components/admin/index.js","./components/anchoring":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/apihub/components/anchoring/index.js","./components/anchoring/strategies":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/apihub/components/anchoring/strategies/index.js","./components/bdns":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/apihub/components/bdns/index.js","./components/bricking":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/apihub/components/bricking/index.js","./components/bricksFabric":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/apihub/components/bricksFabric/index.js","./components/cloudWallet":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/apihub/components/cloudWallet/index.js","./components/config":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/apihub/components/config/index.js","./components/contracts":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/apihub/components/contracts/index.js","./components/debugLogger":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/apihub/components/debugLogger/index.js","./components/enclave":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/apihub/components/enclave/index.js","./components/fileManager":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/apihub/components/fileManager/index.js","./components/installation-details":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/apihub/components/installation-details/index.js","./components/keySsiNotifications":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/apihub/components/keySsiNotifications/index.js","./components/mainDSU":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/apihub/components/mainDSU/index.js","./components/mqHub":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/apihub/components/mqHub/index.js","./components/requestForwarder":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/apihub/components/requestForwarder/index.js","./components/secrets":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/apihub/components/secrets/index.js","./components/staticServer":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/apihub/components/staticServer/index.js","./components/stream":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/apihub/components/stream/index.js","./config":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/apihub/config/index.js","./libs/http-wrapper":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/apihub/libs/http-wrapper/src/index.js","./middlewares/authorisation":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/apihub/middlewares/authorisation/index.js","./middlewares/fixedUrls":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/apihub/middlewares/fixedUrls/index.js","./middlewares/genericErrorMiddleware":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/apihub/middlewares/genericErrorMiddleware/index.js","./middlewares/logger":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/apihub/middlewares/logger/index.js","./middlewares/oauth":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/apihub/middlewares/oauth/index.js","./middlewares/requestEnhancements":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/apihub/middlewares/requestEnhancements/index.js","./middlewares/responseHeader":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/apihub/middlewares/responseHeader/index.js","./middlewares/throttler":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/apihub/middlewares/throttler/index.js","swarmutils":"swarmutils"}],"bar-fs-adapter":[function(require,module,exports){
module.exports.createFsAdapter = () => {
    const FsAdapter = require("./lib/FsAdapter");
    return new FsAdapter();
};
},{"./lib/FsAdapter":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/bar-fs-adapter/lib/FsAdapter.js"}],"bar":[function(require,module,exports){

const ArchiveConfigurator = require("./lib/ArchiveConfigurator");
const createFolderBrickStorage = require("./lib/obsolete/FolderBrickStorage").createFolderBrickStorage;
const createFileBrickStorage = require("./lib/obsolete/FileBrickStorage").createFileBrickStorage;
const BrickStorageService = require('./lib/BrickStorageService').Service;
const BrickMapController = require('./lib/BrickMapController');

ArchiveConfigurator.prototype.registerStorageProvider("FolderBrickStorage", createFolderBrickStorage);
ArchiveConfigurator.prototype.registerStorageProvider("FileBrickStorage", createFileBrickStorage);

module.exports.ArchiveConfigurator = ArchiveConfigurator;
module.exports.createBrick = (config) => {
    const Brick = require("./lib/Brick");
    return new Brick(config);
};

module.exports.createArchive = (archiveConfigurator) => {
    const Archive = require("./lib/Archive");
    return new Archive(archiveConfigurator);
};
module.exports.createArchiveConfigurator = () => {
    return new ArchiveConfigurator();
};

module.exports.createBrickMap = (header) => {
    const BrickMap = require("./lib/BrickMap");
    return new BrickMap(header);
};

module.exports.isArchive = (archive) => {
    const Archive = require('./lib/Archive');
    return archive instanceof Archive;
}

module.exports.BrickMapDiff = require('./lib/BrickMapDiff');
module.exports.BrickMapStrategyFactory = require('./lib/BrickMapStrategy');
module.exports.BrickMapStrategyMixin = require('./lib/BrickMapStrategy/BrickMapStrategyMixin');
module.exports.createFolderBrickStorage = createFolderBrickStorage;
module.exports.createFileBrickStorage = createFileBrickStorage;

module.exports.createBrickStorageService = (archiveConfigurator, keySSI) => {
    const brickStorageService = new BrickStorageService({
        cache: archiveConfigurator.getCache(),
        bufferSize: archiveConfigurator.getBufferSize(),
        keySSI,

        brickFactoryFunction: (encrypt) => {
            const Brick = require("./lib/Brick");
            encrypt = (typeof encrypt === 'undefined') ? true : !!encrypt;
            // Strip the encryption key from the SeedSSI
            return new Brick({templateKeySSI: keySSI, encrypt});
        },

        brickDataExtractorCallback: (brickMeta, brick, callback) => {
            brick.setTemplateKeySSI(keySSI);

            function extractData() {
                const brickEncryptionKeySSI = brickMapController.getBrickEncryptionKeySSI(brickMeta);
                brick.setKeySSI(brickEncryptionKeySSI);
                brick.getRawData(callback);
            }

            if (refreshInProgress) {
                return waitIfDSUIsRefreshing(() => {
                    extractData();
                })
            }
            extractData();
        },

        fsAdapter: archiveConfigurator.getFsAdapter()
    });
    const brickMapController = new BrickMapController({
        config: archiveConfigurator,
        brickStorageService,
        keySSI
    });

    return brickStorageService;
};
},{"./lib/Archive":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/bar/lib/Archive.js","./lib/ArchiveConfigurator":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/bar/lib/ArchiveConfigurator.js","./lib/Brick":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/bar/lib/Brick.js","./lib/BrickMap":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/bar/lib/BrickMap.js","./lib/BrickMapController":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/bar/lib/BrickMapController.js","./lib/BrickMapDiff":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/bar/lib/BrickMapDiff.js","./lib/BrickMapStrategy":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/bar/lib/BrickMapStrategy/index.js","./lib/BrickMapStrategy/BrickMapStrategyMixin":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/bar/lib/BrickMapStrategy/BrickMapStrategyMixin.js","./lib/BrickStorageService":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/bar/lib/BrickStorageService/index.js","./lib/obsolete/FileBrickStorage":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/bar/lib/obsolete/FileBrickStorage.js","./lib/obsolete/FolderBrickStorage":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/bar/lib/obsolete/FolderBrickStorage.js"}],"blockchain":[function(require,module,exports){
___DISABLE_OBSOLETE_ZIP_ARCHIVER_WAIT_FOR_BARS = true;
//require("../../../psknode/bundles/pskruntime.js");
var callflowModule = require("callflow");
let assetUtils = require("./blockchainSwarmTypes/asset_swarm_template");
let transactionUtils = require("./blockchainSwarmTypes/transaction_swarm_template");
$$.assets           = callflowModule.createSwarmEngine("asset", assetUtils);
$$.asset            = $$.assets;
$$.transactions     = callflowModule.createSwarmEngine("transaction", transactionUtils);
$$.transaction      = $$.transactions;

module.exports = require('./moduleExports');


},{"./blockchainSwarmTypes/asset_swarm_template":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/blockchain/blockchainSwarmTypes/asset_swarm_template.js","./blockchainSwarmTypes/transaction_swarm_template":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/blockchain/blockchainSwarmTypes/transaction_swarm_template.js","./moduleExports":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/blockchain/moduleExports.js","callflow":"callflow"}],"bricksledger":[function(require,module,exports){
const Command = require("./src/Command");
const Logger = require("./src/Logger");
const PBlockAddedMessage = require("./src/Broadcaster/PBlockAddedMessage");
const ValidatorNonInclusionMessage = require("./src/Broadcaster/ValidatorNonInclusionMessage");

const NOT_BOOTED_ERROR = "BricksLedger not booted";

function BricksLedger(
    domain,
    validatorDID,
    pBlocksFactory,
    broadcaster,
    consensusCore,
    executionEngine,
    brickStorage,
    commandHistoryStorage
) {
    const logger = new Logger(`[Bricksledger][${domain}][${validatorDID.getIdentifier()}]`);
    let isBootFinished = false;

    this.boot = async function () {
        logger.info("Booting BricksLedger...");
        await executionEngine.loadContracts(consensusCore);
        await consensusCore.boot();
        isBootFinished = true;
        logger.info("Booting BricksLedger finished...");
    };

    this.getLatestBlockInfo = function (callback) {
        if (!isBootFinished) {
            return callback(new Error(NOT_BOOTED_ERROR));
        }
        const lastestBlockInfo = consensusCore.getLatestBlockInfo();
        callback(undefined, lastestBlockInfo);
    };

    this.executeSafeCommand = async function (command, callback) {
        callback = $$.makeSaneCallback(callback);
        logger.debug(`Received safe command ${command.getHash()}`);

        if (!isBootFinished) {
            return callback(new Error(NOT_BOOTED_ERROR));
        }

        if (!command || !(command instanceof Command)) {
            return callback("command not instance of Command");
        }

        try {
            await executionEngine.validateSafeCommand(command);

            logger.debug(`[safe-command-${command.getHash()}] executing method optimistically...`);
            let execution = executionEngine.executeMethodOptimistically(command);

            try {
                callback(undefined, execution);
            } catch (error) {
                logger.error(error);
            }

            if (await execution.requireConsensus()) {
                logger.debug(`[safe-command-${command.getHash()}] Executing safe command optimistically still requires consensus`);
                await commandHistoryStorage.addOptimisticComand(command);
                pBlocksFactory.addCommandForConsensusAsync(command);
            } else {
                logger.debug(`[safe-command-${command.getHash()}] Executing safe command optimistically doesn't requires consensus`);
            }
        } catch (error) {
            callback(error);
        }
    };

    this.executeNoncedCommand = async function (command, callback) {
        callback = $$.makeSaneCallback(callback);
        logger.debug(`Received nonced command ${command.getHash()}`);

        if (!isBootFinished) {
            return callback(new Error(NOT_BOOTED_ERROR));
        }

        if (!command || !(command instanceof Command)) {
            return callback("command not instance of Command");
        }

        try {
            logger.debug(`[nonced-command-${command.getHash()}] getting latest block info...`);
            const latestBlockInfo = consensusCore.getLatestBlockInfo();
            logger.debug(`[nonced-command-${command.getHash()}] got latest block info`, latestBlockInfo);

            logger.debug(`[nonced-command-${command.getHash()}] validating nonced command...`, latestBlockInfo);
            await executionEngine.validateNoncedCommand(command, latestBlockInfo.number);

            logger.debug(`[nonced-command-${command.getHash()}] adding command to history storage...`, latestBlockInfo);
            await commandHistoryStorage.addOptimisticComand(command);

            logger.debug(`[nonced-command-${command.getHash()}] executing method optimistically...`);
            let execution = executionEngine.executeMethodOptimistically(command);

            try {
                callback(undefined, execution);
            } catch (error) {
                console.error(error);
            }

            pBlocksFactory.addCommandForConsensusAsync(command);
        } catch (error) {
            callback(error);
        }
    };

    this.validatePBlockFromNetwork = async function (pBlockMessage, callback) {
        callback = $$.makeSaneCallback(callback);

        logger.debug("Received pBlock message from network", pBlockMessage);

        if (!isBootFinished) {
            return callback(new Error(NOT_BOOTED_ERROR));
        }

        if (!pBlockMessage) {
            return callback("pBlockMessage not provided");
        }

        pBlockMessage = new PBlockAddedMessage(pBlockMessage);

        try {
            await pBlockMessage.validateSignature();
            pBlocksFactory.forcePBlockCreationForBlockNumberIfAbsentAsync(pBlockMessage.blockNumber);

            // add the pBlock in consensus on the next cycle in order to not block the request
            setTimeout(async () => {
                try {
                    await consensusCore.addExternalPBlockInConsensusAsync(pBlockMessage);
                } catch (error) {
                    // errors logged in detail in addExternalPBlockInConsensusAsync
                }
            });
            callback();
        } catch (error) {
            callback(error);
        }
    };

    this.setValidatorNonInclusion = async function (validatorNonInclusionMessage, callback) {
        callback = $$.makeSaneCallback(callback);

        if (!isBootFinished) {
            return callback(new Error(NOT_BOOTED_ERROR));
        }

        if (!validatorNonInclusionMessage) {
            return callback("validatorNonInclusionMessage not provided");
        }

        validatorNonInclusionMessage = new ValidatorNonInclusionMessage(validatorNonInclusionMessage);

        try {
            await validatorNonInclusionMessage.validateSignature();
            await consensusCore.setValidatorNonInclusionAsync(validatorNonInclusionMessage);
            callback();
        } catch (error) {
            callback(error);
        }
    };
}

const initiliseBrickLedger = async (validatorDID, validatorURL, domain, domainConfig, rootFolder, storageFolder, callback) => {
    callback = $$.makeSaneCallback(callback);

    const validatorDIDString = validatorDID && typeof validatorDID === "object" ? validatorDID.getIdentifier() : validatorDID;
    const logger = new Logger(`[Bricksledger][${domain}][${validatorDIDString}]`);
    logger.debug(`Starting initialization...`, {
        validatorURL,
        rootFolder,
        storageFolder,
        domainConfig: JSON.stringify(domainConfig),
    });

    try {
        if (typeof validatorDID === "string") {
            const w3cDID = require("opendsu").loadAPI("w3cdid");
            validatorDID = await $$.promisify(w3cDID.resolveDID)(validatorDID);
        }

        const config =
            domainConfig && domainConfig.contracts && typeof domainConfig.contracts === "object" ? domainConfig.contracts : {};
        const { maxPBlockSize, maxPBlockTimeMs, pendingBlocksTimeoutMs, nonInclusionCheckTimeoutMs } = config;

        // bind the domain and rootFolder in order to use it easier
        const createFSKeyValueStorage = require("./src/FSKeyValueStorage").create.bind(null, domain, storageFolder);

        let brickStorage = require("./src/FSBrickStorage").create(domain, `domains/${domain}/brick-storage`, storageFolder);
        let commandHistoryStorage = require("./src/CommandHistoryStorage").create(domain, storageFolder);
        await commandHistoryStorage.init();

        let executionEngine = require("./src/ExecutionEngine").create(
            domain,
            domainConfig,
            rootFolder,
            storageFolder,
            createFSKeyValueStorage,
            commandHistoryStorage
        );

        let broadcaster = require("./src/Broadcaster").create(domain, validatorDID, validatorURL, executionEngine);
        let notifier = require("./src/Notifier").create(domain, validatorDID);

        let consensusCore = require("./src/ConsensusCore").create(
            validatorDID,
            validatorURL,
            domain,
            storageFolder,
            brickStorage,
            executionEngine,
            broadcaster,
            notifier,
            pendingBlocksTimeoutMs,
            nonInclusionCheckTimeoutMs
        );

        let pBlocksFactory = require("./src/PBlocksFactory").create(
            domain,
            validatorDID,
            brickStorage,
            consensusCore,
            broadcaster,
            maxPBlockSize,
            maxPBlockTimeMs
        );

        const bricksLedger = new BricksLedger(
            domain,
            validatorDID,
            pBlocksFactory,
            broadcaster,
            consensusCore,
            executionEngine,
            brickStorage,
            commandHistoryStorage
        );

        await bricksLedger.boot();

        callback(null, bricksLedger);
    } catch (error) {
        logger.error("Error initializing", error);
        callback(error);
    }
};

const createCommand = (command) => {
    const Command = require("./src/Command");
    return new Command(command);
};

const createFSBrickStorage = (...props) => {
    return require("./src/FSBrickStorage").create(...props);
};

module.exports = {
    initiliseBrickLedger,
    createCommand,
    createFSBrickStorage,
};

},{"./src/Broadcaster":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/bricksledger/src/Broadcaster/index.js","./src/Broadcaster/PBlockAddedMessage":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/bricksledger/src/Broadcaster/PBlockAddedMessage.js","./src/Broadcaster/ValidatorNonInclusionMessage":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/bricksledger/src/Broadcaster/ValidatorNonInclusionMessage.js","./src/Command":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/bricksledger/src/Command.js","./src/CommandHistoryStorage":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/bricksledger/src/CommandHistoryStorage.js","./src/ConsensusCore":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/bricksledger/src/ConsensusCore/index.js","./src/ExecutionEngine":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/bricksledger/src/ExecutionEngine/index.js","./src/FSBrickStorage":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/bricksledger/src/FSBrickStorage/index.js","./src/FSKeyValueStorage":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/bricksledger/src/FSKeyValueStorage/index.js","./src/Logger":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/bricksledger/src/Logger.js","./src/Notifier":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/bricksledger/src/Notifier.js","./src/PBlocksFactory":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/bricksledger/src/PBlocksFactory.js","opendsu":"opendsu"}],"buffer-crc32":[function(require,module,exports){

var CRC_TABLE = [
  0x00000000, 0x77073096, 0xee0e612c, 0x990951ba, 0x076dc419,
  0x706af48f, 0xe963a535, 0x9e6495a3, 0x0edb8832, 0x79dcb8a4,
  0xe0d5e91e, 0x97d2d988, 0x09b64c2b, 0x7eb17cbd, 0xe7b82d07,
  0x90bf1d91, 0x1db71064, 0x6ab020f2, 0xf3b97148, 0x84be41de,
  0x1adad47d, 0x6ddde4eb, 0xf4d4b551, 0x83d385c7, 0x136c9856,
  0x646ba8c0, 0xfd62f97a, 0x8a65c9ec, 0x14015c4f, 0x63066cd9,
  0xfa0f3d63, 0x8d080df5, 0x3b6e20c8, 0x4c69105e, 0xd56041e4,
  0xa2677172, 0x3c03e4d1, 0x4b04d447, 0xd20d85fd, 0xa50ab56b,
  0x35b5a8fa, 0x42b2986c, 0xdbbbc9d6, 0xacbcf940, 0x32d86ce3,
  0x45df5c75, 0xdcd60dcf, 0xabd13d59, 0x26d930ac, 0x51de003a,
  0xc8d75180, 0xbfd06116, 0x21b4f4b5, 0x56b3c423, 0xcfba9599,
  0xb8bda50f, 0x2802b89e, 0x5f058808, 0xc60cd9b2, 0xb10be924,
  0x2f6f7c87, 0x58684c11, 0xc1611dab, 0xb6662d3d, 0x76dc4190,
  0x01db7106, 0x98d220bc, 0xefd5102a, 0x71b18589, 0x06b6b51f,
  0x9fbfe4a5, 0xe8b8d433, 0x7807c9a2, 0x0f00f934, 0x9609a88e,
  0xe10e9818, 0x7f6a0dbb, 0x086d3d2d, 0x91646c97, 0xe6635c01,
  0x6b6b51f4, 0x1c6c6162, 0x856530d8, 0xf262004e, 0x6c0695ed,
  0x1b01a57b, 0x8208f4c1, 0xf50fc457, 0x65b0d9c6, 0x12b7e950,
  0x8bbeb8ea, 0xfcb9887c, 0x62dd1ddf, 0x15da2d49, 0x8cd37cf3,
  0xfbd44c65, 0x4db26158, 0x3ab551ce, 0xa3bc0074, 0xd4bb30e2,
  0x4adfa541, 0x3dd895d7, 0xa4d1c46d, 0xd3d6f4fb, 0x4369e96a,
  0x346ed9fc, 0xad678846, 0xda60b8d0, 0x44042d73, 0x33031de5,
  0xaa0a4c5f, 0xdd0d7cc9, 0x5005713c, 0x270241aa, 0xbe0b1010,
  0xc90c2086, 0x5768b525, 0x206f85b3, 0xb966d409, 0xce61e49f,
  0x5edef90e, 0x29d9c998, 0xb0d09822, 0xc7d7a8b4, 0x59b33d17,
  0x2eb40d81, 0xb7bd5c3b, 0xc0ba6cad, 0xedb88320, 0x9abfb3b6,
  0x03b6e20c, 0x74b1d29a, 0xead54739, 0x9dd277af, 0x04db2615,
  0x73dc1683, 0xe3630b12, 0x94643b84, 0x0d6d6a3e, 0x7a6a5aa8,
  0xe40ecf0b, 0x9309ff9d, 0x0a00ae27, 0x7d079eb1, 0xf00f9344,
  0x8708a3d2, 0x1e01f268, 0x6906c2fe, 0xf762575d, 0x806567cb,
  0x196c3671, 0x6e6b06e7, 0xfed41b76, 0x89d32be0, 0x10da7a5a,
  0x67dd4acc, 0xf9b9df6f, 0x8ebeeff9, 0x17b7be43, 0x60b08ed5,
  0xd6d6a3e8, 0xa1d1937e, 0x38d8c2c4, 0x4fdff252, 0xd1bb67f1,
  0xa6bc5767, 0x3fb506dd, 0x48b2364b, 0xd80d2bda, 0xaf0a1b4c,
  0x36034af6, 0x41047a60, 0xdf60efc3, 0xa867df55, 0x316e8eef,
  0x4669be79, 0xcb61b38c, 0xbc66831a, 0x256fd2a0, 0x5268e236,
  0xcc0c7795, 0xbb0b4703, 0x220216b9, 0x5505262f, 0xc5ba3bbe,
  0xb2bd0b28, 0x2bb45a92, 0x5cb36a04, 0xc2d7ffa7, 0xb5d0cf31,
  0x2cd99e8b, 0x5bdeae1d, 0x9b64c2b0, 0xec63f226, 0x756aa39c,
  0x026d930a, 0x9c0906a9, 0xeb0e363f, 0x72076785, 0x05005713,
  0x95bf4a82, 0xe2b87a14, 0x7bb12bae, 0x0cb61b38, 0x92d28e9b,
  0xe5d5be0d, 0x7cdcefb7, 0x0bdbdf21, 0x86d3d2d4, 0xf1d4e242,
  0x68ddb3f8, 0x1fda836e, 0x81be16cd, 0xf6b9265b, 0x6fb077e1,
  0x18b74777, 0x88085ae6, 0xff0f6a70, 0x66063bca, 0x11010b5c,
  0x8f659eff, 0xf862ae69, 0x616bffd3, 0x166ccf45, 0xa00ae278,
  0xd70dd2ee, 0x4e048354, 0x3903b3c2, 0xa7672661, 0xd06016f7,
  0x4969474d, 0x3e6e77db, 0xaed16a4a, 0xd9d65adc, 0x40df0b66,
  0x37d83bf0, 0xa9bcae53, 0xdebb9ec5, 0x47b2cf7f, 0x30b5ffe9,
  0xbdbdf21c, 0xcabac28a, 0x53b39330, 0x24b4a3a6, 0xbad03605,
  0xcdd70693, 0x54de5729, 0x23d967bf, 0xb3667a2e, 0xc4614ab8,
  0x5d681b02, 0x2a6f2b94, 0xb40bbe37, 0xc30c8ea1, 0x5a05df1b,
  0x2d02ef8d
];

if (typeof Int32Array !== 'undefined') {
  CRC_TABLE = new Int32Array(CRC_TABLE);
}

function newEmptyBuffer(length) {
  var buffer = new $$.Buffer(length);
  buffer.fill(0x00);
  return buffer;
}

function ensureBuffer(input) {
  if ($$.Buffer.isBuffer(input)) {
    return input;
  }

  var hasNewBufferAPI =
      typeof $$.Buffer.alloc === "function" &&
      typeof $$.Buffer.from === "function";

  if (typeof input === "number") {
    return hasNewBufferAPI ? $$.Buffer.alloc(input) : newEmptyBuffer(input);
  }
  else if (typeof input === "string") {
    return hasNewBufferAPI ? $$.Buffer.from(input) : new $$.Buffer(input);
  }
  else {
    throw new Error("input must be buffer, number, or string, received " +
                    typeof input);
  }
}

function bufferizeInt(num) {
  var tmp = ensureBuffer(4);
  tmp.writeInt32BE(num, 0);
  return tmp;
}

function _crc32(buf, previous) {
  buf = ensureBuffer(buf);
  if ($$.Buffer.isBuffer(previous)) {
    previous = previous.readUInt32BE(0);
  }
  var crc = ~~previous ^ -1;
  for (var n = 0; n < buf.length; n++) {
    crc = CRC_TABLE[(crc ^ buf[n]) & 0xff] ^ (crc >>> 8);
  }
  return (crc ^ -1);
}

function crc32() {
  return bufferizeInt(_crc32.apply(null, arguments));
}
crc32.signed = function () {
  return _crc32.apply(null, arguments);
};
crc32.unsigned = function () {
  return _crc32.apply(null, arguments) >>> 0;
};

module.exports = crc32;

},{}],"callflow":[function(require,module,exports){
(function (global){(function (){
function initialise() {
    if($$.callflow){
        throw new Error("Callflow already initialized!");
    }

    function defaultErrorHandlingImplementation(err, res){
        //console.log(err.stack);
        if(err) throw err;
        return res;
    }

    $$.__intern = {
        mkArgs:function(args,pos){
            var argsArray = [];
            for(var i = pos; i < args.length; i++){
                argsArray.push(args[i]);
            }
            return argsArray;
        }
    };

    $$.defaultErrorHandlingImplementation = defaultErrorHandlingImplementation;

    var callflowModule = require("./lib/swarmDescription");
    $$.callflows        = callflowModule.createSwarmEngine("callflow");
    $$.callflow         = $$.callflows;
    $$.flow             = $$.callflows;
    $$.flows            = $$.callflows;


    $$.PSK_PubSub = require("soundpubsub").soundPubSub;

    $$.securityContext = null;
    $$.HRN_securityContext = "unnamedSecurityContext"; /*HRN: Human Readable Name */
    $$.libraryPrefix = "global";
    $$.libraries = {
        global:{

        }
    };

    $$.interceptor = require("./lib/InterceptorRegistry").createInterceptorRegistry();

    $$.loadLibrary = require("./lib/loadLibrary").loadLibrary;

    global.requireLibrary = function(name){
        //var absolutePath = path.resolve(  $$.__global.__loadLibraryRoot + name);
        return $$.loadLibrary(name,name);
    };

    require("./constants");


    $$.pathNormalize = function (pathToNormalize) {
        const path = require("path");
        pathToNormalize = path.normalize(pathToNormalize);

        return pathToNormalize.replace(/[\/\\]/g, path.sep);
    };

    // add interceptors

    const crypto = require('crypto');

    $$.interceptor.register('*', '*', 'before', function () {
        const swarmTypeName = this.getMetadata('swarmTypeName');
        const phaseName = this.getMetadata('phaseName');
        const swarmId = this.getMetadata('swarmId');
        const executionId = crypto.randomBytes(16).toString('hex');

        this.setMetadata('executionId', executionId);

        $$.event('swarm.call', {swarmTypeName, phaseName, swarmId});
    });
}

module.exports = {
    createSwarmEngine: require("./lib/swarmDescription").createSwarmEngine,
    createJoinPoint: require("./lib/parallelJoinPoint").createJoinPoint,
    createSerialJoinPoint: require("./lib/serialJoinPoint").createSerialJoinPoint,
    createStandardAPIsForSwarms: require("./lib/utilityFunctions/base").createForObject,
    initialise: initialise
};

}).call(this)}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./constants":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/callflow/constants.js","./lib/InterceptorRegistry":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/callflow/lib/InterceptorRegistry.js","./lib/loadLibrary":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/callflow/lib/loadLibrary.js","./lib/parallelJoinPoint":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/callflow/lib/parallelJoinPoint.js","./lib/serialJoinPoint":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/callflow/lib/serialJoinPoint.js","./lib/swarmDescription":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/callflow/lib/swarmDescription.js","./lib/utilityFunctions/base":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/callflow/lib/utilityFunctions/base.js","crypto":false,"path":false,"soundpubsub":"soundpubsub"}],"dossier":[function(require,module,exports){
function envSetup(powerCord, seed, identity, callback){
    let cord_identity;
    try{
        const crypto = require("pskcrypto");
        cord_identity = crypto.pskHash(seed, "hex");
        $$.swarmEngine.plug(cord_identity, powerCord);
    }catch(err){
        return callback(err);
    }
    $$.interactions.startSwarmAs(cord_identity, "transactionHandler", "start", identity, "TooShortBlockChainWorkaroundDeleteThis", "add").onReturn(err => {
        if (err) {
            return callback(err);
        }

        const handler = {
            attachTo : $$.interactions.attachTo,
            startTransaction : function (transactionTypeName, methodName, ...args) {
                //todo: get identity from context somehow
                return $$.interactions.startSwarmAs(cord_identity, "transactionHandler", "start", identity, transactionTypeName, methodName, ...args);
            }
        };
        //todo implement a way to know when thread/worker/isolate is ready
        setTimeout(()=>{
            callback(undefined, handler);
        }, 100);
    });
}

module.exports.load = function(seed, identity, callback){
    const se = require("swarm-engine");
    if(typeof $$ === "undefined" || typeof $$.swarmEngine === "undefined"){
        se.initialise();
    }

    const envTypes = require("overwrite-require").constants;
    switch($$.environmentType){
        case envTypes.BROWSER_ENVIRONMENT_TYPE:
            const pc = new se.OuterWebWorkerPowerCord("path_to_boot_script", seed);
            return envSetup(pc, seed, identity, callback);
            break;
        case envTypes.NODEJS_ENVIRONMENT_TYPE:
            const pathName = "path";
            const path = require(pathName);
            const powerCord = new se.OuterThreadPowerCord(path.join(process.env.PSK_ROOT_INSTALATION_FOLDER, "psknode/bundles/threadBoot.js"), false, seed);
            return envSetup(powerCord, seed, identity, callback);
            break;
        case envTypes.WEB_WORKER_ENVIRONMENT_TYPE:
        case envTypes.SERVICE_WORKER_ENVIRONMENT_TYPE:
        case envTypes.ISOLATE_ENVIRONMENT_TYPE:
        case envTypes.THREAD_ENVIRONMENT_TYPE:
        default:
            return callback(new Error(`Dossier can not be loaded in <${$$.environmentType}> environment type for now!`));
    }
}

module.exports.RawDossier = require("./lib/RawDossier");
},{"./lib/RawDossier":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/dossier/lib/RawDossier.js","overwrite-require":"overwrite-require","pskcrypto":"pskcrypto","swarm-engine":"swarm-engine"}],"double-check":[function(require,module,exports){
/**
 * Generic function used to registers methods such as asserts, logging, etc. on the current context.
 * @param name {String)} - name of the method (use case) to be registered.
 * @param func {Function} - handler to be invoked.
 * @param paramsDescription {Object} - parameters descriptions
 * @param after {Function} - callback function to be called after the function has been executed.
 */
function addUseCase(name, func, paramsDescription, after) {
    var newFunc = func;
    if (typeof after === "function") {
        newFunc = function () {
            const args = Array.from(arguments);
            func.apply(this, args);
            after();
        };
    }

    // some properties should not be overridden
    const protectedProperties = ['addCheck', 'addCase', 'register'];
    if (protectedProperties.indexOf(name) === -1) {
        this[name] = newFunc;
    } else {
        throw new Error('Cant overwrite ' + name);
    }

    if (paramsDescription) {
        this.params[name] = paramsDescription;
    }
}

/**
 * Creates an alias to an existing function.
 * @param name1 {String} - New function name.
 * @param name2 {String} - Existing function name.
 */
function alias(name1, name2) {
    this[name1] = this[name2];
}

/**
 * Singleton for adding various functions for use cases regarding logging.
 * @constructor
 */
function LogsCore() {
    this.params = {};
}

/**
 * Singleton for adding your various functions for asserts.
 * @constructor
 */
function AssertCore() {
    this.params = {};
}

/**
 * Singleton for adding your various functions for checks.
 * @constructor
 */
function CheckCore() {
    this.params = {};
}

/**
 * Singleton for adding your various functions for generating exceptions.
 * @constructor
 */
function ExceptionsCore() {
    this.params = {};
}

/**
 * Singleton for adding your various functions for running tests.
 * @constructor
 */
function TestRunnerCore() {
}

LogsCore.prototype.addCase = addUseCase;
AssertCore.prototype.addCheck = addUseCase;
CheckCore.prototype.addCheck = addUseCase;
ExceptionsCore.prototype.register = addUseCase;

LogsCore.prototype.alias = alias;
AssertCore.prototype.alias = alias;
CheckCore.prototype.alias = alias;
ExceptionsCore.prototype.alias = alias;

// Create modules
var assertObj = new AssertCore();
var checkObj = new CheckCore();
var exceptionsObj = new ExceptionsCore();
var loggerObj = new LogsCore();
var testRunnerObj = new TestRunnerCore();

// Export modules
exports.assert = assertObj;
exports.check = checkObj;
exports.exceptions = exceptionsObj;
exports.logger = loggerObj;
exports.testRunner = testRunnerObj;

// Initialise modules
require("./standardAsserts.js").init(exports, loggerObj);
require("./standardLogs.js").init(exports);
require("./standardExceptions.js").init(exports);
require("./standardChecks.js").init(exports);
require("./runner.js").init(exports);

// Global Uncaught Exception handler.
if (process.on) {
    process.on('uncaughtException', function (err) {
        if (typeof err.isFailedAssert == "undefined") {
            exports.logger.record({
                level: 0,
                message: "double-check has intercepted an uncaught exception",
                stack: err.stack
            });
            exports.assert.forceFailedTest("Uncaught Exception!", err);
            exports.assert.end(undefined, 0, true);
        }
    });
    process.on('unhandledRejection', function(error) {
        exports.logger.record({
            level: 0,
            message: "double-check has intercepted an unhandledRejection event",
            stack: error.stack
        });
        exports.assert.forceFailedTest("Unhandled Rejection!", error);
        exports.assert.end(undefined, 0, true);
    });
}


const fs = require('fs');
const crypto = require('crypto');
const AsyncDispatcher = require('../utils/AsyncDispatcher');
const path = require('path');

function ensureFolderHierarchy(folders, callback) {
    const asyncDispatcher = new AsyncDispatcher(() => {
        callback();
    });

    if (folders.length === 0) {
        return callback();
    }

    asyncDispatcher.dispatchEmpty(folders.length);
    folders.forEach(folder => {
        fs.access(folder, (err) => {
            if (err) {
                fs.mkdir(folder, {recursive: true}, (err) => {
                    if (err) {
                        return callback(err);
                    }

                    asyncDispatcher.markOneAsFinished();
                });
            } else {
                asyncDispatcher.markOneAsFinished();
            }
        });
    });

}

function ensureFilesExist(folders, files, text, callback) {
    if (!Array.isArray(folders)) {
        folders = [folders];
    }

    if (!Array.isArray(files)) {
        files = [files];
    }

    ensureFolderHierarchy(folders, (err) => {
        if (err) {
            return callback(err);
        }

        if (files.length === 0) {
            return callback();
        }

        files.forEach((file, i) => {
            const stream = fs.createWriteStream(file);
            stream.write(text[i]);
            if (i === files.length - 1) {
                return callback();
            }
        });
    });
}


function computeFileHash(filePath, callback) {
    const readStream = fs.createReadStream(filePath);
    const hash = crypto.createHash("sha256");
    readStream.on("data", (data) => {
        hash.update(data);
    });

    readStream.on("close", () => {
        callback(undefined, hash.digest("hex"));
    });
}

function computeFoldersHashes(folders, callback) {
    if (!Array.isArray(folders)) {
        folders = [folders];
    }

    if (folders.length === 0) {
        return callback();
    }

    let hashes = [];
    const asyncDispatcher = new AsyncDispatcher(() => {
        callback(undefined, hashes);
    });

    asyncDispatcher.dispatchEmpty(folders.length);
    folders.forEach(folder => {
        __computeHashRecursively(folder, hashes, (err, hashList) => {
            if (err) {
                return callback(err);
            }

            hashes = hashes.concat(hashList);
            asyncDispatcher.markOneAsFinished();
        });
    });
}

function __computeHashRecursively(folderPath, hashes = [], callback) {
    fs.readdir(folderPath, (err, files) => {
        if (err) {
            return callback(err);
        }

        if (files.length === 0) {
            return callback(undefined, hashes);
        }

        const asyncDispatcher = new AsyncDispatcher(() => {
            callback(undefined, hashes);
        });

        asyncDispatcher.dispatchEmpty(files.length);
        files.forEach(file => {
            const tempPath = path.join(folderPath, file);
            fs.stat(tempPath, (err, stats) => {
                if (err) {
                    return callback(err);
                }

                if (stats.isFile()) {
                    computeFileHash(tempPath, (err, fileHash) => {
                        if (err) {
                            return callback(err);
                        }

                        hashes.push(fileHash);
                        asyncDispatcher.markOneAsFinished();
                    });
                } else {
                    __computeHashRecursively(tempPath, hashes, (err) => {
                        if (err) {
                            return callback(err);
                        }
                        asyncDispatcher.markOneAsFinished();
                    });
                }
            });
        });
    });
}

function deleteFolderRecursive(folderPath) {
    const removeDirSync = require("swarmutils").removeDirSync;
    removeDirSync(folderPath, {recursive: true, maxRetries: 10});
}

function deleteFoldersSync(folders) {
    if (!Array.isArray(folders)) {
        folders = [folders];
    }

    if (folders.length === 0) {
        return;
    }

    folders.forEach(folder => {
        deleteFolderRecursive(folder);
    });
}

function createTestFolder(prefix, cllback) {
    const os = require("os");
    fs.mkdtemp(path.join(os.tmpdir(), prefix), function (err, res) {
        const cleanFolder = function () {
            deleteFolderRecursive(res);
        };
        exports.assert.addCleaningFunction(cleanFolder);
        cllback(err, res);
    });
}

Object.assign(module.exports, {
    deleteFolderRecursive,
    createTestFolder,
    computeFoldersHashes,
    computeFileHash,
    ensureFilesExist,
    deleteFoldersSync
});

},{"../utils/AsyncDispatcher":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/double-check/utils/AsyncDispatcher.js","./runner.js":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/double-check/lib/runner.js","./standardAsserts.js":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/double-check/lib/standardAsserts.js","./standardChecks.js":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/double-check/lib/standardChecks.js","./standardExceptions.js":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/double-check/lib/standardExceptions.js","./standardLogs.js":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/double-check/lib/standardLogs.js","crypto":false,"fs":false,"os":false,"path":false,"swarmutils":"swarmutils"}],"dsu-wizard":[function(require,module,exports){
(function (__dirname){(function (){
function initWizard(server) {
	const transactionManager = require("./TransactionManager");

	server.post(`/dsu-wizard/:domain/begin`, (req, res)=>{
		transactionManager.beginTransaction(req, (err, transactionId)=>{
			if(err){
				res.statusCode = 500;
				return res.end();
			}
			res.write(transactionId);
			res.end();
		});
	});

	server.post(`/dsu-wizard/:domain/build/:transactionId`, (req, res)=>{
		let authorization = req.headers['authorization'];
		transactionManager.closeTransaction(req.params.transactionId, authorization,(err, result)=>{
			if(err){
				console.log(err);
				res.statusCode = 500;
				res.write(err.toString());
				return res.end();
			}
			res.write(result);
			res.end();
		});
	});

	const commands = require("./commands");
	Object.keys(commands).forEach((commandName)=>{
		commands[commandName](server);
	});

	server.use(`/dsu-wizard`, require("./utils").redirect);

	const pathName = "path";
	const path = require(pathName);
	if (!process.env.PSK_ROOT_INSTALATION_FOLDER) {
		process.env.PSK_ROOT_INSTALATION_FOLDER = require("path").resolve("." + __dirname + "/../..");
	}

	const VirtualMQ = require('apihub');
	const httpWrapper = VirtualMQ.getHttpWrapper();
	const httpUtils = httpWrapper.httpUtils;
	setTimeout(()=>{
		server.use(`/dsu-wizard/:domain/*`, httpUtils.serveStaticFile(path.join(process.env.PSK_ROOT_INSTALATION_FOLDER, 'modules/dsu-wizard/web'), `dsu-wizard/`));
	}, 1000);
}

module.exports = {
	initWizard,
	getTransactionManager : function(){
		return require("./TransactionManager");
	},
	getCommandRegistry: function(server){
		return require("./CommandRegistry").getRegistry(server);
	},
	getDummyCommand: function(){
		return require("./commands/dummyCommand");
	},
	utils: require("./utils")
}
}).call(this)}).call(this,"/modules/dsu-wizard")

},{"./CommandRegistry":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/dsu-wizard/CommandRegistry.js","./TransactionManager":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/dsu-wizard/TransactionManager.js","./commands":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/dsu-wizard/commands/index.js","./commands/dummyCommand":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/dsu-wizard/commands/dummyCommand.js","./utils":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/dsu-wizard/utils.js","apihub":"apihub","path":false}],"key-ssi-resolver":[function(require,module,exports){
const KeySSIResolver = require('./lib/KeySSIResolver');
const DSUFactory = require("./lib/DSUFactoryRegistry");

/**
 * Create a new KeySSIResolver instance and append it to
 * global object $$
 *
 * @param {object} options
 */
function initialize(options) {
    options = options || {};


    const BrickMapStrategyFactory = require("bar").BrickMapStrategyFactory;

    const brickMapStrategyFactory = new BrickMapStrategyFactory();
    const keySSIFactory = require('./lib/KeySSIs/KeySSIFactory');

    options.dsuFactory =  new DSUFactory({
        brickMapStrategyFactory,
        keySSIFactory
    });

    const keySSIResolver = new KeySSIResolver(options);

    return keySSIResolver;
}

module.exports = {
    initialize,
    KeySSIFactory: require('./lib/KeySSIs/KeySSIFactory'),
    CryptoAlgorithmsRegistry: require('./lib/CryptoAlgorithms/CryptoAlgorithmsRegistry'),
    CryptoFunctionTypes: require('./lib/CryptoAlgorithms/CryptoFunctionTypes'),
    SSITypes: require("./lib/KeySSIs/SSITypes"),
    DSUFactory: require("./lib/DSUFactoryRegistry"),
    KeySSIMixin: require('./lib/KeySSIs/KeySSIMixin'),
    CryptoAlgorithmsMixin: require('./lib/CryptoAlgorithms/CryptoAlgorithmsMixin')
};

},{"./lib/CryptoAlgorithms/CryptoAlgorithmsMixin":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/key-ssi-resolver/lib/CryptoAlgorithms/CryptoAlgorithmsMixin.js","./lib/CryptoAlgorithms/CryptoAlgorithmsRegistry":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/key-ssi-resolver/lib/CryptoAlgorithms/CryptoAlgorithmsRegistry.js","./lib/CryptoAlgorithms/CryptoFunctionTypes":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/key-ssi-resolver/lib/CryptoAlgorithms/CryptoFunctionTypes.js","./lib/DSUFactoryRegistry":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/key-ssi-resolver/lib/DSUFactoryRegistry/index.js","./lib/KeySSIResolver":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/key-ssi-resolver/lib/KeySSIResolver.js","./lib/KeySSIs/KeySSIFactory":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/key-ssi-resolver/lib/KeySSIs/KeySSIFactory.js","./lib/KeySSIs/KeySSIMixin":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/key-ssi-resolver/lib/KeySSIs/KeySSIMixin.js","./lib/KeySSIs/SSITypes":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/key-ssi-resolver/lib/KeySSIs/SSITypes.js","bar":"bar"}],"loki-enclave-facade":[function(require,module,exports){
(function (Buffer){(function (){
const loki = require("./lib/lokijs/src/lokijs.js");
const lfsa = require("./lib/lokijs/src/loki-fs-sync-adapter.js");
// const lfssa = require("./lib/lokijs/src/loki-fs-structured-adapter");

const TABLE_NOT_FOUND_ERROR_CODE = 100;
const adapter = new lfsa();

let filterOperationsMap = {
    "!=": "$ne",
    "==": "$aeq",
    ">": "$jgt",
    ">=": "$jgte",
    "<": "$jlt",
    "<=": "$jlte",
    "like": "$regex"
}

function LokiEnclaveFacade(rootFolder, autosaveInterval) {
    const openDSU = require("opendsu");
    const keySSISpace = openDSU.loadAPI("keyssi")
    const w3cDID = openDSU.loadAPI("w3cdid")
    const utils = openDSU.loadAPI("utils");
    const CryptoSkills = w3cDID.CryptographicSkills;
    const logger = $$.getLogger("LokiEnclaveFacade", "lokiEnclaveFacade");
    const DEFAULT_NAME = "LokiEnclaveFacade";
    const path = require("path");
    const KEY_SSIS_TABLE = "keyssis";
    const SEED_SSIS_TABLE = "seedssis";
    const DIDS_PRIVATE_KEYS = "dids_private";
    const AUTOSAVE_INTERVAL = 100;
    autosaveInterval = autosaveInterval || AUTOSAVE_INTERVAL;
    if (typeof rootFolder === "undefined") {
        throw Error("Root folder was not specified for LokiEnclaveFacade");
    }
    let db = new loki(rootFolder, {
        adapter: adapter,
        autoload: true,
        autoloadCallback: initialized.bind(this),
        autosave: true,
        autosaveInterval: autosaveInterval,
        autosaveCallback: function (err) {
            if (err) {
                logger.error(`Failed to save db on disk.`)
            }
        }
    });

    this.refresh = function (callback) {
        db.loadDatabaseInternal(undefined, callback);
    }

    this.count = function (tableName, callback) {
        let table = db.getCollection(tableName);
        if (!table) {
            return callback(createOpenDSUErrorWrapper(`Table ${tableName} not found`))
        }
        let result;
        try {
            result = table.count();
        } catch (err) {
            return callback(createOpenDSUErrorWrapper(`Could not count on ${tableName}`, err))
        }

        callback(null, result)
    }

    this.getCollections = function () {
        return db.listCollections().map(collection => {
            return collection.name
        })
    }

    this.insertRecord = function (forDID, tableName, pk, record, callback) {
        let table = db.getCollection(tableName) || db.addCollection(tableName);
        const foundRecord = table.findOne({ 'pk': pk });
        if (foundRecord) {
            return callback(createOpenDSUErrorWrapper(`A record with pk ${pk} already exists in ${tableName}`))
        }
        let result;
        try {
            result = table.insert({ "pk": pk, ...record, "did": forDID, "__timestamp": Date.now() });
        } catch (err) {
            return callback(createOpenDSUErrorWrapper(` Could not insert record in table ${tableName} `, err))
        }

        callback(null, result);
    }

    this.updateRecord = function (forDID, tableName, pk, record, callback) {
        let table = db.getCollection(tableName);
        const doc = table.by("pk", pk);
        for (let prop in record) {
            doc[prop] = record[prop];
        }
        let result;
        try {
            result = table.update(doc);
        } catch (err) {
            return callback(createOpenDSUErrorWrapper(` Could not insert record in table ${tableName} `, err));
        }

        callback(null, result);
    }

    this.deleteRecord = function (forDID, tableName, pk, callback) {
        let table = db.getCollection(tableName);
        if (!table) {
            return callback();
        }
        const record = table.findOne({ 'pk': pk });
        if (!record) {
            return callback(createOpenDSUErrorWrapper(`Couldn't find a record for pk ${pk} in ${tableName}`))
        }
        let result;
        try {
            result = table.remove(record);
        } catch (err) {
            return callback(createOpenDSUErrorWrapper(`Couldn't do remove for pk ${pk} in ${tableName}`, err))
        }

        callback(null, result);
    }

    this.getRecord = function (forDID, tableName, pk, callback) {
        let table = db.getCollection(tableName);
        if (!table) {
            return callback();
        }
        let result;
        try {
            result = table.findObject({ 'pk': pk });
        } catch (err) {
            return callback(createOpenDSUErrorWrapper(`Could not find object with pk ${pk}`, err));
        }

        callback(null, result)
    }

    function __parseQuery(filterConditions) {
        let lokiQuery = {}
        if (!filterConditions) {
            return lokiQuery;
        }

        filterConditions.forEach(condition => {
            const splitCondition = condition.split(" ");
            const field = splitCondition[0];
            const operator = splitCondition[1];
            const value = splitCondition[2];
            lokiQuery[field] = {};
            lokiQuery[field][`${filterOperationsMap[operator]}`] = value;
        })
        return lokiQuery;
    }

    function __getSortingField(filterConditions) {
        let sortingField = "__timestamp";
        if (filterConditions && filterConditions.length) {
            const splitCondition = filterConditions[0].split(" ");
            sortingField = splitCondition[0];
        }

        return sortingField;
    }

    this.filter = function (forDID, tableName, filterConditions, sort, max, callback) {
        if (typeof filterConditions === "string") {
            filterConditions = [filterConditions];
        }

        if (typeof filterConditions === "function") {
            callback = filterConditions;
            filterConditions = undefined;
            sort = "asc";
            max = Infinity;
        }

        if (typeof sort === "function") {
            callback = sort;
            sort = "asc";
            max = Infinity;
        }

        if (typeof max === "function") {
            callback = max;
            max = Infinity;
        }

        if (!max) {
            max = Infinity;
        }

        const sortingField = __getSortingField(filterConditions);
        filterConditions = __parseQuery(filterConditions);

        let table = db.getCollection(tableName);
        if (!table) {
            const err = Error(`Table ${tableName} does not exist.`);
            err.code = 404;
            return callback(err);
        }
        let direction = false;
        if (sort === "desc") {
            direction = true;
        }

        let result;
        try {
            result = table.chain().find(filterConditions).simplesort(sortingField, direction).limit(max).data();
        } catch (err) {
            return callback(createOpenDSUErrorWrapper(`Filter operation failed on ${tableName}`, err));
        }


        callback(null, result);
    }

    this.getAllRecords = (forDID, tableName, callback) => {
        let table = db.getCollection(tableName);
        if (!table) {
            return callback();
        }

        let results;
        try {
            results = table.find();
        } catch (err) {
            return callback(createOpenDSUErrorWrapper(`Filter operation failed on ${tableName}`, err));
        }

        callback(null, results);
    };

    utils.bindAutoPendingFunctions(this);

    const READ_WRITE_KEY_TABLE = "KeyValueTable";

    this.writeKey = (forDID, key, value, callback) => {
        let valueObject = {
            type: typeof value,
            value: value
        };

        if (typeof value === "object") {
            if (Buffer.isBuffer(value)) {
                valueObject = {
                    type: "buffer",
                    value: value.toString()
                }
            } else {
                valueObject = {
                    type: "object",
                    value: JSON.stringify(value)
                }
            }
        }
        this.insertRecord(forDID, READ_WRITE_KEY_TABLE, key, valueObject, callback);
    }

    this.readKey = (forDID, key, callback) => {
        this.getRecord(forDID, READ_WRITE_KEY_TABLE, key, (err, record) => {
            if (err) {
                return callback(createOpenDSUErrorWrapper(`Failed to read key ${key}`, err));
            }

            callback(undefined, record);
        })
    }

    //------------------ queue -----------------
    let self = this;
    this.addInQueue = function (forDID, queueName, encryptedObject, callback) {
        let queue = db.getCollection(queueName) || db.addCollection(queueName);
        const crypto = require("opendsu").loadApi("crypto");
        const hash = crypto.sha256(encryptedObject);
        self.insertRecord(forDID, queueName, hash, encryptedObject, callback);
    }

    this.queueSize = function (forDID, queueName, callback) {
        self.count(queueName, callback);
    }

    this.listQueue = function (forDID, queueName, sortAfterInsertTime, onlyFirstN, callback) {

        if (typeof sortAfterInsertTime === "function") {
            callback = sortAfterInsertTime;
            sortAfterInsertTime = "asc";
            onlyFirstN = undefined
        }
        if (typeof onlyFirstN === "function") {
            callback = onlyFirstN;
            onlyFirstN = undefined;
        }

        self.filter(forDID, queueName, undefined, sortAfterInsertTime, onlyFirstN, (err, result) => {
            if (err) {
                return callback(err);
            }

            result = result.map(item => {
                return item.pk
            })
            return callback(null, result);
        })
    }

    this.getObjectFromQueue = function (forDID, queueName, hash, callback) {
        return self.getRecord(forDID, queueName, hash, callback)
    }

    this.deleteObjectFromQueue = function (forDID, queueName, hash, callback) {
        return self.deleteRecord(forDID, queueName, hash, callback)
    }

    //------------------ KeySSIs -----------------
    const getCapableOfSigningKeySSI = (keySSI, callback) => {
        if (typeof keySSI === "undefined") {
            return callback(Error(`A SeedSSI should be specified.`));
        }

        if (typeof keySSI === "string") {
            try {
                keySSI = keySSISpace.parse(keySSI);
            } catch (e) {
                return callback(createOpenDSUErrorWrapper(`Failed to parse keySSI ${keySSI}`, e))
            }
        }

        this.getRecord(undefined, KEY_SSIS_TABLE, keySSI.getIdentifier(), (err, record) => {
            if (err) {
                return callback(createOpenDSUErrorWrapper(`No capable of signing keySSI found for keySSI ${keySSI.getIdentifier()}`, err));
            }

            let capableOfSigningKeySSI;
            try {
                capableOfSigningKeySSI = keySSISpace.parse(record.capableOfSigningKeySSI);
            } catch (e) {
                return callback(createOpenDSUErrorWrapper(`Failed to parse keySSI ${record.capableOfSigningKeySSI}`, e))
            }

            callback(undefined, capableOfSigningKeySSI);
        });
    };

    this.storeSeedSSI = (forDID, seedSSI, alias, callback) => {
        if (typeof seedSSI === "string") {
            try {
                seedSSI = keySSISpace.parse(seedSSI);
            } catch (e) {
                return callback(createOpenDSUErrorWrapper(`Failed to parse keySSI ${seedSSI}`, e))
            }
        }

        const keySSIIdentifier = seedSSI.getIdentifier();

        const registerDerivedKeySSIs = (derivedKeySSI) => {
            this.insertRecord(forDID, KEY_SSIS_TABLE, derivedKeySSI.getIdentifier(), { capableOfSigningKeySSI: keySSIIdentifier }, (err) => {
                if (err) {
                    return callback(err);
                }

                try {
                    derivedKeySSI = derivedKeySSI.derive();
                } catch (e) {
                    return callback();
                }

                registerDerivedKeySSIs(derivedKeySSI);
            });
        }

        this.insertRecord(forDID, SEED_SSIS_TABLE, alias, { seedSSI: keySSIIdentifier }, (err) => {
            if (err) {
                return callback(err);
            }

            return registerDerivedKeySSIs(seedSSI);
        })
    }

    this.signForKeySSI = (forDID, keySSI, hash, callback) => {
        getCapableOfSigningKeySSI(keySSI, (err, capableOfSigningKeySSI) => {
            if (err) {
                return callback(err);
            }
            if (typeof capableOfSigningKeySSI === "undefined") {
                return callback(Error(`The provided SSI does not grant writing rights`));
            }

            capableOfSigningKeySSI.sign(hash, callback);
        });
    }

    //------------------ DIDs -----------------
    const getPrivateInfoForDID = (did, callback) => {
        this.getRecord(undefined, DIDS_PRIVATE_KEYS, did, (err, record) => {
            if (err) {
                return callback(err);
            }

            const privateKeysAsBuff = record.privateKeys.map(privateKey => {
                if (privateKey) {
                    return $$.Buffer.from(privateKey)
                }

                return privateKey;
            });
            callback(undefined, privateKeysAsBuff);
        });
    };

    const __ensureAreDIDDocumentsThenExecute = (did, fn, callback) => {
        if (typeof did === "string") {
            return w3cDID.resolveDID(did, (err, didDocument) => {
                if (err) {
                    return callback(err);
                }

                fn(didDocument, callback);
            })
        }

        fn(did, callback);
    }

    this.storeDID = (forDID, storedDID, privateKeys, callback) => {
        this.getRecord(forDID, DIDS_PRIVATE_KEYS, storedDID, (err, res) => {
            if (err || !res) {
                return this.insertRecord(forDID, DIDS_PRIVATE_KEYS, storedDID, { privateKeys: privateKeys }, callback);
            }

            privateKeys.forEach(privateKey => {
                res.privateKeys.push(privateKey);
            })
            this.updateRecord(forDID, DIDS_PRIVATE_KEYS, storedDID, res, callback);
        });
    }

    this.signForDID = (forDID, didThatIsSigning, hash, callback) => {
        const __signForDID = (didThatIsSigning, callback) => {
            getPrivateInfoForDID(didThatIsSigning.getIdentifier(), (err, privateKeys) => {
                if (err) {
                    return callback(createOpenDSUErrorWrapper(`Failed to get private info for did ${didThatIsSigning.getIdentifier()}`, err));
                }

                const signature = CryptoSkills.applySkill(didThatIsSigning.getMethodName(), CryptoSkills.NAMES.SIGN, hash, privateKeys[privateKeys.length - 1]);
                callback(undefined, signature);
            });
        }

        __ensureAreDIDDocumentsThenExecute(didThatIsSigning, __signForDID, callback);
    }

    this.verifyForDID = (forDID, didThatIsVerifying, hash, signature, callback) => {
        const __verifyForDID = (didThatIsVerifying, callback) => {
            didThatIsVerifying.getPublicKey("pem", (err, publicKey) => {
                if (err) {
                    return callback(createOpenDSUErrorWrapper(`Failed to read public key for did ${didThatIsVerifying.getIdentifier()}`, err));
                }

                const verificationResult = CryptoSkills.applySkill(didThatIsVerifying.getMethodName(), CryptoSkills.NAMES.VERIFY, hash, publicKey, $$.Buffer.from(signature));
                callback(undefined, verificationResult);
            });
        }

        __ensureAreDIDDocumentsThenExecute(didThatIsVerifying, __verifyForDID, callback);
    }

    this.encryptMessage = (forDID, didFrom, didTo, message, callback) => {
        const __encryptMessage = () => {
            getPrivateInfoForDID(didFrom.getIdentifier(), (err, privateKeys) => {
                if (err) {
                    return callback(createOpenDSUErrorWrapper(`Failed to get private info for did ${didFrom.getIdentifier()}`, err));
                }

                CryptoSkills.applySkill(didFrom.getMethodName(), CryptoSkills.NAMES.ENCRYPT_MESSAGE, privateKeys, didFrom, didTo, message, callback);
            });
        }
        if (typeof didFrom === "string") {
            w3cDID.resolveDID(didFrom, (err, didDocument) => {
                if (err) {
                    return callback(err);
                }

                didFrom = didDocument;


                if (typeof didTo === "string") {
                    w3cDID.resolveDID(didTo, (err, didDocument) => {
                        if (err) {
                            return callback(err);
                        }

                        didTo = didDocument;
                        __encryptMessage();
                    })
                } else {
                    __encryptMessage();
                }
            })
        } else {
            __encryptMessage();
        }
    }

    this.decryptMessage = (forDID, didTo, encryptedMessage, callback) => {
        const __decryptMessage = (didTo, callback) => {
            getPrivateInfoForDID(didTo.getIdentifier(), (err, privateKeys) => {
                if (err) {
                    return callback(createOpenDSUErrorWrapper(`Failed to get private info for did ${didTo.getIdentifier()}`, err));
                }

                CryptoSkills.applySkill(didTo.getMethodName(), CryptoSkills.NAMES.DECRYPT_MESSAGE, privateKeys, didTo, encryptedMessage, callback);
            });
        }
        __ensureAreDIDDocumentsThenExecute(didTo, __decryptMessage, callback);
    };
}

function initialized() {
    this.finishInitialisation();
}

module.exports = LokiEnclaveFacade;
}).call(this)}).call(this,{"isBuffer":require("../../node_modules/is-buffer/index.js")})

},{"../../node_modules/is-buffer/index.js":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/node_modules/is-buffer/index.js","./lib/lokijs/src/loki-fs-sync-adapter.js":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/loki-enclave-facade/lib/lokijs/src/loki-fs-sync-adapter.js","./lib/lokijs/src/lokijs.js":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/loki-enclave-facade/lib/lokijs/src/lokijs.js","opendsu":"opendsu","path":false}],"opendsu":[function(require,module,exports){
(function (global){(function (){
/*
html API space
*/

let constants = require("./moduleConstants.js");

switch ($$.environmentType) {
    case constants.ENVIRONMENT_TYPES.WEB_WORKER_ENVIRONMENT_TYPE:
    case constants.ENVIRONMENT_TYPES.SERVICE_WORKER_ENVIRONMENT_TYPE:
        if (typeof self !== "undefined") {
            if(!self.PREVENT_DOUBLE_LOADING_OF_OPENDSU) {
                self.PREVENT_DOUBLE_LOADING_OF_OPENDSU = {}
            }
        }
        break;
    case constants.ENVIRONMENT_TYPES.BROWSER_ENVIRONMENT_TYPE:
        if (typeof window !== "undefined") {
            if(!window.PREVENT_DOUBLE_LOADING_OF_OPENDSU){
                window.PREVENT_DOUBLE_LOADING_OF_OPENDSU = {}
            }
        }
        break;
    case constants.ENVIRONMENT_TYPES.NODEJS_ENVIRONMENT_TYPE:
    default:
        if (typeof global !== "undefined") {
            if(!global.PREVENT_DOUBLE_LOADING_OF_OPENDSU){
                global.PREVENT_DOUBLE_LOADING_OF_OPENDSU = {}
            }
        }
}

if(!PREVENT_DOUBLE_LOADING_OF_OPENDSU.INITIALISED){
    PREVENT_DOUBLE_LOADING_OF_OPENDSU.INITIALISED = true;
    function loadApi(apiSpaceName){
        switch (apiSpaceName) {
            case "http":return require("./http"); break;
            case "crypto":return require("./crypto"); break;
            case "anchoring":return require("./anchoring"); break;
            case "contracts":return require("./contracts"); break;
            case "bricking":return require("./bricking"); break;
            case "bdns":return require("./bdns"); break;
            case "boot":return require("./boot"); break;
            case "dc":return require("./dc"); break;
            case "dt":return require("./dt"); break;
            case "enclave":return require("./enclave"); break;
            case "keyssi":return require("./keyssi"); break;
            case "mq":return require("./mq/mqClient"); break;
            case "notifications":return require("./notifications"); break;
            case "oauth":return require("./oauth"); break;
            case "resolver":return require("./resolver"); break;
            case "sc":return require("./sc"); break;
            case "cache":return require("./cache"); break;
            case "config":return require("./config"); break;
            case "system":return require("./system"); break;
            case "utils":return require("./utils"); break;
            case "db":return require("./db"); break;
            case "w3cdid":return require("./w3cdid"); break;
            case "error":return require("./error"); break;
            case "m2dsu":return require("./m2dsu"); break;
            case "workers":return require("./workers"); break;
            case "storage": return require("./storage"); break;
            case "credentials": return require("./credentials"); break;
            default: throw new Error("Unknown API space " + apiSpaceName);
        }
    }

     function setGlobalVariable(name, value){
        switch ($$.environmentType) {
            case constants.ENVIRONMENT_TYPES.WEB_WORKER_ENVIRONMENT_TYPE:
            case constants.ENVIRONMENT_TYPES.SERVICE_WORKER_ENVIRONMENT_TYPE:
                if (typeof self !== "undefined") {
                    self[name] = value;
                } else {
                    reportUserRelevantError("self not defined in Service Workers");
                }
                break;
            case constants.ENVIRONMENT_TYPES.BROWSER_ENVIRONMENT_TYPE:
                if (typeof window !== "undefined") {
                    window[name] = value;
                } else {
                    reportUserRelevantError("window not defined in browser environment");
                }
                break;
            case constants.ENVIRONMENT_TYPES.NODEJS_ENVIRONMENT_TYPE:
            default:
                if (typeof global !== "undefined") {
                    global[name] = value;
                } else {
                    reportUserRelevantError("global not defined in nodejs environment");
                }
        }
    };

    function getGlobalVariable(name){
        switch ($$.environmentType) {
            case constants.ENVIRONMENT_TYPES.WEB_WORKER_ENVIRONMENT_TYPE:
            case constants.ENVIRONMENT_TYPES.SERVICE_WORKER_ENVIRONMENT_TYPE:
                return self[name];
            case constants.ENVIRONMENT_TYPES.BROWSER_ENVIRONMENT_TYPE:
                return window[name];
            case constants.ENVIRONMENT_TYPES.NODEJS_ENVIRONMENT_TYPE:
            default:
                return global[name];
        }
    };

    function globalVariableExists(name){
        switch ($$.environmentType) {
            case constants.ENVIRONMENT_TYPES.WEB_WORKER_ENVIRONMENT_TYPE:
            case constants.ENVIRONMENT_TYPES.SERVICE_WORKER_ENVIRONMENT_TYPE:
                return typeof self[name] != "undefined";
            case constants.ENVIRONMENT_TYPES.BROWSER_ENVIRONMENT_TYPE:
                return typeof window[name] != "undefined";
            case constants.ENVIRONMENT_TYPES.NODEJS_ENVIRONMENT_TYPE:
            default:
                return typeof global[name] != "undefined";
        }
    };

    PREVENT_DOUBLE_LOADING_OF_OPENDSU.loadApi = loadApi;
    PREVENT_DOUBLE_LOADING_OF_OPENDSU.loadAPI = loadApi; //upper case version just
    PREVENT_DOUBLE_LOADING_OF_OPENDSU.globalVariableExists = setGlobalVariable;
    PREVENT_DOUBLE_LOADING_OF_OPENDSU.setGlobalVariable = setGlobalVariable;
    PREVENT_DOUBLE_LOADING_OF_OPENDSU.getGlobalVariable = getGlobalVariable;
    PREVENT_DOUBLE_LOADING_OF_OPENDSU.constants = constants;
    setGlobalVariable("setGlobalVariable",setGlobalVariable);
    setGlobalVariable("getGlobalVariable",getGlobalVariable);
    setGlobalVariable("globalVariableExists",globalVariableExists);
    require("./config/autoConfig");
}
module.exports = PREVENT_DOUBLE_LOADING_OF_OPENDSU;


}).call(this)}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./anchoring":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/anchoring/index.js","./bdns":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/bdns/index.js","./boot":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/boot/index.js","./bricking":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/bricking/index.js","./cache":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/cache/index.js","./config":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/config/index.js","./config/autoConfig":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/config/autoConfig.js","./contracts":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/contracts/index.js","./credentials":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/credentials/index.js","./crypto":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/crypto/index.js","./db":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/db/index.js","./dc":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/dc/index.js","./dt":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/dt/index.js","./enclave":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/enclave/index.js","./error":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/error/index.js","./http":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/http/index.js","./keyssi":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/keyssi/index.js","./m2dsu":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/m2dsu/index.js","./moduleConstants.js":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/moduleConstants.js","./mq/mqClient":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/mq/mqClient.js","./notifications":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/notifications/index.js","./oauth":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/oauth/index.js","./resolver":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/resolver/index.js","./sc":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/sc/index.js","./storage":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/storage/index.js","./system":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/system/index.js","./utils":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/utils/index.js","./w3cdid":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/w3cdid/index.js","./workers":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/opendsu/workers/index.js"}],"overwrite-require":[function(require,module,exports){
(function (global){(function (){
/*
 require and $$.require are overwriting the node.js defaults in loading modules for increasing security, speed and making it work to the privatesky runtime build with browserify.
 The privatesky code for domains should work in node and browsers.
 */
function enableForEnvironment(envType){

    const moduleConstants = require("./moduleConstants");

    /**
     * Used to provide autocomplete for $$ variables
     * @classdesc Interface for $$ object
     *
     * @name $$
     * @class
     *
     */

    switch (envType) {
        case moduleConstants.BROWSER_ENVIRONMENT_TYPE :
            global = window;
            break;
        case moduleConstants.WEB_WORKER_ENVIRONMENT_TYPE:
        case moduleConstants.SERVICE_WORKER_ENVIRONMENT_TYPE:
            global = self;
            break;
        default:
            Error.stackTraceLimit = Infinity;
    }

    if (typeof(global.$$) == "undefined") {
        /**
         * Used to provide autocomplete for $$ variables
         * @type {$$}
         */
        global.$$ = {};
    }

    if (typeof($$.__global) == "undefined") {
        $$.__global = {};
    }

    if (typeof global.wprint === "undefined") {
        global.wprint = console.warn;
    }
    Object.defineProperty($$, "environmentType", {
        get: function(){
            return envType;
        },
        set: function (value) {
            throw Error(`Trying to set env value: ${value}. Environment type already set!`);
        }
    });


    if (typeof($$.__global.requireLibrariesNames) == "undefined") {
        $$.__global.currentLibraryName = null;
        $$.__global.requireLibrariesNames = {};
    }


    if (typeof($$.__runtimeModules) == "undefined") {
        $$.__runtimeModules = {};
    }


    if (typeof(global.functionUndefined) == "undefined") {
        global.functionUndefined = function () {
            console.log("Called of an undefined function!!!!");
            throw new Error("Called of an undefined function");
        };
        if (typeof(global.webshimsRequire) == "undefined") {
            global.webshimsRequire = global.functionUndefined;
        }

        if (typeof(global.domainRequire) == "undefined") {
            global.domainRequire = global.functionUndefined;
        }

        if (typeof(global.pskruntimeRequire) == "undefined") {
            global.pskruntimeRequire = global.functionUndefined;
        }
    }

    const pastRequests = {};

    function preventRecursiveRequire(request) {
        if (pastRequests[request]) {
            const err = new Error("Preventing recursive require for " + request);
            err.type = "PSKIgnorableError";
            throw err;
        }

    }

    function disableRequire(request) {
        pastRequests[request] = true;
    }

    function enableRequire(request) {
        pastRequests[request] = false;
    }

    function requireFromCache(request) {
        return $$.__runtimeModules[request];
    }

    $$.__registerModule = function (name, module) {
        $$.__runtimeModules[name] = module;
    }

    $$.getLogger = require("./Logger").getLogger;

    function wrapStep(callbackName) {
        const callback = global[callbackName];

        if (callback === undefined) {
            return null;
        }

        if (callback === global.functionUndefined) {
            return null;
        }

        return function (request) {
            const result = callback(request);
            $$.__runtimeModules[request] = result;
            return result;
        }
    }


    function tryRequireSequence(originalRequire, request) {
        let arr;
        if (originalRequire) {
            arr = $$.__requireFunctionsChain.slice();
            arr.push(originalRequire);
        } else {
            arr = $$.__requireFunctionsChain;
        }

        preventRecursiveRequire(request);
        disableRequire(request);
        let result;
        const previousRequire = $$.__global.currentLibraryName;
        let previousRequireChanged = false;

        if (!previousRequire) {
            // console.log("Loading library for require", request);
            $$.__global.currentLibraryName = request;

            if (typeof $$.__global.requireLibrariesNames[request] == "undefined") {
                $$.__global.requireLibrariesNames[request] = {};
                //$$.__global.requireLibrariesDescriptions[request]   = {};
            }
            previousRequireChanged = true;
        }
        for (let i = 0; i < arr.length; i++) {
            const func = arr[i];
            try {

                if (func === global.functionUndefined) continue;
                result = func(request);

                if (result) {
                    break;
                }

            } catch (err) {
                if (err.type !== "PSKIgnorableError") {
                    if(err instanceof SyntaxError){
                        console.error(err);
                    } else{
                        if(request === 'zeromq'){
                            console.warn("Failed to load module ", request," with error:", err.message);
                        }else{
                            console.error("Failed to load module ", request," with error:", err);
                        }
                    }
                    //$$.err("Require encountered an error while loading ", request, "\nCause:\n", err.stack);
                }
            }
        }

        if (!result) {
            throw Error(`Failed to load module ${request}`);
        }

        enableRequire(request);
        if (previousRequireChanged) {
            //console.log("End loading library for require", request, $$.__global.requireLibrariesNames[request]);
            $$.__global.currentLibraryName = null;
        }
        return result;
    }

    function makeBrowserRequire(){
        console.log("Defining global require in browser");


        global.require = function (request) {

            ///*[requireFromCache, wrapStep(webshimsRequire), , wrapStep(pskruntimeRequire), wrapStep(domainRequire)*]
            return tryRequireSequence(null, request);
        }
    }

    function makeIsolateRequire(){
        // require should be provided when code is loaded in browserify
        //const bundleRequire = require;

        $$.requireBundle('sandboxBase');
        // this should be set up by sandbox prior to
        const sandboxRequire = global.require;
        const cryptoModuleName = 'crypto';
        global.crypto = require(cryptoModuleName);

        function newLoader(request) {
            // console.log("newLoader:", request);
            //preventRecursiveRequire(request);
            const self = this;

            // console.log('trying to load ', request);

            function tryBundleRequire(...args) {
                //return $$.__originalRequire.apply(self,args);
                //return Module._load.apply(self,args)
                let res;
                try {
                    res = sandboxRequire.apply(self, args);
                } catch (err) {
                    if (err.code === "MODULE_NOT_FOUND") {
                        const p = path.join(process.cwd(), request);
                        res = sandboxRequire.apply(self, [p]);
                        request = p;
                    } else {
                        throw err;
                    }
                }
                return res;
            }

            let res;


            res = tryRequireSequence(tryBundleRequire, request);


            return res;
        }

        global.require = newLoader;
    }

    function makeNodeJSRequire(){
        const pathModuleName = 'path';
        const path = require(pathModuleName);
        const cryptoModuleName = 'crypto';
        const utilModuleName = 'util';
        $$.__runtimeModules["crypto"] = require(cryptoModuleName);
        $$.__runtimeModules["util"] = require(utilModuleName);

        const moduleModuleName = 'module';
        const Module = require(moduleModuleName);
        $$.__runtimeModules["module"] = Module;

        console.log("Redefining require for node");

        $$.__originalRequire = Module._load;
        const moduleOriginalRequire = Module.prototype.require;

        function newLoader(request) {
            // console.log("newLoader:", request);
            //preventRecursiveRequire(request);
            const self = this;

            function originalRequire(...args) {
                //return $$.__originalRequire.apply(self,args);
                //return Module._load.apply(self,args)
                let res;
                try {
                    res = moduleOriginalRequire.apply(self, args);
                } catch (err) {
                    if (err.code === "MODULE_NOT_FOUND") {
                        let pathOrName = request;
                        if(pathOrName.startsWith('/') || pathOrName.startsWith('./') || pathOrName.startsWith('../')){
                            pathOrName = path.join(process.cwd(), request);
                        }
                        res = moduleOriginalRequire.call(self, pathOrName);
                        request = pathOrName;
                    } else {
                        throw err;
                    }
                }
                return res;
            }

            //[requireFromCache, wrapStep(pskruntimeRequire), wrapStep(domainRequire), originalRequire]
            return tryRequireSequence(originalRequire, request);
        }

        Module.prototype.require = newLoader;
        return newLoader;
    }

    require("./standardGlobalSymbols.js");

    if (typeof($$.require) == "undefined") {

        $$.__requireList = ["webshimsRequire"];
        $$.__requireFunctionsChain = [];

        $$.requireBundle = function (name) {
            name += "Require";
            $$.__requireList.push(name);
            const arr = [requireFromCache];
            $$.__requireList.forEach(function (item) {
                const callback = wrapStep(item);
                if (callback) {
                    arr.push(callback);
                }
            });

            $$.__requireFunctionsChain = arr;
        };

        $$.requireBundle("init");

        switch ($$.environmentType) {
            case moduleConstants.BROWSER_ENVIRONMENT_TYPE:
                makeBrowserRequire();
                $$.require = require;
                let possibleRedirects = [301, 302];
                $$.httpUnknownResponseGlobalHandler = function(res){
                    console.log("Global handler for unknown http errors was called", res.status, res);
                    if(possibleRedirects.indexOf(res.status)!==-1){
                        window.location = "/";
                        return;
                    }
                };
                break;
            case moduleConstants.WEB_WORKER_ENVIRONMENT_TYPE:
                makeBrowserRequire();
                $$.require = require;
                break;
            case moduleConstants.SERVICE_WORKER_ENVIRONMENT_TYPE:
                makeBrowserRequire();
                $$.require = require;
                break;
            case moduleConstants.ISOLATE_ENVIRONMENT_TYPE:
                makeIsolateRequire();
                $$.require = require;
                break;
            default:
               $$.require = makeNodeJSRequire();
        }

    }

    $$.promisify = function promisify(fn, instance) {
        const promisifiedFn = function (...args) {
            return new Promise((resolve, reject) => {
                if (instance) {
                    fn = fn.bind(instance);
                }
                fn(...args, (err, ...res) => {
                    if (err) {
                        reject(err);
                    } else {
                        resolve(...res);
                    }
                });
            });
        };
        if (promisifiedFn.toString() === fn.toString()) {
            console.log("Function already promisified");
            return fn;
        }
        return promisifiedFn;
    };

    $$.makeSaneCallback = function makeSaneCallback(fn) {
        let alreadyCalled = false;
        let prevErr;
        if(fn.alreadyWrapped){
            return fn;
        }

        const newFn = (err, res, ...args) => {
            if (alreadyCalled) {
                if (err) {
                    console.log('Sane callback error:', err);
                }

                throw new Error(`Callback called 2 times! Second call was stopped. Function code:\n${fn.toString()}\n` + (prevErr ? `Previous error stack ${prevErr.toString()}` : ''));
            }
            alreadyCalled = true;
            if(err){
                prevErr = err;
            }
            return fn(err, res, ...args);
        };

        newFn.alreadyWrapped = true;
        return newFn;
    };
}



module.exports = {
    enableForEnvironment,
    constants: require("./moduleConstants")
};

}).call(this)}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./Logger":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/overwrite-require/Logger.js","./moduleConstants":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/overwrite-require/moduleConstants.js","./standardGlobalSymbols.js":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/overwrite-require/standardGlobalSymbols.js"}],"psk-cache":[function(require,module,exports){
const Cache = require("./lib/Cache")
let cacheInstance;

module.exports = {

    /**
     * Create a new cache instance
     *
     * @param {object} options
     * @param {Number} options.maxLevels Number of storage levels. Defaults to 3
     * @param {Number} options.limit Number of max items the cache can store per level.
     *                               Defaults to 1000
     * @return {Cache}
     */
    factory: function (options) {
        return new Cache(options);
    },

    /**
     * Get a reference to a singleton cache instance
     *
     * @param {object} options
     * @param {Number} options.maxLevels Number of storage levels. Defaults to 3
     * @param {Number} options.limit Number of max items the cache can store per level.
     *                               Defaults to 1000
     * @return {Cache}
     */
    getDefaultInstance: function (options) {
        if (!cacheInstance) {
            cacheInstance = new Cache(options);
        }

        return cacheInstance;
    }
};

},{"./lib/Cache":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/psk-cache/lib/Cache.js"}],"pskcrypto":[function(require,module,exports){
const PskCrypto = require("./lib/PskCrypto");
const ssutil = require("./signsensusDS/ssutil");

module.exports = PskCrypto;

module.exports.hashValues = ssutil.hashValues;

module.exports.DuplexStream = require("./lib/utils/DuplexStream");

module.exports.isStream = require("./lib/utils/isStream");
},{"./lib/PskCrypto":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/pskcrypto/lib/PskCrypto.js","./lib/utils/DuplexStream":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/pskcrypto/lib/utils/DuplexStream.js","./lib/utils/isStream":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/pskcrypto/lib/utils/isStream.js","./signsensusDS/ssutil":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/pskcrypto/signsensusDS/ssutil.js"}],"queue":[function(require,module,exports){
function QueueElement(content) {
	this.content = content;
	this.next = null;
}

function Queue() {
	this.head = null;
	this.tail = null;
	this.length = 0;
	this.push = function (value) {
		const newElement = new QueueElement(value);
		if (!this.head) {
			this.head = newElement;
			this.tail = newElement;
		} else {
			this.tail.next = newElement;
			this.tail = newElement;
		}
		this.length++;
	};

	this.pop = function () {
		if (!this.head) {
			return null;
		}
		const headCopy = this.head;
		this.head = this.head.next;
		this.length--;

		//fix???????
		if(this.length === 0){
            this.tail = null;
		}

		return headCopy.content;
	};

	this.front = function () {
		return this.head ? this.head.content : undefined;
	};

	this.isEmpty = function () {
		return this.head === null;
	};

	this[Symbol.iterator] = function* () {
		let head = this.head;
		while(head !== null) {
			yield head.content;
			head = head.next;
		}
	}.bind(this);
}

Queue.prototype.toString = function () {
	let stringifiedQueue = '';
	let iterator = this.head;
	while (iterator) {
		stringifiedQueue += `${JSON.stringify(iterator.content)} `;
		iterator = iterator.next;
	}
	return stringifiedQueue;
};

Queue.prototype.inspect = Queue.prototype.toString;

module.exports = Queue;

},{}],"soundpubsub":[function(require,module,exports){
module.exports = {
					soundPubSub: require("./lib/soundPubSub").soundPubSub
};
},{"./lib/soundPubSub":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/soundpubsub/lib/soundPubSub.js"}],"swarm-engine":[function(require,module,exports){
module.exports = {
    initialise:function(...args){
        if(typeof $$.swarmEngine === "undefined"){
            const SwarmEngine = require('./SwarmEngine');
            $$.swarmEngine = new SwarmEngine(...args);
        }else{
            $$.throw("Swarm engine already initialized!");
        }
    },
    OuterIsolatePowerCord: require("./powerCords/OuterIsolatePowerCord"),
    InnerIsolatePowerCord: require("./powerCords/InnerIsolatePowerCord"),
    OuterThreadPowerCord: require("./powerCords/OuterThreadPowerCord"),
    InnerThreadPowerCord: require("./powerCords/InnerThreadPowerCord"),
    RemoteChannelPairPowerCord: require("./powerCords/RemoteChannelPairPowerCord"),
    RemoteChannelPowerCord: require("./powerCords/RemoteChannelPowerCord"),
    SmartRemoteChannelPowerCord:require("./powerCords/SmartRemoteChannelPowerCord"),
    BootScripts: require('./bootScripts'),
    get SSAppPowerCord(){
        const or = require("overwrite-require");
        const browserContexts = [or.constants.BROWSER_ENVIRONMENT_TYPE, or.constants.SERVICE_WORKER_ENVIRONMENT_TYPE, or.constants.WEB_WORKER_ENVIRONMENT_TYPE];
        if (browserContexts.indexOf($$.environmentType) !== -1) {
            return require("./powerCords/browser/SSAppPowerCord");
        }

    }
};


},{"./SwarmEngine":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/swarm-engine/SwarmEngine.js","./bootScripts":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/swarm-engine/bootScripts/index.js","./powerCords/InnerIsolatePowerCord":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/swarm-engine/powerCords/InnerIsolatePowerCord.js","./powerCords/InnerThreadPowerCord":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/swarm-engine/powerCords/InnerThreadPowerCord.js","./powerCords/OuterIsolatePowerCord":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/swarm-engine/powerCords/OuterIsolatePowerCord.js","./powerCords/OuterThreadPowerCord":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/swarm-engine/powerCords/OuterThreadPowerCord.js","./powerCords/RemoteChannelPairPowerCord":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/swarm-engine/powerCords/RemoteChannelPairPowerCord.js","./powerCords/RemoteChannelPowerCord":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/swarm-engine/powerCords/RemoteChannelPowerCord.js","./powerCords/SmartRemoteChannelPowerCord":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/swarm-engine/powerCords/SmartRemoteChannelPowerCord.js","./powerCords/browser/SSAppPowerCord":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/swarm-engine/powerCords/browser/SSAppPowerCord.js","overwrite-require":"overwrite-require"}],"swarmutils":[function(require,module,exports){

let cachedUIDGenerator = undefined;
let cachedSafeUid = undefined;

function initCache(){
    if(cachedUIDGenerator === undefined){
        cachedUIDGenerator = require("./lib/uidGenerator").createUidGenerator(200, 32);
        let  sfuid = require("./lib/safe-uuid");
        sfuid.init(cachedUIDGenerator);
        cachedSafeUid = sfuid.safe_uuid;
    }
}

module.exports = {
    get generateUid(){
        initCache();
        return cachedUIDGenerator.generateUid;
    },
     safe_uuid: function(){
         initCache();
         return cachedSafeUid();
    }
};

module.exports.OwM = require("./lib/OwM");
module.exports.beesHealer = require("./lib/beesHealer");
module.exports.Queue = require("./lib/Queue");
module.exports.combos = require("./lib/Combos");
module.exports.TaskCounter = require("./lib/TaskCounter");
module.exports.SwarmPacker = require("./lib/SwarmPacker");
module.exports.path = require("./lib/path");
module.exports.createPskConsole = function () {
    return require('./lib/pskconsole');
};

module.exports.pingPongFork = require('./lib/pingpongFork');


module.exports.ensureIsBuffer = function (data) {
    if ($$.Buffer.isBuffer(data)) {
        return data;
    }
    let buffer;
    if (ArrayBuffer.isView(data)) {
        buffer = $$.Buffer.from(data.buffer)
    } else {
        buffer = $$.Buffer.from(data);
    }
    return buffer;
}

module.exports.removeDir = require("./lib/removeDir").removeDir;
module.exports.removeDirSync = require("./lib/removeDir").removeDirSync;

},{"./lib/Combos":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/swarmutils/lib/Combos.js","./lib/OwM":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/swarmutils/lib/OwM.js","./lib/Queue":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/swarmutils/lib/Queue.js","./lib/SwarmPacker":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/swarmutils/lib/SwarmPacker.js","./lib/TaskCounter":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/swarmutils/lib/TaskCounter.js","./lib/beesHealer":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/swarmutils/lib/beesHealer.js","./lib/path":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/swarmutils/lib/path.js","./lib/pingpongFork":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/swarmutils/lib/pingpongFork.js","./lib/pskconsole":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/swarmutils/lib/pskconsole.js","./lib/removeDir":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/swarmutils/lib/removeDir.js","./lib/safe-uuid":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/swarmutils/lib/safe-uuid.js","./lib/uidGenerator":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/swarmutils/lib/uidGenerator.js"}],"syndicate":[function(require,module,exports){
const PoolConfig = require('./lib/PoolConfig');
const WorkerPool = require('./lib/WorkerPool');
const WorkerStrategies = require('./lib/WorkerStrategies');

let registry = {};
function registerWorkerStrategy(strategyName, constructor){
    registry[strategyName] = constructor;
}

function getWorkerStrategy(strategyName){
    return registry[strategyName];
}

/**
 * @throws if config is invalid, if config tries to set properties to undefined or add new properties (check PoolConfig to see solutions)
 * @throws if providing a working dir that does not exist, the directory should be created externally
 * @throws if trying to use a strategy that does not exist
 */
function createWorkerPool(poolConfig, workerCreateHelper) {
    const newPoolConfig = PoolConfig.createByOverwritingDefaults(poolConfig);
    /*
    TODO: why do we need to check this here? :-??

    const fs = require('fs');
    const path = require('path');
    if (newPoolConfig.workerOptions && newPoolConfig.workerOptions.cwd && !fs.existsSync(newPoolConfig.workerOptions.cwd)) {
        throw new Error(`The provided working directory does not exists ${config.workingDir}`);
    }*/

    let workerStrategy = getWorkerStrategy(newPoolConfig.workerStrategy);
    if(typeof workerStrategy === "undefined"){
        throw new TypeError(`Could not find a implementation for worker strategy "${newPoolConfig.workerStrategy}"`);
    }

    let concretePool = new workerStrategy(newPoolConfig, workerCreateHelper);

    return new WorkerPool(concretePool);
}

const PoolIsolates = require('./lib/Pool-Isolates');
registerWorkerStrategy(WorkerStrategies.ISOLATES, PoolIsolates);

const PoolThreads = require('./lib/Pool-Threads');
registerWorkerStrategy(WorkerStrategies.THREADS, PoolThreads);

const PoolWebWorkers = require('./lib/Pool-Web-Workers');
registerWorkerStrategy(WorkerStrategies.WEB_WORKERS, PoolWebWorkers);

module.exports = {
    createWorkerPool,
    PoolConfig,
    WorkerStrategies,
    registerWorkerStrategy
};

},{"./lib/Pool-Isolates":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/syndicate/lib/Pool-Isolates.js","./lib/Pool-Threads":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/syndicate/lib/Pool-Threads.js","./lib/Pool-Web-Workers":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/syndicate/lib/Pool-Web-Workers.js","./lib/PoolConfig":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/syndicate/lib/PoolConfig.js","./lib/WorkerPool":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/syndicate/lib/WorkerPool.js","./lib/WorkerStrategies":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/modules/syndicate/lib/WorkerStrategies.js"}]},{},["/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/builds/tmp/testsRuntime.js"])
                    ;(function(global) {
                        global.bundlePaths = {"webshims":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/psknode/bundles/webshims.js","pskruntime":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/psknode/bundles/pskruntime.js","pskWebServer":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/psknode/bundles/pskWebServer.js","consoleTools":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/psknode/bundles/consoleTools.js","blockchain":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/psknode/bundles/blockchain.js","openDSU":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/psknode/bundles/openDSU.js","nodeBoot":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/psknode/bundles/nodeBoot.js","testsRuntime":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/psknode/bundles/testsRuntime.js","bindableModel":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/psknode/bundles/bindableModel.js","loaderBoot":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/psknode/bundles/loaderBoot.js","swBoot":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/psknode/bundles/swBoot.js","iframeBoot":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/psknode/bundles/iframeBoot.js","launcherBoot":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/psknode/bundles/launcherBoot.js","testRunnerBoot":"/home/skutner/WebstormProjects/work/epi-21-02/opendsu-sdk/psknode/bundles/testRunnerBoot.js"};
                    })(typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {});
                